::					Last updated by S. FISBEIN 2/27/89


:	*************************************************************
:	*****        PATCH FILE FOR VERSION 03.01 (TSG/CS)	*****
:	*************************************************************


PATCH(850407,1100,JL,PERR2,,6)
         J         PA1PTR,,
CONPATCH(PERR3+8,,6)
         J         PERR33,,
CONPATCH(PA1PTR,,3A)
         LH        R1,BUFADR,,
         CHI       R1,IEDBIA
         JGE       RMK100,,
WIPEUP   LHI       R9,AA.DBH        :HERE IF ABOUT TO CRASH (CC=F6)
         STH       R9,TERMCD,,      :USE DROPPED BY HOST AS TERMINATION 
         JAL       R9,DDONE,,       :CAUSE, AND CLEAN UP DPORT, SEND DET.
         J         RMK300,,         :CLEAN UP THE RMAKE WORK
PERR33   LH        R1,BUFADR,,
         CHI       R1,IEDBIA
         JGE       WIPEUP           :INSTEAD OF F6 CRASH
         J         PERR3+12,,       :RETURN
ENDPATCH(CLEARS CALL INSTEAD OF CRASHING GATEWAY WITH CC=F6)

:Patch to check the DNIC on calls with CUD routing - PKTOPT (+NONTN) in use.
:Without this patch no checking is performed at all. Hence no distinction is
:made between ODNIC and GATEWAY calls as far as login strings are concerned,
:and invalid DNICs are not detected and cleared.

PATCH(860109,1400,PMJ,PCR430+8,,6)
	J	PCR457,,		: Now go check TRGPF anyway.
ENDPATCH( Check all DNICs if NONTN call )

:  if	X.75
:patch(860627,1800,STF,ESP17+36,,4)
:	JN	ESP17X
:endpatch(do not crash D5 when TNIC list is incorrect)
:  ei	X.75

: ESCALATION 67361 REPORTED BY TNSC
:
: X.25 HOST PLACES A CALL VIA TRANSPARENT LOGIN THRU T-II GATEWAY TO
: A X.25 HOST ON ANOTHER NETWORK.
: WE START TO RECEIVE IIX MESSAGES:
:          04808808082
:          028082
:          06808080838081
:
:   THE MESSAGE 80808082 WILL SET THE TGATE FLAG.
:   BUG: THIS FLAG SHOULDN'T BE SET IF WE ARE USING TRANSPARENT LOGIN THRU
:        T-II GATEWAY.
:   FIX: DENNIS ERNST PLANS TO CHANGE THE LOGIC DESIGN ON THE TGATE. POSSIBLY
:        NOT TO SET FLAG TGATE UNTIL WE RECEIVE 8084 IIX MESSAGE
:        (LOGIN STATUS).
:        THIS PATCH IS TO RESET TGATE IF WE CONTINUE TO RECEIVE 80808083.
:        NSR WILL BE SENT WITH THIS PATCH TO NTD FOR INVESTIGATING.
:        NTD NEEDS TO ACCEPT THIS PATCH OR REWRITE THIS PATCH. THIS IS A
:        REAL BUG ON X.25. HOW TO WRITE A PATCH DEPENDS ON HOW THE
:        IMPLEMENTATION ON THE TGATE FLAG TO BE REDEFINED IN THE NEXT RELEASE.

PATCH(861121,1000,JWANG,GME020+4,,6)
        J       PA1PTR,,
CONPATCH(PA1PTR,,12)
        RBT     R7,TGATE,,      :THIS FLAG MAY BE SET IF 80808082 RECEIVED
                                :IF SO, RESET TGATE NOW.
        LI      0C,808300
        J       GME020+0A,,
ENDPATCH(RESET TGATE IF 80808083 RECEIVED---TII GATEWAY TRANSPARENT LOGIN)

:	This patch fixes the effect of a register corruption, which
:	is in fact crashing the extended DDT. When the SELE command
:	is performed and the RI &/or RO command entered, the interface
:	will crash after a few minutes of display. This is because the
:	ring pointer in R1 is corrupted when it is caught up with NFMI
:	after having looped in the X.SRO or X.SRI routine for a while.
:	The code notes then that the pointer isn't caught up and goes
:	for a read of the ring expecting to find a port number. This 
:	"port number" is used as index for PFILT to check if the port
:	in question is within the filter of the selection peformed by
:	the SELECT command. It generally addresses a memory location 
:	which is out of segment 0, thus causing an ill. mem. ref. .
:	Although the real cause of R1 corruption isn't found yet, it has
:	been established that the crash conditions are : port number
:	just read out of bounds & ring pointer caught up. Therefore,
:	this patch proposes to detect the crash condition and to resume
:	a normal situation as to the ring pointer value, i.e. caught up.

  if	ddtdia
patch(870407,1700,STF,XSROA0+8,,6)
	J	PA1PTR,,
conpatch(PA1PTR,,1C)
	LHL	R3,RING,R1,RR		: get port #
	CLHI	R3,NDPORT		: is it really a port # ?
	JLE	XSROA0+0E,,		: back to source code if so
	LH	R1,NFMI,RR,		: force caught up situation
	J	XSROA4,,		: back to source to assume caught up
conpatch(XSRIA0+8,,6)
	J	PA1PTR,,
conpatch(PA1PTR,,1C)
	LHL	R3,RING,R1,RR		: get port #
	CLHI	R3,NDPORT		: is it really a port # ?
	JLE	XSRIA0+0E,,		: back to source code if so
	LH	R1,NFMI,RR,		: force caught up situation
	J	XSRIA4,,		: back to source to assume caught up
endpatch(avoid crash with RI RO commands in DDT SELECT mode)
  ei	ddtdia

:****************************************************************
:
:	Patch by :		Stephane Fisbein - TSG - MDISI
:	Patch to module :	XCOMPD.F36
:	Version :		3.01
:	Related NSR # :		1059 & 1631 & 2572.
:	Description :
:
:	Sending the Break key while in login mode causes the X
:	interface to crash. This can be avoided by testing if the
:	dispatcher port we are processing is in login mode. If that is
:	the case, then we do not send any message to the ring. This 
:	patch is adapted from Paul Johnson's patch for the same purpose
:	(version 4.03), Henry Rivers's modification in 4.03 and is
:	looking a bit like James Wang's patch for 3.01 but slighly
:	improved (macro call remains intact).

patch(880412,1620,S/FISBEIN,RLEV36-60,,6)
	J	PA1PTR,,
conpatch(PA1PTR,,2E)
	LH	R2,DPORT,,		: get dispatcher port
	TBT	R2,DPLOGN,,		: port in login mode ?
	JN	TDA300,,		: finish if so
	CTLMSG(BRK)			: send ISIS break into the network
	J	RLEV36-4A,,		: back to source
conpatch(RLEV36,,6)
	J	PA1PTR,,
conpatch(PA1PTR,,26)
	TBT	R2,DPLOGN,,		: port in login mode ?
	JN	RLEV37			: go finish if so
	CTLMSG(BRK)			: send ISIS break into the network
RLEV37	J	TDA300,,		: back to source to finish
endpatch(don't send break into the network if port in login mode)
:	This patch is an adaptation from Henry Rivers's work on NSR # 1121 &
:	1120 regarding a general malfunction with the OCB & ICB parameters of
:	the CUGROUP statement that has been encountered by SBC during the 
:	acceptance tests and submitted under a Trouble Report Form. Henry's 
:	work was to make the Closed User Group feature working properly in 
:	full compliance with CCITT's recommendations X.25 & X.300 in the 
:	coming version 4.02 of XCOM. This patch handles the general logic of
:	the OCB & ICB features which are in the Record Teardown Logic and in
:	the Dispatcher Logic excluding the expansion of the PCAC table and the
:	definition of the PREFOC parameter. The XOM module is changed also.

patch(870223,1414,STF/HJR,PCR332-10,,4)
	ST	R0,TEMP2		: mark "CUG" not received
  if    x.25
    if	cugena
conpatch(PCR372+8,,26)

:-------------------------------------------------------------	:HJR 02-02-87
:   temp2+2 ::= 0FFFF, 03, or 09 if had no facil code, CUG facil, or
:   CUG+OA respectively.  Make into 0, 4, or 8, respectively, to create
:   index based on type of facility received.  Then adjust index to
:   account for subscription to pref CUG and to Outgoing Access.

	lis	r12,0
	lh	r2,temp2+2		:get saved facil code
	jlfs	pcr39a			:if none
	ais	r12,4			:since at least cug
	chi	r2,fc.cug		:is it cug?
	jefs	pcr39a			:if yes
	ais	r12,4			:else must be cug/oa

:   Check Pref because it can make a difference even if we have a cug
:   facility in the Call Request.

pcr39a	lb	r4,cup.lt,rl,		:get pref CUG
	jlfs	pcr39b			:skip if dont have one
	ais	r12,1			: else adjust index
pcr39b	tbt	rl,cuo.f		:check if subscr to OA
	J	PA1PTR,,		: continue in patch area 1
conpatch(PA1PTR,,5A)
	jefs	pcr39c			:skip if not
	ais	r12,2			: else adjust index

:   Since we dont have a cug # yet, we can't tell whether outgoing calls
:   are barred within the CUG.  In any case, we may just want to clear
:   the call or send an ordinary call without making the OCB check.

pcr39c	lb	r2,pcr.oc,r12		:jump thru table assuming
	j	pcr.od,r2		: -OCB until we know cug #

pcr39d	tbt	r12,pcrocb		:check for clear or OA
	jnfs	pcr3a1			:if ordinary call
pcr.od
pcr3a0	lhi	r12,dia182		:outgoing access barred
	j	rteca4,,		:go clear the call
pcr3a1	j	pcr400,,		:ordinary call
pcr3a2	lh	r4,temp2,,		:cug
pcr3a3	lhi	r8,ut.cug		:pref
	jfs	pcr39f
pcr3a4	lh	r4,temp2,,		:cug+oa
pcr3a5	lhi	r8,ut.cuo		:pref+oa
pcr39f	lr	r7,rl			:now that we have a cug#
	slls	r7,cug.sc		: check for +/-OCB
	tbt	r4,ocb.f,r7,
	jn	pcr39d			:go do clear ck if +OCB
	j	pcr380,,		:go create cug iix message
: - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
:   Now we can fill in the jump table.  NAD won't allow us to fill in a
:   BC table using addresses which are yet to be defined. ?!?!?!##??
:   Jump table offsets use PCR.OD as their base.
: - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
:
:   PCR.OC is a 12 byte array based on the following chart, which
:   specifies the action to be taken for a CUG facility recieved under
:   various possible combinations of Preferential CUG and/or Outgoing
:   Access subscribed or not subscribed when outgoing calls are not
:   barred within the CUG.  For definition of action see below.  The
:   chart should match Table 24 in X.25-1984 and Figure 4-5 in draft
:   X.301-1986 (which corrects errors in Figure 25 in X.300-1984).
:   
:       ----------------------------------------------------
:       | SUBSC \ FACIL  || NONE     | CUG      | CUGOA    |
:       ====================================================
:       | NONE           || call     | clear    | clear    |
:       ----------------------------------------------------
:       | IA (1)         || clear    | cug      | clear    |
:       ----------------------------------------------------
:       | [IA], PREF     || pref     | cug      | clear    |
:       ----------------------------------------------------
:       | [IA], OA       || call     | cug      | cug+oa   |
:       ----------------------------------------------------
:       | [IA], OA, PREF || pref+oa  | cug+oa   | clear    |
:       ----------------------------------------------------
:	(1) - CUG without any of Pref, IA, or OA is not allowed.
:
: - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
:   
:   PCROCB is a 16 bit array, of which only 12 bits are significant,
:   each of which specifies an action to be taken, clear or ordinary
:   call, when Outgoing Calls are barred within the CUG selected for a
:   call.  The index generated for use with PCR.OC is also used here.
:   
:       ----------------------------------------------------
:       | SUBSC \ FACIL  || NONE     | CUG      | CUGOA    |
:       ====================================================
:       | IA (1)         || clear    | clear    | clear    |
:       ----------------------------------------------------
:       | [IA], PREF     || clear    | clear    | clear    |
:       ----------------------------------------------------
:       | [IA], OA       || call     | clear    | call     |
:       ----------------------------------------------------
:       | [IA], OA, PREF || call     | call     | clear    |
:       ----------------------------------------------------
:   
: - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
:   
:   	The various actions are:
:   
:   	    clear	= clear call with 'outgoing access barred'
:   	    call	= make call without any cug facility
:   	    cug		= make a cug call using the requested cug #
:   	    cug+oa	= make a cug/oa call using requested cug #
:   	    pref	= make a cug call using the preferential cug #
:   	    pref+oa	= make a cug/oa call using preferential cug #
:
: - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
:   NOTE:  the case where we have a cug or cug/oa facility but have no
:   CUG subscription is handled in the CRFAC routine (PCAC30).  The call
:   is cleared.
: - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
pcr.oc	bc	pcr3a0-pcr.od		:clear
	bc	pcr3a3-pcr.od		:pref
	bc	pcr3a1-pcr.od		:ordinary call
	bc	pcr3a5-pcr.od		:pref+oa
	bc	pcr3a2-pcr.od		:cug
	bc	pcr3a2-pcr.od		:cug
	bc	pcr3a2-pcr.od		:cug
	bc	pcr3a4-pcr.od		:cug+oa
	bc	pcr3a0-pcr.od		:clear
	bc	pcr3a0-pcr.od		:clear
	bc	pcr3a4-pcr.od		:cug+oa
	bc	pcr3a0-pcr.od		:clear

pcrocb	hc	3120			:0=clear, 1=ordinary call

:-----------------------------------------------------------------------

conpatch(PCR380+6,,6)
	LHL	R7,CUG.LT,RL,RL		: 
conpatch(PCR380+10,,6)
	L	R7,CUGTAB,R7,R4		: get interlock code
conpatch(PCR385+1A,,4)
	LR	R0,R8			: copy code
	JFS	PCR398			: resume original logic

    ei	cugena
conpatch(PCAC30,,6)
	J	PA1PTR,,
conpatch(PA1PTR,,14)
	SIS	R7,1			: original code
	STH	R0,TEMP2+2,,		: save facility code
	JAL	R4,PICKCH,,		: original code
	J	PCAC30+6,,		: back to source
:-------------------------------------------------------------	:HJR 02-02-87
:
:   Actions in the code should follow the chart below, which specifies
:   the action to be taken for an IIX X.25 CUG utility received under
:   various possible combinations of Preferential CUG and/or Incoming
:   Access subscribed or not subscribed when incoming calls are not
:   barred within the CUG.  For definition of action see below.  The
:   chart should match Table 25 in X.25-1984 and Figure 26 in
:   X.300-1984 except for the one case indicated.
:
:   The case of no utility received is handled in ESP9, the cases of cug
:   and cugoa received are handled below.  For CUG and CUG/OA utilities
:   received each entry describes the action to be taken when there is a
:   match/nomatch of the interlock code received.
:
:       -------------------------------------------------------
:       | SUBSC \ FACIL  || NONE      | CUG       | CUGOA     |
:       =======================================================
:       | NONE           || call      | clear     | call      |
:       -------------------------------------------------------
:       | OA (1)         || clear     | cug/clear | cug/clear |
:       -------------------------------------------------------
:       | [OA], PREF     || clear     | cug/clear | cug/clear |
:       -------------------------------------------------------
:       | [OA], IA       || call      | cug/clear | cug/call (2)
:       -------------------------------------------------------
:       | [OA], IA, PREF || call      | cug/clear | cug/call  |
:       -------------------------------------------------------
:	(1) - CUG without any of Pref, IA, or OA is not allowed.
:       (2) - According to the standard this should be cug+ia/call
:             meaning the Incoming Call facility should be CUG/OA.
:
: - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
:   
:   The following chart describes what action will be taken if the cug
:   selected has incoming calls barred.
:   
:       -------------------------------------------
:       | SUBSC \ FACIL  || CUG       | CUGOA     |
:       ===========================================
:       | OA (1)         || clear     | clear     |
:       -------------------------------------------
:       | [OA], PREF     || clear     | clear     |
:       -------------------------------------------
:       | [OA], IA       || clear     | call      |
:       -------------------------------------------
:       | [OA], IA, PREF || clear     | call      |
:       -------------------------------------------
:   
: - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
:   
:   	The various actions are:
:   
:   	    clear	= clear call with 'outgoing access barred'
:   	    call	= make call without any cug facility
:   	    cug		= make a cug call using the requested cug #
:
:-----------------------------------------------------------------------
conpatch(PUF70+6,,2)
	LR	R6,R0			: save utility code
conpatch(PUF72-0C,,8)
PUF71	CLHI	R6,UT.CUO		: CUG/OA ?
	JN	ESPCLR			: if not, clear the call

    if	cugena
conpatch(PUF72,,2)
	JFS	PUF74
conpatch(PUF76+14,,6)
	J	PA1PTR,,
conpatch(PA1PTR,,16)
	LHI	R12,CACBAR^8!DIA187	: access barred, non existent CUG
PUF77	TBT	RL,CUI.F,,		: check for incoming
	JN	PUF71,,			: if yes, go check for CUG/OA
	J	ESPCLR,,		: go clear the call otherwise
conpatch(PUF78+0A,,6)
	J	PA1PTR,,
conpatch(PA1PTR,,10)
	TBT	R8,ICB.F,R3,		: check if incoming calls barred
	JN	PUF77			: calls barred, check other access
	J	PUF78+14,,		: back to source

    ei	cugena
  ei    x.25
:	This part fixes the XOM OCB related problems.

  if	xom&cugena
conpatch(XMCUI2+30,,2)
	SLLS	RL,CUG.SC+3
conpatch(XMCCUS+26,,6)
	J	PA1PTR,,
conpatch(PA1PTR,,44)
	JAL	R9,XMCSWI,,		: original code

:-------------------------------------------------------------	:HJR 02-02-87
:   Must have at least one of Pref, +INCOMING, or +OUTGOING

XMCCUX	TBT	RL,CUS.F,,		: subscribed?
        JE      XMCUX4                  : ok if not
	TBT	RL,CUI.F,,		: +incoming
        JN      XMCUX4                  : ok if yes
	TBT	RL,CUO.F,,		: +outgoing
        JN      XMCUX4                  : ok if yes
	LB	R1,CUP.LT,RL,		: pref?
	JGEFS	XMCUX4			: ok if yes
	RBT	RL,CUS.F,,		: bad combo, clear subscription
	JFS	CGEXOM			: go issue warning
XMCUX4	J	XOMRSP,,		: issue normal response

:-----------------------------------------------------------------------

CGEXOM	LHI	R6,80		: prepare error code for bad combination
	J	ERRXOM,,	: process error
conpatch(XMCCUP+14,,0E)
	LA	R1,CUP.LT,RL,
	LIS	R3,1
	J	PA1PTR,,
conpatch(PA1PTR,,0A)
	JAL	R4,XMROTM,,
	J	XMCCUX			: check if not bad combination
conpatch(XMCUM2+8,,2)
	SLLS	RL,CUG.SC+3

  ei	xom&cugena
endpatch(fix the OCB & ICB related problems)
::					Last updated by AHM  05/08/87


:	******************************************************
:	*****        PATCH FILE FOR VERSION 03.01        *****
:	******************************************************

:	Refer to (NETMID:39)PATCH.DOC for details on implemen-
:	ting patches with PATCH.LIB.


	RA	0

	SEG	0
	ORG	PA0PTR
	WS	0
PA0PTR	EQ	.		:PUT PATCH AREA ZERO ON WORD BOUNDARY

  IF	1-\PAHPTS
	SEG	A.WTBL
PAHPTS	WC	PATHIS
  EI

	KILL	PATCH
PATCH	macro(day,tim,usr,fba,lba1,len)[
  IF	1-\VERSION
VN EQ	0
  EI
  IF	1-(VERSION&$8100)
VERSION EQ	VERSION!$8100
	SEG	0E
	ORG	VERREV
	BC	VERSION
	SEG	A.CODE
  EI
  IF	PATACT
 REMARK %>>>> ERROR **** Previous PATCH not ended with ENDPATCH <<<<%
  ELSE
PATACT	EQ	1
  EI
 REMARK %%PATCH added on day at tim by usr`.
	SEG	A.ERR
	ORG	PAHPTR
   IF	(PAHPTR+1)-(PATHIS+PHSIZE)
 REMARK %>>>> ERROR **** Too many PATCHs, increase PHSIZE beyond ; NUMBER $0PHSIZE
 REMARK x and reassemble <<<<%
   EI
	WC	$0 day!19000000
	HC	$0 tim
Q	AC	\usr\
Q1	HS
	ORG	Q+$a10	:skip to next history area
PAHPTR	HS
  IF	Q1-.	:IF UNAME>10 CHARARACTERS, CLEAR OVERFLOW
	RE	Q1-.
	BC	0
	ER
  EI
Q1	EQ	(PAHPTR-PATHIS)/$A10
P1P|Q1|	EQ	PA1PTR

QPATS	EQ	((fba)&$00FF0000)^-$010
QPATB	EQ	fba
QPATC	EQ	lba1
  IF	lba1 0
QPATL	EQ	lba1-(fba)
  ELSE
QPATL	EQ	len 2
  EI
  IF	(.NE.(QPATC,0))&(.GT.(QPATB-QPATC+2,0))
 REMARK %>>>> ERROR **** Address of patch end < address of patch start <<<<%
  EI
  IF	QPATB+1-PATCH1	:IF PATCHING IN PATCH1,
   IF	PA1PTR-QPATB+1	: BUT NOT OUTSIDE IT,
    IF	QPATB+1-PA1PTR	:IF NOT PATCHING A PATCH
QPATA	EQ	1	:PATCHING PATCH1 AREA
    EI
    IF	(QPATB+QPATL)-(PATCH1+P1SIZE)	:BUT NO PATCH AREA LEFT
 REMARK %>>>> ERROR  **** PATCH1 area overflow <<<<%
    EI
   EI
  EI
  IF	QPATB+1-PATCH0	:IF PATCHING IN PATCH0,
   IF	PA0PTR-QPATB+1	: BUT NOT OUTSIDE IT,
    IF	QPATB+1-PA0PTR	:IF NOT PATCHING A PATCH
QPATA	EQ	0	:PATCHING PATCH0 AREA
    EI
    IF	(QPATB+QPATL)-(PATCH0+P0SIZE)	:BUT NO PATCH AREA LEFT
 REMARK %>>>> ERROR  **** PATCH0 area overflow <<<<%
    EI
   EI
  EI
  IF	QPATA+1		:IF PATCHING IN PATCH0 OR PATCH1 AREA
 REMARK %	Starts at PATCH; NUMBER $0QPATA; REMARK +
 NUMBER	$0PA|QPATA|PTR-PATCH|QPATA|
 REMARK  and is ; NUMBER $0QPATL; REMARK x bytes long%
  ELSE
 REMARK %     Starts at fba and is 
 NUMBER $0 QPATL
 REMARK x bytes long%
  EI

	SEG	QPATS
	ORG	QPATB
	RE	QPATL
	BC	0
	ER

	ORG	QPATB

::	PATWAR	Warning message for PATCH MACRO
	KILL	PATWAR
PATWAR	macro[
	REMARK	%>>>> WARNING PATCH(day,tim,usr,fba,lba1,len)  %
   ]
 ]


	KILL	CONPAT
CONPAT	macro(cfba,clba1,clen)[
PATACT	EQ	PATACT+1
  IF	2-PATACT
  REMARK %>>>> ERROR **** CONPAT not preceded by a PATCH <<<<%
  EI
  IF	.-(QPATB+QPATL)
	PATWAR
	REMARK               NOT ENDED AT PRESCRIBED LENGTH <<<<%
  EI
  IF	(QPATB+QPATL)-.
	PATWAR
	REMARK               NOT ENDED AT PRESCRIBED LENGTH <<<<%
  EI
  IF	QPATA+1		:IF PATCH WAS A NEW PATCH IN A PATCH AREA
	WS	0	:ALIGN ON WORD BOUNDARY
PA|QPATA|PTR	EQ	.
  EI
QPATA	EQ	-1	:CLEAR FLAG
QPATS	EQ	((cfba)&$00FF0000)^-$010
QPATB	EQ	cfba
QPATC	EQ	clba1
  IF	clba1 0
QPATL	EQ	clba1-(cfba)
  ELSE
QPATL	EQ	clen 2
  EI
  IF	(.NE.(QPATC,0))&(.GT.(QPATB-QPATC+2,0))
 REMARK %>>>> ERROR **** Address of conpatch end < address of conpatch start <<<<%
  EI
  IF	QPATB+1-PATCH1	:IF PATCHING IN PATCH1,
   IF	PA1PTR-QPATB+1	: BUT NOT OUTSIDE IT,
    IF	QPATB+1-PA1PTR	:IF NOT PATCHING A PATCH
QPATA	EQ	1	:PATCHING PATCH1 AREA
    EI
    IF	(QPATB+QPATL)-(PATCH1+P1SIZE)	:BUT NO PATCH AREA LEFT
 REMARK %>>>> ERROR  **** PATCH1 area overflow <<<<%
    EI
   EI
  EI
  IF	QPATB+1-PATCH0	:IF PATCHING IN PATCH0,
   IF	PA0PTR-QPATB+1	: BUT NOT OUTSIDE IT,
    IF	QPATB+1-PA0PTR	:IF NOT PATCHING A PATCH
QPATA	EQ	0	:PATCHING PATCH0 AREA
    EI
    IF	(QPATB+QPATL)-(PATCH0+P0SIZE)	:BUT NO PATCH AREA LEFT
 REMARK %>>>> ERROR  **** PATCH0 area overflow <<<<%
    EI
   EI
  EI
  IF	QPATA+1		:IF PATCHING IN PATCH0 OR PATCH1 AREA
 REMARK 	Continues at PATCH; NUMBER $0QPATA; REMARK +
 NUMBER	$0PA|QPATA|PTR-PATCH|QPATA|
 REMARK  and is ; NUMBER $0QPATL; REMARK x bytes long%
  ELSE
 REMARK 	Continues at cfba and is 
 NUMBER $0 QPATL
 REMARK x bytes long%
  EI
	SEG	QPATS
	ORG	QPATB
	RE	QPATL
	BC	0
	ER

	ORG	QPATB

::	PATWAR	Warning message for CONPATCH MACRO
	KILL	PATWAR
PATWAR	macro[
	REMARK	%>>>>WARNING CONPATCH(cfba,clba1,clen) %
   ]
 ]

	KILL	ENDPATCH
ENDPATCH	macro(c1,c2,c3,c4,c5)[
  IF	PATACT
PATACT	EQ	0
  IF	.-(QPATB+QPATL)
	PATWAR
	REMARK	             NOT ENDED AT PRESCRIBED LENGTH <<<<%
  EI
  IF	(QPATB+QPATL)-.
	PATWAR
	REMARK	             NOT ENDED AT PRESCRIBED LENGTH <<<<%
  EI
  IF	QPATA+1		:IF PATCH WAS IN A PATCH AREA
	WS	0	:ALIGN ON WORD BOUNDARY
PA|QPATA|PTR	EQ	.
  EI
QPATA	EQ	-1	:CLEAR FLAG
	SEG	A.WTBL
	ORG	PAHPTS
	WC	PAHPTR	:reset PAHPTS
	SEG	A.CODE
  EI
 REMARK <<< c1`c2`c3`c4`c5 >>>%
]

:	>>>>>     START PATCHES HERE     <<<<<

:***********************************************************************

PATCH(840605,1500,BPC,PA0PTR,,NDPORT*2)
        GL      NEDLO1
NEDLO1  HS      NDPORT
CONPATCH(NMPNR+14,,6)
        STH     R0,NEDLO1,,
CONPATCH(NDLSAV+12,,6)
        STH     R0,NEDLO1,R1,R1
CONPATCH(ESC350-0C,,6)
        STH     R4,NEDLO1,R7,R7
CONPATCH(ESC365-6,,6)
        STH     R4,NEDLO1,R7,R7
CONPATCH(NEDCLR+10,,6)
	LHL	R0,NEDLO1,R7,R7
   IF TADRS
CONPATCH(NST150+14,,6)
        STH     R0,NEDLO1,R1,R1
   ELSE
CONPATCH(NST150+0C,,6)
        STH     R0,NEDLO1,R1,R1
   EI
CONPATCH(DDN008,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,12)
	STB     R0,LOGTIM,R1,
        STH     R0,NEDLO1,R1,R1
        J       DDN008+6,,
ENDPATCH(cc=14 fix due to LO1 wiped out)

:***********************************************************************
:	Fix handling of PAD restore after login if no reply  was
:	received and remove distinction for calls which reach an
:	X interface.  Patches (850321,1800)
:	and (850331,1800).  DRE

PATCH(850321,1800,DRE,CON040+14,,6)
	J	PA1PTR,,
CONPATCH(PA0PTR,,NIGRPS*2)
PADCHD	HS	NIGRPS		:FLAG FOR CHANGE OF PAD PARAMETERS
CONPATCH(PA1PTR,,2A)
	RBT	R5,PADCHD,,	:WERE THEY REALLY CHANGED?
	JE	CON041+48,,	:NO, THEN SKIP TRYING TO RESTORE THEM
	LB	R0,WFR.NO,R5,	:ARE THERE ANY REMAINING COMANDS OUT THERE
	JN	CON041+48,,	:YES, SKIP THIS PROCESSING
	TBT	R1,ITP.4,,	:is the original state off
	JE	CON041,,	:yes, skip this message
	J	CON040+1E,,	:CONTINUE NORMAL PROCESSING
CONPATCH(PROM45,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,1C)
	SBT	R7,PADCHD,,	:FLAG PAD PARAMS AS CHANGED
	JN	PROM50,,	:ALREADY DID THIS ONCE
	LB	R0,DPRM
	JN	PROM45+1C,,
	J	PROM45+06,,
CONPATCH(IDONE+6,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,12)
	RBT	R1,NEWLOG,,
	RBT	R1,PADCHD,,
	J	IDONE+0C,,
ENDPATCH(Don't not try to restore PAD params if they weren't changed)

:***********************************************************************
:	Fix handling of PAD restore after login if no reply  was
:	received and remove distinction for calls which reach an
:	X interface.  Patches (850321,1800)
:	and (850331,1800).  DRE

PATCH(850331,1800,DRE,CON040+4,,2)
	JFS	CON040+0C
  IF	CENALX
CONPATCH(CON042,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,1A)
	LHL	R1,DPORT
	TBT	R1,TURKEY	:TURKEY CALL ?
	JN	CON050,,	:YES, SKIP CANNED Q-BIT MESSAGES
	LHL	R1,IEDBUF
	LR	R5,R7
	J	CON042+6,,
  EI
ENDPATCH(Restore X3 params for all calls, but don't L1ENABLE turkey calls)

:***********************************************************************
:	PATCH TO GIVE DIAGNOSTIC FIELD IN ALL RESTART INDICATION PACKETS
:	FOR ALL LINKS DECLARED AS DCE [ psadr(03,01) ] IN X.25 AS WELL
:	AS X.75 SLOTS.  SAR NO. PH-XCOM-060.

	IF	X.25
PATCH(850128,1630,PMJ,PSUBB+4,,6)
	J	PA1PTR,,		: JUMP TO PATCH AREA
CONPATCH(PA1PTR,,26)			: 26 OCTETS LONG
	SBT	RL,RMCAUS,,		: INDICATE CAUSE FIELD PRESENCE
	LHI	R0,YRSTRT		: GET RESTART REQUEST
	LB	R9,PADRT,RL,		: GET FRAME ADDR. FOR LINK
	CHI	R9,1			: SEE IF L.O.G DECLARED AS DTE
	JE	PSUBB+0C,,		: IF DTE, GIVE NO DIAGNOSTIC
	SBT	RL,RMDIAG,,		: L.O.G=DCE,GIVE DIAGNOSTIC
	J	PSUBB+0C,,		: JUMP BACK TO SOURCE
ENDPATCH(Give a diagnostic in Restart Ind. for X.25 as well as X.75)
	EI 	X.25

:***********************************************************************
:	The problem of of incorrect calling address in accounting record
:	was due to the LO4 & LO5 being destroyed by the second needle
:	received before the 1st circuit was established.
:	This patch is to allocate two new storage array, LO4TMP & LO5TMP,
:	to store the orig. node # & orig. port # indexed by its DPORT.
:	A permenant fix will redefine LO4 & LO5 to be multiple storage array
:	instead of single storage and be put into next beta release of 3.02
:	and beyond.  SAR No. IT-XCOM-064.

PATCH(850402,1500,SCY,PA0PTR,,NDPORT*4)
LO4TMP	HS	NDPORT		:DEFINE NEW MULTIPLE STORAGE FOR ORIG. NODE #
LO5TMP	HS	NDPORT		:DEFINE NEW MULTIPLE STORAGE FOR ORIG. PORT #
CONPATCH(NDLSAV+38,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,12)
	STH	R0,LO4TMP,R1,R1 :SAVE ORIGINATING NODE # INDEX BY ITS DPORT
	JAL	R4,GETH,,	:GET ORIGINATION HOST #
	J	NDLSAV+3E,,
CONPATCH(NSAV04+18,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,12)
	STH	R0,LO5TMP,R1,R1 :SAVE ORIGINATION PORT # INDEX BY IT DPORT
	JAL	R4,GETH,,	:SKIP THROUGH UNUSED FIELDS
	J	NSAV04+1E,,
CONPATCH(BCLG40+0A,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,22)
	LHL	R6,DPORT
	LHL	R0,LO4TMP,R6,R6	:GET ORIGINATING NODE #
	JAL	R9,GETBCO,,	:CONVERT TO OCTAL
	STH	R2,DTESAX+4,R7,	:PUT NODE # IN SECOND WORD
	LHL	R0,LO5TMP,R6,R6	:GET ORIGINATION PORT #
	J	BCLG40+1E,,
ENDPATCH(Fixed the problem of wrong calling address in accounting record)

:***********************************************************************
:	Fix background handling  associated  with  received  DM.
:	This  introduced  in  version 3.00.  Patch (850418,1200)
:	DRE.

  IF	LAPB
PATCH(850418,1200,DRE,SDSINF,,0C)
	J	PA1PTR,,
	J	SDMXXX,,
CONPATCH(PA1PTR,,1E)
	LIS	R5,XMSUAM
	STB	R5,XSSTAT,RL	:REPLY WITH UA TO DISC
	JFS	SDMXXY
SDMXXX	RBT	RL,REINIT	:DO LINK LEVEL STUFF NOW TO BRING LINK BACK UP
	RBT	RL,BCKFLG
SDMXXY	LIS	R5,0
	STB	R5,XPSTAT,RL	:CLEAR OUT ANY OUTSTANDING REQUESTS
	LIS	R5,PNARM	:SET STATE TO NOT ARMED
	J	SDMINF+08,,
ENDPATCH(Do correct background processing when DM received)
  EI	LAPB

:***********************************************************************
:	The following patch fixes a problem with ASCII dialect hosts.  The
:	symptoms of the problem are 06 crashes due to buffer problems when
:	receiving long files from ASCII idalect hosts such as inter-Ontyme
:	versions of Ontyme.

PATCH(850409,1800,DRE,SNDDR,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,12)
	LHL	1,DPORT
	RBT	R1,EXTWDR,,
	LIS	R0,3
	J	SNDDR+6,,
ENDPATCH(Turn off EXTWDR in ASCII dialect so that backpreasure works)

:***********************************************************************
:	Correct return address  in  gateway  modifying  of  xom.
:	Ontyme N/A, PATCH(850510,1700).  SCHEN 21-MAY-85

  IF	XOM
PATCH(850510,1700,SCHEN,XMCG25,,6)
	LA	R3,XOMRSP,,	:DONE IF DELETE
CONPATCH(XMCG25+6,,4)
	JAL	R1,XMCG21	:TEST IF ADDING/MODIFYING OR DELETING
ENDPATCH(CORRECT RETURN ADDRESS IN GATEWAY MODIFYING OF XOM)
  EI	XOM

:***********************************************************************
:	No ports available if channel    conflict  with  channel
:	range  and  call  clear  if  channel  is within incoming
:	one-way  logical  channel.   Ontyme   A02226,   NSR 101,
:	PATCH(850510,1600) SCHEN 21-MAY-85

PATCH(850510,1600,SCHEN,FXE080+4,,6)
	J PA1PTR,,
CONPATCH(PA1PTR,,4C)
	AR	R2,R4
	STH	R2,EPORT,,	:FORM PORT #
	SH	R2,EPB.LT,RL2,
	AH	R2,LCC.LT,RL2,	:CONVERT TO ELCN
	TBT	RL,AHC.F,,	:ASSIGN HIGH CHANNEL FLAG
	JEFS	FXE085
	CLH	R2,LTC.LT,RL2,	:IF ELCN < LOW TWOWAY CHANNEL
	JL	FXE099,,	:THEN NO PORTS AVAILABLE
	J	FXE080+0A,,	:RETURN
FXE085	LH	R7,HTC.LT,RL2,
	JL	FXE080+0A,,
	CLH	R2,HTC.LT,RL2,	:IF ELCN > HIGH TWOWAY CHANNEL
	JG	FXE099,,	:THEN NO PORTS AVAILABLE
	J	FXE080+0A,,	:RETURN
CONPATCH(RTD150-0A,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,26)
	CH	R4,HIC.LT,RL2,
	JG	RTD150,,	:IF NOT INCOMING ONE-WAY LCN
	LB	R0,PACKET,,	:YES
	CLHI	R0,YCALR
	JN	RTD180,,	:IF NOT CALL REQUEST
	LHI	R13,CLRCAU!DIA034^8
	J	RTD480,,	:CALL CLEAR
ENDPATCH(NO PORTS AVAILABLE IF CHANNEL # CONFLICT WITH CHANNEL RANGE)
ENDPATCH(CALL CLEAR IF CHANNEL # IS WITHIN INCOMING ONE-WAY LOGICAL CHANNEL)

:***********************************************************************
:	Correct the trap at T1S100+14 due to aux circuit timeout
:	in  PVC  building  state.   Added patches to XCOM03.P00,
:	XCOM03.P01, XCOMBK.F37.  NSR   192,  patch(850520,1031).
:	JLiou 23-May-85

  IF	PVC
PATCH(850520,1031,JL,T1S100+10,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,12)
	JN	T1S105,,
	JAL	R4,PVCERR,,	:detach a circuit built for PVC and reschedule
				:a PVC building
	J	T1S020,,
ENDPATCH(FIX  THE PVC TRAP AT T1S100 DUE TO TIMEOUT IN PVC BUILDING STATE)
  EI

:***********************************************************************
:	Restore DPORT to eliminate  type  14  crash  in  routine
:	ESP974.  ESC  88298.  Patch(850529,1500).  SCY 5-29-85

  IF	TPIDS
PATCH(850529,1500,SCY,ESP974+2E,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,10)
	LHL	R3,DPORT
	LB	R3,BAUD,R3,
	J	ESP974+34,,
ENDPATCH(Restore DPORT to eliminate the type 14 crash)
  EI	TPIDS

:***********************************************************************
:	INTERNATIONAL PATCH 018  CREATED BY S/CHOU  AT 29 JUN 84
:	XCOM DOES NOT SEND HPA(HOST PORTS AVAILABILITY) MSG TO
:	SUP. CORRECTLY.  WHEN ALL THE PORTS(DPORT)ARE FULL, XCOM
:	IS SUPPOSED TO SEND HPA FOR EACH HOST TO SUPERVISOR.  YET, IT
:	ONLY SENDS ONE HPA FOR THE HOST THAT USES UP THE LAST PORT.
:	ALSO,WHEN ONE PORT IS RELEASED UNDER THE CONDITION THAT ALL
:	THE PORTS ARE TAKEN, XCOM IS SUPPOSED TO SEND HPA FOR EACH HOST.
:	YET, IT ONLY REPORTS ONE HPA FOR THE HOST THAT IS RELEASED
:	OF THE PORT.  BESIDES, XCOM ONLY NEEDS TO UPDATE THE ANC.HT(
:	ACTIVE CHANNEL)FOR THE HOST THAT CURRENTLY REQUESTS A PORT
:	ASSIGNED.  HOWEVER, XCOM UPDATES THE ANC.HT FOR ALL THE HOSTS.
:	THE BUG IS DUE TO THAT REG. 10 (CONTAIN THE LINK NUMBER) IS
:	NOT UPDATED TO MATCH HOST NUMBER WITHIN THE LOOP.  SO IT
:	CAUSES THE EXIT OF THE LOOP.
:	THE PATCH ONLY UPDATES THE ANC.HT OF THE HOST THAT REQUESTS
:	A PORT TO BE ASSIGNED AND CHECKS THE PORTS AVAILABILITY
:	FOR EVERY HOST.
:	THIS PATCH SHOULD BE INCORPORATED INTO ALL FUTURE RELEASES.
:	NSR 6.
  
PATCH(840629,1500,SCHOU,HPACH0+0C,,06)
        J       PA1PTR,,
CONPATCH(PA1PTR,,1E)
        L       R4,LHST.F,R3,R3         :GET LINK NO. OF HOST
        JE      HPACH0,,                :NO LINK ASSIGNED FOR THIS HOST
        TBT     RL,LHST.F,R3,R3  
        JE      HPACHH,,                :NO LINK MATCH,HOST DOES NOT NEED
                                        :UPDATE ANC.HT
        J       HPACH0+14,,
ENDPATCH(REPORT HPA FOR ALL HOSTS AND UPDATE ANC.HT FOR ONE HOST ONLY)

:***********************************************************************
:	INTERNATIONAL PATCH 010 CREATED BY S/CHOU  AT 09 MAR 84
:	WHEN USER LOGS IN THE XOM OF X I/F,SOME INPUT LENGTHS
:	OF LOGIN STRINGS IN "MODIFY GATEWAY" COMMAND WILL
:	CRASH THE WHOLE SLOT (E.G. NUMBERS BETWEEN 40 AND 79,
:	8000 OR MORE).
:	THIS PATCH SETS THE MAXIMUN LENGTH OF LOGIN STRING TO 36.
:	IT ALSO CHANGES LH AND AH TO LHL AND A TO PREVENT THE SIDE
:	EFFECT OF LH AND AH (PROPAGATING MSB THROUGH HIGH ORDER
:	BYTE-BITS 0:15).
:	THIS PATCH SHOULD BE INCORPORATED INTO ALL FUTURE RELEASE.

     IF   XOM
PATCH(840309,1025,SCHOU,XMCGA6+12,,06)
        J       PA1PTR,,
CONPATCH(PA1PTR,,1E)
        LHL     R1,XOMPAR+6,R9,         :LOAD LENGTH OF STRING TO REG.1
        CLHI    R1,20                   :TEST IF OVER THE MAXIMUM LENGTH
        JG      TOEXOM,,                :TABLE OVERFLOW ERROR
	SR	R1,R0			:SUBTRACT OUT STRING TO ADD
	A	R1,GAFREE,,		:ADD IN LENGTH OF STRING TO ADD
        J       XMCGA6+1E,,
CONPATCH(XMCG15,,06)
        J       PA1PTR,,
CONPATCH(PA1PTR,,22)
        LHL     R0,XOMPAR+6,R9,         :LOAD LENGTH OF STRING TO R0
        CLHI    R0,20                   :TEST IF OVER THE MAXIMUM LENGTH
        JG      TOEXOM,,                :TABLE OVERFLOW ERROR
        LHL     R0,XOMPAR+6,R9,         :LOAD LENGTH OF STRING TO R0
        A       R0,GAFREE,,             :ADD LENGTH OF STRING TO FREE POINTER
        J       XMCG15+0A,,
ENDPATCH(Change LH to LHL  and set maximum length of string to 36)
   EI   XOM

:***********************************************************************
:	Use DPORT to calculate the address of DIBUF.  ESC 92135,
:	PATCH(850603,1620) created by SCY.  SCHEN 06/17/85

PATCH(850603,1620,SCY,MMD060-16,,4)
	LHL	R7,DPORT
ENDPATCH(Use DPORT to calculate the address of DIBUF)

:************************************************************************
:
:	Fix a general malfunction of Fast Select code in conjunction
:	with RCNS option in the dispatcher logic when building the 
:	facilities field in the Incoming Call packet. This patch
:	REPLACES patch (850422,1210,STF,ESP940,,6) provided with 
:	NSR # 116 which was supposed to fix an RCNS problem when fast
:	select code on but not subscribed to. In fact this old patch
:	was inducing another fast select malfunction. Moreover, at 
:	ESP930+4 the code is testing whether fast select facility has been
:	subscribed for this link or not. This test has nothing to do with
:	the fast select acceptance facility which is the only one that
:	needs to be tested in this routine (cf. Red Book, 6.16 & 6.17).
:	Therefore, this patch is just skipping the test with FSS.F (fast
:	select subscription flag) and provides a fix for NSRs # 949 & 950.
:	General deployment of this patch to versions 3.01 and later is
:	highly recommended because it is fixing a major bug in the fast
:	select acceptance facility code.

  if	fstslt
patch(860922,1300,STF,ESP930+4,,2)
	JFS	ESP930+0C	: skip the test with FSS.F
endpatch(fixes all malfunctions involving RCNS and Fast Select Acceptance)
endpatch(facility, no matter Fast Select Subscription.)
  ei	fstslt

:***********************************************************************
:	Keep all packet type on queue when  channel  is  waiting
:	for  reset  confirmation.   PATCH(850617,1100), NSR 219,
:	ESC 89863.  SCHEN 07/30/85

PATCH(850617,1100,BPC,PERR9+08,,4)
        J       RMK100
ENDPATCH(keep all packet type's data on queue)

:***********************************************************************
:	Subtract isis  msg  byte  count  correctly  when  handle
:	national  pad.   PATCH(850726,0120),  NSR 288, ESC 6791.
:	SCHEN 07/30/85

PATCH(850726,0120,BPC,ESD065,,6)
        J       PA1PTR,,
CONPATCH(PA1PTR,,14)
        SBT     R7,QDSCD,,
        SIS     R5,1
        JLE     ESD115,,
        J       ESD070,,
ENDPATCH(substract isis msg byte count correctly when handle national pad) 

:***********************************************************************
:	TPAD  send  proper  message  to  terminal  according  to
:	clearing  or  reset  causes.   PATCH(850730,1400), SCHEN
:	07/31/85

PATCH(850730,1400,SCHEN,TRSE20+20,,4)
	LHL	R1,IPORT
ENDPATCH(TPAD send proper message to terminal according to clearing)
ENDPATCH(or reset causes)

:***********************************************************************
:	Prevent  PVC  bit   arrays   from   being   messed   up.
:	PATCH(850730,1430), SCHEN 07/31/85

 IF	PVC
PATCH(850730,1430,SCHEN,INI145,,4)
	LHI	R8,NEGRPS
ENDPATCH(Prevent PVC bit arrays from being messed up)
 EI	PVC

:***********************************************************************
:	Clear    INPORG    when    process    discard    output.
:	PATCH(850812,1100), ESC 18786, SCHEN 08/20/85

PATCH(850812,1100,SCHEN,L1P8F+12,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,1C)
	LHL	R1,DPORT,,
	RBT	R1,INPROG,,
	LHL	R1,IDBUF,,
	JAL	R4,EMPTY,,
	J	4,R9
ENDPATCH(CLEAR INPROG WHEN PROCESS DISCARD OUTPUT)

:***********************************************************************
:	Fix R3 corruption if TIDS used.  PATCH(850808,1800)  ESC
:	28391, NSR 335 , SCHEN 09/16/85

  IF    TPIDS
PATCH(850808,1800,BPC,CRQ310+26,,6)
        J       PA1PTR,,
CONPATCH(PA1PTR,,10)
        LHL     R3,DPORT
        LB      R3,BAUD,R3,
        J       CRQ310+2C,,
ENDPATCH(R3 corruption if TPIDS used)
  EI

:***********************************************************************
:	Fix  R3  corruption  if  PADOPT   has   XONOF   enabled.
:	PATCH(851029,1700), NSR 244/245, SCHEN 11/08/85

  IF    PDO.|XONOF|
PATCH(851029,1700,BPC,TDA141-6,,6)
        J       PA1PTR,,
CONPATCH(PA1PTR,,14)
        JE      TDA150,,
        ST      R10,PDOTMP,,
        LR      R10,R6
        J       TDA141,,
CONPATCH(TDA142-4,,2)
        SIS     R10,1
CONPATCH(TDA144-4,,2)
        SIS     R10,1
CONPATCH(TDA146,,6)
        J       PA1PTR,,
CONPATCH(PA1PTR,,1C)
        LR      R6,R6
        JN      TDA141,,
        LR      R3,R10
        L       R10,PDOTMP,,
        JAL     R4,BELODR,,
        J       TDA152,,
CONPATCH(PA0PTR,,4)
PDOTMP  WS      1
ENDPATCH(fix R3 corruption if PADOPT has XONOF enabled)
  EI

:***********************************************************************
:	Reset   TNICNT    after    delete    it    fix    cc=D5.
:	PATCH(850827,1500) ESC I36520, NSR 380, SCHEN 09/24/85

  IF  X.75
PATCH(850827,1500,BPC,ADDT40,,6)
        J       PA1PTR,,
CONPATCH(PA1PTR,,20)
        LB      R7,TNICNT,R7,
ADDT48  SIS     R7,1
        JLFS    ADDT49
        JAL     R4,GCI,,
        JBS     ADDT48
ADDT49  LIS     R4,0
        LHL     R7,IPORT
        STB     R4,TNICNT,R7,
        JR      R6
CONPATCH(NIPT88+2,,6)
        J       PA1PTR,,
CONPATCH(PA1PTR,,12)
        AR      R2,R4
        STH     R2,IPORT
        LIS     R4,0
        STB     R4,TNICNT,R2,
        J       4,R3
ENDPATCH(reset TNICNT after delete it fix cc=D5)
  EI

:***********************************************************************
:	Send   c11   d65   if   not   cug    outgoing    access.
:	PATCH(850829,1500) ECS 37994, NSR 381, SCHEN 09/24/85

  IF X.25
PATCH(850829,1500,BPC,PUF72-10,,4)
        LHI     R12,CACBAR^8!DIA065
ENDPATCH(send c11 d65 if not cug outgoing access )
  EI

:***********************************************************************
:	Fix crash cc=14 due to wrong  value  in  r10  if  PADBRE
:	macro used.  PATCH(851002,1600), NSR 417, SCHEN 10/09/85

  IF  \PBCIND
    IF   INFSW1
       PATCH(851002,1600,BPC,DAT080+14,,6)
        NOP     0,0,0,
       ENDPATCH(cc=14 fix due to wrong value in r10)
    ELSE
       PATCH(851002,1600,BPC,DAT080+0E,,6)
        NOP     0,0,0,
       ENDPATCH(cc=14 fix due to wrong value in r10)
    EI
  EI

:***********************************************************************
:	Make sure T1  timer  is  still  on  before  setting  the
:	timeout    occurred    flag.     In    routine    T1TIM.
:	PATCH(851106,1500), NSR 246.  SCY 11/11/85

PATCH(851107,1530,SCY,T1T030+1A,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,2A)
	TBT	R4,T1TA.F,,	:See if timer is still on in frame level
	JE	T1T010,,	:Skip if it gets reset by forground
	SBT	R4,T1TO.F,,	:Set flag on timeout occurred
	TBT	R4,T1TA.F,,	:See if timer is still on in frame level
	JN	T1T010,,	:Yes
	RBT	R4,T1TO.F,,	:Else, T1TA.F gets reset by forground routine
	J	T1T010,,
ENDPATCH(Make sure timer is on before setting the timeout occurred flag)

:***********************************************************************
:	Fix XOM command TCTCSI malfunction.   PATCH(851030,1545)
:	and PATCH(851030,1610).  NSR 463.  SCY 11/11/85

  if	XOM
patch(851030,1545,STF,XOMCS2,,6)
	J	PA1PTR,,
conpatch(PA1PTR,,12)
	LHI	R8,10		: It's 16 and not 15
	MHR	R8,RL		: Index into mapping table
	AIS	R8,1		: Do not read dummy class TC0
	LHI	R2,$A 80	: Rewrite original instruction
	J	XOMCS2+8,,	: Return to source
endpatch(Make sure Q TCTCSI reports the right bytes from TCT.LT table)
endpatch(excluding the dummy class TC0.)

:***********************************************************************
:	Fix XOM command TCTCSI malfunction.   PATCH(851030,1545)
:	and PATCH(851030,1610).  NSR 463.  SCY 11/11/85

patch(851030,1610,STF,XMCTCS+4,,8)
	J	PA1PTR,,
	AIS	R2,1		: Do not modify dummy class TC0
conpatch(PA1PTR,,12)
	JAL	R9,XSUCCS,,	: Rewrite original instruction
	LHI	R2,10		: It's 16 and not 15
	MHR	R2,RL		: Index into mapping table
	J	XMCTCS+0A,,	: Return to source
endpatch(Make sure MOD TCTCSI modifies the right bytes in TCT.LT table)
endpatch(excluding the dummy class TC0.)
  ei	XOM

:***********************************************************************
:	Changed  to  use  CUO.F  bit  array  instead   of   CLHI
:	R8,UT.CUO.   In  routine PUF72.  PATCH(851107,1500), SCY
:	11/11/85

  IF	X.25
PATCH(851107,1500,SCY,PUF72-0C,,8)
	TBT	RL,CUO.F
	JE	ESPCLR		:If no outgoing access, clear the call
   IF	CUGENA
CONPATCH(PUF72+6,,8)    
	TBT	RL,CUO.F	
	JN	PUF80		:Allow calls with outgoing access
   EI	CUGENA
ENDPATCH(Change to use CUO.F bit array)
  EI	X.25

:***********************************************************************

PATCH(850924,1600,DRE,GENRPT,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,14)
	LHL	R1,DPORT
	TBT	R1,DPLOGN,,	:Has the dispatcher port gotten out of login?
	JNR	R9		:return if not
	LIS	R0,ADA.L
	J	GENRPT+6,,
ENDPATCH(disable accounting reports if still logging in)

:***********************************************************************

  IF	PVC
PATCH(850924,1600,DRE,SNDR20+1C,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,18)
	TBT	R2,DPLOGN,,	:Has the dispatcher port gotten out of login?
	JNR	R8		:return if not
	SBT	R2,DFLUSH,,
	LHL	R1,DPORT
	J	SNDR20+24,,
  ELSE
PATCH(850924,1600,DRE,SNDR20+12,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,18)
	TBT	R2,DPLOGN,,	:Has the dispatcher port gotten out of login?
	JNR	R8		:return if not
	SBT	R2,DFLUSH,,
	LHL	R1,DPORT
	J	SNDR20+1A,,
  EI
ENDPATCH(don't send gobbler if still logging in)

:***********************************************************************

PATCH(850924,1600,DRE,SNDC10,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,1C)
	TBT	R1,DPLOGN,,	:Has the dispatcher port gotten out of login?
	JN	SNDC30,,	:No, then don't send garbage to the sup
	TBT	R1,TURKEY	:Do this test which may not be right
	JE	SNDC20,,	:Send text message
	J	SNDC10+08,,	:Send X.25 clear message
ENDPATCH(don't send turkey messages if still logging in)

:***********************************************************************

  IF	X.75
PATCH(850924,1600,DRE,TRI020+2E,,0A)
	LHI	R0,CNETCG^8!DIA115
	STH	R0,PSDIAG,RL,RL		:STORE FOR HANGAL
  ELSE  X.25
PATCH(850924,1600,DRE,TRI020+2E,,6)
	J	PA1PTR,,
CONPATCH(PA0PTR,,4)
PCAU.F	WC	0			:SET NO PERMISSION FOR NON-ZERO CAUSE CODES
CONPATCH(PA1PTR,,2A)
	LB	R0,PCTL2		:GET SAVED CAUSE CODE
	STB	R0,PSDIAG,RL,RL		:PUT IN PROPER PLACE
	JEFS	TRI025			:ZERO IS ALWAYS OK
	THI	R0,80			:IS BIT 8 ON?
	JNFS	TRI025			:ANYTHING WITH THE BIT ON IS OK
	TBT	RL,PCAU.F,,		:DO WE ALLOW NETWORK CAUSE CODES THROUGH?
	JNFS	TRI025			:YES, LET IT GO THROUGH
	LHI	R0,CLOCPE^8!$A081	:SET ERROR TO INPROPER CAUSE CODE
	STH	R0,PSDIAG,RL,RL		:STORE FOR HANGAL
TRI025	J	TRI020+38,,
  EI	X.25
ENDPATCH(Send proper cause code and diag in clears after a restart)

:***********************************************************************
:	Fixed GCI crash caused from an empty FACBUF.  In routine
:	CGTN20.  PATCH(841002,1600,BPC).  NSR 130.  SCY 11/20/85

  IF	CUD.MX!XOM
PATCH(841002,1600,BPC,CGTN20,,6)
        J       PA1PTR,,
CONPATCH(PA1PTR,,16)
        CLHI    R9,0    :SEE IF FACBUF IS EMPTY ?
        JE      CGTN50+6,,      :YES
        LR      R7,R8           :
        NHI     R7,0F           :GET SAVE COUNT
        J       CGTN20+6,,      :CONTINUE HERE
ENDPATCH(don't  bother get username if username count is 0)
  EI

:***********************************************************************
:	Fixed a GCI crash caused from an extra data byte in XCOM
:	dialect  8083  selection  message,  ex,  8081  8083  8D.
:	PATCH(840919,0200,bpc).  NSR 138.  SCY 11/20/85

PATCH(840919,0200,BPC,GME100+0E,,6)
        J       PA1PTR,,
CONPATCH(PA1PTR,,18)
        JAL     R4,EMPTY,,      :EMPTY TEMP STORAGE OF USERNAME
        LHL     R0,LO7,,        :GET BYTE CNT OF REMANING DATA
        JAL     R4,FLUSH,,      :TRASH REST OF MSG
        J       MMFRA,,         :GO TO PROCESS NEXT MSG
ENDPATCH(if xcom dialect 8083 selection msg has extra data, trash it)

:***********************************************************************
:	Fixed the problem that IPORT assigned but not  clean  up
:	IPORT  variables  and  buffers.  PATCH(851107,1300), ESC
:	61016, NSR 489.  SCHEN 12/05/85

PATCH(851107,1300,BPC,NSAV04+4,,6)
        J       PA1PTR,,
CONPATCH(PA1PTR,,12)
        LIS     R4,0
        STH     R4,IPORT
        STH     R0,LO8,R1,R1
        J       NSAV04+0A,,
CONPATCH(NEDCL3,,6)
        J       PA1PTR,,
CONPATCH(PA1PTR,,12)
        JAL     R9,DDONE,,
        JAL     R9,IDONE,,
        J       MMFRA,,
ENDPATCH(zero out IPORT if a needle and clean up if call get cleared)

:***********************************************************************

:	THIS ACCOUNTING PATCH CHARGES THE ADDITIONAL PACKETS RECOMMENDED
:	BY 1984 CCITT. THE NEW ITEMS INCLUDED IN THE SEGMENT COUNTS ARE
:	CALL REQUEST, INTERRUPT REQUEST,AND RESET REQUEST PACKETS.
:	WE COUNT ALL RESET PACKETS IN PACKET AND SEGMENT ACCOUNTING
:	WITH A CAUSE CODE OF 0, 03 AND 05.
:	(00=DTE ORIGINATED, 03=REMOTE PROCEDURE ERROR, 05=LOCAL
:	PROCEDURE ERROR)

PATCH(851121,1440,SCHEN,PA0PTR,,2*NDGRPS)
CHRSEG	HS	NDGRPS		:SET IF CHARGE SEGMENT

CONPATCH(COP+6,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,34)
	RBT	R2,CHRSEG,,
	JE	COP005		:IF NOT CHARGE
	SBT	R2,POCHNG,,	:SET OUTPUT PACKET COUNT CHANGED
	SBT	R2,SOCHNG,,	:SET OUTPUT SEGMENT COUNT CHANGED
	SLLS	R2,2
	LIS	R3,1
	AM	R3,SOCNT,R2,	:UPDATE OUTPUT SEGMENT COUNT
	J	COP010,,
COP005	SBT	R2,POCHNG,,
	SLLS	R2,2
	J	COP010,,
CONPATCH(CIP+6,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,34)
	RBT	R2,CHRSEG,,
	JE	CIP005		:IF NOT CHARGE
	SBT	R2,PICHNG,,	:SET INPUT PACKET COUNT CHANGED
	SBT	R2,SICHNG,,	:SET INPUT SEGMENT COUNT CHANGED
	SLLS	R2,2
	LIS	R3,1
	AM	R3,SICNT,R2,	:UPDATE INPUT SEGMENT COUNT
	J	CIP010,,
CIP005	SBT	R2,PICHNG,,
	SLLS	R2,2
	J	CIP010,,
CONPATCH(CPR-8,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,3C)
	CHI	R0,ZRESET	:CHECK RESET PACKET
	JR	R9		:IF NO
CNR020	LHL	R1,IPORT,,
	LB	R13,PSDIAG,R1,R1
	CHI	R13,RDTERS
	JE	CNR030		:IF DTE CLEAR
	CHI	R13,RREMPE
	JE	CNR030		:IF REMOTE PROCEDURE ERROR
	CHI	R13,RLOCPE
	JEFS	CNR030		:IF LOCAL PROCEDURE ERROR
	JR	R9
CNR030	LHL	R4,DPORT
	SBT	R4,CHRSEG,,
	JAL	R4,COP,,
	JR	R9

CONPATCH(RTRSE+10,,6)
	NOP	0,0,0,
CONPATCH(TRSE05-10,,6)
	J	PA1PTR,,	:PROCESS RESET INDICATION
CONPATCH(PA1PTR,,38)
	STB	R0,PSDIAG,R7,R7	:SAVE CAUSE FIELD
	CHI	R0,RDTERS
	JE	TRSE02		:IF DTE CLEAR
	CHI	R0,RREMPE
	JE	TRSE02		:IF REMOTE PROCEDURE ERROR
	CHI	R0,RLOCPE
	JEFS	TRSE02		:IF LOCAL PROCEDURE ERROR
	J	TRSE05-0A,,	:RETURN
TRSE02	LHL	R4,DPORT
	SBT	R4,CHRSEG,,
	JAL	R4,CIP,,	:UPDTAT INPUT SEGMENT AND PACKET COUNT
	J	TRSE05-0A,,	:RETURN


CONPATCH(CRQ460+30,,6)
	J	PA1PTR,,	:COUNT IN D.P. FOR CALL REQ
CONPATCH(PA1PTR,,1A)
	LHL	R4,DPORT
	SBT	R4,CHRSEG,,
	JAL	R4,COP,,	:COUNT CALL REQ OUTPUT SEGMENT AND PACKET
	L	R1,LIMSAV,,	:RELOAD RETURN ADDRESS
	J	4,R1		:TAKE GOOD RETURN

CONPATCH(ESP990+54,,6)
	J	PA1PTR,,	:COUNT IN D.D. FOR CALL REQ
CONPATCH(PA1PTR,,16)
	LHL	R4,DPORT
	SBT	R4,CHRSEG,,
	JAL	R4,COP,,	:COUNT CALL REQ OUTPUT SEGMENT AND PACKET
	J	MMFRA,,

CONPATCH(ICP040+0E,,2)
	LIS	R0,1
CONPATCH(ICP040+16,,6)
	ST	R0,SICNT,R1,
CONPATCH(ICP040+1C,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,0E)
	LIS	R0,0
	ST	R0,POCNT,R1,
	J	ICP040+22,,

CONPATCH(RTINT+10,,6)
	J	PA1PTR,,	:COUNT INPUT SEG/PKT FOR INTERRUPT PACKET
CONPATCH(PA1PTR,,16)
	LHL	R4,DPORT
	SBT	R4,CHRSEG,,
	JAL	R4,CIP,,
	J	RTINT+16,,

CONPATCH(IBRK30+1E,,6)
	J	PA1PTR,,	:COUNT OUTPUT SEG/PKT FOR INTERRUPT PACKET
CONPATCH(PA1PTR,,16)
	LHL	R4,DPORT
	SBT	R4,CHRSEG,,
	JAL	R4,COP,,
	J	IBRK40,,

CONPATCH(ESPA+18,,6)
	J	PA1PTR,,	:COUNT OUTPUT SEG/PKT FOR INTERRUPT PACKET
CONPATC(PA1PTR,,16)
	LHL	R4,DPORT
	SBT	R4,CHRSEG,,
	JAL	R4,COP,,
	J	MMFRA,,
ENDPATCH(UPDATE SEGMENT AND PACKET COUNTS TO 1984 CCITT STANDARD)


  IF	PVC
:***********************************************************************
:This patch fixes the problem of resets causing gobblers being sent
:while the PVC setup IIX messages are still in transit.  If the
:gobbler catches the setup message, it will be destroyed and the PVC
:will be left in the initializing state.  A similar thing can happen to
:the PVC build acknowledgement (which can also happen to the call
:connect IIX message) that this patch does NOT fix.  No NSR.  DRE 2/6/86
PATCH(860206,1800,DRE,SNDR20+0C,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,1A)
	LIS	R2,PWPVCR					:DRE 6-FEB-86
	CLB	R2,PCKSTE,R1,		:ARE WE IN PVC BUILDING STATE :DRE 6-FEB-86
	JER	R8			:YES, DONT SEND GOBBLER BECAUSE IT WILL :DRE 6-FEB-86
					:INTERFERE WITH THE PVC SETUP MESSAGES  :DRE 6-FEB-86
	LHL	R2,EPORT
	TBT	R2,PVCOUT		:IS OTHER DTE 'DOWN' ??
	JNR	R8			:YES, RETURN
	J	SNDR20+16,,
ENDPATCH(KEEP RESET GOBBLERS FROM DESTROYING PVC SETUP MESSAGES)
  EI	PVC

:***********************************************************************
:This patch prevents RR packets form being queued up for a channel
:in the PVC building state or any of othe other inappropriate states.
: No NSR.  DRE 2/7/86
PATCH(860207,1300,DRE,ICBKG-8,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,20)
	RBT	R1,DFLUSH,,
	LHL	R4,IPORT					:DRE 7-FEB-86
	LB	R0,PCKSTE,R4,		:GET THE STATE OF THE CHANNEL :DRE 7-FEB-86
	CLHI	R0,PSRESC		:IN A NORMAL STATE?	:DRE 7-FEB-86
	JG	MMFRA,,			:NO, SKIP WINDOW UPDATE	:DRE 7-FEB-86
	J	CWROT,,			:GO SEE IF WINDOW NEED TO BE ROTATED
ENDPATCH(DON'T QUEUE UP RR PACKETS IN WRONG STATES)

  IF	PVC
:***********************************************************************
:If the PVC build message contrains a link number that is not set up
:in the PVC link table then it reads a pointer off the end of the
:table and a illegal memory reference occurs.  This patch adds a
:check for correct range of link number in PVC building IIX message.
: No NSR.   DRE 3/3/86.
PATCH(860303,1800,DRE,ESP19+24,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,16)
	CLHI	R0,NLINKS		:IS IT IN RANGE?	:DRE 3-MAR-86
	JGE	ESP198,,		:NO,REPORT ERROR TO OTHER END :DRE 3-MAR-86
	LR	RL,R0			:DEST. LINK NUMBER
	LR	RL2,RL
	SLLS	RL2,1			:FORM *2 FOR NDLST2
	J	ESP19+2A,,
ENDPATCH(CHECK PVC BUILD MESSAGE FOR LINK NUMBER IN RANGE)
  EI	PVC

::Correct a cr/lf echoing problem with half duplex terminals
::NSR 502, SCHEN 03/14/86
PATCH(851126,1201,ISW/MLH,L1P2F+1C,,6)
        J        PA1PTR,,
CONPATCH(PA1PTR,,1C)
	JN	 L1P2I,,	:2 STATEMENTS OVERWRITTEN BY PATCH
        RBT      R8,PAR0,,
        TBT      R8,HLFDUP,,	:TERMINAL SET TO HALF-DUPLEX MODE ?
        JE       L1P2F+24,,     :NO, SAME AS BEFORE
        J        4,R9           :YES, SKIP THE STP MESSAGE, FOR UCC
ENDPATCH(SUPPRESS ECHO-OFF TOWARD TERMINAL SET FOR HALF-DUPLEX MODE.)


:	This patch corrects the problem of calls going to a interface that
:	is out of ports.  The problem was caused by using the 15 second
:	host status reporting cycle used by host cost.  Since running
:	out of ports is an emergency situation, the new status
:	should be reported immediately.  NSR 451  DRE 3/14/86

PATCH(860312,1300,DRE,HPACH7-08,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,20)
	RBT	R6,HPA.FC,,		: ELSE INDICATE WANT HPA(0) SENT :DRE 12-MAR-86
	JE	HPACH0,,		: FINISHED IF ALREADY DONE :DRE 12-MAR-86
	RBT	R6,HPA.FO,,		:INDICATE MESSAGE SENT TO SUP :DRE 12-MAR-86
	JE	HPACH0,,		: DON'T BOTHER SUP IF ALREADY SHUT :DRE 12-MAR-86
	LIS	R4,0			:REPORT HPA(0)		:DRE 12-MAR-86
	J	HPARPT,,
ENDPATCH(SEND HOST SHUT OR PORTS NOT AVAILABLE MESSAGE AS SOON AS IT IS NEEDED)


:	This patch allows zero length packets to be sent over the link.  When
:	zero-length packets are lost, spurious M-bit sequence errors  can occur.
:	Also some hosts may need the zero-length packet (with the M-bit off) to
:	start processing a M-bit sequence.  ESC 30542  DRE 3/19/86

PATCH(860319,1300,DRE,MAKD10+0C,,2)
	LR	R4,R5
CONPATCH(MAKD30+26,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,14)
	STH	R5,RUFCNT,R2,R2		:STORE COUNT
	LR	R5,R5			:TEST R5
	JE	MAKD70,,		:NO DATA, WE ARE DONE
	J	MAKD30+2C,,		:CONTINUE WITH DATA MAKING
CONPATCH(MAKD70+6,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,1A)
	THI	R8,MBIT			:WAS THIS AN MBIT PACKET
	JNFS	MAKD75			:YES, HANDLE DIFFERENTLY
	JAL	R9,APPBKP,,		:NO, CHECK FOR BACKPRESURE
	JR	R7			:RETURN
MAKD75	JAL	R9,APPBKP,,		:CHECK FOR BACKPRESURE NEEDED
	J	MAKDTA,,		:CHECK FOR ANOTHER PACKET
ENDPATCH(KEEP ZERO LENGTH PACKETS FROM BEING LOST)

:	This patch corrects the SIO mother board setup.  The address of the
:	end of the SIO area is not rounded up to the next quad-word.
:	The ISIS code truncates this address when reporting it to
:	the SIO.  Version E and the HDLC micro-engine correctly use
:	the the end value to check for reading a record from outside
:	the designated area.  No NSR .  DRE 3/21/86

  IF	HDLC
PATCH(860321,1000,DRE,INISIO+22,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,12)
	L	R6,SIOTBX,RL2,RL2	:GET SIO AREA END
	AIS	R6,0F			:ROUND UP
	NHI	R6,@0F			:TRUNCATE ADDRESS
	J	INISIO+28,,
ENDPATCH(INITIALIZE SIO PROPERLY FOR HDLC MICRO AND VERSION E PROMS)
  EI	HDLC


:	This patch corrects the test for Reverse Charge Non-Acceptance (RCNA)
:	in CONUP.  The test was made on the reverse charge flag (RVCHRG)
:	which is set if reverse charge is requested.  This flag is set on 
:	calls to and from the link.  The test at CONUP should be made only
:	for calls to the link, becuase calls from the link are already
:	tested against the appropriate flag in RT.   NSR 650 DRE 3/28/86


PATCH(860328,1600,DRE,CONUP+24,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,1C)
	TBT	R1,EXTCAL,,		:CALL FROM THE LINK?
	JN	CON010,,		:YES, THIS ISN'T CORRECT TEST
	TBT	RL,RCNA.F		:REVERSE CHARGING ACCEPTABLE?
	JE	CON010,,		:YES, CONTINUE
	J	CONUP+2C,,		:NO, HANDLE ERROR
ENDPATCH(PERFORM REVERSE CHARGE NON-ACCEPTANCE TEST IN CORRECT DIRECTION)


:	This patch corrects a bug which causes dispatcher crashes whenever
:	a call is cleared in BLDCRQ.  The input ring pointer is garbaged
:	because the code at CRQ302 expects R8 to contain the remaining
:	bytes in the current input record.  R8 is loaded from R5 before
:	doing the error routines, R5 is already used by the prefix handling
:	routines, so we must get the value from DMSGLN.  NSR 650  DRE 3/30/86

PATCH(860330,1300,DRE,CRQ302+6,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,12)
	LB	R0,DMSGLN,R7,		:GET RESIDUAL MESSAGE LENGTH
	JE	CRQ303,,		:ALL DONE WITH MESSAGE
	J	CRQ303-6,,		:CLEAN UP MESSAGE
ENDPATCH(FIX UP IRING DISPATCHER CRASH FROM BAD END OF RECORD LOGIC)

:	These patches correct a problem in setup of two reverse charging
:	error messages.  The routine "OUTCDL" needs to have R3 pointing
:	to a message string it will put out after the "local" or
:	"remote" header.   NSR 650 DRE 4/01/86

PATCH(860401,1600,DRE,CRQ300+2A,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,12)
	LA	R3,CLMSHD,,		:GET ADDRESS OF CALLED CLEARED MESSAGE
	JAL	R6,OUTCDL,,		:OUT PUT MESSAGE AND DIAGNOSTIC
	J	CRQ300+30,,
CONPATCH(CRQ301+1E,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,12)
	LA	R3,CLMSHD,,		:GET ADDRESS OF CALLED CLEARED MESSAGE
	JAL	R6,OUTCDL,,		:OUT PUT MESSAGE AND DIAGNOSTIC
	J	CRQ301+24,,
ENDPATCH(FIX BAD SETUP OF REVERSE CHARGE ERROR MESSAGES)


:	These patches fix a problem that can occur when ISIS
:	backpressure messages arrive during PVC build states.  A
:	check was not made for that state, which caused RR processing
:	to occur before it was legal for the port.  No NSR.  DRE 4/2/86

PATCH(860402,1000,DRE,ICNOS+10,,6)
	J	PA1PTR,,
  IF	PVC
CONPATCH(PA1PTR,,22)
	LHL	R0,DPORT
	SBT	R0,IDBP.F		:SET BACK PRESSURE FLAG
	CLHI	R1,PFLOWC		:IS PORT IN FLOW CONTROL READY STATE
	JL	MMFRA,,			:NOT IN FLOW CONTROL READY STATE
	CLHI	R1,PWPVCR
	JE	MMFRA,,
	J	ICNOS+18,,
  ELSE
CONPATCH(PA1PTR,,18)
	LHL	R0,DPORT
	SBT	R0,IDBP.F		:SET BACK PRESSURE FLAG
	CLHI	R1,PFLOWC		:IS PORT IN FLOW CONTROL READY STATE
	JL	MMFRA,,			:NOT IN FLOW CONTROL READY STATE
	J	ICNOS+18,,
  EI	PVC
ENDPATCH(HANDLE ISIS BACKPRESSURE CORRECTLY IN LOGIN MODE)


  IF	PVC
PATCH(860402,1000,DRE,ICPSN-8,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,16)
	JL	MMFRA,,			:NOT IN FLOW CONTROL READY STATE
	CLHI	R1,PWPVCR
	JE	MMFRA,,
	J	CWROT,,
ENDPATCH(HANDLE ISIS BACKPRESSURE CORRECTLY IN PVC BUILD STATE)
  EI	PVC

PATCH(860402,1000,DRE,RCON20-8,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,18)
	NH	R1,ID.BF,R5		:AND IN DATA IN BUFFER FLAGS
	LHL	R6,IDBP.F,R5		:GET BACKPRESSURE ARRAY
	XHI	R6,0FFFF		:COMPLIMENT IT
	NR	R1,R6			:AND IT AGAINST REQUESTS
	STH	R1,TEMP
	J	RCON20,,
ENDPATCH(OBSERVE BACKPRESSURE IN LOGIN MODE)

:NSR 588 reset bit array while releasing backpressure.
:submitted by Ben Chen on Feb-04-86 updated by Jerry Hsieh on 04/08/86
PATCH(860408,1000,BPC,TCLR25+8,,4)
	RBT	R1,DBKPR
ENDPATCH(RESET DBKPR BIT ARRAY INSTEAD OF TESTING)


:**********************************************************************
:
:	This patch interlocks the SIO routines so that foreground,
:	background and extended DDT will not interact and moves
:	the SIO over-run interrupt monitoring to foreground.

	PATCH(860319,1711,NTD.E/BUELL,PA0PTR,,2)
SIOACT	HC	0			:SIO ACTIVE FLAG

:******************************
	IF	HDLC
	IF	1-FML

	CONPATCH(INIS20-0A,,6)
	J	SIOLK0,,

	CONPATCH(PA1PTR,,18)
SIOLK0	SVC	IO,(FMBIN.^4)+R4	:FORCE SIO INPUT
	J	SL0.5			:SIO FAILURE
	LIS	R5,0			:INDICATE SIO NOT ACTIVE
	STH	R5,SIOACT,,
	JR	R13			:RETURN
SL0.5	J	INIS50,,

:******************************
	CONPATCH(INISIO,,6)
	J	SIOLK1,,

	CONPATCH(PA1PTR,,1E)
SIOLK1	TS	SIOACT,,		:IS SIO ACTIVE
	JEFS	INIS5			:NO
	SVC	DISMIS,0
	J	INISIO,,
INIS5	RBT	RL,SIOFLG,,
	J	INISIO+6,,

	EI	(1-FML)
	EI	HDLC

:******************************
	IF	HDLC&(LAP!LAPB)

	CONPATCH(XROOM1,,6)
	J	SIOLK2,,

	CONPATCH(PA1PTR,,28)
SIOLK2	TS	SIOACT,,		:IS SIO ACTIVE
	JN	SIOLKB,,		:YES
SIOLK9	CLB	RSIP,PREPAG,RL		:NEXT FREE ENTRY POINTER
:	JE	XROOM6,,		:PLENTY OF ROOM
	JN	XROOM1+8,,

SIOLK4	LB	RSIP,PREPAG,RL		:NEXT FREE ENTRY POINTER
	SLLS	RSIP,4			:EXIT WITH THIS SET
	LIS	R0,0			:INDICATE SIO NOT ACTIVE
	STH	R0,SIOACT,,
	J	4,R5

:******************************
	CONPATCH(XROOM2+1C,,6)
	J	PA1PTR,,
	CONPATCH(PA1PTR,,0A)
	STB	RSIP,PSTPAG,RL		:SAVE OLDEST ENTRY
	J	SIOLK9,,


:******************************
	CONPATCH(XROOM5,,6)
	J	SIOLK3,,

	CONPATCH(PA1PTR,,12)
SIOLK3	LIS	R0,0			:INDICATE SIO NOT ACTIVE
	STH	R0,SIOACT,,
SIOLKB	LIS	R0,1
	AHM	R0,NOROOM,RL2,		:COUNT FAILURES
	JR	R5

:******************************
	CONPATCH(XROOM6,,6)
	J	SIOLK4,,

:******************************
	CONPATCH(XBTERM,,6)
	J	SIOLK5,,

	CONPATCH(PA1PTR,,1A)
SIOLK5	TS	SIOACT,,		:IS SIO ACTIVE
	JEFS	SL5.5			:NO
	SVC	DISMIS,0		:WAIT ONE CYCLE
	JBS	SIOLK5
SL5.5	STH	R5,,R6			:STORE BYTE COUNT
	LR	R4,R6
	J	XBTERM+6,,

:******************************
	CONPATCH(TXROMX+12,,6)
	J	SIOLK6,,

	CONPATCH(PA1PTR,,0E)
SIOLK6	AHM	R4,XROOMC,RL2
	LIS	R4,0			:INDICATE SIO NOT ACTIVE
	STH	R4,SIOACT,,
	JR	R0

	EI	(HDLC&(LAP!LAPB))

:******************************
	IF	LAPB!LAP
	IF	HDLC
	CONPATCH(TFG010+8,,6)
	J	SIOLK7,,

	CONPATCH(PA1PTR,,40)
SIOLK7	L	RSIO,SIOTBL,RL2,RL2	:GET SIOTABLE BASE ADDRESS FOR LINE
	LB	R1,SI.INT,RSIO,		:GET INTERRUPT BYTE
	JE	SL7.8			:IF NO INTERRUPT
	SRHLS	R1,4			:INTERRUPT CAUSE
	CLHI	R1,6
	JN	SL7.9			:IF NOT SIO OVER-RUN
	LIS	R1,0
	STB	R1,SI.INT,RSIO,
	LIS	R1,1
	AHM	R1,SIOER2,RL2,
	JAL	R13,INISIO,,		:RE-INITIALIZE SIO FOR LINE *RL*
	L	RSIO,SIOTBL,RL2,RL2	:GET SIOTABLE BASE ADDRESS FOR LINE
SL7.8	J	TFG010+0E,,

SL7.9	TRAP(R1,E0)			:UNRECOVERABLE SIO INTERRUPT

	EI	(HDLC)
	EI	(LAPB!LAP)
:******************************
	IF	HDLC

	CONPATCH(BCK030,,6)
	J	SIOLK8,,

	CONPATCH(PA1PTR,,14)
SIOLK8	LIS	R13,0			:RESET THE SIO LOCK
	STH	R13,SIOACT,,
	JAL	R13,INISIO,,		:INITIALIZE LITTLE BOARD
	J	BCK020,,		:GO SETUP NEXT IPORT

	EI	(HDLC)

:******************************
	IF	HDLC
	IF	1-FML

	CONPATCH(CHKS25,,4)
	J	CHKS10

	EI	(1-FML)
	EI	(HDLC)

:******************************
	IF	LAP!LAPB
	IF	XOM
	IF	HDLC

	IF	LAP
	CONPATCH(TFG5XX+20,,6)
	ELSE
	CONPATCH(TFG5XX+1A,,6)
	EI	(LAP)
	J	SIOLKA,,

	CONPATCH(PA1PTR,,52)
SIOLKA	TS	SIOACT,,		:IS SIO ACTIVE
	JE	SLA.3			:NO
	LIS	R5,5			:MARKING INDICATOR...
	STB	R5,BPSTAT,RL,		: FOR NEXT FG LOOP
	J	TFG100,,

SLA.2	LIS	R5,0			:INDICATE SIO NOT ACTIVE
	STH	R5,SIOACT,,
	J	TFG010,,

SLA.3	LR	R1,RSIO			:COMMAND TABLE BASE ADR FOR LINK
	AHI	R1,MICCW		:COMMAND TO SEND MARKS
	SVC	IO,(FMBOT.^4)+R0
	J	SLA.2			:ERROR RETURN
	SHI	R1,MICCW
	AHI	R1,DICCW		:TURN RTS/DTR OFF
	SVC	IO,(FMBOT.^4)+R0
	J	SLA.2			:ERROR RETURN
	LIS	R5,0			:INDICATE SIO NOT ACTIVE
	STH	R5,SIOACT,,

	IF	LAP
	J	TFG5XX+3E,,
	ELSE
	J	TFG5XX+38,,
	EI	(LAP)

	EI	(HDLC)
	EI	(XOM)
	EI	(LAP!LAPB)

	ENDPATCH(Prevent background SIO from interrupting foreground SIO)


	IF	HDLC&(LAPB!LAP)
:**********************************************************************
:
:	This patch fixes a bug that can occur with transmitted frames.
:	The symptom of this bug is duplicated bytes at the beginning
:	of the frame.  It seems to be especially likely at baud rates
:	above 9600.

	PATCH(860227,2030,NTD.E/BUELL,XBTERM+48,,2)
TXROM1	LIS	R4,0			:IF SO,

	CONPATCH(XBTERM+32,,4)
	JN	TXROM1			:IF NOT

	ENDPATCH(Fix duplicated leading bytes in a frame)

	EI	(HDLC&(LAPB!LAP))

	IF	HCO.MX
:NSR 535 don't increment number of available channels for reporting
:HOSTCOST. submitted by JL on 12/29/85 updated by JH on 4/15/86
PATCH(860415,1000,JL,HCOST5+12,,2)
	JFS	HCOST5+14
ENDPATCH(INSURES HOSTCOST TABLE INDEX DOES NOT OVERFLOW TABLE BOUNDARY)
	EI	(HCO.MX)

: This patch will report the right value of packet window size and/or
: packet size when the throughput calss is negotiated down by a remote
: host.  The value of packet window and packet size are determined by
: throughput class if TCTOPW and TCTOPS are used in the tymfile.
: NSR 534.  SCY 04/15/86

PATCH(850830,0900,JL,PA0PTR,,8)
R7SAVE   BS         4        :REGISTER SAVE AREAS
R9SAVE   BS         4        :         "
CONPATCH(PFAA20+36,,6)
         J         PA1PTR,,
CONPATCH(PA1PTR,,2A)
         STB       R0,TCLTR,R6,       :STORE NEW THROUGHPUT CLASS
         ST        R7,R7SAVE,,
         ST        R9,R9SAVE,,
         JAL       R7,SETTWP,,        :ADJUST PSIZE AND PWIND IF NECESSARY
         L         R7,R7SAVE,,
         L         R9,R9SAVE,,
         J         PFAA20+3C,,
ENDPATCH(DOES TC TO PW AND TC TO PS MAPPING AFTER CALL ACCEPT IIX MESSAGE)

: Packet size determined by throughput class (macro TCTOPS).
: The value of packet size is stored in the table TTS.LT which
: is 16 halfword values per link.
: R9 which contains the transmit/receive value of throughput class
: should be changed to halfword index in order to get the right
: value of packet size in TTS.LT.  No NSR, SCY 04/16/86

  IF	TCPS
PATCH(860415,1600,SCY,TWP030+0E,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,0E)
	SLLS	R9,1			:MAKE INTO HALFWORD INDEX
	LHL	R3,TTS.LT,R4,R9
	J	TWP030+14,,
CONPATCH(TWP045+0C,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,0E)
	SLLS	R9,1			:MAKE INTO HALFWORD INDEX
	LHL	R4,TTS.LT,R4,R9
	J	TWP045+12,,
ENDPATCH(Fix the wrong index pointer into TTS.LT)
  EI	TCPS
:Fixed ill mem ref when using xom to update LOGINTERVAL timer
:LIN.LT LOGINTERVAL timer is located in RTBL therefore when
:using xom to modify timer value will crash slot with CC 14.
:Routine LOGRT3 should jump to XMROTM to change MAC MASK
:and restore new value.  NSR 670, SCHEN 04/15/86
 if xom
patch(860326,1600,bpc,logrt3,,6)
        j       pa1ptr,,
conpatch(pa1ptr,,16)
        la      r1,lin.lt,rl,rl
        lis     r3,2
        lr      r0,r6
        jal     r4,xmrotm,,
        j       logrt3+6,,
endpatch(cc=14 fix due to LIN.LT couldn't allow to be modified)
 ei

:	This patch fixes a problem which caused a crash while
:	processing zero-length Q-BIT messages by the HPAD/TPAD.
:	The code assumed that a Q-BIT message will always have data.
:	No NSR.  DRE 20-APR-86


PATCH(860420,1000,DRE,RTLEV1,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,1A)
	LR	R6,R6			:GOT A 0-LENGTH Q-BIT PACKET? :DRE 21-APR-86
	JE	TDA300,,		:YES, RETURN TO DATA TEARDOWN :DRE 21-APR-86
	JAL	R4,PICKCH,,		:GET TYPE OF Q-BIT PACKET
  IF	PADTRC
	JAL	R4,X3TMSG,,		:X3 TRACE, MESSAGE CODE ENTRY
	J	RTLEV1+0A,,
  ELSE
	LHL	R7,IPORT,,		:INTERNAL PORT #
	J	RTLEV1+8,,
  EI	PADTRC
ENDPATCH(HANDLE ZERO-LENGTH Q-BIT MESSAGES IN TPAD MODE)


:	This patch fixes a problem in the link level timer recovery
:	state.  The timer which caused the retransmission of data
:	packets (or RR Poll) was being turned off by an ack which
:	acknowledged all outstanding packets but didn't have the
:	final bit on.  No NSR.  DRE 18-APR-86

PATCH(860418,1000,DRE,ANR070-8,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,10)
	THI	R12,CT.NIF		:SEE IF THIS IS AN I-FRAME
	JE	ANR100,,		:IF SO
	J	ANR070+20,,		:RESTART TIMER IN RECOVERY :DRE 18-APR-86
CONPATCH(ANR100+0E,,4)
	JN	ANR070+20		:RESTART TIMER, IF ALL FRAMES OUT WERE NOT ACKED
CONPATCH(ANR110+4,,4)
	J	ANR070+20		:RESTART TIMER
ENDPATCH(KEEP RETRANSMISSION TIMER FROM BEING TURNED OFF INCORRECTLY)


:	This patch fixes a problem with the Final bit response to
:	a packet with the poll bit set.  The Final bit for
:	a response would be cleared if a non-Polled frame arrived
:	after the frame with the Poll bit and was processed in
:	the same foreground cycle.  This condition is probably a
:	protocol violation and shouldn't occur, but we should be prepared.
:	No NSR.   DRE  21-APR-86

  IF	HDLC&(LAPB!LAP)
PATCH(860421,1000,DRE,RFG240,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,14)
	STH	R2,RINDEX,RL2
	TBT	RL,PFBIT		:IS A FINAL RESPONSE NECESSARY
	JN	RFG100+0E,,		:YES, SKIP REST OF BUFFER
	J	RFG100,,		:NO, CONTINUE
ENDPATCH(PRESERVE THE FINAL BIT WHEN PROCESSING MULTIPLE FRAMES)
  EI	HDLC&(LAPB!LAP)

:This patch fixes the problem with XOM command 87 and 88.
:NSR 441   John Liou  4/22/86

  IF 	XOM
PATCH(860422,1700,JLIOU,XADL02+1A,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,1C)
	LHL	R3,XOMPAR+6,,		:INDEX OF ENTRY
	JE	NEEXOM,,		:IF INVALID ENTRY
	LB	R0,XOMNPS,,		:GET # OF PARAMETER ENTERED
	CLHI	R0,4			:SEE IF ENOUGH PARAMETERS
	J	XADL02+22,,
ENDPATCH(CHECK THE INDEX IF XOM COMMAND "88" IS USED TO REMOVE OR DELETE)
  EI	XOM


: These patches fix logical channel problems associated with XOM command
: 5E, 5F, and 60.   The original patches were developed by TNSC.  NSR 549
: 5/6/86   John Liou
: The last part of this patch which initializes the NEC.LT has been modified
: because the segment 7 is a write protection area   05/06/87  AHM


  IF	XOM
patch(860102,1720,STF,PA0PTR,,4)
EPAXOM  WC      0               : To differenciate caller of subroutine
conpatch(XMCIC6+1A,,6)
        J       XMCEPA,,
conpatch(XMCTC7+1A,,6)
        J       XMCEPA,,
conpatch(XMCOC6+16,,6)
        J       XMOEPA,,
conpatch(PA1PTR,,32)
XMCEPA  JAL     R9,XMSTNC,,     : original code
        JFS     XMEPIN
XMOEPA  JAL     R4,XMROTM,,     : original code
XMEPIN  ST      R5,TEMP,,       : save R5
        ST      R6,TEMP1,,      : save R6
        ST      R7,TEMP2,,      : save R7
        LR      RL2,RL
        AR      RL2,RL          : twice link #
        LIS     R5,1            : indicate caller is XOM
        STH     R5,EPAXOM,,
        J       INI155+16,,     : go reinitialize EPA.F
conpatch(INI210,,6)
        J       PA1PTR,,        : return from subroutine if no ICNL
conpatch(PA1PTR,,0E)
        LH      R6,HIC.LT,RL2,  : original code
        JLFS    INI240          : check caller of subroutine if no ICNL
        J       INI210+0A,,     : otherwise resume execution of subroutine
conpatch(INI230+08,,6)
        J       PA1PTR,,        : it is time to return from subroutine
conpatch(PA1PTR,,32)
        JGE     INI230,,        : original code
INI240  LHL     R5,EPAXOM,,     : is caller INIT routine ?
        JE      INI155,,        : back to source then
        LIS     R5,0
        STH     R5,EPAXOM,,     : reset this flag
        L       R5,TEMP,,       : restore R5
        L       R6,TEMP1,,      : restore R6
        L       R7,TEMP2,,      : restore R7
        J       XOMRSP,,        : back to source now
endpatch(don't forget to update EPA.F after modifying TCNL, ICNL or OCNL)

 
patch(870506,1050,STF/AHM,XMCIC6+8,,6)
        JAL     R4,XMINEC,,
conpatch(XMCTC7+8,,6)
        JAL     R4,XMTNEC,,
conpatch(XMCOC6+8,,6)
        JAL     R4,XMONEC,,
conpatch(PA1PTR,,60)
XMINEC  LH      R3,HIC.LT,RL,RL : did we have any ICNL before ?
        JFS     XMNEC1          : continue in common routine anyway
XMTNEC  LH      R3,HTC.LT,RL,RL : did we have any TCNL before ?
        JFS     XMNEC1          : continue in common routine anyway
XMONEC  LH      R3,HOC.LT,RL,RL : did we have any OCNL before ?
XMNEC1  JL      XMNEC5          : jump if not
        LHR     R0,R12          : did we change the range and set a new one ?
        JL      XMNEC6          : jump if not
        SR      R0,R11          : calculate new range
XMNEC2  AH      R0,,R1          : add lower channel # of old range
        SR      R0,R3           : - higher channel # of old range
XMNEC3  AH      R0,NEC.LT,RL,RL : update max # of allowed channels to use
	LR	R6,R1		: save original value
	LA	R1,NEC.LT,RL,RL :
	LIS	R3,2
	LR	R5,R4		: save original return address
	JAL	R4,XMROTM,,	: 
	LR	R4,R5		: restore original return address
	LR	R1,R6		: 
XMNEC4  LR      R0,R11          : restore R0
        LIS     R3,2            : rewrite original code
        J       XMROTM,,        : resume original  logic
XMNEC5  LHR     R0,R12          : did we set a new range
        JLBS    XMNEC4          : do nothing and return if not
        AIS     R0,1            : calculate new range
        SR      R0,R11          : 
        J       XMNEC3          : go update NEC.LT
XMNEC6  LCS     R0,1            : calculate old range to deduct from NEC.LT
        J       XMNEC2          :

: 
: The following is modified at 05/06/87 
:
  IF	PVC
conpatch(INI410+26,,6)
        J       PA1PTR,,
conpatch(PA1PTR,,2C)
	JE	INI430,,
	JG	INI420
	J	INI410+2E,,
INI420	LIS	R0,1
	AH	R0,NEC.LT,RL,RL		:UPDATE MAX #  OF CHANNEL TO USE
	LA	R1,NEC.LT,RL,RL		:GET ADDRESS TO MODIFY
	LIS	R3,2			:GET TYPE TO MODIFY
	JAL	R4,XMROTM,,		:MODIFY NEC.LT
	J	INI410,,
  EI	PVC
 
endpatch(Update max # of channels to use when modifying TCNL, ICNL or)
endpatch(OCNL with XOM, and initialize it properly with the number of )
endpatch(PVC destinations)
 
  EI	XOM

:	This patch disables the incorrect checking for the
:	idle line condition in CHKSIO which should only check
:	for loss of clock.
:	esc #51721.  DRE 12-MAY-86

  IF	HDLC&(1-FML)
PATCH(860512,1000,DRE,CHKS10+26,,4)
	NHI	R1,5			:MASK OFF UNTESTED BITS
ENDPATCH(DISABLE CHECKING FOR IDLE LINE CONDITION IN CHKSIO)
  EI

:MBIT2.301 - SETS M-BIT IF PACKET FULL BUT NO DATA FORWARDING CHARACTER
:  DOES NOT SET M BIT IF - DATA FORWARDING PARAMETER IS 0 OR IF CALL
:  FROM HPAD OR AUX CIRCUIT OR IIX CALL
:  NSR 452. SCY 05/12/86

PATCH(860514,1200,MLH/SCY,PA0PTR,,2*NDGRPS*2)
MBITFL   HS	NDGRPS		        :FLAG IF M-BIT NEEDED
NOMBFL	 HS	NDGRPS			:FLAG M-BIT NOT WANTED
CONPATCH(DAT220+4,,6)
         J         PA1PTR,,             :IS PACKET FULL AND NO LINEFEED?
CONPATCH(MVDIIE+4A,,6)
         J         SMBTFL,,            :SET MBIT IN FLAG IN DI BUFFER
CONPATCH(ICPSN+8,,6)
         J         ICP005,,            :HERE IF HPAD CALL
CONPATCH(NSAV04+30,,6)
         J         IFIIX,,             :CHECK IF IIX CALL
CONPATCH(NSAV10+4,,6)
         J         IFAUX,,             :IS IT AUX CIRCUIT
CONPATCH(DDONE+2E,,6)
         J         RSTHPD,,
CONPATCH(PA1PTR,,0CA)
         LR        R1,R7               :SAVE COPY OF XMIT MASK
         JE        DAT220+0A,,         :VALUE = 0, NO M-BIT 
         LHL       R7,PSTMT,R4,R4      :TRANSMIT PACKET SIZE
         LR        R6,R6               :WAS PACKET FULL?
         JN        DAT220+0A,,         :NO, ENDED IN DATA FRWRD CHAR
         LB        R2,XMTASC,R8,       :PACKET FULL, DID IT END IN 
         NR        R2,R1               :  DATA FORWARDING CHARACTER?
         JN        DAT220+0A,,         :YES, NO NEED FOR M-BIT 
         LHL       R2,DPORT,,          :NO, PICK UP DPORT TO SET
         TBT       R2,NOMBFL,,         :IS CALL FROM HPAD?
         JN        DAT223              :YES, DON'T FLAG M-BIT CONDITION
         SBT       R2,MBITFL,,         :FLAG THAT WE NEED TO SET M-BIT
DAT223   LHL       R7,PSTMT,R4,R4      :RESTORE TRANSMIT PACKET SIZE 
         J         DAT220+0A,,         :AND RETURN
:
SMBTFL   LHL       R4,DPORT,,          :GET DPORT NUMBER
         RBT       R4,MBITFL,,         :M-BIT SPECIAL CONDITION PRESENT?
         JE        SMBT1               :NO, RETURN
         LIS       R0,MBIT             :SET THE M-BIT
         J         SMBT1A
SMBT1    LIS       R0,0                :NO M-BIT OR Q-BIT   
SMBT1A   JAL       R4,WCI,,            :PUT FLAG IN BUFFER
         J         MVDIIE+50,,         :RETURN
:
IFIIX    NHI       R0,IX.HIQ
         JE        NSAV10,,	       :NOT IIX
         SBT       R7,IIXCAL,,
         SBT       R7,NOMBFL,,         :M BIT NOT WANTED
         J         NSAV10,,            :RETURN
:
IFAUX    STB       R0,ORGTID,R1,       :STORE CCT (TID)
         LR        R0,R0               :IF 0, AUX CIRCUIT
         JN        NSAV10+0A,,         :NO AUX CIRCUIT
         SBT       R7,NOMBFL,,         :M BIT NOT WANTED   
         J         NSAV10+0A,,         :RETURN
:
ICP005   JAL       R4,GETH,,
         SBT       R1,NOMBFL,,         :FLAG AN HPAD CALL
         J         ICPSN+0E,,
:
RSTHPD   RBT       R1,NOMBFL,,         :RESET HPAD CALL FLAG
	 RBT	   R1,MBITFL,,
         RBT       R1,WIBMCA,,
         J         DDONE+34,,
ENDPATCH(SETS M-BIT FOR FULL PACKET NOT ENDING IN DATA FORWARD CHAR)


:	This patch sends detaches for dispatcher ports in data mode
:	and zappers for dispatcher ports in login mode.
:	The distinction is only important for MXP systems.

PATCH(860629,1000,DRE,DDN020+0C,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,3A)
	SBT	R1,DPLOGN		:INHIBIT REPORTING OF ACCOUNTING
	JNFS	DDN030			:ZAP CIRCUIT IF STILL TALKING TO SUP
:	SEND DETACH MESSAGE TO DISPATCHER.
	CTLMSB(DET,RX3)
	JFS	DDN040
:	SEND ZAP MESSAGE TO DISPATCHER.
DDN030	CTLMSB(ZAP,RX3)
DDN040	J	DDN020+26,,
ENDPATCH(SEND ZAPPER IF DISPATCHER PORT STILL IN LOGIN MODE)

:	THIS PATCH UPDATES THE THROUGHPUT TO TID MAPPING TABLES

PATCH(070286,1900,DRE,TCLTID,,10)
:TPUT CLASS TO TYMNET TID (INDEXED BY TPUT CLASS)
:		0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
TCLTID	BC	0CA,0CA,0CA,0CA,0C5,0C1,0CC,0CC,0D0,0D3,0D4,0D4,0D4,0D4,0D4,0D4
ENDPATCH(UPDATE THROUGHPUT TO TID MAPPING TABLES)


:	This patch fixes the reporting of zero hosts to the sup

PATCH(860703,1300,DRE,CHSTAT,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,1A)
	LIS	R1,0
	STB	R1,NMHNAS,R6,		:CLEAR OUT LAST ERROR RECEIVED
	LR	R13,R13			:TEST HOST NUMBER
	JLER	R5			:RETURN IF ZERO ( OR > 32K)
	CLI	R13,0FFFF
	JER	R5			:RETURN IF 0FFFF
	J	CHSTAT+8,,
ENDPATCH(DON'T REPORT HOST ZERO OR 0FFFF)


 IF	HCO.MX
PATCH(860703,1400,DRE,RHCOST,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,1C)
	LH	R0,HOSTS,R6,R6		:GET HOST NUMBER
	JER	R7			:FINISHED IF HOST ZERO
	CLI	R0,0FFFF		:IS IT 0FFFF?
	JER	R7			:YES, ANOTHER UNDEFINED HOST
	LIS	R0,RHC.L		:LENGTH OF HOST COST MESSAGE
	LIS	R1,0	
	LIS	R2,NM.RHC		:LOAD UP MESSAGE CODE
	J	RHCOST+6,,
ENDPATCH(DON'T SEND HOST COST IN FOR UNASSIGNED HOST)
  EI

PATCH(860703,1400,DRE,HPARPT,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,26)
	LH	R13,HOSTS,R6,R6		:GET HOST NUMBER
	JE	HPACH0,,		:DON'T REPORT HOST ZERO
	CLI	R13,0FFFF		:COMPARE WITH OTERH UNKNOWN HOST
	JE	HPACH0,,		:DON'T REPORT UNKNOWN HOST
	STH	R4,TEMP3+2
	STH	R5,TEMP3
	J	HPARPT+8,,
ENDPATCH(DON'T SEND HOST PORT AVAILABILITY IN FOR UNASSIGNED HOST)


:	This patch corrects the calculation of host cost in the 
:	presense of PVCs.

  IF	PVC&HCO.MX
PATCH(860709,1100,DRE,HCOST0+0E,,4)
	LHI	R1,MAXPRT-XOM-((PVCLOG-PVCTAB)/10) :GET NUMBER OF PORTS AVAIL FOR SVCS
ENDPATCH(CALCULATE DPORTS AVAILABLE FOR SVCS CORRECTLY WHEN THERE ARE PVCS)
  EI	PVC&HCO.MX

:
: PATCH FOR VBERSION 3.01
:
: 
: PROBLEM: IPORT ASSIGNED OUT OF RANGE
: CAUSE  : USER LOGIN TO X.25 AND GET A '+' PROMPT FOR CALL USER DATA
:          IF USER ENTER CUD NOT CORRECTLY, USER IS ASKED TO RE-ENTER
:          THE CODE LIM500 WILL THEN DECREASE THE APORTS AND CLEAN THE IE.MT
:          AND EI.MT AND EPA.F. IF USER ENTER CUD NOT CORRECTLY AGAIN,
:          SAME CLEAN-UP PROCEDURE IS REPEATED!! CONSEQUENTLY, IT GETS
:          EPORT VALUE OF 'FF' FROM IE.MT AND SET BIT TO THE LAST BIT OF
:          IPA.F INSTAED OF EPA.F. THIS BUG CAUSES THE VALUE IN APORTS TO BE
:	   OUT OF SYNC WITH THE ACTUAL NUMBER OF PORTS ASSIGNED, AND EVENTUALLY
:          ASSIGNS AN IPORT OUTSIDE THE RANGE WHEN THE USER REACHES
:          THE MAX NUMBER OF USERS.
: PATCH  : SKIP CLEAN-UP AFTER NDLERR
PATCH(870119,1500,DRE,LIM500+22,,04)
        J       MMFRA
ENDPATCH(SKIP CLEANING IE.MT EI.MT AND NOT DECREASE APORTS)
ENDPATCH(IF USER ENTER CALL USER DATA NOT CORRECTLY AGAIN FOR '+')



:**************************************
:************************
:**************
:	Patch to module: XCOMOM.F31
:	Change label   :
:       Patch by:        AMA
:       NSR number:      969
:	version:         3.01
:	Description: 
:	XOM could be used to midify the Incoming, Two-way, and Outgoing
:	logical channel ranges while the packet level was up but would
:	re-initialize all the EPORT available bits without regard to 
:	current channel activity.  Fix so that if the packet level state
:	on the specified link is not down the operation is abort (error 0A).

  if	xom
patch(870319,1630,AMA,XMCICN+2,,2)
	LIS	R1,XMPKDO	: packet level down required
conpatch(XMCTCN+2,,2)
	LIS	R1,XMPKDO	: packet level down required
conpatch(XMCOCN+2,,2)
	LIS	R1,XMPKDO	: packet level down required
endpatch(NSR969 -- Packet level has to be down to modify the LCN range)
  ei	xom
:**************************************
:************************
:**************
:	Patch to module: XCOMPD.F31
:	Change label   :
:       Patch by:        HRIVERS
:       NSR number:      1059
:	version:         3.01
:	Description: 
:	With ISIS version 7.00, a Break (AE) message in the 'ORING' will
:	cause a dispatcher crash if the dispatcher port with the message
:	is Login Mode.  Changed to ignore X.29 Indication of Break from
:	the link if the associated 'Dport' is in Login Mode.

zzz	eq	0
  if	padtrc
zzz	eq	zzz+0C
  ei
patch(861122,1900,HRIVERS,rlev34+44+zzz,,6)
	j	pa1ptr,,
conpatch(pa1ptr,,2C)
	x29msd(x29.2,x3.8,0)	:have to send message out
:-----------------------------------------------------------	HJR 11-22-86
	tbt	r2,dplogn	:are we in Login Mode?
	jn	tda300,,	:if yes, then done
:-----------------------------------------------------------------------
	j	rlev34+60+zzz,,	:return to ctlmsg(brk)
conpatch(rlev36,,6)
	j	rlev37,,
zzz	eq	26
  if	.ne.(deflag,0)
zzz	eq	zzz+16
  ei
conpatch(pa1ptr,,zzz)
:-----------------------------------------------------------	HJR 11-22-86
rlev37	tbt	r2,dplogn	:are we in Login Mode?
	jn	tda300,,	:if yes, then done
:-----------------------------------------------------------------------
	ctlmsg(brk)		:else brk msg to oring
	j	tda300,,	:return
  kill zzz
endpatch(NSR1059 -- no Brk msg if X.29 Ind of Break from link in Login Mode)
:**************************************
:************************
:**************
:	Patch to module: XCOMFG.F31
:	Change label   :
:       Patch by:        HRIVERS
:       NSR number:      833
:	version:         3.01
:	Description: 
:       Claim is that FG will return receive sectors being processed by
:       background.  Nothing turned up in analysis.  Put in trap for this
:       occuring - RTD.FG set but no sectors in RSC.RT.

  if	lapb
patch(861212,1700,HRIVERS,rfg004+0C,,6)
	j	pa1ptr,,
conpatch(pa1ptr,,10)
	lh	r4,rsc.rt,r2,r2		:get head of returning chain
	jge	rfg004+12,,		:it's there, continue
	trap(r4,0FF)			:else die sucker!!
endpatch(NSR833 -- Trap return of empty sector queue to FG)
  ei
:**************************************
:************************
:**************
:	Patch to module: XCOMOM.F31
:	Change label   :
:       Patch by:        HRIVERS (HMA)
:       NSR number:      947
:	version:         3.01
:	Description: 
:       The XOM user could modify the current preferential CUG as long as it
:       was less than "CUG.MX" even though the new CUG index had no
:       interlock code assigned to it.  Changed so that lack of interlock
:       code for the new index causes an error 42x to be returned to the XOM
:       user.  Also made out of range error jump consistent with other CUG
:       out of range error jumps.

  if	xom*cugena
patch(861024,1430,HRIVERS,xmccup+0C,,6)
	j	pa1ptr,,
conpatch(pa1ptr,,36)
: NOTE: RX3 conditional jumps should be RX1 in code
	jl	xmcup1			:skip checks if -1	:HJR 10-24-86
	CLHI	R0,CUG.MX
	JG	CUEXOM,,		:JUMP IF OUT OF RANGE	:HJR 10-24-86
:--------------------------------------------------------------	:HJR 10-24-86
	lhl	r4,cug.lt,rl,rl		:get cugtab offset
	je	cnexom,,		:jump if no cug table
	lr	r1,r0			:get cug index
	slls	r1,2			:make a word offset
	lhl	r1,cugtab,r1,r4		:check if index valid (ck ilock dnic)
	je	cmexom,,		:jump if no entry for index
:-----------------------------------------------------------------------
XMCUP1	LA	R1,CUP.LT,RL,		:partly overwritten by patch :HJR 02-02-87
	j	xmccup+0C+0E,,		:return
endpatch(NSR947 -- Don't change CUGPREF for undefined cug index)
  ei xom*cugena
:**************************************
:************************
:**************
:	Patch to module: XCOMOM.F31
:	Change label   :
:       Patch by:        BCHEN (HRIVERS) 
:       NSR number:      684, 801
:	version:         3.01
:	Description: 
:	In the routine 'Tnirpt' the tnic list is cleared from FACBUF but
:	TNICNT and TNIRCV remain set.  If a Call Accept with tnics was
:	received from the link and subsequently a Clear Information IIX
:	message was received from the remote interface then the
:	consistency check (FACBUF count = TNICNT) in 'Esp17' would
:	result in a trap.  Fix resets TNIRCV and clears TNICNT in
:	'tnirpt'.

  if x.75
patch(860418,1200,BPC,tnirpt+4,,6)
        rbt     r7,tnircv,,
conpatch(tnir30-8,,6)
        j       pa1ptr,,
conpatch(pa1ptr,,14)
        jal     r9,genrpt,,
        lhl     r7,iport
        lis     r4,0
        stb     r4,tnicnt,r7,
        jr      r6
endpatch(NSR684/801 -- cc=d5 since TNICNT not 0 after sending accounting msg)
  ei

:**************************************
:************************
:**************
:	Patch to module: XCOMOM.F31
:	Change label   :
:       Patch by:        STF 
:       NSR number:      1097
:	version:         3.01
:	Description: 
:	This patch fixes the XOM B6 command malfunction. If the new
:	USERNAMEPREFIX has its third character defined in 8-bit ASCII,
:	the string generated by XOM will start with "FFFF" , not only
:	leading to a wrong display through the use of the B5 command,
:	but also to a bad username sent to the Supervisor at circuit
:	building time.
:	This is due to the most significant bit propagation when executing 
:	an OH in XMCNUP, thus ignoring the leftmost halfword containing
:	the first two characters of the new string and replacing it by
:	the m.s.b. propagated : i.e. "FFFF" .
:	This patch will load the entire string in one shot, thus avoiding
:	dangerous halword manipulations.

    
  if	xom
patch(861119,1635,STF,XMCNUP+6,,6)
	L	R0,XOMPAR+4	: load whole string
	JFS	XMCNUP+10	: resume logic
endpatch(Fix B6 command malfunction when using 8-bit ASCII characters)
  ei	xom
:**************************************
:************************
:**************
:	Patch to module: XCOMOM.F31
:	Change label   :
:       Patch by:        JWANG
:       NSR number:      1107
:	version:         3.01
:	Description: 
:	XOM command 76 does not allow user to change the prarmeter
:	values if the number of arguments for command 76 is greater
:	than 9 and if XONOF is not set to ON at the sysgen time.
:	XOM prompted '?30' error message no matter the XONOF argument
:	of command 76 is 0 or 1.
:	The problem is fixed by the following patch.  User enters any
:	number of arguments (<=12) for command 76.  The corresponding
:	parameter value can be ON or OFF except the XONOF parameter.
:	If XONOF is not sysgened ON, the XONOF argument value of command
:	76 has to be 0. If XONOF is ON at sysgen, command 76 can have 0
:	or 1 for XONOF value.

  IF 	XOM
PATCH(861125,1100,JWANG,XMCPDO+4C,,4)
        JL      XOMRSP          :IF XOM 76 DOESN'T GIVE XONOF ARGUEMENT,JUMP
CONPATCH(XMCPDO+56,,4)
        JG      CDEXOM          :IF XONOF ARGUEMENT VALUE IS 1, JUMP
ENDPATCH(FIX XOM COMMAND 76 BUG)
  EI	XOM
:***********************************************************************
:***************
:*****
:   Patch for :		XCOM03.P01
:   Patch by:		Louisa Hsu
:   Description:	This patch is to fix XOM commands 28 and 29.
:   			When using either XOM command 28 to query the
:			mapping from throughput class to window size or
:			using XOM command 29 to query the mapping from 
:			throughput class to packet size, XOM replied with 
:			the values of link # 0 no matter the real link #
:			you specified. 
:   Related NSR:	NSR671
:
	IF	XOM&TPUTAB
	PATCH(861126,1500,AMVB,XOMTP2,,6)
	J	PA1PTR,,
	CONPATCH(PA1PTR,,10)
	LR	R8,RL		:GET LINK NUMBER
	SLLS	R8,4		:16 BYTES FOR EACH LINK
	AIS	R8,1		:RESTORE OLD INSTRUCTIONS
	LHI	R2,$A 80
	J	XOMTP2+6,,
	CONPATCH(XOMTP4,,6)
	J	PA1PTR,,
	CONPATCH(PA1PTR,,10)
	LR	R8,RL
	SLLS	R8,4
	AIS	R8,1
	LHI	R2,$A 80
	J	XOMTP4+6,,
	ENDPATCH(correct XOM query TCTOPW & TCTOPS for a specific link)
	EI	:XOM&TPUTAB
:*****
:***************
:***********************************************************************
:***********************************************************************
:***************
:*****
:   Patch for :		XCOM03.P01
:   Patch by:		Louisa Hsu
:   Description:	This patch is modified from KJL 840727 patch
:			XOSTR.BSC to write a new routine XOSTR to
:			support DDT command 'OS' for BSC links.
:			A new implementation for BSC 'OS' command
:			will be released in version 4.02. Please
:			refer to NSR737.DOC.
:   Related NSR:	NSR737
:   Related DOC:	NSR737.DOC

	IF	DDTDIA
	IF	BSC
PATCH(861203,1700,LOUISA,PA1PTR,,0C)
	ds.cmd(OS,XOSTR)	:COMMAND OS INVOKES THIS
CONPATCH(PA1PTR,,1CE)
:	OUTPUT SECTOR TRACE TABLE
XOSTR	LHI	R2,NLINES-1
XOST00	LB	R1,CURSEC,R2,	:GET CURRENT POINTER
	AIS	R1,1		:POINT TO NEXT ENTRY
	CLB	R1,K.LT,R2,	:END OF TABLE FOR THIS LINE?
	JLFS	XOST01		:IF NOT
	LIS	R1,0		:POINT TO BEGINNING OF TABLE
XOST01	STB	R1,P.PTR,R2,	:INIT TRACE POINTER TO ONE AFTER CURRENT
	SIS	R2,1		:BUMP POINTER
	JGEBS	XOST00		:IF MORE TO DO

	LIS	R1,0
	STB	R1,MSGSPC,,	:INIT STORE BYTE COUNT

	JAL	R13,XDTIME,,	:ASK FOR DUMP TIME

::   IF	.EQ.(NLINES,1)
	LHI	R14,100		:FOR SINGLE LINE, NO "LINE NUMBER?" PROMPT
::   ELSE
::	LIS	R14,0		:INIT LINE NUMBER
::	SVC	0B,M.LINQ,,	:ASK FOR LINE NUMBER
::XOST10	SVC	0A,0010		:WAIT FOR RESPONSE
::	JFS	XOST20		:IF NO MORE CHARACTERS
::	NHI	R0,7F		:STRIP PARITY
::	CLHI	R0,0D		:CR?
::	JE	XOST20		:IF SO
::	OHI	R14,100		:INDICATE THAT RESPONSE NOT JUST CR
::	NHI	R0,0F		:JUST GET LAST DIGIT
::	SLLS	R14,0		:MOVE ACCUMULATION OVER A DIGIT
::	OR	R14,R0		:INSERT NEW DIGIT
::	JBS	XOST10		:GO BACK FOR MORE
::   EI	NLINES

XOST20	LR	R14,R14		:LOOK AT LINE NUMBER
	JE	XOSM		:IF NOTHING, GO DO ALL LINES

XOSS	NHI	R14,1F		:REDUCE LINE MOD 32
	CLHI	R14,NLINES	:LINE NUMBER TOO BIG?
	JGE	XOSS99		:IF SO, GET OUT
	LHL	R15,SECBIA,R14,R14	:GET SECTOR BIAS
	SLLS	R15,2		:CONVERT WORD INDEX TO BYTE INDEX

XOSS10	JAL	R13,XOSLP	:GO PRINT SECTORS FOR LINE
	L	R0,XDRSEC,,	:SLOWC TIME TO QUIT
	CL	R0,SLOWC,,	:TIME YET ??
	JLFS	XOSS99		:YES, END OF TRACE TIME
	SVC	DISMIS,0	:DISMISS TO DDT
	JBS	XOSS10		:GO LOOK FOR ANOTHER PACKET
XOSS99	J	PBT99,,		:RETURN TO COMMAND PROCESSOR
:  FOR THE RETURN TO COMMAND PROCESSOR, USE THE SAME EXIT AS PBT99,
:  TO KEEP THIS PATCH COMPATIBLE WITH VERSION 2.01 AND 2.02.
:  FOR 2.01 USE "LM R0,XRSAVE,," AND "SVC KIO,1".
:  FOR 2.02 USE "J DSTRT2".

XOSM	LIS	R14,0		:INIT LINE NUMBER
XOSM10	LIS	R13,0
	STB	R13,MSGSPC,,	:INIT MESSAGE SPACE
	LA	R9,M.LINE,,	:POINT TO LINE MESSAGE
	JAL	R12,MSGMOV,,	:MOVE TO STORE
	LIS	R1,2		:SET FIELD WIDTH TO 2
	LR	R5,R14		:GET LINE NUMBER
	JAL	R11,NUMMOV,,	:MOVE TO STORE
	LA	R9,M.EMPT,,	:POINT TO EMPTY SPACE
	JAL	R12,MSGMOV,,	:MOVE TO STORE
	LHL	R15,SECBIA,R14,R14,	:GET SECTOR BIAS
	SLLS	R15,2		:CONVERT WORD INDEX TO BYTE INDEX
	JAL	R13,XOSLP	:GO PRINT SECTOR
	AIS	R14,1		:BUMP LINE NUMBER
	CLHI	R14,NLINES	:LINE NUMBER TOO BIG?
	JL	XOSM10		:GO ON

XOSM98	L	R0,XDRSEC,,	:SLOWC TIME TO QUIT
	CL	R0,SLOWC,,	:TIME YET ??
	JLFS	XOSM99		:YES, END OF TRACE TIME
	SVC	DISMIS,0	:DISMISS TO DDT
	J	XOSM		:GO LOOK FOR ANOTHER PACKET
XOSM99	J	PBT99,,		:RETURN TO COMMAND PROCESSOR
:  FOR THE RETURN TO COMMAND PROCESSOR, USE THE SAME EXIT AS PBT99.

:	SUBROUTINE TO GET SECTOR AND PRINT IT
:	R13 = LINK REGISTER
:	R14 = LINE NUMBER
:	R15 = SECTOR BIAS
:
:	REGISTER USAGE:
:	R2  = INPUT BUFFER ADDRESS OF PACKET TO BE DISPLAYED.
:	R5  = HOLDS THE BYTE CURRENTLY BEING PROCESSED.
:	R6  = TRACE BUFFER POINTER INTO P.PTR.
:	R7  = COUNT OF REMAINING BYTES OF DATA IN INPUT BUFFER.  ONLY UPDATED
:		WHEN A BYTE IS ACTUALLY OUTPUTTED TOWARD THE TERMINAL.
:	R8  = OFFSET INTO INPUT BUFFER FOR NEXT BYTE TO PROCESS.
:	
:	
XOSLP	HS
XOSL10	LB	R6,P.PTR,R14,	:OUR TRACE PTR
XOSL30	CLB	R6,CURSEC,R14,	:SAME AS INTERFACE ??
	JE	XOSL98		:IF PACKET BUFFER TRACE CAUGHT UP
	LR	R7,R6		:GET POINTER
	SLLS	R7,2		:CONVERT WORD INDEX TO BYTE INDEX
	L	R2,SECADR,R7,R15	:GET ADDRESS OF BUFFER
:  BEGIN SPECIAL CODE FOR BISYNC PACKET DISPLAY.
	LIS	R7,0F		:GET BYTE COUNT OF 0F HEX.  IF DO NOT FIND 
				:DLE STX IN 1ST 15 BYTES, ASSUME EMPTY BUFFER.
	LIS	R8,0		:INIT BYTE POSITION POINTER (INTO PACKET BUF).
:  BEGIN SCAN FOR DLE STX, WHICH MARKS THE BEGINNING OF THE BISYNC FRAME.
XOSL35	JAL	R11,XOSL45	:GET A BYTE FROM THE BUFFER, INTO R5.
	CHI	R5,08		:TEST FOR DLE (REVERSED).
	JNBS	XOSL35		:IF NOT DLE REPEAT SCAN TILL USE UP R7 COUNT.
:  DLE FOUND.  GO CHECK IF NEXT CHAR IS STX.
	JAL	R11,XOSL45	:GET A BYTE FROM THE BUFFER, INTO R5.
	CHI	R5,40		:TEST FOR STX (REVERSED).
	JNBS	XOSL35		:IF NOT DLE STX, CONTINUE THE SCAN.
:  FLUSH FRAME HEADERS, SO ONLY THE PACKET LEVEL IS DISPLAYED.  FLUSH ADDRESS:
	JAL	R11,XOSL45	:GET A BYTE FROM THE BUFFER, INTO R5.
	CHI	R5,08		:ENSURE IT IS NOT A DLE (REVERSED).
	JNFS	XOSL40		:IF NOT, PROCESS FRAME TYPE
	JAL	R11,XOSL45	:GET A BYTE FROM THE BUFFER, INTO R5.
:  FLUSH FRAME TYPE:
XOSL40	JAL	R11,XOSL45	:GET A BYTE FROM THE BUFFER, INTO R5.
	CHI	R5,08		:ENSURE IT IS NOT A DLE (REVERSED).
	JNFS	XOSL50		:IF NOT, CAN FINALLY PROCESS THE PACKET.
	JAL	R11,XOSL45	:GET A BYTE FROM THE BUFFER, INTO R5.
	JFS	XOSL50		:GO PROCESS THE PACKET.
:  ROUTINE TO GET A BYTE FROM THE PACKET BUFFER.  IF THE R7 COUNT IS USED
:  UP, BRANCH TO XOSL70 TO ABORT SCANNING THIS PACKET.
:	R2 = ADDRESS OF PACKET INPUT BUFFER.
:	R7 = COUNT OF BYTES REMAINING BEFORE QUIT RETRIEVAL.
:	R8 = INDEX INTO PACKET INPUT BUFFER.
:	R11= LINK REGISTER
:	R5 = BYTE VALUE RETURNED IN THIS REGISTER.
XOSL45	LB	R5,0,R2,R8	:GET BYTE FROM PACKET, INTO R5.
	AIS	R8,1		:INCREMENT INDEX INTO INPUT BUFFER.
	SIS	R7,1		:DECREMENT COUNT OF BYTES REMAINING.
	JE	XOSL70		:IF ZERO, QUIT--GO CHECK NEXT PACKET.
	JR	R11		:ELSE RETURN, TO PROCESS THE BYTE.
:  PROCESS PACKET LEVEL (DISPLAY TILL DLE ETX, OR GET MAX PACKET SIZE).
XOSL50	LH	R7,MST.LT,R14,R14	:LOAD MAX PKT SIZE AS COUNTER LIMIT.
	AHI	R7,10		:ALLOW 16 BYTES EXTRA FOR PACKET HEADER.
:(NOTE R7 MUST START AS MULTIPLE OF 16 FOR PROPER INITIAL OUTPUT FORMAT.)
XOSL52	LB	R5,0,R2,R8	:GET A BYTE FROM THE INPUT PACKET BUFFER.
	AIS	R8,1		:INCREMENT INDEX INTO BUFFER.
	CHI	R5,08		:CHECK FOR DLE (REVERSED).
	JNFS	XOSL55		:IF NOT DLE, GO TO DISPLAY IT.
	LB	R5,0,R2,R8	:GET A BYTE FROM THE INPUT PACKET BUFFER.
	AIS	R8,1		:INCREMENT INDEX INTO BUFFER.
	CHI	R5,08		:CHECK FOR DLE (REVERSED).
	JN	XOSL65		:IF NOT DLE, ASSUME IT IS ETX, OUTPUT, ABORT.
				:IF DLE TWICE IN DATA, GO TO DISPLAY IT ONCE.
:  GOT A DATA BYTE TO OUTPUT.  FORMAT IT AND PUT INTO MSGSPC OUTPUT BUFFER.
XOSL55	LB	R5,TCHINV,R5,	:NEED TO DO BIT REVERSAL BEFORE DISPLAY.
	LIS	R1,2		:INIT FIELD WIDTH FOR NUMBER CONVERSION
	JAL	R11,NUMMOV,,	:CONVERT AND PRINT
	SIS	R7,1		:DECREMENT BYTE COUNTER OF BYTES LEFT.
	JE	XOSL65		:IF COUNTER EXPIRED OUTPUT DATA AND ABORT PKT.
	LR	R3,R7		:SEE IF NEED CR
	NHI	R3,0F		:IF MULTIPLE OF 16, INSERT CRLF.
	JNFS	XOSL60		:IF NOT, GO TEST IF SPACE SHOULD BE OUTPUTTED.
	LA	R9,M.CRLF,,	:POINT TO CRLF
	JAL	R12,MSGMOV,,	:MOVE TO STORE
	SVC	0B,MSGSPC,,	:OUTPUT THE LINE TO THE TERMINAL.
	LIS	R3,0		:ZERO OUT BYTE COUNT.
	STB	R3,MSGSPC,,	:ZERO OUT BYTE COUNT IN MSGSPC.
XOSL60	NHI	R3,1		:ODD OR EVEN BYTE?
	JN	XOSL52		:IF NOT EVEN GO TO BEGINNING TO GET NEXT BYTE.
	LHI	R5,0A0		:GET SPACE CHARACTER, INSERTED EVERY 2 BYTES.
	JAL	R11,BYTMOV,,	:MOVE TO STORE
	J	XOSL52		:GO TO BEGINNING OF LOOP TO GET NEXT BYTE.
:  DONE WITH PACKET.  SEND THE FINAL LINE OF OUTPUT TO THE TERMINAL.
XOSL65	LA	R9,M.CRLF,,	:END WITH CRLF
	JAL	R12,MSGMOV,,	:MOVE TO STORE
	SVC	0B,MSGSPC,,	:PRINT INTERPRETATION
	LIS	R7,0		:ZERO OUT LENGTH REMAINING.
	STB	R7,MSGSPC,,	:RESET MESSAGE LENGTH
:  CHECK FOR OTHER PACKETS FOR THIS LINE BEFORE RETURNING.
XOSL70	AIS	R6,1		:ADVANCE OUR PTR
	CLB	R6,K.LT,R14,	:END OF TRACE TABLE ??
	JLFS	XOSL80		:IF NOT
	LIS	R6,0		:WRAP TO START
XOSL80	STB	R6,P.PTR,R14,	:SAVE OUR UPDATED PTR
	J	XOSL30		:START NEW PACKET ENTRY

XOSL98	JR	R13		:RETURN

ENDPATCH(Support DDT command 'OS' for BSC links)
	EI	:BSC
	EI	:DDTDIA

:*****
:***************
:***********************************************************************

:***********************************************************************
:***************
:*****
:   Patch for :		XCOM03.P01
:   Patch by:		Louisa Hsu
:   Description:	Fix the crashes with an 'ILL MEM REF', which
:			happened when an invalid SELECT command
:			has been previously entered and if an operator
:			enters a REDO or SNAP command.
:   Related NSR:	NSR884, and NSR1098

  IF DDTDIA
PATCH(870227,1400,JWANG/LOUISA,RED010,,6)
        J       PA1PTR,,
CONPATCH(PA1PTR,,18)
	CH      R1,REQSIZ,,
        JGE     DSTRT2,,                :NO REQUEST, ALL DONE
LSHP1   STH     R1,REQINX,,		:RESTORE OLD INSTRUCTIONS
        J       RED010+6,,
CONPATCH(RED015+0E,,4)
        JL      LSHP1
CONPATCH(RED020,,4)
        J       LSHP1
CONPATCH(SNP010,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,18)
	CH      R1,REQSIZ,,
        JGE     DSTRT2,,                :NO REQUEST, ALL DONE
LSHP2   STH     R1,REQINX,,		:RESTORE OLD INSTRUCTIONS
        J       SNP010+6,,
CONPATCH(SNP010+1E,,4)
	JL	LSHP2
ENDPATCH(Fix the crashes on DDT commands SELECT, SNAP, and REDO)
  EI :DDTDIA

:**************************************
:************************
:**************
:       Patch by:        JSOUNG
:       NSR number:      903
:	version:         3.01 
:	Description: 
:	X.25 crashes, if a TIIX command was sent following
: 	the selected dialect response.  This problem was 
:       occurred when a call was made form CONSAT to X.25.
:       Fix so that X.25 accepts the TIIX command and finishes
:       the dialect exchanges.

PATCH(861024,1210,JSOUNG,GMEXP1,,06)
	J	PA1PTR,,
CONPATCH(PA1PTR,,18)
	RBT	R7,EXTWDR	:NOT WAITING DIALET RESPONSE
	CBCT(R4)		:GET DATA COUNT OF DIBUF
	LR	R4,R4		:ANY DATA IN DIBUF?
	JE	GMEEXI,,	:NO - GO  SEE IF ANY MORE DATA IN IRING
	J	GMEXP1+6,,	:GO PROCESS IT
ENDPATCH(NSR#903-FIX X.25 CRASH WHEN TIIX SENT FOLLOWING DIALECT RESPONSE)
:*********************************
:*************************
:*******************
:       Patch by:        JSOUNG
:       NSR number:      989
:	Version   :      3.01 
:	Description: 
:       X.25 crashes if data is sent immediately following 
:       the IIX seleted dialect response.  This problem was
:       occurred when a call was made from CONSAT to X.25.
:	Fix so that X.25 saves the data and sends it to 
:	the link after the dialect exchanges are finished.

PATCH(861028,0930,JSOUNG,GMEXP8+6,,6)
	JG	PA1PTR,,	:GO PROCESS REMAINING MESSAGE
CONPATCH(PA1PTR,,38)
	JAL	R0,NDLPMT,,	:SEND USER PROMPT
	J	GMEX90		:HERE IF <SEMI-COLON>
	J	GMEX90		:HERE IF <+>
	J	GMEX91		:HERE IF <CR>, NO USER INPUT REQUIRED
	J	GMEX90		:HERE IF TELENET FORMAT LOGIN
GMEX90	LHL	R5,LO7		:GET REMAINING COUNT
	LHL	R1,DPORT	:GET DISPATCH PORT NUMBER
	J	MMTEXT+12,,	:GO PROCESS THE REMAINING MESSAGE
GMEX91	LHL	R1,DPORT	:GET DISPATCH PORT NUMBER
	LHL	R5,LO7		:GET REMAINING COUNT
	STB	R5,DMSGLN,R1,	:SAVE THE REMAINING COUNT
	J	LIM300,,	:GO PROCESS REMAINING MESSAGE
ENDPATCH(NSR#989-FIX X.25 CRASH ON DATA FOLLOWING IIX SELECTED DIALECT)
:***********************
:*****************
:**********
:	Change by      : JSOUNG
:       NSR number     : 943
:	Version        : 3.01
:	Description    : 
:	If a throughput class to packet window size mapping table
:       is specified during the system GEN, the X.25 interface
:	always assigns the packet window size by mapping from the
:       throughput class.  In this case, if customer specifies
:       packet window size during the call set up, this
:	window size is overwritten by mapping from throughput
:       class.  Fix so that the window size will not be overwritten
:	by mapping from throughput class.  Also, if the packet window 
:	size specified by the customer is greater than the packet
:	window size mapped from the throughput class, the latter
:	value will be assigned as packet window size.

	IF	TCPW
PATCH(861486,1420,JSOUNG,TWP025,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,1E)
	LB	R9,PWTMT,R1,		:GET SPECIFIED TRANSMIT WINDOW SIZE
	JE	TWP026			:JUMP IF NO WINDOW SIZE SPECIFIED
	CR	R9,R3	
	JG	TWP026			:JUMP IF SPECIFIED SIZE>MAPPING SIZE
	LR	R3,R9			:OTHERWISE USE SPECIFIED WINDOW SIZE
TWP026	STB	R3,PWTMT,R1,
	J	TWP025+6,,
CONPATCH(TWP030,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,1E)
	LB	R9,PWRCV,R1,		:GET SPECIFIED RECEIVE WINDOW SIZE
	JE	TWP028			:JUMP IF NO WINDOW SIZE SPECIFIED
	CR	R9,R4
	JG	TWP028			:JUMP IF SPECIFIED SIZE>MAPPING SIZE
	LR	R4,R9			:OTHERWISE USE SPECIFIED WINDOW SIZE
TWP028	STB	R4,PWRCV,R1,
	J	TWP030+6,,
ENDPATCH(NSR#943-AVOID OVERWRITING OF WINDOW SIZE WHEN CUSTOMER SPECIFIED)
	EI

PATCH(111486,1430,JSOUNG,TWP025-6,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,44)
	LB	R3,PWT.LT,RL,		:GET DEFAULT TRANSMIT WINDOW SIZE
	TBT	RL,PWN.F,,		:DOES THIS LINK NEGITIATE
	JE	TWP025,,		:NO - SKIP 
	SLLS	R3,2			:MULTIPLY BY 4
	TBT	RL,P128.F,,		:MOD 128?
	JE	TWP022			:NO - GO TO MOD 8 CKECK
	CLHI	R3,$A127		:IS IT IN RANGE?
	JLE	TWP025,,		:YES - ALL DONE
	LHI	R3,$A127		:SCALE DOWN TO MAX
	J	TWP025,,
TWP022	CLHI	R3,7			:COMPARE WITH MOD 8 LIMIT
	JLE	TWP025,,		:IN RANGE, FINISHED
	LIS	R3,7			:SCALE DOWN TO MAX
	J	TWP025,,

CONPATCH(TWP030-6,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,44)
	LB	R4,PWR.LT,RL,		:GET DEFAULT RECEIVE WINDOW SIZE
	TBT	RL,PWN.F,,		:DOES THIS LINK NEGOTIATE
	JE	TWP030,,		:NO - SKIP
	SLLS	R4,2			:MULTIPLY BY 4
	TBT	RL,P128.F,,		:MOD 128?
	JE	TWP027			:NO - GO TO MOD 8 CHECK
	CLHI	R4,$A127		:IS IT IN RANGE?
	JLE	TWP030,,		:YES - ALL DONE
	LHI	R4,$A127		:SCALE TO MOD 128 MAX
	J	TWP030,,
TWP027	CLHI	R4,7			:IS IT IN RANGE?
	JLE	TWP030,,		:YES - ALL DONE
	LIS	R4,7			:SCALE DOWN TO MOD 8 MAX
	J	TWP030,,
ENDPATCH(NSR#943-AVOID OVERWRITING OF WINDOW SIZE WHEN CUSTOMER SPECIFIED)
:*****************************
:*****
:****
:	Patch:        XCOM03.R01
:	Patch by:     JSOUNG
:	NSR number:   929
:	Version:      3.01
:	Description:
:	X.25 interface fails to send packet level RR on the
:	regular basis if the interface inhibits the RR packet.
:       Fix that the X.25 interface sends RR on the regular basis
:	if the RNR packet is inhibited.

patch(861125,1400,JSOUNG,rw040+0c,,0a)
	je	pa1ptr,,
	j	rw040+16		:donn't update p(r) at this moment
conpatch(pa0ptr,,nigrps*2)
lstrnr	hs	nigrps			:bit set indicate that xcom send a RNR
conpatch(pa1ptr,,12)
	tbt	r6,lstrnr,,		:send RNR before?
	je	rw020,,			:no-don't need send RR at this moment
	j	rw040+16,,		:yes-send RR to open the receive 
					:window
conpatch(psubax,,6)
	j	pa1ptr,,
conpatch(pa1ptr,,12)
	lb	r2,ppr,r1,
	stb	r2,tppr,r1,		:update p(r) before send RR/RNR
	j	psubax+6,,
conpatch(cwrot+8,,4)
	j	cwr030
conpatch(cwr030+4,,0e)
	rbt	r5,winrox		:don't delay window rotation when
					:receive release backpresure 
	rbt	r5,flrnr		:cancel RNR
	j	mmfra,,
conpatch(psubaa,,6)
	j	pa1ptr,,
conpatch(pa1ptr,,14)
	rbt	r1,lstrnr,,		:indicate last flow control packet
					:is not a RNR
	rbt	r1,obkpr,,
	lis	r0,1
	j	psubaa+6,,
conpatch(psubab,,6)
	j	pa1ptr,,
conpatch(pa1ptr,,14)
	sbt	r1,lstrnr,,		:indicate last flow control packet 
					:is a RNR
	sbt	r1,obkpr,,
	lis	r0,1
	j	psubab+6,,
endpatch(NSR#929-SEND RR ON THE REGULAR BASIS)
:*****************************
:*****
:****
:	Patch to module: xcom03.r01
:	Patch by:        JWANG(JSOUNG)
:	NSR number:      767
:	Version:         3.01
:	Description:     
:       When a X.29 SET and READ PAD message including
:       ational parameters is received from link, the
:       XCOM fails to insert the national marker into
:       PARAMETER INDICATION PAD message.  Fix that
:       return national marker before any parameter
:       reference.

PATCH(870122,1500,JSOUNG,XLA.30+2A,,6)
	J	XLA.30+30,,	:DON'T SAVE UNMAPPED PARAMETER REF# INTO
                                :"PADPR1"
ENDPATCH(NSR#767-RETURN NATIONAL MARKER BEFORE ANY NATIONAL PARAMETER)
:**************************************
:************************
:**************
:       Patch by:        JSOUNG
:       NSR number:      1086
:	version:         3.01
:	Description: 
:	In processing the faclility in call request packet,
:       if the facility code not falling within the defined range,
:       the slot crashes with the crash code "FA".  Fix that the 
:       facility code will be flushed correctly.

PATCH(870130,1045,JSOUNG,CRF040,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,1C)
	AIS 	R8,1			:+1 TO GET LENGTH OF PARAMETER
	SR	R7,R8			
	JL	RTECAL,,		:CLEAR CALL IF NOT ENOUGH DATA
	LHL	R1,FACBUF,,		
	JAL	R4,WCI,,		:COPY FACILITY CODE 
	J	CRF050,,
CONPATCH(CRF050+4,,4)
	J	CRF050+8		:SKIP COPY FACILITY CODE
ENDPATCH(NSR#1086-FIX "FA" CRASH FOR FACILITY NOT FALLING WITHIN RANGE)

:**************************************
:************************
:**************
:       Patch by:        STF(JSOUNG)
:       NSR number:      1085
:	version:         3.01
:	Description: 
:       In RMAKE routine, R4 is loaded with GRPSAV and is modified 
:       in RMK060.  There is a possibility at the begining of RMK070 
:       to loop back to RMK050 without reinitializing R4, thus corrupting
:       R4, R2, EPORT, IPORT, DPORT,..i.e. all possibilities of index used
:       in the related routines.  These is leading to several types of
:       crashes occuring in the RMAKE routines at different location.
:       Patch ensures that R4 is properly restored after it has been
:       modified.

PATCH(870212,1330,STF,RMK070,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,18)
	LH	R6,EI.MT,R2,R2		:ORIGINAL CODE
	JG	RMK070+0A,,		:PATCH NOT APPLICABLE IN THIS CASE
	LH	R4,GRPSAV,RL2,		:REINITIALIZED
	J	RMK050,,		:THEN GO BACK TO SOURCE CODE
ENDPATCH(NSR#1085-RESTORE R4 BEFORE LOOP BACK FROM RMAK070 TO RMAK050)
:*****************************
:*****
:****
:	Patch by:        JSOUNG
:	NSR number:      764
:	Version:         3.01
:	Description:   
:       There is a potential problem that the low host can
:       attempt to build PVC to high host and the slot will
:       crash.  This problem will occur only when the host number
:       defined for the slot is bigger than 7FFF (in Hex), but the
:       current maximum host number in TYMNET is 9999 (in decimal).
:       Fix to avoid this potential problem

	IF PVC
PATCH(020987,1045,JSOUNG,INI410+20,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,0E)
	LHL	R4,HOSTS,R2,R2		:GET HOST NO. FOR CURRENT LINK
	CR	R3,R4			:COMPARE WITH DESTINATION HOST NO.
	J	INI410+26,,
CONPATCH(IZAP30+38,,6)
	LHL	R7,PVCTAB,R6,R5		:GET DESTINATION HOST NUMBER
CONPATCH(IZAP30+44,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,0E)
	LHL	R2,HOSTS,R5,R5		:GET HOST NO. OF CURRENT LINK
	CR	R7,R2			:COMPARE WITH DESTINATION HOST NO.
	J	IZAP30+4A,,
CONPATCH(IZAP30+4A,,4)
	JG	IZAP33			:JUMP IF LOWER THAN DESTINATION
ENDPATCH(NSR#764-AVOID LOW HOST ATTEMPTING TO BUILD PVC TO HIGH HOST)
	EI
:*****************************
:*****
:****
:	Patch by:   JWANG(JSOUNG)
:	NSR number: 719 
:	Version:    3.01
:	Description:
:	The X.75 interface receives a CALL REQUEST packet from the 
:       link.  When the circuit is built through the network, the 
:       the X.75 interface returns a CALL CONNECTED packet to the 
:       link with the TNIC list if there is any.  After sending
:       the CALL CONNECTED packet, the X.75 interface fails to
:       report the TNIC list to the SUP.  Fix that the X.75 
:       reports the TNIC to the SUP after returning the CALL
:       CONNECTED to the link.

  IF  X.75
PATCH(860506,1250,JWANG,PA0PTR,,0C)
SAVE    WS      3
CONPATCH(ADDT10+16,,6)
        J       PA1PTR,,
CONPATCH(PA1PTR,,50)
        ST      R1,SAVE,,		:SAVE REGISTERS
        ST      R7,SAVE+4,,
        ST      R9,SAVE+8,,
        LR      R7,R0
        JAL     R4,GCI,,
        JAL     R4,WCI,,
        SLLS    R7,8
        AR      R7,R0
        OI      R7,AA.TNI		:BUILD "B7" MESSAGE
        LHL     R9,DPORT,,
        JEFS    .+8
        JAL     R9,GENRPT,,		:REPORT TNIC TO SUP
        L       R1,SAVE,,
        L       R7,SAVE+4,,
        L       R9,SAVE+8,,
        J       ADDT10+1E,,
CONPATCH(ADDT18+20,,6)
        J       PA1PTR,,
CONPATCH(PA1PTR,,50)
        ST      R1,SAVE,,
        ST      R7,SAVE+4,,
        ST      R9,SAVE+8,,
        LR      R7,R0
        EXBR    R0,R0
        JAL     R4,WCI,,
        SRLS    R0,8
        JAL     R4,WCI,,
        OI      R7,AA.TNI		:BUILD "B7" MESSAGE
        LHL     R9,DPORT,,
        JEFS    .+8
        JAL     R9,GENRPT,,             :REPORT TNIC
        L       R1,SAVE,,		:RESTORE REGISTERS
        L       R7,SAVE+4,,
        L       R9,SAVE+8,,
        J       ADDT20,,
CONPATCH(ADDT20,,6)
        J       PA1PTR,,
CONPATCH(PA1PTR,,50)
        ST      R1,SAVE,,
        ST      R7,SAVE+4,,
        ST      R9,SAVE+8,,
        LHL     R7,IPORT
        LB      R7,TNICNT,R7,
        SRLS    R7,1			:BUILD "B7" MESSAGE WITH TNIC COUNTER
        OI      R7,AA.TNI!0FF00		:TO TERMINATE TNIC LIST
        LHL     R9,DPORT,,
        JEFS    .+8
        JAL     R9,GENRPT,,             :OUTPUT TNIC TERMINATOR
        L       R1,SAVE,,
        L       R7,SAVE+4,,
        L       R9,SAVE+8,,
        LB      R5,TNICNT,R7,
        J       ADDT20+6,,
ENDPATCH(NSR#719-REPORT TNIC TO SUP AFTER SENDING CALL CONNECTED PKT TO LINK)
  EI X.75
:
:*****************************
:*****
:****
:	Patch by:   JSOUNG
:	NSR number: 968
:	Version:    3.01
:	Description:
:       The X.75 interface receives a CALL REQUEST packet including 
:       the TNIC list from the lin.  If the circuit can not be built 
:       through the network, the X.75 interface returns a CLEAR REQUEST
:       packet to the link.  When sending the CLEAR REQUEST packet, 
:       the X.75 interface fails to include the TNIC list in the packet.
:       Also, after sending out the CLEAR packet, the X.75 interface
:       fails to report the TNIC list to the SUP.  Fix that X.75
:       interface includes the TNIC list in the CLEAR packet and 
:       reports the TNIC list to SUP after sending out the CLEAR.

  IF  X.75
PATCH(870216,1100,JSOUNG,LOGT75+12,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,24)
	LHL	R1,IPORT,,
	LB	R9,PCKSTE,R1,		:GET CHANNEL STATE
	CLHI	R9,PSCALC		:IN "SEND CALL CONFIRMARION" STATE
	JNFS	LOGT80			:NO - SKIP
	JAL	R9,MAKCLR,,		:SEE IF ANY TNIC TO ADD
LOGT80	JAL	R9,QCR,,		:RESTORE INSTRUCTION
	J	LOGT75+18,,
ENDPATCH(NSR#968-INCLUDING TNIC IN CLEAR REQUEST IF CALL IS REJECTED BY SUP)
  EI  X.75

:**** end of patch area*****************************************************

 PATCHREPORT			:REPORT BYTES OF PATCH AREAS USED
:**************************************
:************************
:**************
:       Patch by:        JSOUNG
:       NSR number:      733
:	version:         3.01
:	Description: report the usage of patch area at SYSGEN time.

	REMARK   FINAL LENGTH OF PATHIS AREA IS  
	NUMBER PAHPTR-PATHIS
	REMARK x  BYTES

	REMARK %%%  CURRENT P0SIZE IS  
	NUMBER P0SIZE
	REMARK x  BYTES  %
	
	REMARK %  CURRENT P1SIZE IS  
	NUMBER P1SIZE
	REMARK x  BYTES  %

	REMARK %  CURRENT PHSIZE IS  
	NUMBER PHSIZE
	REMARK x  BYTES%  

 FINPATCH			:MAKE FINAL REPORT ON SEGMENT USAGE
Q*1