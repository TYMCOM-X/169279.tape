(**********************************************************************)
(* **                  PROPRIETARY INFORMATION                     ** *)
(* **                                                              ** *)
(* **  This  source code listing constitutes the proprietary pro-  ** *)
(* **  perty of TYMNET.  The recipient, by receiving this program  ** *)
(* **  listing, agrees that neither this listing nor the informa-  ** *)
(* **  tion disclosed herein nor any part thereof shall be repro-  ** *)
(* **  duced or transferred to other documents or used or dis-     ** *)
(* **  closed to others for manufacturing or for any other purpose ** *)
(* **  except as specifically authorized in writing by TYMNET.     ** *)
(**********************************************************************)
!
(************************************************************************)
(*									*)
(*	GLOBL.NTV							*)
(*									*)
(*	Global NETVAL definitions.					*)
(*									*)
(************************************************************************)
(*									*)
(*				revision record				*)
(*									*)
(*	05Jan89 - neh							*)
(*		- add MAXIMUM_ENTRY to set limit on re-enter names	*)
(*	23Dec88 - neh							*)
(*		- make PASSWORD_ONLY_VALIDATOR_LIMIT conditional for	*)
(*		  allow_password_only.					*)
(*	22Dec88 - neh							*)
(*		- add request_fpc_start					*)
(*	03Oct88 - jrn							*)
(*		- add assign_password_expiration_as_default		*)
(*		- change allow_user_password_expire to			*)
(*		  password_expiration_by_user 				*)
(*		- add password_expiration_date_in_cud			*)
(*		- add ganpass_file_exists				*)
(*		- add prevent_duplicate_password code			*)
(*		- add allowable_times to modify_type			*)
(*		- define WORD_SIZE					*)
(*		- set PASSWORD_TEXT_MAX to the configuration file	*)
(*		  parameter MAXIMUM_PASSWORD_SIZE			*)
(*		- ENable ALLOW_PASSWORD_ONLY if either			*)
(*		  NO_PASSWORD_ONLY_VALIDATORS is DISabled or		*)
(*		  GLOBAL_PASSWORD_ONLY_LOGIN is ENabled (BEFORE its	*)
(*		  value is displayed in the listing)			*)
(*	        - add allow_logon_inhibit code				*)
(*	18May88 - neh							*)
(*	      - add REQUEST_GLOBAL_EXCEPTION.				*)
(*      17May88 - neh                                                   *)
(*          - add REQUEST_PRIORITY_STOP flag.                           *)
(*      26Apr88 - neh                                                   *)
(*            - if UUNSassignable_by_user is set in NVAL0#.A##, then    *)
(*              set UUNSassignable.                                     *)
(*	22Feb88 - neh							*)
(*	      - add flags ALLOW_GLOBAL_PASSWORD_EXPIRE and		*)
(*		ALLOW_USER_PASSWORD_EXPIRE				*)
(*	      - add type allowable_mud_types, constants			*)
(*		password_type and use_mud_type, will cause		*)
(*		compile error if conflict with include_gan or		*)
(*		force password change					*)
(*	16Nov87 - neh							*)
(*	      - add INCLUDE_DNIC, DNIC_FILE_MESSAGE			*)
(*	      - add conditional correction for conflicting flags	*)
(*	14Aug87 - neh							*)
(*	      - remove TYMSHARE_CUD_FORMAT flag, add INCLUDE_IRC,	*)
(*		CHECK_TIME_STATUS and UPDATE_CUD_ON_CHANGE_FAIL		*)
(*	      - change ignore host to ignore destination		*)
(*			merge 4.00 and 5.00 neh				*)
(*	20Jan87 - rsb							*)
(*		- add conditional flags around 				*)
(*		  MAXIMUM_PASSWORD_VALIDATORS and 			*)
(*		  PASSWORD_ONLY_VALIDATOR_LIMIT to account for 		*)
(*		  global_password_only_login.				*)
(*	14Nov86 - rsb							*)
(*		- add definition of PASSCHANGER_MSG, GANPASS_MSG,	*)
(*		  and GPO_MSG						*)
(*	11Nov86 - rsb							*)
(*	      - Add boxes to define whether force password change and	*)
(*		global password only are enabled/disabled.		*)
(*	02Sep86 - neh							*)
(*	      - Change LOG_MESSAGE_TEXT_MAX to be equal to a value	*)
(*		of 180.  This will make the number of characters in	*)
(*		LOG_MESSAGE for the operator log file equal to 180.	*)
(*	      - If CHANGES_TO_OPER_LOG is enabled, add enumeration	*)
(*		type modify_type, the constants first_modify_type and	*)
(*		last_modify_type and the type modify_index equal to	*)
(*		the range of FIRST_MODIFY_TYPE to LAST_MODIFY_TYPE.	*)
(*	      - Move the enumeration type OPER_LOG_MESSAGE_KIND to	*)
(*		global definitions to be used by internal_to_string.	*)
(*	08Jul86 - jrn							*)
(*	      - add oplog_remark_message				*)
(*	      - add SPECIAL flag					*)
(*	13May86 - neh							*)
(*	      - add INCLUDE_DUMP flag					*)
(*	10Mar86 - jrn							*)
(*	      - redo REUSE_UUNS to maintain a bit map for 18 bit UUNS	*)
(*		and change the add back scheme to be a dated list	*)
(*	26Feb86 - jrn							*)
(*	      - add DISK_LOAD_TEST and NO_SUP_UPDATES flags		*)
(*	27Jan86 - jrn							*)
(*	      - change NULL_PROMPT to NULL_STRING			*)
(*	22Jan86 - jrn							*)
(*	      - add master_validator_count,				*)
(*		password_only_validator_count and			*)
(*		licensed_validator_count				*)
(*	10Jan84 - neb							*)
(*	      - add MASTER_VALIDATOR, MAXIMUM_IRC, MASK_0F and		*)
(*	      	conditional assembly parameters 			*)
(*		NO_PASSWORD_ONLY_VALIDATORS and NETVAL_IS_A_SLAVE	*)	
(*	15Aug84 - jrn							*)
(*	      - add conditional assembly parameter			*)
(*		old_list_configuration					*)
(*	      - adjust LOG_MESSAGE_TEXT_MAX for checksum		*)
(*	14Jun84	version 2.02	jrn					*)
(*	      - added UUNSassignable values				*)
(*	      - added UUN_PROMPT					*)
(*	      - added licenses, AUDITOR_LICENSE, OPERATOR_LICENSE,	*)
(*		and DISPLAY_CUD_LICENSE					*)
(*	      - added control bit name messages and OKAY_QUERY		*)
(*	13Jun84 version 2.02	pgl					*)
(*	      - added ASCII_FORM_FEED and minimum constants for HOST,	*)
(*		NODE, DISTRICT and GAN					*)
(*	      - added RANGE						*)
(*	29SEP83 - original from (patrol)globl.ntc and elsewhere - jnm	*)
(*									*)
(************************************************************************)


	(****************************************************************)
	(*								*)
	(*	FORCE APPROPRIATE CONDITIONAL COMPILATION FLAGS HERE.	*)
	(*								*)
	(****************************************************************)


$ifnot no_password_only_validators
(* password_only_validators are allowed to login: ENable allow_password_only *)
$enable allow_password_only
$endif no_password_only_validators

$if global_password_only_login
(* global_password_only_login users are allowed: ENable allow_password_only *)
$enable allow_password_only
$endif global_password_only_login


$ifany (force_password_change, global_password_only_login)
(* GANPASS_FILE_EXISTS should be ENabled *)
$enable ganpass_file_exists
$endif (force_password_change, global_password_only_login)


$ifany (password_expiration_by_user)
(* PASSWORD_EXPIRATION_DATE_IN_CUD should be ENabled *)
$enable password_expiration_date_in_cud
$endif (password_expiration_by_user)


$ifnot BEFORE_SUP_V43
$disable convert_0_to_1
$endif BEFORE_SUP_V43


$if BEFORE_SUP_V43
(* Remove any possible conflicting flags *)
$disable CONVERT_TO_43
$disable INCLUDE_DNIC
$disable REQUEST_AUX_OR_NORMAL_CIRCUIT
$disable REQUEST_COLLECT_CALL
$disable REQUEST_GLOBAL_EXCEPTION
$disable REQUEST_USER_HOST_OK
$disable REQUEST_PRIORITY_STOP
$disable REQUEST_REQUIRE_HOSTNAME
$disable REQUEST_TARGET_PROFILE
$endif BEFORE_SUP_V43

$if disk_maintenance_code
$ifnone BEFORE_SUP_V43
$if CONVERT_TO_MUD_II
$enable CONVERT_TO_43
$enable include_non_dmc
$disable REQUEST_GLOBAL_EXCEPTION
$endif CONVERT_TO_MUD_II

$ifnone CONVERT_TO_MUD_II
$disable CONVERT_TO_43
$disable include_non_dmc
$endif CONVERT_TO_MUD_II
$endif BEFORE_SUP_V43

$endif disk_maintenance_code

$ifnone disk_maintenance_code
$enable include_non_dmc
$disable CONVERT_TO_43
$endif disk_maintenance_code



	(****************************************************************)
	(*								*)
	(*	SUMMARY OF THE SETTING OF ALL CONDITIONAL PARAMETERS.	*)
	(*								*)
	(****************************************************************)

$if ALLOW_LOGON_INHIBIT

	(****************************************************************)
	(*								*)
	(*	ALLOW_LOGON_INHIBIT:   enabled.				*)
	(*								*)
	(****************************************************************)

$endif ALLOW_LOGON_INHIBIT
$ifnone ALLOW_LOGON_INHIBIT

	(****************************************************************)
	(*								*)
	(*	ALLOW_LOGON_INHIBIT:   disabled.			*)
	(*								*)
	(****************************************************************)

$endif ALLOW_LOGON_INHIBIT
$if ALLOW_HOSTS_ON_NO_PASSWORD

	(****************************************************************)
	(*								*)
	(*	ALLOW_HOSTS_ON_NO_PASSWORD:   enabled.			*)
	(*								*)
	(****************************************************************)

$endif ALLOW_HOSTS_ON_NO_PASSWORD
$ifnone ALLOW_HOSTS_ON_NO_PASSWORD

	(****************************************************************)
	(*								*)
	(*	ALLOW_HOSTS_ON_NO_PASSWORD:   disabled.			*)
	(*								*)
	(****************************************************************)

$endif ALLOW_HOSTS_ON_NO_PASSWORD
$if ALLOW_PASSWORD_ONLY

	(****************************************************************)
	(*								*)
	(*	ALLOW_PASSWORD_ONLY:   enabled.				*)
	(*								*)
	(****************************************************************)

$endif ALLOW_PASSWORD_ONLY
$ifnone ALLOW_PASSWORD_ONLY

	(****************************************************************)
	(*								*)
	(*	ALLOW_PASSWORD_ONLY:   disabled.			*)
	(*								*)
	(****************************************************************)

$endif ALLOW_PASSWORD_ONLY
$if ASSIGN_PASSWORD_EXPIRATION_AS_DEFAULT

	(****************************************************************)
	(*								*)
	(*	ASSIGN_PASSWORD_EXPIRATION_AS_DEFAULT:   enabled.	*)
	(*								*)
	(****************************************************************)

$endif ASSIGN_PASSWORD_EXPIRATION_AS_DEFAULT
$ifnone ASSIGN_PASSWORD_EXPIRATION_AS_DEFAULT

	(****************************************************************)
	(*								*)
	(*	ASSIGN_PASSWORD_EXPIRATION_AS_DEFAULT:   disabled.	*)
	(*								*)
	(****************************************************************)

$endif ASSIGN_PASSWORD_EXPIRATION_AS_DEFAULT
$if BEFORE_SUP_V43

	(****************************************************************)
	(*								*)
	(*	BEFORE_SUP_V43:   enabled.				*)
	(*								*)
	(****************************************************************)

$endif BEFORE_SUP_V43
$ifnone BEFORE_SUP_V43

	(****************************************************************)
	(*								*)
	(*	BEFORE_SUP_V43:   disabled.				*)
	(*								*)
	(****************************************************************)

$endif BEFORE_SUP_V43
$if CHANGES_TO_OPER_LOG

	(****************************************************************)
	(*								*)
	(*	CHANGES_TO_OPER_LOG:   enabled.				*)
	(*								*)
	(****************************************************************)

$endif CHANGES_TO_OPER_LOG
$ifnone CHANGES_TO_OPER_LOG

	(****************************************************************)
	(*								*)
	(*	CHANGES_TO_OPER_LOG:   disabled.			*)
	(*								*)
	(****************************************************************)

$endif CHANGES_TO_OPER_LOG
$if CHECK_TIME_STATUS

	(****************************************************************)
	(*								*)
	(*	CHECK_TIME_STATUS:   enabled.				*)
	(*								*)
	(****************************************************************)

$endif CHECK_TIME_STATUS
$ifnone CHECK_TIME_STATUS

	(****************************************************************)
	(*								*)
	(*	CHECK_TIME_STATUS:   disabled.				*)
	(*								*)
	(****************************************************************)

$endif CHECK_TIME_STATUS
$if CONVERT_0_TO_1

	(****************************************************************)
	(*								*)
	(*	CONVERT_0_TO_1:   enabled.				*)
	(*								*)
	(****************************************************************)

$endif CONVERT_0_TO_1
$ifnone CONVERT_0_TO_1

	(****************************************************************)
	(*								*)
	(*	CONVERT_0_TO_1:   disabled.				*)
	(*								*)
	(****************************************************************)

$endif CONVERT_0_TO_1
$if CONVERT_TO_MUD_II

	(****************************************************************)
	(*								*)
	(*	CONVERT_TO_MUD_II:   enabled.				*)
	(*								*)
	(****************************************************************)

$endif CONVERT_TO_MUD_II
$ifnone CONVERT_TO_MUD_II

	(****************************************************************)
	(*								*)
	(*	CONVERT_TO_MUD_II:   disabled.				*)
	(*								*)
	(****************************************************************)

$endif CONVERT_TO_MUD_II
$if DISK_MAINTENANCE_CODE

	(****************************************************************)
	(*								*)
	(*	DISK_MAINTENANCE_CODE:   enabled.			*)
	(*								*)
	(****************************************************************)

$endif DISK_MAINTENANCE_CODE
$ifnone DISK_MAINTENANCE_CODE

	(****************************************************************)
	(*								*)
	(*	DISK_MAINTENANCE_CODE:   disabled.			*)
	(*								*)
	(****************************************************************)

$endif DISK_MAINTENANCE_CODE
$if force_password_change

	(****************************************************************)
	(*								*)
	(*	FORCE_PASSWORD CHANGE:   enabled.			*)
	(*								*)
	(****************************************************************)

$endif FORCE_PASSWORD_CHANGE
$ifnone FORCE_PASSWORD_CHANGE

	(****************************************************************)
	(*								*)
	(*	FORCE_PASSWORD CHANGE:   disabled.			*)
	(*								*)
	(****************************************************************)

$endif FORCE_PASSWORD_CHANGE
$if GANPASS_FILE_EXISTS

	(****************************************************************)
	(*								*)
	(*	GANPASS_FILE_EXISTS:   enabled.				*)
	(*								*)
	(****************************************************************)

$endif GANPASS_FILE_EXISTS
$ifnone GANPASS_FILE_EXISTS

	(****************************************************************)
	(*								*)
	(*	GANPASS_FILE_EXISTS:   disabled.			*)
	(*								*)
	(****************************************************************)

$endif GANPASS_FILE_EXISTS
$if global_password_only_login

	(****************************************************************)
	(*								*)
	(*	GLOBAL_PASSWORD_ONLY:   enabled.			*)
	(*								*)
	(****************************************************************)

$endif GLOBAL_PASSWORD_ONLY_LOGIN
$ifnone global_password_only_login

	(****************************************************************)
	(*								*)
	(*	GLOBAL_PASSWORD_ONLY:   disabled.			*)
	(*								*)
	(****************************************************************)

$endif GLOBAL_PASSWORD_ONLY_LOGIN
$if INCLUDE_DNIC

	(****************************************************************)
	(*								*)
	(*	INCLUDE_DNIC:   enabled.				*)
	(*								*)
	(****************************************************************)

$endif INCLUDE_DNIC
$ifnone INCLUDE_DNIC

	(****************************************************************)
	(*								*)
	(*	INCLUDE_DNIC:   disabled.				*)
	(*								*)
	(****************************************************************)

$endif INCLUDE_DNIC
$if INCLUDE_DUMP

	(****************************************************************)
	(*								*)
	(*	INCLUDE_DUMP:   enabled.				*)
	(*								*)
	(****************************************************************)

$endif INCLUDE_DUMP
$ifnone INCLUDE_DUMP

	(****************************************************************)
	(*								*)
	(*	INCLUDE_DUMP:   disabled.				*)
	(*								*)
	(****************************************************************)

$endif INCLUDE_DUMP
$if INCLUDE_IRC

	(****************************************************************)
	(*								*)
	(*	INCLUDE_IRC:   enabled.					*)
	(*								*)
	(****************************************************************)

$endif INCLUDE_IRC
$ifnone INCLUDE_IRC

	(****************************************************************)
	(*								*)
	(*	INCLUDE_IRC:   disabled.				*)
	(*								*)
	(****************************************************************)

$endif INCLUDE_IRC
$if INCLUDE_LIST_DESCRIPTIONS

	(****************************************************************)
	(*								*)
	(*	INCLUDE_LIST_DESCRIPTIONS:   enabled.			*)
	(*								*)
	(****************************************************************)

$endif INCLUDE_LIST_DESCRIPTIONS
$ifnone INCLUDE_LIST_DESCRIPTIONS

	(****************************************************************)
	(*								*)
	(*	INCLUDE_LIST_DESCRIPTIONS:   disabled.			*)
	(*								*)
	(****************************************************************)

$endif INCLUDE_LIST_DESCRIPTIONS
$if LOGICAL_VOLUMES

	(****************************************************************)
	(*								*)
	(*	LOGICAL_VOLUMES:   enabled.				*)
	(*								*)
	(****************************************************************)

$endif LOGICAL_VOLUMES
$ifnone LOGICAL_VOLUMES

	(****************************************************************)
	(*								*)
	(*	LOGICAL_VOLUMES:   disabled.				*)
	(*								*)
	(****************************************************************)

$endif LOGICAL_VOLUMES
$if NAME_LEGAL_PASSWORD

	(****************************************************************)
	(*								*)
	(*	NAME_LEGAL_PASSWORD:   enabled.				*)
	(*								*)
	(****************************************************************)

$endif NAME_LEGAL_PASSWORD
$ifnone NAME_LEGAL_PASSWORD

	(****************************************************************)
	(*								*)
	(*	NAME_LEGAL_PASSWORD:   disabled.			*)
	(*								*)
	(****************************************************************)

$endif NAME_LEGASWORD
$if NETVAL_IS_A_SLAVE

	(****************************************************************)
	(*								*)
	(*	NETVAL_IS_A_SLAVE:   enabled.				*)
	(*								*)
	(****************************************************************)

$endif NETVAL_IS_A_SLAVE
$ifnone NETVAL_IS_A_SLAVE

	(****************************************************************)
	(*								*)
	(*	NETVAL_IS_A_SLAVE:   disabled.				*)
	(*								*)
	(****************************************************************)

$endif NETVAL_IS_A_SLAVE
$if NETVAL_IS_BOTH

	(****************************************************************)
	(*								*)
	(*	NETVAL_IS_BOTH:   enabled.				*)
	(*								*)
	(****************************************************************)

$endif NETVAL_IS_BOTH
$ifnone NETVAL_IS_BOTH

	(****************************************************************)
	(*								*)
	(*	NETVAL_IS_BOTH:   disabled.				*)
	(*								*)
	(****************************************************************)

$endif NETVAL_IS_BOTH

	(****************************************************************)
	(*								*)
	(*	NEW_LIST_CONFIGURATION: set for NVDM in LISUTA.NTI.	*)
	(*								*)
	(****************************************************************)

$if NO_PASSWORD_ONLY_VALIDATORS

	(****************************************************************)
	(*								*)
	(*	NO_PASSWORD_ONLY_VALIDATORS:   enabled.			*)
	(*								*)
	(****************************************************************)

$endif NO_PASSWORD_ONLY_VALIDATORS
$ifnone NO_PASSWORD_ONLY_VALIDATORS

	(****************************************************************)
	(*								*)
	(*	NO_PASSWORD_ONLY_VALIDATORS:   disabled.		*)
	(*								*)
	(****************************************************************)

$endif NO_PASSWORD_ONLY_VALIDATORS
$if change_by_whom
"added nsp by SHSUE at 24-Jul-87 15:20:38"
$endif
$if no_self_password_change

	(****************************************************************)
	(*								*)
	(*	NO_SELF_PASSWORD_CHANGE:   enabled.			*)
	(*								*)
	(****************************************************************)

$endif no_self_password_change
$ifnone no_self_password_change

	(****************************************************************)
	(*								*)
	(*	NO_SELF_PASSWORD_CHANGE:   disabled.			*)
	(*								*)
	(****************************************************************)

$endif no_self_password_change

	(****************************************************************)
	(*								*)
	(*	OLD_LIST_CONFIGURATION: set for NVDM in LISUTA.NTI.	*)
	(*								*)
	(****************************************************************)

$if OVERFLOW_CUD_ENTRIES

	(****************************************************************)
	(*								*)
	(*	OVERFLOW_CUD_ENTRIES:   enabled.			*)
	(*								*)
	(****************************************************************)

$endif OVERFLOW_CUD_ENTRIES
$ifnone OVERFLOW_CUD_ENTRIES

	(****************************************************************)
	(*								*)
	(*	OVERFLOW_CUD_ENTRIES:   disabled.			*)
	(*								*)
	(****************************************************************)

$endif OVERFLOW_CUD_ENTRIES
$if PASSWORD_EXPIRATION_BY_USER

	(****************************************************************)
	(*								*)
	(*	PASSWORD_EXPIRATION_BY_USER:   enabled.			*)
	(*								*)
	(****************************************************************)

$endif PASSWORD_EXPIRATION_BY_USER
$ifnone PASSWORD_EXPIRATION_BY_USER

	(****************************************************************)
	(*								*)
	(*	PASSWORD_EXPIRATION_BY_USER:   disabled.		*)
	(*								*)
	(****************************************************************)

$endif PASSWORD_EXPIRATION_BY_USER
$if PASSWORD_EXPIRATION_DATE_IN_CUD

	(****************************************************************)
	(*								*)
	(*	PASSWORD_EXPIRATION_DATE_IN_CUD:   enabled.		*)
	(*								*)
	(****************************************************************)

$endif PASSWORD_EXPIRATION_DATE_IN_CUD
$ifnone PASSWORD_EXPIRATION_DATE_IN_CUD

	(****************************************************************)
	(*								*)
	(*	PASSWORD_EXPIRATION_DATE_IN_CUD:   disabled.		*)
	(*								*)
	(****************************************************************)

$endif PASSWORD_EXPIRATION_DATE_IN_CUD
$if PREVENT_DUPLICATE_PASSWORDS

	(****************************************************************)
	(*								*)
	(*	PREVENT_DUPLICATE_PASSWORDS:   enabled.			*)
	(*								*)
	(****************************************************************)

$endif PREVENT_DUPLICATE_PASSWORDS
$ifnone PREVENT_DUPLICATE_PASSWORDS

	(****************************************************************)
	(*								*)
	(*	PREVENT_DUPLICATE_PASSWORDS:   disabled.		*)
	(*								*)
	(****************************************************************)

$endif PREVENT_DUPLICATE_PASSWORDS
$if REQUEST_AUX_OR_NORMAL_CIRCUIT

	(****************************************************************)
	(*								*)
	(*	REQUEST_AUX_OR_NORMAL_CIRCUIT:   enabled.		*)
	(*								*)
	(****************************************************************)

$endif REQUEST_AUX_OR_NORMAL_CIRCUIT
$ifnone REQUEST_AUX_OR_NORMAL_CIRCUIT

	(****************************************************************)
	(*								*)
	(*	REQUEST_AUX_OR_NORMAL_CIRCUIT:   disabled.		*)
	(*								*)
	(****************************************************************)

$endif REQUEST_AUX_OR_NORMAL_CIRCUIT
$if REQUEST_COLLECT_CALL

	(****************************************************************)
	(*								*)
	(*	REQUEST_COLLECT_CALL:   enabled.			*)
	(*								*)
	(****************************************************************)

$endif REQUEST_COLLECT_CALL
$ifnone REQUEST_COLLECT_CALL

	(****************************************************************)
	(*								*)
	(*	REQUEST_COLLECT_CALL:   disabled.			*)
	(*								*)
	(****************************************************************)

$endif REQUEST_COLLECT_CALL
$if REQUEST_GLOBAL_EXCEPTION

	(****************************************************************)
	(*								*)
	(*	REQUEST_GLOBAL_EXCEPTION:   enabled.			*)
	(*								*)
	(****************************************************************)

$endif REQUEST_GLOBAL_EXCEPTION
$ifnone REQUEST_GLOBAL_EXCEPTION

	(****************************************************************)
	(*								*)
	(*	REQUEST_GLOBAL_EXCEPTION:   disabled.			*)
	(*								*)
	(****************************************************************)

$endif REQUEST_GLOBAL_EXCEPTION
$if REQUEST_USER_HOST_OK

	(****************************************************************)
	(*								*)
	(*	REQUEST_USER_HOST_OK:   enabled.			*)
	(*								*)
	(****************************************************************)

$endif REQUEST_USER_HOST_OK
$ifnone REQUEST_USER_HOST_OK

	(****************************************************************)
	(*								*)
	(*	REQUEST_USER_HOST_OK:   disabled.			*)
	(*								*)
	(****************************************************************)

$endif REQUEST_USER_HOST_OK
$if REQUEST_PRIORITY_STOP

	(****************************************************************)
	(*								*)
	(*	REQUEST_PRIORITY_STOP:   enabled.			*)
	(*								*)
	(****************************************************************)

$endif REQUEST_PRIORITY_STOP
$ifnone REQUEST_PRIORITY_STOP

	(****************************************************************)
	(*								*)
	(*	REQUEST_PRIORITY_STOP:   disabled.			*)
	(*								*)
	(****************************************************************)

$endif REQUEST_PRIORITY_STOP
$if REQUEST_REQUIRE_HOSTNAME

	(****************************************************************)
	(*								*)
	(*	REQUEST_REQUIRE_HOSTNAME:   enabled.			*)
	(*								*)
	(****************************************************************)

$endif REQUEST_REQUIRE_HOSTNAME
$ifnone REQUEST_REQUIRE_HOSTNAME

	(****************************************************************)
	(*								*)
	(*	REQUEST_REQUIRE_HOSTNAME:   disabled.			*)
	(*								*)
	(****************************************************************)

$endif REQUEST_REQUIRE_HOSTNAME
$if REQUEST_TARGET_PROFILE

	(****************************************************************)
	(*								*)
	(*	REQUEST_TARGET_PROFILE:   enabled.			*)
	(*								*)
	(****************************************************************)

$endif REQUEST_TARGET_PROFILE
$ifnone REQUEST_TARGET_PROFILE

	(****************************************************************)
	(*								*)
	(*	REQUEST_TARGET_PROFILE:   disabled.			*)
	(*								*)
	(****************************************************************)

$endif REQUEST_TARGET_PROFILE
$if REQUEST_FPC_START

	(****************************************************************)
	(*								*)
	(*	REQUEST_FPC_START:   enabled.				*)
	(*								*)
	(****************************************************************)

$endif REQUEST_FPC_START
$ifnone REQUEST_FPC_START

	(****************************************************************)
	(*								*)
	(*	REQUEST_FPC_START :   disabled.				*)
	(*								*)
	(****************************************************************)

$endif REQUEST_FPC_START
$if REUSE_UUNS

	(****************************************************************)
	(*								*)
	(*	REUSE_UUNS:   enabled.					*)
	(*								*)
	(****************************************************************)

$endif REUSE_UUNS
$ifnone REUSE_UUNS

	(****************************************************************)
	(*								*)
	(*	REUSE_UUNS:   disabled.					*)
	(*								*)
	(****************************************************************)

$endif REUSE_UUNS
$if UPDATE_CUD_ON_CHANGE_FAIL

	(****************************************************************)
	(*								*)
	(*	UPDATE_CUD_ON_CHANGE_FAIL:   enabled.			*)
	(*								*)
	(****************************************************************)

$endif UPDATE_CUD_ON_CHANGE_FAIL
$ifnone UPDATE_CUD_ON_CHANGE_FAIL

	(****************************************************************)
	(*								*)
	(*	UPDATE_CUD_ON_CHANGE_FAIL:   disabled.			*)
	(*								*)
	(****************************************************************)

$endif UPDATE_CUD_ON_CHANGE_FAIL
$if UUNSassignable_by_user

	(****************************************************************)
	(*								*)
	(*      UUNSassignable_by_user:   enabled.      	        *)
	(*								*)
	(****************************************************************)

$enable UUNSassignable
$endif UUNSassignable_by_user
$ifnone UUNSassignable_by_user

	(****************************************************************)
	(*								*)
	(*	UUNSassignable_by_user:   disabled.			*)
	(*								*)
	(****************************************************************)

$disable UUNSassignable
$endif UUNSassignable_by_user
$if VALIDATE_X25_NAMES

	(****************************************************************)
	(*								*)
	(*	VALIDATE_X25_NAMES:   enabled.				*)
	(*								*)
	(****************************************************************)

$endif VALIDATE_X25_NAMES
$ifnone VALIDATE_X25_NAMES

	(****************************************************************)
	(*								*)
	(*	VALIDATE_X25_NAMES:   disabled.				*)
	(*								*)
	(****************************************************************)

$endif VALIDATE_X25_NAMES
$if DISK_LOAD_TEST

	(****************************************************************)
	(*								*)
	(*	DISK_LOAD_TEST:   enabled.				*)
	(*								*)
	(****************************************************************)

$endif DISK_LOAD_TEST
$ifnone DISK_LOAD_TEST

	(****************************************************************)
	(*								*)
	(*	DISK_LOAD_TEST:   disabled.				*)
	(*								*)
	(****************************************************************)

$endif DISK_LOAD_TEST
$if NO_SUP_UPDATES

	(****************************************************************)
	(*								*)
	(*	NO_SUP_UPDATES:   enabled.				*)
	(*								*)
	(****************************************************************)

$endif NO_SUP_UPDATES
$ifnone NO_SUP_UPDATES

	(****************************************************************)
	(*								*)
	(*	NO_SUP_UPDATES:   disabled.				*)
	(*								*)
	(****************************************************************)

$endif NO_SUP_UPDATES
$if SPECIAL

	(****************************************************************)
	(*								*)
	(*	SPECIAL:   enabled.					*)
	(*								*)
	(****************************************************************)

$endif SPECIAL
$ifnone SPECIAL

	(****************************************************************)
	(*								*)
	(*	SPECIAL:   disabled.					*)
	(*								*)
	(****************************************************************)

$endif SPECIAL



const

$ifnone old_list_configuration
  MAX_INTEGER = 2147483647;
  MIN_INTEGER = -max_integer - 1;

  SECONDS_PER_HOUR = 3600;
  MINUTES_PER_DAY = 1440;
  SECONDS_PER_DAY = 86400;

  BASE_YEAR = 1974 (* base year for Engine dates *);



  BIT0 = -1 - max_integer	(* DECIMAL VALUE OF WORD WITH BIT 0 ON *);
  BIT1 = 1073741824	(* DECIMAL VALUE OF WORD WITH BIT 1 ON *);
  BIT2 = 536870912	(* DECIMAL VALUE OF WORD WITH BIT 2 ON *);
  BIT3 = 268435456	(* DECIMAL VALUE OF WORD WITH BIT 3 ON *);
  BIT4 = 134217728	(* DECIMAL VALUE OF WORD WITH BIT 4 ON *);
  BIT5 = 67108864	(* DECIMAL VALUE OF WORD WITH BIT 5 ON *);
  BIT6 = 33554432	(* DECIMAL VALUE OF WORD WITH BIT 6 ON *);
  BIT7 = 16777216	(* DECIMAL VALUE OF WORD WITH BIT 7 ON *);
  BIT8 = 8388608	(* DECIMAL VALUE OF WORD WITH BIT 8 ON *);
  BIT9 = 4194304	(* DECIMAL VALUE OF WORD WITH BIT 9 ON *);
  BIT10 = 2097152	(* DECIMAL VALUE OF WORD WITH BIT 10 ON *);
  BIT11 = 1048576	(* DECIMAL VALUE OF WORD WITH BIT 11 ON *);
  BIT12 = 524288	(* DECIMAL VALUE OF WORD WITH BIT 12 ON *);
  BIT13 = 262144	(* DECIMAL VALUE OF WORD WITH BIT 13 ON *);
  BIT14 = 131072	(* DECIMAL VALUE OF WORD WITH BIT 14 ON *);
  BIT15 = 65536		(* DECIMAL VALUE OF WORD WITH BIT 15 ON *);
  BIT16 = 32768	(* DECIMAL VALUE OF WORD WITH BIT 16 ON *);
  BIT17 = 16384	(* DECIMAL VALUE OF WORD WITH BIT 17 ON *);
  BIT18 = 8192	(* DECIMAL VALUE OF WORD WITH BIT 18 ON *);
  BIT19 = 4096	(* DECIMAL VALUE OF WORD WITH BIT 19 ON *);
  BIT20 = 2048	(* DECIMAL VALUE OF WORD WITH BIT 20 ON *);
  BIT21 = 1024 	(* DECIMAL VALUE OF WORD WITH BIT 21 ON *);
  BIT22 = 512	(* DECIMAL VALUE OF WORD WITH BIT 22 ON *);
  BIT23 = 256	(* DECIMAL VALUE OF WORD WITH BIT 23 ON *);
  BIT24 = 128	(* DECIMAL VALUE OF WORD WITH BIT 24 ON *);
  BIT25 = 64	(* DECIMAL VALUE OF WORD WITH BIT 25 ON *);
  BIT26 = 32	(* DECIMAL VALUE OF WORD WITH BIT 26 ON *);
  BIT27 = 16	(* DECIMAL VALUE OF WORD WITH BIT 27 ON *);
  BIT28 = 8	(* DECIMAL VALUE OF WORD WITH BIT 28 ON *);
  BIT29 = 4	(* DECIMAL VALUE OF WORD WITH BIT 29 ON *);
  BIT30 = 2	(* DECIMAL VALUE OF WORD WITH BIT 29 ON *);
  BIT31 = 1	(* DECIMAL VALUE OF WORD WITH BIT 31 ON *);
!
  MASK_0F = 15				(* right-most 4 bits only *);
  MASK_3F = 63				(* right-most 6 bits only *);
  MASK_7F = 127				(* right-most 7 bits only *);
  MASK_0F0 = 240;
  MASK_0FF = 255			(* right most 8 bits only *);
  MASK_3FF = 1023			(* right-most 10 bits only *);
  MASK_0FFF = 4095			(* right-most 12 bits only *);
  MASK_0FF_FFFF = 16777215		(* right-most 24 bits only *);
  MASK_0FF00_0000 = -1 - mask_0ff_ffff	(* left-most 8 bits only *);
  MASK_0FFFF_F000 = -1 - mask_0fff	(* left-most 20 bits only *);
  MASK_3F3F3F3F = 1061109567		(* hash mask *);
!
  PAD_CHAR = '(:255:)'			(* pad character *);

$endif old_list_configuration
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  ZERO = '(:0:)';
  ONE = '(:1:)';
!
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone old_list_configuration
(***********************************************************************)
(*                                                                     *)
(*       ascii characters used by system			       *)
(*                                                                     *)
(***********************************************************************)

const
  ASCII_FORM_FEED = '(:12:)';
  ASCII_LINE_FEED = '(:10:)';
  ASCII_CARRIAGE_RETURN = '(:13:)';

  ASCII_ZERO = '0';
  ASCII_NINE = '9';

  ASCII_A = 'A';
  ASCII_F = 'F';
  ASCII_Z = 'Z';

  ASCII_AMPERSAND = '&';
  ASCII_COLON = ':';
  ASCII_COMMA = ',';
  ASCII_DOT = '.';
  ASCII_LEFT_PARENS = '(';
  ASCII_MINUS = '-';
  ASCII_PLUS = '+';
  ASCII_RIGHT_PARENS = ')';
  ASCII_SEMI_COLON = ';';
  ASCII_SINGLE_QUOTE = '(:39:)';
  ASCII_SLASH = '/';
  ASCII_SPACE = ' ';

  END_MESSAGE_CHARACTER = '\'		(* end of message character *);
  ESCAPE = '(:27:)';

  LOWER_CASE_A = 'a';
  LOWER_CASE_S = 's';
  LOWER_CASE_Z = 'z';
!
(*	Global ASCII strings	*)

(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code
  ACCOUNT_SUPERVISOR_MESSAGE = 'account supervisor\ ';
  AUDITOR_MESSAGE = 'auditor\';
$endif disk_maintenance_code
(*      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-  *)
  BY_MESSAGE = ' by \ ';
  CHECKSUM_ERROR = 'checksum error\ ';
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code   CLASS_MESSAGE = 'class \ ';
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  COMMA_SPACE = ', \ ';
  COMPLETE_MESSAGE = 'complete\ ';
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if CHECK_TIME_STATUS
$ifnone disk_maintenance_code
  CONFIRM_MESSAGE = 'please confirm:\';
$endif disk_maintenance_code
$endif CHECK_TIME_STATUS
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  CONTINUE_MESSAGE = 'continue\ ';
  CUD_FILE_MESSAGE = 'CUD\';
  CUD_FILE_BUSY = 'CUD file busy\';
  DAYS_MESSAGE = ' days\';
  DISK_READ_ERROR_MESSAGE = 'disk read error\';
  DISK_WRITE_ERROR_MESSAGE = 'disk write error\ ';
$if INCLUDE_DNIC
  DNIC_FILE_MESSAGE = 'DNIC\ ';
  DNIC_FILE_BUSY = 'DNIC file busy\ ';
$endif INCLUDE_DNIC
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if logical_volumes   DRIVE_MESSAGE =  'drive \ ';
$if password_expiration_date_in_cud   EXPIRED_MESSAGE = ' (expired)\ ';
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  ENTRY_BUSY = 'entry is being modified\';
  ENTRY_COMPLETED = 'entry completed\';
  FORMAT_ERROR = 'format error\ ';
  FPC_EXEMPT_MESSAGE = 'force password change exempt\ ';
  GAN_PROMPT = 'GAN: \';
  GROUP_MESSAGE = 'group \ ';
$if global_password_only_login  GPO_MESSAGE = 'global password only\ ';
  HANDSHAKE_ERROR = 'handshake failed\ ';
$ifnone BEFORE_SUP_V43  VERSION_ERROR = 'incorrect supervisor version\ ';
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code
  DEST_MESSAGE = 'destination\';
  HOST_MESSAGE = 'host\ ';
  IGNORE_DESTINATION_MESSAGE = 'ignore destination\ ';
  LICENSED_MESSAGE = 'licensed\ ';
  LIST_MESSAGE = 'list\ ';
$endif disk_maintenance_code
  MANUAL_MESSAGE = 'manual \';
$ifnone disk_maintenance_code
$if NETVAL_IS_A_SLAVE   MASTER_MESSAGE = 'master\ ';
  MUD_FILE_MESSAGE = 'MUD\';
  NETVAL_WELCOME_MESSAGE = 'NETVAL - Version \';
  NETWORK_ADMINISTRATOR_MESSAGE = 'network administrator\';
$endif disk_maintenance_code
  NO_MESSAGE = 'no\ ';
$ifnone disk_maintenance_code   NODE_MESSAGE = 'node\ ';
$if no_self_password_change   NSP_CHANGE_MESSAGE = 'no self password change\';
  NULL_STRING = '\ ';
  OKAY_QUERY = 'okay\ ';
  OPERATOR_MESSAGE = 'operator\ ';
  PASSWORD_MESSAGE = 'password:\';
$ifany (password_expiration_date_in_cud, force_password_change)
  PASSWORD_EXPIRES_MESSAGE = 'password expires: \ ';
$endif (password_expiration_date_in_cud, force_password_change)
  PASSWORD_ERROR = 'password error\ ';
  PASSWORD_ONLY_MESSAGE = 'password only\';
$ifany (force_password_change, password_expiration_by_user) 
  PASSWORD_VALIDITY_PERIOD_IN_DAYS_MESSAGE =
    'password validity period, in days: \';
  PASSWORD_VALIDITY_PERIOD_MESSAGE = 'password validity period \';
$endif (force_password_change, password_expiration_by_user) 
$if prevent_duplicate_passwords
  PREVIOUS_PASSWORD_MESSAGE = 'new password matches previous password\ ';
$endif prevent_duplicate_passwords
  PROGRAMMER_MESSAGE = 'programmer\ ';
  READING_MESSAGE = 'reading\';
$ifnone disk_maintenance_code   SHUT_OVERRIDE_MESSAGE = 'shut override\';
$if password_expiration_by_user
  STANDARD_PASSWORD_VALIDITY_PERIOD_IN_DAYS_MESSAGE =
    'standard password validity period, in days: \ ';
$endif password_expiration_by_user
  SUPERVISOR_MESSAGE = 'Supervisor \';
$if prevent_duplicate_passwords
  THE_MINIMUM_PASSWORD_CHANGE_TIME_MESSAGE =
    'the minimum password change time \';
$endif prevent_duplicate_passwords
$if password_expiration_by_user
  THE_STANDARD_PASSWORD_VALIDITY_PERIOD_MESSAGE =
    'the standard password validity period \ ';
$endif password_expiration_by_user
  TRANSPARENT_LOGIN_MESSAGE = 'transparent login\';
$ifnot BEFORE_SUP_V43  USERNAME_QUERY = 'name: \ ';
$if BEFORE_SUP_V43  USERNAME_QUERY = 'username: \ ';
  UTC_MESSAGE = ' UTC\ ';
  UUN_PROMPT = 'UUN: \';
  UNKNOWN_MESSAGE = 'unknown      \';
$if CHECK_TIME_STATUS
  WARNING_MESSAGE = '***** WARNING! ***** WARNING! ***** WARNING! *****\ ';
$endif CHECK_TIME_STATUS
  WRITE_PROTECTED_MESSAGE = 'unit is write protected\';
  WRITING_MESSAGE = 'writing\';
  YES_MESSAGE = 'yes\';
$endif old_list_configuration
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
(*	A maximum set of integers from 0-255. Other sets are defined	*)
(*	in terms of this basic set.					*)

const
  BASIC_SET_MAX = 256 (* maximum cardinality *);
  BASIC_SET_LIMIT = basic_set_max - 1;

type
  BASIC_SET_INDEX = 0..basic_set_limit;
  BASIC_SET_SIZE = 0..basic_set_max;

type
  BASIC_SET = set of basic_set_index;

const
  BASIC_SET_SIZE_IN_BYTES = basic_set_max div 8;



(**** A halfword viewed as an array of characters. ****)
const
  MAXIMUM_CHARS_IN_HALFWORD = 2;
  HALFWORD_CHARS_LIMIT = maximum_chars_in_halfword - 1;

type
  HALFWORD_INDEX = 0..halfword_chars_limit;
  HALFWORD_SIZE = 0..maximum_chars_in_halfword;

  HALFWORD = array [halfword_index] of char;



(**** A word viewed as an array of charaters. ****)
const
  MAXIMUM_BYTES_IN_WORD = 4;
  WORD_IN_BYTES_LIMIT = maximum_bytes_in_word - 1;

type
  WORD_IN_BYTES_INDEX = 0..word_in_bytes_limit;
  WORD_SIZE = 0..maximum_bytes_in_word;

  WORD_IN_BYTES = array [word_in_bytes_index] of char;



(**** A word viewed as an array of halfwords. ****)
const
  MAXIMUM_HALFWORDS_IN_WORD = 2;
  WORD_IN_HALFWORDS_LIMIT = maximum_halfwords_in_word - 1;

type
  WORD_IN_HALFWORDS_INDEX = 0..word_in_halfwords_limit;

  WORD_IN_HALFWORDS = array [word_in_halfwords_index] of halfword;

const
  ZERO_HALFWORD = '(:0:)(:0:)';
!
(*    The unit of disk i/o is the page:    *)

const
  PAGE_SIZE = 256 (* bytes *);
  PAGE_LIMIT = page_size - 1;


type
  PAGE_LENGTH = 0..page_size;
  PAGE_INDEX = 0..page_limit;

  PAGE = array [page_index] of char;


const
  PG_DATA_LIMIT = page_size - maximum_bytes_in_word - 1;

type
  PG_DATA_INDEX = 0..pg_data_limit;

  PAGE_RECORD = record
    data	: array [pg_data_index] of char;
    checksum	: integer
  end (* page_record *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if reuse_uuns
!


(* Bit map definitions *)
const
  BITS_PER_WORD = 32;
  BITS_PER_PAGE = (page_size div maximum_bytes_in_word) * bits_per_word;

  MAX_BIT_VALUES_PER_PAGE = bits_per_page - bits_per_word (* page-checksum *);
  BIT_VALUES_PER_PAGE_LIMIT = max_bit_values_per_page - 1;

  MAP_MAX = bits_per_page div basic_set_max (* sets per page *);
  MAP_LIMIT = map_max - 1;

type
  MAP_INDEX = 0 .. map_limit;
  BIT_MAP_PAGE = array [map_index] of set of basic_set_index;
$endif reuse_uuns
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(* A range of integers; can be used as a single value if first=last *)
type
  RANGE = record
    first,
    last : integer
  end (* range *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if logical_volumes


(* time expressed in hours and minutes * 100 *)
(* used for passing logical volume drive age *)

type
  LOGICAL_VOLUME_AGE = record
    hours		: integer;
    scaled_minutes	: integer
  end (* logical_volume_age *);
$endif logical_volumes
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone old_list_configuration

(* Define various network values *)

const
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if UUNSassignable
  uun_radix = assign_uun_radix;
  minimum_uun = assign_minimum_uun;
  maximum_uun = assign_maximum_uun;
$endif UUNSassignable
$ifnone UUNSassignable
  uun_radix = 8;
  minimum_uun = 1;
  maximum_uun = BIT7 - 1 (* 24 bits only *);
$endif UUNSassignable


  MINIMUM_GAN = 1;
  MAXIMUM_GAN = BIT7 - 1 (* 24 bits only *);




(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone NETVAL_IS_A_SLAVE   MINIMUM_DISTRICT = 1 (* max in config file *);
$if NETVAL_IS_A_SLAVE  MINIMUM_DISTRICT = 0 (* max in config file *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)


  MINIMUM_NODE = 1 (* maximum defined in configuration file *);
  MINIMUM_HOST = 1 (* maximum defined in configuration file *);


  MINIMUM_IRC = 0;
  MAXIMUM_IRC = 15;
!
(*	Define Validator Values and Licenses.*)

type

  IRC_NUMBER = minimum_irc..maximum_irc;

(* define all possible types of validators *)
  VALIDATOR_TYPE = (
$if global_password_only_login        gpo_validator (* GAN change password *),
	password_only_validator		(* can change password only *),
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if NETVAL_IS_A_SLAVE 	master_validator  (* changes over a circuit *),
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	account_supervisor_validator	(* can affect users in own GAN *),
	network_administrator_validator	(* can affect all users	*),
	programmer_validator		(* can do ANYTHING *));


  COMMAND_LICENSE = (
	no_license		(* anyone can execute command *),
	auditor_license		(* can display ANYTHING *),
	display_cud_license	(* can access CUD display commands *),
	account_supervisor_license	(* can modify other users in GAN *),
	network_administrator_license	(* can do any validation *),
	operator_license		(* can do operational things *),
	programmer_license		(* can do ANYTHING *));


const
  FIRST_VALIDATOR_LICENSE = auditor_license;
  LAST_VALIDATOR_LICENSE =  programmer_license;


type
  VALIDATOR_LICENSE = FIRST_VALIDATOR_LICENSE..LAST_VALIDATOR_LICENSE;

  VALIDATOR_LICENSE_SET = set of validator_license;
!
(****************************************************************)
(*								*)
(* Define the number and indices for each type of validator.	*)
(* The order of the validator definitions are:			*)
(*		password only validators, if any		*)
(*		master validators, if any			*)
(*		interactive licensed validators			*)
(*								*)
(****************************************************************)

const	 (* Validators who may change their own password only: *)
  FIRST_PASSWORD_ONLY_VALIDATOR = 0;

(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnot allow_password_only   MAXIMUM_PASSWORD_ONLY_VALIDATORS = 0;

$if allow_password_only
  MAXIMUM_PASSWORD_ONLY_VALIDATORS = NUMBER_OF_PASSWORD_ONLY_VALIDATORS;
  PASSWORD_ONLY_VALIDATOR_LIMIT = maximum_password_only_validators - 1;


type
  PASSWORD_ONLY_VALIDATOR_COUNT = 0..NUMBER_OF_PASSWORD_ONLY_VALIDATORS;
  PASSWORD_ONLY_VALIDATOR_INDEX =
	first_password_only_validator..password_only_validator_limit;
$endif allow_password_only
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
(*	Some general validator definitions.	*)

const
  FIRST_VALIDATOR = first_password_only_validator;


(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if NETVAL_IS_A_SLAVE   MAXIMUM_MASTER_VALIDATORS=number_of_master_validators;
$ifnone NETVAL_IS_A_SLAVE   MAXIMUM_MASTER_VALIDATORS = 0;
(*      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-    *)

  MAXIMUM_VALIDATOR =
    maximum_password_only_validators + maximum_master_validators
      + maximum_licensed_validators;

  VALIDATOR_LIMIT = maximum_validator - 1;


(* define indices for all types of validator *)

type
  VALIDATOR_INDEX = first_validator..validator_limit;

(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if NETVAL_IS_A_SLAVE
const
  FIRST_MASTER_VALIDATOR = maximum_password_only_validators;
  MASTER_VALIDATOR_LIMIT =
    first_master_validator + maximum_master_validators - 1;

(* define indices for all types of validator when NETVAL_IS_A_SLAVE *)
type
  MASTER_VALIDATOR_COUNT = 0..MAXIMUM_MASTER_VALIDATORS;
  MASTER_VALIDATOR_INDEX = first_master_validator..master_validator_limit;
$endif NETVAL_IS_A_SLAVE
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
const
  FIRST_LICENSED_VALIDATOR =
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if NETVAL_IS_A_SLAVE 
    maximum_password_only_validators + maximum_master_validators;
$endif NETVAL_IS_A_SLAVE
$ifnone NETVAL_IS_A_SLAVE     maximum_password_only_validators;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

  LICENSED_VALIDATOR_LIMIT = validator_limit;

type
  LICENSED_VALIDATOR_COUNT = 0..MAXIMUM_LICENSED_VALIDATORS;
  LICENSED_VALIDATOR_INDEX =
    first_licensed_validator..licensed_validator_limit;


const
  MAXIMUM_NON_PASSWORD_ONLY_VALIDATORS =
    maximum_validator - maximum_password_only_validators;

  FIRST_NON_PASSWORD_ONLY_VALIDATOR = maximum_password_only_validators;
  LAST_NON_PASSWORD_ONLY_VALIDATOR = validator_limit;

type
  NON_PASSWORD_ONLY_VALIDATOR_INDEX =
    first_non_password_only_validator..last_non_password_only_validator;
!
(* the following are used to perform boolean operations    *)
(* on integer values...the integers to be operated on      *)
(* are stored in an integer_array, a procedure is called   *)
(* that treats the array as a a character_set and performs *)
(* the boolean operation on the set, then the integers     *)
(* are extracted from the resulting integer_array.         *)

type
  INTEGER_ARRAY = array [0..7] of integer;

  CHARACTER_SET = set of char;
!
(* This is a string which is ended with an end_message_character	*)
(* character...used to pass string constants in procedure calls.	*)

const
  QUOTED_TEXT_MAX = 80 (* characters *);
  QUOTED_TEXT_LIMIT = quoted_text_max - 1;

type
  QUOTED_TEXT_INDEX = 0..quoted_text_limit;

  QUOTED_TEXT = array [quoted_text_index] of char;
$endif old_list_configuration
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone old_list_configuration
!
(*	Format buffer for internal_to_string output.	*)

const
  FORMAT_BUFFER_TEXT_MAX = 160 (* characters *);
  FORMAT_BUFFER_TEXT_LIMIT = format_buffer_text_max - 1;

type
  FORMAT_BUFFER_TEXT_INDEX = 0..format_buffer_text_limit;
  FORMAT_BUFFER_TEXT_SIZE = 0..format_buffer_text_max;

  FORMAT_BUFFER_TEXT = array [format_buffer_text_index] of char;

  FORMAT_BUFFER = record
    size: format_buffer_text_size;
    text: format_buffer_text
  end (* format_buffer *);
!
(*	Command line input.		*)
(*	This is the standard command input line, processed by the	*)
(*	the command scanner.						*)

const
  COMMAND_LINE_TEXT_MAX = 80 (* characters *);
  COMMAND_LINE_TEXT_LIMIT = command_line_text_max - 1;

type
  COMMAND_LINE_TEXT_INDEX = 0..command_line_text_limit;
  COMMAND_LINE_TEXT_SIZE = 0..command_line_text_max;

  COMMAND_LINE_TEXT = array [command_line_text_index] of char;

  COMMAND_LINE = record
    size: command_line_text_size;
    text: command_line_text
  end (* command_line *);
!
(* Definition of prompts for various command classes *)

const
  COMMAND_PROMPT_TEXT_MAX = 8 (* characters *);
  COMMAND_PROMPT_TEXT_LIMIT = command_prompt_text_max - 1;

type
  COMMAND_PROMPT_TEXT_INDEX = 0..command_prompt_text_limit;
  COMMAND_PROMPT_TEXT_SIZE = 0..command_prompt_text_max;

  COMMAND_PROMPT = array [command_prompt_text_index] of char;
!
(*	Define an all purpose list to perform I/O	*)

const
(* max is greatest number of "number," strings to fit on an input line *)
  MAXIMUM_GENERAL_NUMBER_LIST_SIZE = 20 (* number of command freewords *);
  GENERAL_NUMBER_LIST_SIZE_LIMIT = maximum_general_number_list_size - 1;

type
  GENERAL_NUMBER_LIST_SIZE = 0..maximum_general_number_list_size;
  GENERAL_NUMBER_LIST_INDEX = 0..general_number_list_size_limit;

  GENERAL_NUMBER_LIST = record
    size : general_number_list_size;
    list : array [general_number_list_index] of integer
  end (* general_number_list *);



$if disk_maintenance_code
(*	Define an all purpose list of ranges for	*)
(*	input in SET VALIDITY GAN command.		*)

const
(* the max number of ranges in the array *)
  MAXIMUM_ARRAY_OF_RANGES = 10;
  ARRAY_OF_RANGES_LIMIT = maximum_array_of_ranges - 1;

type
  ARRAY_OF_RANGES_SIZE = 0..maximum_array_of_ranges;
  ARRAY_OF_RANGES_INDEX = 0..array_of_ranges_limit;

  ARRAY_OF_RANGES = record
    size : array_of_ranges_size;
    list : array [array_of_ranges_index] of range
  end (* ARRAY_OF_RANGES *);
$endif disk_maintenance_code
!
(*	This is the text for a network username,*)
(*	i.e., a username in the MUD.		*)

const
  USERNAME_DATA_MAX = 5;
  USERNAME_TEXT_MAX = username_data_max * MAXIMUM_BYTES_IN_WORD;
  USERNAME_TEXT_LIMIT = username_text_max - 1;

  MAXIMUM_ENTRY = 3;
  ENTRY_LIMIT = maximum_entry - 1;

type
  USERNAME_TEXT_INDEX = 0..username_text_limit;
  USERNAME_TEXT_SIZE = 0..username_text_max;
  USERNAME_DATA_SIZE = 0..username_data_max;

  USERNAME_TEXT = array [username_text_index] of char;

  USERNAME_STRING = record
    size : username_text_size;
    text : username_text
  end (* username_string *);


(*	This is the text for a network password string.			*)

const
  PASSWORD_TEXT_MAX = MAXIMUM_PASSWORD_SIZE (* defined in config file *);
  PASSWORD_TEXT_LIMIT = password_text_max - 1;


type
  PASSWORD_TEXT_INDEX = 0..password_text_limit;
  PASSWORD_TEXT_SIZE = 0..password_text_max;

  PASSWORD_TEXT = array [password_text_index] of char;

  PASSWORD_STRING = record
    size : password_text_size;
    text : password_text
  end (* password_string *);


(*	This is the text for a network login string. It will contain	*)
(*	the username, password, host number, control characters etc.	*)

const
  LOGIN_TEXT_MAX = 58;
  LOGIN_TEXT_LIMIT = login_text_max - 1;


type
  LOGIN_TEXT_INDEX = 0..login_text_limit;
  LOGIN_TEXT_SIZE = 0..login_text_max;

  LOGIN_TEXT = array [login_text_index] of char;

  LOGIN_STRING = record
    size : login_text_size;
    text : login_text
  end (* login_string *);



(* the following definitions are here because thy are used in the	*)
(* internal_to_string class:						*)

(*	This is the text that is stored in a log message.		*)
(*	The size is such that the text and other log message data will	*)
(*	fit on a disk page.						*)

const
  LOG_MESSAGE_TEXT_MAX = 180;
  LOG_MESSAGE_TEXT_LIMIT = log_message_text_max - 1;

type
  LOG_MESSAGE_TEXT_INDEX = 0..log_message_text_limit;
  LOG_MESSAGE_TEXT_SIZE = 0..log_message_text_max;

  LOG_MESSAGE_TEXT = array [log_message_text_index] of char;

 LOG_MESSAGE = record
    size : log_message_text_size;
    text : log_message_text
  end (* log_message *);
$endif old_list_configuration

(****************************************************************)
(*								*)
(*	Message kinds are defined so that users may select out	*)
(*	only messages that they are interested in seeing.	*)
(*								*)
(*	Note: do not change the order of these messages, i.e.	*)
(*	append new ones to end of list because all the messages *)
(*	currently in the oper_log disk file are numbered 	*)
(*	according to the current sequence.			*)
(*								*)
(****************************************************************)

type
  OPER_LOG_MESSAGE_KIND = (
    DEBUGGING_OPLOG_MSG		(* miscellaneous *),
    VALIDATOR_OPLOG_MSG		(* general validator message *),
    FILE_OPLOG_MSG		(* file messages *),
    CUD_OPLOG_MSG		(* CUD error *),
    MUDUPD_OPLOG_MSG		(* MUD_UPDATE_FILE *),
    UN2_OPLOG_MSG		(* UN2 message *),
    CONSISTENCY_OPLOG_MSG	(* consistency message *),
    SYSMSG1_OPLOG_MSG		(* SYSMSG1 message *),
    ARCHIVE_OPLOG_MSG		(* ARCHIVE message *),
    UNUSED1_OPLOG_MSG		(* obsolete: TYMCOM message *),
    CUD_PARAM_OPLOG_MSG		(* CUD PARAMETER file error *),
    LV_OPLOG_MSG		(* logical volume message *),
    MASTER_OPLOG_MSG		(* MASTER valiator message *),
    OPERLOG_REPORT_MSG		(* operator report messgaes *),
    MERGE_UUN_OPLOG_MSG	(* Tymnet only; REUSE_UUNS merger report *),
    MODIFY_CUD_OPLOG_MSG 	(* changes to cud report *),
$ifany (force_password_change, global_password_only_login)
    PASSCHANGER_MSG		(* force_password_change messages *),
$endif (force_password_change, global_password_only_login)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    UPDATE_OFF_MSG (* sup turned off due to disk error *));

(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if changes_to_oper_log
const
  oplog_remark_length = 30 (* characters *);
  oplog_remark_limit = oplog_remark_length - 1;

type
  oplog_remark_index = 0..oplog_remark_limit;
  oplog_remark_size = 0..oplog_remark_length;


  oplog_remark_message = record
    size	: oplog_remark_size;
    chars	: array [oplog_remark_index] of char
  end (* oplog_remark_message *);

(* Modify_type values are used in operator log messages to identify *)
(* the type of cud change being reported. *)

  modify_type = (ACCESS, CONTROL, DISTRICT, GAN, CHANGENAME,
    PASSWORD, UUN, OVERFLOW, GFD, IRC, DELETE, NEW, TIMES,
    NUD_CONTROL, EXPIRE_DATE);

const
  FIRST_MODIFY_TYPE = access;
  LAST_MODIFY_TYPE = expire_date;

type
  modify_index = first_modify_type..last_modify_type;
$endif changes_to_oper_log
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

!
(************************************************************************)
(*									*)
(*	DEVMAX.NTV							*)
(*									*)
(*			 Device Maximums				*)
(*									*)
(*	Set the maximum values for device units.			*)
(*									*)
(************************************************************************)
(*									*)
(*			   Revision Record				*)
(*									*)
(*	08Jan86 - jrn							*)
(*	      - remove UPDATE_TYMCOM_LUDS				*)
(*	09Dec85 - jrn							*)
(*	      - remove ASSIGN_CUSTOMER_NUMBERS_FROM_TYMCOM_IX		*)
(*	 21Jul84 Version 3.00 - jnm/pgl					*)
(*	       - added one to AUX_CIRCUIT_UNIT_MAX for 			*)
(*		 TYMCOM_IX_circuit_maintainer process			*)
(*	 29SEP83	Original -- jnm (from (PATROL)devmax.bas)	*)
(*									*)
(************************************************************************)


const
  disk_unit_max = 2 (* number of units for device disk *);

  tape_unit_max = 4 (* maximum possible number of units for device tape *);

  printer_unit_max = 1 (* max. possible number of units for device printer *);

  terminal_unit_max =
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone logical_volumes
    MAXIMUM_VALIDATOR (* one terminal for each user *);
$endif logical_volumes
$if logical_volumes
    MAXIMUM_VALIDATOR + 1 (* one terminal for each user + initial process *);
$endif logical_volumes
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)


(* one circuit for each Supervisor MUD update,	*)
(* plus one for the Class/group Table update	*)

  aux_circuit_unit_max = MAXIMUM_EXPECTED_SUPERVISORS + 1;


  lv_max = 1 (* possible logical volumes *);
!
(************************************************************************)
(*									*)
(*	DEVDEF.NTV							*)
(*									*)
(*			 Device I/O Declarations			*)
(*									*)
(*	General (nucleus) device I/O definitions.			*)
(*									*)
(************************************************************************)
(*									*)
(*			   Revision Record				*)
(*									*)
(*	07Mar86 - jrn							*)
(*	      - add get_host_state to system_operation definition	*)
(*	08Jan86 - jrn							*)
(*	      - remove UPDATE_TYMCOM_LUDS				*)
(*	09Dec85 - jrn							*)
(*	      - remove ASSIGN_CUSTOMER_NUMBERS_FROM_TYMCOM_IX		*)
(*	01Nov85 - JRN							*)
(*	      - add Supervisor err log definitions (ERRLOG_MESSAGE,	*)
(*		etc.)							*)
(*	23May85 - jrn							*)
(*	      - add get_940_checksum to system device			*)
(*	20Dec84 - jrn							*)
(*	      - add lvol_io_param					*)
(*	 21Jul84 Version 3.00 - jrn/pgl					*)
(*	       - added tymcom_circuit def				*)
(*									*)
(*	 29SEP82	Original -- jnm (from (PATROL)devio.def)	*)
(*									*)
(************************************************************************)


type	(*   Device definition *)
  iodevice = (disk, tape, printer, system, crash, terminal, aux_circuit,
    lvol);


type
  ioresult = (complete, intervention, transmission, failure, end_file,
    end_medium, start_medium, program_error, break_key, orange_ball,
    device_busy, time_out);

type
  ioresult_set = set of ioresult;
!
(************************************************************************)
(*			disk devices					*)
(************************************************************************)


const
  disk_unit_limit = disk_unit_max - 1;



type
  disk_unit_index = 0..disk_unit_limit;


type	(* disk operation codes: *)
  disk_operation = (disk_read, disk_write, disk_attach, disk_detach,
    disk_info, disk_load_program);


type	(* disk i/o parameter list *)
  disk_param = record
    operation : disk_operation;
    status    : ioresult;
    status2,
    start_addr,
    byte_count: integer
  end (* disk_param *);


type
  disk_tape_information = record
    logical_unit_number,
    device_status,
    protection_mask,
    default_block_size,
    start_cylinder,
    number_of_cylinders,
    sectors_per_track,
    tracks_per_cylinder,
    device_address,
    global_unit_number,
    ascii_name,
    device_type,
    number_of_sectors :	 integer
  end (* disk_tape_information *);
!
(************************************************************************)
(*			tape devices					*)
(************************************************************************)


type
  tape_operation = (tape_read, tape_write, tape_attach, tape_detach,
    tape_info, tape_load_program, tape_action);


const
  tape_unit_limit = tape_unit_max - 1;


type
  tape_unit_index = 0..tape_unit_limit;


type
  tape_param = record
    operation : tape_operation;
    status    : ioresult;
    status2,
    arg,
    count      : integer
  end (* tape param *);


const
  tape_back_space = 0;
  tape_forward_file = 1;
  tape_back_file = 2;
  tape_write_eof = 3;
  tape_rewind = 4;
  tape_unload = 5;
  tape_gap = 6;
  tape_set_low_density = 7;
!
(************************************************************************)
(*			printer devices					*)
(************************************************************************)


const
  printer_unit_limit = printer_unit_max - 1;


type
  printer_unit_index = 0..printer_unit_limit;

type
  printer_operation = (printer_raw, printer_text, printer_new_line,
    printer_form_feed, printer_repeat_character, printer_info);


const
  max_lpt_repeat_count = 63;


type
  printer_param = record
    operation : printer_operation;
    status    : ioresult;
    status2,
    arg1,
    arg2      : integer
  end (* printer_param *);


  line_printer_request = record
    prt_op       : printer_operation;
    outline      : format_buffer;
    repeat_char  : char;
    repeat_count : integer
  end (* line_printer_request *);
!
(************************************************************************)
(*			system device					*)
(************************************************************************)


type
  system_operation = (set_system_up, set_system_down, set_system_shut,
    set_system_gone, system_info, system_core_free, read_constant,
    system_checksum, program_status_info, get_940_checksum, get_host_state);


type
  system_param = record
    operation : system_operation;
    status    : ioresult;
    status2,
    arg1,
    arg2      : integer
  end (* system_param *);


type
  system_information = record
    number_of_terminals,		(* NTERM *)
    number_of_aux_circuits,		(* NAUX *)
    host_number,			(* decimal *)
    node_number,			(* octal *)
    slot_number,			(* hexidecimal *)
    kernel_host_number,			(* decimal *)
    isis_version,			(* 100*v+r in decimal *)
    nucleus_version	   : integer (* 256*v+r in octal *)
  end (* system_information *);



(* Netval definition of host state, used in call *)
(* to system_handler procedure SET_HOST_STATE *)

type
  HOST_STATE = (UP_STATE, DOWN_STATE, SHUT_STATE, GONE_STATE);
!
(************************************************************************)
(*			crash device					*)
(************************************************************************)


type
  crash_operation =
    (crash_wait, crash_signal, crash_restart, crash_halt, crash_kill);

type
  crash_param = record
    operation : crash_operation;
    status    : ioresult;
    status2,
    arg1,
    arg2      : integer
  end (* crash_param *);

type
  process_crash_data =
    record
      error_code: integer;
      process_number: integer;
      line_number: integer
    end (* process_crash_data *);
!
(************************************************************************)
(*			 logical volume support 			*)
(************************************************************************)


type
  LVOL_OPERATION = (lvol_init, lvol_soft_init, lvol_info, lvol_setop,
    lvol_copy, lvol_read, lvol_write, lvol_setop_init, lvol_soft_setop_init);


const
  (* LVOL initialization (both LVOL_INIT and LVOL_SOFT_INIT) brings	*)
  (* both incarnations up as read/write; this does not give Netval the	*)
  (* chance to determine which is the proper disk to use as the master.	*)
  (* Netval uses the LVOL_SOFT_SETOP_INIT operation so that it can	*)
  (* bring the master disk up as read/write, and the other disk up as	*)
  (* write only. The following flags are used to specify, when the	*)
  (* LVOL_SOFT_SETOP_INIT is called, if other logical volume operations	*)
  (* may take place (UNLOCK_FOR_INIT) or not (LOCK_FOR_INIT).		*)

  UNLOCK_FOR_INIT = 0;
  LOCK_FOR_INIT = 1;


type
(* used for LVOL_SOFT_SETOP_INIT,  LVOL_SETOP, LVOL_INFO operations *)
  LVOL_PARAM = record
    operation : lvol_operation;
    status    : ioresult;
    status2,
    arg1,
    arg2      : integer
  end (* lvol_param *);


  LVOL_IO_PARAM = record (* used for read and write operations only *)
    operation : lvol_read..lvol_write;
    status    : ioresult;
    status2,
    start_addr,
    byte_count: integer
  end (* lvol_io_param *);


  LVOL_COPY_PARAM = record (* used for LVOL_COPY operation *)
    operation : lvol_copy..lvol_copy;
    status    : ioresult;
    status2,
    start_addr,	(* returns the num bytes transferred *)
    byte_count,
    from_disk,
    to_disk     : integer
  end (* lvol_copy_param *);


(* If logical_volumes is enabled, Netval uses one logical volume. It is *)
(* made up of two incarnations, one on each physical drive; each drive	*)
(* has 2 ISIS logical disk units, a CUD unit and a file_system unit.	*)

const
  LVOL_UNIT = lv_max - 1;


type
  LVOL_UNIT_INDEX = lvol_unit..lvol_unit;


const
  INCARNATION_MAX = 2 (* number of copies within LVOL *);
  INCARNATION_LIMIT = incarnation_max - 1;


type
  incarnation_index = 0..incarnation_limit;


const
  lvol_disk_unit = 4 (* 2 CUDS, 2 file system *);
  lvol_disk_unit_limit = lvol_disk_unit - 1;


type (* see also fildef.ntv, CUD_DISK_UNIT..FILE_SYSTEM_DISK2 *)
  lvol_disk_unit_index = 0..lvol_disk_unit_limit;


  soft_init_rec = record (* used in soft initialization operation *)
    pv_unit	: lvol_disk_unit_index;
    lv_unit	: lvol_unit_index;
    inc_number  : incarnation_index
  end (* soft_init_rec *);


  LVOL_SOFT_INIT_BUFFER = array [lvol_disk_unit_index] of soft_init_rec;


  LVOL_INFO_REC = record (* used for lvol_info operation *)
    read_count,
    write_count,
    last_status,
    error_count,
    logical_volume_number,
    incarnation_number,
    last_error,
    disk_states : integer
  end (* lvol_info_rec *);


  LVOL_INFO_BUFFER = array [lvol_disk_unit_index] of lvol_info_rec;


const
  lvol_info_rec_size = 32;
  lvol_info_buffer_size = lvol_disk_unit * LVOL_INFO_REC_SIZE;



(* If the nucleus is unable to complete an I/O request to a unit 	*)
(* after the standard (256) trys, it sets the unit to "down". The	*)
(* nucleus will not access that unit for lvol_read or lvol_write	*)
(* operations until the unit is restored to "read_write".  This is	*)
(* accomplished in netval by a COPY command.				*)
const
  (* define logical volume I/O states that are returned by the nucleus	*)
  INCARNATION_DOWN = 0		(* down *);
  INCARNATION_READ_WRITE = 1	(* up and read/write *);
  INCARNATION_READ_ONLY = 2	(* up and read only *);
  INCARNATION_WRITE_ONLY = 3	(* up and write only *);
  INCARNATION_OFFLINE = 4	(* up and unavailable *);
  INCARNATION_UNKNOWN = 5	(* when Netval comes up, state is unknown *);


type
  LVOL_STATES = incarnation_down..incarnation_unknown;


const
  (* flags which are sent to the nucleus to set an lvol state *)
  SET_LVOL_CLEAR = 0	(* clears write only, read only or unavailable *);
  SET_LVOL_READ_ONLY = 1;
  SET_LVOL_WRITE_ONLY = 2;
  SET_LVOL_UNAVAILABLE = 3;


type
  LVOL_SET_STATE_FLAGS = set_lvol_clear..set_lvol_unavailable;
!
(************************************************************************)
(*		terminal and aux_circuit devices			*)
(************************************************************************)


type
  circuit_device = terminal..aux_circuit;


const
  terminal_unit_limit = terminal_unit_max - 1;


type
  terminal_unit_index = 0..terminal_unit_limit;

const
  echo_off = 0;
  echo_on  = 1;
  xp_on    = 2;
  xp_off   = 3;
  sys_cons = 4;
  char_del = 5;
  word_del = 6;
  line_del = 7;
  set_crt = 11;

const
   sys_char_del = 0;
   sys_word_del = 1;
   sys_line_del = 2;



const
  sysmsg_circuit = 0;

  aux_circuit_unit_limit = aux_circuit_unit_max - 1;


type
  aux_circuit_unit_index = 0..aux_circuit_unit_limit;


type
  circuit_operation = (circuit_receive_character, circuit_receive_line,
    circuit_send, circuit_disconnect, circuit_clear_break, circuit_set_system,
    circuit_set_unit, circuit_yellow_ball, circuit_detect,
    circuit_aux_request, circuit_info, circuit_send_b1, circuit_get_needle,
    circuit_zap, circuit_sup_log_message, circuit_set_alternate_break,
    circuit_set_bell, circuit_normal_request,
    circuit_send_siix, circuit_send_tiix);



type
  circuit_param = record
    operation : circuit_operation;
    status    : ioresult;
    status2,
    arg1,
    arg2      : integer
  end (* circuit_param *);
!
(*   Needle Record   *)

const
  needle_name_max   = 24 (* characters *);
  needle_name_limit = needle_name_max - 1;


type
  needle_name_index = 0..needle_name_limit;


type
 needle_name_length = 0..needle_name_max;


type
  needle_name = array [needle_name_index] of char;


type
  needle_record = record
    invoice		: integer;
    isis_port		: integer;
    destination_host	: integer;
    origin_node		: integer;
    origin_host		: integer;
    origin_port		: integer;
    number_of_characters: needle_name_length;
    terminal_id		: char;
    login_name		: needle_name
  end (* needle_record *);
!
(* Supervisor ERR log definition. *)

const
  NETVAL_PRODUCT_ID = '(:68:)' (* hex 44 *);
  ERRLOG_DRIVE_DOWN_MESSAGE_TYPE = '(:16:)' (* hex 10 *);
  ERRLOG_SET_SUPERVISOR_MESSAGE_TYPE = '(:17:)' (* hex 11 *);

type
  errlog_message = record (* fields are ISIS message labels *)
    data2	: halfword;
    kind	: char (* type of message *);
    data1	: char;
    pid		: char (* NETVAL_PRODUCT_ID *)
  end (* errlog_message *);
!
(************************************************************************)
(*									*)
(*	LVDEF.NTV							*)
(*									*)
(*			 Logical Volume Definitions			*)
(*									*)
(************************************************************************)


(* Messages are sent to operator log and Supervisors when an	*)
(* incarnation goes down or offline and at LVOL_REPORT_INTERVAL	*)
(* second intervals until it changes to up.			*)
const
  LVOL_REPORT_INTERVAL = 15 * 60 (* fifteen minutes *);


  LVOL_TIME_STAMP_INTERVAL = 60 (* write time stamps every 60 seconds *);


type
  drive_disk_state = record
    legal_disk 	: boolean (* TRUE if config file ok on disk *);
    time_stamp	: integer (* last_pvol_time_stamp from disk *)
  end (* drive_disk_state *);


  lvol_disk_state = array [incarnation_index] of drive_disk_state;
!
(************************************************************************)
(*									*)
(*	CGDEF.NTV							*)
(*									*)
(*      This file contains various NETVAL defintions, including:	*)
(*	Class/group, NODELIST, HOSTLIST definitions.			*)
(*									*)
(************************************************************************)
(*									*)
(*	12Jun87 - neh							*)
(*	      - add conditional for BEFORE_SUP_V43 for sorted flag	*)
(*	15Aug84 - jrn							*)
(*	      - add conditional assembly parameter			*)
(*		OLD_LIST_CONFIGURATION					*)
(*	24Jul84 - jrn							*)
(*	      - redefine classes, groups, node and host lists as to	*)
(*		be more user configurable; add checksums to disk files	*)
(*	      - add list descriptions (if INCLUDE_LIST_DESCRIPTIONS is	*)
(*		enabled							*)
(*	06Jul84 Version 2.02 - jrn					*)
(*	      - add SYSMSG1_UNEXPECTED_INPUT to sysmsg1_status		*)
(*	14Mar84	Version 2.01 modified by jrn				*)
(*	      - modify size of host list to match actual size		*)
(*		in version 1.14						*)
(*									*)
(************************************************************************)


const
  FIRST_CLASS = 1;
  FIRST_GROUP = 1;



type
  CLASS_INDEX = first_class..maximum_class;
  GROUP_INDEX = first_group..maximum_group;

(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone OLD_LIST_CONFIGURATION
$if disk_maintenance_code
const
  MAXIMUM_CLASS_MESSAGE = 'MAXIMUM_CLASS\';
  MAXIMUM_GROUP_MESSAGE = 'MAXIMUM_GROUP\';
  MAXIMUM_LIST_MESSAGE = 'MAXIMUM_LIST\ ';
  MAXIMUM_NAMED_LIST_NAME_SIZE_MESSAGE = 'MAXIMUM_NAMED_LIST_NAME_SIZE\ ';
  MAXIMUM_NAMED_LIST_DESCRIPTION_SIZE_MESSAGE =
    'MAXIMUM_NAMED_LIST_DESCRIPTION_SIZE\';
  MAXIMUM_NAMED_LIST_ENTRY_MESSAGE = 'MAXIMUM_NAMED_LIST_ENTRY\ ';
  MAXIMUM_PAGES_IN_NAMED_LIST_MESSAGE = 'MAXIMUM_PAGES_IN_NAMED_LIST\';
  MAXIMUM_LISTS_IN_GLOBAL_ACCESS_MESSAGE = 'MAXIMUM_LISTS_IN_GLOBAL_ACCESS\ ';
  MAXIMUM_PAGES_IN_GLOBAL_ACCESS_MESSAGE = 'MAXIMUM_PAGES_IN_GLOBAL_ACCESS\ ';
  FIRST_NODE_LIST_PAGE_MESSAGE = 'FIRST_NODE_LIST_PAGE\ ';
  LAST_NODE_LIST_PAGE_MESSAGE = 'LAST_NODE_LIST_PAGE\';
  FIRST_HOST_LIST_PAGE_MESSAGE = 'FIRST_HOST_LIST_PAGE\ ';
  LAST_HOST_LIST_PAGE_MESSAGE = 'LAST_HOST_LIST_PAGE\';
  FIRST_CLASS_DEFINITION_PAGE_MESSAGE = 'FIRST_CLASS_DEFINITION_PAGE\';
  LAST_CLASS_DEFINITION_PAGE_MESSAGE = 'LAST_CLASS_DEFINITION_PAGE\ ';
  FIRST_GROUP_DEFINITION_PAGE_MESSAGE = 'FIRST_GROUP_DEFINITION_PAGE\';
  LAST_GROUP_DEFINITION_PAGE_MESSAGE = 'LAST_GROUP_DEFINITION_PAGE\ ';
$endif disk_maintenance_code

   (* define total size of Class/group Table *)
const
  TABLE_LENGTH = maximum_class_table_size + maximum_group_table_size;

  TABLE_LIMIT =  table_length - 1;



type
  TABLE_INDEX = 0..table_limit;



(* Used to talk to SYSMSG1 - should be the	*)
(* same size as table_contents, below:	*)

  TABLE_IN_BYTES = array [table_index] of char;

   

(* Used to read (and write) the Table from	*)
(* (to) the disk; the file should always be	*)
(* an even number of pages on the disk...	*)

const
  PAGES_IN_TABLE = table_length div page_size;

  TABLE_PAGE_LIMIT = pages_in_table - 1;



type
  TABLE_PAGE_INDEX = 0..table_page_limit;

  TABLE_IN_PAGES = array [table_page_index] of page;



   (* define class and group parameters *)


const
    (* size of class list in bytes: 520, 1256 or 2176 *)

  MAXIMUM_TABLE_CLASS_LIST_SIZE =
    maximum_class_table_size - (maximum_class * 4);



	(* size of class list in halfwords: 260, 628 or 1088 *)

  MAXIMUM_TABLE_CLASS_LIST_HALFWORD_SIZE =
    maximum_table_class_list_size div 2;



  TABLE_CLASS_LIST_HALFWORD_LIMIT =
    maximum_table_class_list_halfword_size - 1;

   

    (* size of group list in bytes: 344, 1436 or 3392 *)

  MAXIMUM_TABLE_GROUP_LIST_SIZE =
    maximum_group_table_size - (maximum_group * 4);



    (* size of group list in halfwords: 172, 718 or 1696 *)

  MAXIMUM_TABLE_GROUP_LIST_HALFWORD_SIZE =
    maximum_table_group_list_size div 2;



  TABLE_GROUP_LIST_HALFWORD_LIMIT =
    maximum_table_group_list_halfword_size - 1;

   

(* The following all refer to the description of	*)
(* the CLASS_GROUP_FILE, or TABLE, which exactly	*)
(* matches the table on the Supervisors.		*)

type
  TABLE_CLASS_LIST_INDEX = 0..table_class_list_halfword_limit;
  TABLE_CLASS_LIST_SIZE = 0..maximum_table_class_list_halfword_size;

  TABLE_GROUP_LIST_INDEX = 0..table_group_list_halfword_limit;
  TABLE_GROUP_LIST_SIZE = 0..maximum_table_group_list_halfword_size;


   (* CLASS_GROUP entries *)

  TABLE_ENTRY_DEFINITION = record
    index,
    count  : halfword (* high order bit on if exception *)
  end (* table_entry_definition *);



   (* pointers and sizes for all CLASSES *)

  TABLE_CLASS_DEFINITIONS = array [class_index] of table_entry_definition;
   


(* The list of CLASS values; the high order	*)
(* bit is on if the halfword is a HOST;		*)
(* otherwise, it is a NODE.			*)

  TABLE_CLASS_LIST = array [table_class_list_index] of halfword;



   (* pointers and sizes for all GROUPS *)

  TABLE_GROUP_DEFINITIONS = array [group_index] of table_entry_definition;



   (* The list of GROUP values (hosts) *)

  TABLE_GROUP_LIST = array [table_group_list_index] of halfword;



   (* The CLASS_GROUP_FILE *)
type	
  CLASS_GROUP_TABLE = record
    class_defs   : table_class_definitions;
    class_values : table_class_list;
    group_defs   : table_group_definitions;
    group_values : table_group_list
  end (* class_group_table *);



(* The following are used in the Supervisor Class/group	*)
(* Table; the actual values in table.class_defs.index,	*)
(* and table.class_defs.size				*)

const	(* actual pointer to first value *)
  FIRST_TABLE_CLASS_VALUE_POINTER = maximum_class * maximum_bytes_in_word;


(* actual pointer to last value *)
  TABLE_CLASS_VALUE_POINTER_LIMIT = maximum_class_table_size - 1;


type
  TABLE_CLASS_VALUE_POINTER_INDEX =
    first_table_class_value_pointer..table_class_value_pointer_limit;


  TABLE_CLASS_VALUE_POINTER_SIZE = 0..maximum_table_class_list_size;



(* The following are used in the Supervisor Class/group	*)
(* Table; the actual values in table.group_defs.index,	*)
(* and table.group_defs.count				*)

const	(* actual pointer to first value *)
  FIRST_TABLE_GROUP_VALUE_POINTER = maximum_group * maximum_bytes_in_word;


  TABLE_GROUP_VALUE_POINTER_LIMIT = maximum_group_table_size - 1;



type
  TABLE_GROUP_VALUE_POINER_INDEX =
    first_table_group_value_pointer..table_group_value_pointer_limit;


  TABLE_GROUP_VALUE_POINTER_SIZE = 0..maximum_table_group_list_size;


(*	Status of Class/group update:	*)

type
  CLASS_GROUP_STATUS = (
    CLASS_GROUP_NOT_TRIED	(* no update attempted *),
    CLASS_GROUP_FAILED		(* failure *),
    CLASS_GROUP_UPDATED		(* successful *));
$endif OLD_LIST_CONFIGURATION
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(************************************************)
(*						*)
(* Description of a node OR host list.		*)
(*						*)
(************************************************)

const
  NAMED_LIST_NAME_SIZE_LIMIT = maximum_named_list_name_size - 1;


type
  NAMED_LIST_NAME_INDEX = 0..named_list_name_size_limit;
  NAMED_LIST_NAME_SIZE = 0..maximum_named_list_name_size;

  NAMED_LIST_NAME_TEXT = array [named_list_name_index] of char;

  NAMED_LIST_NAME = record
    text	: named_list_name_text;
    size	: named_list_name_size
  end (* named_list_name *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if include_list_descriptions

const
  NAMED_LIST_DESCRIPTION_SIZE_LIMIT = maximum_named_list_description_size - 1;


type
  NAMED_LIST_DESCRIPTION_INDEX = 0..named_list_description_size_limit;
  NAMED_LIST_DESCRIPTION_SIZE = 0..maximum_named_list_description_size;

  NAMED_LIST_DESCRIPTION_TEXT = array [named_list_description_index] of char;

  NAMED_LIST_DESCRIPTION = record
    text	: named_list_description_text;
    size	: named_list_description_size
  end (* named_list_description *);
$endif include_list_descriptions
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(* Description of the list of nodes OR hosts *)
const
  NAMED_LIST_ENTRY_LIMIT = maximum_named_list_entry - 1;


type
  NAMED_LIST_SIZE = 0..maximum_named_list_entry;
  NAMED_LIST_INDEX = 0..named_list_entry_limit;

  NAMED_LIST_ENTRIES = array [named_list_index] of integer;

(* the named node OR host list *)

  NAMED_LIST_DEFINITION = record
    name	: named_list_name (* size = 0, if none *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if include_list_descriptions     description	: named_list_description;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    count	: named_list_size	(* count of values *);
    values	: named_list_entries	(* nodes or hosts *);
    checksum	: integer
  end (* named_list_definition *);



(********************************************************)
(*							*)
(* Description of a list index.  Classes and groups are *)
(* defined by the list_indices that represent a node-	*)
(* list or hostlist.  Node and host lists use the	*)
(* same index...this will make it easier to use common	*)
(* code and conversions to a different configuration	*)
(* will not have to modify the data, just the		*)
(* arrangement of it on the disk.			*)
(*							*)
(********************************************************)

const
  LIST_LIMIT = maximum_list - 1;


type
  LIST_INDEX = 0..list_limit;


  LIST_DESCRIPTOR = record
    list_ptr 	: list_index;
    host_flag	: boolean
  end (* list_descriptor *);


(********************************************************)
(*							*)
(* Description of a nodelist or hostlist file entry.	*)
(*							*)
(********************************************************)

const
  MAXIMUM_BYTES_IN_NAMED_LIST =
    (maximum_named_list_name_size + 4) +	(* list name *)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if include_list_descriptions
    (maximum_named_list_description_size + 4) +	(* list description *)
$endif include_list_descriptions
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    ((maximum_named_list_entry + 1) * 4) +	(* entries + count *)
    4						(* checksum *);

  BYTES_IN_NAMED_LIST_LIMIT = MAXIMUM_BYTES_IN_NAMED_LIST - 1;

  MAXIMUM_PAGES_IN_NAMED_LIST =
    (maximum_bytes_in_named_list + page_limit) div page_size;


type
  DISK_NAMED_LIST_DEFINITION = array [0..BYTES_IN_NAMED_LIST_LIMIT] of char;


(********************************************************)
(*							*)
(* Description of a "global access".  A global_access	*)
(* is a collection of lists - also referred to as:  	*)
(*    CLASS - a collection of nodelists and/or hostlists*)
(*    GROUP - a collection of hostlists			*)
(*							*)
(********************************************************)

const
  GLOBAL_ACCESS_LIST_ENTRY_LIMIT = maximum_lists_in_global_access - 1;


type
  GLOBAL_ACCESS_LIST_ENTRY_SIZE = 0..maximum_lists_in_global_access;
  GLOBAL_ACCESS_LIST_ENTRY_INDEX = 0..global_access_list_entry_limit;

  GLOBAL_ACCESS_LIST =
    array [global_access_list_entry_index] of list_descriptor;


  GLOBAL_ACCESS_DESCRIPTION = record
    exception	: boolean	(* TRUE if exception class *);
    count	: global_access_list_entry_size;
    lists	: global_access_list;
    checksum	: integer
  end (* global_access_description *);


const
  MAXIMUM_BYTES_IN_GLOBAL_ACCESS_DESCRIPTION = 
    10 + (6 * maximum_lists_in_global_access);
  BYTES_IN_GLOBAL_ACCESS_DESCRIPTION_LIMIT =
    MAXIMUM_BYTES_IN_GLOBAL_ACCESS_DESCRIPTION - 1;


  MAXIMUM_PAGES_IN_GLOBAL_ACCESS =
    (maximum_bytes_in_global_access_description + page_limit) div page_size;

type
  DISK_GLOBAL_ACCESS_DESCRIPTION =
    array [0..BYTES_IN_GLOBAL_ACCESS_DESCRIPTION_LIMIT] of char;



(********************************************************)
(*							*)
(* Description of classes in the file.			*)
(*							*)
(********************************************************)

const
  MAXIMUM_PAGES_IN_CLASS_DEFINITIONS =
    maximum_class * maximum_pages_in_global_access;



(********************************************************)
(*							*)
(* Description of groups in the file.			*)
(*							*)
(********************************************************)

const
  MAXIMUM_PAGES_IN_GROUP_DEFINITIONS =
    maximum_group * maximum_pages_in_global_access;



(********************************************************)
(*							*)
(* Description of THE file.				*)
(*							*)
(********************************************************)

const
  FIRST_LIST_DATA_PAGE = 2 (* first page on disk that contains a list *);
  FIRST_NODE_LIST_PAGE = FIRST_LIST_DATA_PAGE;
  LAST_NODE_LIST_PAGE =
    first_node_list_page + (maximum_pages_in_named_list * maximum_list) - 1;


  FIRST_HOST_LIST_PAGE = last_node_list_page + 1;
  LAST_HOST_LIST_PAGE =
    first_host_list_page + (maximum_pages_in_named_list * maximum_list) - 1;


  FIRST_CLASS_DEFINITION_PAGE = last_host_list_page + 1;
  LAST_CLASS_DEFINITION_PAGE = 
    first_class_definition_page + maximum_pages_in_class_definitions - 1;


  FIRST_GROUP_DEFINITION_PAGE = last_class_definition_page + 1;
  LAST_GROUP_DEFINITION_PAGE = 
    first_group_definition_page + maximum_pages_in_group_definitions - 1;


(********************************************************)
(*							*)
(* Description of the file header.			*)
(*							*)
(********************************************************)

const
  NODE_HOST_CLASS_GROUP_ID = 'NHCG';

  LIST_HEADER_DATA_SIZE = 64;

  UNUSED_BYTES_IN_NHCG_HEADER =
    page_size - (list_header_data_size + maximum_bytes_in_word);

  UNUSED_BYTES_IN_NHCG_HEADER_LIMIT = unused_bytes_in_nhcg_header - 1;


type
  UNUSED_BYTES_IN_NHCG_HEADER_INDEX = 
    0..unused_bytes_in_nhcg_header_limit;

  NODE_HOST_FILE_HEADER = record
    id : array [0..3] of char	(* NHCG: Node Host Class Group *);
    max_list			(* MAXIMUM_LIST *),
    max_named_list_size		(* MAXIMUM_NAMED_LIST_NAME_SIZE *),
    max_named_list_description	(* MAXIMUM_NAMED_LIST_DESCRIPTION_SIZE *),
    max_named_list_entry	(* MAXIMUM_NAMED_LIST_ENTRY *),
    max_pages_in_list		(* MAXIMUM_PAGES_IN_NAMED_LIST *),
    max_lists_in_global_access	(* MAXIMUM_LISTS_IN_GLOBAL_ACCESS *),
    max_pages_in_global_access	(* MAXIMUM_PAGES_IN_GLOBAL_ACCESS *),
    first_node_page		(* FIRST_NODE_LIST_PAGE *),
    last_node_page		(* LAST_NODE_LIST_PAGE *),
    first_host_page		(* FIRST_HOST_LIST_PAGE	*),
    last_host_page		(* LAST_HOST_LIST_PAGE *),
    first_class_page		(* FIRST_CLASS_DEFINITION_PAGE *),
    last_class_page		(* LAST_CLASS_DEFINITION_PAGE *),
    first_group_page		(* FIRST_GROUP_DEFINITION_PAGE *),
    last_group_page : integer	(* LAST_GROUP_DEFINITION_PAGE *);
    unused_bytes    : array [unused_bytes_in_nhcg_header_index] of char;
    checksum	    : integer
  end (* node_host_file_header *);


(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone OLD_LIST_CONFIGURATION

(* The following is used to return status from the *)
(* node_host_list_utility			*)
type
  NODE_HOST_UTILITY_STATUS = (
    NODE_HOST_OK		(* a-ok *),
    NODE_HOST_LIST_NOT_FOUND	(* no list located *),
    NODE_HOST_LIST_FOUND	(* already there *),
    NODE_HOST_BEING_UPDATED	(* being modified *),
    NODE_HOST_LIST_IN_USE	(* cannot delete list *),
    NODE_HOST_IO_ERROR		(* file error *),
    NODE_HOST_BAD_CHECKSUM	(* checksum does not match *),
    NODE_HOST_FULL		(* no room left *));



(* Description of lists for validators.  This 	*)
(* is used to return (and define new) list	*)
(* descriptions to validators.			*)


(* the named node OR host list *)

  VALIDATOR_NAMED_LIST_DEFINITION = record
    named_list	: named_list_definition;
    host_flag	: boolean (* TRUE if a HOSTlist *)
$if BEFORE_SUP_V43
    ;
    sorted	: boolean (* TRUE if sorted when coming from disk *)
$endif BEFORE_SUP_V43
  end (* validator_named_list_definition *);



(* SYSMSG1 is the Supervisor slave used to update *)
(* the Class/group Table.			  *)

type
  SYSMSG1_STATUS = (
	SYSMSG1_SUCCESSFUl	(* operation complete *),
	SYSMSG1_BUILD_FAILURE	(* SYSMSG1 unavailable *),
	SYSMSG1_HANDSHAKE_ERROR	(* handshake failed *),
	SYSMSG1_CIRCUIT_ERROR	(* lost circuit/circuit zapped *),
	SYSMSG1_UNEXPECTED_INPUT);
$endif OLD_LIST_CONFIGURATION
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone BEFORE_SUP_V43
!
(************************************************************************)
(*									*)
(*	MUDDEF.NTV							*)
(*									*)
(*      This file contains all MUD and NUD file and entry defintions 	*)
(*	for supervisor version 43 format.				*)
(*									*)
(************************************************************************)
(*									*)
(*			Revision Record					*)
(*									*)
(*	04Jan89 - neh							*)
(*		- make LAST_NUD_CONTROL_OPTION_TO_PRINT conditional	*)
(*		  for select control inorder to prevent crash and to	*)
(*		  not print control options which the user is not	*)
(*		  expecting						*)
(*	19Sep88 - jrn							*)
(*		- add password expiration definitions			*)
(*		- add definitions for prevent_duplicate_passwords	*)
(*		- add define allowable_login_times and add it to	*)
(*		  MUD_USER_ENTRY					*)
(*		- add TIME_RESTRICTED_ENTRY to MUD_ENTRY_TYPE, and	*)
(*		  updated LAST_TYPE					*)
(*		- defined MUD_TIME_RESTRICT_BYTES			*)
(*		- define the new mud control option and its bit:	*)
(*		  logon inhibit						*)
(*	10Mar88 - neh							*)
(*	      - add PRIORITY_CONTINUE to access control options and	*)
(*		PROHIBIT_DEFAULT_USER mud option.			*)
(*		(no input procedures have been added to cmdlvl.)	*)
(*	14Sep87 - neh							*)
(*	      - merge with version 4					*)
(*	Original - version 5.00 - Feb 22, 1987 - neh			*)
(*									*)
(************************************************************************)

(* user entry format types:				*)
(* update LAST_TYPE, below when making additions here	*)

type
  MUD_ENTRY_TYPE = (
(* user does not have IRC, expiration date, or time restrictions *)
    MINIMUM_ENTRY,
(* user has IRC or expiration date, but no time restrictions *)
    EXPIRE_DATE_IRC_ENTRY,
(* user has time restrictions, and may have IRC or expiration date *)
    TIME_RESTRICTED_ENTRY);

const
  FIRST_TYPE = minimum_entry;
  LAST_TYPE = time_restricted_entry;

type
  ENTRY_TYPE_RANGE = FIRST_TYPE..LAST_TYPE;


const
  MUD_VERSION_NUMBER = 2 (* major change level, field size, etc. *);
  MUD_REVISION_NUMBER = 0 (* minor change level, new option, etc. *);

(* bytes in a MUD block *)
  MAXIMUM_MUD_BLOCK_SIZE = maximum_mud_block_size_in_sectors * page_size;

(* MUD entry field sizes in bytes *)
  MUD_TYPE_BYTES = 1;
  MUD_AP_START_BYTES = 1;
  MUD_ENTRY_SIZE_BYTES = 2;
  MUD_CONTROL_BYTES = 2;
  MUD_IRC_BYTES = 2;
  MUD_UUN_BYTES = 4;
  MUD_CIPHER_BYTES = 4;
  MUD_EXPIRE_DATE_BYTES = 4;
  MUD_TIME_RESTRICT_BYTES = 4;

(* offsets into MUD entry for each field *)
  MUD_TYPE_OFFSET = 0;
  MUD_AP_START_OFFSET = mud_type_offset + mud_type_bytes;
  MUD_ENTRY_SIZE_OFFSET = mud_ap_start_offset + mud_ap_start_bytes;
  MUD_CONTROL_OFFSET = mud_entry_size_offset + mud_entry_size_bytes;
  MUD_IRC_OFFSET = mud_control_offset + mud_control_bytes;
(* the next offsets require the size of irc to be added if included *)
  MUD_UUN_OFFSET =  mud_control_offset + mud_control_bytes;
  MUD_CIPHER_OFFSET = mud_uun_offset + mud_uun_bytes;
  MUD_USERNAME_OFFSET = mud_uun_offset + mud_uun_bytes;
(* the next offset also requires the size of the username,the size of irc *)
(* if included and the size of the password to be added *)
  MUD_FIRST_ACCESS_OFFSET = mud_username_offset;

(* minimum username size in bytes *)
  MINIMUM_USERNAME_SIZE = maximum_chars_in_halfword (* size byte + 1 char *);
  MAXIMUM_USERNAME_SIZE = username_text_max + minimum_username_size;

(* total fixed field sizes *)
  FIXED_MUD_ENTRY_SIZE = mud_type_bytes + mud_ap_start_bytes +
    mud_entry_size_bytes + mud_control_bytes + mud_uun_bytes;

(* user data size *)
  MAX_USER_DATA = fixed_mud_entry_size + maximum_username_size +
    mud_irc_bytes + mud_cipher_bytes + mud_expire_date_bytes;

  USER_DATA_LIMIT = max_user_data - 1;

type
  USER_DATA_INDEX = 0..user_data_limit;

  USER_DATA_SIZE = 0..max_user_data;

const
(* password sizes *)
  MAX_PASSWORD_SIZE = 2 (* max number of words per password *);
  MINIMUM_PASSWORD_BYTES = maximum_bytes_in_word;
  MAX_PASSWORD_BYTE_SIZE = max_password_size * minimum_password_bytes;

(* NUD field sizes *)
  NUD_ENTRY_DATE_BYTES = 4;
  NUD_GAN_BYTES = 4;
  NUD_OPTIONS_BYTES = 2;
  NUD_DISTRICT_BYTES = 2;
  NUD_PASSWORD_DATE_BYTES = 4;
  NUD_PREVIOUS_CIPHER_BYTES = 4;

(* NUD field offsets *)
  NUD_ENTRY_DATE_OFFSET = 0;
$if include_gan
  NUD_GAN_OFFSET = nud_entry_date_offset + nud_entry_date_bytes;
  NUD_OPTIONS_OFFSET = nud_gan_offset + nud_gan_bytes;
$endif include_gan
$ifnot include_gan
  NUD_OPTIONS_OFFSET = nud_entry_date_offset + nud_entry_date_bytes;
$endif include_gan
  NUD_DISTRICT_OFFSET = nud_options_offset + nud_options_bytes;
  NUD_PASSWORD_DATE_OFFSET = nud_district_offset + nud_district_bytes;
  NUD_PREVIOUS_CIPHER_OFFSET =
    nud_password_date_offset + nud_password_date_bytes;

$if CONVERT_TO_43
  READ_CUD_BLOCK_IN_PAGES_LIMIT = maximum_mud_block_size_in_sectors - 1;
  MAXIMUM_READ_CUD_BLOCK_SIZE = maximum_mud_block_size_in_sectors * page_size;
  MAXIMUM_READ_CUD_DATA = maximum_read_cud_block_size - maximum_bytes_in_word;
  READ_CUD_DATA_LIMIT = maximum_read_cud_data - 1;

type
  READ_CUD_DATA_INDEX = 0..read_cud_data_limit;
  READ_CUD_DATA_SIZE = 0..maximum_read_cud_data;
  READ_CUD_DATA = array [read_cud_data_index] of char;
  READ_CUD_BLOCK_IN_PAGES_INDEX = 0..read_cud_block_in_pages_limit;
  READ_CUD_BLOCK_IN_PAGES = array [read_cud_block_in_pages_index] of page;

  READ_CUD_DISK_BLOCK = record
    data     : read_cud_data;
    checksum : integer
  end (* read_cud_disk_block *);
$endif CONVERT_TO_43

const
(* MUD control op tion bits *)
  USERNAME_TYPE_BIT = bit0;
  HOSTNAME_TYPE_BIT = bit1;
  NO_PASSWORD_REQUIRED_BIT = bit2;
  IGNORE_DESTINATION_BIT = bit3;
  TRANSPARENT_LOGIN_BIT = bit4;
  AUX_PASSWORD_BIT = bit5;
  TARGET_PROFILE_ENTRY_BIT = bit6;
(*	According to Bill Soley, the following bit is used at SWB and	*)
(*	all other networks with LOG-II Supervisors.  It is used to	*)
(*	prevent the username from being implied by an origin address	*)
(*	when the user name is not specified in the login string.	*)
(*	It is currently (9/22/88) displayed, but not settable in Netval.*)
  PROHIBIT_DEFAULT_USER_BIT = bit7;
  LOGON_INHIBIT_BIT = BIT8;

type
  MUD_CONTROL_OPTIONS = (USERNAME_TYPE, HOSTNAME_TYPE, NO_PASSWORD_REQUIRED,
    IGNORE_DESTINATION, TRANSPARENT_LOGIN, AUX_PASSWORD, TARGET_PROFILE_ENTRY,
    PROHIBIT_DEFAULT_USER, LOGON_INHIBIT);
  
const
  FIRST_MUD_CONTROL_OPTION = username_type;
  LAST_MUD_CONTROL_OPTION =
$if allow_logon_inhibit     logon_inhibit;
$ifnone allow_logon_inhibit     prohibit_default_user;

type
  MUD_CONTROL_OPTIONS_RANGE =
    first_mud_control_option..last_mud_control_option;
  MUD_USER_OPTIONS = set of mud_control_options;

const
(* Add new contol bits to MAX_AP_CONTROL *)
(* APE control option bits *)
  USERNAME_OK_BIT = bit16;
  HOSTNAME_OK_BIT = bit17;
  ALLOW_NORMAL_CIRCUIT_BIT = bit18;
  ALLOW_AUX_CIRCUIT_BIT = bit19;
  USER_REGULAR_CALL_BIT = bit20;
  USER_COLLECT_CALL_BIT = bit21;
  HOST_REGULAR_CALL_BIT = bit22;
  HOST_COLLECT_CALL_BIT = bit23;
  SHUT_OVERRIDE_BIT = bit24;
  REQUIRE_HOSTNAME_BIT = bit25;
  TARGET_PROFILE_DESTINATION_BIT = bit26;
  PRIORITY_CONTINUE_BIT = bit27;

(* default control byted *)
  DEFAULT_AP_CONTROL = username_ok_bit + allow_normal_circuit_bit +
    allow_aux_circuit_bit + user_regular_call_bit + host_regular_call_bit;

  MAX_AP_CONTROL = default_ap_control + hostname_ok_bit +
    user_collect_call_bit + user_collect_call_bit + host_collect_call_bit +
    shut_override_bit + require_hostname_bit + target_profile_destination_bit +
    priority_continue_bit;

type
  ACCESS_CONTROL_OPTIONS = (USERNAME_OK, HOSTNAME_OK, ALLOW_NORMAL_CIRCUIT,
    ALLOW_AUX_CIRCUIT, USER_REGULAR_CALL, USER_COLLECT_CALL, HOST_REGULAR_CALL,
    HOST_COLLECT_CALL, SHUT_OVERRIDE, REQUIRE_HOSTNAME,
    TARGET_PROFILE_DESTINATION, PRIORITY_CONTINUE);

  ACCESS_CONTROL_WORD = 0..max_ap_control;

const
  FIRST_ACCESS_CONTROL_OPTION = username_ok;
  LAST_ACCESS_CONTROL_OPTION = priority_continue;

type
  ACCESS_CONTROL_OPTIONS_RANGE =
    first_access_control_option..last_access_control_option;
  ACCESS_USER_OPTIONS = set of access_control_options_range;

const
(* APE description fields in bytes *) 
  AP_HEADER_TOKEN_SIZE = 1;
  OPERATOR_LIMIT = maximum_chars_in_halfword;
  TOKEN_UNIT_SIZE = maximum_bytes_in_word;
  LIST_VALUE_SIZE = maximum_chars_in_halfword;

  AP_ENTRY_HEADER_LIMIT = 8 * ap_header_token_size;
  AP_ORIGIN_MINIMUM = token_unit_size;
  AP_DESTINATION_MINIMUM = token_unit_size;
  AP_DEFINITION_MAX = page_size - list_value_size;
  AP_DEFINITION_LIMIT = ap_definition_max - ap_entry_header_limit;
  AP_OFFSET_MAX = ap_definition_max - list_value_size;

(* APE header offsets *)
  APE_TYPE_OFFSET = 0;
  APE_SIZE_OFFSET = ape_type_offset + 1;
  APE_ORIGIN_OFFSET = ape_size_offset + 1;
  APE_DEST_OFFSET = ape_origin_offset + 1;
  APE_HOME_OFFSET = ape_dest_offset + 1;
  APE_LOCAL_OFFSET = ape_home_offset + 1;
  
  APE_CONTROL_START = ape_local_offset + 1;
  APE_ORIGIN_START = AP_ENTRY_HEADER_LIMIT;

(* maximum number of set operators in an APE *)
  MAXIMUM_AP_OPERATORS = ap_definition_limit div (operator_limit +
    token_unit_size);

(* minimum APE size in bytes *)
  MINIMUM_AP_SIZE = ap_entry_header_limit + ap_destination_minimum +
    ap_origin_minimum;

(* ACCESS set bits *)
  SET_OPERATOR_BIT = bit24;

  NODE_FLAG_BIT = bit16;

(* ACCESS profile set description *)
(* maximum_origin_destination is defined in GLOBL *)
  MAX_CONVERTED_ACCESS_SET_SIZE = maximum_origin_destination;

type
(* AP Entry sizes *)
  AP_DEFINITION_SIZE = minimum_ap_size..ap_definition_max;
  AP_OPER_COUNT = 0..maximum_ap_operators;

(* ACCESS set *)
  ACCESS_CONVERTED_SET_INDEX = 0..max_converted_access_set_size;
  ACCESS_CONVERTED_SET_DATA = array [access_converted_set_index] of halfword;

(* ACCESS record *)
  ACCESS_SET = record
    size : access_converted_set_index;
    set_data : access_converted_set_data
  end (* access_set *);

$ifnone CONVERT_TO_43 type
(* MUD entry size range in bytes *)
  MUD_ENTRY_SIZE = 0..maximum_mud_block_size;

(* Access Profile entry ranges *)
  APE_SIZE = minimum_ap_size..ap_definition_max;
  APE_OFFSET_SIZE = 0..ap_offset_max;

(* APE types *)
  APE_TYPES = (APE_BASIC);

(* APE set operators *)
  APE_OPERATORS = (APE_NOT, APE_UNION, APE_INTERSECTION);

(* APE token types *)
  APE_TOKENS = (APE_LOCAL, APE_CLASS, APE_GROUP);

const
  FIRST_APE_OPER = ape_not;
  LAST_APE_OPER = ape_intersection;

  FIRST_APE_TOKEN = ape_local;
  LAST_APE_TOKEN = ape_group;

type
  APE_OPER_RANGE = first_ape_oper..last_ape_oper;
  APE_TOKEN_RANGE = first_ape_token..last_ape_token;

  APE_OPER_SET = set of ape_oper_range;
  APE_TOKEN_SET = set of ape_token_range;

const
(* MUD header field sizes in bytes *)
  HEADER_BLOCK_NUMBER_BYTES = 4;
  HEADER_TIME_BYTES = 4;
  OVERFLOW_BYTES = 4;
  
  MUD_HEADER_SIZE = header_time_bytes + header_block_number_bytes +
    overflow_bytes;
  
  MUD_HEADER_LIMIT = mud_header_size - 1;

(* MUD header offsets *)
  BLOCK_NUMBER_OFFSET = 0;
  HEADER_TIME_OFFSET = header_block_number_bytes;
  OVERFLOW_OFFSET = header_time_offset + header_time_bytes;
  START_MUD_ENTRY_OFFSET = overflow_offset + overflow_bytes;

  MAXIMUM_MUD_DATA = maximum_mud_block_size - maximum_bytes_in_word;

(* minimum MUD entry size in bytes *)
  MINIMUM_MUD_ENTRY = fixed_mud_entry_size + minimum_ap_size +
    minimum_username_size + minimum_password_bytes;

(* maximum number of users per MUD block *)
  MAXIMUM_MUD_BLOCK_USER_COUNT = (maximum_mud_data - mud_header_size)
    div minimum_mud_entry;

(* NUD - Netval User Data - constants *)
$ifnot INCLUDE_GAN   NUD_MINIMUM_ENTRY_SIZE = 3 * maximum_bytes_in_word;
$if INCLUDE_GAN   NUD_MINIMUM_ENTRY_SIZE = 4 * maximum_bytes_in_word;

  MAXIMUM_NUD_BLOCK_SIZE_IN_SECTORS = (nud_minimum_entry_size *
    maximum_mud_block_user_count) div page_size + 1;
  MAXIMUM_NUD_BLOCK_SIZE = maximum_nud_block_size_in_sectors * page_size;

  MAXIMUM_CUD_BLOCK_SIZE_IN_SECTORS = maximum_mud_block_size_in_sectors +
    maximum_nud_block_size_in_sectors;
  MAXIMUM_CUD_BLOCK_SIZE = maximum_cud_block_size_in_sectors * page_size;

  MUD_BLOCK_TERMINATOR = 0;

(* OVERFLOW flag bits *)
  BLOCK_HAS_OVERFLOWS_BIT = bit0;
  BLOCK_IS_OVERFLOW_BIT = bit1 (* not set in Netval, but in NVDM on all *);
  					(* overflow blocks *)

(* a MUD block consists of Master User Data *)
  MUD_DATA_LIMIT = maximum_mud_data - 1;


(* MUD change information is described by the following types;	*)

(* the size of a MUD change in words...as it is *)
(* used in consistency updates and sent to UN2 *)

  MUD_DATA_WORD_MAXIMUM = maximum_mud_data div maximum_bytes_in_word;
  MUD_DATA_WORD_LIMIT = mud_data_word_maximum - 1;


(* AP description *)
  MAXIMUM_ACCESS_DESCRIPTION = maximum_mud_data - max_user_data -
    mud_header_size;
  MUD_ACCESS_PROFILE_DESCRIPTION_LIMIT = maximum_access_description - 1;

type
  MUD_ACCESS_PROFILE_DESCRIPTION_INDEX = 0..mud_access_profile_description_limit;
  MUD_ACCESS_PROFILE_DESCRIPTION_SIZE = 0..maximum_access_description;
  MUD_ACCESS_PROFILE_DESCRIPTION = array [mud_access_profile_description_index]
    of char;

  MUD_DATA_WORD_SIZE = 0..mud_data_word_maximum;
  MUD_DATA_WORD_INDEX = 0..mud_data_word_limit;

(* MUD data as a block *)
  MUD_DATA_INDEX = 0..mud_data_limit;
  MUD_DATA_SIZE = 0..maximum_mud_data;
  MUD_DATA = array [mud_data_index] of char;

const (* a NUD block consists of Netval User Data *)
  MAXIMUM_NUD_DATA = maximum_nud_block_size - maximum_bytes_in_word;
  NUD_DATA_LIMIT = maximum_mud_block_size + maximum_nud_data - 1;
  NUD_DATA_ENTRY_OFFSET = maximum_mud_block_size;

type
(* NUD data from nud_data_entry_offset to nud_data_limit, to end of CUD *)
  NUD_DATA_INDEX = nud_data_entry_offset..nud_data_limit;
  NUD_DATA_SIZE = 0..maximum_nud_data;
  NUD_DATA = array [nud_data_index] of char;

const (* max entry size accounts for possible previous cipher stored *)
  NUD_ENTRY_SIZE_MAXIMUM = nud_minimum_entry_size
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if prevent_duplicate_passwords      + maximum_bytes_in_word;
$ifnone prevent_duplicate_passwords     ;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)


type
  NUD_ENTRY_SIZE = 0..nud_entry_size_maximum;


(* a MUD disk block record *)
  MUD_DISK_BLOCK = record
    data	: mud_data;
    checksum	: integer
  end (* mud_disk_block *);

(* a CUD entry record *)
  CUD_ENTRY_DATA = record
    mud_block	: mud_disk_block;
    nud_block	: nud_data
  end (* cud_entry_data *);

(* an entire CUD block consists of a mud_block, nud_block and a checksum *)
  CUD_DATA_BLOCK = record
    data	: cud_entry_data;
    checksum	: integer
  end (* cud_data_block *);

const (* NUD control option bits *)
  NETWORK_ADMINISTRATOR_BIT = bit0;
  ACCOUNT_SUPERVISOR_BIT = bit1;
  OPERATOR_BIT = bit2;
  AUDITOR_BIT = bit3;
  FPC_EXEMPT_BIT  = bit4;
  NSP_CHANGE_BIT = bit5;
  PASSWORD_EXPIRATION_EXEMPT_BIT = bit6;
  NON_STANDARD_PASSWORD_EXPIRATION_BIT = bit7;
  PREVIOUS_PASSWORD_BIT = bit15;

type
  NUD_CONTROL_OPTIONS = (
$ifnone CONVERT_TO_43
    LICENSED, PASSWORD_ONLY, (* not bits in CUD *)
$endif CONVERT_TO_43
   NETWORK_ADMINISTRATOR,
   ACCOUNT_SUPERVISOR, OPERATOR,

(* put auditor after useable options, and non useable options after auditor *)
(* to allow auditor to be last option to print and prevent range error *)

$if force_password_change   FPC_EXEMPT, (* print only if force_password *)
$if no_self_password_change   NSP_CHANGE, (* print only if no_self_password *)
$if password_expiration_by_user   EXEMPT_FROM_PASSWORD_EXPIRATION, (* same *)

   AUDITOR,

$ifnot force_password_change   FPC_EXEMPT,
$ifnot no_self_password_change   NSP_CHANGE,
$ifnot password_expiration_by_user   EXEMPT_FROM_PASSWORD_EXPIRATION,

   NON_STANDARD_PASSWORD_EXPIRATION,	(* do not print *)
   PREVIOUS_PASSWORD_STORED		(* do not print *));

const
  FIRST_NUD_CONTROL_OPTION = network_administrator;
  LAST_NUD_CONTROL_OPTION = previous_password_stored;

  FIRST_NUD_CONTROL_OPTION_TO_PRINT = network_administrator;
  LAST_NUD_CONTROL_OPTION_TO_PRINT = auditor;

type
  NUD_CONTROL_OPTIONS_RANGE =
    first_nud_control_option..last_nud_control_option;
  NUD_USER_OPTIONS = set of nud_control_options_range;

(* flag end of user MUD data *)
const
  MUD_ENTRY_TERMINATOR = 0 (* a half-word of 0 *);

  MAXIMUM_DISTRICT = 4095;

type
  DISTRICT_NUMBER = 0..maximum_district;

  PASSWORD_DATA_SIZE = 0..max_password_size;
  PASSWORD_BYTE_SIZE = 0..max_password_byte_size;

  OVERFLOW_FLAGS = (BLOCK_HAS_OVERFLOWS, BLOCK_IS_OVERFLOW);

const
  FIRST_OVERFLOW_FLAG = block_has_overflows;
  LAST_OVERFLOW_FLAG = block_is_overflow;

  NO_PREVIOUS_CIPHER = -1;

type
  OVERFLOW_FLAG_RANGE = first_overflow_flag..last_overflow_flag;
  MUD_OVERFLOW_FLAGS = set of overflow_flag_range;


(* user password data record *)
  PASSWORD_DATA = record
   cipher 	: integer;
   expire_date	: integer
  end (* password_data *);


(* define set that describes the possible login hours for use if *)
(* restrict_users_by_time is ENabled *)

const
  FIRST_HOUR = 0;
  LAST_HOUR = 24;
  ALL_HOURS = 25;

type
  allowable_login_hours = first_hour..all_hours;

  allowable_login_times = set of allowable_login_hours;



(* a MUD block header *)
type
  MUD_BLOCK_HEADER = record
    block	: integer;
    time	: integer;
    overflow	: mud_overflow_flags
  end (* mud_block_header *);

(* a NUD entry *)
  NUD_USER_ENTRY = record
    entry_change_date	: integer;
    gan			: integer;
    nud_options		: nud_user_options;
    district		: district_number;
    password_change_date: integer;
    previous_cipher	: integer
  end (* nud_user_entry *);

type
  ACCESS_DESTINATION_DESCRIPTION = record
    not_destination_global_set : access_set;
    not_destination_local_set : access_set;
    destination_global_set : access_set;
    destination_local_set : access_set;
    home_destination_global_set : access_set;
    home_destination_local_set : access_set;
    home_destination : boolean;
    non_home_destination : boolean
  end (* access_destination_description *);

  ACCESS_ORIGIN_DESCRIPTION = record
    local : boolean;
    global_origin : integer;
    local_set_data : access_set;
    local_offset : integer;
    origin_op : ape_oper_set
  end (* access_origin_description *);
$endif BEFORE_SUP_V43
!
(************************************************************************)
(*									*)
(*	CUDDEF.NTV							*)
(*									*)
(*      This file contains all CUD file and entry defintions.		*)
(*									*)
(************************************************************************)
(*									*)
(*			revision record					*)
(*									*)
(*	03Oct88 - jrn							*)
(*		- add password expiration definitions			*)
(*		- change allow_user_password_expire to			*)
(*		  password_expiration_by_user and check out code	*)
(*		- add small_cud_entry					*)
(*      11Sep87 - neh - add rsb revisions for FPC and expire date       *)
(*	14Aug87 - neh							*)
(*	        - remove Tymshare CUD bits from options			*)
(*		- replace TYMSHARE_CUD_FORMAT flag with INCLUDE_IRC	*)
(*      20Jan87 - rsb                                                   *)
(*              - define bit 7 as FORCE_PASSWD_CHG_EXEMPT               *)
(*              - define bit 9 as NO_SELF_PASSWD_CHANGE                 *)
(*              - add definition of FPC_PASSWORD_CIPHER                 *)
(*              - change GFD_ONLY_PASSWORD from                         *)
(*                '(:251:)(:239:)(:190:)(:251:)' to -68174085           *)
(*      05Jan87 - rsb                                                   *)
(*              - add EXPIREDATE_FIELD to FIELDS                        *)
(*              - add EXPIREDATE_CRITERION to CRITERIA_TYPE             *)
(*	09Jan87 - neh							*)
(*	        - add CONVERT_TO_43 for NVDM command to reformat	*)
(*		- add BEFORE_SUP_V43 conditional for old and new CUD	*)
(*		  definitions 						*)
(*	03Spe86 - jrn							*)
(*	      - allow SET GFD ONLY and CHANGE UUN AND GAN CUD changes	*)
(*		available if not Tymshare CUD format (for BUBBNET)	*)
(*	18Jul86 - jrn							*)
(*	      - add CUD_ENTRY_IN_WRONG_BLOCK to CUD_ENTRY_RESULT	*)
(*	18Jun86 - neh							*)
(*	      - add type FIELDS for select, display and dump commands	*)
(*	07Oct85 - jrn							*)
(*	      - add MAX_X25_PREFIX_SIZE, MAX_X25_HOST_PLACES		*)
(*	15Feb85 - jrn							*)
(*	     - add CUD_ENTRY_ILLEGAL_NAME to cud_entry_result	 	*)
(*	30Jan85 - jrn							*)
(*	      - added OLD_LIST_CONFIGURATION				*)
(*	      - added MUD_VERSION_NUMBER, MUD_REVISION_NUMBER		*)
(*	15Nov84 version 3.00 pgl					*)
(*	      - moved CUD_PARAMETER_FILE definitions to PRMDEF.NTV	*)
(*	30Sep84 version 3.00    neb					*)
(*	      - added CUD block and CUD entry definitions for		*)
(*		conditional parameters					*)
(*		OVERFLOW_CUD_ENTRIES and TYMSHARE_CUD_FORMAT		*)
(*	14Jun84	version 2.02	jrn					*)
(*	      - added AUDITOR_LICENSE, OPERATOR_LICENSE			*)
(*	15Jun84 version 2.02	pgl					*)
(*	      - changed CONTROL_BITS to CUD_CONTROL_OPTIONS and added	*)
(*		LICENSED and PASSWORD_ONLY to CONTROL_OPTIONS		*)
(*	      - added the constants, FIRST_CUD_CONTROL_OPTION and	*)
(*		LAST_CUD_CONTROL_OPTION					*)
(*	      - added CRITERIA_TYPE					*)
(*									*)
(************************************************************************)


(* first, CUD file defintions *)

const
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if BEFORE_SUP_V43
  MUD_VERSION_NUMBER = 1 (* major change level, field size, etc. *);
  MUD_REVISION_NUMBER = 0 (* minor change level, new option, etc. *);
$endif BEFORE_SUP_V43

(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  NORMAL_CUD_BLOCK_LIMIT = maximum_normal_cud_block - 1;

$if BEFORE_SUP_V43
(* bytes in a CUD block *)
  MAXIMUM_CUD_BLOCK_SIZE = maximum_cud_block_size_in_sectors * page_size;
$endif BEFORE_SUP_V43
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone OLD_LIST_CONFIGURATION
$if OVERFLOW_CUD_ENTRIES

  MAXIMUM_CUD_BLOCK = maximum_normal_cud_block + number_of_overflow_blocks;


$ifany (BEFORE_SUP_V43, CONVERT_TO_43)  OVERFLOW_INDICATOR = -1;
$endif OVERFLOW_CUD_ENTRIES
$ifnone OVERFLOW_CUD_ENTRIES   MAXIMUM_CUD_BLOCK = maximum_normal_cud_block;
$endif OLD_LIST_CONFIGURATION
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(* flag end of MUD data *)

  CUD_BLOCK_LIMIT = maximum_cud_block - 1;

$if CONVERT_TO_43
  MAXIMUM_CONVERT_BLOCK = maximum_normal_convert_block +
    convert_overflow_blocks;

  CONVERT_BLOCK_LIMIT = maximum_convert_block - 1;
$endif CONVERT_TO_43

type
  CUD_BLOCK_INDEX = 0..cud_block_limit;

  NORMAL_CUD_BLOCK_INDEX = 0..normal_cud_block_limit;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone OLD_LIST_CONFIGURATION
!
(* The following definition describes a type of CUD change: *)

  CUD_CHANGE_INDICATOR = (
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if OVERFLOW_CUD_ENTRIES     CREATE_OVERFLOW_BLOCK,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    NEW_USER_CUD_CHANGE,
    CHANGE_GAN_CUD_CHANGE,
    CHANGE_PASSWORD_CUD_CHANGE,
    RENAME_DELETE_USER_CUD_CHANGE,
    RENAME_RESTORE_OLD_NAME,
    RENAME_NEW_USER_CUD_CHANGE,
    DELETE_USER_CUD_CHANGE,
    CHANGE_OPTIONS_CUD_CHANGE,
    CHANGE_DISTRICT_CUD_CHANGE,
    CHANGE_UUN_CUD_CHANGE,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if NETVAL_IS_A_SLAVE
    SET_GFD_ONLY_CUD_CHANGE,
    CHANGE_UUN_AND_GAN_CUD_CHANGE,
$endif NETVAL_IS_A_SLAVE
$if INCLUDE_IRC     CHANGE_IRC_CUD_CHANGE,
$if force_password_change    PASSCHANGER_PASSWORD_CHANGE,
    CHANGE_ACCESS_CUD_CHANGE,
$if password_expiration_date_in_cud     CHANGE_PASSWORD_EXPIRE,
$if restrict_users_by_time     CHANGE_ALLOWABLE_TIMES_CUD_CHANGE,
$ifnone before_sup_v43     CHANGE_NUD_OPTIONS_CUD_CHANGE,
    DUMMY_CUD_CHANGE);
$endif OLD_LIST_CONFIGURATION
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(* CUD block defintions *)


(* a CUD block in pages *)

const
  CUD_BLOCK_IN_PAGES_LIMIT = maximum_cud_block_size_in_sectors - 1;

type
  CUD_BLOCK_IN_PAGES_INDEX = 0..cud_block_in_pages_limit;
  CUD_BLOCK_IN_PAGES = array [cud_block_in_pages_index] of page;

(* a CUD block *)
const (* a CUD block consists of data and one word of checksum *)
  MAXIMUM_CUD_DATA = maximum_cud_block_size - maximum_bytes_in_word;
  CUD_DATA_LIMIT = maximum_cud_data - 1;


type
  CUD_DATA_INDEX = 0..cud_data_limit;
  CUD_DATA_SIZE = 0..maximum_cud_data;
  CUD_DATA = array [cud_data_index] of char;


(* an entire CUD block *)
  CUD_DISK_BLOCK = record
    data     : cud_data;
    checksum : integer
  end (* cud_disk_block *);


(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone OLD_LIST_CONFIGURATION
(* The following are used for displaying CUD data *)
const
  MAXIMUM_CUD_BYTES_IN_LINE = 16;

  MAXIMUM_CUD_WORDS_IN_LINE =
    maximum_cud_bytes_in_line div maximum_bytes_in_word;
  CUD_WORDS_IN_LINE_LIMIT = maximum_cud_words_in_line - 1;



(* Describe size of parts of CUD entry in bytes *)

$ifany (BEFORE_SUP_V43, CONVERT_TO_43)
const
  ENTRY_SIZE_BYTES = 4;
  PASSWORD_BYTES = 4;
  ENTRY_CHANGE_DATE_BYTES = 4;
  GAN_BYTES = 4;
  UUN_BYTES = 4;
  OPTIONS_DISTRICT_BYTES = 4;
  PASSWORD_CHANGE_DATE_BYTES = 4;
  END_FLAG_BYTES = 2;
$endif (BEFORE_SUP_V43, CONVERT_TO_43)

(* gfd only values *)
const
(*  GFD_ONLY_PASSWORD = '(:251:)(:239:)(:190:)(:251:)' *)
  GFD_ONLY_PASSWORD = -68174085;
  GFD_ONLY_PASSWORD_DATE = BIT7 - 1;
(* force_password_change password cipher *)
  FPC_PASSWORD_CIPHER = 12345678;
(* Some offsets of CUD values. *)


$ifany (BEFORE_SUP_V43, CONVERT_TO_43)
(* Some offsets of CUD values. *)
  USERNAME_OFFSET = entry_size_bytes;

(* To get the exact offset for the following values, *)
(* the size of the user name must be taken into account *)
  PASSWORD_OFFSET = entry_size_bytes;
  ENTRY_CHANGE_DATE_OFFSET = entry_size_bytes + password_bytes;
  GAN_OFFSET = entry_size_bytes + password_bytes + entry_change_date_bytes;
  UUN_OFFSET = entry_size_bytes + password_bytes + entry_change_date_bytes +
    gan_bytes;
  OPTIONS_OFFSET = entry_size_bytes + password_bytes +
    entry_change_date_bytes + gan_bytes + uun_bytes;
  DISTRICT_OFFSET = options_offset;
  PASSWORD_CHANGE_DATE_OFFSET = entry_size_bytes + password_bytes +
    entry_change_date_bytes + gan_bytes + uun_bytes + options_district_bytes;
  IRC_OFFSET = password_change_date_offset;
  PROFILE_OFFSET = entry_size_bytes + password_bytes +
    entry_change_date_bytes + gan_bytes + uun_bytes + options_district_bytes +
    password_change_date_bytes;

(* the sizes of some cud changes... *)

  PASSWORD_CHANGE_SIZE = password_bytes + entry_change_date_bytes + gan_bytes +
    uun_bytes + options_district_bytes + password_change_date_bytes;
  IRC_CHANGE_SIZE = entry_change_date_bytes + gan_bytes + uun_bytes +
    options_district_bytes + password_change_date_bytes;
  GAN_CHANGE_SIZE = entry_change_date_bytes + gan_bytes;
  UUN_CHANGE_SIZE = entry_change_date_bytes + gan_bytes + uun_bytes;



(*	Some change option commands also change:	*)
(*		- password				*)
(*	  	- profile access (homes)		*)
(*	  	- password & profile access (homes)	*)
  OPTIONS_CHANGE_SIZE = entry_change_date_bytes +
    gan_bytes + uun_bytes + options_district_bytes;
  DISTRICT_CHANGE_SIZE = options_change_size;



(* This is the minimum change size for a profile change *)
(* when the new profile is the same size as the old pro-*)
(* file - the actual size of the profile must be added  *)
(* to compute the actual profile size change             *)
  MINIMUM_PROFILE_CHANGE_SIZE = entry_change_date_bytes +
    gan_bytes + uun_bytes + options_district_bytes +
    password_change_date_bytes;



(* The number of fixed characters in a CUD entry.		*)
(* Includes: size-of-entry word (4), password cipher (4),	*)
(*    entry change date (4), GAN (4), UUN (4), control		*)
(*    word (4), password change date (4), 0FFFF flag (2).	*)
(* In addition, the total size includes the variable values	*)
(* of user name and access profile information.			*)
  FIXED_CUD_ENTRY_SIZE = entry_size_bytes + password_bytes +
    entry_change_date_bytes + gan_bytes + uun_bytes + options_district_bytes +
    password_change_date_bytes + end_flag_bytes;

  MAXIMUM_ACCESS_DESTINATION = maximum_cud_data - fixed_cud_entry_size -
    username_text_max;
$endif (convert_to_43, before_sup_v43)

(* mask used with district word *)
  DISTRICT_MASK = mask_0FFF;
"remove tymshare masks
  TYMSHARE_OPTIONS_MASK = mask_0F0;
  TYMSHARE_CPARW_MASK = 65520 (* hex 0FFF0 *);
"
  CONTROL_OPTIONS_MASK = mask_0FFFF_F000;
$ifany (convert_to_43, before_sup_v43)

$if BEFORE_SUP_V43
(* define all CUD control options *)
  SHUT_OVERRIDE_BIT = bit3;
$if force_password_change
  FPC_EXEMPT_BIT  = bit7;
$endif force_password_change
(*      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-  *)
$if no_self_password_change
  NSP_CHANGE_BIT = bit9;
$endif no_self_password_change
(*      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-  *)
  TRANSPARENT_LOGIN_BIT = bit10;
  BILLABLE_BIT = bit12;
  IGNORE_HOST_BIT = bit13;
  NEW_PASSWORD_BIT = bit14;
  NO_PASSWORD_BIT = bit15;
  PRIORITY_CIRCUIT_BIT = bit16;
  NETWORK_ADMINISTRATOR_BIT = bit17;
  AUDITOR_BIT = bit19;
  ACCOUNT_SUPERVISOR_BIT = bit18;
  OPERATOR_BIT = bit4;
(*      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-  *)
$endif BEFORE_SUP_V43
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

$if CONVERT_TO_43
  OLD_SHUT_OVERRIDE_BIT = bit3;
$if force_password_change
  OLD_FPC_EXEMPT_BIT  = bit7;
$endif force_password_change
(*      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-  *)
$if no_self_password_change
  OLD_NSP_CHANGE_BIT = bit9;
$endif no_self_password_change
(*      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-  *)
  OLD_TRANSPARENT_LOGIN_BIT = bit10;
  OLD_IGNORE_HOST_BIT = bit13;
  OLD_NO_PASSWORD_BIT = bit15;
  OLD_NETWORK_ADMINISTRATOR_BIT = bit17;
  OLD_AUDITOR_BIT = bit19;
  OLD_ACCOUNT_SUPERVISOR_BIT = bit18;
  OLD_OPERATOR_BIT = bit4;
$endif CONVERT_TO_43

(* define all control options *)
(* Licensed and password_only do not have a one to one ratio with	*)
(* control bits in the cud.  Licensed means the account_supervisor bit	*)
(* is on or the network_administrator bit is on.  Password_only means	*)
(* the account_supervisor bit is off and the network_administrator bit	*)
(* is off.								*)

type
$if BEFORE_SUP_V43
  CONTROL_OPTIONS = (LICENSED, PASSWORD_ONLY, (* not bits in CUD *)
    ACCOUNT_SUPERVISOR, IGNORE_DESTINATION, NETWORK_ADMINISTRATOR,
    NO_PASSWORD_REQUIRED,
    SHUT_OVERRIDE, BILLABLE, AUDITOR, OPERATOR,
(*      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-  *)
$if force_password_change    FPC_EXEMPT,
$if no_self_password_change    NSP_CHANGE,
(*      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-  *)
  TRANSPARENT_LOGIN,
  PRIORITY_CIRCUIT, NEW_PASSWORD_OPTION);
$endif BEFORE_SUP_V43
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if CONVERT_TO_43
  CONTROL_OPTIONS = (LICENSED, PASSWORD_ONLY,(* not bits in CUD *)
    OLD_SHUT_OVERRIDE, (* not in user options *)
    OLD_ACCOUNT_SUPERVISOR,  OLD_IGNORE_DESTINATION, OLD_NETWORK_ADMINISTRATOR,
    OLD_NO_PASSWORD_REQUIRED, OLD_AUDITOR,
    OLD_OPERATOR,
(*      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-  *)
$if force_password_change     OLD_FPC_EXEMPT,
$if no_self_password_change     OLD_NSP_CHANGE,
(*      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-  *)
    OLD_TRANSPARENT_LOGIN);
$endif CONVERT_TO_43

const
$if BEFORE_SUP_V43
  FIRST_CUD_CONTROL_OPTION  = account_supervisor;
  LAST_CUD_CONTROL_OPTION =  new_password_option;

  FIRST_CUD_CONTROL_OPTION_TO_PRINT = account_supervisor;
  LAST_CUD_CONTROL_OPTION_TO_PRINT = transparent_login;
$endif BEFORE_SUP_V43
$if CONVERT_TO_43
  FIRST_CUD_CONTROL_OPTION  = old_account_supervisor;
  LAST_CUD_CONTROL_OPTION = old_transparent_login;
$endif CONVERT_TO_43

type
(* cud_control_options - previously called control bits *)
(* this is a subset of control options *)
  CUD_CONTROL_OPTIONS = first_cud_control_option..last_cud_control_option;
  USER_OPTIONS = set of cud_control_options;

const
$endif (BEFORE_SUP_V43, CONVERT_TO_43)
$if BEFORE_SUP_V43

  MAXIMUM_DISTRICT = 4095;

type
  DISTRICT_NUMBER = 0..maximum_district;
const
$endif BEFORE_SUP_V43  


$ifany (NETVAL_IS_A_SLAVE, BEFORE_SUP_V43, CONVERT_TO_43)
(* define some access entry definitions *)
(* Always consider the halfwords from the CUD access *)
(* entry to be in the right half of an integer.      *)
(* When converting from cud_data characters to a     *)
(* cud_user_entry, the two bytes will be picked up   *)
(* into the right half of a word (the left half is   *)
(* zeroed by pick_up_two_cud_bytes).                 *)

  ACCESS_ENTRY_SIZE_LOCATION = bit19;
  IN_PLACE_BIT = bit20;
  EXCEPTION_BIT = bit21;
  HOME_BIT = bit16;
  ORIGIN_HOST_BIT = bit16;
  GROUP_BIT = bit17;
  IN_PLACE_ORIGIN_SIZE_MASK = mask_3FF;
  USER_CLASS_MASK = mask_3FF;
$endif (NETVAL_IS_A_SLAVE, BEFORE_SUP_V43, CONVERT_TO_43)



(* in-place origin definitions *)
  MAXIMUM_IN_PLACE_ORIGIN = maximum_origin_destination - 1;
  (* max no. of in-place origins *)

  IN_PLACE_ORIGIN_LIMIT = maximum_in_place_origin - 1;



type
(* if compile error occurs, MAXIMUM_ORIGIN_DESTINATION was set to less than 2 *)
(* correct config file, NVAL0v.Arr, recompile *)
  IN_PLACE_ORIGIN_INDEX = 0..in_place_origin_limit;
  IN_PLACE_ORIGIN_SIZE = 0..maximum_in_place_origin;

  IN_PLACE_ORIGIN_ENTRY = record
    value     : integer (* host or node *);
    host_flag : boolean (* TRUE if value is a host *)
                        (* FALSE if value is a node *)
  end (* in_place_origin_entry *);


  IN_PLACE_ORIGIN_DESCRIPTION = record
    size : in_place_origin_size;
    list : array [in_place_origin_index] of in_place_origin_entry
  end (* in_place_origin_description *);



(* destination definitions *)
const
  DESTINATION_LIMIT = maximum_origin_destination - 1;


type
  DESTINATION_INDEX = 0..destination_limit;
  DESTINATION_SIZE = 0..maximum_origin_destination;

  DESTINATION_ENTRY = record
    value     : integer (* host or group *);
    group_flag: boolean (* TRUE if value is group, FALSE if value is host *);
$ifnot BEFORE_SUP_V43     exception	: boolean (* negative destination *);
    home_flag : boolean (* TRUE if value is home, else FALSE *)
  end (* destination_entry *);

  DESTINATION_DESCRIPTION = record
    size : destination_size;
    list : array [destination_index] of destination_entry
  end (* destination_description *);


(* a single access entry *)
  ACCESS_ENTRY_DESCRIPTION = record
$ifnot BEFORE_SUP_V43     access_control	: access_control_word;
    in_place_origin: boolean	(* TRUE if origin is in-place *);
    exception   : boolean	(* TRUE if in-place or class is exception *);
    class_no    : class_index	(* if not in-place origin, CLASS number *);
    origin      : in_place_origin_description;
    destination : destination_description
  end (* access_entry_description *);


(* an entire access profile *)
const
  ACCESS_ENTRY_LIMIT = maximum_access_entry - 1;

(* flag that ends a user CUD entry *) (* a half-word of all one's *)
$ifany (BEFORE_SUP_V43, CONVERT_TO_43)   CUD_ENTRY_TERMINATOR = 65535;

type
(* if compile error occurs, MAXIMUM_ACCESS_ENTRY was set to less than 1 *)
(* correct config file, NVAL0v.Arr, recompile *)
  ACCESS_ENTRY_INDEX = 0..access_entry_limit;
  ACCESS_ENTRY_SIZE = 0..maximum_access_entry;

  ACCESS_PROFILE_DESCRIPTION = record
    count   : access_entry_size;
    entries : array [access_entry_index] of access_entry_description
  end (* access_profile_description *);


$ifany (BEFORE_SUP_V43, CONVERT_TO_43)
(* an entire user CUD entry *)
type
  CUD_USER_ENTRY = record
$endif (BEFORE_SUP_V43, CONVERT_TO_43)
$if BEFORE_SUP_V43
    name		: username_string;
    password		: integer (* cipher of password *);
    entry_change_date	: integer (* seconds since 1/1/72 *);
    gan			: integer;
    uun			: integer;
    password_change_date: integer (* days since 1/1/72 *);
    district		: district_number;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if INCLUDE_IRC     irc		: integer;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    options		: user_options;
    access_profile	: access_profile_description
  end (* cud_user_entry *);
$endif BEFORE_SUP_V43
$if CONVERT_TO_43
(*      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-  *)
    cud_name            : username_string;
    cud_password                : integer (* cipher of password *);
    cud_entry_change_date       : integer (* seconds since 1/1/72 *);
    cud_gan                     : integer;
    cud_uun                     : integer;
    cud_password_change_date: integer (* days since 1/1/72 *);
    cud_district                : district_number;
(*      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-  *)
$if INCLUDE_IRC     cud_irc             : integer;
(*      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-  *)
    cud_options         : user_options;
    cud_access_profile  : access_profile_description
  end (* cud_user_entry *);
$endif CONVERT_TO_43

$ifnone BEFORE_SUP_V43
(* a MUD user entry *)
  MUD_USER_ENTRY = record
    entry_type		: mud_entry_type;
    ap_offset		: user_data_size;
    size		: mud_entry_size;
    mud_options		: mud_user_options;
    uun			: integer;
    irc			: integer;
    password		: password_data;
    allowable_times	: allowable_login_times;
    name		: username_string;
    mud_access_profile	: access_profile_description
  end (* mud_user_entry *);
$endif BEFORE_SUP_V43

(* used by DISPLAY_DIRECTORY, SELECT and ARCHIVE_DUMP Command *)
  CRITERIA_TYPE = (ALL_CRITERIA, ACCESS_CRITERION, GAN_CRITERION,
    DISTRICT_CRITERION, UUN_CRITERION, CONTROL_CRITERION,
    ENTRYDATE_CRITERION, 
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifany (force_password_change, password_expiration_by_user)
    EXPIREDATE_CRITERION,
$endif (force_password_change, password_expiration_by_user)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    PASSWORDDATE_CRITERION);
  
  FIELDS = (ALL_FIELDS, UUN_FIELD, GAN_FIELD, DISTRICT_FIELD,
    CONTROL_FIELD, PASSWORDDATE_FIELD, ENTRYDATE_FIELD,
(*      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-  *)
$ifany (force_password_change, password_expiration_by_user)
         EXPIREDATE_FIELD,
$endif (force_password_change, password_expiration_by_user)
$if restrict_users_by_time     TIMERESTRICT_FIELD,
(*      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-  *)
    ACCESS_FIELD);

const
  FIRST_FIELD = ALL_FIELDS;
  FIRST_SPECIFIC_FIELD = UUN_FIELD;
  LAST_FIELD = ACCESS_FIELD;
!
(* Results from CUD block operations:	*)

type
  CUD_OPERATION_RESULT = (
    CUD_OPERATION_OK		(* successful *),
    CUD_FILE_LOCKED		(* CUD file is read only *),
				(* busy doing STORE in ARCHIVE *)
    CUD_BLOCK_MANUALLY_LOCKED	(* locked manually *),
    CUD_CHECKSUM_ERROR		(* bad checksum read *),
    CUD_OPERATION_FAILED	(* read/write failed *));


(*	Results from CUD ACCESS operations:	*)

type
  CUD_ACCESS_STATUS = (
    CUD_ACCESS_OK		(* block locked successfully *),
    CUD_ACCESS_FILE_LOCKED	(* file locked for ARCHIVE against writing *),
    CUD_ACCESS_BLOCK_SHUT	(* programmer has block *));



(*	Results from CUD update operations:	*)

type
  CUD_ENTRY_RESULT = (
    CUD_ENTRY_OK,			(* complete *)
    CUD_ENTRY_FILE_LOCKED,		(* locked (archive) against writing *)
    CUD_ENTRY_LOCKED,			(* entry busy *)
    CUD_ENTRY_BLOCK_LOCKED,		(* programmer has block locked! *)
    CUD_ENTRY_DOES_NOT_FIT,		(* CUD block full *)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if OVERFLOW_CUD_ENTRIES
    CUD_ENTRY_OVERFLOW_FOUND,		(* block has overflow *)
$endif OVERFLOW_CUD_ENTRIES
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    CUD_ENTRY_NOT_FOUND,		(* name not found *)
    CUD_NAME_TAKEN,         		(* name requested already used *)
    CUD_FORMAT_ERROR,       		(* error in CUD format *)
    CUD_ENTRY_BAD_CHECKSUM,		(* bad checksum on CUD block *)
    CUD_ENTRY_MUD_CHANGE_FILE_FULL,	(* MUDUPD full *)
    CUD_ENTRY_MUD_CHANGE_FILE_ERROR,	(* MUDUPD I/O error *)
    CUD_ENTRY_LUD_CHANGE_FILE_ERROR,	(* LUD file error *)
    CUD_ENTRY_OPERATION_FAILED,		(* I/O failed *)
    CUD_ENTRY_IN_WRONG_BLOCK,		(* entry is not in correct block *)
    CUD_ENTRY_ILLEGAL_NAME		(* not a valid username *));


(* CUD change information is described by the following types;	*)
(* they are used to pass information about changes to the	*)
(* MUD_CHANGE_HANDLER Monitor.					*)


(* the size of a CUD change in words...as it is *)
(* stored in the MUD_UPDATE_FILE and sent to UN2 *)

const
  CUD_DATA_WORD_MAXIMUM = maximum_cud_data div maximum_bytes_in_word;
  CUD_DATA_WORD_LIMIT = cud_data_word_maximum - 1;


type
  CUD_DATA_WORD_SIZE = 0..cud_data_word_maximum;
  CUD_DATA_WORD_INDEX = 0..cud_data_word_limit;

$if BEFORE_SUP_V43
(* the header for CUD changes *)
(* as it appears everywhere but on the DISK *)

  CUD_CHANGE_HEADER = record
    block  : cud_block_index		(* block of change *);
    offset : cud_data_word_index	(* word index into CUD block *);
    size   : cud_data_word_size		(* words in change *)
  end (* cud_change_header *);
$endif BEFORE_SUP_V43
$ifnone BEFORE_SUP_V43
(* the header for MUD changes *)
(* as it appears everywhere but on the DISK *)

  MUD_CHANGE_HEADER = record
    block  : cud_block_index		(* block of change *);
    offset : mud_data_index		(* byte index into MUD block *);
    size   : mud_data_size		(* bytes in change *);
    time   : integer			(* UTS time block was changed *)
  end (* mud_change_header *);
$endif BEFORE_SUP_V43


(* the header for CUD changes *)
(* as it appears on the DISK *)
const
  CUD_CHANGE_HEADER_SIZE = 8
$ifnone BEFORE_SUP_V43  + 2
    (* bytes *);

(***** CUD change information *****)

type
  CUD_CHANGE_INFORMATION = record
$if BEFORE_SUP_V43
    header : cud_change_header;
    data   : cud_data
$endif BEFORE_SUP_V43
$ifnone BEFORE_SUP_V43
    header : mud_change_header;
    data : mud_data
$endif BEFORE_SUP_V43
  end (* cud_change_information *);
$endif old_list_configuration

(* the header for CUD changes *)
(* as it appears on the DISK *)


(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if VALIDATE_X25_NAMES
const
  MAX_X25_PREFIX_SIZE = 4;
  MAX_X25_HOST_PLACES = 5;
$endif VALIDATE_X25_NAMES
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)


type
  small_cud_entry = record
    name		: username_string;
    gan			: integer;
    password_date	: integer;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if BEFORE_SUP_V43    options		: user_options;
$ifnone BEFORE_SUP_V43
    options		: mud_user_options;
    nud_options		: nud_user_options;
    expire_date		: integer;
    previous_cipher	: integer;
$endif BEFORE_SUP_V43
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    cipher		: integer
  end (* small_cud_entry  *);
!
(************************************************************************)
(*									*)
(*	PRMDEF.NTV							*)
(*									*)
(*	Constants and type definitions for the cud parameter file.	*)
(*									*)
(************************************************************************)
(*									*)
(*			  Revision Record				*)
(*									*)
(*	10Mar86 - jrn							*)
(*	      - redo REUSE_UUNS to maintain a bit map for 18 bit UUNS	*)
(*		and change the add back scheme to be a dated list	*)
(*	      - the changes will not take care of assigning greater	*)
(*		than 18 bit UUNS, but will leave things open for that	*)
(*		later development					*)
(*	15Nov84		Original - pgl - neb				*)
(*									*)
(************************************************************************)



(************************************************************************)
(*									*)
(* The last CUD block is followed by an empty (unused) block.		*)
(* The cud parameter file follows the empty block.			*)
(*									*)
(* The format for the first page, or header, of the CUD parameter file	*)
(* depends on the conditional flag, reuse_uuns.				*)
(*									*)
(* If reuse_uuns is DISABLED, then the first page contains the next	*)
(* GAN and UUN to be assigned and a checksum; the file is one page long.*)
(*									*)
(************************************************************************)

const
  CUD_PARAMETER_HEADER_PAGE = 0 (* first page of CUD_PARAMETER file *);


type
  UUN_INDEX = 1..MAX_INTEGER (* possible legal uuns *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone reuse_uuns

const
  LAST_PARAM_PAGE = 0 (* file is only a header page *);
$endif reuse_uuns
$if reuse_uuns



(************************************************************************)
(*									*)
(* If reuse_uuns is ENABLED, the first page contains the next GAN	*)
(* to be assigned, next 17bit_page, 18bit_page, 19bit_uun,		*)
(* add_back_page and a checksum; used UUN's are contained in a bit map	*)
(* which follows, and the add_back list follows that.  There is also	*)
(* room allocated for a temporary bit map used to reconstruct the UUN	*)
(* bit map from the CUD and add_back file.				*)
(*									*)
(************************************************************************)
(*					page offset into file		*)
(*					    decimal	hex		*)
(************************************************************************)
(*	header page				0	0		*)
(************************************************************************)
(*	bit 17 UUN bit map			1	1		*)
(*		"				.	.		*)
(*		"				.	.		*)
(*	bit 17-bit18 UUN bit map	       66      42		*)
(*	  (31 bits of 17 bit UUNs					*)
(*	   rest for 18 bit UUNs)					*)
(*	bit 18 UUN bit map continued	       67      43		*)
(*		"				.	.		*)
(*		"				.	.		*)
(*	last bit 18 UUN bit map page	      131      83		*)
(************************************************************************)
(*	add back file page		      132      84		*)
(*		"				.	.		*)
(*		"				.	.		*)
(*	last add back file page		      393     189		*)
(************************************************************************)
(*	temp bit map page		      394     18A		*)
(*		"				.	.		*)
(*		"				.	.		*)
(*	last temp bit map page		      524     20C		*)
(************************************************************************)


(* define 17-bit values for the bit map *)
const
  MAX_17BIT_UUN = BIT14 - 1 (* value of maximum 17 bit UUN *);

  FIRST_17BIT_PAGE = CUD_PARAMETER_HEADER_PAGE + 1 (* page after header *);
  BIT17_PAGE_MAX =
    (MAX_17BIT_UUN + bit_values_per_page_limit) div max_bit_values_per_page;

type
  BIT17_PAGE_INDEX = first_17bit_page..bit17_page_max;



(* define 18-bit values for the bit map *)
const
  MAX_18BIT_UUN = BIT13 - 1 (* value of maximum 18 bit UUN *);

  FIRST_18BIT_PAGE = bit17_page_max;
  BIT18_PAGE_MAX =
    (MAX_18BIT_UUN + bit_values_per_page_limit) div max_bit_values_per_page;


type
  BIT18_PAGE_INDEX = first_18bit_page..bit18_page_max;



(* define the first 19-bit UUN *)
const
  FIRST_19BIT_UUN = BIT12 - 1;



(* define add back page values *)
const
  FIRST_ADD_BACK_PAGE = bit18_page_max + 1;
  ADD_BACK_PAGE_MAX = first_add_back_page + ADD_BACK_FILE_SIZE - 1;

type
  ADD_BACK_PAGE_INDEX = first_add_back_page..add_back_page_max;


const
  MAX_DATA_IN_ADD_BACK_PAGE = page_size - maximum_bytes_in_word (* checksum *);

  MAX_ENTRIES_IN_ADD_BACK_PAGE = max_data_in_add_back_page div     
    (2 * maximum_bytes_in_word);
  ENTRIES_IN_ADD_BACK_PAGE_LIMIT = max_entries_in_add_back_page - 1;  


type
  ADD_BACK_ENTRY_INDEX = 0..entries_in_add_back_page_limit;

  ADD_BACK_ENTRY = record
    time	: integer;
    uun		: integer
  end (* add_back_entry *);

  ADD_BACK_PAGE = record
    entries	: array [add_back_entry_index] of add_back_entry;
    unused	: integer (* to fill out to a page *);
    checksum	: integer
  end (* add_back_page *);



(* define temp UUN bit map values; used for NVDM RECONSTRUCT *)
(* command, but must be allocated on disk in Netval.  The    *)
(* temp UUN bit map is the same size as the UUN bit map.     *)
const
  FIRST_TEMP_UUN_PAGE = add_back_page_max + 1;
  TEMP_UUN_PAGE_MAX = first_temp_uun_page + bit18_page_max - 1;

type
  TEMP_UUN_PAGE_INDEX = first_temp_uun_page..temp_uun_page_max;



(* define general file values *)
type
(* to refer to ANY bit in the UUN bit map *)
  UUN_PAGE_INDEX = first_17bit_page..bit18_page_max;

const
  LAST_PARAM_PAGE = temp_uun_page_max;
$endif reuse_uuns
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)


type
(* to refer to any PAGE in the file *)
  CUD_PARAMETER_PAGE_INDEX = cud_parameter_header_page..last_param_page;



  CUD_PARAMETER_STATUS = (
    CUD_PARAMETER_OK,
    CUD_PARAMETER_BAD_CHECKSUM,
    CUD_PARAMETER_IO_ERROR);



(* unused bytes in the header page *)
const
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone reuse_uuns
  CUD_PARAMETER_HEADER_UNUSED_BYTES = page_size - (3 * maximum_bytes_in_word);
$endif reuse_uuns
$if reuse_uuns
  CUD_PARAMETER_HEADER_UNUSED_BYTES = page_size - (6 * maximum_bytes_in_word);


type
  REUSE_UUN_HEADER_INFO = record
    bit17_page		: bit17_page_index;
    bit18_page		: bit18_page_index;
    bit19_uun		: integer (* UUNs over 18 bits will be sequential *);
    add_back_page	: add_back_page_index
  end (* reuse_uun_header_info *);
$endif reuse_uuns
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)


const
  CUD_PARAMETER_HEADER_UNUSED_LIMIT = cud_parameter_header_unused_bytes - 1;

type
  CUD_PARAMETER_HEADER = record
    next_gan		: integer (* next GAN to be assigned *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone reuse_uuns     next_uun	: uun_index (* next UUN to be assigned *);
$if reuse_uuns     reuse_info	: reuse_uun_header_info;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    unused   : array [0..cud_parameter_header_unused_limit] of char;
    checksum : integer
  end (* cud_parameter_header *);



(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if reuse_uuns
(* These data structures pertain to the 	*)
(* UUN pages, beginning with FIRST_17BIT_PAGE.	*)
const
  UUN_DATA_PER_PAGE = page_size - maximum_bytes_in_word; (* in bytes *)
  UUN_DATA_LIMIT = uun_data_per_page - 1;
  

type
  UUN_PAGE_DATA = record
    uun_data : array [0..uun_data_limit] of char;
    checksum : integer
  end (* uun_page_data *);
$endif reuse_uuns
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if INCLUDE_DNIC
const
  DNIC_FILE_ID = 'DNIC';

  DNICNAME_SIZE = MAXIMUM_BYTES_IN_WORD;
  DNICNAME_LIMIT = DNICNAME_SIZE - 1;
 
(* define DNIC data record sizes *)
  DNIC_INFO_SIZE = MAXIMUM_BYTES_IN_WORD;

  DNIC_DATA_SIZE = DNICNAME_SIZE + DNIC_INFO_SIZE;

type
  DNICNAME_INDEX = 0..DNICNAME_LIMIT;

  DNICNAME_STRING = array [dnicname_index] of char;

  DNIC_DATA = record
    name : dnicname_string;
    info : integer
  end (* dnic_record *);

(* null dnic name to terminate *)
const
  NULL_DNICNAME = '(:0:)(:0:)(:0:)(:0:)';
  NULL_INFO = 0;

(* first and second lookup values *)
  MAXIMUM_LOOKUP = 10;

  MINIMUM_LOOKUP = 0;

  FIRST_LOOKUP_MASK = mask_0ff (* mask used for first_lookup byte *);

 (* define flag bits *)
  NATIVE_BIT = bit0;
  SHARED_BIT = bit1;
  TRANSLATED_BIT = bit2;

type
  LOOKUP_INDEX = minimum_lookup..maximum_lookup;

  (* DNIC flags *)
  DNIC_FLAGS = (NATIVE, SHARED, TRANSLATED);

(* define flag limits *)
const
  FIRST_DNIC_FLAG = native;
  LAST_DNIC_FLAG = translated;

(* define DNIC table sizes in bytes *)
const
  DNIC_TABLE_LENGTH = maximum_dnic_table_size;
  DNIC_TABLE_LIMIT = dnic_table_length - 1;

  DNIC_HEADER_LENGTH = page_size;
  DNIC_FILE_LENGTH = dnic_header_length + dnic_table_length;
  DNIC_FILE_LIMIT = dnic_file_length - 1;

  DNIC_HEADER_DATA_LENGTH = dnic_header_length - MAXIMUM_BYTES_IN_WORD;
  DNIC_HEADER_LIMIT = dnic_header_data_length - 1;

  DNIC_DATA_LENGTH = dnic_table_length - MAXIMUM_BYTES_IN_WORD;
  DNIC_DATA_LIMIT = dnic_data_length - 1;

type
  DNIC_HEADER_INDEX = 0..dnic_header_limit;
  DNIC_HEADER_IN_BYTES = array [dnic_header_index] of char;

  DNIC_TABLE_INDEX = 0..DNIC_TABLE_LIMIT;
  DNIC_TABLE_IN_BYTES = array [dnic_table_index] of char;

  DNIC_FILE_INDEX = 0..dnic_file_limit;
  DNIC_FILE_IN_BYTES = array [dnic_file_index] of char;

  DNIC_DATA_INDEX = 0..dnic_data_limit;
  DNIC_DATA_IN_BYTES = array [dnic_data_index] of char;

(* define disk data *)
  DISK_DNIC_HEADER = record
    data	: dnic_header_in_bytes;
    checksum	: integer
  end (* disk_dnic_header *);

  DISK_DNIC_DATA = record
    data : dnic_data_in_bytes;
    checksum : integer
  end (* disk_dnic_data *);

(* define DNIC table in data records *)
const
  DNIC_RECORD_COUNT = dnic_table_length div dnic_data_size; 

(* reserve one dnic data record for default dnic and one for terminating dnic *)
  NON_DEFAULT_RECORD_COUNT = dnic_record_count - 2 (* 1 default, 1 zero *);

  NON_DEFAULT_RECORD_LIMIT = non_default_record_count - 1;

type
  NON_DEFAULT_DATA_SIZE = 0..NON_DEFAULT_RECORD_COUNT;
  NON_DEFAULT_DATA_INDEX = 0..NON_DEFAULT_RECORD_LIMIT;

  NON_DEFAULT_DATA_TABLE = array [non_default_data_index] of dnic_data;
    
(* define DNIC table in pages *)
const
  PAGES_IN_DNIC_TABLE = maximum_dnic_table_size div page_size;
  DNIC_TABLE_PAGE_LIMIT = pages_in_dnic_table - 1;

  PAGES_IN_DNIC_HEADER = 1;

(* define DNIC header and data locations *)
  DNIC_HEADER_ADDRESS = 0;
  DNIC_FILE_START = dnic_header_address + pages_in_dnic_header;

(* define total DNIC file *)
  PAGES_IN_DNIC_FILE = pages_in_dnic_table + pages_in_dnic_header;
  DNIC_FILE_PAGE_LIMIT = pages_in_dnic_file - 1;

  DNIC_TABLE_ADDRESS = dnic_header_address + pages_in_dnic_file;

type
  DNIC_TABLE_PAGE_INDEX = 0..dnic_table_page_limit;
  DNIC_TABLE_IN_PAGES = array [dnic_table_page_index] of page;

  DNIC_FILE_PAGE_INDEX = 0..dnic_file_page_limit;
  DNIC_FILE_IN_PAGES = array [dnic_file_page_index] of page;

  DNIC_DATA_TABLE = record
    default_dnic: dnic_data;
    non_default : non_default_data_table;
    unused	: array [0..3] of char (* unused and checksum is zero dnic *);
    checksum	: integer
  end (* dnic_data_table *);

(* status of DNIC sup updates *)
  DNIC_TABLE_STATUS = (
    DNIC_UPDATE_NOT_TRIED	(* no update attempted to sup *),
    DNIC_UPDATE_FAILED		(* attempted, but failed *),
    DNIC_UPDATED		(* successsful update *));

$endif INCLUDE_DNIC
!
(************************************************************************)
(*									*)
(*	FILDEF.NTV							*)
(*									*)
(*	Constants and type definitions for the file system.		*)
(*									*)
(************************************************************************)
(*									*)
(*			  Revision Record				*)
(*									*)
(*	22Dec88 - neh							*)
(*		- add passtable def for effective start date of FPC	*)
(*	20Sep88 - jrn							*)
(*		- use ganpass_file_exists				*)
(*		- modify schedtable definitions to include:		*)
(*		  standard_password_validity_period			*)
(*		  password_change_time_in_seconds			*)
(*	19Nov87 - neh							*)
(*	      - changed unused_configuration for change in size of	*)
(*		configuration_info size					*)
(*	05Nov87 - neh							*)
(*	      - add DNIC table after class table			*)
(*	21Sep87 - neh							*)
(*              - add mud_version to configuration_information		*)
(*		  if BEFORE_SUP_V43 is disabled.			*)
(*	16Oct86 - rsb							*)
(*		- if either force password change or 			*)
(*		  global password only are enabled add PASSTABLE	*)
(*		- add SCHEDTABLE					*)
(*		- change name of CUD_BUFFER to CUD_MUD_BUFFER		*)
(*		- change UNUSED_CONFIGURATION_BYTES from 40 to either	*)
(*		  8 or 24 to account for schedtable, and sometimes,	*)
(*		  passtable.						*)
(*	10Mar86 - jrn							*)
(*	      - redo REUSE_UUNS to maintain a bit map for 18 bit UUNS	*)
(*		and change the add back scheme to be a dated list	*)
(*	14Jun85 - jrn							*)
(*	      - define file_utility_status				*)
(*	      - in CONFIGURATION_INFORMATION record, changed		*)
(*		pages_on_this_disk to pages_on_disk_one, and added	*)
(*		pages_on_disk_zero					*)
(*	11Dec84 - jrn							*)
(*	      - added ID and LAST_PVOL_TIME_STAMP to			*)
(*		configuration_information				*)
(*	15Nov84 - pgl							*)
(*	      - added conditional assembly flag, REUSE_UUNS,	 	*)
(*		to computation of CUD_PARAMETER_FILE_LENGTH 		*)
(*	31Jul84 - jrn							*)
(*	      - increase incarnation to 1; add node_host list		*)
(*		configuration information to the node_host file;	*)
(*		new format node_host file; treat CUD PARAMETER file	*)
(*		as a separate file; add checksums to operlog and	*)
(*		node_host file entries					*)
(*	14Mar84	Version 2.01 - jrn					*)
(*	      - modify length of node host file to match actual size	*)
(*		in version 1.14						*)
(*	29SEP83 Original from (patrol)fildef.ntc - jrn			*)
(*									*)
(************************************************************************)



(*	Define the disk units:   *)

const
  CUD_DISK_UNIT = 0;
  FILE_SYSTEM_DISK = cud_disk_unit + 1;

(* for logical volumes, add: *)
  CUD_DISK_UNIT2 = file_system_disk + 1;
  FILE_SYSTEM_DISK2 = cud_disk_unit2 + 1;



type
  FILE_DESCRIPTOR = record
      unit        : disk_unit_index;
      address		(* first physical page number in file *),
      length	  : integer (* number of pages in file *)
"
remove, always the same as the config label date and time
      creation_date : integer
"
  end (* file_descriptor *);



  FILE_INDEX = (
    CONFIGURATION_FILE	(* NETVAL configuration dependant value defs *),
    NODE_HOST_FILE	(* NETVAL format Class/group information *),
    CLASS_GROUP_FILE	(* Supervisor format Class/group table *),
    OPERLOG_FILE	(* NETVAL happenings *),
    MUD_UPDATE_FILE	(* Misc. NETVAL info and MUD change records *),
$if INCLUDE_DNIC
    DNIC_FILE		(* NETVAL DNIC data file *),
$endif INCLUDE_DNIC
$if ganpass_file_exists
    PASSTABLE_FILE	(* password validity period defs., GPO access defs. *),
$endif ganpass_file_exists
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    *)
    SCHEDTABLE_FILE	(* scheduled processes, various Netval parameters *),
    CUD_FILE		(* user information *),
    CUD_PARAMETER_FILE	(* next gan, uun to be assigned *)	);


const
  FIRST_FILE = CONFIGURATION_FILE;
  LAST_FILE = CUD_PARAMETER_FILE;

(* all file descriptors *)
type
  FILE_SYSTEM_DESCRIPTOR = array [file_index] of file_descriptor;


const
  FIRST_ARCHIVE_FILE = CONFIGURATION_FILE;
  LAST_ARCHIVE_FILE = CUD_PARAMETER_FILE;

type
  ARCHIVE_FILE_INDEX = first_archive_file..last_archive_file;


const
  INTEGER_LENGTH_IN_BYTES = maximum_bytes_in_word;

  BOOLEAN_LENGTH_IN_BYTES = 2;

  PASSTABLE_ENTRY_SIZE_IN_BYTES = 
	integer_length_in_bytes  	(* GAN *) 
$if force_password_change
	+ integer_length_in_bytes	(* passlife *)
	+ boolean_length_in_bytes	(* fpc boolean *)
$if request_fpc_start	+ integer_length_in_bytes	(* start date *)
$endif force_password_change
$if global_password_only_login
	+ boolean_length_in_bytes	(* gpo boolean *)
$endif global_password_only_login
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
; 

  PASSTABLE_HEADER_SIZE_IN_BYTES = integer_length_in_bytes * 2;

  PASSTABLE_DATA_LENGTH = passtable_header_size_in_bytes +
	((number_of_passtable_entries+1) * passtable_entry_size_in_bytes);

  PASSTABLE_FILLER_LENGTH = page_size - (passtable_data_length mod page_size);

  PASSTABLE_FILE_LENGTH_IN_BYTES = passtable_data_length + passtable_filler_length ;

  PASSTABLE_FILE_LENGTH_IN_PAGES = PASSTABLE_FILE_LENGTH_IN_BYTES div page_size;

  PASSTABLE_PAGE_MAX = passtable_file_length_in_bytes div page_size;

  PASSTABLE_PAGE_LIMIT = passtable_page_max - 1;


type
  PASSTABLE_PAGE_INDEX = 0..passtable_page_limit;


(*	With version 6.00, the sched table includes values other than	*)
(*	schedules; it is a convenient place to store Netval parameters	*)
(*	that may be modified online, rather than in the config file.	*)

const
  SCHEDTABLE_FILE_ID = 'SCHD';
  SCHEDTABLE_FILE_LENGTH_IN_PAGES = 1;
  SCHEDTABLE_FILE_LENGTH_IN_BYTES = page_size; 
  SCHEDTABLE_HEADER_SIZE_IN_BYTES = 4;
  SCHEDTABLE_BYTE_LIMIT = page_size - 1;
  SCHEDTABLE_DATA_LENGTH =
    (integer_length_in_bytes * 9) +  (boolean_length_in_bytes * 3);
  SCHEDTABLE_FILLER_LENGTH = page_size - 4 - schedtable_data_length;
  SCHEDTABLE_FILLER_LIMIT = schedtable_filler_length - 1;	
  TAPE_SCHEDTABLE_LENGTH = page_size + 4;
  TAPE_SCHEDTABLE_SIZE_LIMIT = tape_schedtable_length - 1;


type
  SCHEDTABLE_FILLER_INDEX = 0..schedtable_filler_limit;

  SCHEDTABLE_DATA_INDEX = 0..schedtable_byte_limit;

  SCHEDTABLE_HEADER = array [0..3] of char;

  SCHEDTABLE_DATA = record
	consistency_enabled		: boolean;
	consistency_start		: integer;
	consistency_end			: integer;
	passchanger_enabled		: boolean;
	passchanger_schedule		: integer;
	passchanger_next_time		: integer;
	uunmerge_enabled		: boolean;
	uunmerge_schedule		: integer;
	uunmerge_next_time		: integer;
	continue_oplog_reporter_time	: integer;
	password_change_time_in_seconds : integer;
	standard_password_validity_period: integer
  end (* schedtable_data *);

  ACTUAL_SCHEDTABLE_DATA = record
	header		: schedtable_header;
	data		: schedtable_data;
	filler		: array [schedtable_filler_index] of char
  end (* actual_schedtable_data *);

  TAPE_SCHEDTABLE_IN_BYTES =  array [0..tape_schedtable_size_limit] of char;

  TAPE_SCHEDTABLE = record
	data		: actual_schedtable_data;
	checksum	: integer
  end (* schedtable_to_checksum *);

!
(**************     DISK CONFIGURATION     **************)


(* Define file lengths in pages of 256 bytes. *)



(********************************************************)
(*							*)
(*			Unit 0				*)
(*							*)
(********************************************************)



(*	The maximum possible size of the CUD file in pages:	*)

const
  CUD_FILE_LENGTH = (maximum_cud_block * maximum_cud_block_size) div page_size;



(* The start page of CUD file, beginning of disk unit:	*)

  CUD_FILE_START = 0;


(* The start and length of the CUD parameter file:	*)

  CUD_PARAMETER_FILE_START = CUD_FILE_LENGTH + 1;

  CUD_PARAMETER_FILE_LENGTH = last_param_page + 1;
!
(********************************************************)
(*							*)
(*			Unit 1				*)
(*							*)
(********************************************************)

  CONFIGURATION_FILE_START = 0;
  CONFIGURATION_FILE_LENGTH = 1;

  NODE_HOST_FILE_START = configuration_file_start + configuration_file_length;
  NODE_HOST_FILE_LENGTH = LAST_GROUP_DEFINITION_PAGE;

  CLASS_GROUP_FILE_START = node_host_file_start + node_host_file_length;
  CLASS_GROUP_FILE_LENGTH =
    (maximum_class_table_size + maximum_group_table_size) div page_size;


(****************************************************************)
(*								*)
(*	Define 2 buffers to hold CUD blocks on the		*)
(*	disk.  These are used for programmers to		*)
(*	store their CUD and MUD buffers, rather than		*)
(*	declaring them as permanent variables.			*)
(*	Since I/O is done in the DISK_SYSTEM (via		*)
(*	read_cud_block and write_cud_block) the			*)
(*	buffer locations must be in terms of BLOCKS,		*)
(*	not PAGES.  3 Blocks are allocated, since		*)
(*	CUD_MUD_BUFFER_START may not be on a block boundry.	*)
(*								*)
(****************************************************************)

(* in pages: *)
  CUD_MUD_BUFFER_START  = class_group_file_start + class_group_file_length;
  CUD_MUD_BUFFER_LENGTH = 3 *
$if BEFORE_SUP_V43  MAXIMUM_CUD_BLOCK_SIZE_IN_SECTORS;
$ifnot BEFORE_SUP_V43
    MAXIMUM_MUD_BLOCK_SIZE_IN_SECTORS + (2 * MAXIMUM_NUD_BLOCK_SIZE_IN_SECTORS);
$endif BEFORE_SUP_V43

(* in CUD blocks: *)
  CUD_MUD_BUFFER_LOCATION = (MAXIMUM_CUD_BLOCK_SIZE_IN_SECTORS +
			      	cud_mud_buffer_start) div
    				MAXIMUM_CUD_BLOCK_SIZE_IN_SECTORS;

(*ptr to mid of CUDMUD_BF*)
$if BEFORE_SUP_V43
  MUD_BUFFER_LOCATION = cud_mud_buffer_location + 1;
$endif BEFORE_SUP_V43
$ifnot BEFORE_SUP_V43
  MUD_BUFFER_LOCATION = (((cud_mud_buffer_location + 1)
    * MAXIMUM_CUD_BLOCK_SIZE_IN_SECTORS) + MAXIMUM_NUD_BLOCK_SIZE_IN_SECTORS)
    div MAXIMUM_MUD_BLOCK_SIZE_IN_SECTORS;
$endif BEFORE_SUP_V43


  OPERLOG_FILE_START = cud_mud_buffer_start + cud_mud_buffer_length;



(****************************************************************)
(* The MUDUPD file should be the maximum size possible, i.e.,	*)
(* the size of the entire disk less:				*)
(*	- all preceeding files 					*)
(*	- CUD/MUD ("programmer") buffers; since buffers are	*)
(*	  defined in terms of blocks, room is kept for 3 full	*)
(*	  buffers in case the first does not start on a CUD	*)
(*	  block boundry						*)
(*	- operlog						*)
(*	- if force_password_change then passtable needs room	*)
(*	- SCHEDTABLE goes at the very end of the disc		*)
(****************************************************************)

  MUD_UPDATE_FILE_START = operlog_file_start + operlog_file_length;
$if change_by_whom
" removed parenthesis on before disk and before mud"
" by SHSUE at 2-Jul-87 14:13:42"
$endif
  MUD_UPDATE_FILE_LENGTH = disk_unit_one_size - 
				schedtable_file_length_in_pages -
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if change_by_whom
"changed passtable_file_length_in_BYTES to PAGES by SHSUE at 17-Jul-87 10:00:16"
$endif
$if ganpass_file_exists
			    passtable_file_length_in_pages -
$endif ganpass_file_exists
$if include_dnic	    pages_in_dnic_header - (2 * pages_in_dnic_table) -
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
					 mud_update_file_start;

$if include_dnic
(* buffer DNIC data and table sent to SUPs *)
  DNIC_FILE_HEADER_START = mud_update_file_start + mud_update_file_length;
  DNIC_FILE_HEADER_LENGTH = pages_in_dnic_header;

  DNIC_FILE_DATA_START = dnic_file_header_start + dnic_file_header_length;
  DNIC_FILE_DATA_LENGTH = PAGES_IN_DNIC_TABLE;

  DNIC_BUFFER_START = dnic_file_data_start + dnic_file_data_length;
  DNIC_BUFFER_LENGTH = PAGES_IN_DNIC_TABLE;
$endif include_dnic
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if ganpass_file_exists
(************************************************************************)
(*									*)
(*	PASSTABLE is only present if either force_password_change or	*)
(*	global_password_only_login is ENabled (ganpass_file_exists).	*)
(*									*)
(************************************************************************)

  PASSTABLE_FILE_START =
$ifnot include_dnic    mud_update_file_start + mud_update_file_length;
$if include_dnic    dnic_buffer_start + dnic_buffer_length;
$endif ganpass_file_exists
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    *)


(****************************************************************)
(*	SCHEDTABLE is always 1 page long, regardless of		*)
(*	force_password_change or global_password_only_login	*)
(*	conditional compilation flags, because it is not worth	*)
(*	the complication of conditionaly compiling out one or	*)
(*	two words of table space.				*)
(****************************************************************)


(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    *)
$ifnot ganpass_file_exists
  SCHEDTABLE_FILE_START =
$ifnot include_dnic    mud_update_file_start + mud_update_file_length;
$if include_dnic    dnic_buffer_start + dnic_buffer_length;
$endif ganpass_file_exists 
$if ganpass_file_exists
  SCHEDTABLE_FILE_START =
    passtable_file_start + passtable_file_length_in_pages;
$endif ganpass_file_exists
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+    *)


(*    Configuration file format:    *)

const
  NETVAL_ID = 'NETVAL';
  UNUSED_CONFIGURATION_BYTES 	= 26
$if BEFORE_SUP_V43    + 2 (* cud_is_mud boolean replaces mud_version integer *)
$ifnone INCLUDE_DNIC    + 4 + 12 (* DNIC table and size not included *)
$ifnot ganpass_file_exists      + 12 (* sub file *)
;
  UNUSED_CONFIGURATION_LIMIT 	= unused_configuration_bytes - 1;
  ORIGINAL_INCARNATION		= 0;
  CURRENT_INCARNATION		= 1;



(* Other values may be added to the CONFIGURATION_FILE	*)
(* at a later time.  UNUSED_CONFIGURATION_BYTES must	*)
(* then be updated.					*)
(* The information in configuration_information from the*)
(* disk is compared against NETVAL parameters at	*)
(* start-up time, and NETVAL crashes if any differences.*)

type
  CONFIGURATION_INFORMATION = record
    id			: array [0..5] of char (* NETVAL_ID *);
    incarnation_number,
    label_date_and_time,
    pages_on_disk_one	: integer (* DISK_UNIT_ONE_SIZE *);
    files		: file_system_descriptor;
    cud_block_size_in_sectors	(* MAXIMUM_CUD_BLOCK_SIZE_IN_SECTORS *),
    supervisors				(* MAXIMUM_EXPECTED_SUPERVISORS *),
    cud_blocks		: integer	(* MAXIMUM_CUD_BLOCK *);
    gans				(* INCLUDE_GAN *),
    districts		: boolean	(* INCLUDE_DISTRICT *);
    password_size	: integer	(* MINIMUM_PASSWORD_SIZE *);
    non_alpha_password			(* REQUIRE_NONALPHANUMERIC *),
    zero_class_group_assignable : boolean (* CLASS_0_GROUP_0_ASSIGNABLE *);
$if BEFORE_SUP_V43    cud_is_mud: boolean	(* NETVAL_CUD_IS_A_MUD *);
$ifnone BEFORE_SUP_V43    mud_version		 (* MUD_VERSION *),
    programmer_size	: integer	(* PROGRAMMER_NAME_SIZE *);
    programmer		: username_text (* PROGRAMMER_NAME *);
    hosts				(* MAXIMUM_HOST *),
    nodes				(* MAXIMUM_NODE *),
    classes				(* MAXIMUM_CLASS *),
    class_table_size			(* MAXIMUM_CLASS_TABLE_SIZE *),
    groups				(* MAXIMUM_GROUP *),
    group_table_size	: integer	(* MAXIMUM_GROUP_TABLE_SIZE *);
$if INCLUDE_DNIC    dnic_table_size	: integer (* MAXIMUM_DNIC_TABLE_SIZE *);
    last_pvol_time_stamp: integer (* if LVOL are used, last time *);
				  (* a write was known successful *)
    pages_on_disk_zero	: integer (* DISK_UNIT_ZERO_SIZE *);
    unused		: array [0..unused_configuration_limit] of char;
    checksum		: integer
  end (* configuration_information *);



(*	The following is used to describe the access state	*)
(*	of a file; access to files are handled in a Monitor	*)
(*	for each file, since access is specific to the file	*)
(*	and how it is used.					*)

type
  FILE_ACCESS_STATE = (
    FILE_AVAILABLE	(* usable *),
    FILE_READABLE	(* read-only *),
    FILE_LOCKED		(* not accessable *));


  FILE_UTILITY_STATUS = (FU_SUCCESS, FU_IO_ERROR, FU_CHECKSUM_ERROR);
!
$ifany (force_password_change, global_password_only_login)
(************************************************************************)
(*									*)
(*	PASDEF.NTV							*)
(*									*)
(*      This file contains all Passtable file definitions.		*)
(*									*)
(************************************************************************)
(*									*)
(*			revision record					*)
(*      								*)
(*	22Dec88 - neh							*)
(*		- add start_date to passtable_entry			*)
(*	09Apr87	- rsb							*)
(*		- Original						*)
(*									*)
(************************************************************************)

const
  PASSTABLE_FILE_ID = 'PASS';

  PASSTABLE_HEADER_LIMIT = passtable_header_size_in_bytes -1;

  PASSTABLE_ENTRY_LIMIT = number_of_passtable_entries;

  PASSTABLE_SIZE_RANGE = number_of_passtable_entries + 1;

  PASSTABLE_BYTE_LIMIT = passtable_file_length_in_bytes - 1;

  PASSTABLE_FILLER_LIMIT = passtable_filler_length -1;

  PASSTABLE_DATA_LIMIT = passtable_byte_limit - (
	passtable_header_size_in_bytes + passtable_filler_length);

  TAPE_PASSTABLE_LENGTH = passtable_file_length_in_bytes + 4;

  TAPE_PASSTABLE_SIZE_LIMIT = tape_passtable_length - 1;

  PASSCHANGER_NAME = 'Passchanger         ';

  PASSCHANGER_NAME_SIZE = 11;


type
  PASSLIFE_INDEX = 0..MAXIMUM_GANPASS_PERIOD;

  PASSTABLE_ENTRY_INDEX = 0..passtable_entry_limit;

  PASSTABLE_BYTE_INDEX = 0..passtable_byte_limit;

  PASSTABLE_HEADER_INDEX = 0..passtable_header_limit;

  PASSTABLE_DATA_INDEX = 0..passtable_data_limit;

  PASSTABLE_FILE_LENGTH = 0..passtable_file_length_in_bytes;

  PASSTABLE_FILLER_INDEX = 0..passtable_filler_limit;

  PASSTABLE_DISC_HEADER = record
    file_id	: word_in_bytes 		(* should be PASSTABLE_ID *);
    tail	: 0..passtable_size_range
  end (* passtable_disc_header *);


  PASSTABLE_ENTRY = record
    gan		: integer;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if force_password_change
$if request_fpc_start    start_date	: integer (* date to take effect *);
    passlife	: passlife_index (* GAN's Password validity Period *);
    fpc		: boolean (* passlife field is meaningfull *)
$if global_password_only_login ;
$endif force_password_change
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if global_password_only_login
    gpo		: boolean (* GAN's members can use GPO *)
$endif global_password_only_login
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  end (* passtable_entry *);


  PASSTABLE_IN_ENTRIES = array [passtable_entry_index] of passtable_entry;

  ACTUAL_PASSTABLE_DATA = record
	header		: passtable_disc_header;
	data		: passtable_in_entries;
	filler		: array [passtable_filler_index] of char
  end (* actual_passtable_data *);

  TAPE_PASSTABLE_IN_BYTES = array [0..tape_passtable_size_limit] of char;

  TAPE_PASSTABLE = record
	data		: actual_passtable_data;
	checksum	: integer
  end (* passtable_to_checksum *);

  PASSTABLE_IN_PAGES = array [passtable_page_index] of page;

$endif any force_password_change or global_password_only_login
!
(************************************************************************)
(*									*)
(*	MCHDEF.NTV							*)
(*									*)
(*      This file contains all MUD change file defintions.		*)
(*									*)
(************************************************************************)
(*									*)
(*			revision record					*)
(*      								*)
(*	05Nov87 - neh							*)
(*	      - add last_dnic_update to SUPERVISOR_DISK_INFORMATION	*)
(*	      - add last_dnic_sent, dnic_on_all_sups and		*)
(*		dnic_on_some_sups to MUDUPD_DISK_HEADER if INCLUDE_DNIC	*)
(*		is enabled						*)
(*	13Feb87 - neh							*)
(*	        - add UN2_VERSION_ERROR, UN2_TOO_MANY_DISK_ERRORS and	*)
(*		  UN2_OPTION_ERROR to UN2_STATUS enumeration type	*)
(*		  if BEFORE_SUP_V43 is disabled				*)
(*	31Jul86 - rsb							*)
(*		- add CURRENT_UN2_ACTIVITY enumeration type as a direct *)
(*		  way of knowing what is going on in relation to a Sup, *)
(*		  instead of inferring it from examining mud_updater_	*)
(*		  delay_que and consistency_start_date			*)
	(*		merge 4.00 and 5.00 neh			*)
(*	21Apr87 - rsb							*)
(*		- add data for passchanger and uunmerge run times to	*)
(*		  header so the header holds all schedule data		*)
(*	10Mar86 - jrn							*)
(*	      - redo REUSE_UUNS to maintain a bit map for 18 bit UUNS	*)
(*		and change the add back scheme to be a dated list	*)
(*	      - change merge_month to last_merge			*)
(*	20Jan86 - jrn							*)
(*	        - modify USN code for NVDM				*)
(*	23Dec85 - rsb							*)
(*		- change definition of MAXIMUM_MUDUPD_SUPERVISOR AND	*)
(*		  MUDUPD_SUPERVISOR_INDEX for USN: 			*)
(*                change "MUDUPD" into "REAL"				*)
(*		- redefine SUPERVISOR_INDICATOR because of above	*)
(*		- added definitions for:				*)
(*                     PSEUDO_SUPERVISOR_INDEX  			*)
(*                     EMPTY_ENTRY 					*)
(*                     ps_table_search_range 				*)
(*		- SET_SUPERVISOR_STATUS add USN-related errors		*)
(*									*)
(************************************************************************)


(* Define bytes and pages in the MUD_UPDATE_FILE: *)

const
  PAGES_IN_MUDUPD_HEADER = 1;
  MUDUPD_HEADER_ADDRESS = 0;



(* Define the address of a byte of data in the		*)
(* MUD_UPDATE_FILE in terms of a specific page		*)
(* and byte in the page.  This is used internally	*)
(* to help in accessing the file.			*)

  MUDUPD_PAGE_LIMIT = mud_update_file_length - 1;


type
  MUDUPD_PAGE_INDEX = 0..mudupd_page_limit;

  MUDUPD_ADDRESS = record
    page_offset : mudupd_page_index;
    byte_offset : page_index
  end (* mudupd_address *);



(*	Define the address of a byte of data		*)
(* (MUDUPD_DATA_INDEX) in the MUD_UPDATE_FILE. This	*)
(* is the actual "address" recorded for last_record	*)
(* and disk_eof.					*)

(* MUD_UPDATE_FILE_LENGTH is defined in fildef.ntv *)

const
  MUDUPD_DATA_MAX =
    (mud_update_file_length - pages_in_mudupd_header) * page_size;
  MUDUPD_DATA_LIMIT = mudupd_data_max - 1;


type
  MUDUPD_DATA_INDEX = 0..mudupd_data_limit;



(* Define Supervisors values. *)

const
  FIRST_SUPERVISOR = 1;

(* for printing only *)
   PRINT_SUPERVISOR_OFFSET = 120;


(**** all possible Supervisors ****)

const
  MAXIMUM_REAL_SUPERVISOR = 7;

type
  REAL_SUPERVISOR_INDEX = FIRST_SUPERVISOR..MAXIMUM_REAL_SUPERVISOR;


(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code
  PSEUDO_SUPERVISOR_INDEX = FIRST_SUPERVISOR..MAXIMUM_EXPECTED_SUPERVISORS;
$endif disk_maintenance_code
$if disk_maintenance_code
  PSEUDO_SUPERVISOR_INDEX = FIRST_SUPERVISOR..MAXIMUM_REAL_SUPERVISOR;
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

const
  EMPTY_ENTRY = 0;

type
  ps_table_search_range = EMPTY_ENTRY..MAXIMUM_REAL_SUPERVISOR;




(*	The following describes Supervisor information	*)
(*	in the MUD_UPDATE_FILE header:			*)

type		(* consistency run information *)
  CONSISTENCY_INFO = record
    start_date	: integer		(* start of run *);
    block	: cud_block_index	(* last processed *);
    manual	: boolean		(* run started manually *);
    stopped	: boolean		(* run stopped by command *)
  end (* consistency_info *);


  CONSISTENCY_HISTORY_INFO = record
    consistency : consistency_info;
    stop_date   : integer   	(* run stopped *)
  end (* consistency_history_info *);


(*	The following describes Supervisor information: *)

const
  SUPERVISOR_OFF = 0;


type
  SUPERVISOR_INDICATOR = supervisor_off..maximum_real_supervisor;

  SUPERVISOR_DISK_INFORMATION = record
    state           : supervisor_indicator;
    pointer         : mudupd_data_index (* next record *);
    last_mud_update,          (* date of last MUD update *)
    last_cg_update  : integer (* Class/group update date *);
    history         : consistency_history_info
  end (* supervisor_disk_information *);


  HEADER_SUPERVISOR_INFORMATION =
    array [real_supervisor_index] of supervisor_disk_information;



(*	The record to describe the first block	*)
(*	Of the MUD_UPDATE_FILE is:		*)

const
  MUDUPD_ID = 1515847745 (* hex 5A5A0041 *);



(*	The disk_eof is a pointer to the actual physical end of data	*)
(*	in the MUD_UPDATE_FILE, i.e., the pointer to where to store	*)
(*	the next CUD change record.  "last_record" points to the	*)
(*	beginning of data in the last record stored in the file.	*)

(*	"last_record" is used to determine if the last CUD change	*)
(*	was totally completed; when a CUD change is made:		*)
(*		- the MUD_UPDATE_FILE is notified that a		*)
(*		  change is pending and the change is			*)
(*		  recorded in the MUD_UPDATE_FILE			*)
(*		- the changed CUD block is written out			*)
(*		  to the disk						*)
(*		- the change is confirmed to the			*)
(*		  MUD_CHANGE_HANDLER					*)

(*	When a change is appended to the file, last_record is set to	*)
(*	disk_eof; when the system is initialized, the information in	*)
(*	the record pointed to by "last_record" is compared against	*)
(*	the actual data in the CUD; if the data does NOT match, the	*)
(*	data in the last record is thrown away (disk_eof is set to	*)
(*	last_record) and the MUDs are not notified of that change.	*)
(*	This should only be possible if NETVAL crashes between the	*)
(*	MUD_UPDATE_FILE's notification of a CUD change and the		*)
(*	confirmation of the CUD change.					*)

type
  MUDUPD_DISK_HEADER = record
    file_id          : integer  (* should be MUDUPD_ID *);
    disk_eof         : mudupd_data_index (* see comments above *);
    last_cg_creation : integer (* date of last Class/group creation *);
$ifnone INCLUDE_DNIC
    unused_1	     : array [0..3] of char;
    unused_2	     : array [0..3] of char;
$endif INCLUDE_DNIC
$if INCLUDE_DNIC
    last_dnic_update : integer (* date dnic updated to disk *);
    dnic_on_all_sups : boolean (* all sups received last sent DNIC *);
    dnic_on_some_sups: boolean (* some sups received last sent DNIC *);
$endif INCLUDE_DNIC
    last_passchanger : integer;
    last_record      : mudupd_data_index (* see comments above *);
    last_merge	     : integer (* time UUN, add_back files were last merged *);
    sup_disc_info    : header_supervisor_information
  end (* mudupd_disk_header *);

$if INCLUDE_DNIC
  (* DNIC file definitions *)
  DNIC_TABLE_HEADER = record
    file_id	: array [0..3] of char;
    dnic_count	: non_default_data_size;
    was_sent	: boolean (* TRUE if table sent to sup *);
    date_updated: integer (* REALTIME when DNIC was updated *);
    last_sent 	: integer (* REALTIME when DNIC was sent to sups *);
    sup_update 	: array [real_supervisor_index] of integer;
    unused 	: array [0..205] of char;
    checksum 	: integer
  end (* dnic_header *);

  DNIC_FILE_DATA = record
    header	: dnic_table_header;
    data	: dnic_data_table
  end (* dnic_file_data *);
$endif INCLUDE_DNIC



(*	The following definition is used to pass MUD	*)
(*	changes between MUD_UPDATER Processes and	*)
(*	validator Processes and the UN2_UTILITY Class	*)

type
  MUD_UPDATE_INFORMATION = record
    cud_info : cud_change_information;
    checksum : integer
  end (* mud_update_information *);

type
  UN2_STATUS = (
	UN2_SUCCESSFUL		(* operation complete *),
	UN2_BUSY		(* circuit in use by consistency *),
	UN2_BUILD_FAILURE	(* Sup unavailable *),
	UN2_UNEXPECTED_INPUT	(* char received not in protocol *),
        UN2_TOO_MANY_RETRIES	(* resent block too many times *),
	UN2_HANDSHAKE_ERROR	(* handshake failed *),
$ifnone BEFORE_SUP_V43
	UN2_VERSION_ERROR (* received wrong version *),
	UN2_TOO_MANY_DISK_ERRORS (* too many sup disk errors *),
	UN2_OPTION_ERROR (* error in receiving options *),
$endif BEFORE_SUP_V43
	UN2_CIRCUIT_ERROR	(* lost circuit/circuit zapped *));


type
  CONSISTENCY_STATUS = (
    CONSISTENCY_OK	(* all is good *),
    UN2_ERROR		(* some problem on circuit *),
    CUD_ERROR		(* some problem on file *),
    CONSISTENCY_STOPPED	(* stopped by cmd or time *),
    CONSISTENCY_DONE);



  SET_SUPERVISOR_STATUS = (
    SET_SUP_SUCCESSFULL,
    SET_SUP_AUTO_CONSISTENCY_HALTED,
    SET_SUP_NO_ROOM_IN_PSEUDO_SUP_TABLE,
    SET_SUP_ALREADY_IN_PSEUDO_SUP_TABLE,
    SET_SUP_MANUAL_CONSISTENCY_IN_PROGRESS,
    SET_SUP_ALREADY_ON,
    SET_SUP_ALREADY_OFF,
    SET_SUP_OFF_ALREADY_IN_PROGRESS);


(* Current Netval-to-Sup communications activity *)
type
  CURRENT_COMM_ACTIVITY = (
	NOT_BUSY,	
	AUTO_CONSISTENCY, 
	MANUAL_CONSISTENCY,
	MUD_UPDATING);

(************************************************************************)
(*									*)
(*	ARCDEF.NTV							*)
(*									*)
(************************************************************************)
(*									*)
(*			    Revision Record				*)
(*									*)
(*	06Dec89 - neh							*)
(*		- add second volume header				*)
(*		  divide label id into string 'VOL' and number		*)
(*	15Feb 88 - neh							*)
(*		- add DNIC tape definitions				*)
(*	23Feb87 - neh							*)
(*	      - include read cud in tape definition if CONVERT_TO_43 	*)
(*		is enabled						*)
(*	13May86 - neh							*)
(*	      - if INCLUDE_DUMP is enabled add ascii_dump parameters	*)
(*	31Jul84 - jrn							*)
(*	      - standard ANSII format tapes				*)
(*									*)
(************************************************************************)


type
  TAPE_ASSIGN_STATUS = (ASSIGN_OK, ALREADY_ASSIGNED, ATTACH_FAILED);


(************************************************************************)
(*									*)
(*	ALL LABELS USE ANSII_TAPE_LABEL for manipulating data, due	*)
(*	to the painful fact that character strings must start on	*)
(*	a halfword boundry; also, note that there are some odd		*)
(*	length strings in the record definitions, due to odd length	*)
(*	fields in the ANSII standard.					*)
(*									*)
(************************************************************************)

const
  max_ansii_tape_label_size = 80 (* the size of ALL ANSII standard labels *);
  ansii_tape_label_limit = max_ansii_tape_label_size - 1;
  max_volumes = 9 (* maximum number of tape volumes - 1 digit *);

type
  ansii_tape_label_size = 0..max_ansii_tape_label_size;
  ansii_tape_label_index = 0..ansii_tape_label_limit;

  ansii_tape_label = array [ansii_tape_label_index] of char;


(************************************************************************)
(*                                                                      *)
(*  Global label definitions for ANSII Magnetic tape standard.		*)
(*                                                                      *)
(************************************************************************)

const
  label_owner_id = 'NETVAL \';

  label_id_offset = 0;
  label_id_size = 4;
  label_volume_offset = 3;

  label_file_name_offset = 4;
  label_file_name_size = 17;

  label_set_id_offset = 21;
  label_set_id_size = 6;

(* The "section" of a file is incremented by one	*)
(* on each subsequent volume of the file.		*)
  label_file_section = 1 (* first section for each file *);
  label_file_section_offset = 27;
  label_file_section_size = 4;

  label_file_sequence_offset = 31;
  label_file_sequence_size = 4;

  label_generation_number_offset = 35;
  label_generation_number_size = 4;

  label_generation_version_number_offset = 39;
  label_generation_version_number_size = 2;

  label_creation_date_offset = 42;
  label_expiration_date_offset = 48;
  label_date_size = 5;

  label_block_count_offset = 54;
  label_block_count_size = 6;
!
(************************************************************************)
(*                                                                      *)
(*  Volume label definitions for ANSII Magnetic tape standard:		*)
(*	bytes 0 - 39:	"VOLnddmmyy                           NET"	*)
(*	bytes 40 - 79:	"VAL vv.rr                              1"	*)
(*                                                                      *)
(************************************************************************)

const
  vol_id = 'VOL1\ '	(* use label_id_offset *);

  volume_header_date_day_offset = 4;
  volume_header_date_month_offset = 6;
  volume_header_date_year_offset = 8;
  volume_header_date_size = 6;

  volume_header_owner_offset = 37;
  volume_header_owner_size = 7;

  volume_header_version_offset = 44;
  volume_header_version_size = 5;

  volume_header_standard_level_offset = 79;
  volume_header_standard_level = '1';


(* The entire VOLn label description, for information only;		*)
(* ALL LABELS USE LABEL_IN_BYTES for manipulating data, (see above).	*)
"type
    vol1_label = record
    label_id		: array [0..3] of char  (* VOLn_ID *);
    serial_number	: array [0..5] of char  (* 'DDMMYY' *);
    accessibility	: char			(* ' ' (unlimited) *);
    reserved1		: array [0..25] of char (* must be ' ' *);
    owner_id		: array [0..6] of char  (* LABEL_OWNER_ID *);
    version_id		: array [0..4]	  	(* 'VV.RR' *);
    reserved2		: array [0..29] of char (* must be ' ' *);
    label_level		: char			(* VOLn_STANDARD_LEVEL *)
  end (* vol1_label *);"
!
(************************************************************************)
(*                                                                      *)
(*  File header 1 label definitions for ANSII Magnetic tape standard:	*)
(*	bytes 0 - 39:	"HDR1file identifier  NETVALssssnnnn00010"	*)
(*	bytes 40 - 79:	"0 yyddd yyddd 000000                    "	*)
(*                                                                      *)
(************************************************************************)

const 
  hdr1_id = 'HDR1\ '	(* use label_id_offset *);

(* The entire HDR1 label description, for information only;		*)
(* ALL LABELS USE LABEL_IN_BYTES for manipulating data, (see above).	*)
"type
  hdr1_label = record
    label_id		: array [0..3] of char  (* HDR1_ID *);
    file_identifier	: array [0..16] of char (* NETVAL file name *);
    set_identifier	: array [0..5] of char  (* 'NETVAL' *);
    file_section	: array [0..3] of char  (* 0001, 0002, etc. *);
    file_sequence	: array [0..3] of char  (* sequential file number *);
    generation		: array [0..3] of char  (* 0001 *);
    version		: array [0..1] of char  (* 00 *);
    creation_date	: array [0..5] of char  (* ' YYDDD' *);
    expiration_date	: array [0..5] of char  (* ' YYDDD' *);
    accessibility	: char			(* ' ' (unlimited) *);
    block_count		: array [0..5] of char  (* '000000' *);
    reserved		: array [0..19] of char (* ' ' *)
  end (* hdr1_label *);"
!
(************************************************************************)
(*                                                                      *)
(*  File header 2 label definitions for ANSII Magnetic tape standard:	*)
(*	bytes 0 - 39:	"HDR2Fbbbbbrrrrr                         "	*)
(*	bytes 40 - 79:	"          00                            "	*)
(*                                                                      *)
(************************************************************************)

const 
  hdr2_id = 'HDR2\ ';

  hdr2_format = 'F' 		(* size is in first 4 bytes of each record *);
				(* in binary, USUALLY followed by checksum *)
  hdr2_format_offset = 4;

  hdr2_block_length_offset = 5;
  hdr2_block_length_size = 5;

  hdr2_record_length_offset = 10;
  hdr2_record_length_size = 5;

  hdr2_buffer_offset = 50;
  hdr2_buffer_offset_size = 2;


(* The entire HDR2 label description, for information only;		*)
(* ALL LABELS USE LABEL_IN_BYTES for manipulating data, (see above).	*)
"type
  hdr2_label = record
    label_id		: array [0..3] of char	(* HDR2_ID *);
    record_format	: char			(* HDR2_FORMAT *);
    block_length	: array [0..4] of char	(* max. block length *);
    record_length	: array [0..4] of char	(* record length *);
    reserved1		: array [0..34] of char	(* ' ' *);
    buffer_offset	: array [0..1] of char	(* 00 *);
    reserved2		: array [0..27] of char	(* ' ' *)
  end (* hdr2_label *);"
!
(************************************************************************)
(*                                                                      *)
(* End-of-file label definitions for ANSII Magnetic tape standard.	*)
(* EOF1 fields are the same as corresponding fields in the first file	*)
(* header EXCEPT for the id and block_count.				*)
(*                                                                      *)
(************************************************************************)

const 
  eof1_id = 'EOF1\ ';
!
(****************************************************************)
(*								*)
(*	Files which use the blocking factor to write to tape	*)
(*	(CUD, OPERLOG and, if REUSE_UUNS is enabled, the CUD	*)
(*	PARAMETER file) use the following data structures:	*)
(*								*)
(****************************************************************)


(****************************************************************)
(*								*)
(*	The CUD tape block is composed of CUD blocks and 	*)
(*	their block number; the other files use tape blocks	*)
(*	which are composed of page numbers and page data	*)
(*								*)
(****************************************************************)

const
  (* Size of one CUD tape block in bytes: *)

$if CONVERT_TO_43  TAPE_CUD_BLOCK_SIZE = (MAXIMUM_READ_CUD_BLOCK_SIZE + 4) * TAPE_BLOCKING_FACTOR;
$ifnone CONVERT_TO_43  TAPE_CUD_BLOCK_SIZE = (MAXIMUM_CUD_BLOCK_SIZE + 4) * TAPE_BLOCKING_FACTOR;
  TAPE_CUD_BLOCK_BYTE_LIMIT = TAPE_CUD_BLOCK_SIZE - 1;

  TAPE_CUD_BLOCK_LIMIT = tape_blocking_factor - 1;

type
  TAPE_CUD_BLOCK_IN_BYTES = array [0..TAPE_CUD_BLOCK_BYTE_LIMIT] of char;
  TAPE_CUD_BLOCK_INDEX = 0..tape_cud_block_limit;
  
  TAPE_CUD_RECORD = record
    block	: cud_block_index;
$if CONVERT_TO_43    cud_data	: read_cud_disk_block
$ifnone CONVERT_TO_43    cud_data	: cud_disk_block
  end (* tape_cud_record *);

  TAPE_CUD_BLOCK = array [tape_cud_block_index] of tape_cud_record;


const
  (* The TAPE_PAGE_BLOCK and the TAPE_CUD_BLOCK are approximately the	*)
  (* same size, but the factored_tape_page_block will be		*)
  (* MAXIMUM_CUD_BLOCK_SIZE_IN_SECTORS - 1 * tape_blocking_factor	*)
  (* words larger.							*)

  TAPE_PAGE_BLOCKING_FACTOR =
$if BEFORE_SUP_V43    MAXIMUM_CUD_BLOCK_SIZE_IN_SECTORS
$ifnot BEFORE_SUP_V43    MAXIMUM_MUD_BLOCK_SIZE_IN_SECTORS
    * TAPE_BLOCKING_FACTOR;
    
  (* Size of one factored tape page block in bytes *)
  TAPE_PAGE_BLOCK_SIZE =  (page_size + 4) * tape_page_blocking_factor;
  TAPE_PAGE_BLOCK_BYTE_LIMIT =  TAPE_PAGE_BLOCK_SIZE - 1;

  TAPE_PAGE_BLOCK_LIMIT = tape_page_blocking_factor - 1;

type
  TAPE_PAGE_BLOCK_IN_BYTES = array [0..TAPE_PAGE_BLOCK_BYTE_LIMIT] of char;
  TAPE_PAGE_BLOCK_INDEX = 0..tape_page_block_limit;

  (* Used by OPERLOG and, if REUSE_UUNS is enabled, CUD_PARAMETER file *)

  TAPE_PAGE_RECORD = record
    page_offset	: integer;
    page_data	: page_record
  end (* tape_page_record *);

  TAPE_PAGE_BLOCK = array [tape_page_block_index] of tape_page_record;
    
  BLOCKED_PAGE_CHECKSUMS = array [tape_page_block_index] of boolean;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if include_dump
!
(************************************************************************)
(*									*)
(*	The following constants and types are used by the dump tape	*)
(*	command if INCLUDE_DUMP is enabled.				*)
(*									*)
(************************************************************************)

const
(* DUMP tape record size is string size of ascii formatted CUD data *)
(* Formatted data is half the size of format buffer text *)

  ASCII_DUMP_DATA_SIZE = 80;

(* Chars in min pages per block of 80 byte ascii strings, total 1280 bytes *)
  ASCII_DUMP_CHARS_IN_PAGES = ascii_dump_data_size * 16;

(* the constant value of an ascii block size in bytes *)
  ASCII_DUMP_BLOCK_SIZE = ascii_dump_blocking_factor *
    ascii_dump_chars_in_pages;
  ASCII_DUMP_BLOCK_BYTE_LIMIT = ascii_dump_block_size - 1;

  ASCII_DUMP_BLOCK_STRING_LIMIT = (ascii_dump_block_size
    div format_buffer_text_max) - 1;

type
  ASCII_DUMP_BLOCK_IN_BYTES = array [0..ascii_dump_block_byte_limit] of char;
  ASCII_DUMP_TAPE_BLOCK_INDEX = 0..ascii_dump_block_string_limit;
  ASCII_DUMP_TAPE_BLOCK = array [ascii_dump_tape_block_index]
    of format_buffer_text;
$endif include_dump
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
(************************************************************************)
(*									*)
(*	The tape_named_list_definition record, used for hostlists	*)
(*	and nodelists.  Empty lists are not stored.  Lists are		*)
(*	uniquely identified by their list_descriptor.			*)
(*									*)
(************************************************************************)
(*									*)
(*	the maximum size of tape_named_list_definition is the size of:	*)
(*	    list_ptr (4)						*)
(*	    named_list (MAXIMUM_BYTES_IN_NAMED_LIST)			*)
(*									*)
(************************************************************************)

const
  TAPE_NAMED_LIST_DEFINITION_SIZE = maximum_bytes_in_named_list + 4;
  TAPE_NAMED_LIST_DEFINITION_LIMIT = TAPE_NAMED_LIST_DEFINITION_SIZE - 1;

type
  TAPE_NAMED_LIST_DEFINITION_IN_BYTES =
    array [0..TAPE_NAMED_LIST_DEFINITION_LIMIT] of char;
  TAPE_NAMED_LIST_DEFINITION = record
    list_ptr	: list_index;
    named_list	: named_list_definition
  end (* tape_named_list_definition *);
!
(************************************************************************)
(*									*)
(*	The tape_global_access_definition record, used for classes and	*)
(*	groups.  Undefined global accesses are not stored.		*)
(*									*)
(************************************************************************)
(*									*)
(*	the size of tape_global_access_definition is the size of:	*)
(*	    global value (4) 						*)
(*	    global_access_descriptor					*)
(*		(MAXIMUM_BYTES_IN_GLOBAL_ACCESS_DESCRIPTION)		*)
(*									*)
(************************************************************************)

const
  MAXIMUM_TAPE_GLOBAL_ACCESS_DEFINITION_SIZE =
    MAXIMUM_BYTES_IN_GLOBAL_ACCESS_DESCRIPTION + 4;
  TAPE_GLOBAL_ACCESS_DEFINITION_SIZE_LIMIT =
    MAXIMUM_TAPE_GLOBAL_ACCESS_DEFINITION_SIZE - 1;

type
  TAPE_GLOBAL_ACCESS_DEFINITION_IN_BYTES =
   array [0..TAPE_GLOBAL_ACCESS_DEFINITION_SIZE_LIMIT] of char;
  TAPE_GLOBAL_ACCESS_DEFINITION = record
    global_value	: integer;
    global_access	: global_access_description
  end (* tape_global_access_definition *);

!
(************************************************************************)
(*									*)
(*	The tape_mudupd_header_definition				*)
(*									*)
(************************************************************************)

const
  MAXIMUM_TAPE_MUDUPD_HEADER_SIZE = page_size + 4;
  TAPE_MUDUPD_HEADER_SIZE_LIMIT = MAXIMUM_TAPE_MUDUPD_HEADER_SIZE - 1;

type
  TAPE_MUDUPD_HEADER_IN_BYTES =
    array [0..TAPE_MUDUPD_HEADER_SIZE_LIMIT] of char;

  TAPE_MUDUPD_HEADER_DEFINITION = record
    mudupd_info	: mudupd_disk_header;
    checksum	: integer
  end (* tape_mudupd_header_definition *);
$if INCLUDE_DNIC

const
  TAPE_DNIC_LENGTH = dnic_file_length + maximum_bytes_in_word;
  TAPE_DNIC_LIMIT = tape_dnic_length - 1;

type
  TAPE_DNIC_IN_BYTES = array [0..tape_dnic_limit] of char;

  TAPE_DNIC_FILE = record
	file	: dnic_file_data;
	checksum: integer
  end (* tape_dnic_file *);
$endif INCLUDE_DNIC

!
(************************************************************************)
(*									*)
(*	CMDDEF.NTV							*)
(*									*)
(*	Constants and global types for commands.			*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	23Jan89 - neh							*)
(*		- add FILTER_MODIFY_EXPIRE_DATE_KEYWORD to NVDM 	*)
(*		  filter commands to correct compile error		*)
(*	04Jan89 - neh							*)
(*		- increase COMMAND_KEYWORD_MAX to 50			*)
(*	04Nov88 - jrn							*)
(*		 - add allow_temporary_apes and perform_daily_cud_scan	*)
(*		  commands						*)
(*	03Oct88 - jrn							*)
(*		- add definitions for the following NETVAL commands:	*)
(*				CHANGE VALIDITY				*)
(*				DISPLAY VALIDITY			*)
(*				SET VALIDITY				*)
(*				SELECT CONTROL EE			*)
(*		- add definitions for the following NVDM commands:	*)
(*				DISPLAY PASSPERIOD			*)
(*				DISPLAY VALIDITY			*)
(*				SET PASSPERIOD				*)
(*				SET VALIDITY				*)
(*		- add PRIMARY_SELECT_CONTROL_LOGON_INHIBIT_KEYWORD	*)
(*		- change allow_user_password_expire to			*)
(*		  password_expiration_by_user and check out code	*)
(*		- use password_expiration_date_in_cud for code that is	*)
(*		  required for global or user password expiration	*)
(*		- use ganpass_file_exists				*)
(*		- add code for prevent_duplicate_passwords		*)
(*		- add code for restrict_users_by_time			*)
(*		- redefine primary_change's primary_set's and		*)
(*		  primary_display's for clarity, sanity			*)
(*		  and simplicity					*)
(*	        - add allow_logon_inhibit code				*)
(*	22Feb88 - neh							*)
(*	      - add change validity gan, change validity user and	*)
(*		display validity					*)
(*	09Nov87 - neh							*)
(*	      - add primary commands NEW DNIC, DELETE DNIC, CHANGE	*)
(*		DNIC, DISPLAY DNIC, SEND DNIC and READ DNIC plus 	*)
(*		archive	command RESTORE DNIC FILE			*)
(*	15Aug87 - neh							*)
(*	        - remove TYMSHARE_CUD_FORMAT flag, add INCLUDE_IRC	*)
(*		  and check_time_status, make GFD conditional on	*)
(*		  NETVAL_IS_A_SLAVE					*)
		(*      - merge FPC and GPO with 5.00		*)
(*      12Jun87 - neh                                                   *)
(*            - add select access control commands                      *)
(*	24Feb87 - neh							*)
(*	        - add REFORMAT command					*)
(*	05Jan87	- rsb							*)
(*		- add PRIMARY_DISPLAY_DIRECTORY_EXPIREDATE_KEYWORD	*)
(*	20Nov86 - rsb							*)
(*		- add PRIMARY_CLEAR_CONSISTENCY_KEYWORD			*)
(*		      PRIMARY_CLEAR_GANPASS_KEYWORD, 			*)
(*		      PRIMARY_CLEAR_GPOGAN_KEYWORD			*)
(*		- move SET_SCHEDULE to PRIMARY_SCHEDULE.CONSISTENCY	*)
(*		- add SCHEDULE_PASSCHANGER				*)
(*		- add SET_GANPASS					*)
(*		- add SET_GPOGAN					*)
(*		- add DISPLAY_SCHEDULE, DISPLAY_GPOGAN, DISPLAY_GANPASS *)
(*		- add DISPLAY_GANPASS_FILTER, DISPLAY_GPOGAN_FILTER	*)
(*		  and DISPLAY_SCHEDULE_FILTER				*)
(*	02Sep86 - neh							*)
(*	      - Change GLOBAL_MESSAGE to PRIMARY_MESSAGE to make	*)
(*		MESSAGE_COMMAND a primary command.			*)
(*	      - Change GLOBAL_MESSAGE_KEYWORD_OFFSETs to		*)
(*		PRIMARY_MESSAGE_KEYWORD_OFFSETs.			*)
(*	      - Add PRIMARY_DISPLAY_FILTER_KEYWORD_OFFSET and		*)
(*		PRIMARY_FILTER_KEYWORD_OFFSET.				*)
(*	14Aug86 - jrn							*)
(*	      - add DELETE CLASS, DELETE GROUP for clearing classes	*)
(*		and groups after a configuration change			*)
(*	08Jul86 - jrn							*)
(*	      - add REMARK command					*)
(*	      - add SPECIAL flag (CLEAN and OLDPASS commands)		*)
(*	06Aug86 - jrn							*)
(*	      - add GFDONLY to SELECT PASSWORDDATE command		*)
(*	31Jul86 - jrn							*)
(*	      - add MESSAGES FROM command to NVDM			*)
(*	13May86 - neh							*)
(*	      - if INCLUDE_DUMP add ARCHIVE_DUMP to archive commands	*)
(*		and PARAMETERS keyword to NETVAL archive command	*)
(*	30Apr86 - jrn							*)
(*	      - remove RESET command					*)
(*	28Apr86 - jrn							*)
(*	      - make REGENERATE PARAMETERS and RECOLLECT commands	*)
(*		restartable at a CUD block				*)
(*	24Apr86 - jrn							*)
(*	      - if REUSE_UUNS, add PARAMETERS keyword to NVDM		*)
(*		CHECK command						*)
(*	15Apr86 - jrn							*)
(*	      - add ADDBACK keyword to the INITIALIZE PARAMETERS	*)
(*		command							*)
(*	      - add ADDBACK keyword to the REGENERATE PARAMETERS	*)
(*		command							*)
(*	      - change DISPLAY NEXT to DISPLAY PARAMETERS		*)
(*	08Mar86 - jrn							*)
(*	      - add COPY command to Tymnet's NVDM			*)
(*	10Mar86 - jrn							*)
(*	      - redo REUSE_UUNS to maintain a bit map for 18 bit UUNS	*)
(*		and change the add back scheme to be a dated list	*)
(*	      - add APPEND keyword to REGENERATE command, and		*)
(*		add RECOLLECT command					*)
(*	22Jan86 - jrn							*)
(*	      - change the UP and SHUT commands to HOST UP and HOST	*)
(*		SHUT, and add the HOST STATUS command			*)
(*	      - remove abbreviations and sizes in command and keyword	*)
(*	        definitions (handle in code)				*)
(*	14Jan85 -  jrn							*)
(*	      - change DISPLAY LVOL to DISPLAY VOLUME for both Netval	*)
(*		and NVDM						*)
(*	20Dec85 - jrn							*)
(*	      - add the FROM SUPERVISOR keywords to the			*)
(*		WRITE CUD command					*)
(*	01Nov85 - jrn							*)
(*	      - add the REPEAT keyword for DISPLAY UPDATES, and the	*)
(*		SHUT and UP commands; increase COMMAND_KEYWORD_MAX	*)
(*		to 25							*)
(*	07Oct85 - jrn							*)
(*	      - add the X25 keyword for the NEW USER command if		*)
(*		VALIDATE_X25_NAMES is enabled				*)
(*	17Jul85 - jrn							*)
(*	     - add NVDM COMPARE command					*)
(*	09Jan85 - jrn							*)
(*	      - remove UNIT keyword from Archive commands		*)
(*	08Jan85 - jrn							*)
(*	      - use INCLUDE_LIST_DESCRIPTIONS				*)
(*	14Dec84 - pgl							*)
(*	      - if logical_volumes, keywords for COPY, DISPLAY LVOL,	*)
(*		and SET DRIVE OFFLINE commands				*)
(*	24Jul84 - jrn							*)
(*	      - added PRIMARY_CHANGE_LIST_DESCRIPTION_KEYWORD		*)
(*	08Jun84 Version 2.02	jrn - pgl				*)
(*	      - added code for NVDM					*)
(*	      - added FROM keyword to CONSISTENCY			*)
(*	      - removed DISPLAY SCHEDULE and DISPLY SUPERVISORS commands*)
(*	      - added SELECT, DISPLAY DIRECTORY and DISPLAY SELECT	*)
(*		commands						*)
(*	      - added CHANGE UUN command				*)
(*	      - changed required_level to required_license		*)
(*	14Mar84	Version 2.01	jrn					*)
(*	      - added NO_CHANGE keyword to CONSISTENCY command		*)
(*	29SEP83  original from (PATROL)cmddef.bas - jrn		        *)
(*									*)
(************************************************************************)


(* constants dealing with input errors *)

type
  COMMAND_SCAN_STATE = (
    CMD_OK, RUN_ERROR, NO_CMD, SUBCOMMAND_MISSING,
    CMD_ERROR, ILLEGAL_CHAR, DUPLICATE_KEYWORDS, BREAK_ERROR,
    INV_KEYWORD, AUTH_ERROR, ARG_ERROR, ARG_MISSING,
    TOO_MANY_ARGS, ARG_TOO_MANY_CHARS, ARG_NOT_ENOUGH_CHARS,
    ARG_NUMBER_OUT_OF_BOUNDS, ARG_FREEWORD_MISSING);



type
  COMMAND_CLASS_INDEX = (
    START_OF_COMMAND_CLASSES,
      ARCHIVE_CLASS   (* Archive Sub-system commands *),
      PRIMARY_CLASS   (* Non-global system level commands *),
      GLOBAL_CLASS    (* Global system level commands *),
    END_OF_COMMAND_CLASSES);

(* Context switching definitions *)

type
  CONTEXT_SET = set of command_class_index;
!
(* List of internal identifiers for all commands in the system.  These  *)
(* commands will be distributed in various arrays according to what	*)
(* command class they belong to.					*)

type
  COMMAND_INDEX = (
    START_OF_COMMANDS,

(* Global commands may be executed from anywhere: *)

      START_GLOBAL_COMMANDS,
        GLOBAL_DATE     (* current time and date in UTC *),
  	GLOBAL_HELP	(* help as best you can *),
	GLOBAL_STATISTICS (* print disk stats *),
	GLOBAL_VERSION	(* display version and revision number *),
      END_GLOBAL_COMMANDS,

(* ARCHIVE commands  *)

      START_ARCHIVE_COMMANDS,
$ifnone disk_maintenance_code
        ARCHIVE_ASSIGN   (* reserve tape unit for validator *),
	ARCHIVE_ATTACH	 (* reserve tape unit for NETVAL slot *),
	ARCHIVE_DEASSIGN (* free tape unit from validator *),
	ARCHIVE_DETACH	 (* free tape unit from slot *),
	ARCHIVE_DISPLAY	 (* type type id *),
$if include_dump   ARCHIVE_DUMP  (* dump CUD to tape in ascii format *),
	ARCHIVE_RETURN	 (* return to system command level *),
	ARCHIVE_REWIND	 (* return mag tape to beginning *),
	ARCHIVE_STORE	 (* copy files form disk to tape *),
$endif disk_maintenance_code
$if disk_maintenance_code
	ARCHIVE_ATTACH	 (* reserve tape unit for NETVAL slot *),
	ARCHIVE_DETACH	 (* free tape unit from slot *),
	ARCHIVE_DISPLAY	 (* type type id *),
$if CONVERT_TO_43        ARCHIVE_REFORMAT (* reformat CUD to version 43 *),
$ifnone CONVERT_TO_43       ARCHIVE_RESTORE (* copy files from tape to disk *),
	ARCHIVE_RETURN	 (* return to system command level *),
	ARCHIVE_REWIND	 (* return mag tape to beginning *),
$endif disk_maintenance_code
      END_ARCHIVE_COMMANDS,

(* Primary commands  *)

$ifnone disk_maintenance_code
      START_PRIMARY_COMMANDS,
	PRIMARY_ARCHIVE		(* enter ARCHIVE sub-system *),
	PRIMARY_CHANGE		(* change a validation value *),
	PRIMARY_CHECK		(* check on existence of a user name *),
$if special 	PRIMARY_CLEAN		(* clean up some MUD data *),
	PRIMARY_CLEAR		(* turn off automatic consistency *),
$ifnone CONVERT_TO_43        PRIMARY_COMPARE (* compare CUD and MUD buffer *),
	PRIMARY_CONSISTENCY	(* perform manual consistency *),
$if logical_volumes	PRIMARY_COPY	(* perform manual pvol copy *),
	PRIMARY_DELETE		(* delete a validation value *),
	PRIMARY_DISPLAY		(* display a validation value *),
	PRIMARY_FILTER		(* filter out operator log messages *),
	PRIMARY_GET		(* type block number for a user *),
	PRIMARY_HOST		(* retrieve or set host information *),
	PRIMARY_MESSAGE		(* list operator log *),
	PRIMARY_NEW		(* add a validation value *),
$if special 	PRIMARY_OLDPASS		(* list old password users *),
	PRIMARY_QUIT	 	(* leave system *),
	PRIMARY_READ		(* read a validation value *),
$if changes_to_oper_log
	PRIMARY_REMARK		(* append a remark to the oper log *),
$endif changes_to_oper_log
	PRIMARY_SCHEDULE	(* consistency, cud_scanner, uun_merge *),
	PRIMARY_SELECT		(* choose users to be displayed *),
	PRIMARY_SEND		(* send Sup Class/group table *),
	PRIMARY_SET		(* define Supervisors, ganpass, gpogan *),
	PRIMARY_STOP		(* halt a running consistency *),
	PRIMARY_UNLOCK		(* unlock a locked CUD block *),
	PRIMARY_WRITE		(* write a CUD/MUD block *),
      END_PRIMARY_COMMANDS,
$endif none disk_maintenance_code
$if disk_maintenance_code
      START_PRIMARY_COMMANDS,
        PRIMARY_ARCHIVE		(* enter ARCHIVE sub-system *),
        PRIMARY_CHECK		(* compare configuration information *),
$ifnone convert_to_43	PRIMARY_COMPARE	(* compare CUD/MUD information *),
	PRIMARY_CONSISTENCY	(* check CUD against specified MUD *),
$ifnone convert_to_43	PRIMARY_CONVERT	(* update from previous Versions *),
$ifall (logical_volumes, check_time_status)
	PRIMARY_COPY		(* copy from 1 drive to another *),
$endif all (logical_volumes, check_time_status)
	PRIMARY_DISPLAY		(* display some information *),
	PRIMARY_FILTER		(* filter message command *),
	PRIMARY_INITIALIZE	(* init the disk *),
	PRIMARY_MESSAGE		(* output operator log messages *),
	PRIMARY_QUIT		(* leave NTVINI *),
$ifnone convert_to_43
$if reuse_uuns 	PRIMARY_RECOLLECT	(* reconstruct the UUN bit map *),
$endif convert_To_43
"	PRIMARY_RECONFIGURE	(* reconfigure lists *),"
$ifnone convert_to_43	PRIMARY_REGENERATE (* create CUD or prarmeter file *),
$ifany (password_expiration_by_user, prevent_duplicate_passwords)
	PRIMARY_SET		(* set initial parameters on disk *),
$endif (password_expiration_by_user, prevent_duplicate_passwords)
      END_PRIMARY_COMMANDS,
$endif disk_maintenance_code


  END_OF_COMMANDS);

type
  GLOBAL_COMMAND_INDEX =
    start_global_commands .. end_global_commands;

  ARCHIVE_COMMAND_INDEX =
    start_archive_commands .. end_archive_commands;

  PRIMARY_COMMAND_INDEX =
    start_primary_commands .. end_primary_commands;
!
(*	The keyword index for GLOBAL commands.				*)

const
  GLOBAL_OFFSET = 0;

  GLOBAL_DATE_KEYWORD_OFFSET = global_offset;
  GLOBAL_DATE_KEYWORD_MAX = 0;
  GLOBAL_DATE_SUBCOMMAND_MAX = 0;

  GLOBAL_HELP_KEYWORD_OFFSET =
    global_date_keyword_offset + global_date_keyword_max;
  GLOBAL_HELP_KEYWORD_MAX = 0;
  GLOBAL_HELP_SUBCOMMAND_MAX = 0;

  GLOBAL_STATISTICS_KEYWORD_OFFSET =
    global_help_keyword_offset + global_help_keyword_max;
  GLOBAL_STATISTICS_KEYWORD_MAX = 0;
  GLOBAL_STATISTICS_SUBCOMMAND_MAX = 0;

  GLOBAL_VERSION_KEYWORD_OFFSET =
    global_statistics_keyword_offset + global_statistics_keyword_max;
  GLOBAL_VERSION_KEYWORD_MAX = 0;
  GLOBAL_VERSION_SUBCOMMAND_MAX = 0;


  GLOBAL_KEYWORD_MAX =
    global_version_keyword_offset + global_version_keyword_max - global_offset;
!
(*	The keyword index for ARCHIVE commands.			*)

const
$ifnone disk_maintenance_code
  ARCHIVE_OFFSET = global_offset + global_keyword_max;

  ARCHIVE_ASSIGN_KEYWORD_OFFSET = archive_offset;
  ARCHIVE_ASSIGN_KEYWORD_MAX = 0;
  ARCHIVE_ASSIGN_SUBCOMMAND_MAX = 0;

  ARCHIVE_ATTACH_KEYWORD_OFFSET =
    archive_assign_keyword_offset + archive_assign_keyword_max;
  ARCHIVE_ATTACH_KEYWORD_MAX = 0;
  ARCHIVE_ATTACH_SUBCOMMAND_MAX = 0;

  ARCHIVE_DEASSIGN_KEYWORD_OFFSET =
    archive_attach_keyword_offset + archive_attach_keyword_max;
  ARCHIVE_DEASSIGN_KEYWORD_MAX = 0;
  ARCHIVE_DEASSIGN_SUBCOMMAND_MAX = 0;

  ARCHIVE_DETACH_KEYWORD_OFFSET =
    archive_deassign_keyword_offset + archive_deassign_keyword_max;
  ARCHIVE_DETACH_KEYWORD_MAX = 0;
  ARCHIVE_DETACH_SUBCOMMAND_MAX = 0;

  ARCHIVE_DISPLAY_KEYWORD_OFFSET =
    archive_deassign_keyword_offset + archive_deassign_keyword_max;
  ARCHIVE_DISPLAY_ID_KEYWORD = 0;
  ARCHIVE_DISPLAY_STATUS_KEYWORD = archive_display_id_keyword + 1;
  ARCHIVE_DISPLAY_KEYWORD_MAX = 2;
  ARCHIVE_DISPLAY_SUBCOMMAND_MAX = 2;
$if include_dump

  ARCHIVE_DUMP_KEYWORD_OFFSET =
    archive_display_keyword_offset + archive_display_keyword_max;
  ARCHIVE_DUMP_FROM_KEYWORD = 0;
  ARCHIVE_DUMP_KEYWORD_MAX = 1;
  ARCHIVE_DUMP_SUBCOMMAND_MAX = 0;

  ARCHIVE_RETURN_KEYWORD_OFFSET =
    archive_dump_keyword_offset +  archive_dump_keyword_max;
$endif include_dump
$ifnone include_dump

  ARCHIVE_RETURN_KEYWORD_OFFSET =
    archive_display_keyword_offset + archive_display_keyword_max;
$endif none include_dump
  ARCHIVE_RETURN_KEYWORD_MAX = 0;
  ARCHIVE_RETURN_SUBCOMMAND_MAX = 0;

  ARCHIVE_REWIND_KEYWORD_OFFSET =
    archive_return_keyword_offset + archive_return_keyword_max;
  ARCHIVE_REWIND_KEYWORD_MAX = 0;
  ARCHIVE_REWIND_SUBCOMMAND_MAX = 0;

  ARCHIVE_STORE_KEYWORD_OFFSET =
    archive_rewind_keyword_offset + archive_rewind_keyword_max;
  ARCHIVE_STORE_KEYWORD_MAX = 0;
  ARCHIVE_STORE_SUBCOMMAND_MAX = 0;

  ARCHIVE_KEYWORD_MAX =
    archive_return_keyword_offset + archive_return_keyword_max-archive_offset;
$endif none disk_maintenance_code
$if disk_maintenance_code
  ARCHIVE_OFFSET = global_offset + global_keyword_max;

  ARCHIVE_ATTACH_KEYWORD_OFFSET = archive_offset;
  ARCHIVE_ATTACH_KEYWORD_MAX = 0;
  ARCHIVE_ATTACH_SUBCOMMAND_MAX = 0;

  ARCHIVE_DETACH_KEYWORD_OFFSET =
   archive_attach_keyword_offset + archive_attach_keyword_max;
  ARCHIVE_DETACH_KEYWORD_MAX = 0;
  ARCHIVE_DETACH_SUBCOMMAND_MAX = 0;

  ARCHIVE_DISPLAY_KEYWORD_OFFSET =
    archive_detach_keyword_offset + archive_detach_keyword_max;
  ARCHIVE_DISPLAY_KEYWORD_MAX = 0;
  ARCHIVE_DISPLAY_SUBCOMMAND_MAX = 0;

$if CONVERT_TO_43
  ARCHIVE_REFORMAT_KEYWORD_OFFSET =
    archive_display_keyword_offset + archive_display_keyword_max;
  ARCHIVE_REFORMAT_KEYWORD_MAX = 0;
  ARCHIVE_REFORMAT_SUBCOMMAND_MAX = 0;

  ARCHIVE_RETURN_KEYWORD_OFFSET =
    archive_reformat_keyword_offset + archive_reformat_keyword_max;
$endif CONVERT_TO_43
$ifnone CONVERT_TO_43
  ARCHIVE_RESTORE_KEYWORD_OFFSET =
    archive_display_keyword_offset + archive_display_keyword_max;
  ARCHIVE_RESTORE_ALL_KEYWORD = 0;
  ARCHIVE_RESTORE_CUD_KEYWORD = archive_restore_all_keyword + 1;
$if include_dnic
  ARCHIVE_RESTORE_DNIC_FILE_KEYWORD = archive_restore_cud_keyword + 1;
$endif include_dnic
  ARCHIVE_RESTORE_MUDUPDATE_KEYWORD =
$ifnone include_dnic    archive_restore_cud_keyword + 1;
$if include_dnic    archive_restore_dnic_file_keyword + 1;
  ARCHIVE_RESTORE_NODE_KEYWORD = archive_restore_mudupdate_keyword + 1;
  ARCHIVE_RESTORE_OPERLOG_KEYWORD = archive_restore_node_keyword + 1;
$if ganpass_file_exists
  ARCHIVE_RESTORE_PASSTABLE_KEYWORD = archive_restore_operlog_keyword + 1;
  ARCHIVE_RESTORE_SCHEDTABLE_KEYWORD = archive_restore_passtable_keyword +1;
$endif ganpass_file_exists
$ifnot ganpass_file_exists
  ARCHIVE_RESTORE_SCHEDTABLE_KEYWORD = archive_restore_operlog_keyword +1;
$endif ganpass_file_exists
  ARCHIVE_RESTORE_BLOCK_KEYWORD = archive_restore_schedtable_keyword + 1;
  ARCHIVE_RESTORE_KEYWORD_MAX = archive_restore_block_keyword + 1;
  ARCHIVE_RESTORE_SUBCOMMAND_MAX = archive_restore_block_keyword;

  ARCHIVE_RETURN_KEYWORD_OFFSET =
    archive_restore_keyword_offset + archive_restore_keyword_max;
$endif CONVERT_TO_43
  ARCHIVE_RETURN_KEYWORD_MAX = 0;
  ARCHIVE_RETURN_SUBCOMMAND_MAX = 0;

  ARCHIVE_REWIND_KEYWORD_OFFSET =
    archive_return_keyword_offset + archive_return_keyword_max;
  ARCHIVE_REWIND_KEYWORD_MAX = 0;
  ARCHIVE_REWIND_SUBCOMMAND_MAX = 0;


  ARCHIVE_KEYWORD_MAX = archive_return_keyword_offset +
    archive_return_keyword_max - archive_offset;
$endif disk_maintenance_code
!
(* The keyword index for primary commands. *)

const
$ifnone disk_maintenance_code
  PRIMARY_OFFSET = archive_offset + archive_keyword_max;

  PRIMARY_ARCHIVE_KEYWORD_OFFSET = primary_offset;
  PRIMARY_ARCHIVE_KEYWORD_MAX = 0;
  PRIMARY_ARCHIVE_SUBCOMMAND_MAX = 0;

  PRIMARY_CHANGE_KEYWORD_OFFSET =
    primary_archive_keyword_offset + primary_archive_keyword_max;
  PRIMARY_CHANGE_ACCESS_KEYWORD = 0;
  PRIMARY_CHANGE_CLASS_KEYWORD = primary_change_access_keyword + 1;
  PRIMARY_CHANGE_CONTROL_KEYWORD = primary_change_class_keyword + 1;
  PRIMARY_CHANGE_CUD_KEYWORD = primary_change_control_keyword + 1;
  PRIMARY_CHANGE_DISTRICT_KEYWORD = primary_change_cud_keyword + 1;
$if include_dnic
  PRIMARY_CHANGE_DNIC_KEYWORD = primary_change_district_keyword + 1;
$endif INCLUDE_DNIC
$ifnone include_dnic
  PRIMARY_CHANGE_DNIC_KEYWORD = primary_change_district_keyword;
$endif INCLUDE_DNIC
  PRIMARY_CHANGE_GAN_KEYWORD = primary_change_dnic_keyword + 1;
  PRIMARY_CHANGE_GROUP_KEYWORD = primary_change_gan_keyword + 1;
  PRIMARY_CHANGE_HOSTLIST_KEYWORD = primary_change_group_keyword + 1;
$ifnone BEFORE_SUP_V43
$if allow_logon_inhibit
  PRIMARY_CHANGE_INHIBIT_KEYWORD = primary_change_hostlist_keyword + 1;
$endif allow_logon_inhibit
$ifnone allow_logon_inhibit
  PRIMARY_CHANGE_INHIBIT_KEYWORD = primary_change_hostlist_keyword;
$endif allow_logon_inhibit
$endif BEFORE_SUP_V43
$if BEFORE_SUP_V43
  PRIMARY_CHANGE_INHIBIT_KEYWORD = primary_change_hostlist_keyword;
$endif BEFORE_SUP_V43
$if INCLUDE_IRC
  PRIMARY_CHANGE_IRC_KEYWORD = primary_change_inhibit_keyword + 1;
$endif INCLUDE_IRC
$ifnone INCLUDE_IRC
  PRIMARY_CHANGE_IRC_KEYWORD = primary_change_inhibit_keyword;
$endif INCLUDE_IRC
  PRIMARY_CHANGE_NAME_KEYWORD = primary_change_irc_keyword + 1;
  PRIMARY_CHANGE_NODELIST_KEYWORD = primary_change_name_keyword + 1;
  PRIMARY_CHANGE_PASSWORD_KEYWORD = primary_change_nodelist_keyword + 1;
$if restrict_users_by_time
  PRIMARY_CHANGE_TIME_KEYWORD = primary_change_password_keyword + 1;
$endif restrict_users_by_time
$ifnot restrict_users_by_time
  PRIMARY_CHANGE_TIME_KEYWORD = primary_change_password_keyword;
$endif restrict_users_by_time
$if UUNSassignable
  PRIMARY_CHANGE_UUN_KEYWORD = primary_change_time_keyword + 1;
$endif UUNSassignable
$ifnone UUNSassignable
  PRIMARY_CHANGE_UUN_KEYWORD = primary_change_time_keyword;
$endif UUNSassignable
$if password_expiration_date_in_cud
  PRIMARY_CHANGE_VALIDITY_KEYWORD = primary_change_uun_keyword + 1;
$endif password_expiration_date_in_cud
$ifnot password_expiration_date_in_cud
  PRIMARY_CHANGE_VALIDITY_KEYWORD = primary_change_uun_keyword;
$endif password_expiration_date_in_cud
$if allow_temporary_apes
  PRIMARY_CHANGE_ACCESS_EXPIRE_KEYWORD = primary_change_validity_keyword + 1;
$endif allow_temporary_apes
$ifnone allow_temporary_apes
  PRIMARY_CHANGE_ACCESS_EXPIRE_KEYWORD = primary_change_validity_keyword;
$endif allow_temporary_apes
$if INCLUDE_DNIC
  PRIMARY_CHANGE_DNIC_DEFAULT_KEYWORD = primary_change_access_expire_keyword+1;
$endif INCLUDE_DNIC
$ifnone INCLUDE_DNIC
  PRIMARY_CHANGE_DNIC_DEFAULT_KEYWORD = primary_change_access_expire_keyword;
$endif INCLUDE_DNIC
$if include_list_descriptions
  PRIMARY_CHANGE_LIST_DESCRIPTION_KEYWORD =
    primary_change_dnic_default_keyword + 1;
$endif include_list_descriptions
$ifnone include_list_descriptions
  PRIMARY_CHANGE_LIST_DESCRIPTION_KEYWORD =
    primary_change_dnic_default_keyword;
$endif include_list_descriptions
  PRIMARY_CHANGE_OFFSET_KEYWORD = primary_change_list_description_keyword + 1;

  PRIMARY_CHANGE_KEYWORD_MAX = primary_change_offset_keyword + 1;
  PRIMARY_CHANGE_SUBCOMMAND_MAX = primary_change_validity_keyword + 1;

  PRIMARY_CHECK_KEYWORD_OFFSET =
    primary_change_keyword_offset + primary_change_keyword_max;
  PRIMARY_CHECK_KEYWORD_MAX = 0;
  PRIMARY_CHECK_SUBCOMMAND_MAX = 0;

$if special
  PRIMARY_CLEAN_KEYWORD_OFFSET =
    primary_check_keyword_offset + primary_check_keyword_max;
  PRIMARY_CLEAN_DELETE_KEYWORD = 0;
  PRIMARY_CLEAN_FROM_KEYWORD = primary_clean_delete_keyword + 1;
  PRIMARY_CLEAN_KEYWORD_MAX = 2;
  PRIMARY_CLEAN_SUBCOMMAND_MAX = 0;

  PRIMARY_CLEAR_KEYWORD_OFFSET =
    primary_clean_keyword_offset + primary_clean_keyword_max;
$endif special
$ifnone special

  PRIMARY_CLEAR_KEYWORD_OFFSET =
    primary_check_keyword_offset + primary_check_keyword_max;
$endif none special
  PRIMARY_CLEAR_CONSISTENCY_KEYWORD = 0;
$if perform_daily_cud_scan
  PRIMARY_CLEAR_CUDMAINTENANCE_KEYWORD=primary_clear_consistency_keyword + 1;
$endif perform_daily_cud_scan
$ifnone perform_daily_cud_scan
  PRIMARY_CLEAR_CUDMAINTENANCE_KEYWORD = primary_clear_consistency_keyword;
$endif perform_daily_cud_scan
$if force_password_change
  PRIMARY_CLEAR_GANPASS_KEYWORD = primary_clear_cudmaintenance_keyword + 1;
$endif force_password_change
$ifnone force_password_change
  PRIMARY_CLEAR_GANPASS_KEYWORD = primary_clear_cudmaintenance_keyword;
$endif force_password_change
$if global_password_only_login
  PRIMARY_CLEAR_GPOGAN_KEYWORD = primary_clear_ganpass_keyword + 1;
$endif global_password_only_login
$ifnone global_password_only_login
  PRIMARY_CLEAR_GPOGAN_KEYWORD = primary_clear_ganpass_keyword;
$endif global_password_only_login
$if force_password_change
  PRIMARY_CLEAR_PASSCHANGER_KEYWORD = primary_clear_gpogan_keyword +1;
$endif force_password_change
$ifnone force_password_change
  PRIMARY_CLEAR_PASSCHANGER_KEYWORD = primary_clear_gpogan_keyword;
$endif force_password_change
$if reuse_uuns
  PRIMARY_CLEAR_UUNMERGE_KEYWORD = primary_clear_passchanger_keyword + 1;
$endif reuse_uuns
$ifnone reuse_uuns
  PRIMARY_CLEAR_UUNMERGE_KEYWORD = primary_clear_passchanger_keyword;
$endif reuse_uuns

  PRIMARY_CLEAR_KEYWORD_MAX = primary_clear_uunmerge_keyword + 1;
  PRIMARY_CLEAR_SUBCOMMAND_MAX = primary_clear_uunmerge_keyword + 1;
$ifnone convert_to_43

  PRIMARY_COMPARE_KEYWORD_OFFSET =
    primary_clear_keyword_offset + primary_clear_keyword_max;
  PRIMARY_COMPARE_KEYWORD_MAX = 0;
  PRIMARY_COMPARE_SUBCOMMAND_MAX = 0;
$endif convert_to_43

  PRIMARY_CONSISTENCY_KEYWORD_OFFSET =

$ifnone convert_to_43   primary_compare_keyword_offset + primary_compare_keyword_max;
$if convert_to_43  primary_clear_keyword_offset + primary_clear_keyword_max;
  PRIMARY_CONSISTENCY_NOCHANGE_KEYWORD = 0;
  PRIMARY_CONSISTENCY_SUPERVISOR_KEYWORD =
    primary_consistency_nochange_keyword + 1;
  PRIMARY_CONSISTENCY_FROM_KEYWORD =
    primary_consistency_supervisor_keyword + 1;
  PRIMARY_CONSISTENCY_KEYWORD_MAX = 3;
  PRIMARY_CONSISTENCY_SUBCOMMAND_MAX = 0;
$if logical_volumes

  PRIMARY_COPY_KEYWORD_OFFSET =
    primary_consistency_keyword_offset + primary_consistency_keyword_max;
  PRIMARY_COPY_KEYWORD_MAX = 0;
  PRIMARY_COPY_SUBCOMMAND_MAX = 0;
$endif logical_volumes

  PRIMARY_DELETE_KEYWORD_OFFSET =
$if logical_volumes    primary_copy_keyword_offset + primary_copy_keyword_max;
$ifnone logical_volumes
    primary_consistency_keyword_offset + primary_consistency_keyword_max;
$endif none logical_volumes
  PRIMARY_DELETE_ACCESS_KEYWORD = 0;
  PRIMARY_DELETE_CLASS_KEYWORD = primary_delete_access_keyword + 1;
$if include_dnic
  PRIMARY_DELETE_DNIC_KEYWORD = primary_delete_class_keyword + 1;
$endif include_dnic
  PRIMARY_DELETE_GROUP_KEYWORD =
$ifnone include_dnic    primary_delete_class_keyword + 1;
$if include_dnic    primary_delete_dnic_keyword + 1;
  PRIMARY_DELETE_HOSTLIST_KEYWORD = primary_delete_group_keyword + 1;
  PRIMARY_DELETE_NODELIST_KEYWORD = primary_delete_hostlist_keyword + 1;
  PRIMARY_DELETE_USER_KEYWORD = primary_delete_nodelist_keyword + 1;
  PRIMARY_DELETE_KEYWORD_MAX = primary_delete_user_keyword + 1;
  PRIMARY_DELETE_SUBCOMMAND_MAX = primary_delete_keyword_max;

  PRIMARY_DISPLAY_KEYWORD_OFFSET =
    primary_delete_keyword_offset + primary_delete_keyword_max;
  PRIMARY_DISPLAY_CLASS_KEYWORD = 0;
  PRIMARY_DISPLAY_CUD_KEYWORD = primary_display_class_keyword + 1;
  PRIMARY_DISPLAY_DIRECTORY_KEYWORD = primary_display_cud_keyword + 1;
$if INCLUDE_DNIC
  PRIMARY_DISPLAY_DNIC_KEYWORD = primary_display_directory_keyword + 1;
$endif INCLUDE_DNIC
$ifnone INCLUDE_DNIC
  PRIMARY_DISPLAY_DNIC_KEYWORD = primary_display_directory_keyword;
$endif INCLUDE_DNIC
  PRIMARY_DISPLAY_FILTER_KEYWORD = primary_display_dnic_keyword + 1;
$if force_password_change
  PRIMARY_DISPLAY_GANPASS_KEYWORD = primary_display_filter_keyword + 1;
$endif force_password_change
$ifnone force_password_change
  PRIMARY_DISPLAY_GANPASS_KEYWORD = primary_display_filter_keyword;
$endif force_password_change
$if global_password_only_login
  PRIMARY_DISPLAY_GPOGAN_KEYWORD = primary_display_ganpass_keyword + 1;
$endif global_password_only_login
$ifnone global_password_only_login
  PRIMARY_DISPLAY_GPOGAN_KEYWORD = primary_display_ganpass_keyword;
$endif global_password_only_login
  PRIMARY_DISPLAY_GROUP_KEYWORD = primary_display_gpogan_keyword + 1;
  PRIMARY_DISPLAY_HOSTLIST_KEYWORD = primary_display_group_keyword + 1;
  PRIMARY_DISPLAY_MUD_KEYWORD = primary_display_hostlist_keyword + 1;
  PRIMARY_DISPLAY_NODELIST_KEYWORD = primary_display_mud_keyword + 1;
$if prevent_duplicate_passwords
  PRIMARY_DISPLAY_PASSPERIOD_KEYWORD = primary_display_nodelist_keyword + 1;
$endif prevent_duplicate_passwords
$ifnone prevent_duplicate_passwords
  PRIMARY_DISPLAY_PASSPERIOD_KEYWORD = primary_display_nodelist_keyword;
$endif prevent_duplicate_passwords
  PRIMARY_DISPLAY_PARAMETERS_KEYWORD = primary_display_passperiod_keyword + 1;
  PRIMARY_DISPLAY_SCHEDULE_KEYWORD = primary_display_parameters_keyword + 1;
  PRIMARY_DISPLAY_SELECT_KEYWORD = primary_display_schedule_keyword + 1;
$if password_expiration_by_user
  PRIMARY_DISPLAY_VALIDITY_KEYWORD = primary_display_select_keyword + 1;
$endif password_expiration_by_user
$ifnot password_expiration_by_user
  PRIMARY_DISPLAY_VALIDITY_KEYWORD = primary_display_select_keyword;
$endif password_expiration_by_user
  PRIMARY_DISPLAY_UPDATES_KEYWORD = primary_display_validity_keyword + 1;
  PRIMARY_DISPLAY_USER_KEYWORD = primary_display_updates_keyword + 1;
$if logical_volumes
  PRIMARY_DISPLAY_VOLUMES_KEYWORD = primary_display_user_keyword + 1;
$endif logical_volumes
$ifnone logical_volumes
  PRIMARY_DISPLAY_VOLUMES_KEYWORD = primary_display_user_keyword;
$endif logical_volumes
  PRIMARY_DISPLAY_CUD_ALL_KEYWORD = primary_display_volumes_keyword + 1;
  PRIMARY_DISPLAY_CUD_FORMATTED_KEYWORD = primary_display_cud_all_keyword + 1;
$if include_list_descriptions
  PRIMARY_DISPLAY_LIST_DESCRIPTIONS_KEYWORD =
    primary_display_cud_formatted_keyword + 1;
$endif include_list_descriptions
$ifnone include_list_descriptions
  PRIMARY_DISPLAY_LIST_DESCRIPTIONS_KEYWORD =
    primary_display_cud_formatted_keyword;
$endif none include_list_descriptions
  PRIMARY_DISPLAY_LIST_NAMES_KEYWORD =
    primary_display_list_descriptions_keyword + 1;
(* keywords associated with the display_directory keyword *)
  PRIMARY_DISPLAY_DIRECTORY_UUN_KEYWORD =
    primary_display_list_names_keyword + 1;
FIRST_DISPLAY_DIRECTORY_KEYWORD = PRIMARY_DISPLAY_DIRECTORY_UUN_KEYWORD;
  PRIMARY_DISPLAY_DIRECTORY_GAN_KEYWORD =
    primary_display_directory_uun_keyword + 1;
  PRIMARY_DISPLAY_DIRECTORY_DISTRICT_KEYWORD =
    primary_display_directory_gan_keyword + 1;
  PRIMARY_DISPLAY_DIRECTORY_CONTROL_KEYWORD =
    primary_display_directory_district_keyword + 1;
  PRIMARY_DISPLAY_DIRECTORY_PASSWORDDATE_KEYWORD =
    primary_display_directory_control_keyword + 1;
  PRIMARY_DISPLAY_DIRECTORY_ENTRYDATE_KEYWORD =
    primary_display_directory_passworddate_keyword + 1;
  PRIMARY_DISPLAY_DIRECTORY_ACCESS_KEYWORD =
    primary_display_directory_entrydate_keyword + 1;
  PRIMARY_DISPLAY_DIRECTORY_LINES_KEYWORD =
    primary_display_directory_access_keyword + 1;
$ifany (force_password_change, password_expiration_by_user)
  PRIMARY_DISPLAY_DIRECTORY_EXPIREDATE_KEYWORD =
    primary_display_directory_lines_keyword + 1;
$endif (force_password_change, password_expiration_by_user)
$ifnone (force_password_change, password_expiration_by_user)
  PRIMARY_DISPLAY_DIRECTORY_EXPIREDATE_KEYWORD =
    primary_display_directory_lines_keyword;
$endif (force_password_change, password_expiration_by_user)
$if restrict_users_by_time
  PRIMARY_DISPLAY_DIRECTORY_TIMERESTRICT_KEYWORD =
    primary_display_directory_expiredate_keyword + 1;
$endif restrict_users_by_time
$ifnone restrict_users_by_time
  PRIMARY_DISPLAY_DIRECTORY_TIMERESTRICT_KEYWORD =
    primary_display_directory_expiredate_keyword;
$endif restrict_users_by_time

	(* when adding keywords to the display directory command,	*)
	(* update the value LAST_DISPLAY_DIRECTORY_KEYWORD		*)

LAST_DISPLAY_DIRECTORY_KEYWORD=PRIMARY_DISPLAY_DIRECTORY_TIMERESTRICT_KEYWORD;
(* end of keywords associated with the display_directory keyword *)
$if INCLUDE_DNIC
  PRIMARY_DISPLAY_DNIC_DEFAULT_KEYWORD =
    primary_display_directory_timerestrict_keyword + 1;
  PRIMARY_DISPLAY_DNIC_ENTRY_KEYWORD =
    primary_display_dnic_default_keyword + 1;
$endif INCLUDE_DNIC
$ifnot INCLUDE_DNIC
  PRIMARY_DISPLAY_DNIC_DEFAULT_KEYWORD =
    primary_display_directory_timerestrict_keyword;
  PRIMARY_DISPLAY_DNIC_ENTRY_KEYWORD = primary_display_dnic_default_keyword;
$endif INCLUDE_DNIC
  PRIMARY_DISPLAY_UPDATES_REPEAT_KEYWORD =
    primary_display_dnic_entry_keyword + 1;

  PRIMARY_DISPLAY_KEYWORD_MAX = primary_display_updates_repeat_keyword + 1;
  PRIMARY_DISPLAY_SUBCOMMAND_MAX = primary_display_volumes_keyword + 1;

(* PRIMARY_FILTER_KEYWORD_OFFSETS for all FILTER keywords *)
  PRIMARY_FILTER_KEYWORD_OFFSET =
    primary_display_keyword_offset + primary_display_keyword_max;
  PRIMARY_FILTER_ALL_KEYWORD = 0;
  PRIMARY_FILTER_ARCHIVE_KEYWORD = primary_filter_all_keyword + 1;
  PRIMARY_FILTER_CONSISTENCY_KEYWORD = primary_filter_archive_keyword + 1;
  PRIMARY_FILTER_CUDERROR_KEYWORD = primary_filter_consistency_keyword + 1;
$if perform_daily_cud_scan
  PRIMARY_FILTER_CUDMAINTENANCE_KEYWORD = primary_filter_cuderror_keyword + 1;
$endif perform_daily_cud_scan
$ifnone perform_daily_cud_scan
  PRIMARY_FILTER_CUDMAINTENANCE_KEYWORD = primary_filter_cuderror_keyword;
$endif perform_daily_cud_scan
  PRIMARY_FILTER_DEBUG_KEYWORD = primary_filter_cudmaintenance_keyword + 1;
  PRIMARY_FILTER_FILE_KEYWORD = primary_filter_debug_keyword + 1;
$if NETVAL_IS_A_SLAVE
  PRIMARY_FILTER_MASTER_KEYWORD = primary_filter_file_keyword + 1;
$endif NETVAL_IS_A_SLAVE
$ifnone NETVAL_IS_A_SLAVE
  PRIMARY_FILTER_MASTER_KEYWORD = primary_filter_file_keyword;
$endif NETVAL_IS_A_SLAVE
$if CHANGES_TO_OPER_LOG
  PRIMARY_FILTER_MODIFY_KEYWORD = primary_filter_master_keyword + 1;
$endif CHANGES_TO_OPER_LOG
$ifnone CHANGES_TO_OPER_LOG
  PRIMARY_FILTER_MODIFY_KEYWORD = primary_filter_master_keyword;
$endif CHANGES_TO_OPER_LOG
  PRIMARY_FILTER_MUDUPDATE_KEYWORD = primary_filter_modify_keyword + 1;
  PRIMARY_FILTER_OPERATOR_KEYWORD = primary_filter_mudupdate_keyword + 1;
  PRIMARY_FILTER_PARAMETER_KEYWORD = primary_filter_operator_keyword + 1;
  PRIMARY_FILTER_SUPERVISOR_KEYWORD = primary_filter_parameter_keyword  + 1;
  PRIMARY_FILTER_SYSMSG1_KEYWORD = primary_filter_supervisor_keyword + 1;
$ifany (force_password_change, global_password_only_login)
  PRIMARY_FILTER_PASSCHANGER_KEYWORD = primary_filter_sysmsg1_keyword + 1;
  PRIMARY_FILTER_UN2_KEYWORD = primary_filter_passchanger_keyword + 1;
$endif any force_password_change global_password_only_login
$ifnone (force_password_change, global_password_only_login)
  PRIMARY_FILTER_UN2_KEYWORD = primary_filter_sysmsg1_keyword + 1;
$endif any force_password_change global_password_only_login
$if REUSE_UUNS
  PRIMARY_FILTER_UUNMERGE_KEYWORD = primary_filter_un2_keyword + 1;
$endif REUSE_UUNS
$ifnone REUSE_UUNS
  PRIMARY_FILTER_UUNMERGE_KEYWORD = primary_filter_un2_keyword;
$endif REUSE_UUNS
  PRIMARY_FILTER_VALIDATOR_KEYWORD = primary_filter_uunmerge_keyword + 1;
$if LOGICAL_VOLUMES
  PRIMARY_FILTER_VOLUMES_KEYWORD = primary_filter_validator_keyword + 1;
$endif LOGICAL_VOLUMES
$ifnone LOGICAL_VOLUMES
  PRIMARY_FILTER_VOLUMES_KEYWORD = primary_filter_validator_keyword;
$endif LOGICAL_VOLUMES
  PRIMARY_FILTER_VALIDATOR_NUMBER_KEYWORD = primary_filter_volumes_keyword + 1;
  PRIMARY_FILTER_VALIDATOR_USER_KEYWORD =
    primary_filter_validator_number_keyword + 1;
$if CHANGES_TO_OPER_LOG
  PRIMARY_FILTER_MODIFY_ACCESS_KEYWORD =
    primary_filter_validator_user_keyword + 1;
  PRIMARY_FILTER_MODIFY_CONTROL_KEYWORD =
    primary_filter_modify_access_keyword + 1;
  PRIMARY_FILTER_MODIFY_DISTRICT_KEYWORD =
    primary_filter_modify_control_keyword + 1;
$if password_expiration_date_in_cud
  PRIMARY_FILTER_MODIFY_EXPIRE_DATE_KEYWORD =
    primary_filter_modify_district_keyword + 1;
$endif password_expiration_date_in_cud
$ifnone password_expiration_date_in_cud
  PRIMARY_FILTER_MODIFY_EXPIRE_DATE_KEYWORD =
    primary_filter_modify_district_keyword;
$endif password_expiration_date_in_cud
  PRIMARY_FILTER_MODIFY_GAN_KEYWORD =
    primary_filter_modify_expire_date_keyword + 1;
  PRIMARY_FILTER_MODIFY_NAME_KEYWORD =
    primary_filter_modify_gan_keyword + 1;
$ifnone before_sup_v43
  PRIMARY_FILTER_MODIFY_NUD_KEYWORD = primary_filter_modify_name_keyword + 1;
$endif before_sup_v43
$if before_sup_v43
  PRIMARY_FILTER_MODIFY_NUD_KEYWORD = primary_filter_modify_name_keyword;
$endif before_sup_v43
  PRIMARY_FILTER_MODIFY_PASSWORD_KEYWORD = primary_filter_modify_nud_keyword+1;
$if restrict_users_by_time
  PRIMARY_FILTER_MODIFY_TIME_KEYWORD =
    primary_filter_modify_password_keyword + 1;
$endif restrict_users_by_time
$ifnone restrict_users_by_time
  PRIMARY_FILTER_MODIFY_TIME_KEYWORD = primary_filter_modify_password_keyword;
$endif restrict_users_by_time
  PRIMARY_FILTER_MODIFY_UUN_KEYWORD =
    primary_filter_modify_time_keyword + 1;
$if NETVAL_IS_A_SLAVE
  PRIMARY_FILTER_MODIFY_GFD_KEYWORD = primary_filter_modify_uun_keyword + 1;
$if INCLUDE_IRC
  PRIMARY_FILTER_MODIFY_IRC_KEYWORD = primary_filter_modify_gfd_keyword + 1;
$endif INCLUDE_IRC
$ifnot INCLUDE_IRC
  PRIMARY_FILTER_MODIFY_IRC_KEYWORD = primary_filter_modify_gfd_keyword;
$endif INCLUDE_IRC
$endif NETVAL_IS_A_SLAVE
$ifnot NETVAL_IS_A_SLAVE
  PRIMARY_FILTER_MODIFY_IRC_KEYWORD = primary_filter_modify_uun_keyword;
$endif NETVAL_IS_A_SLAVE
$if OVERFLOW_CUD_ENTRIES
  PRIMARY_FILTER_MODIFY_OVERFLOW_KEYWORD =primary_filter_modify_irc_keyword + 1;
$endif OVERFLOW_CUD_ENTRIES
$ifnot OVERFLOW_CUD_ENTRIES
  PRIMARY_FILTER_MODIFY_OVERFLOW_KEYWORD =primary_filter_modify_irc_keyword;
$endif OVERFLOW_CUD_ENTRIES
  PRIMARY_FILTER_MODIFY_DELETE_KEYWORD=primary_filter_modify_overflow_keyword+1;
  PRIMARY_FILTER_MODIFY_NEW_KEYWORD = primary_filter_modify_delete_keyword + 1;
$endif CHANGES_TO_OPER_LOG
$ifnot CHANGES_TO_OPER_LOG
  PRIMARY_FILTER_MODIFY_NEW_KEYWORD = primary_filter_validator_user_keyword;
$endif CHANGES_TO_OPER_LOG
  PRIMARY_FILTER_SUPERVISOR_OFF_KEYWORD = primary_filter_modify_new_keyword + 1;
  PRIMARY_FILTER_KEYWORD_MAX = primary_filter_supervisor_off_keyword + 1;
  PRIMARY_FILTER_SUBCOMMAND_MAX = 0;







  PRIMARY_GET_KEYWORD_OFFSET =
    primary_filter_keyword_offset + primary_filter_keyword_max;
  PRIMARY_GET_KEYWORD_MAX = 0;
  PRIMARY_GET_SUBCOMMAND_MAX = 0;

  PRIMARY_HOST_KEYWORD_OFFSET =
    primary_get_keyword_offset + primary_get_keyword_max;
  PRIMARY_HOST_SHUT_KEYWORD = 0;
  PRIMARY_HOST_STATUS_KEYWORD = primary_host_shut_keyword + 1;
  PRIMARY_HOST_UP_KEYWORD = primary_host_status_keyword + 1;
  PRIMARY_HOST_KEYWORD_MAX = 3;
  PRIMARY_HOST_SUBCOMMAND_MAX = 3;

  PRIMARY_MESSAGE_KEYWORD_OFFSET =
   primary_host_keyword_offset + primary_host_keyword_max;
  PRIMARY_MESSAGE_FROM_KEYWORD = 0;
  PRIMARY_MESSAGE_KEYWORD_MAX = 1;
  PRIMARY_MESSAGE_SUBCOMMAND_MAX = 0;

  PRIMARY_NEW_KEYWORD_OFFSET =
    primary_message_keyword_offset + primary_message_keyword_max;
  PRIMARY_NEW_ACCESS_KEYWORD = 0;
$if include_dnic
  PRIMARY_NEW_DNIC_KEYWORD = primary_new_access_keyword + 1;
$endif include_dnic
  PRIMARY_NEW_HOSTLIST_KEYWORD =
$ifnone include_dnic    primary_new_access_keyword + 1;
$if include_dnic    primary_new_dnic_keyword + 1;
  PRIMARY_NEW_NODELIST_KEYWORD = primary_new_hostlist_keyword + 1;
  PRIMARY_NEW_USER_KEYWORD = primary_new_nodelist_keyword + 1;
$if allow_temporary_apes
  PRIMARY_NEW_ACCESS_EXPIRE_KEYWORD = primary_new_user_keyword + 1;
$endif allow_temporary_apes
$ifnone allow_temporary_apes
  PRIMARY_NEW_ACCESS_EXPIRE_KEYWORD = primary_new_user_keyword;
$endif allow_temporary_apes
  PRIMARY_NEW_USER_AS_KEYWORD = primary_new_access_expire_keyword + 1;
$if validate_x25_names
  PRIMARY_NEW_USER_X25_KEYWORD = primary_new_user_as_keyword + 1;
$endif validate_x25_names
$ifnone validate_x25_names
  PRIMARY_NEW_USER_X25_KEYWORD = primary_new_user_as_keyword;
$endif validate_x25_names

  PRIMARY_NEW_KEYWORD_MAX = primary_new_user_x25_keyword + 1;
  PRIMARY_NEW_SUBCOMMAND_MAX = primary_new_user_keyword + 1;
$if special

  PRIMARY_OLDPASS_KEYWORD_OFFSET =
    primary_new_keyword_offset + primary_new_keyword_max;
  PRIMARY_OLDPASS_KEYWORD_MAX = 0;
  PRIMARY_OLDPASS_SUBCOMMAND_MAX = 0;

  PRIMARY_QUIT_KEYWORD_OFFSET =
    primary_oldpass_keyword_offset + primary_oldpass_keyword_max;
$endif special
$ifnone special

  PRIMARY_QUIT_KEYWORD_OFFSET =
    primary_new_keyword_offset + primary_new_keyword_max;
$endif special
  PRIMARY_QUIT_KEYWORD_MAX = 0;
  PRIMARY_QUIT_SUBCOMMAND_MAX = 0;

  PRIMARY_READ_KEYWORD_OFFSET =
    primary_quit_keyword_offset + primary_quit_keyword_max;
  PRIMARY_READ_CUD_KEYWORD = 0;
  PRIMARY_READ_MUD_KEYWORD = primary_read_cud_keyword + 1;
$if include_dnic
  PRIMARY_READ_DNIC_KEYWORD = primary_read_mud_keyword + 1;
$endif include_dnic
  PRIMARY_READ_TABLE_KEYWORD =
$ifnone include_dnic    primary_read_mud_keyword + 1;
$if include_dnic    primary_read_dnic_keyword + 1;
  PRIMARY_READ_BLOCK_KEYWORD = primary_read_table_keyword + 1;
  PRIMARY_READ_LOCK_KEYWORD = primary_read_block_keyword + 1;
$if include_dnic
  PRIMARY_READ_DNIC_DEFAULT_KEYWORD = primary_read_lock_keyword + 1;
  PRIMARY_READ_DNIC_ENTRY_KEYWORD = primary_read_dnic_default_keyword + 1;
$endif include_dnic
  PRIMARY_READ_SUPERVISOR_KEYWORD =
$ifnone include_dnic    primary_read_lock_keyword + 1;
$if include_dnic primary_read_dnic_entry_keyword + 1;
  PRIMARY_READ_TABLE_CLASS_KEYWORD = primary_read_supervisor_keyword + 1;
  PRIMARY_READ_TABLE_GROUP_KEYWORD = primary_read_table_class_keyword + 1;
  PRIMARY_READ_KEYWORD_MAX = primary_read_table_group_keyword + 1;
  PRIMARY_READ_SUBCOMMAND_MAX = primary_read_table_keyword + 1;
$if changes_to_oper_log

  PRIMARY_REMARK_KEYWORD_OFFSET =
    primary_read_keyword_offset + primary_read_keyword_max;
  PRIMARY_REMARK_KEYWORD_MAX = 0;
  PRIMARY_REMARK_SUBCOMMAND_MAX = 0;
$endif changes_to_oper_log
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

  PRIMARY_SCHEDULE_KEYWORD_OFFSET =
$if changes_to_oper_log
    primary_remark_keyword_offset + primary_remark_keyword_max;
$endif changes_to_oper_log
$ifnone changes_to_oper_log
    primary_read_keyword_offset + primary_read_keyword_max;
$endif none changes_to_oper_log
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

  PRIMARY_SCHEDULE_CONSISTENCY_KEYWORD = 0;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if force_password_change
  PRIMARY_SCHEDULE_PASSCHANGER_KEYWORD =
    primary_schedule_consistency_keyword + 1;
$endif force_password_change
$if reuse_uuns
$if force_password_change
  PRIMARY_SCHEDULE_UUNMERGE_KEYWORD = 
    primary_schedule_passchanger_keyword + 1;
$endif force_password_change
$ifnone force_password_change
  PRIMARY_SCHEDULE_UUNMERGE_KEYWORD = 
    primary_schedule_consistency_keyword + 1;
$endif none force_password_change
$endif reuse_uuns
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  PRIMARY_SCHEDULE_KEYWORD_MAX = 1
$if force_password_change + 1
$if reuse_uuns + 1
;
  PRIMARY_SCHEDULE_SUBCOMMAND_MAX = 1
$if force_password_change + 1
$if reuse_uuns + 1
;
  

  PRIMARY_SELECT_KEYWORD_OFFSET =
    primary_schedule_keyword_offset + primary_schedule_keyword_max;
  PRIMARY_SELECT_ALL_KEYWORD = 0;
  PRIMARY_SELECT_ACCESS_KEYWORD = primary_select_all_keyword + 1;
  PRIMARY_SELECT_GAN_KEYWORD = primary_select_access_keyword + 1;
  PRIMARY_SELECT_DISTRICT_KEYWORD = primary_select_gan_keyword + 1;
  PRIMARY_SELECT_UUN_KEYWORD = primary_select_district_keyword + 1;
  PRIMARY_SELECT_CONTROL_KEYWORD = primary_select_uun_keyword + 1;
  PRIMARY_SELECT_ENTRYDATE_KEYWORD = primary_select_control_keyword + 1;
$ifany (force_password_change, password_expiration_by_user)
  PRIMARY_SELECT_EXPIREDATE_KEYWORD = primary_select_entrydate_keyword + 1;
$endif (force_password_change, password_expiration_by_user)
$ifnone (force_password_change, password_expiration_by_user)
  PRIMARY_SELECT_EXPIREDATE_KEYWORD = primary_select_entrydate_keyword;
$endif (force_password_change, password_expiration_by_user)
  PRIMARY_SELECT_PASSWORDDATE_KEYWORD = primary_select_expiredate_keyword + 1;
(* keywords associated with the select_access *)
  PRIMARY_SELECT_CLASS_ACCESS_KEYWORD =
    primary_select_passworddate_keyword + 1;
$if allow_temporary_apes
  PRIMARY_SELECT_TEMP_ACCESS_KEYWORD = primary_select_class_access_keyword+1;
$endif allow_temporary_apes
$ifnone allow_temporary_apes
  PRIMARY_SELECT_TEMP_ACCESS_KEYWORD = primary_select_class_access_keyword;
$endif allow_temporary_apes
  PRIMARY_SELECT_GROUP_ACCESS_KEYWORD = primary_select_temp_access_keyword+1;
  PRIMARY_SELECT_HOST_ACCESS_KEYWORD = primary_select_group_access_keyword + 1;
  PRIMARY_SELECT_NODE_ACCESS_KEYWORD = primary_select_host_access_keyword + 1;
$ifnone before_sup_v43
  PRIMARY_SELECT_ACCESS_CONTROL_USERNAME_OK_KEYWORD =
    primary_select_node_access_keyword + 1;
  PRIMARY_SELECT_ACCESS_CONTROL_HOSTNAME_OK_KEYWORD =
    primary_select_access_control_username_ok_keyword + 1;
  PRIMARY_SELECT_ACCESS_CONTROL_NORMAL_KEYWORD =
    primary_select_access_control_hostname_ok_keyword + 1;
  PRIMARY_SELECT_ACCESS_CONTROL_AUXILIARY_KEYWORD =
    primary_select_access_control_normal_keyword + 1;
  PRIMARY_SELECT_ACCESS_CONTROL_USER_REGULAR_CALL_KEYWORD =
    primary_select_access_control_auxiliary_keyword + 1;
  PRIMARY_SELECT_ACCESS_CONTROL_USER_COLLECT_CALL_KEYWORD =
    primary_select_access_control_user_regular_call_keyword + 1;
  PRIMARY_SELECT_ACCESS_CONTROL_HOST_REGULAR_CALL_KEYWORD =
    primary_select_access_control_user_collect_call_keyword + 1;
  PRIMARY_SELECT_ACCESS_CONTROL_HOST_COLLECT_CALL_KEYWORD =
    primary_select_access_control_host_regular_call_keyword + 1;
  PRIMARY_SELECT_ACCESS_CONTROL_SHUT_OVERRIDE_KEYWORD =
    primary_select_access_control_host_collect_call_keyword + 1;
  PRIMARY_SELECT_ACCESS_CONTROL_REQUIRE_HOSTNAME_KEYWORD =
    primary_select_access_control_shut_override_keyword + 1;
  PRIMARY_SELECT_ACCESS_CONTROL_TARGET_DESTINATION_KEYWORD =
    primary_select_access_control_require_hostname_keyword + 1;
  PRIMARY_SELECT_ACCESS_CONTROL_PRIORITY_CONTINUE_KEYWORD =
    primary_select_access_control_target_destination_keyword + 1;
$endif before_sup_v43
(* keywords associated with select_passworddate and select_entrydate *)
  PRIMARY_SELECT_AFTER_DATE_KEYWORD =
$if before_sup_v43     primary_select_node_access_keyword
$ifnot before_sup_v43  primary_select_access_control_priority_continue_keyword
    + 1;
  PRIMARY_SELECT_BEFORE_DATE_KEYWORD =
    primary_select_after_date_keyword + 1;
$if NETVAL_IS_A_SLAVE
  PRIMARY_SELECT_GFD_ONLY_DATE_KEYWORD =
    primary_select_before_date_keyword + 1;
(* keywords associated with the select_control *)
  PRIMARY_SELECT_CONTROL_LICENSED_KEYWORD =
    primary_select_gfd_only_date_keyword + 1;
$endif NETVAL_IS_A_SLAVE
$ifnone NETVAL_IS_A_SLAVE
(* keywords associated with the select_control *)
  PRIMARY_SELECT_CONTROL_LICENSED_KEYWORD =
    primary_select_before_date_keyword + 1;
$endif NETVAL_IS_A_SLAVE
  PRIMARY_SELECT_CONTROL_PASSWORD_ONLY_KEYWORD =
    primary_select_control_licensed_keyword + 1;
  PRIMARY_SELECT_CONTROL_ACCOUNT_SUPERVISOR_KEYWORD =
    primary_select_control_password_only_keyword + 1;
  PRIMARY_SELECT_CONTROL_IGNORE_DESTINATION_KEYWORD =
    primary_select_control_account_supervisor_keyword + 1;
$ifnone before_sup_v43
  PRIMARY_SELECT_CONTROL_USERTYPE_KEYWORD =
    primary_select_control_ignore_destination_keyword + 1;
  PRIMARY_SELECT_CONTROL_HOSTTYPE_KEYWORD =
    primary_select_control_usertype_keyword + 1;
$endif before_sup_v43
  PRIMARY_SELECT_CONTROL_NETWORK_ADMINISTRATOR_KEYWORD =
$if before_sup_v43    primary_select_control_ignore_destination_keyword + 1;
$ifnone before_sup_v43    primary_select_control_hosttype_keyword + 1;
  PRIMARY_SELECT_CONTROL_NO_PASSWORD_REQUIRED_KEYWORD =
    primary_select_control_network_administrator_keyword + 1;
$ifnone before_sup_v43
  PRIMARY_SELECT_CONTROL_AUX_PASSWORD_KEYWORD =
    primary_select_control_no_password_required_keyword + 1;
  PRIMARY_SELECT_CONTROL_TARGET_ENTRY_KEYWORD =
    primary_select_control_aux_password_keyword + 1;
  PRIMARY_SELECT_CONTROL_PROHIBIT_DEFAULT_KEYWORD =
    primary_select_control_target_entry_keyword + 1;
$if allow_logon_inhibit
  PRIMARY_SELECT_CONTROL_LOGON_INHIBIT_KEYWORD =
    primary_select_control_prohibit_default_keyword + 1;
$endif allow_logon_inhibit
$ifnone allow_logon_inhibit
  PRIMARY_SELECT_CONTROL_LOGON_INHIBIT_KEYWORD =
    primary_select_control_prohibit_default_keyword;
$endif allow_logon_inhibit
  PRIMARY_SELECT_CONTROL_AUDITOR_KEYWORD =
    primary_select_control_logon_inhibit_keyword + 1;
$endif before_sup_v43
$if before_sup_v43
  PRIMARY_SELECT_CONTROL_SHUT_OVERRIDE_KEYWORD =
    primary_select_control_no_password_required_keyword + 1;
  PRIMARY_SELECT_CONTROL_AUDITOR_KEYWORD =
    primary_select_control_shut_override_keyword + 1;
$endif before_sup_v43
  PRIMARY_SELECT_CONTROL_OPERATOR_KEYWORD =
    primary_select_control_auditor_keyword + 1;
$if password_expiration_by_user
  PRIMARY_SELECT_CONTROL_EXPIRATION_EXEMPT_KEYWORD =
   primary_select_control_operator_keyword + 1;
$endif password_expiration_by_user
$ifnone password_expiration_by_user
  PRIMARY_SELECT_CONTROL_EXPIRATION_EXEMPT_KEYWORD =
    primary_select_control_operator_keyword;
$endif password_expiration_by_user
$if force_password_change
  PRIMARY_SELECT_CONTROL_FORCE_PASSWD_CHG_EXEMPT_KEYWORD =
    primary_select_control_expiration_exempt_keyword + 1;
$endif force_password_change
$ifnone force_password_change
  PRIMARY_SELECT_CONTROL_FORCE_PASSWD_CHG_EXEMPT_KEYWORD =
    primary_select_control_expiration_exempt_keyword;
$endif force_password_change
$if no_self_password_change
  PRIMARY_SELECT_CONTROL_NO_SELF_PASSWD_CHANGE_KEYWORD =
    primary_select_control_force_passwd_chg_exempt_keyword + 1;
$endif no_self_password_change
$ifnone no_self_password_change
  PRIMARY_SELECT_CONTROL_NO_SELF_PASSWD_CHANGE_KEYWORD =
    primary_select_control_force_passwd_chg_exempt_keyword;
$endif none no_self_password_change
  PRIMARY_SELECT_CONTROL_TRANSPARENT_LOGIN_KEYWORD =
   primary_select_control_no_self_passwd_change_keyword + 1;
  PRIMARY_SELECT_KEYWORD_MAX =
    primary_select_control_transparent_login_keyword + 1;
  PRIMARY_SELECT_SUBCOMMAND_MAX = 0;

  PRIMARY_SEND_KEYWORD_OFFSET =
    primary_select_keyword_offset + primary_select_keyword_max;
$if include_dnic
  PRIMARY_SEND_DNIC_KEYWORD = 0;
  PRIMARY_SEND_TABLE_KEYWORD = primary_send_dnic_keyword + 1;
  PRIMARY_SEND_WAIT_KEYWORD = primary_send_table_keyword + 1;
$endif include_dnic
$ifnone include_dnic
  PRIMARY_SEND_WAIT_KEYWORD = 0;
$endif include_dnic
  PRIMARY_SEND_KEYWORD_MAX = primary_send_wait_keyword + 1;
  PRIMARY_SEND_SUBCOMMAND_MAX = primary_send_wait_keyword;

  PRIMARY_SET_KEYWORD_OFFSET =
    primary_send_keyword_offset + primary_send_keyword_max;
$if logical_volumes
  PRIMARY_SET_DRIVE_KEYWORD = 0;
$endif logical_volumes
$ifnone logical_volumes
  PRIMARY_SET_DRIVE_KEYWORD = -1;
$endif logical_volumes
$if force_password_change
  PRIMARY_SET_GANPASS_KEYWORD = primary_set_drive_keyword + 1;
$endif force_password_change
$ifnone force_password_change
  PRIMARY_SET_GANPASS_KEYWORD = primary_set_drive_keyword;
$endif force_password_change
$if global_password_only_login
  PRIMARY_SET_GPOGAN_KEYWORD = primary_set_ganpass_keyword + 1;
$endif global_password_only_login
$ifnone global_password_only_login
  PRIMARY_SET_GPOGAN_KEYWORD = primary_set_ganpass_keyword;
$endif global_password_only_login
$if prevent_duplicate_passwords
  PRIMARY_SET_PASSPERIOD_KEYWORD = primary_set_gpogan_keyword + 1;
$endif prevent_duplicate_passwords
$ifnone prevent_duplicate_passwords
  PRIMARY_SET_PASSPERIOD_KEYWORD = primary_set_gpogan_keyword;
$endif prevent_duplicate_passwords
$if password_expiration_by_user
  PRIMARY_SET_VALIDITY_KEYWORD = primary_set_passperiod_keyword + 1;
$endif password_expiration_by_user
$ifnot password_expiration_by_user
  PRIMARY_SET_VALIDITY_KEYWORD = primary_set_passperiod_keyword;
$endif password_expiration_by_user
  PRIMARY_SET_SUPERVISOR_KEYWORD = primary_set_validity_keyword + 1;
$if logical_volumes
  PRIMARY_SET_DRIVE_OFFLINE_KEYWORD = primary_set_supervisor_keyword + 1;
$endif logical_volumes
$ifnone logical_volumes
  PRIMARY_SET_DRIVE_OFFLINE_KEYWORD = primary_set_supervisor_keyword;
$endif logical_volumes
  PRIMARY_SET_SUPERVISOR_ON_KEYWORD = primary_set_drive_offline_keyword + 1;
  PRIMARY_SET_SUPERVISOR_OFF_KEYWORD = primary_set_supervisor_on_keyword + 1;

  PRIMARY_SET_KEYWORD_MAX = primary_set_supervisor_off_keyword + 1;
  PRIMARY_SET_SUBCOMMAND_MAX = PRIMARY_SET_SUPERVISOR_KEYWORD + 1;

  PRIMARY_STOP_KEYWORD_OFFSET =
    primary_set_keyword_offset + primary_set_keyword_max;
  PRIMARY_STOP_SUPERVISOR_KEYWORD = 0;
  PRIMARY_STOP_KEYWORD_MAX = 1;
  PRIMARY_STOP_SUBCOMMAND_MAX = 0;

  PRIMARY_UNLOCK_KEYWORD_OFFSET =
    primary_stop_keyword_offset + primary_stop_keyword_max;
  PRIMARY_UNLOCK_KEYWORD_MAX = 0;
  PRIMARY_UNLOCK_SUBCOMMAND_MAX = 0;

  PRIMARY_WRITE_KEYWORD_OFFSET =
    primary_unlock_keyword_offset + primary_unlock_keyword_max;
  PRIMARY_WRITE_CUD_KEYWORD = 0;
  PRIMARY_WRITE_MUD_KEYWORD = primary_write_cud_keyword + 1;
  PRIMARY_WRITE_CUD_FROM_KEYWORD = primary_write_mud_keyword + 1;
  PRIMARY_WRITE_CUD_FROM_SUPERVISOR_KEYWORD =
    primary_write_cud_from_keyword + 1;
  PRIMARY_WRITE_KEYWORD_MAX = 4;
  PRIMARY_WRITE_SUBCOMMAND_MAX = 2;

  PRIMARY_KEYWORD_MAX =
    primary_write_keyword_offset + primary_write_keyword_max - primary_offset;
$endif disk_maintenance_code
$if disk_maintenance_code
  PRIMARY_OFFSET = archive_offset + archive_keyword_max;

  PRIMARY_ARCHIVE_KEYWORD_OFFSET = primary_offset;
  PRIMARY_ARCHIVE_KEYWORD_MAX = 0;
  PRIMARY_ARCHIVE_SUBCOMMAND_MAX = 0;

  PRIMARY_CHECK_KEYWORD_OFFSET =
    primary_archive_keyword_offset + primary_archive_keyword_max;
  PRIMARY_CHECK_CUD_KEYWORD = 0;
$if reuse_uuns
  PRIMARY_CHECK_PARAMETERS_KEYWORD = primary_check_cud_keyword + 1;
  PRIMARY_CHECK_KEYWORD_MAX = 2;
$endif reuse_uuns
$ifnone reuse_uuns   PRIMARY_CHECK_KEYWORD_MAX = 1;
  PRIMARY_CHECK_SUBCOMMAND_MAX = 0;
$ifnot CONVERT_TO_43

  PRIMARY_COMPARE_KEYWORD_OFFSET =
    primary_check_keyword_offset + primary_check_keyword_max;
  PRIMARY_COMPARE_FROM_KEYWORD = 0;
$if BEFORE_SUP_V43  PRIMARY_COMPARE_NODATES_KEYWORD =
$ifnot BEFORE_SUP_V43  PRIMARY_COMPARE_NOORDER_KEYWORD =
    primary_compare_from_keyword + 1;
$if BEFORE_SUP_V43
  PRIMARY_COMPARE_NOGANS_KEYWORD = primary_compare_nodates_keyword + 1;
  PRIMARY_COMPARE_NOORDER_KEYWORD = primary_compare_nogans_keyword + 1;
$endif BEFORE_SUP_V43
  PRIMARY_COMPARE_NOUUNS_KEYWORD = primary_compare_noorder_keyword + 1;
  PRIMARY_COMPARE_SUPERVISOR_KEYWORD = primary_compare_nouuns_keyword + 1;
  PRIMARY_COMPARE_KEYWORD_MAX = 6;
  PRIMARY_COMPARE_SUBCOMMAND_MAX = 0;
$endif not CONVERT_TO_43

  PRIMARY_CONSISTENCY_KEYWORD_OFFSET =
$ifnot CONVERT_TO_43    primary_compare_keyword_offset + primary_compare_keyword_max;
$if CONVERT_TO_43    primary_check_keyword_offset + primary_check_keyword_max;
  PRIMARY_CONSISTENCY_NOCHANGE_KEYWORD = 0;
  PRIMARY_CONSISTENCY_SUPERVISOR_KEYWORD =
    primary_consistency_nochange_keyword + 1;
  PRIMARY_CONSISTENCY_FROM_KEYWORD =
    primary_consistency_supervisor_keyword + 1;
  PRIMARY_CONSISTENCY_KEYWORD_MAX = 3;
  PRIMARY_CONSISTENCY_SUBCOMMAND_MAX = 0;

$ifnot CONVERT_TO_43
  PRIMARY_CONVERT_KEYWORD_OFFSET =
    primary_consistency_keyword_offset + primary_consistency_keyword_max;
  PRIMARY_CONVERT_KEYWORD_MAX = 0;
  PRIMARY_CONVERT_SUBCOMMAND_MAX = 0;
$endif CONVERT_TO_43
$ifall (logical_volumes, check_time_status)

  PRIMARY_COPY_KEYWORD_OFFSET =
$ifnot CONVERT_TO_43    primary_convert_keyword_offset + primary_convert_keyword_max;
$if CONVERT_TO_43    primary_consistency_keyword_offset + primary_consistency_keyword_max;
  PRIMARY_COPY_KEYWORD_MAX = 0;
  PRIMARY_COPY_SUBCOMMAND_MAX = 0;
$endif (logical_volumes, check_time_status)

$if logical_volumes
$if check_time_status
  PRIMARY_DISPLAY_KEYWORD_OFFSET =
    primary_copy_keyword_offset + primary_copy_keyword_max;
$endif check_time_status
$ifnone check_time_status
  PRIMARY_DISPLAY_KEYWORD_OFFSET =
$ifnot CONVERT_TO_43    primary_convert_keyword_offset + primary_convert_keyword_max;
$if CONVERT_TO_43    primary_consistency_keyword_offset + primary_consistency_keyword_max;
$endif check_time_status
$endif logical_volumes
$ifnone logical_volumes
  PRIMARY_DISPLAY_KEYWORD_OFFSET =
$ifnot CONVERT_TO_43    primary_convert_keyword_offset + primary_convert_keyword_max;
$if CONVERT_TO_43    primary_consistency_keyword_offset + primary_consistency_keyword_max;
$endif logical_volumes
  PRIMARY_DISPLAY_CONFIGURATION_KEYWORD = 0;
  PRIMARY_DISPLAY_FILTER_KEYWORD = primary_display_configuration_keyword + 1;
  PRIMARY_DISPLAY_PAGE_KEYWORD = primary_display_filter_keyword + 1;
$if prevent_duplicate_passwords
  PRIMARY_DISPLAY_PASSPERIOD_KEYWORD = primary_display_page_keyword + 1;
$endif prevent_duplicate_passwords
$ifnone prevent_duplicate_passwords
  PRIMARY_DISPLAY_PASSPERIOD_KEYWORD = primary_display_page_keyword;
$endif prevent_duplicate_passwords
$if password_expiration_by_user
  PRIMARY_DISPLAY_VALIDITY_KEYWORD = primary_display_passperiod_keyword + 1;
$endif password_expiration_by_user
$ifnone password_expiration_by_user
  PRIMARY_DISPLAY_VALIDITY_KEYWORD = primary_display_passperiod_keyword;
$endif password_expiration_by_user
$if logical_volumes
  PRIMARY_DISPLAY_VOLUMES_KEYWORD = primary_display_validity_keyword + 1;
$endif logical_volumes
$ifnone logical_volumes
  PRIMARY_DISPLAY_VOLUMES_KEYWORD = primary_display_validity_keyword;
$endif logical_volumes
  PRIMARY_DISPLAY_UNIT_KEYWORD = primary_display_volumes_keyword + 1;

  PRIMARY_DISPLAY_KEYWORD_MAX = primary_display_unit_keyword + 1;
  PRIMARY_DISPLAY_SUBCOMMAND_MAX = primary_display_volumes_keyword + 1;


(* PRIMARY_FILTER_KEYWORD_OFFSETS for all FILTER keywords *)
  PRIMARY_FILTER_KEYWORD_OFFSET =
    primary_display_keyword_offset + primary_display_keyword_max;
  PRIMARY_FILTER_ALL_KEYWORD = 0;
  PRIMARY_FILTER_ARCHIVE_KEYWORD = primary_filter_all_keyword + 1;
  PRIMARY_FILTER_CONSISTENCY_KEYWORD = primary_filter_archive_keyword + 1;
  PRIMARY_FILTER_CUDERROR_KEYWORD = primary_filter_consistency_keyword + 1;
$if perform_daily_cud_scan
  PRIMARY_FILTER_CUDMAINTENANCE_KEYWORD = primary_filter_cuderror_keyword + 1;
$endif perform_daily_cud_scan
$ifnone perform_daily_cud_scan
  PRIMARY_FILTER_CUDMAINTENANCE_KEYWORD = primary_filter_cuderror_keyword;
$endif perform_daily_cud_scan
  PRIMARY_FILTER_DEBUG_KEYWORD = primary_filter_cudmaintenance_keyword + 1;
  PRIMARY_FILTER_FILE_KEYWORD = primary_filter_debug_keyword + 1;
$if NETVAL_IS_A_SLAVE
  PRIMARY_FILTER_MASTER_KEYWORD = primary_filter_file_keyword + 1;
$endif NETVAL_IS_A_SLAVE
$ifnot NETVAL_IS_A_SLAVE
  PRIMARY_FILTER_MASTER_KEYWORD = primary_filter_file_keyword;
$endif NETVAL_IS_A_SLAVE
$if CHANGES_TO_OPER_LOG
  PRIMARY_FILTER_MODIFY_KEYWORD = primary_filter_master_keyword + 1;
$endif CHANGES_TO_OPER_LOG
$ifnot CHANGES_TO_OPER_LOG
  PRIMARY_FILTER_MODIFY_KEYWORD = primary_filter_master_keyword;
$endif CHANGES_TO_OPER_LOG
  PRIMARY_FILTER_MUDUPDATE_KEYWORD = primary_filter_modify_keyword + 1;
  PRIMARY_FILTER_OPERATOR_KEYWORD = primary_filter_mudupdate_keyword + 1;
  PRIMARY_FILTER_PARAMETER_KEYWORD = primary_filter_operator_keyword + 1;
  PRIMARY_FILTER_SUPERVISOR_KEYWORD = primary_filter_parameter_keyword  + 1;
  PRIMARY_FILTER_SYSMSG1_KEYWORD = primary_filter_supervisor_keyword + 1;
$ifany (force_password_change, global_password_only_login)
  PRIMARY_FILTER_PASSCHANGER_KEYWORD = primary_filter_sysmsg1_keyword + 1;
  PRIMARY_FILTER_UN2_KEYWORD = primary_filter_passchanger_keyword + 1;
$endif any force_password_change global_password_only_login
$ifnone (force_password_change, global_password_only_login)
  PRIMARY_FILTER_UN2_KEYWORD = primary_filter_sysmsg1_keyword + 1;
$endif any force_password_change global_password_only_login
$if REUSE_UUNS
  PRIMARY_FILTER_UUNMERGE_KEYWORD = primary_filter_un2_keyword + 1;
$endif REUSE_UUNS
$ifnot REUSE_UUNS
  PRIMARY_FILTER_UUNMERGE_KEYWORD = primary_filter_un2_keyword;
$endif REUSE_UUNS
  PRIMARY_FILTER_VALIDATOR_KEYWORD = primary_filter_uunmerge_keyword + 1;
$if LOGICAL_VOLUMES
  PRIMARY_FILTER_VOLUMES_KEYWORD = primary_filter_validator_keyword + 1;
$endif LOGICAL_VOLUMES
$ifnot LOGICAL_VOLUMES
  PRIMARY_FILTER_VOLUMES_KEYWORD = primary_filter_validator_keyword;
$endif LOGICAL_VOLUMES
  PRIMARY_FILTER_VALIDATOR_NUMBER_KEYWORD = primary_filter_volumes_keyword + 1;
  PRIMARY_FILTER_VALIDATOR_USER_KEYWORD =
    primary_filter_validator_number_keyword + 1;
$if CHANGES_TO_OPER_LOG
  PRIMARY_FILTER_MODIFY_ACCESS_KEYWORD =
    primary_filter_validator_user_keyword + 1;
  PRIMARY_FILTER_MODIFY_CONTROL_KEYWORD =
    primary_filter_modify_access_keyword + 1;
  PRIMARY_FILTER_MODIFY_DISTRICT_KEYWORD =
    primary_filter_modify_control_keyword + 1;
$if password_expiration_date_in_cud
  PRIMARY_FILTER_MODIFY_EXPIRE_DATE_KEYWORD =
    primary_filter_modify_district_keyword + 1;
$endif password_expiration_date_in_cud
$ifnot password_expiration_date_in_cud
  PRIMARY_FILTER_MODIFY_EXPIRE_DATE_KEYWORD =
    primary_filter_modify_district_keyword;
$endif password_expiration_date_in_cud
  PRIMARY_FILTER_MODIFY_GAN_KEYWORD =
    primary_filter_modify_expire_date_keyword + 1;
  PRIMARY_FILTER_MODIFY_NAME_KEYWORD =
    primary_filter_modify_gan_keyword + 1;
$ifnone before_sup_v43
  PRIMARY_FILTER_MODIFY_NUD_KEYWORD = primary_filter_modify_name_keyword + 1;
$endif before_sup_v43
$if before_sup_v43
  PRIMARY_FILTER_MODIFY_NUD_KEYWORD = primary_filter_modify_name_keyword;
$endif before_sup_v43
  PRIMARY_FILTER_MODIFY_PASSWORD_KEYWORD = primary_filter_modify_nud_keyword+1;
$if restrict_users_by_time
  PRIMARY_FILTER_MODIFY_TIME_KEYWORD =
    primary_filter_modify_password_keyword + 1;
$endif restrict_users_by_time
$ifnone restrict_users_by_time
  PRIMARY_FILTER_MODIFY_TIME_KEYWORD = primary_filter_modify_password_keyword;
$endif restrict_users_by_time
  PRIMARY_FILTER_MODIFY_UUN_KEYWORD = primary_filter_modify_time_keyword + 1;
$if NETVAL_IS_A_SLAVE
  PRIMARY_FILTER_MODIFY_GFD_KEYWORD = primary_filter_modify_uun_keyword + 1;
$if INCLUDE_IRC
  PRIMARY_FILTER_MODIFY_IRC_KEYWORD = primary_filter_modify_gfd_keyword + 1;
$endif INCLUDE_IRC
$ifnot INCLUDE_IRC
  PRIMARY_FILTER_MODIFY_IRC_KEYWORD = primary_filter_modify_gfd_keyword;
$endif INCLUDE_IRC
$endif NETVAL_IS_A_SLAVE
$ifnot NETVAL_IS_A_SLAVE
  PRIMARY_FILTER_MODIFY_IRC_KEYWORD = primary_filter_modify_uun_keyword;
$endif NETVAL_IS_A_SLAVE
$if OVERFLOW_CUD_ENTRIES
  PRIMARY_FILTER_MODIFY_OVERFLOW_KEYWORD =primary_filter_modify_irc_keyword + 1;
$endif OVERFLOW_CUD_ENTRIES
$ifnot OVERFLOW_CUD_ENTRIES
  PRIMARY_FILTER_MODIFY_OVERFLOW_KEYWORD =primary_filter_modify_irc_keyword;
$endif OVERFLOW_CUD_ENTRIES
  PRIMARY_FILTER_MODIFY_DELETE_KEYWORD=primary_filter_modify_overflow_keyword+1;
  PRIMARY_FILTER_MODIFY_NEW_KEYWORD = primary_filter_modify_delete_keyword + 1;
$endif CHANGES_TO_OPER_LOG
$ifnot changes_to_oper_log
  PRIMARY_FILTER_MODIFY_NEW_KEYWORD = primary_filter_validator_user_keyword;
$endif changes_to_oper_log
  PRIMARY_FILTER_SUPERVISOR_OFF_KEYWORD = primary_filter_modify_new_keyword + 1;
  PRIMARY_FILTER_KEYWORD_MAX = primary_filter_supervisor_off_keyword + 1;
  PRIMARY_FILTER_SUBCOMMAND_MAX = 0;

  PRIMARY_INITIALIZE_KEYWORD_OFFSET =
    primary_filter_keyword_offset + primary_filter_keyword_max;
  PRIMARY_INITIALIZE_ALL_KEYWORD = 0;
  PRIMARY_INITIALIZE_CONFIGURATION_KEYWORD =
    primary_initialize_all_keyword + 1;
  PRIMARY_INITIALIZE_CUD_KEYWORD =
    primary_initialize_configuration_keyword + 1;
$if include_dnic
  PRIMARY_INITIALIZE_DNIC_KEYWORD= primary_initialize_cud_keyword + 1;
  PRIMARY_INITIALIZE_MUDUPDATE_KEYWORD = primary_initialize_dnic_keyword + 1;
$endif include_dnic
$ifnone include_dnic
  PRIMARY_INITIALIZE_MUDUPDATE_KEYWORD = primary_initialize_cud_keyword + 1;
$endif include_dnic
  PRIMARY_INITIALIZE_NODE_KEYWORD =
    primary_initialize_mudupdate_keyword + 1;
  PRIMARY_INITIALIZE_OPERLOG_KEYWORD =
    primary_initialize_node_keyword + 1;
  PRIMARY_INITIALIZE_PARAMETERS_KEYWORD =
    primary_initialize_operlog_keyword + 1;
$if ganpass_file_exists
  PRIMARY_INITIALIZE_PASSTABLE_KEYWORD =
    primary_initialize_parameters_keyword + 1;
$endif ganpass_file_exists
$ifnone ganpass_file_exists
  PRIMARY_INITIALIZE_PASSTABLE_KEYWORD = primary_initialize_parameters_keyword;
$endif ganpass_file_exists
  PRIMARY_INITIALIZE_SCHEDTABLE_KEYWORD =
    primary_initialize_passtable_keyword + 1;
$ifnot reuse_uuns

  PRIMARY_INITIALIZE_KEYWORD_MAX = primary_initialize_schedtable_keyword + 1;
$endif none reuse_uuns
$if reuse_uuns
  PRIMARY_INITIALIZE_PARAMETERS_ADDBACK_KEYWORD =
    primary_initialize_schedtable_keyword + 1;

  PRIMARY_INITIALIZE_KEYWORD_MAX =
    primary_initialize_parameters_addback_keyword + 1;
$endif reuse_uuns
  PRIMARY_INITIALIZE_SUBCOMMAND_MAX = primary_initialize_schedtable_keyword+1;

  PRIMARY_MESSAGE_KEYWORD_OFFSET =
    primary_initialize_keyword_offset + primary_initialize_keyword_max;
  PRIMARY_MESSAGE_FROM_KEYWORD = 0;
  PRIMARY_MESSAGE_KEYWORD_MAX = 1;
  PRIMARY_MESSAGE_SUBCOMMAND_MAX = 0;

  PRIMARY_QUIT_KEYWORD_OFFSET =
    primary_message_keyword_offset + primary_message_keyword_max;
  PRIMARY_QUIT_KEYWORD_MAX = 0;
  PRIMARY_QUIT_SUBCOMMAND_MAX = 0;

$ifnone convert_to_43
$if reuse_uuns
  PRIMARY_RECOLLECT_KEYWORD_OFFSET =
    primary_quit_keyword_offset + primary_quit_keyword_max;
  PRIMARY_RECOLLECT_FROM_KEYWORD = 0;
  PRIMARY_RECOLLECT_KEYWORD_MAX = 1;
  PRIMARY_RECOLLECT_SUBCOMMAND_MAX = 0;

  PRIMARY_REGENERATE_KEYWORD_OFFSET =
    primary_recollect_keyword_offset + primary_recollect_keyword_max;
$endif reuse_uuns
$ifnone reuse_uuns
  PRIMARY_REGENERATE_KEYWORD_OFFSET =
    primary_quit_keyword_offset + primary_quit_keyword_max;
$endif reuse_uuns
  PRIMARY_REGENERATE_CUD_KEYWORD = 0;
  PRIMARY_REGENERATE_PARAMETERS_KEYWORD = primary_regenerate_cud_keyword + 1;
  PRIMARY_REGENERATE_FROM_KEYWORD =
    primary_regenerate_parameters_keyword + 1;
  PRIMARY_REGENERATE_CUD_SUPERVISOR_KEYWORD =
    primary_regenerate_from_keyword + 1;
$if reuse_uuns
  PRIMARY_REGENERATE_PARAMETERS_ADDBACK_KEYWORD =
    primary_regenerate_cud_supervisor_keyword + 1;
  PRIMARY_REGENERATE_PARAMETERS_APPEND_KEYWORD =
    primary_regenerate_parameters_addback_keyword + 1;
$endif reuse_uuns
$ifnone reuse_uuns
  PRIMARY_REGENERATE_PARAMETERS_APPEND_KEYWORD =
    primary_regenerate_cud_supervisor_keyword;
$endif reuse_uuns
  PRIMARY_REGENERATE_KEYWORD_MAX =
    primary_regenerate_parameters_append_keyword + 1;
  PRIMARY_REGENERATE_SUBCOMMAND_MAX =
    primary_regenerate_parameters_keyword + 1;
$endif convert_to_43
$if convert_to_43
  PRIMARY_REGENERATE_KEYWORD_OFFSET =
    primary_quit_keyword_offset + primary_quit_keyword_max;
  PRIMARY_REGENERATE_KEYWORD_MAX = 0;
$endif convert_to_43

  PRIMARY_SET_KEYWORD_OFFSET =
    primary_regenerate_keyword_offset + primary_regenerate_keyword_max;
$if prevent_duplicate_passwords   PRIMARY_SET_PASSPERIOD_KEYWORD = 0;
$ifnone prevent_duplicate_passwords   PRIMARY_SET_PASSPERIOD_KEYWORD = -1;
$if password_expiration_by_user
  PRIMARY_SET_VALIDITY_KEYWORD = primary_set_passperiod_keyword + 1;
  PRIMARY_SET_VALIDITY_GAN_KEYWORD = primary_set_validity_keyword + 1;
$endif password_expiration_by_user
$ifnone password_expiration_by_user
  PRIMARY_SET_VALIDITY_KEYWORD = primary_set_passperiod_keyword;
  PRIMARY_SET_VALIDITY_GAN_KEYWORD = primary_set_validity_keyword;
$endif password_expiration_by_user
  PRIMARY_SET_KEYWORD_MAX = primary_set_validity_gan_keyword + 1;
  PRIMARY_SET_SUBCOMMAND_MAX = primary_set_validity_keyword + 1;


  PRIMARY_KEYWORD_MAX =
    primary_set_keyword_offset + primary_set_keyword_max - primary_offset;
$endif disk_maintenance_code
!
(*	The following keywords are referred to only	*)
(*	by tokenized lines, not by a command line.	*)

const
  LINE_OFFSET = primary_offset + primary_keyword_max;

  LINE_KEYWORD_OFFSET = line_offset;

  LINE_YES_KEYWORD = 0;
  LINE_NO_KEYWORD = line_yes_keyword + 1;
  LINE_NODE_KEYWORD = line_no_keyword + 1;
  LINE_HOST_KEYWORD = line_node_keyword + 1;
  LINE_GROUP_KEYWORD = line_host_keyword + 1;
  LINE_HOSTLIST_KEYWORD = line_group_keyword + 1;
  LINE_NODELIST_KEYWORD = line_hostlist_keyword + 1;
  LINE_ADD_KEYWORD = line_nodelist_keyword + 1;
  LINE_DELETE_KEYWORD = line_add_keyword + 1;
  LINE_REPLACE_KEYWORD =line_delete_keyword + 1;
  LINE_END_KEYWORD = line_replace_keyword + 1;
  LINE_COMPLETE_KEYWORD = line_end_keyword + 1;
  LINE_KEYWORD_COUNT = 12;

  LINE_KEYWORD_LIMIT = line_keyword_count - 1;

type
  LINE_KEYWORD_INDEX = 0..line_keyword_limit;

  KEYWORD_CHOICE_SET = set of line_keyword_index;



(* keyword totals *)
const
  KEYWORD_MAX = global_keyword_max +
    primary_keyword_max + archive_keyword_max + line_keyword_count;
  KEYWORD_LIMIT = keyword_max - 1;

type
  KEYWORD_INDEX = 0..keyword_limit;
!
(***********************************************************************)
(*                                                                     *)
(*       command scanner definitions                                   *)
(*                                                                     *)
(***********************************************************************)



(* The name of the command in the command definition. *)

const
  COMMAND_NAME_MAX = 12 (* characters *);
  COMMAND_NAME_LIMIT = command_name_max - 1;

type
  COMMAND_NAME_INDEX = 0..command_name_limit;
  COMMAND_NAME_SIZE = 0..command_name_max;

  COMMAND_NAME = array [command_name_index] of char;



(* Keyword type definitions. *)

const
  COMMAND_KEYWORD_MAX = 50 (* maximum number of keywords/command *);
  COMMAND_KEYWORD_LIMIT = command_keyword_max - 1;

type
  COMMAND_KEYWORD_INDEX = 0..command_keyword_limit;
  COMMAND_KEYWORD_TOTAL = 0..command_keyword_max;

type
  COMMAND_KEYWORD_SET = set of command_keyword_index;



(* The name of the keyword in the command definition. *)

const
  KEYWORD_NAME_MAX = 12 (* characters *);
  KEYWORD_NAME_LIMIT = keyword_name_max - 1;

type
  KEYWORD_NAME_INDEX = 0..keyword_name_limit;
  KEYWORD_NAME_SIZE = 0..keyword_name_max;

  KEYWORD_NAME = array [keyword_name_index] of char;



(* Define HELP text...text to be stored with commands and keywords to	*)
(* be output on the HELP command according to the validators license	*)
(* and current context.							*)

const (* size of tty line minus possible command and spaces *)
  HELP_TEXT_MAX = command_line_text_max - (command_name_max + 6);
  HELP_TEXT_LIMIT = help_text_max - 1;

type
  HELP_TEXT_INDEX = 0..help_text_limit;
  HELP_TEXT_SIZE = 0..help_text_max;

  HELP_STRING = array [help_text_index] of char;



(* Freeword definitions. *)

const
  COMMAND_FREEWORD_MAX = 20 (* maximum number of freewords/command *);
  COMMAND_FREEWORD_LIMIT = command_freeword_max - 1;

type
  COMMAND_FREEWORD_INDEX = 0..command_freeword_limit;
  COMMAND_FREEWORD_TOTAL = 0..command_freeword_max;



(* Command token definition.  This record points to a command line token. *)

const
  COMMAND_TOKEN_MAX = command_line_text_limit (* maximum token extent *);
  COMMAND_TOKEN_LIMIT = command_token_max - 1;

type
  COMMAND_TOKEN_INDEX = 0..command_token_limit;
  COMMAND_TOKEN_SIZE = 0..command_token_max;

type
  COMMAND_TOKEN = record
    start  : command_token_index;
    finish : command_token_index
  end (* command_token *);



(* Description of a command line after it is scanned.			*)
(* The fields of the record have the following meaning.			*)
(*									*)
(*  input_line		the text to be scanned				*)
(*  prompt		the prompt for the current command class	*)
(*  status		the status of the scan i.e. an error code	*)
(*  command_class	the context the command comes from		*)
(*  command		the index of the command scanned		*)
(*  subcommand		the keyword index of the subcommand if one	*)
(*			is required. A subcommand is required if the	*)
(*			'subcommand_count' in the command definition	*)
(*			is greater than zero				*)
(*  keyword_count	the number of keywords in the command		*)
(*  keyword_present	the set of all keywords scanned			*)
(*  keyword_value	the value token if the command requires one	*)
(*  freeword_count	the number of freewords in the command		*)
(*  freeword_value	the token for the freewords entered		*)

type
  SCANNED_COMMAND = record
    input_line		: command_line;
    prompt		: command_prompt;
    status		: command_scan_state;
    command_class	: command_class_index;
    command		: command_index;
    subcommand		: command_keyword_index;
    keyword_count	: command_keyword_total;
    keyword_present	: command_keyword_set;
    keyword_value	: array [command_keyword_index] of command_token;
    freeword_count	: command_freeword_total;
    freeword_value	: array [command_freeword_index] of command_token
  end (* scanned_command *);
!
(* A command definition header.						*)
(* This record defines a command, including its name and allowed	*)
(* parameters. The fields of the record have the following meaning.	*)
(*									*)
(*  name		the text for the command name			*)
(*  required_license	the command_license the validator must have     *)
(*                      for the command to be executed.			*)
(*			Keywords may have further requirements.		*)
(*  freeword_allowed	true if the command allows freewords		*)
(*  keyword_offset	the start of the keywords for this command in	*)
(*			'keyword_table' which contains all keywords	*)
(*			for all commands				*)
(*  keyword_count	the number of keywords allowed for this command	*)
(*			in 'keyword_table' starting at 'keyword_offset'	*)
(*  subcommand_count	the number of the keywords for this command	*)
(*			which should be treated as subcommands. These	*)
(*			will be the first 'subcommand_total' keywords	*)
(*			of this command					*)
(*  explanation         string for HELP command 			*)

type
  COMMAND_DEFINITION = record
    name		: command_name;
    required_license	: command_license;
    freeword_allowed	: boolean;
    keyword_offset	: keyword_index;
    keyword_count	: command_keyword_total;
    subcommand_count	: command_keyword_total;
    explanation		: help_string
  end (* command_definition *);



(* A keyword definition.						*)
(* This record defines a keyword, including its name and		*)
(* properties. The fields of the record have the folowing meaning.	*)
(*									*)
(*  name		the text for the keyword name			*)
(*  required_license	the command_license the validator must have     *)
(*                      for the command with this keyword to be		*)
(*			executed. The command and other keywords may 	*)
(*			have further level requirements			*)
(*  value_required	true if the keyword must be followed by a value	*)
(*  explanation         string for HELP command 			*)

type
  KEYWORD_DEFINITION = record
    name		: keyword_name;
    required_license	: command_license;
    value_required	: boolean;
    explanation		: help_string
  end (* keyword_definition *);
!
$ifnone OLD_LIST_CONFIGURATION
(************************************************************************)
(*									*)
(*	sysio.ntv							*)
(*									*)
(*			    system_handler				*)
(*									*)
(*	This class contains system I/O calls.				*)
(*									*)
(*      The following identifiers must be defined externally:		*)
(*	  system_operation, systam_param, system_information		*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	11Nov87 - neh							*)
(*	      - add DNICDATA_CHECKSUM and DNIC_CHECKSUM			*)
(*	09APR87 - rsb							*)
(*		- add PASSTABLE_CHECKSUM 				*)
(*	14Jan87 - neh							*)
(*	      - change supervisor_checksum to be included only if 	*)
(*		BEFORE_SUP_V43 being enabled				*)
(*	07Mar86 - jrn							*)
(*	      - add CURRENT_HOST_STATE procedure			*)
(*	19Dec85 - jrn							*)
(*	      - remove the 3 functions, TYM_FILE_TERMINAL_COUNT, 	*)
(*		TYM_FILE_AUX_CIRCUIT_COUNT, KERNEL_HOST; replace with	*)
(*		a single sysio call in the initial statement, and the	*)
(*		entry variable sys_info					*)
(*	01Nov85 - jrn							*)
(*	      - add SET_HOST_STATE procedure				*)
(*	23May85 - jrn							*)
(*	      - change functions to procedures to pass variable		*)
(*		arguments, so that I/O calls do not require an		*)
(*		additional stack variable (to save space)		*)
(*	      - add supervisor_checksum routine				*)
(*	23Mar85 - pgl							*)
(*	      - delete all functions referring to tape checksums	*)
(*	07Aug84 - jrn							*)
(*	      - add various checksum computations, internal		*)
(*		"engine_checksum" routine, and remove entry variable	*)
(*		"param"							*)
(*	01Aug84 - jrn							*)
(*	      - change function netval_host_number to kernel_host to	*)
(*		return the kernel host number to check to see if the	*)
(*		NETVAL kernel host is the same as a Supervisor (check	*)
(*		is in MISC_UTILITY routine LEGAL_CONSISTENCY)		*)
(*		Original -- jrn						*)
(*									*)
(************************************************************************)


type SYSTEM_HANDLER = class;


var
  entry sys_info : system_information;



(**************************  system_handler  ****************************)
(*									*)
(*			       initialize				*)
(*									*)
(************************************************************************)

procedure initialize;

var
  param : system_param;

begin
  param.operation := SYSTEM_INFO;
  io(sys_info, param, SYSTEM, 0)
end (* initialize *);
$endif OLD_LIST_CONFIGURATION
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if BEFORE_SUP_V43



(**************************  system_handler  ****************************)
(*									*)
(*			   supervisor_checksum				*)
(*									*)
(*      Return the supervisor (940) checksum.				*)
(*									*)
(************************************************************************)

procedure entry SUPERVISOR_CHECKSUM(
      size	: cud_data_size;
  var data	: cud_data;
  var checksum	: integer);

var
  param : system_param;

begin
  param.operation := GET_940_CHECKSUM;
  param.arg1 := size;
  io(data, param, SYSTEM, 0);
  checksum := param.arg2
end (* supervisor_checksum *);
$endif BEFORE_SUP_V43



(**************************  system_handler  ****************************)
(*									*)
(*			     engine_checksum				*)
(*									*)
(*      Return the engine vertical checksum in the left half and	*)
(*	the diagonal checksum in the right half.			*)
(*									*)
(************************************************************************)

function engine_checksum(
      param : system_param) : integer;

begin
  engine_checksum := (param.arg1 * BIT15) + param.arg2
end (* engine_checksum *);



(**************************  system_handler  ****************************)
(*									*)
(*			   page_checksum				*)
(*									*)
(*      Return the system checksum for the page data.			*)
(*									*)
(************************************************************************)

procedure 
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone OLD_LIST_CONFIGURATION entry
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
PAGE_CHECKSUM(
      size	: page_length;
  var data	: univ page;
  var checksum	: integer);

var
  param : system_param;

begin
  param.operation := SYSTEM_CHECKSUM;
  param.arg1 := size;
  io(data, param, SYSTEM, 0);
  checksum := engine_checksum(param)
end (* page_checksum *);
$if include_dnic


(**************************  system_handler  ****************************)
(*									*)
(*  Name:	dnic_checksum						*)
(*									*)
(*  Purpose:	compute checksum on entire dnicfile			*)
(*									*)
(************************************************************************)

procedure entry DNIC_CHECKSUM(
  var data	: univ dnic_file_in_bytes;
  var checksum  : integer);

var
  param : system_param;

begin (* dnicfile_checksum *);
  param.operation := SYSTEM_CHECKSUM;
  param.arg1 := DNIC_FILE_LENGTH;
  io(data, param, SYSTEM, 0);
  checksum := engine_checksum(param)
end (* dnicfile_checksum *);


(**************************  system_handler  ****************************)
(*									*)
(*  Name:	dnicdata_checksum					*)
(*									*)
(*  Purpose:	compute checksum on entire dnictable			*)
(*									*)
(************************************************************************)

procedure entry DNICDATA_CHECKSUM(
  var data : univ dnic_table_in_bytes;
  var checksum : integer);

var
  param : system_param;

begin (* dnicdata_checksum *);
  param.operation := SYSTEM_CHECKSUM;
  param.arg1 := DNIC_DATA_LENGTH;
  io(data, param, SYSTEM, 0);
  checksum := engine_checksum(param)
end (* dnicdata_checksum *);
$endif include_dnic
$ifany (force_password_change, global_password_only_login)



(**************************  system_handler  ****************************)
(*									*)
(*  Name:	passtable_checksum					*)
(*									*)
(*  Purpose:	compute checksum on entire Passtable			*)
(*									*)
(************************************************************************)

procedure  
$ifnone OLD_LIST_CONFIGURATION  entry 
PASSTABLE_CHECKSUM(
      size : passtable_file_length;
  var data : univ actual_passtable_data;
  var checksum : integer);

var
  param : system_param;

begin (* passtable_checksum *);
  param.operation := SYSTEM_CHECKSUM;
  param.arg1 := size;
  io(data, param, SYSTEM, 0);
  checksum := engine_checksum(param)
end (* passtable_checksum *);
$endif any(force_password_change, global_password_only_login)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(**************************  system_handler  ****************************)
(*									*)
(*			   named_list_checksum				*)
(*									*)
(*      Return the system checksum for the named_list_definition.	*)
(*									*)
(************************************************************************)

procedure 
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone OLD_LIST_CONFIGURATION entry
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
NAMED_LIST_CHECKSUM(
  var named_list	: named_list_definition;
  var checksum		: integer);

var
  param : system_param;

begin
  param.operation := SYSTEM_CHECKSUM;
  param.arg1 := MAXIMUM_BYTES_IN_NAMED_LIST - MAXIMUM_BYTES_IN_WORD;
  io(named_list, param, SYSTEM, 0);
  checksum := engine_checksum(param)
end (* named_list_checksum *);



(**************************  system_handler  ****************************)
(*									*)
(*			 global_access_checksum				*)
(*									*)
(*      Return the system checksum for a global_access.			*)
(*									*)
(************************************************************************)

procedure 
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone OLD_LIST_CONFIGURATION entry
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
GLOBAL_ACCESS_CHECKSUM(
  var global_access	: global_access_description;
  var checksum		: integer);

var
  param : system_param;

begin
  param.operation := SYSTEM_CHECKSUM;
  param.arg1 := MAXIMUM_BYTES_IN_GLOBAL_ACCESS_DESCRIPTION -
    MAXIMUM_BYTES_IN_WORD;
  io(global_access, param, SYSTEM, 0);
  checksum := engine_checksum(param)
end (* global_access_checksum *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone OLD_LIST_CONFIGURATION



(**************************  system_handler  ****************************)
(*									*)
(*			     cud_checksum				*)
(*									*)
(*      Return the system checksum for the cud data.			*)
(*									*)
(************************************************************************)

procedure entry CUD_CHECKSUM(
      size	: cud_data_size;
  var data	: univ cud_data;
  var checksum	: integer);

var
  param : system_param;

begin
  param.operation := SYSTEM_CHECKSUM;
  param.arg1 := size;
  io(data, param, SYSTEM, 0);
  checksum := engine_checksum(param)
end (* cud_checksum *);
$ifnone BEFORE_SUP_V43



(**************************  system_handler  ****************************)
(*									*)
(*			     mud_checksum				*)
(*									*)
(*      Return the system checksum for the cud data.			*)
(*									*)
(************************************************************************)

procedure entry MUD_CHECKSUM(
      size	: mud_data_size;
  var data	: univ mud_data;
  var checksum	: integer);

var
  param : system_param;

begin
  param.operation := SYSTEM_CHECKSUM;
  param.arg1 := size;
  io(data, param, SYSTEM, 0);
  checksum := engine_checksum(param)
end (* mud_checksum *);
$if CONVERT_TO_43




(**************************  system_handler  ****************************)
(*									*)
(*			     read_cud_checksum				*)
(*									*)
(*      Return the system checksum for the cud data.			*)
(*									*)
(************************************************************************)

procedure entry READ_CUD_CHECKSUM(
      size	: read_cud_data_size;
  var data	: univ read_cud_data;
  var checksum	: integer);

var
  param : system_param;

begin
  param.operation := SYSTEM_CHECKSUM;
  param.arg1 := size;
  io(data, param, SYSTEM, 0);
  checksum := engine_checksum(param)
end (* read_cud_checksum *);
$endif CONVERT_TO_43
$endif BEFORE_SUP_V43
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code


(**************************  system_handler  ****************************)
(*									*)
(*			     set_host_state				*)
(*									*)
(************************************************************************)

procedure entry SET_HOST_STATE(
      state_to_set	: host_state);

var
  param : system_param;
  dummy : integer;

begin
  case state_to_set of
    UP_STATE:	param.operation := SET_SYSTEM_UP;
    DOWN_STATE:	param.operation := SET_SYSTEM_DOWN;
    SHUT_STATE:	param.operation := SET_SYSTEM_SHUT;
    GONE_STATE:	param.operation := SET_SYSTEM_GONE
  end (* case *);
  io(dummy, param, SYSTEM, 0)
end (* set_host_state *);
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(**************************  system_handler  ****************************)
(*									*)
(*			   current_host_state				*)
(*									*)
(************************************************************************)

function entry CURRENT_HOST_STATE : host_state;

var
  param : system_param;
  dummy : integer;
  state : host_state;

begin
  param.operation := GET_HOST_STATE;
  param.arg1 := 0;
  io(dummy, param, SYSTEM, 0);
  state := UP_STATE; dummy := 0;
  while dummy < param.arg1 do
    begin
      state := succ(state);
      dummy := dummy + 1
    end (* while *);
  current_host_state := state
end (* current_host_state *);



(************************************************************************)
(************************************************************************)

begin (* initial statement *)
  initialize
end (* system_handler *);
$endif OLD_LIST_CONFIGURATION
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
(************************************************************************)
(*								      	*)
(*	MUTIL.NTV							*)
(*								      	*)
(*				misc_utility			      	*)
(*								      	*)
(*    This class handles miscellaneous operations.			*)
(*        							      	*)
(************************************************************************)
(*								      	*)
(*			   Revision Record		    		*)
(*							      		*)
(*	08Dec87 - neh							*)
(*	      - add unsigned_mod to perform modulo for 32 bit integer	*)
(*	11Nov87 - neh							*)
(*	      - add dnicname_match if include_dnic is enabled		*)
(*	02Jun86 - jrn							*)
(*	      - add legal_username_character function			*)
(*	05Mar86 - jrn							*)
(*	      - add same_name procedure with different arguments than	*)
(*		username_match, and use new do_username_match function	*)
(*	23Dec85	- rsb							*)
(*		  change def of "sup" in legal_consistency to		*)
(*		real_sup	  : real_supervisor_index;		*)
(*	19Dec85 - jrn							*)
(*	      - change sys_io.kernel_host to				*)
(*		sys_io.sys_info.kernel_host_number			*)
(*	19Feb85 - jrn							*)
(*	      - add decimal_digit function				*)
(*	01Aug84 - jrn							*)
(*	      - fix bug in LEGAL_CONSISTENCY function (compare  	*)
(*		supervisor_index + PRINT_SUPERVISOR_OFFSET against	*)
(*		sysio.kernel_host)					*)
(*	Version 2.01 May 1, 1984 - jrn					*)
(*	      - remove percent routine					*)
(*	14Mar84	Version 2.01 neb					*)
(*	      - added the CLEAR_PAGE and CLEAR_BLOCK routines		*)
(*	29SEP83    Original -- from (patrol)mutil.tms - jrn     	*)
(*							      		*)
(************************************************************************)


type MISC_UTILITY = class;


var
  sys_io : system_handler;
"

(****************************  misc_utility  ****************************)
(*								      	*)
(*			  	 percent				*)
(*								      	*)
(*    The second argument percent of the first argument.		*)
(*								      	*)
(************************************************************************)

function entry PERCENT(
      n	: integer;
      p : integer) : integer;

begin
  percent := (n*p+99) div 100
end (* percent *);
"



(****************************  misc_utility  ****************************)
(*									*)
(*			     do_username_match				*)
(*									*)
(*      Return TRUE if usernames match.					*)
(*									*)
(************************************************************************)

function do_username_match(
      first_name	: username_string;
      second_name	: username_string) : boolean;

var
  i : username_text_index;

begin
  do_username_match := TRUE;
  if first_name.size <> second_name.size
  then do_username_match := FALSE
  else
    for i := 0 to first_name.size - 1 do
      if first_name.text[i] <> second_name.text[i]
      then do_username_match := FALSE
end (* do_username_match *);



(****************************  misc_utility  ****************************)
(*									*)
(*			      username_match				*)
(*									*)
(*      Return TRUE if usernames match.					*)
(*									*)
(************************************************************************)

function entry USERNAME_MATCH(
      first_name	: username_string;
      second_name	: username_string) : boolean;

begin
  username_match := do_username_match(first_name, second_name);
end (* username_match *);



(****************************  misc_utility  ****************************)
(*									*)
(*				same_name				*)
(*									*)
(*      Return TRUE if second_name matches the name described by	*)
(*	first_name_text and first_name_size.				*)
(*									*)
(************************************************************************)

function entry SAME_NAME(
      first_name_text	: username_text;
      first_name_size	: username_text_size;
      second_name	: username_string) : boolean;

var
  first_name : username_string;

begin
  first_name.text := first_name_text;
  first_name.size := first_name_size;
  same_name := do_username_match(second_name, first_name)
end (* same_name *);
$if include_dnic



(****************************  misc_utility  ****************************)
(*									*)
(*				dnic_match				*)
(*									*)
(*      Return TRUE if second_dnic matches the dnic described by	*)
(*	first_dnic.							*)
(*									*)
(************************************************************************)

function entry DNIC_MATCH(
      first_dnic	: dnicname_string;
      second_dnic	: dnicname_string) : boolean;

var
  i : dnicname_index;

begin
  dnic_match := TRUE;
  for i := 0 to DNICNAME_LIMIT do
    if first_dnic[i] <> second_dnic[i]
    then dnic_match := FALSE
end (* dnic_match *);
$endif include_dnic


(***************************  misc_utility  *****************************)
(*									*)
(*				odd_value				*)
(*									*)
(*	Return true if test word has rightmost bit set. 		*)
(*									*)
(************************************************************************)

function odd_value(
      test_word	: integer) : boolean;

begin
  odd_value := (test_word mod 2) <> 0
end (* odd_value *);



(***************************  misc_utility  *****************************)
(*									*)
(*				 odd					*)
(*									*)
(*	Return true if test word has rightmost bit set. 		*)
(*									*)
(************************************************************************)

function entry ODD(
      test_word	: integer) : boolean;

begin
  odd := odd_value(test_word)
end (* odd *);



(***************************  misc_utility  *****************************)
(*									*)
(*				maximum					*)
(*									*)
(*	Return the greater of the two integers.				*)
(*									*)
(************************************************************************)

function entry MAXIMUM(
      number1	: integer;
      number2	: integer) : integer;

begin
  if number1 > number2
  then maximum := number1
  else maximum := number2
end (* maximum *);



(***************************  misc_utility  *****************************)
(*									*)
(*				minimum					*)
(*									*)
(*	Return the lesser of the two integers.				*)
(*									*)
(************************************************************************)

function entry MINIMUM(
      number1	: integer;
      number2	: integer) : integer;

begin
  if number1 < number2
  then minimum := number1
  else minimum := number2
end (* minimum *);



(***************************  misc_utility  *****************************)
(*									*)
(*			      do_test_bit				*)
(*									*)
(*    Test if given bit is on in test word.				*)
(*									*)
(************************************************************************)

function do_test_bit(
      bit	: integer;
      test_word	: univ integer) : boolean;

var
  x : integer;

begin
  x := test_word;
  if bit < 0
  then do_test_bit := x < 0
  else
    begin
      if x < 0
      then x := x + BIT0;
      do_test_bit := odd_value(x div bit)
    end
end (* do_test_bit *);



(***************************  misc_utility  *****************************)
(*									*)
(*				test_bit				*)
(*									*)
(*    Test if given bit is on in test word.				*)
(*									*)
(************************************************************************)

function entry TEST_BIT(
      bit	: integer;
      test_word : univ integer) : boolean;

begin
  test_bit := do_test_bit(bit, test_word);
end (* test_bit *);



(***************************  misc_utility  *****************************)
(*									*)
(*				 set_bit				*)
(*									*)
(*    Be sure bit is on in word.					*)
(*									*)
(************************************************************************)

procedure entry SET_BIT(
      bit	: integer;
  var word	: univ integer);

begin
  if not do_test_bit(bit, word)
  then word := word + bit
end (* set_bit *);



(***************************  misc_utility  *****************************)
(*									*)
(*				clear_bit				*)
(*									*)
(*    Be sure bit is off in word.					*)
(*									*)
(************************************************************************)

procedure entry CLEAR_BIT(
      bit	: integer;
  var word	: univ integer);

begin
  if do_test_bit(bit, word)
  then word := word - bit
end (* clear_bit *);


(****************************  misc_utility  ****************************)
(*									*)
(*				left_shift				*)
(*									*)
(*	Return integer shifted left such that the rightmost bit of the	*)
(*	original integer has shifted to the position occupied by the	*)
(*	given bit.							*)
(*									*)
(*	   1111111111222222222233	     1111111111222222222233	*)
(* 01234567890123456789012345678901   01234567890123456789012345678901	*)
(* ................................   ............00000000000000000000	*)
(*	    ^								*)
(*	   bit								*)
(*									*)
(************************************************************************)

function entry LEFT_SHIFT(
      bit		: integer;
      shift_word	: integer) : integer;

begin
  if bit = BIT0
  then
    if odd_value(shift_word)
    then left_shift := BIT0
    else left_shift := 0
  else
    if shift_word < 0
    then left_shift := (shift_word + BIT0) * bit
    else left_shift := shift_word * bit
end (* left_shift *);



(****************************  misc_utility  ****************************)
(*									*)
(*			      do_right_shift				*)
(*									*)
(*									*)
(*	Return integer shifted right such that the bit in the original	*)
(*	word in the same position as the given bit is moved to the	*)
(*	rightmost bit position. 					*)
(*									*)
(*	   1111111111222222222233	     1111111111222222222233	*)
(* 01234567890123456789012345678901   01234567890123456789012345678901	*)
(* ................................   00000000000000000000............	*)
(*	    ^								*)
(*	   bit								*)
(************************************************************************)

function do_right_shift(
      bit		: integer;
      shift_word	: integer) : integer;

begin
  if bit = BIT0
  then
    if shift_word < 0
    then do_right_shift := 1
    else do_right_shift := 0
  else
    if shift_word < 0
    then do_right_shift := (shift_word + BIT0) div bit + (BIT1 div (bit div 2))
    else do_right_shift := shift_word div BIT
end (* do_right_shift *);



(****************************  misc_utility  ****************************)
(*									*)
(*			      right_shift				*)
(*									*)
(************************************************************************)

function entry RIGHT_SHIFT(
      bit		: integer;
      shift_word	: integer) : integer;

begin
  right_shift := do_right_shift(bit, shift_word)
end (* right_shift *);


(****************************  misc_utility  ****************************)
(*									*)
(*				   xor					*)
(*									*)
(*	return the exclusive OR of the two sets.			*)
(*									*)
(************************************************************************)

procedure xor(
  var x	: univ character_set;
      y	: univ character_set);

begin
  x := (x-y) or (y-x)
end (* xor *);



(****************************  misc_utility  ****************************)
(*									*)
(*			     exclusive_or				*)
(*									*)
(*	return the exclusive OR of the two integers.			*)
(*									*)
(************************************************************************)

function entry EXCLUSIVE_OR(
      x	: integer;
      y : integer) : integer;

var
  xarray : integer_array;
  yarray : integer_array;

begin
  xarray[0] := x;
  yarray[0] := y;
  xor(xarray, yarray);
  exclusive_or := xarray[0]
end (* exclusive_or *);



(****************************  misc_utility  ****************************)
(*									*)
(*				mask_sets				*)
(*									*)
(*	return the AND of the two sets.					*)
(*									*)
(************************************************************************)

procedure mask_sets(
  var x	: univ character_set;
      y	: univ character_set);

begin
  x := x & y (* x AND y *)
end (* mask_sets *);



(****************************  misc_utility  ****************************)
(*									*)
(*				  mask					*)
(*									*)
(*	return the AND of the two integers.				*)
(*									*)
(************************************************************************)

function entry MASK(
      x	: integer;
      y : integer) : integer;

var
  xarray : integer_array;
  yarray : integer_array;

begin
  xarray[0] := x;
  yarray[0] := y;
  mask_sets(xarray, yarray);
  mask := xarray[0]
end (* mask *);


(****************************  misc_utility  ****************************)
(*									*)
(*			       unsigned_mod				*)
(*									*)
(*	return the AND of the two integers.				*)
(*									*)
(************************************************************************)

function entry UNSIGNED_MOD(
      value	: integer;
      divisor	: integer) : integer;

var
  add_odd : integer;
  temp_value : integer;

begin
  if odd_value(value)
  then add_odd := 1
  else add_odd := 0;
  temp_value := do_right_shift(BIT30, value) (* right shift value 1 bit *);
  if value < 0
  then unsigned_mod := ((temp_value mod divisor) * BIT30) mod divisor + add_odd
  else unsigned_mod := value mod divisor
end (* unsigned_mod *);



(***************************  misc_utility  *****************************)
(*								      	*)
(*			       halfword_count				*)
(*								      	*)
(*	Compute the number of half words required to store		*)
(*	byte_count bytes.						*)
(*								      	*)
(************************************************************************)

function entry HALFWORD_COUNT(
      byte_count	: univ integer) : integer;

begin
  halfword_count := (byte_count + HALFWORD_CHARS_LIMIT) div
    MAXIMUM_CHARS_IN_HALFWORD
end (* halfword_count *);

(***************************  misc_utility  *****************************)
(*								      	*)
(*			       word_count				*)
(*								      	*)
(*	Compute the number of whole words required to store		*)
(*	byte_count bytes.						*)
(*								      	*)
(************************************************************************)

function entry WORD_COUNT(
      byte_count	: univ integer) : integer;

begin
  word_count := (byte_count + WORD_IN_BYTES_LIMIT) div MAXIMUM_BYTES_IN_WORD
end (* word_count *);



(****************************  misc_utility  ****************************)
(*								      	*)
(*			   save_halfword_in_word		  	*)
(*								      	*)
(*    Store the  halfword_to_save in the right half of target_word.	*)
(*								      	*)
(************************************************************************)

procedure entry SAVE_HALFWORD_IN_WORD(
      halfword_to_save	: univ halfword;
  var target_word	: univ word_in_halfwords);

begin
  target_word[0] := ZERO_HALFWORD;
  target_word[1] := halfword_to_save
end (* save_halfword_in_word *);



(****************************  misc_utility  ****************************)
(*								      	*)
(*			   save_word_in_halfword		  	*)
(*								      	*)
(*    Store the rightmost half of word_to_save in target_halfword.	*)
(*								      	*)
(************************************************************************)

procedure entry SAVE_WORD_IN_HALFWORD(
      word_to_save	: univ word_in_halfwords;
  var target_halfword	: halfword);

begin
  target_halfword := word_to_save[1]
end (* save_word_in_halfword *);



(****************************  misc_utility  ****************************)
(*								      	*)
(*			   value_of_halfword		  		*)
(*								      	*)
(*    Return halfword_value in right half of value_of_halfword.		*)
(*								      	*)
(************************************************************************)

function entry VALUE_OF_HALFWORD(
      halfword_value	: univ halfword) : integer;

begin
  value_of_halfword := (ord(halfword_value[0]) * BIT23) +
    ord(halfword_value[1])
end (* value_of_halfword *);



(****************************  misc_utility  ****************************)
(*								      	*)
(*			   save_word_to_two_chars		  	*)
(*								      	*)
(*    Store the leftmost half of word_to_save in target_chars.		*)
(*								      	*)
(************************************************************************)

procedure entry SAVE_WORD_TO_TWO_CHARS(
      word_to_save	: univ word_in_bytes;
  var target_chr1	: char;
  var target_chr2	: char);

begin
  target_chr1 := word_to_save[0];
  target_chr2 := word_to_save[1]
end (* save_word_to_two_chars *);



(****************************  misc_utility  ****************************)
(*                                                                      *)
(*                         save_two_chars_to_word                       *)
(*                                                                      *)
(*    Store two chars in the leftmost half of target_word.		*)
(*                                                                      *)
(************************************************************************)

procedure entry SAVE_TWO_CHARS_TO_WORD(
      chr1              : char;
      chr2              : char;
  var target_word       : univ word_in_bytes);

begin
  target_word[0] := chr1;
  target_word[1] := chr2;
  target_word[2] := ZERO;
  target_word[3] := ZERO
end (* save_two_chars_to_word *);


(****************************  misc_utility  ****************************)
(*								      	*)
(*			   save_word_in_two_chars		  	*)
(*								      	*)
(*    Store the rightmost half of word_to_save in target_chars.		*)
(*								      	*)
(************************************************************************)

procedure entry SAVE_WORD_IN_TWO_CHARS(
      word_to_save	: univ word_in_bytes;
  var target_chr1	: char;
  var target_chr2	: char);

begin
  target_chr1 := word_to_save[2];
  target_chr2 := word_to_save[3]
end (* save_word_in_two_chars *);



(****************************  misc_utility  ****************************)
(*                                                                      *)
(*                         save_two_chars_in_word                       *)
(*                                                                      *)
(*    Store two chars in the rightmost half of target_word.		*)
(*                                                                      *)
(************************************************************************)

procedure entry SAVE_TWO_CHARS_IN_WORD(
      chr1              : char;
      chr2              : char;
  var target_word       : univ word_in_bytes);

begin
  target_word[0] := ZERO;
  target_word[1] := ZERO;
  target_word[2] := chr1;
  target_word[3] := chr2
end (* save_two_chars_in_word *);



(****************************  misc_utility  ****************************)
(*								      	*)
(*			   save_halfword_in_characters		  	*)
(*								      	*)
(*    Store the rightmost half of word_to_save in target_halfword.	*)
(*								      	*)
(************************************************************************)

procedure entry SAVE_HALFWORD_IN_CHARACTERS(
      half_word_to_save	: univ halfword;
  var ch1		: char;
  var ch2		: char);

begin
  ch1 := half_word_to_save[0];
  ch2 := half_word_to_save[1]
end (* save_halfword_in_characters *);



(****************************  misc_utility  ****************************)
(*								      	*)
(*			   save_characters_in_halfword		  	*)
(*								      	*)
(*    Store the rightmost half of word_to_save in target_halfword.	*)
(*								      	*)
(************************************************************************)

procedure entry SAVE_CHARACTERS_IN_HALFWORD(
      ch1		: char;
      ch2		: char;
  var target_half_word	: univ halfword);

begin
  target_half_word[0] := ch1;
  target_half_word[1] := ch2
end (* save_characters_in_halfword *);
$ifnone disk_maintenance_code



(***************************  misc_utility  *****************************)
(*									*)
(*			make_character_upper_case			*)
(*									*)
(************************************************************************)

procedure entry MAKE_CHARACTER_UPPER_CASE(
  var c	: char);

begin
  if (lower_case_a <= c) and (c <= lower_case_z)
  then c := chr(ord(c) - 32)
end (* make_character_upper_case *);
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)




(****************************  misc_utility  ****************************)
(*								      	*)
(*			  save_characters_in_word			*)
(*								      	*)
(*    Store the four characters, ch1, ch2, ch3, ch4 in word.		*)
(*								      	*)
(************************************************************************)

procedure entry SAVE_CHARACTERS_IN_WORD(
      ch1	: char;
      ch2	: char;
      ch3	: char;
      ch4 	: char;
  var word	: univ word_in_bytes);

begin
  word[0] := ch1;
  word[1] := ch2;
  word[2] := ch3;
  word[3] := ch4;
end (* save_characters_in_word *);



(****************************  misc_utility  ****************************)
(*								      	*)
(*			  save_word_in_characters			*)
(*								      	*)
(*    Store the word in the 4 characters.				*)
(*							      		*)
(************************************************************************)

procedure entry SAVE_WORD_IN_CHARACTERS(
      word	: univ word_in_bytes;
  var ch1	: char;
  var ch2	: char;
  var ch3	: char;
  var ch4	: char);

begin
  ch1 := word[0];
  ch2 := word[1];
  ch3 := word[2];
  ch4 := word[3]
end (* save_word_in_characters *);




(****************************  misc_utility  ****************************)
(*								      	*)
(*			     quoted_text_size		    		*)
(*								      	*)
(*    Return the size of the quoted text.				*)
(*							      		*)
(************************************************************************)

function entry QUOTED_TEXT_SIZE(
      text : quoted_text) : integer;

var
  count : quoted_text_index;

begin
  count := 0;
  while text[count] <> END_MESSAGE_CHARACTER do
    count := count + 1;
  quoted_text_size := count
end (* quoted_text_size *);



(***************************  misc_utility  *****************************)
(*									*)
(*				negative				*)
(*									*)
(*	Return true if integer value is negative.			*)
(*									*)
(************************************************************************)

function negative(
      test_value	: univ integer) : boolean;

begin
  negative := test_value < 0
end (* negative *);



(***************************  misc_utility  *****************************)
(*									*)
(*			     negative_byte				*)
(*									*)
(*	Return true if byte is negative.				*)
(*									*)
(************************************************************************)

function entry NEGATIVE_BYTE(
      byte	: char) : boolean;

var
  test_word : word_in_bytes;

begin
  test_word[0] := byte;
  negative_byte := negative(test_word)
end (* negative_byte *);



(***************************  misc_utility  *****************************)
(*									*)
(*			     a_decimal_digit				*)
(*									*)
(************************************************************************)

function a_decimal_digit(
      c	: char) : boolean;

begin
  a_decimal_digit := (ASCII_ZERO <= c) and (c <= ASCII_NINE)
end (* a_decimal_digit *);



(***************************  misc_utility  *****************************)
(*									*)
(*			  an_alpha_numeric_character			*)
(*									*)
(************************************************************************)

function an_alpha_numeric_character(
      c	: char) : boolean;

begin
  an_alpha_numeric_character := a_decimal_digit(c) or
    ((c >= ascii_a) and (c <= ascii_z))
end (* an_alpha_numeric_character *);



(***************************  misc_utility  *****************************)
(*									*)
(*			     alpha_numeric				*)
(*									*)
(************************************************************************)

function entry ALPHA_NUMERIC(
      c	: char) : boolean;

begin
  alpha_numeric := an_alpha_numeric_character(c)
end (* alpha_numeric *);



(***************************  misc_utility  *****************************)
(*									*)
(*			 legal_username_character			*)
(*									*)
(************************************************************************)

function entry LEGAL_USERNAME_CHARACTER(
      c	: char) : boolean;

begin
$if BEFORE_SUP_V43
  legal_username_character := an_alpha_numeric_character(c) or
    (c in [ASCII_SPACE, '#', '$', '*', ASCII_AMPERSAND, ASCII_COMMA,
     ASCII_DOT, ASCII_MINUS, ASCII_SLASH])
$endif BEFORE_SUP_V43
$ifnot BEFORE_SUP_V43
  legal_username_character := an_alpha_numeric_character(c) or
    (c in ['#', '$', '*', ASCII_AMPERSAND, ASCII_COMMA,
     ASCII_DOT, ASCII_MINUS, ASCII_SLASH])
$endif BEFORE_SUP_V43
end (* legal_username_character *);


(***************************  misc_utility  *****************************)
(*									*)
(*			     decimal_digit				*)
(*									*)
(************************************************************************)

function entry DECIMAL_DIGIT(
      c	: char) : boolean;

begin
  decimal_digit := a_decimal_digit(c)
end (* decimal_digit *);



(****************************  misc_utility  ****************************)
(*									*)
(*				clear_block			       	*)
(*									*)
(************************************************************************)

procedure entry CLEAR_BLOCK(
$ifnone CONVERT_TO_43  var block_data : univ cud_data);
$if CONVERT_TO_43  var block_data : univ read_cud_data);

var
  count : cud_data_index;

begin
  for count := 0 to CUD_DATA_LIMIT do
    block_data[count] := ZERO
end (* clear_block *);


(****************************  misc_utility  ****************************)
(*									*)
(*				clear_page				*)
(*									*)
(************************************************************************)

procedure entry CLEAR_PAGE(
  var page_data : univ page);

var
  count : page_index;

begin
  for count := 0 to PAGE_LIMIT do
    page_data[count] := ZERO
end (* clear_page *);



(****************************  misc_utility  ****************************)
(*									*)
(*			    legal_consistency				*)
(*									*)
(*      Check to be sure a consistency can be done on the sup.		*)
(*									*)
(************************************************************************)

function entry LEGAL_CONSISTENCY(
      real_sup	: real_supervisor_index) : boolean;

begin (* legal_consistency *)
  legal_consistency := not (NETVAL_CUD_IS_A_MUD and
    ((real_sup + PRINT_SUPERVISOR_OFFSET) =
		   sys_io.sys_info.kernel_host_number))
end (* legal_consistency *);
	 


(**********************************************************************)
(**********************************************************************)

begin (* initial statement *)
  init sys_io
end (* misc_utility *);

!
(**********************************************************************)
(*                                                                    *)
(*	DELUTL.NTV						      *)
(*                       circuit_delay_utility                        *)
(*                                                                    *)
(*    This class handles circuit delay operations.		      *)
(*                                                                    *)
(**********************************************************************)
(*                                                                    *)
(*                           Revision Record                          *)
(*	14Feb86 - rsb						      *)
(*		  add a line of code to DELAY so delay_period will    *)
(*		  never exceed maximum_delay			      *)	
(*    21Jul84 Version 3.00 - jrn/pgl				      *)
(*	    - added the class parameters, first_retry and 	      *)
(*	      maximum_retry					      *)
(*	    - changed FIRST_CIRCUIT_RETRY_DELAY to first_retry	      *)
(*	      and MAXIMUM_CIRCUIT_RETRY_DELAY to maximum_retry	      *)
(*                                                                    *)
(*    29NOV83    Original - jrn				              *)
(*                                                                    *)
(**********************************************************************)


type CIRCUIT_DELAY_UTILITY = class(
	first_retry	: integer;
	maximum_retry	: integer);


var
  delay_period : integer;
!
(**********************  circuit_delay_utility  *************************)
(*									*)
(*			    initialize_delay				*)
(*									*)
(*      Reset delay_period.						*)
(*									*)
(************************************************************************)

procedure INITIALIZE_DELAY;

begin
  delay_period := first_retry
end (* initialize_delay *);



(**********************  circuit_delay_utility  *************************)
(*									*)
(*			      reset_delay				*)
(*									*)
(*      Reset delay_period.						*)
(*									*)
(************************************************************************)

procedure entry RESET_DELAY;

begin
  initialize_delay
end (* reset_delay *);



(**********************  circuit_delay_utility  *************************)
(*									*)
(*				 delay					*)
(*									*)
(*      Delay before attempting to build another circuit.		*)
(*									*)
(************************************************************************)

procedure entry DELAY;

var
  restart_time : integer;

begin (* delay *)
  restart_time := delay_period + REALTIME (* compute time to return *);
  while REALTIME < restart_time do (* perform actual delay *)
    wait;
  if delay_period < maximum_retry	(* if necessary... *)
  then delay_period := delay_period * 2 (* increment delay *);
  if delay_period > maximum_retry
  then delay_period := maximum_retry
end (* delay *);



(***********************  circuit_delay_utility  ***********************)
(***********************************************************************)

begin (* initial statement *)
  initialize_delay
end (* circuit_delay_utility *);
!
(************************************************************************)
(*									*)
(*	CRASH.NTV							*)
(*									*)
(*			    crash_utility				*)
(*									*)
(*	This class handles all calls to the crash pseudo-device.	*)
(*	It has separate entries corresponding to each crash operation.	*)
(*									*)
(*      The following identifiers must be defined externally:		*)
(*									*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	20Oct83	Original -- from (PATROL)crash.ntv - jrn		*)
(*									*)
(************************************************************************)


type CRASH_UTILITY = class
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if include_non_dmc




(***************************  crash_utility  ****************************)
(*									*)
(*			  signal_process_error				*)
(*									*)
(*	The crash_send operation. Crash the process making the call and *)
(*	signal any awaiting process that the crash occurred.		*)
(*									*)
(************************************************************************)

procedure entry SIGNAL_PROCESS_ERROR;

var
  param : crash_param;

begin
  wait;
  param.operation := CRASH_SIGNAL;
  io(param, param, CRASH, 0)
end (* signal_process_error *);
$endif include_non_dmc
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(***************************  crash_utility  ****************************)
(*									*)
(*				halt_slot				*)
(*									*)
(*	The crash_halt operation. Halt the slot.			*)
(*									*)
(************************************************************************)

procedure entry HALT_SLOT;

var
  param : crash_param;

begin
  param.operation := CRASH_HALT;
  io(param, param, CRASH, 0)
end (* halt_slot *);



(************************************************************************)
(************************************************************************)

begin (* initial statement *)
end (* crash_utility *);
!
(************************************************************************)
(*									*)
(*	CIPHER.NTV							*)
(*			 password_cipher_utility			*)
(*									*)
(*    This class handles the conversion of a password string to a	*)
(*    password cipher.							*)
(*									*)
(*     The following identifiers must be defined externally:		*)
(*	 password_string, password_text_index				*)
(*									*)
(************************************************************************)
(*									*)
(*			     Revision Record				*)
(*									*)
(*	04Mar85 - jrn							*)
(*	      - added function ciphered_name				*)
(*	27jul84 Version 3.00 - jrn/pgl					*)
(*	      - added function illegal_alpha_password			*)
(*	20jul83 original from (patrol)cipher.tms -- jrn			*)
(*									*)
(************************************************************************)



type password_cipher_utility = class(
	mutil	: misc_utility);



(************************  password_cipher_utility  *********************)
(*									*)
(*			   illegal_alpha_password			*)
(*									*)
(*      TRUE if password requires a non-alpha numeric, and there 	*)
(*	is none in the password.					*)
(*									*)
(************************************************************************)

function entry ILLEGAL_ALPHA_PASSWORD(
	password	: password_string) : boolean;

var
  index : password_text_index;
  done  : boolean;

begin
  illegal_alpha_password := FALSE;
  index := 0;
  done := FALSE;
  if REQUIRE_NONALPHANUMERIC
  then
    repeat
      if not mutil.alpha_numeric(password.text[index])
      then done := TRUE
      else
        if index < password.size - 1
	then index := index + 1
	else
	  begin
	    done := TRUE;
	    illegal_alpha_password := TRUE
	  end
    until done
end (* ILLEGAL_ALPHA_PASSWORD *);



(*********************  password_cipher_utility  ************************)
(*									*)
(*			    password_cipher 				*)
(*									*)
(*	Convert a password string into a cipher.			*)
(*									*)
(************************************************************************)

function password_cipher(
      password	: password_string) : integer;

var
  cipher: integer;
  j: password_text_index;
  i: integer;
  x: integer;

begin
  cipher := 0;
  x := 0;
  for j := 0 to password.size-1 do
    for i := 1 to 7 do
      begin
	cipher := cipher + x + ord(password.text[j]);
	x := x + cipher;
	if mutil.test_bit(BIT25, x)
	then x := x + ord(password.text[j]);
	x := mutil.left_shift(BIT28, x) + mutil.right_shift(BIT2, x)
      end (* for *);
  password_cipher := mutil.exclusive_or(cipher, x)
end (* password_cipher *);



(*********************  password_cipher_utility  ************************)
(*									*)
(*				convert 				*)
(*									*)
(*	Convert a password string into a cipher.			*)
(*									*)
(************************************************************************)

function entry CONVERT(
      password	: password_string) : integer;

begin
  convert := password_cipher(password)
end (* CONVERT *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone name_legal_password


(*********************  password_cipher_utility  ************************)
(*									*)
(*			     ciphered_name 				*)
(*									*)
(*	Convert a username string into a cipher; used to check to see	*)
(*	if username = password, if name_legal_password is not enabled.	*)
(*									*)
(************************************************************************)

function entry CIPHERED_NAME(
      name	: username_string) : integer;

var
  index : username_text_index;
  password : password_string;

begin
  for index := 0 to name.size - 1 do
    password.text[index] := name.text[index];
  password.size := name.size;
  ciphered_name := password_cipher(password)
end (* ciphered_name *);
$endif name_legal_password
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(*********************  password_cipher_utility  ************************)
(************************************************************************)

begin
end (* password_cipher_utility *);
!
(**********************************************************************)
(*								      *)
(*	FIFO.NTV						      *)
(*                                                                    *)
(*                                Fifo                                *)
(*                                                                    *)
(*    This is a first-in-first-out index manager.		      *)
(*                                                                    *)
(**********************************************************************)
(*                                                                    *)
(*                          Revision Record                           *)
(*                                                                    *)
(*    29SEP83   Original -- from ((Osiris)fifoz.cmn)                  *)
(*                                                                    *)
(**********************************************************************)



type FIFO = class(
	origin	: integer;
	limit	: integer);


var
  head : integer;
  tail : integer;
  length : integer;



(*******************************  Fifo  *******************************)
(*                                                                    *)
(*                              Arrival                               *)
(*                                                                    *)
(**********************************************************************)

function entry ARRIVAL : integer;

begin
  arrival := tail;
  if tail = limit
  then tail := origin
  else tail := tail + 1;
  length := length + 1
end (* arrival *);



(*******************************  Fifo  *******************************)
(*                                                                    *)
(*                             Departure                              *)
(*                                                                    *)
(**********************************************************************)

function entry DEPARTURE : integer;

begin
  departure := head;
  if head = limit
  then head := origin
  else head := head + 1;
  length := length - 1
end (* departure *);



(*******************************  Fifo  *******************************)
(*                                                                    *)
(*                               Empty                                *)
(*                                                                    *)
(**********************************************************************)

function entry EMPTY : Boolean;

begin
  empty := length = origin
end (* empty *);



(*******************************  Fifo  *******************************)
(*                                                                    *)
(*                                Full                                *)
(*                                                                    *)
(**********************************************************************)

function entry FULL : Boolean;

begin
  full := length < limit
end (* full *);



(*******************************  Fifo  *******************************)
(**********************************************************************)

begin (* initial statement *)
  head := origin;
  tail := origin;
  length := origin
end (* fifo *);
!
(**********************************************************************)
(*                                                                    *)
(*	DATE.NTV						      *)
(*                                                                    *)
(*                         date_time_converter                        *)
(*                                                                    *)
(*    This class handles all ISIS time calculations.		      *)
(*                                                                    *)
(**********************************************************************)
(*                                                                    *)
(*                           Revision Record                          *)
(*                                                                    *)
(*      27Apr88 - neh                                                 *)
(*            - remove EXPIREDATE                                     *)
(*	12Aug87 - neh						      *)
(*	      - remove convert to CUBS procedures, TYMSHARE_CUD_FORMAT*)
(*	      - make do_cubs_to_isis_days and cubs_to_isis_days       *)
(*		conditional on the flag SPECIAL			      *)
(*	09Mar87	- neh - 5.00					      *)
(*	      - add CUBS_TO_ISIS_DAYS				      *)
(*			merge 4.00 and 5.00 - neh		      *)
(*	07Jan87 - rsb					      	      *)
(*		- add function entry EXPIREDATE for use by CMDUTL     *)
(*		  procedure do_display_select.			      *)
(*		- also add do_expiredate			      *)
(*	05Aug86 - jrn						      *)
(*	      - add COMPUTE_YEAR for NVDM MESSGAES FROM command	      *)
(*	10Mar86 - jrn						      *)
(*	      - redo REUSE_UUNS to maintain a bit map for 18 bit UUNS *)
(*		and change the add back scheme to be a dated list     *)
(*		(add function ISIS_TIME)			      *)
(*	09May85 - add Tymshare format date conversions - jrn	      *)
(*	29SEP83  original from (patrol)date.tms - jrn		      *)
(*                                                                    *)
(**********************************************************************)


type
  PRINT_TIME = record
    year,	 (* 19xx *)
    month,
    day,
    hour,
    minute,
    second : integer
  end (* PRINT_TIME *);



type DATE_TIME_CONVERTER = class;


const
  leap_year_seconds = 31622400 (* seconds in leap year *);
  non_leap_year_seconds = 31536000 (* seconds in non leap year *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if special

(* 940 constant to convert secs since 2/29/72 00:00 to cubs to store in CUD *)

  BASE_CUB_SECONDS_VALUE = 250000;
  HIGH_ORDER_BASE_CUB_SECONDS_VALUE = 61 (* high order halfword *);
  LOW_ORDER_BASE_CUB_SECONDS_VALUE = 144 (* low order halfword *);

(* 940 constant to convert cubs from CUD to the number of days since 2/29/72 *)
  BASE_CUB_DAYS_VALUE = 3258;

(* number of days between 2/29/72 00:00 and 1/1/74 00:00 *)
  ENGINE_940_DAYS_BIAS = 307 + 365;

(* number of seconds between 2/29/72 00:00 and 1/1/74 00:00 *)
  ENGINE_940_SECONDS_BIAS = ENGINE_940_DAYS_BIAS * SECONDS_PER_DAY;	
$endif special
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
var
  mutil	: misc_utility;



(************************  date_time_converter  ***********************)
(*                                                                    *)
(*                          leap_year_test                            *)
(*                                                                    *)
(*    Return true if year is a leap year.                             *)
(*                                                                    *)
(**********************************************************************)

function leap_year_test(
      year	: integer) : boolean;

begin
  leap_year_test := ((year mod 40) <> 0) and ((year mod 4) = 0)
end (* leap_year_test *);



(***********************  date_time_converter  ************************)
(*                                                                    *)
(*                         do_days_to_month                           *)
(*                                                                    *)
(*    Return the number of days before the first day of the given     *)
(*    month. LY is true if calculation is for a leap year.            *)
(*                                                                    *)
(**********************************************************************)

function do_days_to_month(
      month	: integer;
      ly	: boolean) : integer;

var
  value : integer;

begin
  case month of
    1: value := 0   (* january 0 *);
    2: value := 31  (* february 0 + 31 *);
    3: value := 59  (* march 31 + 28 *);
    4: value := 90  (* april 59 + 31 *);
    5: value := 120 (* may 90 + 30 *);
    6: value := 151 (* june 120 + 31 *);
    7: value := 181 (* july 151 + 30 *);
    8: value := 212 (* august 181 + 31 *);
    9: value := 243 (* september 212 + 31 *);
   10: value := 273 (* october 243 + 30 *);
   11: value := 304 (* november 273 + 31 *);
   12: value := 334 (* december 304 + 30 *)
  end (* case *);
  if ly and (month > 2)
  then do_days_to_month := value + 1
  else do_days_to_month := value
end (* do_days_to_month *);



(***********************  date_time_converter  ************************)
(*                                                                    *)
(*                           days_to_month                            *)
(*                                                                    *)
(*    Return the number of days before the first day of the given     *)
(*    month. LY is true if calculation is for a leap year.            *)
(*                                                                    *)
(**********************************************************************)

function entry DAYS_TO_MONTH(
      month	: integer;
      ly	: boolean) : integer;

begin
  days_to_month := do_days_to_month(month, ly)
end (* days_to_month *);



(***********************  date_time_converter  ************************)
(*                                                                    *)
(*                         do_days_to_year                            *)
(*                                                                    *)
(*    Return the number of days before the first day of the given     *)
(*    year from 1/1/74.		                                      *)
(*                                                                    *)
(**********************************************************************)

function do_days_to_year(
      year	: integer) : integer;

var
  next_year : integer;
  days : integer;

begin
  next_year := BASE_YEAR;
  days := 0;
  while next_year < year do
    begin
      if leap_year_test(next_year)
      then days := days + 366
      else days := days + 365;
      next_year := next_year + 1
    end (* while *);
  do_days_to_year := days
end (* do_days_to_year *);



(***********************  date_time_converter  ************************)
(*                                                                    *)
(*                            days_to_year                            *)
(*                                                                    *)
(*    Return the number of days before the first day of the given     *)
(*    year from 1/1/74.		                                      *)
(*                                                                    *)
(**********************************************************************)

function entry DAYS_TO_YEAR(
      year	: integer) : integer;

begin
  days_to_year := do_days_to_year(year)
end (* days_to_year *);



(**********************  date_time_converter  *************************)
(*                                                                    *)
(*                      compute_days_in_month                         *)
(*                                                                    *)
(*    Return the number of days in specified month.                   *)
(*                                                                    *)
(**********************************************************************)

function compute_days_in_month(
      month	: integer;
      ly	: boolean) : integer;

begin
  case month of
    1,3,5,7,8,10,12: compute_days_in_month := 31;
    4,6,9,11:        compute_days_in_month := 30;
    2: if ly
       then compute_days_in_month := 29
       else compute_days_in_month := 28
  end (* case *)
end (* compute_days_in_month *);



(**********************  date_time_converter  *************************)
(*                                                                    *)
(*                          days_in_month                             *)
(*                                                                    *)
(*    Return the number of days in specified month.                   *)
(*                                                                    *)
(**********************************************************************)

function entry DAYS_IN_MONTH(
      month	: integer;
      ly	: boolean): integer;

begin
  days_in_month := compute_days_in_month(month, ly)
end (* days_in_month *);



(************************  date_time_converter  ***********************)
(*                                                                    *)
(*                             leap_year                              *)
(*                                                                    *)
(*    Return true if year is a leap year.                             *)
(*                                                                    *)
(**********************************************************************)

function entry LEAP_YEAR(
      year	: integer) : boolean;

begin
  leap_year := leap_year_test(year)
end (* leap_year *);



(**********************  date_time_converter  *************************)
(*                                                                    *)
(*                         do_compute_year                            *)
(*                                                                    *)
(*    Convert an ISIS time (i.e., since 1/1/74) in seconds to         *)
(*    seconds since the beginnning of the year. Also return           *)
(*    the year.                                                       *)
(*                                                                    *)
(**********************************************************************)

procedure do_compute_year(
  var new_time	: integer;
  var year	: integer);

var
  year_seconds: integer;

begin
  year := BASE_YEAR;
  year_seconds := non_leap_year_seconds;
  while new_time >= year_seconds do
    begin
      new_time := new_time - year_seconds;
      year := year + 1;
      if leap_year_test(year)
      then year_seconds := leap_year_seconds
      else year_seconds := non_leap_year_seconds
    end (* while *)
end (* do_compute_year *);



(**********************  date_time_converter  *************************)
(*                                                                    *)
(*                            compute_year                            *)
(*                                                                    *)
(*    Convert an ISIS time (i.e., since 1/1/74) in seconds to         *)
(*    seconds since the beginnning of the year. Also return           *)
(*    the year.                                                       *)
(*                                                                    *)
(**********************************************************************)

procedure entry COMPUTE_YEAR(
  var new_time	: integer;
  var year	: integer);

begin
  do_compute_year(new_time, year)
end (* compute_year *);



(************************  date_time_converter  *************************)
(*									*)
(*			  do_date_from_isis_time			*)
(*									*)
(*    Given an ISIS time, return the time for printing. 		*)
(*									*)
(************************************************************************)

procedure do_date_from_isis_time(
      isis_time	: integer;
  var date_time	: print_time);

var
  ly : boolean (* TRUE if leap year *);

begin
  with date_time do
    begin
      second := isis_time;
      do_compute_year(second, year)
    end (* with *);
  with date_time do
    begin
      minute := second div 60;
      second := second mod 60;

      hour := minute div 60;
      minute := minute mod 60;

      day := (hour div 24)+1;
      hour := hour mod 24;

      ly := leap_year_test(year);
      month := 1;
      while day > compute_days_in_month(month, ly) do
	begin
	  day := day - compute_days_in_month(month, ly);
	  month := month+1
	end (* while *)
    end (* with *)
end (* do_date_from_isis_time *);



(************************  date_time_converter  *************************)
(*									*)
(*			   date_from_isis_time				*)
(*									*)
(*    Given an ISIS time, return the time for printing. 		*)
(*									*)
(************************************************************************)

procedure entry DATE_FROM_ISIS_TIME(
      isis_time	: integer;
  var date_time	: print_time);

begin
  do_date_from_isis_time(isis_time, date_time)
end (* date_from_isis_time *);



(************************  date_time_converter  *************************)
(*									*)
(*			    do_seconds_in_time				*)
(*									*)
(************************************************************************)

function do_seconds_in_time(
      hour	: integer;
      minute	: integer;
      second	: integer) : integer;

begin
  do_seconds_in_time := (hour * 60 + minute) * 60 + second
end (* do_seconds_in_time *);



(************************  date_time_converter  *************************)
(*									*)
(*			     seconds_in_time				*)
(*									*)
(************************************************************************)

function entry SECONDS_IN_TIME(
      hour	: integer;
      minute	: integer;
      second	: integer) : integer;

begin
  seconds_in_time := do_seconds_in_time(hour, minute, second)
end (* seconds_in_date *);



(************************  date_time_converter  *************************)
(*									*)
(*			    do_seconds_in_date				*)
(*									*)
(************************************************************************)

function do_seconds_in_date(
      month	: integer;
      day	: integer;
      year	: integer;
      leap	: boolean) : integer;

begin
  do_seconds_in_date := (do_days_to_year(year) +
    do_days_to_month(month, leap) + day - 1) * SECONDS_PER_DAY
end (* do_seconds_in_date *);



(************************  date_time_converter  *************************)
(*									*)
(*			     seconds_in_date				*)
(*									*)
(************************************************************************)

function entry SECONDS_IN_DATE(
      month	: integer;
      day	: integer;
      year	: integer;
      leap	: boolean) : integer;

begin
  seconds_in_date := do_seconds_in_date(month, day, year, leap)
end (* seconds_in_date *);



(************************  date_time_converter  *************************)
(*									*)
(*				ISIS_TIME				*)
(*									*)
(*    Given a time, return the ISIS time.		 		*)
(*									*)
(************************************************************************)

function entry ISIS_TIME(
      date_time	: print_time) : integer;

begin
  with date_time do
    isis_time := do_seconds_in_date(month, day, year, leap_year_test(year)) +
      do_seconds_in_time(hour, minute, second)
end (* isis_time *);
$if special



(************************  date_time_converter  *************************)
(*									*)
(*			  do_cubs_to_isis_days				*)
(*									*)
(*      Convert the time in cubs (940 format) to the number of days	*)
(*	since 1/1/74.							*)
(*									*)
(************************************************************************)

procedure do_cubs_to_isis_days(
      cubs	: integer;
  var isis_days	: integer);


begin
  isis_days := (((cubs div 65536) * BASE_CUB_DAYS_VALUE div 128) +
    ((cubs mod 65536) * BASE_CUB_DAYS_VALUE div 8388608)) -
    ENGINE_940_DAYS_BIAS;
end (* do_cubs_to_isis_days *);
"remove CUBS


(************************  date_time_converter  *************************)
(*									*)
(*			      isis_to_cubs				*)
(*									*)
(*      Convert the current time to cubs (940 format), i.e., get number	*)
(*	of seconds since 1/1/74 00:00, add the number of seconds between*)
(*	base year for cubs (2/29/72 00:00), multiply by 250000, and	*)
(*	shift 23 bits.							*)
(*									*)
(************************************************************************)

function entry ISIS_TO_CUBS(
      isis_time	: integer) : integer;

var
  result : array [ 1..4 ] of integer;
  split : array [ 1..2 ] of integer;
  sum,
  i,
  x:integer;

begin
  x := isis_time + ENGINE_940_SECONDS_BIAS;
  split[1] := x div 65536 (* high order halfword of time *);
  split[2] := x mod 65536 (* low order halfword of time *);
  result[1] := HIGH_ORDER_BASE_CUB_SECONDS_VALUE * split[1] * 32;
  result[2] := HIGH_ORDER_BASE_CUB_SECONDS_VALUE * split[2] div 2048;
  result[3] := LOW_ORDER_BASE_CUB_SECONDS_VALUE * split[1] div 128;
  result[4] := LOW_ORDER_BASE_CUB_SECONDS_VALUE * split[2] div 8388608;
  sum := 0;
  for i := 1 to 4 do
    sum := sum + result[i];
  isis_to_cubs := sum
end (* isis_to_cubs *);
$endif special
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+	*)
"


(************************  date_time_converter  *************************)
(*									*)
(*			    do_password_date				*)
(*									*)
(************************************************************************)

function do_password_date(
      password_change_date : integer) : integer;

begin
  do_password_date := password_change_date * SECONDS_PER_DAY
end (* do_password_date *);



(************************  date_time_converter  *************************)
(*									*)
(*			  password_date					*)
(*									*)
(************************************************************************)

function entry PASSWORD_DATE(
      password_change_date : integer) : integer;

var
  temp_date : integer;

begin
  password_date := do_password_date(password_change_date)
end (* password_date *);
"
"
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if force_password_change



(************************  date_time_converter  *************************)
(*									*)
(*			    do_expiredate				*)
(*									*)
(************************************************************************)

function do_expiredate(
      expiredate : integer) : integer;

begin
  do_expiredate := expiredate * SECONDS_PER_DAY
end (* do_expiredate *);


(************************  date_time_converter  *************************)
(*									*)
(*			  expire_date					*)
(*									*)
(************************************************************************)


function entry expire_date(
      password_expiredate : integer) : integer;

var
  temp_date : integer;

begin (* expire_date *)
  expire_date := do_expiredate(password_expiredate)
end (* expire_date *);
$endif force_password_change
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
"



(************************  date_time_converter  *************************)
(*									*)
(*			    word_time					*)
(*									*)
(*      Convert time to word with month (mm), day (dd) and year (yy)	*)
(*									*)
(************************************************************************)

function entry WORD_TIME(
      time	: integer) : integer;

var
  date_time : print_time;

begin
  do_date_from_isis_time(time, date_time);
  with mutil, date_time do
    word_time := left_shift(BIT15, month) + left_shift(BIT23, day) +
      (year mod 100)
end (* word_time *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if special


(************************  date_time_converter  *************************)
(*									*)
(*			    cubs_to_isis_days				*)
(*									*)
(*      Convert CUBs to ISIS time format.				*)
(*									*)
(************************************************************************)

procedure entry CUBS_TO_ISIS_DAYS(
      cubs	: integer;
  var isis_days : integer);

begin
  do_cubs_to_isis_days(cubs, isis_days)
end (* cubs_to_isis_days *);
$endif special
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(***********************  date_time_converter  ************************)
(**********************************************************************)


begin (* initial statement *)
  init mutil
end (* date_time_converter *);
!
(************************************************************************)
(*									*)
(*	CIRCIO.NTV							*)
(*			    circuit_handler				*)
(*									*)
(*	This class handles all direct calls to io for access to the	*)
(*	terminal or aux_circuit.					*)
(*									*)
(*	Procedures are organized as follows:				*)
(*	General initializing routines:					*)
(*		initialize_circuit, reset_circuit, zap_circuit,		*)
(*		status_check, LOGIN, BUILD_NORMAL_CIRCUIT,		*)
(*		BUILD_AUX_CIRCUIT, USE_CIRCUIT				*)
(*	Output routines: SEND,						*)
(*		SEND_QUOTED_TEXT, SEND_NEWLINE, WRITE_QUOTED_TEXT,	*)
(*		WRITE_QUOTED_TEXT_LINE, WRITE_LINE_AND_QUOTED_TEXT,	*)
(*		WRITE_LINE_AND_QUOTED_TEXT_LINE, WRITE_NEWLINE,		*)
(*		WRITE_FORMAT_BUFFER, WRITE_COMMAND_PROMPT,		*)
(*		WRITE_LOG_MESSAGE, WRITE_ONE_CHARACTER, 		*)
(*		WRITE_TWO_CHARACTERS, WRITE_THREE_CHARACTERS,		*)
(*		WRITE_WORD, WRITE_MUD_DATA, WRITE_CLASS_GROUP_TABLE,	*)
(*	Input routines: RECEIVE_LINE, RECEIVE_CHARACTERS,		*)
(*		READ_COMMAND_LINE, READ_LINE_DESCRIPTION,		*)
(*		READ_PASSWORD_STRING, READ_ONE_CHARACTER,		*)
(*		READ_TWO_CHARACTERS, READ_THREE_CHARACTERS, READ_WORD,	*)
(*		READ_PAGE, READ_MUD_DATA, READ_CLASS_GROUP_TABLE,	*)
(*	Checking and setting status routines:				*)
(*		WAIT_FOR_INPUT, WAIT_FOR_OUTPUT, CLEAR_CIRCUIT,		*)
(*		SET_ECHO, CLEAR_EDIT_CHARACTERS, SET_ALTERNATE_BREAK,	*)
(*		CHECK_CIRCUIT, CLEAR_BREAK_STATUS, SET_TIMEOUT		*)
(*                                                                      *)
(************************************************************************)
(*                                                                      *)
(*			     Revision Record				*)
(*									*)
(*	22Dec88 - neh							*)
(*		- correct range error in READ_LIST_DESCRIPTION		*)
(*		  when break_key has been hit				*)
(*	12Sep88 - jrn							*)
(*		- eliminate READ_PASSWORD_STRING			*)
(*	10Nov87 - neh							*)
(*	      - add READ_DNIC_TABLE and WRITE_DNIC_TABLE		*)
(*	15Jan87 - neh							*)
(*	      - change write_mud_data to use mud_data if		*)
(*	        BEFORE_SUP_V43 is disabled				*)
(*	      - change read_mud_data to use mud_disk_block		*)
(*	08Aug86 - jrn							*)
(*	      - add read_remark routine					*)
(*	31Jul86 - jrn							*)
(*	      - make WRITE_LOG_MESSAGE routine available to NVDM	*)
(*	03Feb86 - jrn							*)
(*	      - add general procedcures SEND, RECEIVE_LINE and		*)
(*		RECEIVE_CHARACTERS					*)
(*	27Jan86 - jrn							*)
(*	      - move write_command_prompt procedure to			*)
(*		internal_to_sting					*)
(*	01Nov85 - jrn							*)
(*	      - add send_errlog_message procedure			*)
(*	20Jul84 Version 3.0 - jrn/pgl					*)
(*	      - added procedures write_word, read_two_characters,	*)
(*		read_word						*)
(*	14Nov84 Version 2.02 - jrn					*)
(*	      - add read_list_description				*)
(*	14Mar84	Version 2.01 - jrn					*)
(*	      - fix range error bug in use_circuit			*)
(*	      - on all routines that repeatedly call a routine to read	*)
(*		or write a page, check for error conditions before	*)
(*		going thru the loop again				*)
(*	29SEP83	Original from CIRC.BAS -- jrn				*)
(*									*)
(************************************************************************)


type
  logout_cause = (GENERAL_LOGOUT, TIMEDOUT_LOGOUT, LOST_CIRCUIT_LOGOUT);


type CIRCUIT_HANDLER = class(
	mutil	: misc_utility);

var
  device : circuit_device (* type of device, TERMINAL/AUX_CIRCUIT *);
  accept_status : ioresult_set (* acceptable results; otherwise, zap cir. *);

  entry current_timeout	: integer (* current read timeout *);
  entry unit		: integer (* specific circuit device being used *);
  entry param		: circuit_param (* parameter block of last io call *);
  entry available	: boolean (* whether or not a circuit is built *);
  entry break_pending	: boolean (* whether or not break was hit *);
  entry sendable	: boolean (* whether available & not break_pending *);
  entry logout_reason	: logout_cause;
!
(*************************  circuit_handler  ****************************)
(*									*)
(*			   initialize_circuit				*)
(*									*)
(*	Set initial parameters for a just built circuit.		*)
(*									*)
(************************************************************************)

procedure initialize_circuit;

begin
  logout_reason := GENERAL_LOGOUT;
  available := TRUE;
  sendable := TRUE;
  break_pending := FALSE;
  current_timeout := 0
end (* initialize_circuit *);



(*************************  circuit_handler  ****************************)
(*									*)
(*			     reset_circuit				*)
(*									*)
(*	Reset parameters for a just freeed circuit.			*)
(*									*)
(************************************************************************)

procedure reset_circuit;

begin
  available := FALSE;
  sendable := FALSE;
  break_pending := FALSE
end (* reset_circuit *);



(*************************  circuit_handler  ****************************)
(*									*)
(*			      zap_circuit				*)
(*									*)
(*	Zap circuit and set as not available.				*)
(*									*)
(************************************************************************)

procedure zap_circuit;

var
  dummy : char;
  param : circuit_param;

begin
  param.operation := CIRCUIT_DISCONNECT;
  io(dummy, param, device, unit);
  reset_circuit
end (* zap_circuit *);



(*************************  circuit_handler  ****************************)
(*									*)
(*			      status_check				*)
(*									*)
(*	Check if status one of acceptable status. If not, zap circuit.	*)
(*									*)
(************************************************************************)

procedure status_check;

begin
  if param.status in accept_status
  then
    begin
      if param.status = BREAK_KEY
      then
	begin
	  break_pending := TRUE;
	  sendable := FALSE
	end (* param.status = BREAK_KEY *)
    end (* param.status in accept_status *)
  else
    begin (* unacceptable status received, zap this circuit *)
      if param.status = TIME_OUT
      then logout_reason := TIMEDOUT_LOGOUT
      else
        if param.status = FAILURE
	then logout_reason := LOST_CIRCUIT_LOGOUT;
      zap_circuit
    end
end (* status_check *);
!
(*************************  circuit_handler  ****************************)
(*									*)
(*				 login					*)
(*									*)
(*	Accept a login. 						*)
(*									*)
(************************************************************************)

procedure entry LOGIN(
      new_unit		: terminal_unit_index;
      new_accept_status	: ioresult_set;
  var login_info	: needle_record);

begin
  unit := new_unit;
  device := TERMINAL;
  accept_status := new_accept_status;
  repeat
    param.operation := CIRCUIT_GET_NEEDLE;
    param.arg1 := 0 (* no subhosts *);
    param.arg2 := 0 (* no time out waiting for needle *);
    io(login_info, param, device, unit)
  until param.status = COMPLETE;
  initialize_circuit
end (* login *);
"


(*************************  circuit_handler  ****************************)
(*									*)
(*			 build_normal_circuit 				*)
(*									*)
(*	Build a normal circuit.						*)
(*									*)
(************************************************************************)

procedure entry BUILD_NORMAL_CIRCUIT(
      new_unit			: aux_circuit_unit_index;
      new_accept_status		: ioresult_set;
      build_login_string	: login_string;
      build_timeout		: integer);

(*	The login string text is copied since 'io' requires that its	*)
(*	data buffer be writeable incase this is a write call.		*)

var
  io_login_text : login_text;

begin
  unit := new_unit;
  device := AUX_CIRCUIT;
  accept_status := new_accept_status;
  io_login_text := build_login_string.text;
  param.arg1 := build_login_string.size;
  param.arg2 := build_timeout;
  param.operation := CIRCUIT_NORMAL_REQUEST;
  io(io_login_text, param, device, unit);
  if param.status = COMPLETE
  then initialize_circuit
end (* build_normal_circuit *);
"


(*************************  circuit_handler  ****************************)
(*									*)
(*			   build_aux_circuit 				*)
(*									*)
(*	Build an auxiliary circuit.					*)
(*									*)
(************************************************************************)

procedure entry BUILD_AUX_CIRCUIT(
      new_unit			: aux_circuit_unit_index;
      new_accept_status		: ioresult_set;
      build_timeout		: integer;
  var build_login_string	: login_string);

begin
  unit := new_unit;
  device := AUX_CIRCUIT;
  accept_status := new_accept_status;
  param.arg1 := build_login_string.size;
  param.arg2 := build_timeout;
  param.operation := CIRCUIT_AUX_REQUEST;
  io(build_login_string.text, param, device, unit);
  if param.status = COMPLETE
  then initialize_circuit
end (* build_aux_circuit *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code



(*************************  circuit_handler  ****************************)
(*									*)
(*			      use_circuit 				*)
(*									*)
(*	Use an already built circuit.					*)
(*									*)
(************************************************************************)

procedure entry USE_CIRCUIT(
      new_unit		: univ integer;
      new_device	: circuit_device;
      new_accept_status	: ioresult_set);

begin
  unit := new_unit;
  device := new_device;
  accept_status := new_accept_status;
  initialize_circuit
end (* use_circuit *);
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!



(*************************  circuit_handler  ****************************)
(*									*)
(*				send					*)
(*									*)
(*	Write to the circuit.						*)
(*									*)
(************************************************************************)

procedure send(
      length		: integer;
  var first_char	: char);

begin
  repeat
    param.operation := CIRCUIT_SEND;
    param.arg1 := length;
    param.arg2 := 0 (* no timeout on write *);
    io(first_char, param, device, unit)
  until param.status <> DEVICE_BUSY;
  status_check
end (* send *);



(*************************  circuit_handler  ****************************)
(*									*)
(*			   send_quoted_text				*)
(*									*)
(*	Write a string to the terminal. A string is a message without	*)
(*	a newline. The string text is terminated with an		*)
(*	end_message_character.						*)
(*									*)
(************************************************************************)

procedure send_quoted_text(
      string	: quoted_text);

var
  io_string : quoted_text;

begin
  io_string := string;
  send(mutil.quoted_text_size(string), io_string[0])
end (* send_quoted_text *);



(*************************  circuit_handler  ****************************)
(*									*)
(*			     send_newline				*)
(*									*)
(*	Write a newline to the circuit device.				*)
(*									*)
(************************************************************************)

procedure send_newline;

var
  newline : array [ 0..1 ] of char;

begin
  newline[0] := ASCII_CARRIAGE_RETURN;
  newline[1] := ASCII_LINE_FEED;
  send(2, newline[0])
end (* send_newline *);



(*************************  circuit_handler  ****************************)
(*									*)
(*			   write_quoted_text				*)
(*									*)
(*	Write a string to the terminal. A string is a message without	*)
(*	a newline. The string text is terminated with an		*)
(*	end_message_character.						*)
(*									*)
(************************************************************************)

procedure entry WRITE_QUOTED_TEXT(
      string	: quoted_text);

begin
  send_quoted_text(string)
end (* write_quoted_text *);



(*************************  circuit_handler  ****************************)
(*									*)
(*			write_quoted_text_line				*)
(*									*)
(*	Write a message to the terminal. A message is a string		*)
(*	terminated with the end message character. Follow message	*)
(*	with a newline. 						*)
(*									*)
(************************************************************************)

procedure entry WRITE_QUOTED_TEXT_LINE(
      message	: quoted_text);

begin
  send_quoted_text(message);
  if sendable
  then send_newline
end (* write_quoted_text_line *);



(*************************  circuit_handler  ****************************)
(*									*)
(*		      write_line_and_quoted_text			*)
(*									*)
(*	Write a newline and a string to the terminal. A string is a	*)
(*	message without a newline following. The string text is		*)
(*	terminated with an end_message_character.			*)
(*									*)
(************************************************************************)

procedure entry WRITE_LINE_AND_QUOTED_TEXT(
      string	: quoted_text);

begin
  send_newline;
  if sendable
  then send_quoted_text(string)
end (* write_line_and_quoted_text *);



(*************************  circuit_handler  ****************************)
(*									*)
(*		     write_line_and_quoted_text_line			*)
(*									*)
(*	Write a newline and a message to the terminal. A message is a	*)
(*	string terminated with the end message character. Follow	*)
(*	message with a newline.						*)
(*									*)
(************************************************************************)

procedure entry WRITE_LINE_AND_QUOTED_TEXT_LINE(
      message	: quoted_text);

begin
  send_newline;
  if sendable
  then send_quoted_text(message);
  if sendable
  then send_newline
end (* write_line_and_quoted_text_line *);



(*************************  circuit_handler  ****************************)
(*									*)
(*			     write_newline				*)
(*									*)
(*	Write carriage return and linefeed to terminal. 		*)
(*									*)
(************************************************************************)

procedure entry WRITE_NEWLINE;

begin
  send_newline
end (* write_newline *);



(*************************  circuit_handler  ****************************)
(*									*)
(*			  write_format_buffer				*)
(*									*)
(*	Write a format_buffer to terminal.				*)
(*									*)
(************************************************************************)

procedure entry WRITE_FORMAT_BUFFER(
      data	: format_buffer);

var
  io_data : format_buffer;

begin
  io_data := data;
  send(io_data.size, io_data.text[0])
end (* write_format_buffer *);



(*************************  circuit_handler  ****************************)
(*									*)
(*			  write_one_character				*)
(*									*)
(*	Write a single character to the circuit.			*)
(*									*)
(************************************************************************)

procedure entry WRITE_ONE_CHARACTER(
      byte	: char);

var
  io_byte : char;

begin
  io_byte := byte;
  send(1, io_byte)
end (* write_one_character *);



(*************************  circuit_handler  ****************************)
(*									*)
(*			  write_two_characters				*)
(*									*)
(*	Write the right half of the word to the circuit.		*)
(*									*)
(************************************************************************)

procedure entry WRITE_TWO_CHARACTERS(
      word	: univ word_in_bytes);

var
  io_word : word_in_bytes;

begin
  io_word[0] := word[2];
  io_word[1] := word[3];
  send(2, io_word[0])
end (* write_two_characters *);



(*************************  circuit_handler  ****************************)
(*									*)
(*			 write_three_characters				*)
(*									*)
(*	Write the three rightmost characters to the circuit.		*)
(*									*)
(************************************************************************)

procedure entry WRITE_THREE_CHARACTERS(
      characters	: univ word_in_bytes);

var
  io_word : word_in_bytes;

begin
  io_word[0] := characters[1];
  io_word[1] := characters[2];
  io_word[2] := characters[3];
  send(3, io_word[0])
end (* write_three_characters *);



(*************************  circuit_handler  ****************************)
(*									*)
(*				write_word				*)
(*									*)
(*      Output 4 bytes							*)
(*									*)
(************************************************************************)

procedure entry WRITE_WORD(
      word	: univ word_in_bytes);

var
  io_word : word_in_bytes;

begin
  io_word := word;
  send(MAXIMUM_BYTES_IN_WORD, io_word[0])
end (* write_word *);


  
(*************************  circuit_handler  ****************************)
(*									*)
(*			     write_mud_data				*)
(*									*)
(*	Write bytes_to_write from the MUD block to the circuit.		*)
(*									*)
(************************************************************************)

procedure entry WRITE_MUD_DATA(
$if BEFORE_SUP_V43
      bytes_to_write	: cud_data_size;
  var data		: cud_data);
$endif BEFORE_SUP_V43
$ifnone BEFORE_SUP_V43
      bytes_to_write	: mud_data_size;
  var data		: mud_data);
$endif BEFORE_SUP_V43

begin
  send(bytes_to_write, data[0])
end (* write_mud_data *);



(*************************  circuit_handler  ****************************)
(*									*)
(*			  write_log_message				*)
(*									*)
(*	Write a log_message to terminal.				*)
(*									*)
(************************************************************************)

procedure entry WRITE_LOG_MESSAGE(
  var data	: log_message);

begin
  send(data.size, data.text[0])
end (* write_log_message *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code



(*************************  circuit_handler  ****************************)
(*									*)
(*		 	write_class_group_table				*)
(*									*)
(*	Write class/group table to the circuit by pages.		*)
(*									*)
(************************************************************************)

procedure entry WRITE_CLASS_GROUP_TABLE(
  var data	: univ table_in_bytes);

begin
  send(TABLE_LENGTH, data[0])
end (* write_class_group_table *);
$if INCLUDE_DNIC



(*************************  circuit_handler  ****************************)
(*									*)
(*		 	write_dnic_table				*)
(*									*)
(*	Write class/group table to the circuit by pages.		*)
(*									*)
(************************************************************************)

procedure entry WRITE_DNIC_TABLE(
  var data	: univ dnic_table_in_bytes);

begin
  send(DNIC_TABLE_LENGTH, data[0])
end (* write_dnic_table *);
$endif INCLUDE_DNIC



(*************************  circuit_handler  ****************************)
(*									*)
(*			  send_errlog_message				*)
(*									*)
(*      Send a message to the Supervisor error log.			*)
(*									*)
(************************************************************************)

procedure entry SEND_ERRLOG_MESSAGE(
      kind	: char;
      data1	: char;
      data2	: halfword);

var  
  msg : errlog_message;
  param : circuit_param;

begin
  msg.data2 := data2;
  msg.kind := kind;
  msg.data1 := data1;
  msg.pid := NETVAL_PRODUCT_ID;
  param.operation := CIRCUIT_SUP_LOG_MESSAGE;
  io(msg, param, AUX_CIRCUIT, 0)
end (* send_errlog_message *);
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!



(*************************  circuit_handler  ****************************)
(*									*)
(*			     receive_line 				*)
(*									*)
(*	Read a line with editting.					*)
(*									*)
(************************************************************************)

procedure receive_line(
      max_length	: integer;
  var first_char	: char);

begin
  repeat
    param.operation := CIRCUIT_RECEIVE_LINE;
    param.arg1 := max_length;
    param.arg2 := current_timeout;
    io(first_char, param, device, unit)
  until param.status <> DEVICE_BUSY;
  status_check
end (* receive_line *);



(*************************  circuit_handler  ****************************)
(*									*)
(*			   read_command_line 				*)
(*									*)
(*	Read a line with editting.					*)
(*									*)
(************************************************************************)

procedure entry READ_COMMAND_LINE(
  var input_line	: command_line);

begin
  receive_line(COMMAND_LINE_TEXT_MAX, input_line.text[0]);
  if param.arg2 > COMMAND_LINE_TEXT_MAX
  then
    begin (* guarantee that the line terminates with a carriage return *)
      input_line.size := COMMAND_LINE_TEXT_MAX;
      input_line.text[COMMAND_LINE_TEXT_LIMIT] := ASCII_CARRIAGE_RETURN
    end
  else input_line.size := param.arg2
end (* read_command_line *);



(*************************  circuit_handler  ****************************)
(*									*)
(*			   receive_characters 				*)
(*									*)
(*	Read into an array of characters.				*)
(*									*)
(************************************************************************)

procedure receive_characters(
      max_length	: integer;
  var first_char	: char);

begin
  repeat
    param.operation := CIRCUIT_RECEIVE_CHARACTER;
    param.arg1 := max_length;
    param.arg2 := current_timeout;
    io(first_char, param, device, unit)
  until param.status <> DEVICE_BUSY;
  status_check
end (* receive_characters *);



(*************************  circuit_handler  ****************************)
(*									*)
(*			   read_one_character 				*)
(*									*)
(*	Read a single character.					*)
(*									*)
(************************************************************************)

procedure entry READ_ONE_CHARACTER(
  var byte	: char);

begin
  receive_characters(1, byte)
end (* read_one_character *);


 
(*************************  circuit_handler  ****************************)
(*									*)
(*			 read_three_characters 				*)
(*									*)
(*	Read three characters and store them right justified.		*)
(*									*)
(************************************************************************)

procedure entry READ_THREE_CHARACTERS(
  var characters	: univ word_in_bytes);

var
  io_word : word_in_bytes;

begin
  receive_characters(3, io_word[0]);
  characters[0] := ZERO;
  characters[1] := io_word[0];
  characters[2] := io_word[1];
  characters[3] := io_word[2]
end (* read_three_characters *);



(*************************  circuit_handler  ****************************)
(*									*)
(*			     read_mud_data 				*)
(*									*)
(*	Read a MUD block.						*)
(*									*)
(************************************************************************)

procedure entry READ_MUD_DATA(
$ifnone BEFORE_SUP_V43  var buffer	: mud_disk_block);
$if BEFORE_SUP_V43  var buffer	: cud_disk_block);

begin
  receive_characters(
$if BEFORE_SUP_V43    MAXIMUM_CUD_DATA,
$ifnone BEFORE_SUP_V43    MAXIMUM_MUD_DATA,
    buffer.data[0])
end (* read_mud_data *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code
$if include_list_descriptions



(*************************  circuit_handler  ****************************)
(*									*)
(*			read_list_description 				*)
(*									*)
(*	Read a list description with editting.				*)
(*									*)
(************************************************************************)

procedure entry READ_LIST_DESCRIPTION(
  var description	: named_list_description);

begin
  receive_line(MAXIMUM_NAMED_LIST_DESCRIPTION_SIZE, description.text[0]);
  if not break_pending
  then
    begin (* adjust size only if receive_line not interrupted by break *)
      if param.arg2 > MAXIMUM_NAMED_LIST_DESCRIPTION_SIZE
      then description.size := MAXIMUM_NAMED_LIST_DESCRIPTION_SIZE
      else description.size := param.arg2;
      if description.text[description.size - 1] = ASCII_CARRIAGE_RETURN
      then description.size := description.size - 1
    end
end (* read_list_description *);
$endif include_list_descriptions
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if changes_to_oper_log


(*************************  circuit_handler  ****************************)
(*									*)
(*			     read_remark 				*)
(*									*)
(*	Read a remark with editting.					*)
(*									*)
(************************************************************************)

procedure entry READ_REMARK(
  var remark : oplog_remark_message);

begin
  receive_line(OPLOG_REMARK_LENGTH, remark.chars[0]);
  if param.arg2 > OPLOG_REMARK_LENGTH
  then remark.size := OPLOG_REMARK_LENGTH
  else remark.size := param.arg2 - 1 (* remove carriage return *)
end (* read_remark *);
$endif changes_to_oper_log
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$endif disk_maintenance_code



(*************************  circuit_handler  ****************************)
(*									*)
(*			 read_two_characters 				*)
(*									*)
(*	Read two characters and store them right justified.		*)
(*									*)
(************************************************************************)

procedure entry READ_TWO_CHARACTERS(
  var characters	: univ word_in_bytes);

var
  io_word : word_in_bytes;

begin
  receive_characters(2, io_word[0]);
  characters[0] := ZERO;
  characters[1] := ZERO;
  characters[2] := io_word[0];
  characters[3] := io_word[1]
end (* read_two_characters *);


 
(*************************  circuit_handler  ****************************)
(*									*)
(*				read_word 				*)
(*									*)
(*	Input 4 bytes.							*)
(*									*)
(************************************************************************)

procedure entry READ_WORD(
  var word	: univ word_in_bytes);

begin
  receive_characters(MAXIMUM_BYTES_IN_WORD, word[0])
end (* read_word *);
$ifnone disk_maintenance_code



(*************************  circuit_handler  ****************************)
(*									*)
(*			read_class_group_table 				*)
(*									*)
(*	Read a Supervisor Class/group table.				*)
(*									*)
(************************************************************************)

procedure entry READ_CLASS_GROUP_TABLE(
  var data	: univ table_in_pages);

var
  page_index : table_page_index;

begin
  for page_index := 0 to TABLE_PAGE_LIMIT do
    receive_characters(PAGE_SIZE, data[page_index][0])
end (* read_class_group_table *);
$if INCLUDE_DNIC



(*************************  circuit_handler  ****************************)
(*									*)
(*			read_dnic_table 				*)
(*									*)
(*	Read a Supervisor DNIC table.					*)
(*									*)
(************************************************************************)

procedure entry READ_DNIC_TABLE(
  var data	: univ dnic_table_in_pages);

var
  page_index : table_page_index;

begin
  for page_index := 0 to DNIC_TABLE_PAGE_LIMIT do
    receive_characters(PAGE_SIZE, data[page_index][0])
end (* read_dnic_table *);
$endif INCLUDE_DNIC
!



(*************************  circuit_handler  ****************************)
(*									*)
(*			     wait_for_input 				*)
(*									*)
(*	Return when user has typed any characters and carriage return	*)
(*	or a <break>.							*)
(*									*)
(************************************************************************)

procedure entry WAIT_FOR_INPUT;

var
  dummy : char;

begin
  repeat
    param.operation := CIRCUIT_RECEIVE_LINE;
    param.arg1 := 1;
    param.arg2 := current_timeout;
    io(dummy, param, device, unit)
  until param.status <> DEVICE_BUSY;
  status_check
end (* wait_for_input *);



(*************************  circuit_handler  ****************************)
(*									*)
(*				set_echo				*)
(*									*)
(*	Set echo on or off.						*)
(*									*)
(************************************************************************)

procedure entry SET_ECHO(
      echo_on	: boolean);

var
  dummy: char;

begin
  param.operation := CIRCUIT_SET_UNIT;
  if echo_on
  then param.arg1 := 1
  else param.arg1 := 0;
  io(dummy, param, device, unit)
end (* set_echo *);
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(*************************  circuit_handler  ****************************)
(*									*)
(*			    wait_for_output				*)
(*									*)
(*	Send a yellow ball out over the circuit and wait for the	*)
(*	return of an orange ball.					*)
(*									*)
(************************************************************************)

procedure entry WAIT_FOR_OUTPUT;

var
  dummy: char;

begin
(* first send a yellow ball... *)
  param.operation := CIRCUIT_YELLOW_BALL;
  io(dummy, param, device, unit);
  status_check;

  repeat
    param.operation := CIRCUIT_DETECT (* detect ORANGE ball *);
    io(dummy, param, device, unit);
    status_check;
    wait
  until (param.status = ORANGE_BALL) or not available
end (* wait_for_output *);
!
(*************************  circuit_handler  ****************************)
(*									*)
(*			     clear_circuit				*)
(*									*)
(*	Clear circuit if not allready cleared and return to login ring. *)
(*									*)
(************************************************************************)

procedure entry CLEAR_CIRCUIT;

begin
  zap_circuit
end (* clear_circuit *);



(*************************  circuit_handler  ****************************)
(*									*)
(*			      set_console				*)
(*									*)
(*	Make this the console terminal for runtime errors.		*)
(*									*)
(************************************************************************)

procedure entry SET_CONSOLE;

var
  dummy : char;

begin
  param.operation := CIRCUIT_SET_UNIT;
  param.arg1 := SYS_CONS;
  io(dummy, param, device, unit)
end (* set_console *);



(*************************  circuit_handler  ****************************)
(*									*)
(*			   set_crt_terminal				*)
(*									*)
(*	Set handling of backspace for CRT terminal.			*)
(*									*)
(************************************************************************)

procedure entry SET_CRT_TERMINAL;

var
  dummy : char;

begin
  param.operation := CIRCUIT_SET_UNIT;
  param.arg1 := SET_CRT;
  io(dummy, param, device, unit)
end (* set_crt_terminal *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code



(*************************  circuit_handler  ****************************)
(*									*)
(*			 clear_edit_characters				*)
(*									*)
(*	Used for I/O over auxilliary circuits.				*)
(*									*)
(************************************************************************)

procedure entry CLEAR_EDIT_CHARACTERS;

var
  dummy : char;
  arg1_value : CHAR_DEL..LINE_DEL;

begin
  for arg1_value := CHAR_DEL to LINE_DEL do 
    begin
      param.operation := CIRCUIT_SET_UNIT;
      param.arg1 := arg1_value;
      param.arg2 := 0 (* clear this edit character *);
      io(dummy, param, device, unit)
    end (* for *)
end (* clear_edit_characters *);
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(*************************  circuit_handler  ****************************)
(*									*)
(*			  set_alternate_break				*)
(*									*)
(*	Set an alternate character for the break function.		*)
(*									*)
(************************************************************************)

procedure entry SET_ALTERNATE_BREAK(
      other	: char);

var
  io_other : char;

begin
  io_other := other;
  param.operation := CIRCUIT_SET_ALTERNATE_BREAK;
  io(io_other, param, device, unit)
end (* set_alternate_break *);



(*************************  circuit_handler  ****************************)
(*									*)
(*			     check_circuit				*)
(*									*)
(*	Check if circuit available.					*)
(*									*)
(************************************************************************)

procedure entry CHECK_CIRCUIT;

var
  dummy: char;

begin
  param.operation := CIRCUIT_INFO;
  param.arg2 := 0;
  io(dummy, param, device, unit);
  status_check
end (* check_circuit *);



(*************************  circuit_handler  ****************************)
(*									*)
(*			   clear_break_status				*)
(*									*)
(*	Clear the pending break in param so that other operations can	*)
(*	happen. This is the programs acknowledgement of the break.	*)
(*									*)
(************************************************************************)

procedure entry CLEAR_BREAK_STATUS;

var
  dummy: char;

begin
  param.operation := CIRCUIT_CLEAR_BREAK;
  io(dummy, param, device, unit);
  break_pending := FALSE;
  sendable := TRUE;
  status_check
end (* clear_break_status *);



(*************************  circuit_handler  ****************************)
(*									*)
(*			      set_timeout				*)
(*									*)
(*	Set timeout to be used on all read operations.			*)
(*									*)
(************************************************************************)

procedure entry SET_TIMEOUT(
      new_timeout	: integer);

begin
  current_timeout := new_timeout
end (* set_timeout *);
!
(*************************  circuit_handler  ****************************)
(************************************************************************)

begin (* initial statement *)
  reset_circuit
end (* circuit_handler *);
!
(************************************************************************)
(*									*)
(*	FORM.NTV							*)
(*									*)
(*			   internal_to_string				*)
(*									*)
(*    This class converts various internal representations to		*)
(*    strings of type format_buffer.					*)
(*									*)
(***** BE AWARE OF FORMAT_BUFFER_TEXT_MAX, DEFINED IN GLOBL.NTV;    *****)
(***** THIS IS THE MAXIMUM NUMBER OF CHARACTERS THAT CAN BE ADDED   *****)
(***** TO THE BUFFER; A RANGE ERROR WILL OCCUR IF THIS IS EXCEEDED. *****)
(*									*)
(************************************************************************)
(*									*)
(*			     Revision Record				*)
(*									*)
(*	03Oct88 - jrn							*)
(*		- add NUD control options for				*)
(*		  password_expiration_by_user 				*)
(*		- change allow_user_password_expire to			*)
(*		  password_expiration_by_user and check out code	*)
(*		- use password_expiration_date_in_cud for code that is	*)
(*		  required for global or user password expiration	*)
(*		- add code for restrict_users_by_time			*)
(*		- use ganpass_file_exists				*)
(*		- add code for allow_logon_inhibit			*)
(*	10Mar88 - neh							*)
(*	      - add PRIORITY_CONTINUE to access control options and	*)
(*		PROHIBIT_DEFAULT_USER mud option.			*)
(*	02Feb88 - neh							*)
(*	      - remove NEW_LINE, unused duplicate of NEWLINE		*)
(*		add add get_string, STRING_FROM_BUFFER			*)
(*	30Nov87 - neh							*)
(*	      - add DNICNAME and DNIC_NAME_FLAG				*)
(*	19Nov87 - neh							*)
(*	      - add DNIC_FILE_MESSAGE					*)
(*	13Aug87 - neh							*)
(*	      - replace TYMSHARE_CUD_FORMAT flag with INCLDUE_IRC	*)
(*	17Feb87 - neh							*)
(*	      - add UN2_VERSION_ERROR, UN2_TOO_MANY_DISK_ERRORS and	*)
(*		UN2_OPTION_ERROR to un2_sup_error			*)
(*			merge 4.00 and 5.00 neh 			*)
(*	04Feb87 - rsb							*)
(*		- add FORCE_PASSWD_CHG_EXEMPT and NO_SELF_PASSWD_CHANGE	*) 
(*		  to SHORT_CONTROL_OPTION_NAME and CONTROL_OPTION_NAME	*)
(*		- add EXPIREDATE_CRITERION to CRITERIA_NAME		*)
(*	03Sep86 - neh							*)
(*	      - Add the procedures PUT_MESSAGE_KIND, to output the	*)
(*		operator message type description and			*)
(*		PUT_MODIFY_DESCRIPTION, to output the description of	*)
(*		of the cud change modifcation type from the operator	*)
(*		log messages.						*)
(*	      - Change UN2_SUP_ERROR to remove the addition of       	*)
(*		of "UN2 error on Supervisor" and the supervisor number 	*)
(*     	      - Change SYSMSG1_ERROR to remove the addition of	 	*)
(*		"SYSMSG1 error on Supervisor" and the supervisor number *)
(*	      - Change CONSISTENCY_ERROR to remove the addition of 	*)
(*		the string "Supervisor" and the supervisor number 	*)
(*      03Sep86 - jrn                                                   *)
(*            - allow SET GFD ONLY and CHANGE UUN AND GAN CUD changes   *)
(*              available if not Tymshare CUD format (for BUBBNET)      *)
(*	18Jul86 - jrn							*)
(*	      - add CUD_ENTRY_IN_WRONG_BLOCK to cud_entry_status	*)
(*		procedure						*)
(*	24Jan86 - jrn							*)
(*	      - add PROMPT procedure					*)
(*	      - add COMMAND_STRING and KEYWORD_STRING procedures	*)
(*	      - change HELP_TEXT_STRING to accomodate removal of help	*)
(*		text size						*)
(*	23Jan86	- rsb							*)
(*		- un2_sup_error:  add "un2_supervisor_not_in_		*)
(*		  pseudo_sup_table" to case statement:			*)  
(*		  put_string an error message, then 			*)
(*		  crash_utility.halt_slot				*)
(*	21Jan86 - jrn							*)
(*	      - add BY_VALIDATOR procedure				*)
(*	      - add put_unit_and_sector and UNIT_AND_SECTOR procedures	*)
(*		and make use of put_unit_and_sector in CUD_BLOCK_ERROR	*)
(*	08Jan86 - jrn							*)
(*	      - remove UPDATE_TYMCOM_LUDS				*)
(*	23Dec85	- change every "sup : supervisor_index" to		*)
(*                 "real_sup          : real_supervisor_index;"		*)
(*		  and every "sup" to "real_sup" for USN.		*)
(*	09Dec85 - jrn							*)
(*	      - remove ASSIGN_CUSTOMER_NUMBERS_FROM_TYMCOM_IX		*)
(*	13Nov85 - jrn							*)
(*	      - add host_state_name procedure				*)
(*	15Feb85 - jrn							*)
(*	      - add CUD_ENTRY_ILLEGAL_NAME to cud_entry_status routine 	*)
(*	22Jan85 - version 3.00 pgl					*)
(*	      - if LOGICAL_VOLUMES, add lvol_state			*)
(*	      - added put_basic_time and no_sec_time			*)
(*	27Nov84 - version 3.00 pgl					*)
(*	      - add procedure cud_parameter_file_status			*)
(*	02Oct84 - version 3.00	neb					*)
(*	      - add conditional change types to CUD_CHANGE_DESCRIPTION  *)
(*		for netval_is_a_slave and tymshare_cud_format		*)
(*	27Nov84 - jrn							*)
(*	      - change message for type node_host_utility_status, value	*)
(*		NODE_HOST_BEING_UPDATED in routine named_list_status	*)
(*	01Aug84 - jrn							*)
(*	      - add CUD_PARAMETER_FILE to put_file_name routine		*)
(*	      - add ansii_tape_label_chars and ansii_tape_label_date	*)
(*		routines						*)
(*	      - add list_description					*)
(*	      - list_name reflects change made to named_list_name	*)
(*	      - add NODE_HOST_BAD_CHECKSUM and delete 			*)
(*	        NODE_HOST_HEADER_ERROR and NODE_HOST_FORMAT_ERROR	*)
(*		to named_list_status					*)
(*	20Jul84 Version 3.0     jrn/pgl					*)
(*	      - added MASTER_VALIDATOR to validator_type_name		*)
(*	      - added procedures tymcom_ix_slave_error,	 		*)
(*		cud_change_description and build_error			*)
(*	10Jul84 Version 2.02	jrn					*)
(*	      - add report_file_error for NVDM				*)
(*	      - fixed format_number routine bug				*)
(*	      - added AUDITOR_LICENSE, OPERATOR_LICENSE			*)
(*	      - consolidated common string messages			*)
(*	      - added procedure criteria_name 				*)
(*	      - renamed procedures short_control_bit_name and		*)
(*	    	control_bit_name to short_control_option_name and	*)
(*		control_option_name 					*)
(*	      - added LICENSED and PASSWORD_ONLY control_options	*)
(*	      - added CUD_ENTRY_OVERFLOW_FOUND to cud_entry_status 	*)
(*									*)
(*	29SEP83 Original (from form.bas) -- jrn 			*)
(*									*)
(************************************************************************)



type INTERNAL_TO_STRING = class


const
  DIGITS_IN_MAX_DECIMAL_INTEGER = 10;
  DIGITS_IN_MAX_HEX_INTEGER = 8;
  DIGITS_IN_MAX_OCTAL_INTEGER = 10;


  circuit_build_error = 'circuit build error: \';
  circuit_error = 'circuit error: \';
  cud_block_shut = 'programmer has block locked\';
  file_busy = 'file busy\';
  io_failure = 'I/O operation failed\ ';
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code   lost_circuit = 'lost circuit\ ';
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  system_unavailable = 'system unavailable\ ';
  timed_out = 'timed out\';
  unrecognized_input = 'unrecognized input\ ';
  user_not_found = 'user not found\ ';


var
  calendar : date_time_converter;

  entry buffer : format_buffer (* all conversion into here *);



(***********************  internal_to_string  ***************************)
(*									*)
(*			    put_character				*)
(*									*)
(*    Put character in buffer.text[size].				*)
(*									*)
(************************************************************************)

procedure put_character(
      c	: char);

begin
  buffer.text[buffer.size] := c;
  if buffer.size < FORMAT_BUFFER_TEXT_MAX
  then buffer.size := buffer.size + 1
end (* put_character *);



(***********************  internal_to_string  ***************************)
(*									*)
(*			       put_string				*)
(*									*)
(*    Put string into buffer.						*)
(*									*)
(************************************************************************)

procedure put_string(
      string_to_insert	: quoted_text);

var
  i: quoted_text_index;

begin
  i := 0;
  while string_to_insert[i] <> END_MESSAGE_CHARACTER do
    begin
      put_character(string_to_insert[i]);
      i := i + 1
    end (* while *)
end (* put_string *);



(***********************  internal_to_string  ***************************)
(*									*)
(*			       put_number				*)
(*									*)
(*    Convert number to string and store in buffer.			*)
(*									*)
(************************************************************************)

procedure put_number(
      number_to_convert	: integer;
      radix		: integer);

var
  s : array [1..11] of integer;
  positive_number : integer;
  n : integer;
  i : integer;
  negative : boolean;

begin
  positive_number := number_to_convert;
  negative := positive_number < 0;
  if negative
  then
    if (radix = 16) or (radix = 8)
    then positive_number := (positive_number + MAX_INTEGER) + 1
    else positive_number := -positive_number;

  n := 0;
  repeat
    n := n + 1;
    s[n] := positive_number mod radix;
    positive_number := positive_number div radix
  until positive_number = 0;

  if negative
  then
    if radix = 8
    then
      begin
	for i := n + 1 to 11 do
	  s[i] := 0;
	n := 11;
	s[11] := s[11] + 2 (* put sign bit back in last character *)
      end
    else if radix = 16
    then
      begin
	for i := n + 1 to 8 do
	  s[i] := 0;
	n := 8;
	s[8] := s[8] + 8 (* put sign bit back *)
      end
    else put_character(ASCII_MINUS);

  for i := n downto 1 do
    if s[i] < 10
    then put_character(chr(ord(ASCII_ZERO) + s[i]))
    else put_character(chr(ord(ASCII_A) + s[i] - 10))
end (* put_number *);



(************************  internal_to_string  **************************)
(*									*)
(*			    put_scaled_number				*)
(*									*)
(*    Convert a number to a string with a radix point a given number	*)
(*    of places to the left of the right of the number. I.e, a call	*)
(*    of scaled_number(1234, 10, 1) will produce the number 123.4	*)
(*									*)
(************************************************************************)

procedure put_scaled_number(
      number_to_convert	: integer;
      radix		: integer;
      radix_place	: integer);

var
  fraction : integer;
  scale : integer;
  i : integer;

begin
  scale := 1 (* construct scale factor from radix places *);
  for i := 1 to radix_place do
    scale := scale*radix;
  put_number(number_to_convert div scale, radix);
  put_character(ASCII_DOT);
  fraction := abs(number_to_convert mod scale);
  scale := scale div radix;
  while scale > fraction do (* output leading zeros of fraction *)
    begin
      put_character(ASCII_ZERO);
      scale := scale div radix
    end (* while *);
  if fraction > 0
  then put_number(fraction, radix)
end (* put_scaled_number *);



(***********************  internal_to_string  ***************************)
(*									*)
(*			   put_colon_space				*)
(*									*)
(*    Put colon, space in buffer.					*)
(*									*)
(************************************************************************)

procedure put_colon_space;

begin
  put_character(ASCII_COLON);
  put_character(ASCII_SPACE)
end (* put_colon_space *);



(***********************  internal_to_string  ***************************)
(*									*)
(*			     put_newline				*)
(*									*)
(*    Put carriage return linefeed in buffer.				*)
(*									*)
(************************************************************************)

procedure put_newline;

begin
  put_character(ASCII_CARRIAGE_RETURN);
  put_character(ASCII_LINE_FEED)
end (* put_newline *);



(************************  internal_to_string  **************************)
(*									*)
(*			       put_supervisor 				*)
(*									*)
(*    Convert a supervisor_index to a string.				*)
(*									*)
(************************************************************************)

procedure put_supervisor(
  real_sup          : real_supervisor_index);

begin
  put_number(real_sup + PRINT_SUPERVISOR_OFFSET, 10)
end (* put_supervisor *);



(***********************   internal_to_string	*************************)
(*									*)
(*			     put_format_number				*)
(*									*)
(*    Convert a number to a string of max_places characters.		*)
(*    If number_to_print is negative or too bit, output *'s.		*)
(*    If max_places is negative, display leading zeros.			*)
(*    Otherwise, display leading blanks.				*)
(*									*)
(************************************************************************)

procedure put_format_number(
      number_to_print	: integer;
      radix 		: integer;
      max_places	: integer);

var
  zero_fill : boolean (* TRUE if field should be zero filled *);
  number_fits : boolean (* TRUE if number_to_print fits in max_places *);
  places_to_print,
  length_required,	(* places required to output number_to_print *)
  n : integer;

begin
  zero_fill := max_places < 0;
  places_to_print := abs(max_places);
  if number_to_print < 0
  then number_fits := FALSE
  else
    begin
      number_fits := TRUE; length_required := 1; n := radix;
      while number_fits and (n <= number_to_print) do
        begin
	  length_required := length_required + 1;
	  number_fits := length_required <= places_to_print;
	  n := n * radix
	end (* while *);
      if number_fits
      then
        for n := 1 to (places_to_print - length_required) do
	  if zero_fill
	  then put_character(ASCII_ZERO)
	  else put_character(ASCII_SPACE)
    end (* number_to_print >= 0 *);
  if number_fits
  then put_number(number_to_print, radix)
  else
    for n := 1 to places_to_print do
      put_character('*')
end (* put_format_number *);



(***********************  internal_to_string  ***************************)
(*									*)
(*			    put_basic_time				*)
(*									*)
(*    Convert ISIS time to character string - MM/DD/YY HH:MM		*)
(*									*)
(************************************************************************)

procedure put_basic_time(
      time_to_convert	: integer;
  var date_time		: print_time);

begin
  calendar.date_from_isis_time(time_to_convert, date_time);
  with date_time do
    begin
      put_format_number(month, 10, -2);
      put_character(ASCII_SLASH);
      put_format_number(day, 10, -2);
      put_character(ASCII_SLASH);
      put_format_number(year mod 100, 10, -2);
      put_character(ASCII_SPACE);
      put_format_number(hour, 10, -2);
      put_character(ASCII_COLON);
      put_format_number(minute, 10, -2)
    end
end (* put_basic_time *);



(***********************  internal_to_string  ***************************)
(*									*)
(*			      put_time					*)
(*									*)
(*    Convert ISIS time to character string - MM/DD/YY HH:MM		*)
(*									*)
(************************************************************************)

procedure put_time(
      time_to_convert	: integer);

var
  date_time: print_time;

begin
  put_basic_time(time_to_convert, date_time);
  with date_time do
    begin
      put_character(ASCII_COLON);
      put_format_number(second, 10, -2)
    end (* with *)
end (* put_time *);



(***********************  internal_to_string  ***************************)
(*									*)
(*			      put_isis_error				*)
(*									*)
(************************************************************************)

procedure put_isis_error(
      error	: integer);

begin
  if (error <= 0) or (error > 24)
  then
    begin
      put_string('undefined error: \');
      put_number(error, 10)
    end
  else
    case error of
      1:  put_string('bad memory address\ ');
      2:  put_string('no access allowed to unit\');
      3:  put_string('read/write/attach protection failure\ ');
      4:  put_string('virtual block out of allocated area on disk\');
      5:  put_string('kernel tables VBN past EOV\ ');
      6:  put_string('kernel tables cyliner overflow past EOV\');
      7:  put_string('error return from unit\ ');
      8:  put_string('error return from controller\ ');
      9:  put_string('operation aborted\');
      10: put_string('requested byte count 0 or odd\');
      11: put_string('invalid cylinder overflow indication\ ');
      12: put_string('defective sector in alternate cylinder\ ');
      13: put_string('defective sector, and no alternate cylinders\ ');
      14: put_string('cylinder map not readable\');
      15: put_string('defective cylinder; alternate assigned\ ');
      16: put_string('end of file detected\ ');
      17: put_string('end of volume detected\ ');
      18: put_string('device unavailable\ ');
      19: put_string(WRITE_PROTECTED_MESSAGE);
      20: put_string('unit attached, but it is write protected\ ');
      21: put_string('unit attached to another slot\');
      22: put_string('operation ignored for this unit\');
      23: put_string(TIMED_OUT);
      24: put_string('recovered error correcting code error\')
    end (* case *)
end (* put_isis_error *);



(***********************  internal_to_string  ***************************)
(*									*)
(*			       get_string				*)
(*									*)
(*    Get string from buffer.						*)
(*									*)
(************************************************************************)

procedure get_string(
  var string_to_get : quoted_text);

var
  i: quoted_text_index;

begin
  if buffer.size > QUOTED_TEXT_LIMIT
  then buffer.size := QUOTED_TEXT_LIMIT;
  for i := 0 to buffer.size - 1 do
    string_to_get[i] := buffer.text[i];
  string_to_get[buffer.size] := END_MESSAGE_CHARACTER
end (* get_string *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if logical_volumes



(***********************  internal_to_string  ***************************)
(*									*)
(*			      isis_error				*)
(*									*)
(************************************************************************)

procedure entry ISIS_ERROR(
      error	: integer);

begin
  put_isis_error(error)
end (* isis_error *);



(***********************  internal_to_string  ***************************)
(*									*)
(*			     no_sec_time				*)
(*									*)
(*    Convert ISIS time to character string - MM/DD/YY HH:MM		*)
(*									*)
(************************************************************************)

procedure entry NO_SEC_TIME(
      time_to_convert	: integer);

var
  date_time: print_time;

begin
  put_basic_time(time_to_convert, date_time)
end (* no_sec_time *);
$endif logical_volumes



(***********************  internal_to_string  ***************************)
(*									*)
(*		              put_date					*)
(*									*)
(*    Convert ISIS time to character string.				*)
(*									*)
(************************************************************************)

procedure put_date(
      date_time	: print_time);

begin
  with date_time do
    begin
      put_format_number(month, 10, -2);
      put_character(ASCII_SLASH);
      put_format_number(day, 10, -2);
      put_character(ASCII_SLASH);
      put_format_number(year mod 100, 10, -2);
    end (* with *)
end (* put_date *);


(************************  internal_to_string  **************************)
(*									*)
(*				  date     				*)
(*									*)
(*      convert ISIS time to character string w/o min and sec		*)
(*									*)
(************************************************************************)

procedure entry DATE(
      time_to_convert	: integer);

var
 date_time : print_time;

begin
  calendar.date_from_isis_time(time_to_convert, date_time);
  put_date(date_time);
end (* date *);
$ifnone disk_maintenance_code



(************************  internal_to_string  **************************)
(*									*)
(*				  write_date   				*)
(*									*)
(*      copy print_time to character string w/o min and sec		*)
(*									*)
(************************************************************************)

procedure entry WRITE_DATE(
      date_time	: print_time);

begin
  put_date(date_time);
end (* date *);



(************************  internal_to_string  **************************)
(*									*)
(*			  ansii_tape_label_date				*)
(*									*)
(*      Convert supplied ISIS time to "YYDDD" for ANSII standard tape	*)
(*	HDR1 label.							*)
(*									*)
(************************************************************************)

procedure entry ANSII_TAPE_LABEL_DATE(
      time_to_convert	: integer);

var
 date_time : print_time;

begin
  calendar.date_from_isis_time(time_to_convert, date_time);
  with calendar, date_time do
    begin
      put_format_number(year mod 100, 10, -2);
      day := days_to_month(month, leap_year(year)) + day;
      put_format_number(date_time.day, 10, -3)
    end
end (* ansii_tape_label_date *);



(***********************  internal_to_string  ***************************)
(*									*)
(*			      short_time				*)
(*									*)
(*    Convert ISIS time to character string - MM/DD HH:MM		*)
(*									*)
(************************************************************************)

procedure entry SHORT_TIME(
      time_to_convert	: integer);

var
  date_time: print_time;

begin
  calendar.date_from_isis_time(time_to_convert, date_time);
  with date_time do
    begin
      put_format_number(month, 10, -2);
      put_character(ASCII_SLASH);
      put_format_number(day, 10, -2);
      put_character(ASCII_SPACE);
      put_format_number(hour, 10, -2);
      put_character(ASCII_COLON);
      put_format_number(minute, 10, -2)
    end (* with *)
end (* short_time *);
$if changes_to_oper_log



(***********************  internal_to_string ****************************)
(*									*)
(*			 cud_change_description				*)
(*									*)
(*      Add the description of the CUD change to the buffer		*)
(*									*)
(************************************************************************)

procedure entry CUD_CHANGE_DESCRIPTION(
      change	: cud_change_indicator);

begin
  case change of
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if overflow_cud_entries
    CREATE_OVERFLOW_BLOCK:	put_string('create overflow block\');
$endif overflow_cud_entries
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    NEW_USER_CUD_CHANGE:		put_string('new user\ ');
    CHANGE_GAN_CUD_CHANGE:		put_string('change GAN\ ');
    CHANGE_PASSWORD_CUD_CHANGE:		put_string('change password\');
    RENAME_DELETE_USER_CUD_CHANGE:	put_string('rename user (delete)\ ');
    RENAME_RESTORE_OLD_NAME:	    put_string('restore old name (rename)\');
    RENAME_NEW_USER_CUD_CHANGE:		put_string('rename user (add)\');
    DELETE_USER_CUD_CHANGE:		put_string('delete user\');
    CHANGE_OPTIONS_CUD_CHANGE:		put_string('change options\ ');
    CHANGE_DISTRICT_CUD_CHANGE:		put_string('change district\');
    CHANGE_UUN_CUD_CHANGE:		put_string('change UUN\ ');
(*      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+      *)
$if netval_is_a_slave
    SET_GFD_ONLY_CUD_CHANGE:		put_string('change GFD only\');
    CHANGE_UUN_AND_GAN_CUD_CHANGE:	put_string('change UUN and GAN\ ');
$endif netval_is_a_slave
$if INCLUDE_IRC     CHANGE_IRC_CUD_CHANGE:	put_string('change IRC\ ');
$if force_password_change
    PASSCHANGER_PASSWORD_CHANGE:	put_string('force password change\');
$endif force_password_change
$if password_expiration_date_in_cud
    CHANGE_PASSWORD_EXPIRE:	put_string('change password expiration\ ');
$endif password_expiration_date_in_cud
$if restrict_users_by_time
    CHANGE_ALLOWABLE_TIMES_CUD_CHANGE:
      put_string('change allowable login times\ ');
$endif restrict_users_by_time
$ifnone before_sup_v43
    CHANGE_NUD_OPTIONS_CUD_CHANGE: put_string('change NUD options\ ');
$endif before_sup_v43
    CHANGE_ACCESS_CUD_CHANGE:		put_string('change access\')
  end (* case *)
end (* cud_change_description *);
$endif changes_to_oper_log
(*      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+      *)



(************************  internal_to_string  **************************)
(*									*)
(*			   validator_type_name 				*)
(*									*)
(************************************************************************)

procedure entry VALIDATOR_TYPE_NAME(
      validator_level	: validator_type);

begin
  case validator_level of
$if global_password_only_login    GPO_VALIDATOR: put_string(GPO_MESSAGE);
(*      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+      *)
$if netval_is_a_slave     MASTER_VALIDATOR: put_string(MASTER_MESSAGE);
(*      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+      *)
    PASSWORD_ONLY_VALIDATOR: put_string(PASSWORD_ONLY_MESSAGE);
    ACCOUNT_SUPERVISOR_VALIDATOR: put_string(ACCOUNT_SUPERVISOR_MESSAGE);
    NETWORK_ADMINISTRATOR_VALIDATOR: put_string(NETWORK_ADMINISTRATOR_MESSAGE);
    PROGRAMMER_VALIDATOR: put_string(PROGRAMMER_MESSAGE)
  end (* case *)
end (* validator_type_name *);
$ifnone BEFORE_SUP_V43



(************************  internal_to_string  **************************)
(*									*)
(*			 short_control_option_name			*)
(*									*)
(*    Generate short name string from control_options.			*)
(*									*)
(************************************************************************)

procedure entry SHORT_CONTROL_OPTION_NAME(
      option	: mud_control_options);

begin
  case option of
    USERNAME_TYPE:		put_string('ut\ ');
    HOSTNAME_TYPE:		put_string('dt\ ');
    NO_PASSWORD_REQUIRED:	put_string('np\ ');
    IGNORE_DESTINATION:		put_string('id\ ');
    TRANSPARENT_LOGIN:		put_string('tl\ ');
    AUX_PASSWORD:		put_string('ap\ ');
    TARGET_PROFILE_ENTRY:	put_string('te\ ');
    PROHIBIT_DEFAULT_USER:	put_string('pd\ ');
    LOGON_INHIBIT:		put_string('lg\ ')
  end (* case *)
end (* short_control_option_name *);



(************************  internal_to_string  **************************)
(*									*)
(*			 short_nud_control_option_name			*)
(*									*)
(*    Generate short name string from nud_control_options.		*)
(*									*)
(************************************************************************)

procedure entry SHORT_NUD_CONTROL_OPTION_NAME(
      option	: nud_control_options);

begin
  case option of
    NETWORK_ADMINISTRATOR:	put_string('na\ ');
    FPC_EXEMPT: 		put_string('fe\ ');
    NSP_CHANGE:			put_string('ns\ ');
    EXEMPT_FROM_PASSWORD_EXPIRATION: put_string('ee\ ');
    ACCOUNT_SUPERVISOR:		put_string('as\ ');
    OPERATOR:			put_string('op\ ');
    AUDITOR:			put_string('au\ ')
  end (* case *)
end (* short_nud_control_option_name *);




(************************  internal_to_string  **************************)
(*									*)
(*			 short_access_control_option_name		*)
(*									*)
(*    Generate short name string from mud_control_options.		*)
(*									*)
(************************************************************************)

procedure entry SHORT_ACCESS_CONTROL_OPTION_NAME(
      option : access_control_options);

begin
  case option of
    USERNAME_OK:		put_string('uok\');
    HOSTNAME_OK:		put_string('dok\');
    ALLOW_NORMAL_CIRCUIT:	put_string('anc\');
    ALLOW_AUX_CIRCUIT:		put_string('aac\');
    USER_REGULAR_CALL:		put_string('urc\');
    USER_COLLECT_CALL:		put_string('ucc\');
    HOST_REGULAR_CALL:		put_string('drc\');
    HOST_COLLECT_CALL:		put_string('dcc\');
    SHUT_OVERRIDE:		put_string('so\ ');
    REQUIRE_HOSTNAME:		put_string('rd\ ');
    TARGET_PROFILE_DESTINATION:	put_string('td\ ');
    PRIORITY_CONTINUE:		put_string('ps\ ')
  end (* case *)
end (* short_access_control_option_name *);
$endif BEFORE_SUP_V43
$if BEFORE_SUP_V43



(************************  internal_to_string  **************************)
(*									*)
(*			 short_control_option_name			*)
(*									*)
(*    Generate short name string from control_options.			*)
(*									*)
(************************************************************************)

procedure entry SHORT_CONTROL_OPTION_NAME(
      option	: control_options);

begin
  case option of
    ACCOUNT_SUPERVISOR:		put_string('as\ ');
    IGNORE_DESTINATION:		put_string('id\ ');
    NETWORK_ADMINISTRATOR:	put_string('na\ ');
    NO_PASSWORD_REQUIRED:	put_string('np\ ');
    SHUT_OVERRIDE:		put_string('so\ ');
    AUDITOR:			put_string('au\ ');
    OPERATOR:			put_string('op\ ');
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if force_password_change
    FPC_EXEMPT: 		put_string('fe\ ');
$endif force_password_change
$if no_self_password_change
    NSP_CHANGE:			put_string('ns\ ');
$endif no_self_password_change
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    TRANSPARENT_LOGIN:		put_string('tl\ ')
  end (* case *)
end (* short_control_option_name *);
$endif BEFORE_SUP_V43
$if INCLUDE_DNIC



(*************************  internal_to_string  *************************)
(*									*)
(*				dnic_flag_name				*)
(*									*)
(*      Generates name string from dnic_flag.				*)
(*									*)
(************************************************************************)

procedure entry DNIC_FLAG_NAME(
      flag	: dnic_flags);

begin
  case flag of
    NATIVE:	put_string('native \');
    SHARED:	put_string('shared \');
    TRANSLATED: put_string('translated \')
  end (* case flag *)
end (* dnic_flag_name *);
$endif INCLUDE_DNIC



(*************************  internal_to_string  *************************)
(*									*)
(*				criteria_name				*)
(*									*)
(*      Generates name string from criteria_type.			*)
(*									*)
(************************************************************************)

procedure entry CRITERIA_NAME(
      criteria_index	: criteria_type);

begin
  case criteria_index of
    ALL_CRITERIA:		(* null *);
    ACCESS_CRITERION:		put_string('access\ ');
    GAN_CRITERION:		put_string('GAN\');
    DISTRICT_CRITERION:		put_string('district\ ');
    UUN_CRITERION:		put_string('UUN\');
    CONTROL_CRITERION:		put_string('control\');
    ENTRYDATE_CRITERION:	put_string('entrydate\');
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifany (force_password_change, password_expiration_by_user)
    EXPIREDATE_CRITERION:	put_string('expiredate\ ');
$endif (force_password_change, password_expiration_by_user)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    PASSWORDDATE_CRITERION:	put_string('passworddate\ ')
  end (* case *)
end (* criteria_name *);
$if BEFORE_SUP_V43



(************************  internal_to_string  **************************)
(*									*)
(*			     control_option_name			*)
(*									*)
(*    Generate name string from control_options.			*)
(*									*)
(************************************************************************)

procedure entry CONTROL_OPTION_NAME(
      option_index	: control_options);

begin
  case option_index of
    LICENSED:			put_string(LICENSED_MESSAGE);
    PASSWORD_ONLY:		put_string(PASSWORD_ONLY_MESSAGE);
    ACCOUNT_SUPERVISOR:		put_string(ACCOUNT_SUPERVISOR_MESSAGE);
    IGNORE_DESTINATION:		put_string(IGNORE_DESTINATION_MESSAGE);
    NETWORK_ADMINISTRATOR:	put_string(NETWORK_ADMINISTRATOR_MESSAGE);
    NO_PASSWORD_REQUIRED:	put_string('no password required\ ');
    SHUT_OVERRIDE:		put_string(SHUT_OVERRIDE_MESSAGE);
    AUDITOR:			put_string(AUDITOR_MESSAGE);
    OPERATOR:			put_string(OPERATOR_MESSAGE);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if force_password_change
    FPC_EXEMPT: 		put_string(FPC_EXEMPT_MESSAGE);
$endif force_password_change
$if no_self_password_change
    NSP_CHANGE:			put_string(NSP_CHANGE_MESSAGE);
$endif no_self_password_change
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    TRANSPARENT_LOGIN:		put_string(TRANSPARENT_LOGIN_MESSAGE)
  end (* case *)
end (* control_option_name *);
$endif BEFORE_SUP_V43
$ifnone BEFORE_SUP_V43



(************************  internal_to_string  **************************)
(*									*)
(*			     control_option_name			*)
(*									*)
(*    Generate name string from control_options.			*)
(*									*)
(************************************************************************)

procedure entry CONTROL_OPTION_NAME(
      option_index	: mud_control_options);

begin
  case option_index of
    USERNAME_TYPE: 		put_string('username type entry\');
    HOSTNAME_TYPE:		put_string('destination type entry\ ');
    NO_PASSWORD_REQUIRED:	put_string('no password required \');
    IGNORE_DESTINATION:		put_string(IGNORE_DESTINATION_MESSAGE);
    TRANSPARENT_LOGIN:		put_string(TRANSPARENT_LOGIN_MESSAGE);
    AUX_PASSWORD:	put_string('password required on aux circuit\ ');
    TARGET_PROFILE_ENTRY:	put_string('target profile entry\ ');
    PROHIBIT_DEFAULT_USER:	put_string('prohibit default user\');
    LOGON_INHIBIT:		put_string('logon inhibited\')
  end (* case *)
end (* control_option_name *);



(************************  internal_to_string  **************************)
(*									*)
(*			    nud_control_option_name			*)
(*									*)
(*    Generate name string from control_options.			*)
(*									*)
(************************************************************************)

procedure entry NUD_CONTROL_OPTION_NAME(
      option_index	: nud_control_options);

begin
  case option_index of
    LICENSED:			put_string(LICENSED_MESSAGE);
    PASSWORD_ONLY:		put_string(PASSWORD_ONLY_MESSAGE);
    ACCOUNT_SUPERVISOR:		put_string(ACCOUNT_SUPERVISOR_MESSAGE);
    NETWORK_ADMINISTRATOR:	put_string(NETWORK_ADMINISTRATOR_MESSAGE);
    FPC_EXEMPT: 		put_string(FPC_EXEMPT_MESSAGE);
$if no_self_password_change
    NSP_CHANGE:			put_string(NSP_CHANGE_MESSAGE);
$endif no_self_password_change
    EXEMPT_FROM_PASSWORD_EXPIRATION: put_string(
      'exempt from password expiration\');
    AUDITOR:			put_string(AUDITOR_MESSAGE);
    OPERATOR:			put_string(OPERATOR_MESSAGE)
  end (* case *)
end (* nud_control_option_name *);




(************************  internal_to_string  **************************)
(*									*)
(*			    access_control_option_name			*)
(*									*)
(*    Generate name string from control_options.			*)
(*									*)
(************************************************************************)

procedure entry  ACCESS_CONTROL_OPTION_NAME(
      option_index	: access_control_options);

begin
  case option_index of
    USERNAME_OK:		put_string('username ok\');
    HOSTNAME_OK:		put_string('destination ok\ ');
    ALLOW_NORMAL_CIRCUIT:	put_string('allow normal circuit\ ');
    ALLOW_AUX_CIRCUIT:		put_string('allow auxiliary circuit\');
    USER_REGULAR_CALL:		put_string('user regular call\');
    USER_COLLECT_CALL:		put_string('user collect call\');
    HOST_REGULAR_CALL:		put_string('destination regular call\ ');
    HOST_COLLECT_CALL:		put_string('destination collect call\ ');
    SHUT_OVERRIDE:		put_string(SHUT_OVERRIDE_MESSAGE);
    REQUIRE_HOSTNAME:		put_string('destination name required\');
    TARGET_PROFILE_DESTINATION:	put_string('target profile destination\ ');
    PRIORITY_CONTINUE:		put_string('priority stop\')
  end (* case *)
end (* access_control_option_name *);
$endif BEFORE_SUP_V43



(************************  internal_to_string  **************************)
(*									*)
(*				listname        			*)
(*									*)
(*      put listname into buffer                                        *)
(*									*)
(************************************************************************)

procedure entry LISTNAME(
      name	: named_list_name);

var
  i : named_list_name_index;

begin
  for i := 0 to name.size - 1 do
    put_character(name.text[i])
end (* listname *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if include_list_descriptions



(************************  internal_to_string  **************************)
(*									*)
(*			    list_description        			*)
(*									*)
(*      put named_list_description into buffer                          *)
(*									*)
(************************************************************************)

procedure entry LIST_DESCRIPTION(
      description	: named_list_description);

var
  i : named_list_description_index;

begin
  for i := 0 to description.size - 1 do
    put_character(description.text[i])
end (* list_description *);
$endif include_list_descriptions
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(************************  internal_to_string  **************************)
(*                                                                      *)
(*                          put_message_kind                            *)
(*                                                                      *)
(*      This procedure outputs the message type description for the     *)
(*      message kind passed to it.                                      *)
(*                                                                      *)
(************************************************************************)

procedure entry PUT_MESSAGE_KIND(
        kind    : oper_log_message_kind);

begin
  case kind of
    DEBUGGING_OPLOG_MSG:         put_string('debug\');
    VALIDATOR_OPLOG_MSG:         put_string('validator\');
    FILE_OPLOG_MSG:              put_string('file\ ');
    CUD_OPLOG_MSG:               put_string('CUD error\');
    MUDUPD_OPLOG_MSG:            put_string('mudupdate\');
    UN2_OPLOG_MSG:               put_string('UN2\');
    CONSISTENCY_OPLOG_MSG:       put_string('consistency\');
    SYSMSG1_OPLOG_MSG:           put_string('SYSMSG1\');
    ARCHIVE_OPLOG_MSG:           put_string('archive\');
    UNUSED1_OPLOG_MSG:           (* null statement *);
    CUD_PARAM_OPLOG_MSG:         put_string('PARAMETER\');
    LV_OPLOG_MSG:                put_string('volumes\');
    MASTER_OPLOG_MSG:            put_string('MASTER\ ');
    OPERLOG_REPORT_MSG:          put_string('operator\ ');
    MERGE_UUN_OPLOG_MSG:         put_string('uun merge\');
$if changes_to_oper_log     MODIFY_CUD_OPLOG_MSG:       put_string('modify\ ');
$ifany (force_password_change, global_password_only_login)
    PASSCHANGER_MSG:		put_string('passchanger\');
$endif any force_password_change, global_password_only_login
    UPDATE_OFF_MSG:		put_string('SUP turned off\ ')
  end  (* case *)
end (* put_message_kind *);
(*      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-  *)
$if CHANGES_TO_OPER_LOG



(************************  internal_to_string  **************************)
(*                                                                      *) 
(*                      put_modify_description                          *)
(*                                                                      *) 
(*      This procedure outputs the description of the modify type       *)
(*      corresponding to the modify_index.                              *)
(*                                                                      *)
(************************************************************************)

procedure entry PUT_MODIFY_DESCRIPTION(
        modify  : modify_type);
  
begin
  case modify of
    ACCESS:		put_string('access\ ');
    CONTROL:		put_string('control\');
    DISTRICT:		put_string('district\ ');
    GAN:		put_string('gan\');
    CHANGENAME:		put_string('name\ ');
    PASSWORD:		put_string('password\ ');
    UUN:		put_string('UUN\');
$if restrict_users_by_time     TIMES:		put_string('time\ ');
$ifnone before_sup_v43     NUD_CONTROL:	put_string('NUD control options\');
$if password_expiration_date_in_cud
    EXPIRE_DATE:		put_string('expiration date\');
$endif password_expiration_date_in_cud
$if overflow_cud_entries     OVERFLOW:		put_string('overflow\ ');
$if netval_is_a_slave
    GFD:		put_string('GFD only\ ');
$if INCLUDE_IRC    IRC:		put_string('IRC\');
$endif netval_is_a_slave
    DELETE:		put_string('delete user\');
    NEW:		put_string('new user\ ')
  end (* case *)
end (* put_modify_description *);
$endif CHANGES_OT_OPER_LOG
(*      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-  *)



(***********************  internal_to_string  ***************************)
(*									*)
(*				  time					*)
(*									*)
(*    Convert ISIS time to character string.				*)
(*									*)
(************************************************************************)

procedure entry TIME(
      time_to_convert	: integer);

begin
  put_time(time_to_convert)
end (* time *);



(***********************  internal_to_string  ***************************)
(*									*)
(*			  disk_operation_name				*)
(*									*)
(*    Print name for disk operation.					*)
(*									*)
(************************************************************************)

procedure entry DISK_OPERATION_NAME(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if logical_volumes
$ifnone disk_maintenance_code       operation	: lvol_operation);
$if disk_maintenance_code       operation	: disk_operation);
$endif logical_volumes
$ifnone logical_volumes       operation	: disk_operation);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

begin
  case operation of
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if logical_volumes
$ifnone disk_maintenance_code
    LVOL_READ:  put_string('read\ ');
    LVOL_WRITE: put_string('write\')
$endif disk_maintenance_code
$if disk_maintenance_code
  DISK_READ:  put_string('read\ ');
  DISK_WRITE: put_string('write\')
$endif disk_maintenance_code
$endif logical_volumes
$ifnone logical_volumes
  DISK_READ:  put_string('read\ ');
  DISK_WRITE: put_string('write\')
$endif logical_volumes
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  end (* case *)
end (* disk_operation_name *);



(***********************   internal_to_string	*************************)
(*									*)
(*			     welcome_message				*)
(*									*)
(************************************************************************)

procedure entry WELCOME_MESSAGE(
      welcome_string	: quoted_text);

begin
  put_newline; put_newline;
  put_string(welcome_string);
  put_scaled_number(version*100+revision, 10, 2);
  put_string(' at \ ');
  put_time(REALTIME)
end (* welcome_message *);



(************************  internal_to_string  **************************)
(*									*)
(*			     put_file_name				*)
(*									*)
(*      Add file name to buffer.					*)
(*									*)
(************************************************************************)

procedure put_file_name(
      file	: file_index);

begin
  case file of
    CUD_FILE:		put_string(CUD_FILE_MESSAGE);
$if INCLUDE_DNIC    DNIC_FILE:		put_string(DNIC_FILE_MESSAGE);
    CUD_PARAMETER_FILE:	put_string('CUD_PARAMETER\');
    CONFIGURATION_FILE:	put_string('configuration\');
    NODE_HOST_FILE:	put_string('node_host\');
    CLASS_GROUP_FILE:	put_string('class_group\');
    OPERLOG_FILE:	put_string('oper_log\ ');
$if change_by_whom
" added passtable_file and schedtable_file by SHSUE at 15-Jul-87 11:14:41"
$endif
$if ganpass_file_exists
    PASSTABLE_FILE:	put_string('passtable\');
$endif ganpass_file_exists
    SCHEDTABLE_FILE:	put_string('schedtable\ ');
    MUD_UPDATE_FILE:	put_string('mud_update\ ')
  end (* case *)
end (* put_file_name *);



(************************  internal_to_string  **************************)
(*									*)
(*				file_name				*)
(*									*)
(*      Add file name to buffer.					*)
(*									*)
(************************************************************************)

procedure entry FILE_NAME(
      file	: file_index);

begin
  put_file_name(file)
end (* file_name *);



(************************  internal_to_string  **************************)
(*									*)
(*			     ioresult_name				*)
(*									*)
(*    Generate status name string from ioresult.			*)
(*									*)
(************************************************************************)

procedure ioresult_name(
      status	: ioresult);

begin
  case status of
    COMPLETE:      put_string(COMPLETE_MESSAGE);
    INTERVENTION:  put_string('intervention required\');
    TRANSMISSION:  put_string('transmission error\ ');
    FAILURE:       put_string('device failure\ ');
    END_FILE:      put_string('end of file detected\ ');
    END_MEDIUM:    put_string('end of volume detected\ ');
    START_MEDIUM:  put_string('start medium\ ');
    PROGRAM_ERROR: put_string('program error\');
    BREAK_KEY:     put_string('break key\');
    ORANGE_BALL:   put_string('orange ball\');
    DEVICE_BUSY:   put_string('device busy\');
    TIME_OUT:      put_string(TIMED_OUT)
  end (* case *)
end (* ioresult_name *);



(************************  internal_to_string  **************************)
(*									*)
(*			      status_name				*)
(*									*)
(*    Generate status name string from ioresult.			*)
(*									*)
(************************************************************************)

procedure entry STATUS_NAME(
      status	: ioresult);
      
begin
  ioresult_name(status)
end (* status_name *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if logical_volumes
$ifnone disk_maintenance_code



(************************  internal_to_string  **************************)
(*									*)
(*			       lvol_state				*)
(*									*)
(************************************************************************)

procedure entry LVOL_STATE(
      state	: lvol_states);

begin
  case state of
    INCARNATION_DOWN:		put_string('down         \');
    INCARNATION_READ_WRITE:	put_string('read/write   \');
    INCARNATION_READ_ONLY:	put_string('read only    \');
    INCARNATION_WRITE_ONLY:	put_string('write only   \');
    INCARNATION_OFFLINE:	put_string('offline      \');
    INCARNATION_UNKNOWN:	put_string(UNKNOWN_MESSAGE)
  end
end (* lvol_state *);



(************************  internal_to_string  **************************)
(*									*)
(*				lvol_age				*)
(*									*)
(************************************************************************)

procedure entry LVOL_AGE(
      lvol_age		: logical_volume_age);

begin
  if lvol_age.hours <> 0
  then
    begin (* output hour value if non zero *)
      put_number(lvol_age.hours, 10);
      put_string(' hour\');
      if lvol_age.hours > 1
      then put_character(LOWER_CASE_S);
      put_character(ASCII_SPACE)
    end (* output hour value if non zero *);
  put_scaled_number(lvol_age.scaled_minutes, 10, 2);
  put_string(' minutes old\ ')
end (* get_and_display_lvol_age *);
$endif disk_maintenance_code
$endif logical_volumes
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(************************  internal_to_string  **************************)
(*									*)
(*			    controller_status				*)
(*									*)
(*    Generate controller status message.				*)
(*									*)
(************************************************************************)

procedure entry CONTROLLER_STATUS(
      status		: ioresult;
      status2		: integer;
      isis_value	: integer);

begin
  put_string('controller status: \');
  put_number(status2, 16);
  put_character(ASCII_SPACE);
  case status of
    COMPLETE,
    END_FILE,
    END_MEDIUM,
    START_MEDIUM,
    BREAK_KEY,
    ORANGE_BALL,
    DEVICE_BUSY,
    TIME_OUT: (* NULL *);
    FAILURE,
    TRANSMISSION,
    INTERVENTION,
    PROGRAM_ERROR: put_isis_error(isis_value)
  end (* case *)
end (* controller_status *);



(************************  internal_to_string  **************************)
(*									*)
(*		             put_build_error				*)
(*									*)
(*    Generate build error message from build error number.		*)
(*									*)
(************************************************************************)

procedure put_build_error(
      message_number	: integer);

var
  x : integer;

begin
  put_string(CIRCUIT_BUILD_ERROR);
  x := message_number mod 128 (* remove parity bit *);
  if x > 11
  then put_number(x, 10)
  else
    case x of
      0: put_string('slot 0 will not honor request...try later\');
      1: put_string(FORMAT_ERROR);
      2: put_string(USER_NOT_FOUND);
      3: put_string('bad MUD\');
      4: put_string(SYSTEM_UNAVAILABLE);
      5: put_string('downline load request failure\');
      6: put_string(TIMED_OUT);
      7: put_string('access not permitted\ ');
      8: put_string('out of origination ports\ ');
      9: put_string('sup will not honor request...try later\ ');
      10: put_string('bad requesting host number\ ');
      11: put_string('requesting host not up on requesting node\')
    end (* case *)
end (* put_build_error *);



(************************  internal_to_string  **************************)
(*									*)
(*		             put_on_block				*)
(*									*)
(************************************************************************)

procedure put_on_block(
      block	: univ integer);

begin
  if block >= 0
  then
    begin
      put_string(' on block \ ');
      put_number(block, 10)
    end
end (* put_on_block *);



(************************  internal_to_string  **************************)
(*									*)
(*		               on_block					*)
(*									*)
(************************************************************************)

procedure entry ON_BLOCK(
      block	: univ integer);

begin
  put_on_block(block)
end (* put_on_block *);



(************************  internal_to_string  **************************)
(*									*)
(*		               un2_sup_error				*)
(*									*)
(*    Generate a UN2 error message for supervisor.			*)
(*									*)
(************************************************************************)

procedure entry UN2_SUP_ERROR(
      status	: un2_status;
      result	: ioresult;
      io_error	: integer;
      block	: cud_block_index);

begin
  case status of
    UN2_SUCCESSFUL:       put_string(COMPLETE_MESSAGE);
    UN2_BUSY:		  put_string('circuit in use\ ');
    UN2_BUILD_FAILURE:	  put_build_error(io_error);
    UN2_UNEXPECTED_INPUT: put_string(UNRECOGNIZED_INPUT);
    UN2_TOO_MANY_RETRIES: put_string('too many resends\ ');
    UN2_HANDSHAKE_ERROR:  put_string(HANDSHAKE_ERROR);
$ifnone BEFORE_SUP_V43
    UN2_VERSION_ERROR:	  put_string(VERSION_ERROR);
    UN2_TOO_MANY_DISK_ERRORS: put_string('too many supervisor disk errors\');
    UN2_OPTION_ERROR:	  put_string('Error receiving options\');
$endif BEFORE_SUP_V43
    UN2_CIRCUIT_ERROR:
      begin (* un2_circuit_error *)
        put_string(CIRCUIT_ERROR);
        ioresult_name(result)
      end (* un2_circuit_error *)
  end (* case *);
  if (status = UN2_UNEXPECTED_INPUT) or (status = UN2_TOO_MANY_RETRIES) 
          or (status = UN2_CIRCUIT_ERROR)
$ifnone BEFORE_SUP_V43  	or (status = UN2_TOO_MANY_DISK_ERRORS)
  then put_on_block(block)
end (* un2_sup_error *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code



(************************  internal_to_string  **************************)
(*									*)
(*		             sysmsg1_error				*)
(*									*)
(*    Generate a SYSMSG1 error message.					*)
(*									*)
(************************************************************************)

procedure entry SYSMSG1_ERROR(
      status	: sysmsg1_status;
      result	: ioresult;
      io_error	: integer);

begin
  case status of
    SYSMSG1_SUCCESSFUL:       put_string(COMPLETE_MESSAGE);
    SYSMSG1_BUILD_FAILURE:    put_build_error(io_error);
    SYSMSG1_HANDSHAKE_ERROR:  put_string(HANDSHAKE_ERROR);
    SYSMSG1_CIRCUIT_ERROR:
      begin
        put_string(CIRCUIT_ERROR);
        ioresult_name(result)
      end;
    SYSMSG1_UNEXPECTED_INPUT: put_string(UNRECOGNIZED_INPUT)
  end (* case *)
end (* sysmsg1_error *);
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(************************  internal_to_string  **************************)
(*									*)
(*		           consistency_error				*)
(*									*)
(*    Generate a consistency error message.				*)
(*									*)
(************************************************************************)

procedure entry CONSISTENCY_ERROR(
      block	: cud_block_index;
      status	: consistency_status);

begin
  put_string('Consistency: \');
  case status of
    CONSISTENCY_OK:	put_string('ok\ ');
    UN2_ERROR:		put_string('error on UN2\ ');
    CUD_ERROR:
      begin
        put_string('CUD error\');
	put_on_block(block)
      end (* CUD_ERROR *);
    CONSISTENCY_STOPPED: put_string('halted\ ');
    CONSISTENCY_DONE: put_string(COMPLETE_MESSAGE)
  end (* case *)
end (* consistency_error *);



(************************  internal_to_string  **************************)
(*									*)
(*		       put_checksum_error_on_block			*)
(*									*)
(************************************************************************)

procedure put_checksum_error_on_block(
      block	: univ integer);

begin
  put_string(CHECKSUM_ERROR);
  put_on_block(block)
end (* put_checksum_error_on_block *);



(************************  internal_to_string  **************************)
(*									*)
(*			   put_unit_and_secrtor				*)
(*									*)
(************************************************************************)

procedure put_unit_and_sector(
      unit	: disk_unit_index;
      address	: integer);

begin
  put_string(' (unit: \ '); put_number(unit, 10);
  put_string(' sector \ '); put_number(address, 10);
  put_character(')')
end (* put_unit_and_sector *);



(************************  internal_to_string  **************************)
(*									*)
(*		            cud_block_error				*)
(*									*)
(*    Generate CUD block error message from cud_operation_result.	*)
(*									*)
(************************************************************************)

procedure entry CUD_BLOCK_ERROR(
      block	: univ integer;
      result	: cud_operation_result);

begin
  buffer.size := 0;
  if result = CUD_OPERATION_OK
  then put_string(COMPLETE_MESSAGE)
  else
    begin
      put_string(CUD_FILE_MESSAGE);
      put_character(ASCII_SPACE);
      case result of
        CUD_FILE_LOCKED:		put_string(FILE_BUSY);
        CUD_BLOCK_MANUALLY_LOCKED:	put_string('block locked\ ');
        CUD_CHECKSUM_ERROR:		put_checksum_error_on_block(block);
        CUD_OPERATION_FAILED: 		put_string(IO_FAILURE)
      end (* case *);
      if (result <> CUD_FILE_LOCKED) and (result <> CUD_CHECKSUM_ERROR)
      then
        begin
	  put_on_block(block);
	  put_unit_and_sector(0, MAXIMUM_CUD_BLOCK_SIZE_IN_SECTORS * block)
	end (* (result<>CUD_FILE_LOCKED) and (result<>CUD_CHECKSUM_ERROR) *)
    end (* result <> CUD_OPERATION_OK *)
end (* cud_block_error *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code


(************************  internal_to_string  **************************)
(*									*)
(*		            cud_access_error				*)
(*									*)
(*    Generate CUD access error message from cud_access_status.		*)
(*									*)
(************************************************************************)

procedure entry CUD_ACCESS_ERROR(
      status	: cud_access_status);

begin
  case status of
    CUD_ACCESS_OK:		put_string('block locked successfully\');
    CUD_ACCESS_FILE_LOCKED:	put_string(CUD_FILE_BUSY);
    CUD_ACCESS_BLOCK_SHUT:	put_string(CUD_BLOCK_SHUT)
  end (* case *)
end (* cud_access_error *);



(************************  internal_to_string  **************************)
(*									*)
(*		          named_list_status      			*)
(*									*)
(*      generate message from node_host_utility_status             	*)
(*									*)
(************************************************************************)

procedure entry NAMED_LIST_STATUS(
      last_status	: node_host_utility_status);

begin
  case last_status of
    NODE_HOST_OK:		put_string(ENTRY_COMPLETED);
    NODE_HOST_LIST_NOT_FOUND:	put_string('list not found\ ');
    NODE_HOST_LIST_FOUND:	put_string('list already defined\ ');
    NODE_HOST_BEING_UPDATED:	put_string(ENTRY_BUSY);
    NODE_HOST_LIST_IN_USE:	put_string('\ ') (* not used *);
    NODE_HOST_IO_ERROR:		put_string(IO_FAILURE);
    NODE_HOST_BAD_CHECKSUM:	put_string(CHECKSUM_ERROR);
    NODE_HOST_FULL:		put_string('file full\')
  end
end (* named_list_status *);
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(************************  internal_to_string  **************************)
(*									*)
(*		             cud_entry_status				*)
(*									*)
(*    Generate CUD entry message from cud_entry_result.			*)
(*									*)
(************************************************************************)

procedure entry CUD_ENTRY_STATUS(
      status	: cud_entry_result);

begin
  case status of
    CUD_ENTRY_OK:		put_string(ENTRY_COMPLETED);
    CUD_ENTRY_FILE_LOCKED:	put_string(CUD_FILE_BUSY);
    CUD_ENTRY_LOCKED:       	put_string(ENTRY_BUSY);
    CUD_ENTRY_BLOCK_LOCKED:	put_string(CUD_BLOCK_SHUT);
    CUD_ENTRY_DOES_NOT_FIT: 	put_string('CUD block full\ ');
    CUD_ENTRY_NOT_FOUND:	put_string(USER_NOT_FOUND);
    CUD_NAME_TAKEN:         	put_string('user already exists\');
    CUD_FORMAT_ERROR:       	put_string(FORMAT_ERROR);
    CUD_ENTRY_BAD_CHECKSUM:	put_string(CHECKSUM_ERROR);
    CUD_ENTRY_MUD_CHANGE_FILE_FULL: put_string('MUD_UPDATE full\');
    CUD_ENTRY_MUD_CHANGE_FILE_ERROR:
      put_string('MUD_UPDATE file or disk error\');
    CUD_ENTRY_OPERATION_FAILED: put_string(IO_FAILURE);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if overflow_cud_entries
    CUD_ENTRY_OVERFLOW_FOUND:	put_string('CUD entry overflow\ ');
$endif overflow_cud_entries
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    CUD_ENTRY_IN_WRONG_BLOCK:	put_string('entry in wrong block\ ');
    CUD_ENTRY_ILLEGAL_NAME:	put_string('illegal username\ ')
  end (* case *)
end (* cud_entry_status *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code



(************************  internal_to_string  **************************)
(*									*)
(*			cud_parameter_file_status			*)
(*									*)
(*      Generate the CUD PARAMETER file's status.			*)
(*									*)
(************************************************************************)

procedure entry CUD_PARAMETER_FILE_STATUS(
      status	: cud_parameter_status);

begin
  case status of
    CUD_PARAMETER_BAD_CHECKSUM: put_string(CHECKSUM_ERROR);
    CUD_PARAMETER_IO_ERROR:	put_string(IO_FAILURE)
  end
end (* cud_parameter_file_status *);
$endif disk_maintenance_code
$ifnone disk_maintenance_code



(************************  internal_to_string  **************************)
(*									*)
(*			   logout_explanation				*)
(*									*)
(************************************************************************)

procedure entry LOGOUT_EXPLANATION(
      logout_reason	: logout_cause);

begin
  put_string('validator \ ');
  case logout_reason of
    GENERAL_LOGOUT:	put_string('logged out\ ');
    TIMEDOUT_LOGOUT:	put_string(TIMED_OUT);
    LOST_CIRCUIT_LOGOUT:put_string(LOST_CIRCUIT)
  end (* case *);
  put_colon_space
end (* logout_explanation *);
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(************************  internal_to_string  **************************)
(*									*)
(*			       put_username   				*)
(*									*)
(*	Put a network username in the buffer.				*)
(*									*)
(************************************************************************)

procedure put_username(
      user	: username_string);

var
  i : username_text_index;

begin
  for i := 0 to user.size - 1 do
    put_character(user.text[i])
end (* put_username *);



(************************  internal_to_string  **************************)
(*									*)
(*			       username   				*)
(*									*)
(*	Put a network username in the buffer.				*)
(*									*)
(************************************************************************)

procedure entry USERNAME(
      user	: username_string);

begin
  put_username(user)
end (* username *);
$if INCLUDE_DNIC



(************************  internal_to_string  **************************)
(*									*)
(*			       dnicname   				*)
(*									*)
(*	Put a network dnicname in the buffer.				*)
(*									*)
(************************************************************************)

procedure entry DNICNAME(
      dnic	: dnicname_string);

var
  i : dnicname_index;

begin
  for i := 0 to DNICNAME_LIMIT do
    put_character(dnic[i])
end (* put_username *);
$endif INCLUDE_DNIC



(************************  internal_to_string  **************************)
(*									*)
(*				 number 				*)
(*									*)
(*    Convert a number in any radix to a string.			*)
(*									*)
(************************************************************************)

procedure entry NUMBER(
      number_to_convert	: integer;
      radix		: integer);

begin
  put_number(number_to_convert, radix)
end (* number *);



(*************************  internal_to_string  *************************)
(*									*)
(*				format_number				*)
(*									*)
(*    Convert a number to a string of places_to_print characters.	*)
(*    If 'places_to_print' is negative, display leading zeros.		*)
(*    Otherwise, display leading blanks.				*)
(*									*)
(************************************************************************)

procedure entry FORMAT_NUMBER(
      number_to_convert	: integer;
      radix		: integer;
      places_to_print	: integer);

begin
  put_format_number(number_to_convert, radix, places_to_print)
end (* format_number *);



(************************  internal_to_string  **************************)
(*									*)
(*			       sup_number 				*)
(*									*)
(*    Convert a supervisor_index to a string.				*)
(*									*)
(************************************************************************)

procedure entry SUP_NUMBER(
  real_sup          : real_supervisor_index);

begin
  put_supervisor(real_sup)
end (* sup_number *);



(************************  internal_to_string  **************************)
(*									*)
(*			      scaled_number				*)
(*									*)
(*    Convert a number to a string with a radix point a given number	*)
(*    of places to the left of the right of the number. I.e, a call	*)
(*    of scaled_number(1234, 10, 1) will produce the number 123.4	*)
(*									*)
(************************************************************************)

procedure entry SCALED_NUMBER(
      number_to_convert	: integer;
      radix		: integer;
      radix_place	: integer);

begin
  put_scaled_number(number_to_convert, radix, radix_place)
end (* scaled_number *);



(************************  internal_to_string  **************************)
(*									*)
(*			   number_range 				*)
(*									*)
(*    convert a number range in any radix to a string.			*)
(*									*)
(**************************************************************************)

procedure entry NUMBER_RANGE(
      first_number_to_convert	: integer;	
      last_number_to_convert	: integer;
      radix			: integer);

begin
  put_number(first_number_to_convert, radix);
  if first_number_to_convert <> last_number_to_convert
  then
    begin
      put_character(ASCII_MINUS);
      put_number(last_number_to_convert, radix)
    end
end (* number_range *);



(************************  internal_to_string  **************************)
(*									*)
(*			    report_progress				*)
(*									*)
(*      Report progress to validator and clear counts.			*)
(*									*)
(************************************************************************)

procedure entry REPORT_PROGRESS(
      user_terminal	: circuit_handler;
      block		: univ integer;
      blocks_sent	: integer;
      retries		: integer;
  var line_length	: integer);

begin
  buffer.size := 0;
  put_number(block, 10);
  if (retries <> 0) or (blocks_sent <> 0)
  then
    begin
      put_character(ASCII_COLON);
      put_number(blocks_sent, 10);
      put_character('/');
      put_number(retries, 10)
    end (* (retries <> 0) or (blocks_sent <> 0) *);
  put_character(ASCII_SPACE);
  if (line_length + buffer.size) >= COMMAND_LINE_TEXT_LIMIT
  then
    begin
      user_terminal.write_newline;
      line_length := 0
    end;
  user_terminal.write_format_buffer(buffer);
  line_length := line_length + buffer.size
end (* report_progress *);



(************************  internal_to_string  **************************)
(*									*)
(*			ansii_tape_label_chars  			*)
(*									*)
(************************************************************************)

procedure entry ANSII_TAPE_LABEL_CHARS(
      label		: ansii_tape_label;
      first_char	: ansii_tape_label_index;
      number_of_chars	: ansii_tape_label_size);

var
  label_index : ansii_tape_label_index;

begin
  for label_index := first_char to (first_char + number_of_chars - 1) do
    put_character(label[label_index])
end (* ansii_tape_label_chars *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code



(************************  internal_to_string  **************************)
(*									*)
(*			     host_state_name	  			*)
(*									*)
(************************************************************************)

procedure entry HOST_STATE_NAME(
      state_to_add	: host_state);

begin
  case state_to_add of
    UP_STATE:	put_string('UP\ ');
    DOWN_STATE:	put_string('DOWN\ ');
    SHUT_STATE:	put_string('SHUT\ ');
    GONE_STATE:	put_string('GONE\ ')
  end (* case *)
end (* host_state_name *);
$endif disk_maintenance_code
$if include_non_dmc



(************************  internal_to_string  **************************)
(*									*)
(*			     unit_and_sector				*)
(*									*)
(************************************************************************)

procedure entry UNIT_AND_SECTOR(
      unit	: disk_unit_index;
      address	: integer);

begin
  put_unit_and_sector(unit, address)
end (* unit_and_sector *);
$endif include_non_dmc
(*      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-  *)



(************************  internal_to_string  **************************)
(*									*)
(*			      by_validator				*)
(*									*)
(************************************************************************)

procedure entry BY_VALIDATOR(
      user	: username_string);

begin
  put_string(BY_MESSAGE);
  put_username(user)
end (* by_validator *);



(************************  internal_to_string  **************************)
(*									*)
(*			    command_string				*)
(*									*)
(************************************************************************)

procedure entry COMMAND_STRING(
      name	: command_name);

var
  i : command_name_index;

begin
  i := 0;
  while name[i] <> END_MESSAGE_CHARACTER do
    begin
      put_character(name[i]);
      i := i + 1
    end (* while *)
end (* command_string *);



(************************  internal_to_string  **************************)
(*									*)
(*			    keyword_string				*)
(*									*)
(************************************************************************)

procedure entry KEYWORD_STRING(
      name	: keyword_name);

var
  i : keyword_name_index;

begin
  i := 0;
  while name[i] <> END_MESSAGE_CHARACTER do
    begin
      put_character(name[i]);
      i := i + 1
    end (* while *)
end (* keyword_string *);



(************************  internal_to_string  **************************)
(*									*)
(*				prompt	  				*)
(*									*)
(************************************************************************)

procedure entry PROMPT(
  var string_to_insert	: command_prompt);

var
  i : command_prompt_text_index;

begin
  i := 0;
  while string_to_insert[i] <> END_MESSAGE_CHARACTER do
    begin
      put_character(string_to_insert[i]);
      i := i + 1
    end (* while *)
end (* prompt *);



(***********************  internal_to_string  ***************************)
(*									*)
(*				 string 				*)
(*									*)
(*    Put string into buffer.						*)
(*									*)
(************************************************************************)

procedure entry STRING(
      string_to_insert	: quoted_text);

begin
  put_string(string_to_insert)
end (* string *);



(***********************  internal_to_string  ***************************)
(*									*)
(*			  string_from_buffer 				*)
(*									*)
(*    Get string from buffer.						*)
(*									*)
(************************************************************************)

procedure entry STRING_FROM_BUFFER(
  var string_to_get	: quoted_text);

begin
  get_string(string_to_get)
end (* string_from_buffer *);



(***********************  internal_to_string  ***************************)
(*									*)
(*			   help_text_string 				*)
(*									*)
(*    Put help_text into buffer.					*)
(*									*)
(************************************************************************)

procedure entry HELP_TEXT_STRING(
      string_to_insert	: help_string);

var
  i : help_text_index;

begin
  i := 0;
  while string_to_insert[i] <> END_MESSAGE_CHARACTER do
    begin
      put_character(string_to_insert[i]);
      i := i + 1
    end (* while *)
end (* help_text_string *);



(***********************  internal_to_string  ***************************)
(*									*)
(*			     colon_space				*)
(*									*)
(*    Put colon, space in buffer.					*)
(*									*)
(************************************************************************)

procedure entry COLON_SPACE;

begin
  put_colon_space
end (* colon_space *);



(***********************  internal_to_string  ***************************)
(*									*)
(*				 newline				*)
(*									*)
(*    Put carriage return linefeed in buffer.				*)
(*									*)
(************************************************************************)

procedure entry NEWLINE;

begin
  put_newline
end (* newline *);



(************************  internal_to_string  **************************)
(*									*)
(*				  skip					*)
(*									*)
(*    Skip n blanks in buffer. If n is negative, set buffer size.	*)
(*									*)
(************************************************************************)

procedure entry SKIP(
      n	: integer);

var
  i : integer;

begin
  if n > 0
  then
    for i := 1 to n do
      put_character(ASCII_SPACE)
  else buffer.size := buffer.size+n
end (* skip *);



(************************  internal_to_string  **************************)
(*									*)
(*				skip_to 				*)
(*									*)
(*    Skip to position n in buffer.					*)
(*									*)
(************************************************************************)

procedure entry SKIP_TO(
      n	: integer);

var
  i : integer;

begin
  if n > buffer.size
  then
    for i := 1 to n - buffer.size do
      put_character(ASCII_SPACE)
  else buffer.size := n
end (* skip_to *);



(***********************  internal_to_string  ***************************)
(*									*)
(*				character				*)
(*									*)
(*    Put single character in buffer.					*)
(*									*)
(************************************************************************)

procedure entry CHARACTER(
      c	: char);

begin
  put_character(c)
end (* character *);



(***********************  internal_to_string  ***************************)
(*									*)
(*				  start 				*)
(*									*)
(*    Start the buffer at the beginning.				*)
(*									*)
(************************************************************************)

procedure entry START;

begin
  buffer.size := 0
end (* start *);



(***********************  internal_to_string  ***************************)
(*									*)
(*			    start_message				*)
(*									*)
(*    Start the buffer at the beginning and insert a message.		*)
(*									*)
(************************************************************************)

procedure entry START_MESSAGE(
      message_to_insert	: quoted_text);

begin
  buffer.size := 0;
  put_string(message_to_insert)
end (* start_message *);



(***********************  internal_to_string  ***************************)
(*									*)
(*			 do_start_and_newline				*)
(*									*)
(*    Start the buffer at the beginning and insert a newline.		*)
(*									*)
(************************************************************************)

procedure do_start_and_newline;

begin
  buffer.size := 0;
  put_newline
end (* do_start_and_newline *);



(***********************  internal_to_string  ***************************)
(*									*)
(*			  start_and_newline				*)
(*									*)
(*    Start the buffer at the beginning and insert a newline.		*)
(*									*)
(************************************************************************)

procedure entry START_AND_NEWLINE;

begin
  do_start_and_newline
end (* start_and_newline *);



(***********************  internal_to_string  ***************************)
(*									*)
(*			  start_line_message				*)
(*									*)
(*    Start the buffer at the beginning and insert a newline and	*)
(*    a message.							*)
(*									*)
(************************************************************************)

procedure entry START_LINE_MESSAGE(
      message_to_insert	: quoted_text);

begin
  do_start_and_newline;
  put_string(message_to_insert)
end (* start_line_message *);



(***********************  internal_to_string  ***************************)
(*									*)
(*			     write_block				*)
(*									*)
(*    Write buffer to given terminal as a block.			*)
(*									*)
(************************************************************************)

procedure entry WRITE_BLOCK(
      circuit	: circuit_handler);

begin
  circuit.write_format_buffer(buffer)
end (* write_block *);


(***********************  internal_to_string  ***************************)
(*									*)
(*			      write_line				*)
(*									*)
(*    Write current buffer to given circuit as a line.			*)
(*									*)
(************************************************************************)

procedure entry WRITE_LINE(
      circuit	: circuit_handler);

begin
  put_newline;
  circuit.write_format_buffer(buffer)
end (* write_line *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code

 

(************************  internal_to_string  **************************)
(*									*)
(*			     report_file_error				*)
(*									*)
(************************************************************************)

procedure entry REPORT_FILE_ERROR(
      file		: file_index;
      operation_message	: quoted_text;
      page_no		: univ integer;
      user_terminal	: circuit_handler);

begin
  buffer.size := 0;
  put_string('Error in \');
  put_string(operation_message);
  put_character(ASCII_SPACE);
  put_file_name(file);
  put_string(' page \ ');
  put_number(page_no, 10);
  put_newline;
  user_terminal.write_format_buffer(buffer)
end (* report_file_error *);
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(************************  internal_to_string  **************************)
(************************************************************************)

begin (* initial statement *)
  init calendar
end (* internal_to_string *);
!
(************************************************************************)
(*									*)
(*	PASS.NTV							*)
(*			    password_reader				*)
(*									*)
(*    This class handles the reading and checking of a password text,	*)
(*    and the optional conversion to a cipher.				*)
(*									*)
(*     The following identifiers must be defined externally:		*)
(*	 password_string, password_text_index				*)
(*									*)
(************************************************************************)
(*									*)
(*			     Revision Record				*)
(*									*)
(*	21Sep88 - jrn							*)
(*		- add code for prevent_duplicate_passwords		*)
(*	12Sep88 - jrn							*)
(*		- eliminate call to READ_PASSWORD_STRING in		*)
(*		  user_terminal, and use READ_COMMAND_LINE instead,	*)
(*		  so that error message about maximum password length	*)
(*		  can be output						*)
(*		- if PASSWORD_RESTRICTED_TO_FIPS_1_2 is ENabled,	*)
(*		  restrict password characters to the 95 characters	*)
(*		  described in FIPS PUB 1-2 (minus the semi-colon).	*)
(*	31Jan87 - rsb							*)
(*		- add processing of use_exit_time and exit_time to	*)
(*		  GET_NEW_CIPHER					*)
(*		- change prompr in CIPHERED_PASSWORD from		*)
(*		  "enter password" to "password"			*)
(*	04Mar85 - jrn							*)
(*	      - add name argument to get_new_cipher routine if		*)
(*		name_legal_password is disabled				*)
(*	07aug84 Version 3.00						*)
(*	      - changed function legal_password to call 		*)
(*		password_cipher_utility routine, illegal_alpha_password *)
(*	06jul93 Original -- from (patrol)pass.ntc - jrn			*)
(*									*)
(************************************************************************)



type PASSWORD_READER = class(
	mutil		: misc_utility;
	format		: internal_to_string;
	user_terminal	: circuit_handler);


var
  cipher_password: password_cipher_utility;



(*************************  password_reader  ****************************)
(*									*)
(*				 match					*)
(*									*)
(*    Test if two password strings are the same.			*)
(*									*)
(************************************************************************)

function match(
      first	: password_string;
      second	: password_string) : boolean;

var
  i: password_text_index;

begin
  match := TRUE;
  if first.size <> second.size then match := FALSE
  else
    for i := 0 to first.size - 1 do
      if first.text[i] <> second.text[i] then match := FALSE
end (* match *);



(*************************  password_reader  ****************************)
(*									*)
(*			    legal_password				*)
(*									*)
(************************************************************************)

function legal_password(
      new_password	: password_string) : boolean;

var
  index : password_text_index;
  illegal : boolean;

begin
  legal_password := FALSE; illegal := FALSE;
  if (MINIMUM_PASSWORD_SIZE > 0) and
    (new_password.size < MINIMUM_PASSWORD_SIZE)
  then
    begin
      illegal := TRUE;
      format.start_line_message('passwords must be a minimum of \');
      format.number(MINIMUM_PASSWORD_SIZE, 10);
      format.string(' characters\');
      format.write_line(user_terminal)
    end
  else
    for index := 0 to new_password.size - 1 do
      if new_password.text[index] = ASCII_SEMI_COLON
      then
        begin
  	  illegal := TRUE;
	  user_terminal.write_line_and_quoted_text_line(
	    'semicolon is an illegal password character\ ')
	end (* password character is a semi-colon, its illegal *)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if password_restricted_to_fips_1_2
      else
        if (new_password.text[index] > '~') or
	  (new_password.text[index] < ASCII_SPACE)
	then
	  begin
	    illegal := TRUE;
	    format.start_line_message(
	      'the character with the decimal ASCII value \');
	    format.number(ord(new_password.text[index]), 10);
	    format.string(' is an illegal password character\');
	    format.write_line(user_terminal)
	  end (* password character is an illegal character *)
$endif password_restricted_to_fips_1_2
$if password_restricted_from_pad
        else
	  if (new_password.text[index] in
	        [ASCII_COMMA, ASCII_DOT, ASCII_MINUS, '+'])
	  then
	    begin
	      illegal := TRUE;
	      format.start_line_message(
	        'the pad terminate character \ ');
	      format.character(new_password.text[index]);
	      format.string(' is an illegal password character\');
	      format.write_line(user_terminal)
	    end
$endif password_restricted_from_pad
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
;
  if not illegal
  then
    if cipher_password.illegal_alpha_password(new_password)
    then user_terminal.write_line_and_quoted_text_line(
      'password must contain at least one nonalphanumeric character\ ')
    else legal_password := TRUE (* all chars check out ok *)
end (* legal_password *);



(*************************  password_reader  ****************************)
(*									*)
(*			     read_password				*)
(*									*)
(*    Read password from terminal turning echo off during read. 	*)
(*									*)
(************************************************************************)

procedure read_password(
      first_cipher	: boolean;
      prompt		: quoted_text;
  var new_cipher	: integer);

var
  done : boolean;
  temp_line : command_line;
  temp_ptr : command_line_text_index;
  password : password_string;
  password_ptr : password_text_index;

begin
  done := FALSE;
  repeat
    user_terminal.set_echo(FALSE);
    user_terminal.write_quoted_text(prompt);
    user_terminal.read_command_line(temp_line);
    temp_line.size := temp_line.size - 1 (* eliminate Carriage return *);
    user_terminal.write_newline;
    user_terminal.set_echo(TRUE);
    if temp_line.size > MAXIMUM_PASSWORD_SIZE
    then
      begin
	format.start_line_message('passwords may be a maximum of \ ');
	format.number(MAXIMUM_PASSWORD_SIZE, 10);
	format.string(' characters\');
	format.write_line(user_terminal)
      end
    else
      begin (* length of password entered was not greater than max allowed *)
        temp_ptr := 0;
        for password_ptr := 0 to temp_line.size - 1 do
	  begin (* move characters to password string and make upper case *)
	    password.text[password_ptr] := temp_line.text[temp_ptr];
	    temp_ptr := temp_ptr + 1;
	    mutil.make_character_upper_case(password.text[password_ptr])
	  end (* move characters to password string and make upper case *);
	password.size := temp_line.size;
	new_cipher := cipher_password.convert(password);
	if not first_cipher
	then done := TRUE
	else
	  if legal_password(password)
	  then done := TRUE
      end (* length of password entered was not greater than max allowed *)
  until done or not user_terminal.sendable
end (* read_password *);



(*************************  password_reader  ****************************)
(*									*)
(*			    get_new_cipher				*)
(*									*)
(*    Read a new password from terminal and do it twice to insure	*)
(*    it is the same. Return the new password cipher if successful.	*)
(*									*)
(************************************************************************)

procedure entry GET_NEW_CIPHER(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone name_legal_password       name		: username_string;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      old_cipher	: integer;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if prevent_duplicate_passwords       previous_cipher	: integer;
$if global_password_only_login
      exit_time		: integer;
      use_exit_time	: boolean;
$endif global_password_only_login
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  var new_cipher	: integer;
  var success		: boolean);

var
  attempt_count	: integer;
  retry 	: integer;
  new_timeout	: integer;
  done		: boolean;

begin (* get_new_cipher *)
  attempt_count := 0;
  done := FALSE;
  success := FALSE;
  while not done and user_terminal.sendable do
    begin
      read_password(TRUE, PASSWORD_MESSAGE, new_cipher);
      if user_terminal.sendable
      then
        begin (* check for acceptable password *)
          if new_cipher = old_cipher
	  then user_terminal.write_line_and_quoted_text_line(
	    'new password matches old password\')
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone name_legal_password
	  else
	    if cipher_password.ciphered_name(name) = new_cipher
	    then user_terminal.write_line_and_quoted_text_line(
	      'new password matches name\')
$endif name_legal_password
$if prevent_duplicate_passwords
	    else
	      if new_cipher = previous_cipher
	      then user_terminal.write_line_and_quoted_text_line(
	        PREVIOUS_PASSWORD_MESSAGE)
$endif prevent_duplicate_passwords
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	      else
		if (new_cipher = GFD_ONLY_PASSWORD)
$if force_password_change 		  or (new_cipher = FPC_PASSWORD_CIPHER)
		then user_terminal.write_line_and_quoted_text_line(
		  'password unacceptable, try another\ ')
		else
		  begin (* get password a second time *)
$if change_by_whom
" added global_password_only_login by SHSUE at 9-Jul-87 17:30:37"
$endif
$if global_password_only_login
    	      if use_exit_time
	      then
	        begin (* set new timeout value for password only users *)
                  new_timeout := exit_time - REALTIME;
		  if new_timeout > 1
  		  then user_terminal.set_timeout(new_timeout)
		  else done := TRUE
		end (* set new timeout value for password only users *);
$endif global_password_only_login

	      if not done
	      then
		begin (* prompt for password re-entry *)
	          read_password(FALSE, 'enter it again:\', retry);
	          if new_cipher = retry
	          then
		    begin (* success at last *)
		      done := TRUE;
		      success := TRUE
		    end (* success at last *)
	          else user_terminal.write_line_and_quoted_text_line(
		    'passwords do not match,\');
		end (* prompt for password re-entry *)
		  end (* get password a second time *);
$if change_by_whom
" added gloabl_password_only_login by SHSUE at 9-Jul-87 17:31:42"
$endif
$if global_password_only_login
          if use_exit_time
          then
            if not done
            then
              begin (* compute new timeout and check attempt count *)
$if change_by_whom
(**  updated by SHSUE at 19-May-87 17:01:21				**)
(**  change d GLOBAL_PASSWORD_ONLY_ATTEMP_MAX to GPO_ATTEMPT_MAX	**)
$endif
                if attempt_count = GPO_ATTEMPT_MAX
                then done := TRUE
	        else attempt_count := attempt_count + 1;
		if not done
		then
		  begin (* set new timeout value for password only users *)
                    new_timeout := exit_time - REALTIME;
		    if new_timeout > 1
  		    then user_terminal.set_timeout(new_timeout)
		    else done := TRUE
		  end (* set new timeout value for password only users *)
              end (* compute new timeout and check attempt count *)
$endif global_password_only_login
         end (* check for acceptable password *)
    end (* while not done and user_terminal.sendable *);

$if change_by_whom
" added global_password_only_login by SHSUE at 10-Jul-87 9:06:49"
$endif
$if global_password_only_login
  if use_exit_time
  then user_terminal.set_timeout(TERMINAL_TIMEOUT * 60)
$endif global_password_only_login
end (* get_new_cipher *);



(*************************  password_reader  ****************************)
(*									*)
(*			      ciphered_password				*)
(*									*)
(*	Read a password from the terminal and return the cipher.	*)
(*	Used for programmer WRITE commands and programmer logging in	*)
(*	through auxilliary circuits.					*)
(*									*)
(************************************************************************)

function entry CIPHERED_PASSWORD : integer;

var
  new_cipher : integer;

begin
  read_password(FALSE, PASSWORD_MESSAGE, new_cipher);
  ciphered_password := new_cipher
end (* ciphered_password *);



(*************************  password_reader  ****************************)
(************************************************************************)


begin (* initial statement *)
  init cipher_password(mutil)
end (* password_reader *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if logical_volumes
!
(************************************************************************)
(*									*)
(*	LVUTIL.NTV							*)
(*									*)
(*			    lvol_utility				*)
(*									*)
(*	This class performs logical volume operations other than	*)
(*	LVOL_READ and LVOL_WRITE (INIT, LVOL_SETOP and LVOL_INFO)	*)
(*	and maintains information about releationships between		*)
(*	incarnations and their lvol_disk_unit_index.			*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*		Original - pgl						*)
(*									*)
(************************************************************************)

type LVOL_UTILITY = class;


var
  crash_util : crash_utility;



(***************************  lvol_utility  *****************************)
(*									*)
(*			   incarnation_for_unit				*)
(*									*)
(************************************************************************)

function incarnation_for_unit(
      unit	: lvol_disk_unit_index) : incarnation_index;

begin
  case unit of
    CUD_DISK_UNIT:	incarnation_for_unit := 0;
    FILE_SYSTEM_DISK:	incarnation_for_unit := 0;
    CUD_DISK_UNIT2:	incarnation_for_unit := 1;
    FILE_SYSTEM_DISK2:	incarnation_for_unit := 1
  end (* case *)
end (* incarnation_for_unit *);



(***************************  lvol_utility  *****************************)
(*									*)
(*			    this_incarnation				*)
(*									*)
(************************************************************************)

function entry THIS_INCARNATION(
      unit	: lvol_disk_unit_index) : incarnation_index;

begin
  this_incarnation := incarnation_for_unit(unit)
end (* this_incarnation *);



(***************************  lvol_utility  *****************************)
(*									*)
(*			   first_incarnation_disk			*)
(*									*)
(************************************************************************)

function first_incarnation_disk(
      incarnation	: incarnation_index) : lvol_disk_unit_index;

begin
  case incarnation of
    0: first_incarnation_disk := CUD_DISK_UNIT;
    1: first_incarnation_disk := CUD_DISK_UNIT2
  end (* case *)
end (* first_incarnation_disk *);



(***************************  lvol_utility  *****************************)
(*									*)
(*			 first_incarnation_disk_unit			*)
(*									*)
(************************************************************************)

function entry FIRST_INCARNATION_DISK_UNIT(
      incarnation	: incarnation_index) : lvol_disk_unit_index;

begin
  first_incarnation_disk_unit := first_incarnation_disk(incarnation)
end (* first_incarnation_disk_unit *);



(***************************  lvol_utility  *****************************)
(*									*)
(*			    disk_unit_partner				*)
(*									*)
(************************************************************************)

function disk_unit_partner(
      unit	: lvol_disk_unit_index) : lvol_disk_unit_index;

begin
  case unit of
    CUD_DISK_UNIT:	disk_unit_partner := FILE_SYSTEM_DISK;
    FILE_SYSTEM_DISK:	disk_unit_partner := CUD_DISK_UNIT;
    CUD_DISK_UNIT2:	disk_unit_partner := FILE_SYSTEM_DISK2;
    FILE_SYSTEM_DISK2:	disk_unit_partner := CUD_DISK_UNIT2
  end (* case *)
end (* disk_unit_partner *);



(***************************  lvol_utility  *****************************)
(*									*)
(*			      unit_partner				*)
(*									*)
(************************************************************************)

function entry UNIT_PARTNER(
      unit	: lvol_disk_unit_index) : lvol_disk_unit_index;

begin
  unit_partner := disk_unit_partner(unit)
end (* unit_partner *);



(***************************  lvol_utility  *****************************)
(*									*)
(*			      lvol_partner				*)
(*									*)
(************************************************************************)

function entry LVOL_PARTNER(
      incarnation	: incarnation_index) : incarnation_index;

begin
  case incarnation of
    0: lvol_partner := 1;
    1: lvol_partner := 0
  end (* case *)
end (* lvol_partner *);



(*****************************  lvol_utility  ***************************)
(*									*)
(*			       set_unit_state				*)
(*									*)
(*      Sets unit to specified state.					*)
(*									*)
(************************************************************************)

procedure set_unit_state(
      unit		: lvol_disk_unit_index;
      state_flag	: lvol_set_state_flags);

var
  dummy_buffer	: char;
  param		: lvol_param;
  dummy_unit	: integer;

begin
  param.operation := LVOL_SETOP;
  param.arg2 := state_flag;
  param.arg1 := unit;
  io(dummy_buffer, param, LVOL, dummy_unit);
  if param.status <> COMPLETE
  then crash_util.halt_slot
end (* set_unit_state *);



(*****************************  lvol_utility  ***************************)
(*									*)
(*			   set_incarnation_state			*)
(*									*)
(*      Sets both units of incarnation to state_flag.			*)
(*									*)
(************************************************************************)

procedure set_incarnation_state(
      incarnation	: incarnation_index;
      state_flag	: lvol_set_state_flags);

var
  unit : lvol_disk_unit_index;

begin
  unit := first_incarnation_disk(incarnation);
  set_unit_state(unit, state_flag);
  set_unit_state(disk_unit_partner(unit), state_flag)
end (* set_state *);



(*****************************  lvol_utility  ***************************)
(*									*)
(*			         set_state				*)
(*									*)
(*      Sets specified incarnation to state_flag.			*)
(*									*)
(************************************************************************)

procedure entry SET_STATE(
      incarnation	: incarnation_index;
      state_flag	: lvol_set_state_flags);

begin
  set_incarnation_state(incarnation, state_flag)
end (* set_state *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code



(****************************  lvol_utility  ****************************)
(*									*)
(*			     lvol_information				*)
(*									*)
(*      Returns with lvol disk info					*)
(*									*)
(************************************************************************)

procedure entry LVOL_INFORMATION(
  var info_buffer	: lvol_info_buffer);

var
 dummy_unit : integer;
 param : lvol_param;

begin
  param.arg1 := lvol_info_buffer_size (* number of bytes in buffer *);
  param.operation := LVOL_INFO;
  io(info_buffer, param, LVOL, dummy_unit);
  if param.status <> COMPLETE
  then crash_util.halt_slot
end (* lvol_information *);
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(****************************  lvol_utility  ****************************)
(*									*)
(*			        initialize				*)
(*									*)
(*      Initializes lvol and sets incarnation to set_flag (other	*)
(*	incarnation is set to read/write).				*)
(*									*)
(************************************************************************)

procedure entry INITIALIZE(
      incarnation	: incarnation_index;
      set_flag		: lvol_set_state_flags);

 var
  init_buffer	: lvol_soft_init_buffer;
  param		: lvol_param;
  dummy_unit	: integer;
  unit	: lvol_disk_unit_index;

begin
  for unit := 0 to LVOL_DISK_UNIT_LIMIT do (* set up init_buffer for INIT *)
    with init_buffer[unit] do
      begin
        pv_unit := unit		(* this Pascal unit number *);
	lv_unit := LVOL_UNIT	(* only one logical volume *);
	inc_number := incarnation_for_unit(unit)
      end (* with *);
  param.arg2 := LOCK_FOR_INIT (* lock unit so we can set things up *);
  param.arg1 := LVOL_DISK_UNIT (* number of Pascal units *);
  param.operation := LVOL_SOFT_SETOP_INIT;
  io(init_buffer, param, LVOL, dummy_unit);

  if param.status <> COMPLETE
  then crash_util.halt_slot;
  set_incarnation_state(incarnation, set_flag);

  param.arg2 := UNLOCK_FOR_INIT;
  io(init_buffer, param, LVOL, dummy_unit);
  if param.status <> COMPLETE
  then crash_util.halt_slot
end (* initialize *);



(************************************************************************)
(************************************************************************)

begin (* initial statement *)
  init crash_util
end (* lvol_utility *);
$endif (* logical_volumes *)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
(**********************************************************************)
(*                                                                    *)
(*	STAT.NTV						      *)
(*                        statistics_gatherer                         *)
(*                                                                    *)
(*    This monitor gathers and prints program running statistics.     *)
(*    This includes disk read/write statistics.                       *)
(*                                                                    *)
(*     The following identifiers must be defined externally:          *)
(*       disk_param                                                   *)
(*       page_size                                                    *)
(*                                                                    *)
(**********************************************************************)
(*                                                                    *)
(*                           Revision Record                          *)
(*                                                                    *)
(*	21Oct87 Version 5.00 - neh				      *)
(*	     - change UTC to UTC				      *)
(*	14Oct84 Version 3.00 - pgl				      *)
(*	      - add conditional assembly parameter logical_volumes    *)
(*	21May84	2.02 - jrn					      *)
(*	      - fix bug in second argument to initialize FIFO	      *)
(*     29SEP83    Original from (patrol)stat.tms - jrn                *)
(*                                                                    *)
(**********************************************************************)


type STATISTICS_GATHERER = monitor;


const
  histogram_interval = 300 (* seconds *);

  bar_max = 12 (* bars in a histogram *);
  bar_limit = bar_max - 1;

type
  bar_index = 0..bar_max;

  histogram = array [bar_index] of integer;

  disk_statistic_operation =
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if logical_volumes
$ifnone disk_maintenance_code     lvol_read..lvol_write;
$if disk_maintenance_code     disk_read..disk_write;
$endif logical_volumes
$ifnone logical_volumes     disk_read..disk_write;
$if disk_maintenance_code

const
  save_error_max = 4 (* disk errors *);
  save_error_limit = save_error_max - 1;

type
  save_error_index = 0..save_error_limit;

var
  next_error : fifo;
$endif disk_maintenance_code
$ifnone logical_volumes
$ifnone disk_maintenance_code
const
  save_error_max = 4 (* disk errors *);
  save_error_limit = save_error_max - 1;

type
  save_error_index = 0..save_error_limit;

var
  next_error: fifo;
$endif disk_maintenance_code
$endif logical_volumes
$if logical_volumes
$ifnone disk_maintenance_code
var
  lv_utility : lvol_utility;
$endif disk_maintenance_code
$endif logical_volumes
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  current_bar : integer;
  current_time : integer;
  start_time : integer;
  disk_statistic:
    array [disk_statistic_operation] of
      record
	count		: integer (* number of operations *);
	page_access	: integer (* number of pages operated on *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code
	errors		: integer (* no. of disk errors *);
$endif disk_maintenance_code
$ifnone logical_volumes
$ifnone disk_maintenance_code
	errors		: integer (* no. of disk errors *);
$endif disk_maintenance_code
$endif logical_volumes
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	history		: histogram
      end (* disk_statistic *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone logical_volumes
$ifnone disk_maintenance_code
  error : array [save_error_index] of
    record
      when  : integer (* when error occurred *);
      call  : disk_param (* param of io call *);
      value : disk_param (* param set by io call *)
    end (* errors *);
$endif disk_maintennance_code
$endif logical_volumes
$if disk_maintenance_code
  error : array [save_error_index] of
    record
      when  : integer (* when error occurred *);
      call  : disk_param (* param of io call *);
      value : disk_param (* param set by io call *)
    end (* errors *);
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(***********************  statistics_gatherer  ************************)
(*                                                                    *)
(*                             initialize                             *)
(*                                                                    *)
(*    Initialize all statistics to zero and set start time to now.    *)
(*                                                                    *)
(**********************************************************************)

procedure initialize;

var
  i : bar_index;
  j : disk_statistic_operation;

begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code   init next_error(0, SAVE_ERROR_LIMIT);
$ifnone logical_volumes
$ifnone disk_maintenance_code   init next_error(0, SAVE_ERROR_LIMIT);
$endif logical_volumes
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  current_bar := 0;
  current_time := REALTIME;
  start_time := current_time;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone logical_volumes   for j := DISK_READ to DISK_WRITE do
$if logical_volumes
$ifnone disk_maintenance_code   for j := LVOL_READ to LVOL_WRITE do
$if disk_maintenance_code   for j := DISK_READ to DISK_WRITE do
$endif logical_volumes
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    with disk_statistic[j] do
      begin
	count := 0;
	page_access := 0;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code       	errors := 0;
$ifnone logical_volumes
$ifnone disk_maintenance_code        	errors := 0;
$endif logical_volumes
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	for i := 0 to BAR_LIMIT do
	  history[i] := 0
      end (* with *)
end (* initialize *);



(***********************  statistics_gatherer  ************************)
(*                                                                    *)
(*                          print_histogram                           *)
(*                                                                    *)
(*    Print the given histogram on one line allowing six positions    *)
(*    for each number.                                                *)
(*                                                                    *)
(**********************************************************************)

procedure print_histogram(
      history		: histogram;
      format		: internal_to_string;
      user_terminal	: circuit_handler);

var
  i : bar_index;

begin
  format.start;
  for i := 0 to BAR_LIMIT do
    begin
      format.skip_to(i*6);
      format.number(history[(current_bar+1+i) mod BAR_MAX], 10)
    end (* for *);
  format.write_line(user_terminal)
end (* print_histogram *);



(***********************  statistics_gatherer  ************************)
(*                                                                    *)
(*                          set_current_bar                           *)
(*                                                                    *)
(*    Set the current_time for histograms and move bar to this time.  *)
(*                                                                    *)
(**********************************************************************)

procedure set_current_bar;

var
  i : disk_statistic_operation;
  j,
  n,
  new_bar: integer;

begin
  current_time := REALTIME;
  new_bar := (current_time-start_time) div HISTOGRAM_INTERVAL;
  n := new_bar-current_bar;
  if n > 0
  then
    begin
      if n > BAR_MAX
      then n := BAR_MAX;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone logical_volumes       for i := DISK_READ to DISK_WRITE do  
$if logical_volumes
$if disk_maintenance_code       for i := DISK_READ to DISK_WRITE do
$ifnone disk_maintenance_code       for i := LVOL_READ to LVOL_WRITE do
$endif logical_volumes
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	with disk_statistic[i] do
	  for j := 1 to n do
	    history[(current_bar+j) mod BAR_MAX] := 0;
      current_bar := new_bar
    end
end (* set_current_bar *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if logical_volumes
$ifnone disk_maintenance_code



(***********************  statistics_gatherer  ************************)
(*                                                                    *)
(*                           report_lv_copy                           *)
(*                                                                    *)
(*    This entry is called whenever a lvol copy operation is done.    *)
(*    The parameter of the actual operation is passed.                *)
(*                                                                    *)
(**********************************************************************)

procedure entry REPORT_LV_COPY(
      call_param	: lvol_copy_param);

var
  j	  : bar_index;
  operation : disk_statistic_operation;

begin
  set_current_bar;
  for operation := LVOL_READ to LVOL_WRITE do
    with disk_statistic[operation] do
      begin
        count := count+1;
	page_access := page_access+(call_param.byte_count div PAGE_SIZE);
	j := current_bar mod BAR_MAX;
	history[j] := history[j]+1
      end (* with *)
end (* report_lv_copy *);
$endif disk_maintenance_code
$endif logical_volumes
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(***********************  statistics_gatherer  ************************)
(*                                                                    *)
(*                           report_disk_io                           *)
(*                                                                    *)
(*    This entry is called whenever a disk io is done. The parameter  *)
(*    of the actual operation is passed.                              *)
(*                                                                    *)
(**********************************************************************)

procedure entry REPORT_DISK_IO(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if logical_volumes
$ifnone disk_maintenance_code
      call_param	: lvol_io_param);
$endif disk_maintenance_code
$if disk_maintenance_code
      call_param	: disk_param;
      value_param	: disk_param);
$endif disk_maintenance_code
$endif logical_volumes
$ifnone logical_volumes
      call_param	: disk_param;
      value_param	: disk_param);
$endif logical_volumes
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

var
  j	  : bar_index;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone logical_volumes
$ifnone disk_maintenance_code  discard : save_error_index;
$endif logical_volumes
$if disk_maintenance_code  discard : save_error_index;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

begin
  set_current_bar;
  with call_param, disk_statistic[operation] do
    begin
      count := count+1;
      page_access := page_access+(byte_count div PAGE_SIZE);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone logical_volumes
$ifnone disk_maintenance_code
      if value_param.status <> COMPLETE
      then errors := errors+1;
$endif disk_maintenance_code
$endif logical_volumes
$if disk_maintenance_code
      if value_param.status <> COMPLETE
      then errors := errors+1;
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      j := current_bar mod BAR_MAX;
      history[j] := history[j]+1
    end (* with *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code
  if value_param.status <> COMPLETE
  then
    begin
      if next_error.full then discard := next_error.departure;
      with error[next_error.arrival] do
	begin
	  when := REALTIME;
	  call := call_param;
	  value := value_param
	end (* with *)
    end
$endif disk_maintenance_code
$ifnone logical_volumes
$ifnone disk_maintenance_code
  if value_param.status <> COMPLETE
  then
    begin
      if next_error.full
      then discard := next_error.departure;
      with error[next_error.arrival] do
	begin
	  when := REALTIME;
	  call := call_param;
	  value := value_param
	end (* with *)
    end
$endif disk_maintenance_code
$endif logical_volumes
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
end (* report_disk_io *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if logical_volumes
$if disk_maintenance_code



(************************  statistics_gatherer  *************************)
(*									*)
(*			     format_error_line				*)
(*									*)
(************************************************************************)

procedure format_error_line(
      format		: internal_to_string;
      user_terminal	: circuit_handler);

const
  operation_column = 18;
  status_column    = operation_column+10;
  address_column   = status_column+13;
  count_column	   = address_column+8;
  transfer_column  = count_column+6;
  isis_column	   = transfer_column+9;
  status2_column   = isis_column+5;

begin
  if not next_error.empty
  then
    begin
      with format do
        begin
	  start_line_message('when\ ');
	  skip_to(operation_column);
	  string('operation\');
	  skip_to(status_column);
	  string('status\ ');
	  skip_to(address_column);
	  string('address\');
	  skip_to(count_column);
	  string('count\');
	  skip_to(transfer_column);
	  string('transfer\ ');
	  skip_to(isis_column);
	  string('isis\ ');
	  skip_to(status2_column);
	  string('status2\');
	  write_line(user_terminal)
	end (* with *);
      repeat
	with error[next_error.departure], format do
	  begin
	    start;
	    time(when);
	    skip_to(operation_column);
	    disk_operation_name(call.operation);
	    skip_to(status_column);
	    status_name(value.status);
	    skip_to(address_column);
	    number(call.start_addr, 16);
	    skip_to(count_column);
	    number(call.byte_count, 10);
	    skip_to(transfer_column);
	    number(value.start_addr, 10);
	    skip_to(isis_column);
	    number(value.byte_count, 10);
	    skip_to(status2_column);
	    number(value.status2, 16);
	    write_line(user_terminal)
	  end (* with *)
      until next_error.empty
    end
end (* format_error_line *);
$endif disk_maintenance_code
$endif logical_volumes



(************************  statistics_gatherer  *************************)
(*									*)
(*			     write_first_line				*)
(*									*)
(************************************************************************)

procedure write_first_line(
      format		: internal_to_string;
      i			: disk_statistic_operation;
      user_terminal	: circuit_handler);

begin
  with disk_statistic[i], format do
    begin
      start_and_newline;
      disk_operation_name(i);
      string('   total: \ ');
      number(count, 10);
      string('   pages: \ ');
      number(page_access, 10);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone logical_volumes
      string('   errors: \');
      number(errors, 10);
$endif logical_volumes
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      write_line(user_terminal)
   end
end (* write_first_line *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone logical_volumes



(************************  statistics_gatherer  *************************)
(*									*)
(*			     format_error_line				*)
(*									*)
(************************************************************************)

procedure format_error_line(
      format		: internal_to_string;
      user_terminal	: circuit_handler);

const
  operation_column = 18;
  status_column    = operation_column+10;
  address_column   = status_column+13;
  count_column	   = address_column+8;
  transfer_column  = count_column+6;
  isis_column	   = transfer_column+9;
  status2_column   = isis_column+5;

begin
  if not next_error.empty
  then
    begin
      with format do
        begin
	  start_line_message('when\ ');
	  skip_to(operation_column);
	  string('operation\');
	  skip_to(status_column);
	  string('status\ ');
	  skip_to(address_column);
	  string('address\');
	  skip_to(count_column);
	  string('count\');
	  skip_to(transfer_column);
	  string('transfer\ ');
	  skip_to(isis_column);
	  string('isis\ ');
	  skip_to(status2_column);
	  string('status2\');
	  write_line(user_terminal)
	end (* with *);
      repeat
	with error[next_error.departure], format do
	  begin
	    start;
	    time(when);
	    skip_to(operation_column);
	    disk_operation_name(call.operation);
	    skip_to(status_column);
	    status_name(value.status);
	    skip_to(address_column);
	    number(call.start_addr, 16);
	    skip_to(count_column);
	    number(call.byte_count, 10);
	    skip_to(transfer_column);
	    number(value.start_addr, 10);
	    skip_to(isis_column);
	    number(value.byte_count, 10);
	    skip_to(status2_column);
	    number(value.status2, 16);
	    write_line(user_terminal)
	  end (* with *)
      until next_error.empty
    end
end (* format_error_line *);
$endif logical_volumes
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(***********************  statistics_gatherer  ************************)
(*                                                                    *)
(*                          print_statistics                          *)
(*                                                                    *)
(*    Print the statistics currently gathered to the given terminal.  *)
(*                                                                    *)
(**********************************************************************)

procedure entry PRINT_STATISTICS(
      format		: internal_to_string;
      user_terminal	: circuit_handler);
          
var
  i : disk_statistic_operation;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if logical_volumes
$ifnone disk_maintenance_code
  info_buffer	: lvol_info_buffer;
  unit	: lvol_disk_unit_index;
$endif disk_maintenance_code
$endif logical_volumes
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

begin
  set_current_bar;
  with format do
    begin
      start_message('since \ ');
      time(start_time);
      string(UTC_MESSAGE);
      write_line(user_terminal)
    end (* with *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone logical_volumes   for i := DISK_READ to DISK_WRITE do
$if logical_volumes
$if disk_maintenance_code   for i := DISK_READ to DISK_WRITE do
$ifnone disk_maintenance_code   for i := LVOL_READ to LVOL_WRITE do
$endif logical_volumes
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    begin
      write_first_line(format, i, user_terminal);
      print_histogram(disk_statistic[i].history, format, user_terminal);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone logical_volumes       format_error_line(format, user_terminal)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    end (* for *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if logical_volumes
$if disk_maintenance_code   format_error_line(format, user_terminal);
$ifnone disk_maintenance_code
      lv_utility.lvol_information(info_buffer);
      user_terminal.write_newline;
      for unit := 0 to LVOL_DISK_UNIT_LIMIT do
        begin
          if (unit = CUD_DISK_UNIT) or (unit = CUD_DISK_UNIT2)
	  then
	    begin
	      format.start_message(DRIVE_MESSAGE);
	      if unit = 0
	      then format.number(0, 10)
	      else
	        if unit = 2
		then format.number(1, 10);
	      format.character(ASCII_COLON);
	      format.write_line(user_terminal)
	    end
	  else user_terminal.write_newline;
	  format.start_message(' unit \ ');
	  format.number(unit, 10);
	  format.colon_space;
	  format.string('  reads: \');
	  format.number(info_buffer[unit].read_count, 10);
	  format.string('   writes: \');
	  format.number(info_buffer[unit].write_count, 10);
	  format.string('   state: \ ');
	  format.lvol_state(info_buffer[unit].disk_states);
	  format.write_line(user_terminal);
	  format.start;
	  format.skip_to(11);
	  format.string('errors: \ ');
	  format.number(info_buffer[unit].error_count, 10);
	  format.string('   last error: \');
	  format.number(info_buffer[unit].last_error, 10);
	  format.string('   last isis: \ ');
	  format.number(info_buffer[unit].last_status, 10);
          format.write_line(user_terminal)
	end (* for *)
$endif disk_maintenance_code
$endif logical_volumes
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
end (* print_statistics *);



(***********************  statistics_gatherer  ************************)
(**********************************************************************)

begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if logical_volumes
$ifnone disk_maintenance_code   init lv_utility;
$endif logical_volumes
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  initialize
end (* statistics_gatherer *);
!
(**********************************************************************)
(*                                                                    *)
(*	profil.ntv						      *)
(*                        validator_profile			      *)
(*                                                                    *)
(*    This class contains validator information for currently logged  *)
(*    in validators.						      *)
(*                                                                    *)
(**********************************************************************)
(*                                                                    *)
(*                          revision record                           *)
(*                                                                    *)
(*	27Mar87 Version 5.00	neh				      *)
(*            - change user_options to nud_user_options if 	      *)
(*		BEFORE_SUP_V43 is diabled and check for OLD_AUDITOR   *)
(*		if CONVERT_TO_43 is enabled			      *)
(*	14Jun84	Version 2.02	jrn				      *)
(*	      - added licenses, AUDITOR_LICENSE, OPERATOR_LICENSE     *)
(*		and DISPLAY_CUD_LICENSE				      *)
(*    05Dec83    original - jnm					      *)
(*								      *)
(**********************************************************************)


type (* information about each validator *)
  validator_login_information = record
    level	: validator_type (* kind of validator *);
    needle	: needle_record;
    unit	: terminal_unit_index (* terminal device *);
    name	: username_string;
    gan		: integer;
$ifnone (BEFORE_SUP_V43, CONVERT_TO_43)
    mud_options	: mud_user_options;
    options	: nud_user_options
$endif (BEFORE_SUP_V43, CONVERT_TO_43)
$ifany (BEFORE_SUP_V43, CONVERT_TO_43)    options	: user_options
  end (* validator_login_information *);


type VALIDATOR_PROFILE = class(
	this_validator : validator_index);

var
  entry needle : needle_record;
  entry level : validator_type;
  entry gan : integer;
  entry name : username_string;
  entry licenses : validator_license_set;



(*************************  validator_profile  ************************)
(*                                                                    *)
(*                            set_validator			      *)
(*                                                                    *)
(*    Set up the validator.					      *)
(*                                                                    *)
(**********************************************************************)

procedure entry SET_VALIDATOR(
      new_info	: validator_login_information);

begin
  needle := new_info.needle;
  gan := new_info.gan;
  name := new_info.name;
  level := new_info.level;

  licenses := [];
$if CONVERT_TO_43  if OLD_AUDITOR in new_info.options
$ifnone CONVERT_TO_43  if AUDITOR in new_info.options
  then licenses := licenses or [AUDITOR_LICENSE]; 
$if CONVERT_TO_43  if OLD_OPERATOR in new_info.options
$ifnone CONVERT_TO_43  if OPERATOR in new_info.options
  then licenses := licenses or [OPERATOR_LICENSE]; 

  if level >= ACCOUNT_SUPERVISOR_VALIDATOR
  then licenses := licenses or [ACCOUNT_SUPERVISOR_LICENSE];
  if level >= NETWORK_ADMINISTRATOR_VALIDATOR
  then licenses := licenses or
    [NETWORK_ADMINISTRATOR_LICENSE, AUDITOR_LICENSE, OPERATOR_LICENSE];
  if level = PROGRAMMER_VALIDATOR
  then licenses := licenses or [PROGRAMMER_LICENSE];

  if (AUDITOR_LICENSE in licenses) or (ACCOUNT_SUPERVISOR_LICENSE in licenses)
  then licenses := licenses or [DISPLAY_CUD_LICENSE]
end (* set_validator *);



(*************************  validator_profile  ************************)
(*                                                                    *)
(*                              validator                             *)
(*                                                                    *)
(*    Return the validator's index.				      *)
(*                                                                    *)
(**********************************************************************)

function entry VALIDATOR : validator_index;

begin
  validator := this_validator
end (* validator *);



(*************************  validator_profile  ************************)
(*                                                                    *)
(*                            access_to_gan                           *)
(*                                                                    *)
(*    - if validator is programmer or network administrator, they may *)
(*	do anything to anyone, so return TRUE			      *)
(*    - if write_access is TRUE, return TRUE if the validator is an   *)
(*	ACCOUNT SUPERVISOR and the gan_to_check matches and GANS      *)
(*	are included in the system, otherwise return FALSE	      *)
(*    - if write_access is FALSE (caller is checking READ access),    *)
(*	return TRUE if:						      *)
(*		- the validator is an AUDITOR			      *)
(*				OR				      *)
(*		- the validator is an ACCOUNT SUPERVISOR AND the      *)
(*		  gan_to_check matehs AND GANS are included	      *)
(*		  in the system					      *)
(*	otherwise, return FALSE					      *)
(*                                                                    *)
(**********************************************************************)

function entry ACCESS_TO_GAN(
      gan_to_check 	: integer;
      write_access	: boolean) : boolean;

begin
  if level > ACCOUNT_SUPERVISOR_VALIDATOR
  then access_to_gan := TRUE		(* N.A. and PROG. can do anything *)
  else
    if write_access	(* checking a write command *)
    then access_to_gan := INCLUDE_GAN and 
        (level = ACCOUNT_SUPERVISOR_VALIDATOR) and (gan = gan_to_check)
    else	(* checking a read command *)
      access_to_gan := (AUDITOR_LICENSE in licenses) or
        (INCLUDE_GAN and 
	  (level = ACCOUNT_SUPERVISOR_VALIDATOR) and (gan = gan_to_check))
end (* access_to_gan *);



(*************************  validator_profile  ************************)
(*                                                                    *)
(*                          access_to_command                         *)
(*                                                                    *)
(*	Return TRUE if the required license for  the command or	      *)
(*	subcommand is NO_LICENSE or the validator has the	      *)
(*	required license.				      	      *)
(*                                                                    *)
(**********************************************************************)

function entry ACCESS_TO_COMMAND(
      required_license 	: command_license) : boolean;

begin
  access_to_command := (required_license = NO_LICENSE) or
    (required_license in licenses)
end (* access_to_command *);


(************************  validator_profile  *************************)
(**********************************************************************)


begin (* initial statement *)
end (* validator_profile *);
!
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone OLD_LIST_CONFIGURATION
(**********************************************************************)
(*                                                                    *)
(*	DSKSYS.NTV						      *)
(*                            Disk_System                             *)
(*                                                                    *)
(*	This class makes the actual I/O calls for disk access to      *)
(*	the file system. It handles page and CUD block I/O.  All      *)
(*	other data types use a multiple of pages.		      *)
(*                                                                    *)
(*    The following identifiers must be defined externally:           *)
(*	disk_unit_index				                      *)
(*      cud_disk_block                                                *)
(*      Disk_operation                                                *)
(*      Page                                                          *)
(*                                                                    *)
(**********************************************************************)
(*                                                                    *)
(*                          Revision Record                           *)
(*                                                                    *)
(*	11Dec87 - neh						      *)
(*	      - add dnic_data_request if INCLUDE_DNIC is enabled      *)
(*	03Feb86 - jrn						      *)
(*	      - add general procedcure IO_REQUEST		      *)
(*	13Dec84 - pgl						      *)
(*	      - add disk_io_page_request for logical_volumes	      *)
(*	14Oct84 - pgl						      *)
(*	      - add conditional assembly parameter 		      *)
(*		logical_volumes					      *)
(*	21Aug84 - jrn						      *)
(*	      - add conditional assembly parameter 		      *)
(*		OLD_LIST_CONFIGURATION to use code from here in the   *)
(*		old_node_host_list_utility class in NVDM	      *)
(*	20Jul84	- jrn						      *)
(*	      - change disk_system to perform I/O on lists and	      *)
(*		global_access					      *)
(*    29SEP83    original from (patrol)dsksys.tms - jrn		      *)
(*                                                                    *)
(**********************************************************************)



type DISK_SYSTEM = class(
	statistics	: statistics_gatherer);


(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if logical_volumes
(***************************  Disk_System  ****************************)
(*                                                                    *)
(*			  disk_io_page_request			      *)
(*                                                                    *)
(*	Do a page read or write, using a disk operation.	      *)
(*                                                                    *)
(**********************************************************************)

procedure entry DISK_IO_PAGE_REQUEST(
      unit_num		: lvol_disk_unit_index;
      page_operation	: disk_operation;
      page_address	: integer;
  var page_buffer	: univ page;
  var ok		: boolean);

var
  call_param,
  value_param : disk_param;

begin
  with call_param do
    begin
      operation := page_operation;
      start_addr := page_address;
      byte_count := PAGE_SIZE
    end (* with *);
  value_param := call_param;
  io(page_buffer, call_param, DISK, unit_num);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code  statistics.report_disk_io(call_param, value_param);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  ok := call_param.status = COMPLETE
end (* disk_io_page_request *);
$endif logical_volumes
$endif old_list_configuration
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(***************************  Disk_System  ****************************)
(*                                                                    *)
(*			      io_request			      *)
(*                                                                    *)
(*	Do a character array read or write.			      *)
(*                                                                    *)
(**********************************************************************)

procedure io_request(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone logical_volumes
      unit_num		: disk_unit_index;
      io_operation	: disk_operation;
$endif logical_volumes
$if logical_volumes
$if disk_maintenance_code
      unit_num		: lvol_disk_unit_index;
      io_operation	: disk_operation;
$endif disk_maintenance_code
$ifnone disk_maintenance_code
      unit_num		: disk_unit_index;
      io_operation	: lvol_operation;
$endif disk_maintenance_code
$endif logical_volumes
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      io_address	: integer;
      io_length		: integer;
  var first_char	: char;
  var ok		: boolean);

var
  call_param,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code   value_param : disk_param;
$ifnone disk_maintenance_code
$if logical_volumes  value_param : lvol_io_param;
$ifnone logical_volumes  value_param : disk_param;
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

begin
  with call_param do
    begin
      operation := io_operation;
      start_addr := io_address;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if logical_volumes
$ifnone disk_maintenance_code
      if unit_num = FILE_SYSTEM_DISK
      then start_addr := start_addr + DISK_UNIT_ZERO_SIZE;
$endif disk_maintenance_code      
$endif logical_volumes
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      byte_count := io_length
    end (* with *);
  value_param := call_param;
  io(first_char, value_param,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code    DISK, unit_num);
$ifnone disk_maintenance_code
$if logical_volumes    LVOL, LVOL_UNIT);
$ifnone logical_volumes    DISK, unit_num);
$endif disk_maintenance_code
$if disk_maintenance_code   statistics.report_disk_io(call_param, value_param);
$ifnone disk_maintenance_code
$if logical_volumes   statistics.report_disk_io(value_param);
$ifnone logical_volumes   statistics.report_disk_io(call_param, value_param);
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  ok := value_param.status = COMPLETE
end (* io_request *);



(***************************  Disk_System  ****************************)
(*                                                                    *)
(*			      page_request			      *)
(*                                                                    *)
(*	Do a page read or write.				      *)
(*                                                                    *)
(**********************************************************************)

procedure
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone OLD_LIST_CONFIGURATION entry
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
PAGE_REQUEST(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone logical_volumes
      unit_num		: disk_unit_index;
      page_operation	: disk_operation;
$endif logical_volumes
$if logical_volumes
$if disk_maintenance_code
      unit_num		: lvol_disk_unit_index;
      page_operation	: disk_operation;
$endif disk_maintenance_code
$ifnone disk_maintenance_code
      unit_num		: disk_unit_index;
      page_operation	: lvol_operation;
$endif disk_maintenance_code
$endif logical_volumes
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      address		: integer;
  var buffer		: univ page;
  var ok		: boolean);

begin
  io_request(unit_num, page_operation, address, PAGE_SIZE, buffer[0], ok)
end (* page_request *);



(***************************  Disk_System  ****************************)
(*                                                                    *)
(*			  named_list_request			      *)
(*                                                                    *)
(*	Do a named_list read or write.				      *)
(*                                                                    *)
(**********************************************************************)

procedure
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone OLD_LIST_CONFIGURATION entry
NAMED_LIST_REQUEST(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone logical_volumes
      unit_num		: disk_unit_index;
      list_operation	: disk_operation;
$endif logical_volumes
$if logical_volumes
$if disk_maintenance_code
      unit_num		: lvol_disk_unit_index;
      list_operation	: disk_operation;
$endif disk_maintenance_code
$ifnone disk_maintenance_code
      unit_num		: disk_unit_index;
      list_operation	: lvol_operation;
$endif disk_maintenance_code
$endif logical_volumes
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      address		: integer;
  var buffer		: univ disk_named_list_definition;
  var ok		: boolean);

begin
  io_request(unit_num, list_operation, address, MAXIMUM_BYTES_IN_NAMED_LIST,
    buffer[0], ok)
end (* named_list_request *);



(***************************  Disk_System  ****************************)
(*                                                                    *)
(*			  global_access_request			      *)
(*                                                                    *)
(*	Do a global_access read or write.			      *)
(*                                                                    *)
(**********************************************************************)

procedure
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone OLD_LIST_CONFIGURATION entry
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
GLOBAL_ACCESS_REQUEST(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone logical_volumes
      unit_num		: disk_unit_index;
      io_operation	: disk_operation;
$endif logical_volumes
$if logical_volumes
$if disk_maintenance_code
      unit_num		: lvol_disk_unit_index;
      io_operation	: disk_operation;
$endif disk_maintenance_code
$ifnone disk_maintenance_code
      unit_num		: disk_unit_index;
      io_operation	: lvol_operation;
$endif disk_maintenance_code
$endif logical_volumes
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      page_address	: integer;
  var buffer		: univ disk_global_access_description;
  var ok		: boolean);

begin
  io_request(unit_num, io_operation, page_address,
    MAXIMUM_BYTES_IN_GLOBAL_ACCESS_DESCRIPTION, buffer[0], ok)
end (* global_access_request *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if INCLUDE_DNIC


(***************************  Disk_System  ****************************)
(*                                                                    *)
(*			  dnic_data_request			      *)
(*                                                                    *)
(*	Do a dnic_data read or write.			      	      *)
(*                                                                    *)
(**********************************************************************)

procedure entry DNIC_DATA_REQUEST(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone logical_volumes
      unit_num		: disk_unit_index;
      io_operation	: disk_operation;
$endif logical_volumes
$if logical_volumes
$if disk_maintenance_code
      unit_num		: lvol_disk_unit_index;
      io_operation	: disk_operation;
$endif disk_maintenance_code
$ifnone disk_maintenance_code
      unit_num		: disk_unit_index;
      io_operation	: lvol_operation;
$endif disk_maintenance_code
$endif logical_volumes
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      page_address	: integer;
  var buffer		: univ dnic_table_in_bytes;

  var ok		: boolean);

begin
  io_request(unit_num, io_operation, page_address,
    MAXIMUM_DNIC_TABLE_SIZE, buffer[0], ok)
end (* dnic_data_request *);
$endif INCLUDE_DNIC


$ifnone OLD_LIST_CONFIGURATION
!
(***************************  Disk_System  ****************************)
(*                                                                    *)
(*			      block_request			      *)
(*                                                                    *)
(*	Do a CUD block read or write.				      *)
(*	Called for CUD file and CUD/MUD buffers.		      *)
(*                                                                    *)
(**********************************************************************)

procedure block_request(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone logical_volumes
      unit_num		: disk_unit_index;
      block_operation	: disk_operation;
$endif logical_volumes
$if logical_volumes
$if disk_maintenance_code
      unit_num		: lvol_disk_unit_index;
      block_operation	: disk_operation;
$endif disk_maintenance_code
$ifnone disk_maintenance_code
      unit_num		: disk_unit_index;
      block_operation	: lvol_operation;
$endif disk_maintenance_code
$endif logical_volumes
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      block_address	: integer;
  var buffer		: cud_disk_block;
  var ok		: boolean);

var
  call_param,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code   value_param : disk_param;
$ifnone disk_maintenance_code
$if logical_volumes  value_param : lvol_io_param;
$ifnone logical_volumes  value_param : disk_param;
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

begin
  with call_param do
    begin
      operation := block_operation;
      start_addr := block_address * MAXIMUM_CUD_BLOCK_SIZE_IN_SECTORS;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if logical_volumes
$ifnone disk_maintenance_code
      if unit_num = FILE_SYSTEM_DISK
      then start_addr := start_addr + DISK_UNIT_ZERO_SIZE;
$endif disk_maintenance_code      
$endif logical_volumes
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      byte_count := MAXIMUM_CUD_BLOCK_SIZE
    end (* with *);
  value_param := call_param;
  io(buffer, value_param,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code     DISK, unit_num);
$ifnone disk_maintenance_code
$if logical_volumes    LVOL, LVOL_UNIT);
$ifnone logical_volumes    DISK, unit_num);
$endif disk_maintenance_code
$if disk_maintenance_code   statistics.report_disk_io(call_param, value_param);
$ifnone disk_maintenance_code
$if logical_volumes   statistics.report_disk_io(value_param);
$ifnone logical_volumes   statistics.report_disk_io(call_param, value_param);
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  ok := value_param.status = COMPLETE
end (* block_request *);



(***************************  Disk_System  ****************************)
(*                                                                    *)
(*                          Read_CUD_Block                            *)
(*                                                                    *)
(*	Reads a cud_disk_block.					      *)
(*	Called for CUD file and CUD/MUD buffers.		      *)
(*                                                                    *)
(**********************************************************************)

procedure entry READ_CUD_BLOCK(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone logical_volumes       unit_num		: disk_unit_index;
$if logical_volumes
$if disk_maintenance_code       unit_num		: lvol_disk_unit_index;
$ifnone disk_maintenance_code       unit_num		: disk_unit_index;
$endif logical_volumes
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      block_address	: integer;
  var cud_buffer	: univ cud_disk_block;
  var success		: boolean);

begin
  block_request(unit_num,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone logical_volumes    DISK_READ,
$if logical_volumes
$if disk_maintenance_code	DISK_READ,
$ifnone disk_maintenance_code	LVOL_READ,
$endif logical_volumes
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    block_address, cud_buffer, success)
end (* READ_CUD_BLOCK *);



(***************************  Disk_System  ****************************)
(*                                                                    *)
(*                          Write_CUD_Block                           *)
(*                                                                    *)
(*	Writes a cud_disk_block.				      *)
(*	Called for CUD file and CUD/MUD buffers.		      *)
(*                                                                    *)
(**********************************************************************)

procedure entry WRITE_CUD_BLOCK(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone logical_volumes       unit_num		: disk_unit_index;
$if logical_volumes
$if disk_maintenance_code       unit_num		: lvol_disk_unit_index;
$ifnone disk_maintenance_code       unit_num		: disk_unit_index;
$endif logical_volumes
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      block_address	: integer;
  var cud_buffer	: univ cud_disk_block;
  var success		: boolean);

begin
  block_request(unit_num,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone logical_volumes    DISK_WRITE,
$if logical_volumes
$if disk_maintenance_code	DISK_WRITE,
$ifnone disk_maintenance_code	LVOL_WRITE,
$endif logical_volumes
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    block_address, cud_buffer, success)
end (* WRITE_CUD_BLOCK *);
$ifnone BEFORE_SUP_V43



(***************************  Disk_System  ****************************)
(*                                                                    *)
(*			      mud_block_request			      *)
(*                                                                    *)
(*	Do a CUD block read or write.				      *)
(*	Called for CUD file and CUD/MUD buffers.		      *)
(*                                                                    *)
(**********************************************************************)

procedure mud_block_request(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone logical_volumes
      unit_num		: disk_unit_index;
      block_operation	: disk_operation;
$endif logical_volumes
$if logical_volumes
$if disk_maintenance_code
      unit_num		: lvol_disk_unit_index;
      block_operation	: disk_operation;
$endif disk_maintenance_code
$ifnone disk_maintenance_code
      unit_num		: disk_unit_index;
      block_operation	: lvol_operation;
$endif disk_maintenance_code
$endif logical_volumes
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      block_address	: integer;
  var buffer		: mud_disk_block;
  var ok		: boolean);

var
  call_param,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code   value_param : disk_param;
$ifnone disk_maintenance_code
$if logical_volumes  value_param : lvol_io_param;
$ifnone logical_volumes  value_param : disk_param;
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

begin
  with call_param do
    begin
      operation := block_operation;
      start_addr := block_address * MAXIMUM_MUD_BLOCK_SIZE_IN_SECTORS;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if logical_volumes
$ifnone disk_maintenance_code
      if unit_num = FILE_SYSTEM_DISK
      then start_addr := start_addr + DISK_UNIT_ZERO_SIZE;
$endif disk_maintenance_code      
$endif logical_volumes
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      byte_count := MAXIMUM_MUD_BLOCK_SIZE
    end (* with *);
  value_param := call_param;
  io(buffer, value_param,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code     DISK, unit_num);
$ifnone disk_maintenance_code
$if logical_volumes    LVOL, LVOL_UNIT);
$ifnone logical_volumes    DISK, unit_num);
$endif disk_maintenance_code
$if disk_maintenance_code   statistics.report_disk_io(call_param, value_param);
$ifnone disk_maintenance_code
$if logical_volumes   statistics.report_disk_io(value_param);
$ifnone logical_volumes   statistics.report_disk_io(call_param, value_param);
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  ok := value_param.status = COMPLETE
end (* mud_block_request *);


(***************************  Disk_System  ****************************)
(*                                                                    *)
(*                          Read_MUD_Block                            *)
(*                                                                    *)
(*	Reads a mud_disk_block.					      *)
(*	Called for CUD file and CUD/MUD buffers.		      *)
(*                                                                    *)
(**********************************************************************)

procedure entry READ_MUD_BLOCK(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone logical_volumes       unit_num		: disk_unit_index;
$if logical_volumes
$if disk_maintenance_code       unit_num		: lvol_disk_unit_index;
$ifnone disk_maintenance_code       unit_num		: disk_unit_index;
$endif logical_volumes
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      block_address	: integer;
  var mud_buffer	: univ mud_disk_block;
  var success		: Boolean);

begin
  mud_block_request(unit_num,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone logical_volumes    DISK_READ,
$if logical_volumes
$if disk_maintenance_code	DISK_READ,
$ifnone disk_maintenance_code	LVOL_READ,
$endif logical_volumes
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    block_address, mud_buffer, success)
end (* READ_MUD_BLOCK *);



(***************************  Disk_System  ****************************)
(*                                                                    *)
(*                          Write_MUD_Block                           *)
(*                                                                    *)
(*	Writes a mud_disk_block.				      *)
(*	Called for CUD file and CUD/MUD buffers.		      *)
(*                                                                    *)
(**********************************************************************)

procedure entry WRITE_MUD_BLOCK(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone logical_volumes       unit_num		: disk_unit_index;
$if logical_volumes
$if disk_maintenance_code       unit_num		: lvol_disk_unit_index;
$ifnone disk_maintenance_code       unit_num		: disk_unit_index;
$endif logical_volumes
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      block_address	: integer;
  var mud_buffer	: univ mud_disk_block;
  var success		: boolean);

begin
  mud_block_request(unit_num,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone logical_volumes    DISK_WRITE,
$if logical_volumes
$if disk_maintenance_code	DISK_WRITE,
$ifnone disk_maintenance_code	LVOL_WRITE,
$endif logical_volumes
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    block_address, mud_buffer, success)
end (* WRITE_MUD_BLOCK *);
$endif BEFORE_SUP_V43



(***************************  Disk_System  ****************************)
(**********************************************************************)



begin (* initial statement *)
end (* disk_system *);
$endif OLD_LIST_CONFIGURATION
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if include_non_dmc
!
(**********************************************************************)
(*                                                                    *)
(*	FILSYS.NTV						      *)
(*                        file_system_manager			      *)
(*                                                                    *)
(*    This monitor manages the files descriptors (from both the disk  *)
(*    and the config.ntv file.					      *)
(*                                                                    *)
(*    The following identifiers must be defined externally:           *)
(*      file_index		                                      *)
(*      file_descriptor                                               *)
(*      file_system_descriptor                                        *)
(*                                                                    *)
(**********************************************************************)
(*                                                                    *)
(*                          revision record                           *)
(*                                                                    *)
(*    29SEP83    original - jnm					      *)
(*								      *)
(**********************************************************************)


type FILE_SYSTEM_MANAGER = monitor;

var
  files : file_system_descriptor;
!
(************************  file_system_manager  ***********************)
(*                                                                    *)
(*                               lookup                               *)
(*                                                                    *)
(*    Translates a file_index into a file descriptor.                 *)
(*                                                                    *)
(**********************************************************************)

procedure entry lookup(
      index	: univ file_index;
  var desc	: file_descriptor);

begin
  desc := files[index]
end (* lookup *) ;
!
(************************  file_system_manager  ***********************)
(*                                                                    *)
(*                                reset                               *)
(*                                                                    *)
(*     Set up files.				                      *)
(*                                                                    *)
(**********************************************************************)


procedure entry RESET(
      new_files	: file_system_descriptor);

begin
  files := new_files
end (* RESET *) ;



(************************  file_system_manager  ***********************)
(**********************************************************************)


begin (* initial statement *)
end (* file_system_manager *) ;
$endif include_non_dmc
$if include_non_dmc
!
(**********************************************************************)
(*                                                                    *)
(*	BSCFL.NTV						      *)
(*                             basic_file                             *)
(*                                                                    *)
(*    This class implements page-addressable random-access files      *)
(*    identified by file_id.  It assumes that higher levels will      *)
(*    use it properly.						      *)
(*                                                                    *)
(*    the following identifiers must be defined externally:           *)
(*      file_index	                                              *)
(*      file_descriptor                                               *)
(*      page                                                          *)
(*                                                                    *)
(**********************************************************************)
(*                                                                    *)
(*                          revision record                           *)
(*                                                                    *)
(*	26Nov84	 - pgl						      *)
(*	      - added function unit				      *)
(*	20Jul84	 - jrn						      *)
(*	      - change to only compute address and crash if outside   *)
(*		limit of file					      *)
(*    29SEP83    original from (patrol)bscfl.tms - jrn		      *)
(*								      *)
(**********************************************************************)


type BASIC_FILE = class(
	this_file	: file_index;
	file_system	: file_system_manager);

var
  crash_util : crash_utility;

  desc : file_descriptor;



(****************************  basic_file  ****************************)
(*                                                                    *)
(*                             initialize                             *)
(*                                                                    *)
(**********************************************************************)


procedure initialize;

begin
  init crash_util;
  file_system.lookup(this_file, desc)
end (* initialize *) ;



(****************************  basic_file  ****************************)
(*                                                                    *)
(*                               length                               *)
(*                                                                    *)
(**********************************************************************)


function entry LENGTH : integer;

begin
  length := desc.length
end (* LENGTH *) ;

(****************************  basic_file  ****************************)
(*                                                                    *)
(*                               unit                                 *)
(*                                                                    *)
(**********************************************************************)


function entry UNIT : integer;

begin
  unit := desc.unit
end (* UNIT *) ;


(****************************  basic_file  ****************************)
(*                                                                    *)
(*                            disk_address                            *)
(*                                                                    *)
(**********************************************************************)


function entry DISK_ADDRESS(
      pageno	: integer) : integer;

var
  physical_address : integer;

begin
  physical_address := desc.address + pageno;
  if pageno < desc.length
  then disk_address := physical_address
  else crash_util.signal_process_error
end (* disk_address *) ;



(****************************  basic_file  ****************************)
(**********************************************************************)


begin (* initial statement *)
  initialize
end (* basic_file *) ;
$endif include_non_dmc
!
(************************************************************************)
(*									*)
(*	OPDEF.NTV							*)
(*									*)
(************************************************************************)

const
  OPER_LOG_HEADER_PAGE = operlog_file_length - 1  (* header page number *);

  OPER_LOG_DATA_LENGTH = operlog_file_length - 1 (* length of data *);
  OPER_LOG_PAGE_LIMIT = oper_log_data_length - 1;

type
  OPER_LOG_PAGE_INDEX = 0..oper_log_page_limit;
  OPER_LOG_ARCHIVE_PAGE_INDEX = 0..oper_log_header_page;

(* The last page of the operator log file is a header containing infor- *)
(* mation about what has been read from the file.  The rest of the pages*)
(* are log entries of 1 page each.					*)

type
  OPER_LOG_HEADER = record
    last_read_sequence	: integer;
    filler		: array [1..248] of char;
    checksum		: integer
  end (* oper_log_header *);

(*	Definition of data in each oper_log page *)

  OPER_LOG_ENTRY = record
    sequence	: integer;
    time	: integer;
    kind	: oper_log_message_kind;
$if changes_to_oper_log
    modify	: modify_type;
    cud_name	: username_string;
$endif changest_to_oper_log
$ifnone changes_to_oper_log   filler	: array [1..26] of char;
    login_number: validator_index;
    login_name	: username_string;
    sup_number	: integer;
    message     : log_message (* defined in globl.ntv *);
    checksum	: integer
  end (* oper_log_entry *);

const

(* These constants are used to index the oper_log_message_kind *)
  FIRST_MESSAGE_KIND = debugging_oplog_msg;
  LAST_MESSAGE_KIND = update_off_msg;

type
  MESSAGE_KIND_INDEX = first_message_kind..last_message_kind;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if check_time_status
const
  OPLOG_REPORTER_DELAY = 15 * 60 (* seconds *);
$endif check_time_status
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
(************************************************************************)
(*									*)
(*	OPLOG.NTV							*)
(*									*)
(*				operator_log				*)
(*									*)
(*	This monitor maintains the operator log file.  Entries are be	*)
(*	written to the file in a sequential order, writing over old	*)
(*	records when necessary.  Records may be read either in a one	*)
(*	time mode or according to a time specified.			*)
(*									*)
(*	The following identifiers must be defined externally:		*)
(*	  statistics_gatherer, file_system_manager, identifier,		*)
(*	  oper_log_page_index, basic_file, validator_index,		*)
(*	  oper_log_header, oper_log_entry, log_message,			*)
(*	  oper_log_message_kind						*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	03Sep86 - neh							*)
(*	      - Change WRITE procedure to be passed oper_log_entry	*)
(*		instead of message_kind and message.			*)
(*	31Jul86 - jrn							*)
(*	      - add MESSAGES FROM command to NVDM			*)
(*	29Jul85 - jrn							*)
(*	      - change searches thru file to binary searches to		*)
(*		handle bigger files					*)
(*	18Dec84 - jrn							*)
(*	      - change to a class for NVDM and add			*)
(*		logical_volume_directory				*)
(*	14Oct84 - pgl						        *)
(*	      - add conditional assembly parameter		        *)
(*		logical_volumes					        *)
(*	20Jul84 - jrn							*)
(*	      - add checksum to each page				*)
(*	      - use new disk_system and basic_file			*)
(*	20Jun84 - jrn							*)
(*	      - use disk_maintenance_code parameter			*)
(*	29SEP83	Original from (patrol)oplog.nc2 -- jrn			*)
(*									*)
(************************************************************************)



(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code
type OPERATOR_LOG = class(
$if logical_volumes 	lv_dir		: logical_volume_directory;
	sys_io		: system_handler;
	dsksys		: disk_system;
	statistics	: statistics_gatherer;
	format		: internal_to_string;
	user_terminal	: circuit_handler);


var
  next_write_sequence_set_up : boolean;
  validator_sequence : integer;
$endif disk_maintenance_code
$ifnone disk_maintenance_code
type OPERATOR_LOG = monitor(
	statistics	: statistics_gatherer;
	file_system	: file_system_manager);


var
  sys_io : system_handler;
  dsksys : disk_system;
  oplog_file : basic_file;

  validator_sequence : array [licensed_validator_index] of integer;
$endif disk_maintenance_code
  next_read_sequence : integer (* sequence number of next read *);
  next_write_sequence : integer (* sequence number of next write *);
!



(***************************  operator_log  *****************************)
(*									*)
(*			       read_page				*)
(*									*)
(*      Read a page from the oper log file.				*)
(*									*)
(************************************************************************)

procedure read_page(
      addr	: integer;
  var buffer	: univ oper_log_entry;
  var success	: boolean);

var
  checksum : integer;

begin
  dsksys.page_request(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code
$if logical_volumes     lv_dir.files_unit,
$ifnone logical_volumes     FILE_SYSTEM_DISK,
    DISK_READ, OPERLOG_FILE_START + addr,
$endif disk_maintenance_code
$ifnone disk_maintenance_code
    FILE_SYSTEM_DISK, 
$ifnone logical_volumes     DISK_READ,
$if logical_volumes     LVOL_READ,
     oplog_file.disk_address(addr),
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    buffer, success);
  if success
  then
    begin
      sys_io.page_checksum(PAGE_SIZE - MAXIMUM_BYTES_IN_WORD, buffer,
        checksum);
      success := buffer.checksum = checksum;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code
      if not success
      then
        begin
	  format.start_message(CHECKSUM_ERROR);
	  format.string(' on oper_log file\');
	  format.write_line(user_terminal)
	end
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    end
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code
  else format.report_file_error(OPERLOG_FILE, WRITING_MESSAGE,
    OPERLOG_FILE_START + addr, user_terminal)
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
end (* read_page *);



(***************************  operator_log  *****************************)
(*									*)
(*			       write_page				*)
(*									*)
(*      Write a page to the oper log file.				*)
(*									*)
(************************************************************************)

procedure write_page(
      addr	: univ oper_log_archive_page_index;
  var buffer	: univ oper_log_entry;
  var success	: boolean);

begin
  sys_io.page_checksum(PAGE_SIZE - MAXIMUM_BYTES_IN_WORD, buffer,
    buffer.checksum);
  dsksys.page_request(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code
$if logical_volumes     lv_dir.files_unit,
$ifnone logical_volumes     FILE_SYSTEM_DISK,
    DISK_WRITE, OPERLOG_FILE_START + addr,
$endif disk_maintenance_code
$ifnone disk_maintenance_code
    FILE_SYSTEM_DISK,
$ifnone logical_volumes     DISK_WRITE,
$if logical_volumes     LVOL_WRITE,
    oplog_file.disk_address(addr),
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    buffer, success);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code
  if not success
  then format.report_file_error(OPERLOG_FILE, WRITING_MESSAGE,
    OPERLOG_FILE_START + addr, user_terminal)
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
end (* write_page *);



(****************************  operator_log  ****************************)
(*									*)
(*			    sequence_to_address				*)
(*									*)
(*      This routine converts a message sequence number to a file	*)
(*	address.							*)
(*									*)
(************************************************************************)

function sequence_to_address(
      sequence	: integer) : oper_log_page_index;

begin
  sequence_to_address := sequence mod OPER_LOG_DATA_LENGTH
end (* sequence_to_address *);



(***************************  operator_log  *****************************)
(*									*)
(*			set_next_write_sequence				*)
(*									*)
(*	Perform a searcyh for last entry written to set up		*)
(*	next_write_sequence.						*)
(*									*)
(************************************************************************)

procedure set_next_write_sequence;

var
  pi : oper_log_page_index;
  success : boolean;
  done : boolean;
  header : oper_log_header;
  log_entry : oper_log_entry;

begin
  next_write_sequence := next_read_sequence (* in case of disk errors *);
(* start with next record to be read and find oldest sequence... *)
(* that will be the place to write the next record *)
  pi := next_read_sequence; done := FALSE;
  repeat
    read_page(sequence_to_address(pi), log_entry, success);
    if success
    then
      if log_entry.sequence < pi
      then
        begin
	  done := TRUE;
	  next_write_sequence := pi
	end
      else
        if pi < (next_read_sequence + OPER_LOG_DATA_LENGTH)
	then pi := pi + 1
	else done := TRUE
  until not success or done
end (* set_next_write_sequence *);



(****************************  operator_log  ****************************)
(*									*)
(*			    adjust_read_sequence			*)
(*									*)
(*	This routine insures that a read sequence number refers to a	*)
(*	current message in the operator log.				*)
(*									*)
(************************************************************************)

procedure adjust_read_sequence(
  var sequence	: integer);

begin
  if (next_write_sequence - sequence) > OPER_LOG_DATA_LENGTH
  then sequence := next_write_sequence - OPER_LOG_DATA_LENGTH
end (* adjust_read_sequence *);



(*****************************  operator_log  ***************************)
(*									*)
(*			     do_find_timed_message			*)
(*									*)
(************************************************************************)

procedure do_find_timed_message(
      start_time	: integer;
  var this_sequence	: integer;
  var got_message	: boolean);

var
  oldest_sequence : integer;
  newest_sequence : integer;
  buffer  : oper_log_entry;
  success : boolean;

begin
  oldest_sequence := next_write_sequence - OPER_LOG_DATA_LENGTH;
  newest_sequence := next_write_sequence - 1;
  got_message := FALSE;
  repeat
    this_sequence := (oldest_sequence + newest_sequence) div 2;
    read_page(sequence_to_address(this_sequence), buffer, success);
    if success
    then
      begin
        if start_time <= buffer.time
	then newest_sequence := this_sequence - 1;
	if start_time >= buffer.time
	then oldest_sequence := this_sequence + 1
      end (* success *)
  until not success or (newest_sequence < oldest_sequence);
  if success and ((oldest_sequence - newest_sequence) >= 1)
  then got_message := TRUE
end (* do_find_timed_message *);



(*****************************  operator_log  ***************************)
(*									*)
(*			    do_read_timed_message			*)
(*									*)
(*	Read the message stored at validator_sequence in log_entry.	*)
(*	Advance to next message.					*)
(*									*)
(************************************************************************)

procedure do_read_timed_message(
  var this_sequence	: integer;
  var log_entry		: oper_log_entry;
  var got_message	: boolean);

begin
  adjust_read_sequence(this_sequence);
  if this_sequence = next_write_sequence
  then got_message := FALSE
  else
    begin (* this_sequence <> next_write_sequence *)
      read_page(sequence_to_address(this_sequence), log_entry, got_message);
      this_sequence := this_sequence + 1
    end (* this_sequence <> next_write_sequence *)
end (* do_read_timed_message *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code



(***************************  operator_log  *****************************)
(*									*)
(*				initialize				*)
(*									*)
(*	Set up next_read_sequence to be equal to last_read_sequence	*)
(*	from header of file; scan file for latest entry and set up	*)
(*	next_write_sequence.						*)
(*									*)
(************************************************************************)

procedure initialize;

var
  header : oper_log_header;
  success : boolean;

begin
  init oplog_file(OPERLOG_FILE, file_system);
  read_page(OPER_LOG_HEADER_PAGE, header, success);
  next_read_sequence := header.last_read_sequence;
  set_next_write_sequence
end (* initialize *);



(*****************************  operator_log  ***************************)
(*									*)
(*			     read_timed_message				*)
(*									*)
(*	Read the message stored at validator_sequence in log_entry.	*)
(*	Advance to next message.					*)
(*									*)
(************************************************************************)

procedure entry READ_TIMED_MESSAGE(
      validator	  : licensed_validator_index;
  var log_entry   : oper_log_entry;
  var got_message : boolean);

begin
  do_read_timed_message(validator_sequence[validator], log_entry, got_message)
end (* read_timed_message *);



(*****************************  operator_log  ***************************)
(*									*)
(*			     find_timed_message				*)
(*									*)
(************************************************************************)

procedure entry FIND_TIMED_MESSAGE(
      validator		: licensed_validator_index;
      start_time	: integer;
  var got_message	: boolean);

begin
  do_find_timed_message(start_time, validator_sequence[validator],
    got_message)
end (* find_timed_message *);



(***************************  operator_log  *****************************)
(*									*)
(*				   write				*)
(*									*)
(*      Write a message to the oper log file.				*)
(*									*)
(************************************************************************)

procedure entry WRITE(
  var new_log_entry : oper_log_entry);

var
  success : boolean;

begin
  with new_log_entry do
    begin
      sequence := next_write_sequence;
      time := REALTIME
    end (* with *);
  write_page(sequence_to_address(next_write_sequence), new_log_entry, success);
  next_write_sequence := next_write_sequence + 1
end (* write *);



(***************************  operator_log  *****************************)
(*                                                                      *)
(*                          read_operlog_page                           *)
(*                                                                      *)
(************************************************************************)

procedure entry READ_OPERLOG_PAGE(
      addr      : integer;
  var buffer    : univ oper_log_entry;
  var success   : boolean);

begin
  read_page(addr, buffer, success)
end (* read_operlog_page *);
$endif disk_maintenance_code



(***************************  operator_log  *****************************)
(*									*)
(*				  read					*)
(*									*)
(*      Read the next sequential message from the operator log file.	*)
(*									*)
(************************************************************************)

procedure entry READ(
  var log_entry   : oper_log_entry;
  var got_message : boolean);

begin
  adjust_read_sequence(next_read_sequence);
  got_message := next_read_sequence < next_write_sequence;
  if got_message
  then read_page(sequence_to_address(next_read_sequence), log_entry,
    got_message)
end (* read *);



(***************************  operator_log  *****************************)
(*                                                                      *)
(*                          advance_address                             *)
(*                                                                      *)
(*      Validator is done with the record just read...advance the       *)
(*      address.  Record the address to the file                        *)
(*      header if the reader has caught up to the writer.               *)
(*                                                                      *)
(************************************************************************)

procedure entry ADVANCE_ADDRESS;

var
  header : oper_log_header;
  success : boolean;


begin
  next_read_sequence := next_read_sequence + 1;
  if next_read_sequence = next_write_sequence
  then
    begin
       header.last_read_sequence := next_read_sequence;
       write_page(OPER_LOG_HEADER_PAGE, header, success)
    end
end (* advance_address *);
$if disk_maintenance_code



(*****************************  operator_log  ***************************)
(*									*)
(*			     find_timed_message				*)
(*									*)
(************************************************************************)

procedure entry FIND_TIMED_MESSAGE(
      start_time	: integer;
  var got_message	: boolean);

var
  header : oper_log_header;
  success : boolean;

begin
  if not next_write_sequence_set_up
  then
    begin
      read_page(OPER_LOG_HEADER_PAGE, header, success);
      next_read_sequence := header.last_read_sequence;
      user_terminal.write_quoted_text_line('scanning for start of log\');
      set_next_write_sequence;
      next_write_sequence_set_up := TRUE
    end (* not next_write_sequence_set_up *);
  user_terminal.write_quoted_text_line('scanning for time\');
  do_find_timed_message(start_time, validator_sequence, got_message)
end (* find_timed_message *);



(*****************************  operator_log  ***************************)
(*									*)
(*			     read_timed_message				*)
(*									*)
(*	Read the message stored at validator_sequence in log_entry.	*)
(*	Advance to next message.					*)
(*									*)
(************************************************************************)

procedure entry READ_TIMED_MESSAGE(
  var log_entry   : oper_log_entry;
  var got_message : boolean);

begin
  do_read_timed_message(validator_sequence, log_entry, got_message)
end (* read_timed_message *);



(*****************************  operator_log  ***************************)
(*									*)
(*			        new_file	 			*)
(*									*)
(*	Initialize a new operator_log.					*)
(*									*)
(************************************************************************)

procedure entry NEW_FILE;

var
  header : oper_log_header;
  done : boolean;
  log_entry : oper_log_entry;
  pi : oper_log_page_index;
  ok : boolean;

begin
  header.last_read_sequence := OPER_LOG_DATA_LENGTH;
  write_page(OPER_LOG_HEADER_PAGE, header, ok);
  if ok
  then
    begin
      user_terminal.write_line_and_quoted_text_line(
        'OPERLOG header initialized...initializing entries\');
      log_entry.time := MIN_INTEGER;
      done := FALSE;
      pi := 0;
      repeat
        log_entry.sequence := pi;
	write_page(pi, log_entry, ok);
	user_terminal.check_circuit;
	if pi = OPER_LOG_PAGE_LIMIT
	then done := TRUE
	else pi := pi + 1
      until done or not user_terminal.sendable;
      user_terminal.write_quoted_text_line('OPERLOG entries written\')
    end
end (* new_file *);



(*****************************  operator_log  ***************************)
(*									*)
(*			        check_file	 			*)
(*									*)
(************************************************************************)

procedure entry CHECK_FILE(
  var all_match	: boolean);

var
  header : oper_log_header;
  ok : boolean;

begin
  read_page(OPER_LOG_HEADER_PAGE, header, ok);
  if not ok
  then all_match := FALSE
end (* check_file *);



(***************************  operator_log  *****************************)
(*									*)
(*			    write_operlog_page				*)
(*									*)
(*      Write a page to the oper log file; used by archive		*)
(*	RESTORE command.						*)
(*									*)
(************************************************************************)

procedure entry WRITE_OPERLOG_PAGE(
      addr	: univ oper_log_archive_page_index;
  var buffer	: univ oper_log_entry;
  var success	: boolean);

begin
  write_page(addr, buffer, success)
end (* write_operlog_page *);
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)


(***************************  operator_log  *****************************)
(************************************************************************)

begin (* initial statement *)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code   next_write_sequence_set_up := FALSE;
$ifnone disk_maintenance_code
  init sys_io, dsksys(statistics);
  initialize
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
end (* operator_log *);
!
(************************************************************************)
(*									*)
(*	OPMSGS.NTV							*)
(*									*)
(*			operator_messages				*)
(*									*)
(*	Formats and outputs operator log messages.			*)
(*									*)
(*      The following identifiers must be defined externally:		*)
(*	  log_message, log_message_text_index, operator_log		*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	19Sep88 - jrn							*)
(*		- add code for restrict_users_by_time,			*)
(*		  password_expiration_date_in_cud			*)
(*	15Aug87 - neh							*)
(*	      - change TYMSHARE_CUD_FORMAT to INCLUDE_IRC		*)
(*	30Jul87 - neh							*)
(*	      - report nud_control_options if BEFORE_SUP_V43 disabled	*)
(*	03Sep86 - neh							*)
(*	      - Add permanent variable next_log_entry. Change procedure *)
(*		SAVE_MESSAGE to pass next_log_entry to oplog.write.	*)
(* 	      - Change procedure REPORT_MESSAGE to set modify, cud_name,*)
(*		login_number, login_name and sup_number.		*)
(*	      - Change REPORT_NUMBER_AND_NAME to assign validator name	*)
(*		to next_log_entry.login_name and validator number to	*)
(*		next_log_entry.login_number.				*)
(*	      - Add procedures REPORT_VALIDATOR_ENTRY,			*)
(*		REPORT_MODIFY_MESSAGE, REPORT_VALIDATOR_SUP_MESSAGE,	*)
(*		REPORT_MASTER_MESSAGE and REPORT_SUPERVISOR_MESSAGE.    *)
(*	14Nov85 - jrn							*)
(*	      - for Account Supervisor and Password Only validators,	*)
(*		add AUDITOR and OPERATOR control option message to	*)
(*		REPORT_LOGIN procedure					*)
(*	31Jul85 - jrn							*)
(*	      - add report_logout routine				*)
(*	08Mar85 - jrn							*)
(*	      - removed extra line at end of report_login		*)
(*	29SEP83	Original from (patrol)opmsgs.bas -- jrn			*)
(*									*)
(************************************************************************)

type OPERATOR_MESSAGES = class(
	oplog  : operator_log;
	format : internal_to_string);

var
  mutil : misc_utility;
  next_log_entry : oper_log_entry;

!
(*************************  operator_messages  **************************)
(*									*)
(*				save_message				*)
(*									*)
(************************************************************************)
procedure save_message(
      save_kind	: oper_log_message_kind);

var
  i	  : log_message_text_index;

begin
  with next_log_entry do
    begin
      kind := save_kind;
      format.skip(2);
      if format.buffer.size > log_message_text_max
      then message.size := log_message_text_max
      else message.size := format.buffer.size;
      for i := 0 to message.size-1 do
        message.text[i] := format.buffer.text[i]
    end (* with *);
  oplog.write(next_log_entry)
end (* save_message *);



(*************************  operator_messages  **************************)
(*									*)
(*			      report_license				*)
(*									*)
(************************************************************************)

procedure report_license(
      license_to_check	: validator_license;
$if BEFORE_SUP_V43      option		: control_options;
$ifnone BEFORE_SUP_V43      option		: nud_control_options;
      licenses		: validator_license_set;
  var first_license	: boolean);

begin
  if license_to_check in licenses (* if user has this license *)
  then
    begin (* display the option *)
      if first_license
      then
        begin
	  first_license := FALSE;
	  format.character(ASCII_COLON)
	end (* first_license *);
      format.character(ASCII_SPACE);
$ifnone BEFORE_SUP_V43     format.short_nud_control_option_name(option)
$if BEFORE_SUP_V43      format.short_control_option_name(option)
    end (* display the option *)
end (* report_license *);



(****************************  operator_messages  ***********************)
(*								        *) 
(*			do_report_validator_message			*) 
(*									*) 
(*	The procedure report_validator_message will add validator	*)
(*	type messages to the operator including the validator login	*)
(*	number and name.						*) 
(*									*) 
(************************************************************************) 

procedure do_report_validator_message(
      kind	: oper_log_message_kind;
      name	: username_string);

begin
  with next_log_entry do
    begin
$if changes_to_oper_log
      modify := FIRST_MODIFY_TYPE;
      cud_name.size := 0;
$endif changes_to_oper_log
      login_name := name
    end (* with *);
  save_message(kind)
end (* do_report_validator_message *);



(*************************  operator_messages  **************************)
(*									*)
(*			   make_login_message				*)
(*									*)
(************************************************************************)

procedure make_login_message(
      kind	: oper_log_message_kind;
      profile	: validator_profile);

var
  temp : integer;
  first_license : boolean;

begin
  with profile.needle do
    begin
      format.start_message('From host: \');
      temp := origin_host;
      mutil.clear_bit(BIT16, temp);
      format.number(temp, 10);
      format.string(' node: \');
      format.number(origin_node, 8);
      format.string(' port: \');
      temp := origin_port;
      mutil.clear_bit(BIT16, temp);
      format.number(temp, 10);
      format.string('d   invoice: \');
      format.number(invoice, 10)
    end (* with *);
  format.newline;
  format.string('validator login: \');
  format.validator_type_name(profile.level);
  format.skip(1);
  if profile.level <= ACCOUNT_SUPERVISOR_VALIDATOR
  then
    begin
      first_license := TRUE;
      report_license(AUDITOR_LICENSE, AUDITOR, profile.licenses,
        first_license);
      report_license(OPERATOR_LICENSE, OPERATOR, profile.licenses,
        first_license)
    end (* profile.level <= ACCOUNT_SUPERVISOR_VALIDATOR *);
  next_log_entry.sup_number := 0;
  next_log_entry.login_number := profile.validator;
end (* make_login_message *);



(*************************  operator_messages  **************************)
(*									*)
(*			       report_login				*)
(*									*)
(************************************************************************)

procedure entry REPORT_LOGIN(
      kind	: oper_log_message_kind;
      profile	: validator_profile);

begin
  make_login_message(kind, profile);
  do_report_validator_message(kind, profile.name)
end (* report_login *);
$if global_password_only_login



(*************************  operator_messages  **************************)
(*									*)
(*			     report_gpo_login				*)
(*									*)
(************************************************************************)

procedure entry REPORT_GPO_LOGIN(
      kind	: oper_log_message_kind;
      name	: username_string;
      profile	: validator_profile);

begin
  make_login_message(kind, profile);
  format.character(ASCII_LEFT_PARENS);
  format.username(name);
  format.character(ASCII_RIGHT_PARENS);
  do_report_validator_message(kind, profile.name)
end (* report_gpo_login *);
$endif global_password_only_login



(*************************  operator_messages  **************************)
(*									*)
(*			       report_logout				*)
(*									*)
(************************************************************************)

procedure entry REPORT_LOGOUT(
      kind	: oper_log_message_kind;
      profile		: validator_profile;
      logout_reason	: logout_cause);

begin
  format.start;
  format.logout_explanation(logout_reason);
  next_log_entry.sup_number := 0;
  next_log_entry.login_number := profile.validator;
  do_report_validator_message(kind, profile.name)
end (* report_logout *);



(************************  operator_messages  ***************************)
(*									*)
(*			    report_message				*)
(*									*)
(*	Report message of kind already set up in format.		*)
(*									*)
(************************************************************************)

procedure entry REPORT_MESSAGE(
      kind	: oper_log_message_kind);

begin
  with next_log_entry do
    begin
$if changes_to_oper_log
      modify := FIRST_MODIFY_TYPE;
      cud_name.size := 0;
$endif changes_to_oper_log
      login_number := 0;
      login_name.size := 0;
      sup_number := 0
    end (* with *);
  save_message(kind)
end (* report_message *);



(***************************  operator_messages *************************) 
(*									*) 
(*		 	    report_validator_message			*)
(*									*) 
(*	Set next_log_entry.sup_number to zero and report validator	*)
(*	entry.								*)
(*									*) 
(************************************************************************) 

procedure entry REPORT_VALIDATOR_MESSAGE(
      profile	: validator_profile);

begin
  next_log_entry.sup_number := 0;
  next_log_entry.login_number := profile.validator;
  do_report_validator_message(VALIDATOR_OPLOG_MSG, profile.name)
end (* report_validator_message *);



(***************************  operator_messages *************************) 
(*									*) 
(*		 	 report_by_validator_message			*)
(*									*) 
(*	Set next_log_entry.sup_number to the sup which is passed and    *)
(*	report validator entry.						*)
(*									*) 
(************************************************************************) 

procedure entry REPORT_BY_VALIDATOR_MESSAGE(
      name	: username_string;
      kind	: oper_log_message_kind);

begin
  next_log_entry.login_number := 0;
  next_log_entry.sup_number := 0;
  do_report_validator_message(kind, name)
end (* report_by_validator_message *);



(***************************  operator_messages *************************) 
(*									*) 
(*		 	 report_validator_sup_message			*)
(*									*) 
(*	Set next_log_entry.sup_number to the sup which is passed and    *)
(*	report validator entry.						*)
(*									*) 
(************************************************************************) 

procedure entry REPORT_VALIDATOR_SUP_MESSAGE(
      profile	: validator_profile;
      sup	: real_supervisor_index;
      kind	: oper_log_message_kind);

begin
  next_log_entry.sup_number := sup;
  next_log_entry.login_number := profile.validator;
  do_report_validator_message(kind, profile.name)
end (* report_validator_sup_message *);



(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if netval_is_a_slave
(***************************  operator_messages *************************) 
(*									*) 
(*		 	    report_master_message			*)
(*									*) 
(*	Set next_log_entry.sup_number to zero and report validator	*)
(*	entry.								*)
(*									*) 
(************************************************************************) 

procedure entry REPORT_MASTER_MESSAGE(
      profile	: validator_profile);

begin
  next_log_entry.sup_number := 0;
  next_log_entry.login_number := profile.validator;
  do_report_validator_message(MASTER_OPLOG_MSG, profile.name)
end (* report_master_message *);
$endif netval_is_a_slave
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if CHANGES_TO_OPER_LOG



(**************************  operator_messages  *************************) 
(*									*) 
(*			  report_modify_message				*) 
(*									*) 
(*	The procedure report_modify_message will add modify type	*) 
(*	messages to the operator log.					*) 
(*									*) 
(************************************************************************) 

procedure entry REPORT_MODIFY_MESSAGE(
      name		: username_string;
      number		: validator_index;
      cud_change 	: cud_change_indicator;
      cud_name_change	: username_string;
$if OVERFLOW_CUD_ENTRIES       block		: cud_block_index;
$if special       block		: cud_block_index;
       oplog_remark	: oplog_remark_message);

var
  oplog_remark_ptr : oplog_remark_index;

begin
  format.start;
  if oplog_remark.size > 0
  then
    begin
      for oplog_remark_ptr := 0 to oplog_remark.size - 1 do
	format.character(oplog_remark.chars[oplog_remark_ptr]);
      format.newline
    end (* oplog_remark.size > 0 *);
  format.cud_change_description(cud_change);
  format.colon_space;
  with next_log_entry do
    begin
      login_name := name;
      login_number := number;
      case cud_change of
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if OVERFLOW_CUD_ENTRIES
	CREATE_OVERFLOW_BLOCK:
	  begin
	    modify := OVERFLOW;
            format.number(block, 10)
	  end (* CREATE_OVERFLOW_BLOCK *);
$endif OVERFLOW_CUD_ENTRIES
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
        NEW_USER_CUD_CHANGE: modify := NEW;
$if NETVAL_IS_A_SLAVE 	CHANGE_UUN_AND_GAN_CUD_CHANGE,
	CHANGE_GAN_CUD_CHANGE: modify := GAN;
        CHANGE_PASSWORD_CUD_CHANGE: modify := PASSWORD;
        RENAME_DELETE_USER_CUD_CHANGE,
        RENAME_RESTORE_OLD_NAME,
        RENAME_NEW_USER_CUD_CHANGE: modify := CHANGENAME;
        DELETE_USER_CUD_CHANGE: modify := DELETE;
        CHANGE_OPTIONS_CUD_CHANGE: modify := CONTROL;
        CHANGE_DISTRICT_CUD_CHANGE: modify := DISTRICT;
        CHANGE_UUN_CUD_CHANGE: modify := UUN;
$if netval_is_a_slave
	SET_GFD_ONLY_CUD_CHANGE: modify := GFD;
$if INCLUDE_IRC 	CHANGE_IRC_CUD_CHANGE: modify := IRC;
$endif netval_is_a_slave
$if restrict_users_by_time
	CHANGE_ALLOWABLE_TIMES_CUD_CHANGE: modify := TIMES;
$endif restrict_users_by_time
$ifnone before_sup_v43 	CHANGE_NUD_OPTIONS_CUD_CHANGE: modify := NUD_CONTROL;
$if password_expiration_date_in_cud
	CHANGE_PASSWORD_EXPIRE: modify := EXPIRE_DATE;
$endif password_expiration_date_in_cud
        CHANGE_ACCESS_CUD_CHANGE: modify := ACCESS
      end (* case *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if special
      format.string(' from block \ ');
      format.number(block, 10);
$endif special
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      cud_name := cud_name_change;
      sup_number := 0
    end (* with *);
  save_message(MODIFY_CUD_OPLOG_MSG)
end (* report_modify_message *);
$endif CHANGES_TO_OPER_LOG



(************************  operator_messages  ***************************) 
(*									*) 
(*			report_supervisor_message			*) 
(*									*) 
(*	The procedure report_supervisor_message will add supervisor	*) 
(*	type messages to the operator log.				*) 
(*									*) 
(************************************************************************) 

procedure entry REPORT_SUPERVISOR_MESSAGE(
	sup		: real_supervisor_index;
	kind		: oper_log_message_kind);

begin
  with next_log_entry do
    begin
      sup_number := sup;
$if changes_to_oper_log
      modify := FIRST_MODIFY_TYPE;
      cud_name.size := 0;
$endif changes_to_oper_log
      login_name.size := 0;
      login_number := 0
    end (* with *);
  save_message(kind)
end (* report_supervisor_message *);


(*************************  operator_messages  **************************)
(************************************************************************)

begin (* initial statement *) 
  init mutil
end (* operator_messages *);
$if include_non_dmc
!
(**********************************************************************)
(*								      *)
(*	FUTIL.NTV						      *)
(*                                                                    *)
(*			     file_utility			      *)
(*                                                                    *)
(*    This class handles the reporting of errors to the		      *)
(*    OPERATOR_LOG.						      *)
(*                                                                    *)
(*     The following identifiers must be defined externally:          *)
(*	 operator_messages, file_index, page,			      *)
(*	 basic_file						      *)
(*                                                                    *)
(**********************************************************************)
(*                                                                    *)
(*                           Revision Record                          *)
(*                                                                    *)
(*	10Dec87 - neh						      *)
(*	     - add read_dnic_file_data and write_dnic_file_data       *)
(*	21Jan86 - jrn						      *)
(*	      - modify disk error operlog messages to include	      *)
(*		physical address				      *)
(*	19Jun85 - jrn						      *)
(*		- add parameter check_checksum to all read routines   *)
(*		- add parameter do_checksunm to all write routines    *)
(*	        - expand use of report_error			      *)
(*	26Nov84 - Version 3.00 - pgl				      *)
(*	      - calls to dsksys.page_request use function,	      *)
(*		bfile.unit	    				      *)
(*	      - add conditional assembly parameter LOGICAL_VOLUMES    *)
(*	20Jul84 - jrn						      *)
(*	      - use new disk_system, basic_file and global_access     *)
(*	20Jun84 - jrn						      *)
(*	      - use READING_MESSAGE and WRITING_MESSAGE		      *)
(*	14Mar84	Version 2.01 - jrn				      *)
(*	      - removed sequential procedures			      *)
(*	29SEP83    Original -- jnm (from (basicws)futil.bes)	      *)
(*                                                                    *)
(**********************************************************************)

type
  FILE_UTILITY_OPERATION = (FU_READ, FU_WRITE);


type FILE_UTILITY = class(
	this_file	: file_index;
	statistics	: statistics_gatherer;
	file_system	: file_system_manager;
$ifnone CONVERT_TO_43       oper_messages	: operator_messages;
$if CONVERT_TO_43      user_terminal		: circuit_handler;
	format		: internal_to_string);

var
  dsksys	: disk_system;
  bfile		: basic_file;
  sys_io	: system_handler;
!
(**************************  file_utility  ******************************)
(*									*)
(*			     report_error				*)
(*									*)
(*    Report file error in file.					*)
(*									*)
(************************************************************************)

procedure report_error(
      checksum_error	: boolean;
      file_operation	: file_utility_operation;
      location		: univ integer);

var
  desc : file_descriptor;

begin
  format.start_message('error \ ');
  case file_operation of
    FU_READ:
      begin
        if checksum_error
	then format.string('in checksum while \ ');
        format.string(READING_MESSAGE);
      end (* FU_READ *);
    FU_WRITE: format.string(WRITING_MESSAGE)
  end (* case *);
  format.string(' file: \');
  format.file_name(this_file);
  format.string(' at \ ');
  format.number(location, 10);
  file_system.lookup(this_file, desc);
  format.unit_and_sector(bfile.unit, desc.address+location);
$ifnone CONVERT_TO_43  oper_messages.report_message(FILE_OPLOG_MSG)
$if CONVERT_TO_43  format.write_line(user_terminal)
end (* report_error *);
!



(***************************  file_utility  ***************************)
(*                                                                    *)
(*			         length				      *)
(*                                                                    *)
(*    Return length of file in pages.				      *)
(*                                                                    *)
(**********************************************************************)

function entry LENGTH : integer;

begin
  length := bfile.length
end (* LENGTH *);



(***************************  file_utility  ***************************)
(*                                                                    *)
(*			       read_random			      *)
(*                                                                    *)
(*    Read the given page from the file.			      *)
(*                                                                    *)
(**********************************************************************)

procedure entry READ_RANDOM(
      check_checksum	: boolean;
      location		: integer;
  var page_buffer	: univ page_record;
  var io_status		: file_utility_status);

var
  success : boolean;
  computed_checksum : integer;

begin
  io_status := FU_SUCCESS;
  dsksys.page_request(bfile.unit,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone LOGICAL_VOLUMES     DISK_READ,
$if LOGICAL_VOLUMES
$ifnone disk_maintenance_code       LVOL_READ,
$if disk_maintenance_code      DISK_READ,
$endif LOGICAL_VOLUMES
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    bfile.disk_address(location), page_buffer, success);
  if not success
  then
    begin
      io_status := FU_IO_ERROR;
      report_error(FALSE, FU_READ, location)
    end
  else
    if check_checksum
    then
      begin
        sys_io.page_checksum(PAGE_SIZE-MAXIMUM_BYTES_IN_WORD, page_buffer,
	  computed_checksum);
	if computed_checksum <> page_buffer.checksum
	then
	  begin
	    io_status := FU_CHECKSUM_ERROR;
	    report_error(TRUE, FU_READ, location)
	  end
      end (* read was a success *)
end (* read_random *);



(***************************  file_utility  ***************************)
(*                                                                    *)
(*			      write_random			      *)
(*                                                                    *)
(*    Write the page at the given location.			      *)
(*                                                                    *)
(**********************************************************************)

procedure entry WRITE_RANDOM(
      do_checksum	: boolean;
      location		: integer;
  var page_buffer	: univ page_record;
  var io_status		: file_utility_status);

var
  success : boolean;

begin
  io_status := FU_SUCCESS;
  if do_checksum
  then sys_io.page_checksum(PAGE_SIZE-MAXIMUM_BYTES_IN_WORD, page_buffer,
    page_buffer.checksum);
  dsksys.page_request(bfile.unit,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone LOGICAL_VOLUMES    DISK_WRITE,
$if LOGICAL_VOLUMES
$ifnone disk_maintenance_code     LVOL_WRITE,
$if disk_maintenance_code     DISK_WRITE,
$endif LOGICAL_VOLUMES
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    bfile.disk_address(location), page_buffer, success);
  if not success
  then
    begin
      io_status := FU_IO_ERROR;
      report_error(FALSE, FU_WRITE, location)
    end
end (* write_random *);
!



(***************************  file_utility  ***************************)
(*                                                                    *)
(*			    read_named_list			      *)
(*                                                                    *)
(*    Read the given named_list from the file.			      *)
(*                                                                    *)
(**********************************************************************)

procedure entry READ_NAMED_LIST(
      location		: integer;
  var named_list	: named_list_definition;
  var io_status		: file_utility_status);

var
  success : boolean;
  computed_checksum : integer;

begin
  io_status := FU_SUCCESS;
  dsksys.named_list_request(bfile.unit,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone LOGICAL_VOLUMES    DISK_READ,
$if LOGICAL_VOLUMES
$ifnone disk_maintenance_code       LVOL_READ,
$if disk_maintenance_code      DISK_READ,
$endif LOGICAL_VOLUMES
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    bfile.disk_address(location), named_list, success);
  if not success
  then
    begin
      io_status := FU_IO_ERROR;
      report_error(FALSE, FU_READ, location)
    end
  else
    begin
      sys_io.named_list_checksum(named_list, computed_checksum);
      if computed_checksum <> named_list.checksum
      then
        begin
	  io_status := FU_CHECKSUM_ERROR;
	  report_error(FALSE, FU_READ, location)
	end
      end (* read was a success *)
end (* read_named_list *);



(***************************  file_utility  ***************************)
(*                                                                    *)
(*			     write_named_list			      *)
(*                                                                    *)
(*    Write the named_list at the given location.		      *)
(*                                                                    *)
(**********************************************************************)

procedure entry WRITE_NAMED_LIST(
      location		: integer;
  var named_list	: named_list_definition;
  var io_status		: file_utility_status);

var
  success : boolean;

begin
  io_status := FU_SUCCESS;
  sys_io.named_list_checksum(named_list, named_list.checksum);
  dsksys.named_list_request(bfile.unit,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone LOGICAL_VOLUMES     DISK_WRITE,
$if LOGICAL_VOLUMES
$ifnone disk_maintenance_code     LVOL_WRITE,
$if disk_maintenance_code     DISK_WRITE,
$endif LOGICAL_VOLUMES
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    bfile.disk_address(location), named_list, success);
  if not success
  then report_error(FALSE, FU_WRITE, location)
end (* WRITE_NAMED_LIST *);
!



(***************************  file_utility  ***************************)
(*                                                                    *)
(*			    read_global_access			      *)
(*                                                                    *)
(*    Read the given global_access from the file.		      *)
(*                                                                    *)
(**********************************************************************)

procedure entry READ_GLOBAL_ACCESS(
      location		: integer;
  var global_access	: global_access_description;
  var io_status		: file_utility_status);

var
  success : boolean;
  computed_checksum  : integer;

begin
  io_status := FU_SUCCESS;
  dsksys.global_access_request(bfile.unit,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone LOGICAL_VOLUMES     DISK_READ,
$if LOGICAL_VOLUMES
$ifnone disk_maintenance_code       LVOL_READ,
$if disk_maintenance_code      DISK_READ,
$endif LOGICAL_VOLUMES
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    bfile.disk_address(location), global_access, success);
  if not success
  then
    begin
      io_status := FU_IO_ERROR;
      report_error(FALSE, FU_READ, location)
    end
  else
    begin
      sys_io.global_access_checksum(global_access, computed_checksum);
      if computed_checksum <> global_access.checksum
      then
        begin
	  io_status := FU_CHECKSUM_ERROR;
	  report_error(TRUE, FU_READ, location)
	end
      end (* read was a success *)
end (* read_global_access *);



(***************************  file_utility  ***************************)
(*                                                                    *)
(*			   write_global_access			      *)
(*                                                                    *)
(*    Write the global_access the given location.		      *)
(*                                                                    *)
(**********************************************************************)

procedure entry WRITE_GLOBAL_ACCESS(
      location		: integer;
  var global_access	: global_access_description;
  var io_status		: file_utility_status);

var
  success : boolean;

begin
  io_status := FU_SUCCESS;
  sys_io.global_access_checksum(global_access, global_access.checksum);
  dsksys.global_access_request(bfile.unit,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone LOGICAL_VOLUMES     DISK_WRITE,
$if LOGICAL_VOLUMES
$ifnone disk_maintenance_code     LVOL_WRITE,
$if disk_maintenance_code     DISK_WRITE,
$endif LOGICAL_VOLUMES
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    bfile.disk_address(location), global_access, success);
  if not success
  then
    begin
      io_status := FU_IO_ERROR;
      report_error(FALSE, FU_WRITE, location)
    end
end (* write_global_access *);
$if INCLUDE_DNIC
!


(***************************  file_utility  ***************************)
(*                                                                    *)
(*			    read_dnic_file_data			      *)
(*                                                                    *)
(*    Read the given dnic_data from the file.		      	      *)
(*                                                                    *)
(**********************************************************************)

procedure entry READ_DNIC_FILE_DATA(
      location  : integer;
  var dnic_data	: univ disk_dnic_data;
  var io_status	: file_utility_status);

var
  success : boolean;
  computed_checksum  : integer;

begin
  io_status := FU_SUCCESS;
  dsksys.dnic_data_request(bfile.unit,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone LOGICAL_VOLUMES     DISK_READ,
$if LOGICAL_VOLUMES
$ifnone disk_maintenance_code       LVOL_READ,
$if disk_maintenance_code      DISK_READ,
$endif LOGICAL_VOLUMES
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    bfile.disk_address(location), dnic_data, success);
  if not success
  then
    begin
      io_status := FU_IO_ERROR;
      report_error(FALSE, FU_READ, DNIC_FILE_DATA_START)
    end
  else
    begin
      sys_io.dnicdata_checksum(dnic_data, computed_checksum);
      if computed_checksum <> dnic_data.checksum
      then
        begin
	  io_status := FU_CHECKSUM_ERROR;
	  report_error(TRUE, FU_READ, DNIC_FILE_DATA_START)
	end
      end (* read was a success *)
end (* read_dnic_file_data *);



(***************************  file_utility  ***************************)
(*                                                                    *)
(*			   write_dnic_file_data			      *)
(*                                                                    *)
(*    Write the dnic_data table location.		      	      *)
(*                                                                    *)
(**********************************************************************)

procedure entry WRITE_DNIC_FILE_DATA(
      location	: integer;
  var dnic_data	: univ disk_dnic_data;
  var io_status	: file_utility_status);

var
  success : boolean;

begin
  io_status := FU_SUCCESS;
  sys_io.dnicdata_checksum(dnic_data, dnic_data.checksum);
  dsksys.dnic_data_request(bfile.unit,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone LOGICAL_VOLUMES     DISK_WRITE,
$if LOGICAL_VOLUMES
$ifnone disk_maintenance_code     LVOL_WRITE,
$if disk_maintenance_code     DISK_WRITE,
$endif LOGICAL_VOLUMES
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    bfile.disk_address(location), dnic_data, success);
  if not success
  then
    begin
      io_status := FU_IO_ERROR;
      report_error(FALSE, FU_WRITE, DNIC_FILE_DATA_START)
    end
end (* write_dnic_file_data *);
$endif INCLUDE_DNIC

(***************************  file_utility  ***************************)
(**********************************************************************)

begin (* initial statement *)
  init dsksys(statistics), bfile(this_file, file_system)
end (* FILE_UTILITY *);
$endif include_non_dmc
!
(************************************************************************)
(*									*)
(*	CBUTIL.NTV							*)
(*									*)
(*			    cud_block_utility				*)
(*									*)
(*	The cud_block_utility class includes routines to compute	*)
(*	the CUD block checksum and record CUD block errors to the	*)
(*	operator log (unless disk_maintenance_code is ENABLED).		*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	18Dec84 - jrn, pgl - Version 3.00				*)
(*	      - moved cud_block_byte_count to cud_entry_utility		*)
(*	      - add logical_volume_directory				*)
(*	      - add conditional assembly parameter LOGICAL_VOLUMES	*)
(*	      - use engine checksum for disk				*)
(*	08Mar85 - jrn - Version 2.03					*)
(*	      - fixed a bug that allowed a format error in a CUD block	*)
(*		to crash NETVAL; if an odd size is picked up, the total	*)
(*		size of the data in the CUD block is then odd, and the	*)
(*		Nucleus checksum call causes an illegal instruction.	*)
(*	15Jun84	jrn							*)
(*	      - add disk_maintenance_code assembly parameter		*)
(*		Original -- jrn						*)
(*									*)
(************************************************************************)

type CUD_BLOCK_UTILITY = class(
	mutil		: misc_utility;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code  	oper_messages		: operator_messages;
$if disk_maintenance_code
	user_terminal	: circuit_handler;
$if logical_volumes	lv_dir	: logical_volume_directory;
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	format		: internal_to_string;
	dsksys		: disk_system);


var
  sys_io : system_handler;
!
(*************************  cud_block_utility  **************************)
(*									*)
(*				report_error				*)
(*									*)
(*      Report CUD block error to operator_log or terminal.		*)
(*									*)
(************************************************************************)

procedure entry REPORT_ERROR(
      result	: cud_operation_result;
      block	: univ integer);

begin
  format.cud_block_error(block, result);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code oper_messages.report_message(CUD_OPLOG_MSG)
$if disk_maintenance_code format.write_line(user_terminal)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
end (* report_error *);



(*************************  cud_block_utility  **************************)
(*									*)
(*			     read_cud_block				*)
(*									*)
(*      Input the CUD block into cud_buffer.				*)
(*									*)
(************************************************************************)

procedure entry READ_CUD_BLOCK(
      block		: univ cud_block_index;
  var result		: cud_operation_result;
  var cud_buffer	: univ cud_disk_block);

var
  computed_checksum : integer;
  success : boolean;

begin
  dsksys.read_cud_block(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code
$ifnone LOGICAL_VOLUMES    CUD_DISK_UNIT,
$if LOGICAL_VOLUMES    lv_dir.cud_unit,
$endif disk_maintenance_code
$ifnone disk_maintenance_code     CUD_DISK_UNIT,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    block, cud_buffer, success);
  if not success
  then result := CUD_OPERATION_FAILED
  else
    begin
      sys_io.cud_checksum(MAXIMUM_CUD_DATA,cud_buffer.data,computed_checksum);
      if computed_checksum <> cud_buffer.checksum
      then result := CUD_CHECKSUM_ERROR
      else result := CUD_OPERATION_OK
    end
end (* read_cud_block *);
$ifnone BEFORE_SUP_V43


(*************************  cud_block_utility  **************************)
(*									*)
(*			     read_mud_block				*)
(*									*)
(*      Input the CUD block into mud_buffer.				*)
(*									*)
(************************************************************************)

procedure entry READ_MUD_BLOCK(
      block		: univ cud_block_index;
  var result		: cud_operation_result;
  var mud_buffer	: univ mud_disk_block);

var
  computed_checksum : integer;
  success : boolean;

begin
  dsksys.read_mud_block(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code
$ifnone LOGICAL_VOLUMES    CUD_DISK_UNIT,
$if LOGICAL_VOLUMES    lv_dir.cud_unit,
$endif disk_maintenance_code
$ifnone disk_maintenance_code     CUD_DISK_UNIT,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    block, mud_buffer, success);
  if not success
  then result := CUD_OPERATION_FAILED
  else result := CUD_OPERATION_OK
end (* read_mud_block *);
$endif BEFORE_SUP_V43



(************************************************************************)
(************************************************************************)

begin (* initial statement *)
  init sys_io
end (* cud_block_utility *);
!
(************************************************************************)
(*									*)
(*	LOGONM.NTV							*)
(*									*)
(*			  login_distributer				*)
(*									*)
(*      The following identifiers must be defined externally:		*)
(*	  validator_type, validator_index, username_string,		*)
(*	  terminal_unit_index						*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	17Oct88 - jrn							*)
(*	      - fix validator_count for GPO_VALIDATOR			*)
(*	04Mar88 - neh							*)
(*	      - add GPO_VALIDATOR					*)
(*	22Jan86 - jrn							*)
(*	      - add VALIDATOR_COUNT procedure				*)
(*	02Jul85 jrn							*)
(*	      - change for logical volumes to deal with one less	*)
(*		terminal						*)
(*	07Aug84 Version 3.00 - jrn/pgl					*)
(*	      - procedure login_validator changed to handle 		*)
(*		MASTER_VALIDATOR, if NETVAL_IS_A_SLAVE			*)
(*		is enabled						*)
(*	14Jun84 Version 2.02	jrn					*)
(*	      - added licenses, AUDITOR_LICENSE and OPERATOR_LICENSE	*)
(*		Original -- jrn						*)
(*									*)
(************************************************************************)


type LOGIN_DISTRIBUTER = monitor;



type (* information about each validator process *)
  validator_pool_information = record
    login_waiter	: queue (* wait for login here *);
(* in the following record, "level" is only meaningful *)
(* if login_waiter is empty *)
    info	: validator_login_information
  end (* validator_pool_information *);


var
  AVAILABLE_UNITS : array [terminal_unit_index] of boolean;

  WAITING_FOR_UNIT : queue;

  VALIDATOR_SINK : array [validator_index] of validator_pool_information;
!
(*************************  login_distributer  **************************)
(*									*)
(*			   	initialize				*)
(*									*)
(*	Set all terminal units to available.				*)
(*									*)
(************************************************************************)

procedure initialize;

var
  unit : terminal_unit_index;

begin
  for unit := 0 to TERMINAL_UNIT_LIMIT do
    available_units[unit] := TRUE
end (* initialize *);



(*************************  login_distributer  **************************)
(*									*)
(*			   	find_free				*)
(*									*)
(*	Find an available validator process in the range specified	*)
(*	(first through last); success is TRUE if one was found,		*)
(*	the one found is specified in validator_found.			*)
(*									*)
(************************************************************************)

procedure find_free(
      first		: validator_index;
      last		: validator_index;
  var success		: boolean;
  var validator_found	: validator_index);

var
  validator : validator_index;

begin
  success := FALSE;
  for validator := first to last do
    if not empty(validator_sink[validator].login_waiter)
    then
      begin
        success := TRUE;
	validator_found := validator
      end
end (* find_free *);



(*************************  login_distributer  **************************)
(*									*)
(*		       another_validator_available			*)
(*									*)
(*	Return TRUE if there is another available licensed validator	*)
(*	login.								*)
(*									*)
(************************************************************************)

function ANOTHER_VALIDATOR_AVAILABLE : boolean;

var
  validator : validator_index;
  available : integer;

begin
  available := MAXIMUM_LICENSED_VALIDATORS;
  for validator := FIRST_LICENSED_VALIDATOR to VALIDATOR_LIMIT do
    if empty(validator_sink[validator].login_waiter)
    then available := available - 1;
  another_validator_available := available > 1
end (* another_validator_available *);



(*************************  login_distributer  **************************)
(*									*)
(*		      		logged_in				*)
(*									*)
(*	Return TRUE if there is a validator of the type specified	*)
(*	already logged in.						*)
(*									*)
(************************************************************************)

function logged_in(
      level_to_check	: validator_type) : boolean;

var
  validator : validator_index;

begin
  logged_in := FALSE;
  for validator := FIRST_LICENSED_VALIDATOR to VALIDATOR_LIMIT do
    if empty(validator_sink[validator].login_waiter) and
      (validator_sink[validator].info.level = level_to_check)
    then logged_in := TRUE
end (* logged_in *);



(*************************  login_distributer  **************************)
(*									*)
(*			     login_validator				*)
(*									*)
(*	Login the user on the port.  If not successful, there is no	*)
(*	validator process of the type required.  This routine is	*)
(*	called by ACCEPT_LOGIN Processes when a needle is detected.	*)
(*									*)
(************************************************************************)

procedure entry LOGIN_VALIDATOR(
      new_info	: validator_login_information;
  var success	: boolean);

var
  validator : validator_index;

begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if allow_password_only
  if
$ifnone no_password_only_validators
    ((new_info.level = PASSWORD_ONLY_VALIDATOR) and
    not (AUDITOR in new_info.options) and not (OPERATOR in new_info.options))
$if global_password_only_login    or
$endif no_password_only_validators
$if global_password_only_login    (new_info.level = GPO_VALIDATOR)
  then find_free(FIRST_PASSWORD_ONLY_VALIDATOR, PASSWORD_ONLY_VALIDATOR_LIMIT,
    success, validator)
  else
$endif allow_password_only
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    if (new_info.level = PROGRAMMER_VALIDATOR) and
      logged_in(PROGRAMMER_VALIDATOR)
    then success := FALSE	(* only allow one PROGRAMMER *)
    else
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if netval_is_a_slave
      if new_info.level = MASTER_VALIDATOR
      then find_free(FIRST_MASTER_VALIDATOR, MASTER_VALIDATOR_LIMIT, success,
        validator)
      else
$endif netval_is_a_slave
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      begin
        find_free(FIRST_LICENSED_VALIDATOR, LICENSED_VALIDATOR_LIMIT, success,
          validator);
        if success and
	  ((new_info.level = ACCOUNT_SUPERVISOR_VALIDATOR) or
	   (new_info.level = PASSWORD_ONLY_VALIDATOR))
        then success :=
          another_validator_available or 
	  (logged_in(PROGRAMMER_VALIDATOR) or
	   logged_in(NETWORK_ADMINISTRATOR_VALIDATOR))
      end;
  if success
  then
    begin
      validator_sink[validator].info :=  new_info;
      continue(validator_sink[validator].login_waiter)
    end
end (* login_validator *);
!
(*************************  login_distributer  **************************)
(*									*)
(*			     release_unit				*)
(*									*)
(*	Relase the terminal unit and continue the waiting login		*)
(*	process.							*)
(*									*)
(************************************************************************)

procedure entry RELEASE_UNIT(
      unit	: terminal_unit_index);

begin
  available_units[unit] := TRUE;
  continue(waiting_for_unit)
end (* release_unit *);



(*************************  login_distributer  **************************)
(*									*)
(*			     wait_for_login				*)
(*									*)
(*	Wait for a login for this type validator.		        *)
(*									*)
(************************************************************************)

procedure entry WAIT_FOR_LOGIN(
      profile	: validator_profile;
  var unit	: terminal_unit_index);

begin
  delay(validator_sink[profile.validator].login_waiter)	(* wait here *);

  profile.set_validator(validator_sink[profile.validator].info);
  unit := validator_sink[profile.validator].info.unit
end (* wait_for_login *);
!
(*************************  login_distributer  **************************)
(*									*)
(*			    get_available_unit				*)
(*									*)
(************************************************************************)

procedure entry GET_AVAILABLE_UNIT(
  var unit	: terminal_unit_index);

var
  done,
  found_unit : boolean;

begin
  done := FALSE;
  repeat
    found_unit := FALSE;
    unit := 0;
    repeat
      if available_units[unit]
      then
        begin
	  done := TRUE;
	  found_unit := TRUE;
	  available_units[unit] := FALSE
	end
      else
        if unit = TERMINAL_UNIT_LIMIT
	then done := TRUE
	else unit := unit + 1
    until done;
    if not found_unit
    then
      begin
        delay(waiting_for_unit);
	done := FALSE
      end
  until done and found_unit
end (* get_available_unit *);
!
(*************************  login_distributer  **************************)
(*									*)
(*			     validator_name				*)
(*									*)
(************************************************************************)

procedure entry VALIDATOR_NAME(
      validator	: validator_index;
  var name	: username_string);

begin
  name := validator_sink[validator].info.name
end (* validator_name *);



(*************************  login_distributer  **************************)
(*									*)
(*			     validator_count				*)
(*									*)
(************************************************************************)

procedure entry VALIDATOR_COUNT(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if netval_is_a_slave
  var master_count		: master_validator_count;
$endif netval_is_a_slave
$if global_password_only_login
  var global_only_count         : password_only_validator_count;
$endif global_password_only_login
$ifnone no_password_only_validators
  var password_only_count	: password_only_validator_count;
$endif no_password_only_validators
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  var licensed_count		: licensed_validator_count;
  var programmer_count	: integer);

var
  validator : validator_index;

begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if netval_is_a_slave   master_count := 0;
$ifnone no_password_only_validators
  password_only_count := 0;
$if global_password_only_login   global_only_count := 0;
$endif no_password_only_validators
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  licensed_count := 0; programmer_count := 0;
  for validator := FIRST_VALIDATOR to VALIDATOR_LIMIT do
    if empty(validator_sink[validator].login_waiter)
    then
      case validator_sink[validator].info.level of
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if netval_is_a_slave
        MASTER_VALIDATOR: master_count := master_count + 1;
$endif netval_is_a_slave
$if global_password_only_login
        GPO_VALIDATOR: global_only_count := global_only_count+1;
$endif global_password_only_login
$ifnone no_password_only_validators
	PASSWORD_ONLY_VALIDATOR: password_only_count := password_only_count+1;
$endif no_password_only_validators
$if no_password_only_validators 	PASSWORD_ONLY_VALIDATOR,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	ACCOUNT_SUPERVISOR_VALIDATOR,
	NETWORK_ADMINISTRATOR_VALIDATOR: licensed_count := licensed_count + 1;
	PROGRAMMER_VALIDATOR: programmer_count := programmer_count + 1
      end (* case *)
end (* validator_count *);



(************************************************************************)
(************************************************************************)

begin (* initial statement *)
  initialize
end (* login_distributer *);
(*    -+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifany (force_password_change, global_password_only_login)
!
(************************************************************************)
(*									*)
(*	PASMON.NTV							*)
(*									*)
(*			    passtable_handler				*)
(*									*)
(*	This Monitor controls the updating of PASSTABLE. 		*)
(*	Passtable is always disc-resident. 				*)
(*									*)
(*      The routines are organized as follows:				*)
(*		initialization routines					*)
(*									*)
(*      The following identifiers must be defined externally:		*)
(*	  passtable_length, number_of_passtable_entries, page,		*)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	04Jan89 - neh							*)
(*		- add code for FPC effective start date			*)
(*	19Oct88 - jrn							*)
(*		- fix the bug in CLEAR_GANPASS and CLEAR_GPOGAN that	*)
(*		  does not write new entry out to disk			*)
(*	10-15-86	rsb						*)
(*		- Original						*)
(*									*)
(************************************************************************)

$if disk_maintenance_code
type PASSTABLE_HANDLER = class(
$if logical_volumes	  lv_dir : logical_volume_directory;
  dsksys	: disk_system;
  format	: internal_to_string;
  user_terminal	: circuit_handler);
$endif disk_maintenance_code

$ifnone disk_maintenance_code
type PASSTABLE_HANDLER = monitor(
  statistics	: statistics_gatherer;
  file_system	: file_system_manager;
  oplog		: operator_log);
$endif none disk_maintenance_code

var
  calendar 	: date_time_converter;
  mutil	 	: misc_utility;
  crash_util	: crash_utility;
  sysio		: system_handler;
$ifnone disk_maintenance_code
  file_util	: file_utility;
  format	: internal_to_string;
  dsksys	: disk_system;
  oper_messages	: operator_messages;
$endif none disk_maintenance_code

  PASSTABLE_DISC_ADDRESS : record
    page_offset : passtable_page_index;
    byte_offset : page_index
  end (* passtable_address *);


  PASSTABLE : actual_passtable_data;



$ifnone disk_maintenance_code



(********************  passtable_handler  *******************************)
(*									*)
(*  Name:	read_passtable_from_disc				*)
(*									*)
(*  Called By:	pasmon.initial_statement				*)
(*									*)
(*  Purpose:	bring passtable in from disc at Netval init. time.	*)
(*									*)
(*  Method:	read in table one page at a time until all pages have	*)
(*		been fetched.  CRASH SLOT ON DISC READ ERROR.		*)
(*									*)
(*  On Return:	Passtable is in memory, ready to work with.		*)
(*									*)
(************************************************************************)

procedure read_passtable_from_disc(
  var passtable : univ passtable_in_pages;
  var io_status	: file_utility_status);

var
  current_page 	: passtable_page_index;
  done		: boolean;

begin
  current_page := 0;
  done := FALSE;
  
  repeat
    file_util.read_random(FALSE, current_page, passtable[current_page],
			   io_status);
    if current_page < PASSTABLE_PAGE_LIMIT
    then current_page := current_page + 1
    else done := TRUE
  until (io_status <> FU_SUCCESS) or done
end (* read_passtable_from_disc *);



(*************************  passtable_handler  **************************)
(*									*)
(*  Name:	write_passtable_to_disc					*)
(*									*)
(*  Purpose: 	preserve current passtable on disc in case of crash	*)
(*									*)
(*  Method: 	standard disc writing procedure.  do NOT crash in case	*)
(*		of error, just report it.				*)
(*									*)
(************************************************************************)

procedure write_passtable_to_disc(
  var passtable	: univ passtable_in_pages;
  var io_status	: file_utility_status);

var
  current_page 	: passtable_page_index;
  done		: boolean;

begin
  current_page := 0;
  done := FALSE;

  repeat
    file_util.write_random(FALSE, current_page, passtable[current_page], 
							io_status);
    if current_page < PASSTABLE_PAGE_LIMIT
    then current_page := current_page + 1
    else done := TRUE
  until (io_status <> FU_SUCCESS) or done;
  
  if io_status <> FU_SUCCESS
  then 
    begin (* record unsuccessful Passtable write, in operlog *)
      format.start_message('unable to write Passtable to disc\');
$ifany (force_password_change, global_password_only_login)
      oper_messages.report_message(FILE_OPLOG_MSG);
$endif force_password_change, global_password_only_login
    end (* record unsuccessful Passtable write, in operlog *)
end (* write_passtable_to_disc *);
$endif none disk_maintenance_code
$if disk_maintenance_code



(*************************  passtable_handler  **************************)
(*									*)
(*			     do_write_passtable_file			*)
(*									*)
(************************************************************************)

procedure do_write_passtable_file(
  var passtable_buffer 	: univ passtable_in_pages;
  var ok		: boolean);

var
  page_no : passtable_page_index;
  done : boolean;

begin
  page_no := 0; done := false;
  repeat
    dsksys.page_request(
$if logical_volumes  		lv_dir.files_unit, 
$ifnone logical_volumes 	FILE_SYSTEM_DISK,
      DISK_WRITE, PASSTABLE_FILE_START+page_no, passtable_buffer[page_no], ok);
    if page_no < PASSTABLE_PAGE_LIMIT
    then page_no := page_no + 1
    else done := true
  until (not ok) or done;
  if not ok
  then format.report_file_error(PASSTABLE_FILE, WRITING_MESSAGE, 
    passtable_file_start, user_terminal)
end (* do_write_passtable_file *);


(*********************  passtable_handler  ******************************)
(*									*)
(*  Name:	move_passtable_to_disc					*)
(*									*)
(*  Purpose:	part of the restore passtable command process		*)
(*									*)
(************************************************************************)

procedure entry MOVE_PASSTABLE_TO_DISC(
      passtable_to_restore : univ actual_passtable_data;
  var ok 		   : boolean);

begin
  passtable := passtable_to_restore;
  do_write_passtable_file(passtable, ok)
end (* move_passtable_to_disc *);
$endif disk_maintenance_code
$ifnone disk_maintenance_code



(*********************  passtable_handler  ******************************)
(*									*)
(*  Name:	fetch_passtable						*)
(*									*)
(*  Purpose:	return passtable to archive subsystem for Store cmd.	*)
(*									*)
(************************************************************************)


procedure entry FETCH_PASSTABLE( 
 var passtable_buffer 	: actual_passtable_data);

begin
  passtable_buffer := passtable
end (* fetch_passtable *);
$endif none disk_maintenance_code
$if disk_maintenance_code



(*************************  passtable_handler  **************************)
(*									*)
(*			 make_new_passtable_file 			*)
(*									*)
(************************************************************************)

procedure make_new_passtable_file(
  var ok :  boolean);

var
  clear_entry		: passtable_entry_index;
  filler_count		: passtable_filler_index;
  io_status		: file_utility_status;

begin (* make_new_passtable_file *)
  passtable.header.file_id := PASSTABLE_FILE_ID;
  passtable.header.tail := 0;

  for clear_entry := 0 to PASSTABLE_ENTRY_LIMIT do
    begin (* clear every entry in passtable *)
      passtable.data[clear_entry].gan := 0;
$if force_password_change
      passtable.data[clear_entry].passlife := 0;
$if request_fpc_start      passtable.data[clear_entry].start_date := 0;
      passtable.data[clear_entry].fpc := FALSE;
$endif force_password_change
$if global_password_only_login
      passtable.data[clear_entry].gpo := FALSE
$endif global_password_only_login
    end (* clear every entry in passtable *);

  do_write_passtable_file(passtable, ok)

(**  if io_status = FU_SUCCESS
  then ok := TRUE
  else ok := FALSE **)
end (* make_new_passtable_file *);



(*************************  passtable_handler  **************************)
(*									*)
(*			      do_new_passtable_file 			*)
(*									*)
(*	Initialize the passtable file.					*)
(*									*)
(************************************************************************)

procedure do_new_passtable_file;

var
  ok : boolean;

begin
  make_new_passtable_file(ok);
  if ok
  then user_terminal.write_quoted_text_line(
  '(:13:)(:10:)PASSTABLE initialized\')
end (* do_new_passtable_file *);



(*************************  passtable_handler  **************************)
(*									*)
(*			    new_passtable_file 				*)
(*									*)
(*	Initialize passtable file in response to an INIT_PASSTABLE cmd	*)
(*									*)
(************************************************************************)

procedure entry NEW_PASSTABLE_FILE;

begin (* new_passtable_file *)
  do_new_passtable_file
end (* new_passtable_file *);
$endif disk_maintenance_code
$ifnone disk_maintenance_code



(********************  passtable_handler  *******************************)
(*									*)
(*  Name:	search_passtable					*)
(*									*)
(*  Purpose: 	Find an entry with the input GAN in it.  If the GAN is  *)
(*		not already in passtable this will find where it should *)
(*		go.							*)
(*									*)
(*  Method:	Binary search						*)
(*									*)
(*  On Return:	If the GAN is curently in Passtable:			*)
(*			Found will be TRUE				*)
(*			passtable_entry = addr of GAN's entry		*)
(*		If the GAN is NOT in Passtable:				*)
(*			Found will be FALSE				*)
(*			passtable_entry = where GAN should be		*)
(*									*)
(*									*)
(************************************************************************)

procedure search_passtable(
      search_gan   : integer;
  var search_entry : integer;
  var found        : boolean);

var
  search_head : integer;
  search_tail : integer;
  done	      : boolean;

begin (* search_passtable *)
  search_head := 0;
  search_tail := passtable.header.tail;
  done := false;

  if search_head = search_tail   (** search empty passtable **)
  then 
    begin
      found := FALSE;
      search_entry := 0
    end
  else
    begin
    while (search_tail >= search_head) and (not done) do
      begin (* binary search *)
        search_entry := (search_head + search_tail) div 2;
        if search_gan < passtable.data[search_entry].gan 
        then search_tail := search_entry - 1
        else
          if search_gan > passtable.data[search_entry].gan 
          then search_head := search_entry + 1
          else  (* search_gan = passtable.data[search_entry].gan *)
	    done := true
      end (* binary search *);
  
    found := passtable.data[search_entry].gan = search_gan;
    if not found and (search_gan > passtable.data[search_entry].gan)
	and (passtable.data[search_entry].gan <> 0) then
      search_entry := search_entry + 1
  end  (** else **)
end (* search_passtable *);



(********************  passtable_handler  *******************************)
(*									*)
(*  Name:	open_new_entry_location					*)
(*									*)
(*  Purpose:	create an opening for a new entry into Passtable	*)	
(*									*)
(*  Method:	1) Call SEARCH_PASSTABLE to find new entrie's proper	*)
(*		location (search returns found as FALSE and 		*)
(*		search_entry as where it should be).			*)
(*  		2) Move tail entry to tail + 1,	*)
(*		continue moving entries down until open_entry has been	*)
(*		moved.							*)
(*		3) If Passtable is already full return opened as FALSE	*)
(*									*)
(*  On Return:	new_entry is longer in Passtable,			*)
(*		tail = tail + 1						*)
(*									*)
(************************************************************************)

procedure open_new_entry_location( 
	open_entry_number	: integer;
  var 	opened			: boolean);

var  
  move_entry	: integer;

begin
  opened := passtable.header.tail < number_of_passtable_entries;
  if opened 
  then
    begin (* table has room, open a clear entry *)
      for move_entry := passtable.header.tail downto open_entry_number do
          passtable.data[move_entry+1] := passtable.data[move_entry];

      passtable.header.tail := passtable.header.tail + 1;
      passtable.data[open_entry_number].gan := 0
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if force_password_change
;
      passtable.data[open_entry_number].passlife := 0;
$if request_fpc_start      passtable.data[open_entry_number].start_date := 0;
      passtable.data[open_entry_number].fpc := FALSE
$endif force_password_change
$if global_password_only_login
;
      passtable.data[open_entry_number].gpo := FALSE
$endif  global_password_only_login
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    end (* table has room, open a clear entry *)
end (* open_new_entry_location *);



(********************  passtable_handler  *******************************)
(*									*)
(*  Name:	remove_passtable_entry					*)
(*									*)
(*  Purpose:	remove an entry entirely from Passtable			*)
(*									*)
(*  Method:	write over remove_entry_number with 			*)
(*		remove_entry_number + 1, continue			*)
(*		moving entries up until last valid one has been moved.	*)
(*		Zero out location last_entry came from.			*)
(*		Write Passtable to disc after change is complete.	*)
(*									*)
(************************************************************************)

procedure remove_passtable_entry(
      remove_entry_number : passtable_entry_index;
  var io_status		  : file_utility_status);		

var
  move_entry	: integer;

begin
  for move_entry := remove_entry_number to (passtable.header.tail - 1) do
    passtable.data[move_entry] := passtable.data[move_entry + 1];

  passtable.data[passtable.header.tail].gan := 0;
$if force_password_change
  passtable.data[passtable.header.tail].passlife := 0;
$if request_fpc_start     passtable.data[passtable.header.tail].start_date := 0;
  passtable.data[passtable.header.tail].fpc := false;
$endif force_password_change
$if global_password_only_login
  passtable.data[passtable.header.tail].gpo := false;
$endif global_password_only_login
  
  passtable.header.tail := passtable.header.tail - 1;

  write_passtable_to_disc(passtable, io_status)
end (* remove_passtable_entry *);
$if force_password_change



(********************  passtable_handler  *******************************)
(*									*)
(*  Name:	set_ganpass						*)
(*									*)
(*  Purpose:	grant a GAN access to global password only procedure.	*)
(*									*)
(*  Method:	1) call search_passtable to determine if the set_gan	*)
(*		already has an entry in passtable.			*)
(*		2) if it does, set the GPO boolean to TRUE		*)
(*		3) if it doesn't, call open_new_entry_location.		*)
(*		4) place set_gan into entry and set GPO boolean		*)
(*									*)
(*  On Return:	set_done = TRUE if data was added to table.		*)
(*		io_status = FU_STATUS to indicate disc write success.	*)
(*									*)
(************************************************************************)

procedure entry SET_GANPASS(
	set_gan	: integer;
      passtime	: integer;
$if request_fpc_start      start    : integer;
  var io_status	: file_utility_status;
  var found	: boolean;
  var open_ok	: boolean);

var
  set_data_entry	: integer;

begin
  set_data_entry := 0;  
  search_passtable(set_gan, set_data_entry, found);
  if not found then  (* not found *)
    begin
      open_new_entry_location(set_data_entry, open_ok);
      if open_ok
      then
        begin (* set set_data_entry's fpc variables *)
          passtable.data[set_data_entry].gan := set_gan;
          passtable.data[set_data_entry].passlife := passtime; 
$if request_fpc_start       passtable.data[set_data_entry].start_date := start;
          passtable.data[set_data_entry].fpc := TRUE;
          write_passtable_to_disc(passtable, io_status)
        end   (* set set_data_entry's fpc variables *)
    end   (* not found *)
  else  (* found *)
    if not passtable.data[set_data_entry].fpc then
      begin
        passtable.data[set_data_entry].passlife := passtime;
$if request_fpc_start     passtable.data[set_data_entry].start_date := start;
	passtable.data[set_data_entry].fpc := TRUE;
	found := FALSE;  open_ok := TRUE;
	write_passtable_to_disc(passtable, io_status)
      end  (* found *)
end (* set_ganpass *);
$endif force_password_change
$if global_password_only_login



(********************  passtable_handler  *******************************)
(*									*)
(*  Name:	set_gpogan						*)
(*									*)
(*  Called By:	command_level set command				*)
(*									*)
(*  Purpose:	grant a GAN access to global pasword only procedure.	*)
(*									*)
(*  Method:	1) call search_passtable to determine if the set_gan	*)
(*		already has an entry in passtable.			*)
(*		2) if it does, set the GPO boolean to TRUE		*)
(*		3) if it doesn't, call open_new_entry_location.		*)
(*		4) place set_gan into entry and set GPO boolean		*)
(*									*)
(*  On Return:	set_done = TRUE if data was added to table.		*)
(*		io_status = FU_STATUS to indicate disc write success.	*)
(*									*)
(************************************************************************)

procedure entry SET_GPOGAN(
	set_gan	: integer;
  var io_status	: file_utility_status;
  var found	: boolean;
  var set_ok	: boolean);

var
  set_data_entry	: passtable_entry_index;

begin
  search_passtable(set_gan, set_data_entry, found);
  if not found then 
    begin  (* not found *)
      open_new_entry_location(set_data_entry, set_ok);
      if set_ok then
        begin (* set set_data_entry's fpc variables *)
          passtable.data[set_data_entry].gan := set_gan;
          passtable.data[set_data_entry].gpo := TRUE;
          write_passtable_to_disc(passtable, io_status)
        end  (* set set_data_entry's fpc variables *)
    end  (* not found *)
  else  (* found *)
    if not passtable.data[set_data_entry].gpo then
    begin
      passtable.data[set_data_entry].gpo := TRUE;
      found := FALSE;   set_ok := TRUE;
      write_passtable_to_disc(passtable, io_status)
    end
end (* set_gpogan *);
$endif global_password_only_login
$if force_password_change



(********************  passtable_handler  *******************************)
(*									*)
(*  Name: 	clear_ganpass						*)	
(*									*)
(*  Called By: 	command_level clear command				*)
(*									*)
(*  Purpose: 	clear one or more gan password validity period defs.	*)
(*									*)
(*  On Return: 	at least one GAN's members are safe from Passchanger	*)
(*									*)
(************************************************************************)

procedure entry CLEAR_GANPASS(
      clear_gan		: integer;
  var io_status		: file_utility_status;
  var found		: boolean);

var
  clear_gan_entry_number : passtable_entry_index;

begin
  clear_gan_entry_number := 0;
  search_passtable(clear_gan, clear_gan_entry_number, found);
  if found
  then 
    if not passtable.data[clear_gan_entry_number].fpc
    then found := FALSE
    else (* fpc *)
      begin
        passtable.data[clear_gan_entry_number].passlife := 0;
$if request_fpc_start passtable.data[clear_gan_entry_number].start_date := 0;
        passtable.data[clear_gan_entry_number].fpc := FALSE;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if global_password_only_login
        if passtable.data[clear_gan_entry_number].gpo 
        then write_passtable_to_disc(passtable, io_status)
	else
$endif global_password_only_login
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
          remove_passtable_entry(clear_gan_entry_number, io_status)
      end (* fpc & found *)
end (* clear_ganpass *);
$endif force_password_change
$if global_password_only_login



(********************  passtable_handler  *******************************)
(*									*)
(*  Name: 	clear_gpogan						*)	
(*									*)
(*  Called By: 	command_level clear command				*)
(*									*)
(*  Purpose: 	remove global password only authorization from a GAN.	*)
(*									*)
(*  On Return: 	at least one GAN's members are safe from Passchanger	*)
(*									*)
(************************************************************************)

procedure entry CLEAR_GPOGAN(
  var clear_gan	: integer;
  var io_status	: file_utility_status;
  var found	: boolean);

var
  clear_gan_entry_number : passtable_entry_index;

begin
  clear_gan_entry_number := 0;
  search_passtable(clear_gan, clear_gan_entry_number, found);
  if found
  then 
    if not passtable.data[clear_gan_entry_number].gpo
    then found := FALSE
    else (* gpo *)
      begin (* actually disable global_password_only_login for the gan *)
        passtable.data[clear_gan_entry_number].gpo := FALSE;
$if force_password_change
        if passtable.data[clear_gan_entry_number].fpc  
        then write_passtable_to_disc(passtable, io_status)
	else
$endif force_password_change
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
          remove_passtable_entry(clear_gan_entry_number, io_status)
      end (* gpo & found *)
end (* clear_gpogan *);
$endif global_password_only_login
$if force_password_change



(********************  passtable_handler  *******************************)
(*									*)
(*  Name:	fetch_ganpass						*)
(*									*)
(*  Purpose:	send a GAN's password validity period to Passchanger	*)
(*									*)
(*  Method:	call search_passtable to determine if the gan has an	*)
(*		entry IN Passtable. If it does, and it's fpc boolean	*)
(*		is TRUE, return passlife variable to caller		*)
(*									*)
(*  On Return:	found = TRUE if the GAN has a defined password validity *)
(*		period, and passlife has the period in it.		*)
(*									*)
(************************************************************************)

procedure entry fetch_ganpass( 
      gan		: integer;
  var gan_passlife	: passlife_index;
$if request_fpc_start   var start               : integer;
  var found		: boolean);

var
  gan_entry : passtable_entry_index;

begin (* fetch_ganpass *)
  gan_entry := 0;
  search_passtable(gan, gan_entry, found);
  if found
  then 
    if passtable.data[gan_entry].fpc
    then
$if request_fpc_start
      begin
        start := passtable.data[gan_entry].start_date;
$endif request_fpc_start
        gan_passlife := passtable.data[gan_entry].passlife
$if request_fpc_start       end
    else found := FALSE
end (* fetch_ganpass *);



(********************  passtable_handler  *******************************)
(*									*)
(*  Name:	fetch_expiredate					*)
(*									*)
(*  Purpose:	send a users password expiration date back for 		*)
(*		Display_directory command use.				*)
(*									*)
(*  Method:	call search_passtable to determine if the gan has an	*)
(*		entry in Passtable. If it does, and it's fpc boolean	*)
(*		is TRUE, fetch password validity period from passtable	*)
(*		and add it to the input password change date, giving	*)
(*		expiration date.					*)
(*									*)
(*  On Return:	found = TRUE if the GAN has a defined password validity *)
(*		period, and expiredate has meaningfull data in it.	*)	
(*									*)
(************************************************************************)

procedure entry FETCH_EXPIREDATE( 
      gan		: integer;
      password_date	: integer;
  var expiredate	: integer;
  var pass_circle	: integer;
  var found		: boolean);

var
  gan_entry : passtable_entry_index;

begin
  gan_entry := 0;
  search_passtable(gan, gan_entry, found);
  if found
  then 
    if passtable.data[gan_entry].fpc
    then
      begin
	expiredate := (passtable.data[gan_entry].passlife * SECONDS_PER_DAY) +
$ifnot before_sup_v43            password_date;
$if before_sup_v43             (password_date * SECONDS_PER_DAY);
$if request_fpc_start
	if passtable.data[gan_entry].start_date > expiredate
	then expiredate := passtable.data[gan_entry].start_date;
$endif request_fpc_start
	pass_circle := passtable.data[gan_entry].passlife
      end
    else  found := FALSE
end (* fetch_expiredate *);
$endif force_password_change
$if global_password_only_login



(********************  passtable_handler  *******************************)
(*									*)
(*  Name:	fetch_gpogan  						*)
(*									*)
(*  Purpose:	return a GAN's global_password_only_login eligibility	*)
(*									*)
(*  Method:	call search_passtable to determine if the gan has an	*)
(*		entry in Passtable. If it does, and it's fpc boolean	*)
(*		is TRUE, return passlife variable to caller		*)
(*									*)
(*  On Return:	found = TRUE if the GAN has a defined password validity *)
(*		period, and passlife has the period in it.		*)
(*									*)
(************************************************************************)

procedure entry FETCH_GPOGAN( 
	gan : integer;
  var found : boolean);

var
  gan_entry : passtable_entry_index;

begin
  search_passtable(gan, gan_entry, found);
  if found
  then if not passtable.data[gan_entry].gpo
         then found := FALSE
end (* fetch_gpogan *);
$endif global_password_only_login
$endif none disk_maintenance_code
$if force_password_change



(********************  passtable_handler  *******************************)
(*									*)
(*  Name:	fetch_sequential_ganpass_entry				*)
(*									*)
(*  Purpose:	return one entry at a time to cmdlvl.display_ganpass	*)
(*									*)
(************************************************************************)

procedure entry FETCH_SEQUENTIAL_GANPASS_ENTRY(
      entry_to_fetch	: passtable_entry_index;
  var found_gan		: integer;
  var found_passlife	: passlife_index;
$if request_fpc_start  var start        : integer;
  var found		: boolean);

begin
  found := passtable.data[entry_to_fetch].fpc;
  if found
  then
    begin (* got a hit *)
      found_gan := passtable.data[entry_to_fetch].gan;
$if request_fpc_start start := passtable.data[entry_to_fetch].start_date;
      found_passlife := passtable.data[entry_to_fetch].passlife
    end (* got a hit *)
end (* fetch_sequential_ganpass_entry *);
$endif force_password_change
$if global_password_only_login



(********************  passtable_handler  *******************************)
(*									*)
(*  Name:	fetch_sequential_gpogan_entry				*)
(*									*)
(*  Purpose:	return one entry at a time to cmdlvl.display_gpogan	*)
(*									*)
(************************************************************************)

procedure entry FETCH_SEQUENTIAL_GPOGAN_ENTRY(
      entry_to_fetch	: passtable_entry_index;
  var found_gan		: integer;
  var found		: boolean);

begin
  found := passtable.data[entry_to_fetch].gpo;
  if found
  then found_gan := passtable.data[entry_to_fetch].gan
end (* fetch_sequential_gpogan_entry *);
$endif global_password_only_login



(********************  passtable_handler  *******************************)
(*									*)
(*  Name:	fetch_remaining_entries					*)
(*									*)
(*  Purpose:	return empty entry COUNT to a display command		*)
(*									*)
(************************************************************************)

procedure entry fetch_remaining_entries(
  var available_entries : integer);

begin
  available_entries := NUMBER_OF_PASSTABLE_ENTRIES - passtable.header.tail 
end (* fetch_remaining_entries *);
!
$ifnone disk_maintenance_code


		(* Initialization Routines *) 



(********************  passtable_handler  *******************************)
(*									*)
(*  Name:	initialize						*)
(*									*)
(*  Purpose:	read passtable into main memory from disc		*)
(*									*)
(************************************************************************)

procedure initialize;

var
  io_status	: file_utility_status;

begin
  read_passtable_from_disc(passtable, io_status);
  if (io_status <> FU_SUCCESS) or 
				(passtable.header.file_id <> PASSTABLE_FILE_ID)
  then
    begin (* report unsuccessful Passtable read then crash *)
      format.start_message('unable to read Passtable from disc \');
$ifany (force_password_change, global_password_only_login)
      oper_messages.report_message(FILE_OPLOG_MSG);
$endif force_password_change, global_password_only_login
      crash_util.halt_slot
    end (* report unsuccessful Passtable read then crash *)

end (* initialize *);
$endif none disk_maintenance_code



(************************************************************************)
(************************************************************************)

begin (* initial statement *)
$ifnone disk_maintenance_code
  init mutil, crash_util, format,
    oper_messages(oplog, format),
    file_util(PASSTABLE_FILE, statistics, file_system, oper_messages, format), 
    dsksys(statistics);
  initialize
$endif none disk_maintenance_code
end (* passtable_monitor *);
$endif any (force_password_change, global_password_only_login)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
(************************************************************************)
(*									*)
(*	MUDUTL.NTV							*)
(*									*)
(*			    mudupd_utility				*)
(*									*)
(*	This Class contains various general file_util file routines.	*)
(*									*)
(*      The following identifiers must be defined externally:		*)
(*	  mudupd_address, page, word_in_bytes, cud_change_header,	*)
(*	  mudupd_data_index, cud_change_information, file_utility	*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	30Nov87 - neh							*)
(*	      - add dnic_file_util, read_dnic_header_form_disc,		*)
(*		write_dnic_header_to_disc				*)
(*      11Oct87 - smh                                                   *)
(*              - change "mud_update : file_utility" to                 *)
(*                       "mud_file_util : file_utility"                 *)
(*                       "sched_file_util : file_utility"               *)
(*              - add write_schedtable_to_disc and                      *)
(*      27Jul87 Version 5.00 - neh					*)
(*	      - add time to cud change info if BEFORE_SUP_V43 disabled  *)
	(*		merge 4.00 and 5.00 neh			*)
(*	21Apr87 rsb							*)
(*		- change "mud_update : file_utility" to			*)
(*		         " file_util : file_utility"			*)
(*		- add write_schedtable_to_disc and			*)
(*		  read_schedtable_from_disc				*)
(*	14Mar84	Version 2.01 - jrn					*)
(*	      - use CLEAR_PAGE						*)
(*	10/20/83 Original -- jrn					*)
(*									*)
(************************************************************************)

type MUDUPD_UTILITY = class(
	mutil		: misc_utility;
	format		: internal_to_string;
	oper_messages	: operator_messages;
	mud_file_util	: file_utility;
$if INCLUDE_DNIC      dnic_file_util	: file_utility;
	sched_file_util	: file_utility);

!



(***************************  mudupd_utility  ***************************)
(*									*)
(*			        do_write_page				*)
(*									*)
(************************************************************************)

procedure do_write_page(
      location	: integer;
  var buffer	: univ page;
  var success	: boolean);

var
  io_status : file_utility_status;

begin
  mud_file_util.write_random(FALSE, location, buffer, io_status);
  success := io_status = FU_SUCCESS
end (* do_write_page *);



(***************************  mudupd_utility  ***************************)
(*									*)
(*			      do_read_page				*)
(*									*)
(************************************************************************)

procedure do_read_page(
      location	: integer;
  var buffer	: univ page;
  var success	: boolean);

var
  io_status : file_utility_status;

begin
  mud_file_util.read_random(FALSE, location, buffer, io_status);
  success := io_status = FU_SUCCESS
end (* read_page *);



(***************************  mudupd_utility  ***************************)
(*									*)
(*				get_byte				*)
(*									*)
(*      Return the next character, increment file_address		*)
(*	by one and read in a new page if necessary.			*)
(*									*)
(************************************************************************)

procedure GET_BYTE(
  var file_address	: mudupd_address;
  var data		: page;
  var success		: boolean;
  var byte		: char);

begin
  success := TRUE;
  byte := data[file_address.byte_offset];
  if file_address.byte_offset < PAGE_LIMIT
  then file_address.byte_offset := file_address.byte_offset + 1
  else
    if file_address.page_offset < MUDUPD_PAGE_LIMIT
    then
      begin (* input next page of data *)
        file_address.page_offset := file_address.page_offset + 1;
	do_read_page(file_address.page_offset, data, success);
	file_address.byte_offset := 0
      end
    else success := FALSE (* END OF FILE *)
end (* get_byte *);



(***************************  mudupd_utility  ***************************)
(*									*)
(*			   next_two_mudupd_bytes			*)
(*									*)
(*      Return the next two bytes in data pointed to by file_address	*)
(*	in a word; increment file_address past the bytes.		*)
(*									*)
(************************************************************************)

procedure NEXT_TWO_MUDUPD_BYTES(
  var file_address	: mudupd_address;
  var data		: page;
  var success		: boolean;
  var two_bytes		: univ word_in_bytes);

begin
  two_bytes[0] := ZERO;
  two_bytes[1] := ZERO;
  get_byte(file_address, data, success, two_bytes[2]);
  if success
  then get_byte(file_address, data, success, two_bytes[3])
end (* next_two_mudupd_bytes *);



(***************************  mudupd_utility  ***************************)
(*									*)
(*			   next_mudupd_word				*)
(*									*)
(*      Return the next two bytes in data pointed to by file_address	*)
(*	in a word; increment file_address past the bytes.		*)
(*									*)
(************************************************************************)

procedure next_mudupd_word(
  var file_address	: mudupd_address;
  var data		: page;
  var success		: boolean;
  var value		: univ word_in_bytes);

begin
  get_byte(file_address, data, success, value[0]);
  if success
  then get_byte(file_address, data, success, value[1]);
  if success
  then get_byte(file_address, data, success, value[2]);
  if success
  then get_byte(file_address, data, success, value[3])
end (* next_mudupd_word *);



(***************************  mudupd_utility  ***************************)
(*									*)
(*			   check_header_value				*)
(*									*)
(************************************************************************)

procedure check_header_value(
      value_limit	: integer;
      value_error	: quoted_text;
      header_value	: univ integer;
      file_address	: mudupd_address;
  var success		: boolean);
      
begin
  if header_value >= value_limit
  then
    begin
      success := FALSE;
      format.start_message('Format error in mud_update file in block \');
      format.number(file_address.page_offset, 10);
      format.string(' at \ ');
      format.number(file_address.byte_offset, 10);
      format.colon_space;
      format.string(' illegal \');
      format.string(value_error);
      format.string(' of \ ');
      format.number(header_value, 10);
      oper_messages.report_message(MUDUPD_OPLOG_MSG)
    end
end (* check_header_value *);



(***************************  mudupd_utility  ***************************)
(*									*)
(*			   extract_header_value				*)
(*									*)
(************************************************************************)

procedure EXTRACT_HEADER_VALUE(
      value_limit	: integer;
      value_error	: quoted_text;
  var file_address	: mudupd_address;
  var success		: boolean;
  var header_value	: univ integer;
  var data		: page);

begin
  next_two_mudupd_bytes(file_address, data, success, header_value);
  if success
  then check_header_value(value_limit, value_error, header_value,
    file_address, success)
end (* extract_header_value *);



(***************************  mudupd_utility  ***************************)
(*									*)
(*			   extract_header_word				*)
(*									*)
(************************************************************************)

procedure extract_header_word(
      value_limit	: integer;
      value_error	: quoted_text;
  var file_address	: mudupd_address;
  var success		: boolean;
  var header_value	: univ integer;
  var data		: page);

begin
  next_mudupd_word(file_address, data, success, header_value);
  if success
  then check_header_value(value_limit, value_error, header_value,
    file_address, success)
end (* extract_header_word *);



(***************************  mudupd_utility  ***************************)
(*									*)
(*			  compute_mudupd_address			*)
(*									*)
(*      Translate disk_pointer that describes the location		*)
(*	of the data into a page and byte offset.			*)
(*									*)
(************************************************************************)

procedure entry COMPUTE_MUDUPD_ADDRESS(
      disk_pointer	: mudupd_data_index;
  var file_address	: mudupd_address);

begin
  file_address.page_offset :=
    PAGES_IN_MUDUPD_HEADER + (disk_pointer div PAGE_SIZE);
  file_address.byte_offset := disk_pointer mod PAGE_SIZE
end (* compute_mudupd_address *);



(***************************  mudupd_utility  ***************************)
(*									*)
(*			    disk_byte_address				*)
(*									*)
(*      Translate file_address into a disk byte address.		*)
(*									*)
(************************************************************************)

function entry DISK_BYTE_ADDRESS(
	file_address : mudupd_address) : mudupd_data_index;

begin
  disk_byte_address :=
    ((file_address.page_offset - PAGES_IN_MUDUPD_HEADER) * PAGE_SIZE) +
      file_address.byte_offset
end (* disk_byte_address *);



(***************************  mudupd_utility  ***************************)
(*									*)
(*			     put_mudupd_byte				*)
(*									*)
(*      Save character, increment file_address by one and write		*)
(*	out the page if necessary.					*)
(*									*)
(************************************************************************)

procedure entry PUT_MUDUPD_BYTE(
      byte		: char;
  var file_address	: mudupd_address;
  var data		: page;
  var success		: boolean);

begin
  success := TRUE;
  data[file_address.byte_offset] := byte;
  if file_address.byte_offset < PAGE_LIMIT
  then file_address.byte_offset := file_address.byte_offset + 1
  else
    if file_address.page_offset = MUDUPD_PAGE_LIMIT
    then success := FALSE
    else
      begin
        do_write_page(file_address.page_offset, data, success);
	file_address.page_offset := file_address.page_offset + 1;
	file_address.byte_offset := 0;
	mutil.clear_page(data)
      end
end (* put_mudupd_byte *);



(***************************  mudupd_utility  ***************************)
(*									*)
(*			    extract_cud_change				*)
(*									*)
(*      Return the CUD change stored in the MUD_UPDATE_FILE at		*)
(*	file_address; increment file_address past change.		*)
(*									*)
(************************************************************************)

procedure entry EXTRACT_CUD_CHANGE(
  var file_address	: mudupd_address;
  var success		: boolean;
  var change		: cud_change_information);

var
  data : page;
$if BEFORE_SUP_V43  pointer : cud_data_index;
$ifnone BEFORE_SUP_V43  pointer : mud_data_index;
  filler : integer;

begin
  do_read_page(file_address.page_offset, data, success);

  if success
  then extract_header_value(MAXIMUM_CUD_BLOCK, 'CUD_BLOCK_INDEX\',
    file_address, success, change.header.block, data);

  if success
  then extract_header_value(
$if BEFORE_SUP_V43    CUD_DATA_WORD_MAXIMUM, 'CUD_DATA_WORD_INDEX\',
$ifnot BEFORE_SUP_V43    MAXIMUM_MUD_DATA, 'MAXIMUM_MUD_DATA_INDEX\ ',
    file_address, success, change.header.offset, data);

  if success
  then extract_header_value(
$if BEFORE_SUP_V43    CUD_DATA_WORD_MAXIMUM + 1, 'CUD_DATA_WORD_SIZE\ ',
$ifnot BEFORE_SUP_V43    MAXIMUM_MUD_DATA + 1, 'MAXIMUM_MUD_DATA_SIZE\',
    file_address, success, change.header.size, data);
  if success (* pick up 2 bytes to fill out header word or get time *)
  then 
$ifnone BEFORE_SUP_V43
  extract_header_word(REALTIME + 1, 'CUD_DATA_UTC_TIME\',
    file_address, success, change.header.time, data);
$endif BEFORE_SUP_V43
$if BEFORE_SUP_V43  next_two_mudupd_bytes(file_address, data, success, filler);
  if success
  then
    begin	(* extract the CUD data *)
      for pointer := 0 to
$if BEFORE_SUP_V43        CUD_DATA_LIMIT do
$ifnone BEFORE_SUP_V43        MUD_DATA_LIMIT do
        change.data[pointer] := ZERO;
      for pointer := 0 to
(* before SUP 43 keeps words count, 43 and later keeps byte count *)
$if BEFORE_SUP_V43      (change.header.size * MAXIMUM_BYTES_IN_WORD) - 1 do
$ifnot BEFORE_SUP_V43      change.header.size - 1 do
        if success
        then get_byte(file_address, data, success, change.data[pointer])
    end
end (* extract_cud_change *);



(***************************  mudupd_utility  ***************************)
(*									*)
(*			        write_page				*)
(*									*)
(************************************************************************)

procedure entry WRITE_PAGE(
      location	: integer;
  var buffer	: univ page;
  var success	: boolean);

begin
  do_write_page(location, buffer, success)
end (* write_page *);



(***************************  mudupd_utility  ***************************)
(*									*)
(*			      read_page					*)
(*									*)
(************************************************************************)

procedure entry READ_PAGE(
      location	: integer;
  var buffer	: univ page;
  var success	: boolean);

begin
  do_read_page(location, buffer, success)
end (* read_page *);


!
(***************************  mudupd_utility  ***************************)
(*									*)
(*		         write_schedtable_to_disc			*)
(*									*)
(************************************************************************)

procedure entry WRITE_SCHEDTABLE_TO_DISC(
  var buffer	: univ actual_schedtable_data;
  var io_status	: univ file_utility_status);

var
  location	: integer;

begin
  location := 0;
  sched_file_util.write_random(FALSE, location, buffer, io_status)
end (* write_schedtable_to_disc *);


(***************************  mudupd_utility  ***************************)
(*									*)
(*		  	read_schedtable_from_disc			*)
(*									*)
(************************************************************************)

procedure entry READ_SCHEDTABLE_FROM_DISC(
  var buffer	: univ actual_schedtable_data;
  var success	: boolean);

var
  location	: integer;
  io_status	: file_utility_status;

begin
  location := 0;
  sched_file_util.read_random(FALSE, location, buffer, io_status);
  success := io_status = FU_SUCCESS 
end (* read_schedtable_from_disc *);
$if INCLUDE_DNIC


!
(***************************  mudupd_utility  ***************************)
(*									*)
(*		         write_dnic_header_to_disc			*)
(*									*)
(************************************************************************)

procedure entry WRITE_DNIC_HEADER_TO_DISC(
      location	: integer;
  var buffer	: univ page;
  var success	: boolean);

var
  io_status : file_utility_status;

begin
  dnic_file_util.write_random(TRUE, location, buffer, io_status);
  success := io_status = FU_SUCCESS 
end (* write_dnic_header_to_disc *);


(***************************  mudupd_utility  ***************************)
(*									*)
(*		  	read_dnic_header_from_disc			*)
(*									*)
(************************************************************************)

procedure entry READ_DNIC_HEADER_FROM_DISC(
      location	: integer;
  var buffer	: univ page;
  var success	: boolean);

var
  io_status	: file_utility_status;

begin
  dnic_file_util.read_random(FALSE, location, buffer, io_status);
  success := io_status = FU_SUCCESS 
end (* read_dnic_header_from_disc *);
$endif include_dnic


(************************************************************************)
(************************************************************************)

begin (* initial statement *)
end (* mudupd_utility *);
!
(************************************************************************)
(*									*)
(*	MUDCHG.NTV							*)
(*									*)
(*			    mud_change_handler				*)
(*									*)
(*	This Monitor controls the updating of the Supervisor MUDs	*)
(*	and Class/group Table.  Pertinent information is maintained	*)
(*	on the disk in the MUD_UPDATE file, and the monitor controls	*)
(*	the access and updating of the file.				*)
(*									*)
(*	Version 4.00 adds SCHEDTABLE, and it's maintanence.		*)
(*	Also, this monitor starts PASSCHANGER and UUN MERGE 		*)
(*	processes at their appointed times.				*)
(*									*)
(*      The routines are organized as follows:				*)
(*		initialization routines					*)
(*		merge UUN routines					*)
(*		legal Supervisor routines				*)
(*		consistency schedule routines				*)
(*		class/group routines					*)
(*		cud_entry_updater routines				*)
(*		mud_updater routines					*)
(*		consistency routines					*)
(*		tick routines						*)
(*		validator command routines				*)
(*		archive routines					*)
(*									*)
(*      The following identifiers must be defined externally:		*)
(*	  class_group_status, consistency_info, mudupd_address, page,	*)
(*	  mudupd_disk_header, mudupd_data_index, validator_index,	*)
(*	  cud_data, cud_change_information, supervisor_index,		*)
(*	  word_in_bytes, cud_block_index, in_core_supervisor_info	*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	12Jan89 - neh							*)
(*	      - add delay to UPDATE_WAITING until 10 sec after		*)
(*		consistency stops in order to wait for UN2.		*)
(*	20Sep88 - jrn							*)
(*		- change back to clearing Supervisors when INITIALIZE	*)
(*		  MUDUPDATE command is executed				*)
(*		- add password_expiration_by_user code			*)
(*		- add prevent_duplicate_passwords code			*)
(*	18Nov87 - neh							*)
(*	      - add last_dnic_status to supervisor_in_core_information	*)
(*	      - add clear DNIC info in clear_muf_header_info		*)
(*	      - add DNIC table routines, SET_DNIC_DATE,			*)
(*		SET_SUP_DNIC_STATUS, DNIC_DATE, SUP_DNIC_STATUS and	*)
(*		DNIC_TO_SEND						*)
(*	14Aug87 - neh							*)
(*	      - replace tymshare_cud_format with check_time_status	*)
(*	18May87 - neh							*)
(*	      - change make_new_file to turn off supervisors		*)
(*		greater than MAXIMUM_EXPECTED_SUPVISORS			*)
		(*	Merge 4.00 and 5.00		*)
(*	01Apr87 - rsb							*)
(*		- change internal name of file_utility from		*)
(*		  mud_update to file_util				*)
(*	03Dec86 - rsb							*)
(*		- change name of DO_CLEAR_HEADER_INFO to		*)
(*		  CLEAR_MUF_HEADER_INFO					*)
(*	12Nov86	- rsb							*)
(*		- add more schedule info to mud change file header	*)
(*		  and add new procedures to work with the new data	*)
(*		- add set_consistency_schedule				*)
(*		- add set_passchanger_schedule				*)
(*		- add set_uunmerge_schedule				*)
(*		- add clear_consistency_schedule			*)
(*		- add clear_passchanger_schedule			*)
(*		- add clear_uunmerge_schedule				*)
(*		- change SET_NEXT_MERGE_TIME so it works with		*)
(*		  schedtable.uunmerge_schedule, making "A" file		*)
(*		  parameter ADD_BACK_TIME meaningless			*)
(*		- moving consistency schedule to Schedtable means it is	*)
(*		  no longer in the mud change file header.		*)
(*		- Therefore, do_clear_header_info no longer clears	*)
(*		  consistency_start/stop				*)
(*		- check_time will now check for passchanger and 	*)
(*		  uun_merge run times.					*)
(*		- add passchanger_delay_que				*)
(*	17Feb87 - neh							*)
(*	      - add turn_sup_off if BEFORE_SUP_V43 is disabled		*)
(*	31Jul86 - rsb							*)
(*		- add "current_un2_activity" of type 			*)
(*		  "current_comm_activity" to IN_CORE_INFO		*)
(*		  use it insetad of checking for consistency start_time *)
(*		  not being 0 as an indicator of what Netval is doing   *)
(*		- modify SET_SUPERVISOR to use 				*)
(*		  sup_core_info.current_un2_activity			*)
(*		  which involves rewriting SET_SUP:OFF into a four-way  *)
(*		  case statement.					*)
(*		- change name of REPORT_CONSISTENCY_START to		*)
(*		  RECORD_CONSISTENCY_STARTED.				*)
(*		  SET_SUP:ON at start set current_un2_activity to	*)
(*		  NOT_BUSY.  Also set it to AUTO_CONSISTENCY if that	*)
(*		  flag is true.						*)
(*		- add setting of CURRENT_UN2_ACTIVITY := NOT_BUSY to	*)
(*		  REPORT_CONSISTENCY_OVER				*)
(*		- change name of DO_CLEAR_SUP_INFO to 			*)
(*		  INIT_SUP_INFO						*)
(*		- change name of CLEAR_CURRENT_CONSISTENCY_SUP_INFO to	*)
(*		  CLEAR_CURRENT_CONSISTENCY_SUP_SINK_INFO		*)
(*		- change name of CLEAR_CURRENT_SUP_INFO to		*)
(*		  INIT_SUP_CORE_INFO					*)
(*		- change SUP_INFO into SUP_DISC_INFO			*)
(*		- change SUP_SINK into SUP_CORE_INFO			*)
(*		- change name of set_to_be_stopped_true into		*)
(*		  SET_TO_BE_STOPPED_TRUE				*)
(*		- change name of 					*)
(*		  supervisor_in_core_information.INITIALIZING to	*)
(*		  ....RUN_INIT_AUTO_CONSISTENCY				*)
(*		- change name of SET_SUPERVISOR_OFF to			*)
(*		  SET_SUP_OFF in order to create an entry point		*)
(*		  called SET_SUPERVISOR_OFF for calling by MUDUPDATER	*)
(*		- create entry point CONTINUE_WAIT_FOR_STOP_QUE so	*)
(*		  mudupdater can continue a set_sup:off.		*)
(*	25Apr86 - jrn							*)
(*	      - fix bug that caused defining the consistency period	*)
(*		across the end of day boundry not to work		*)
(*	01Apr86 - jrn							*)
(*	      - if Tymnet, add a delay queue for the oplog_reporter	*)
(*		process							*)
(*	10Mar86 - jrn							*)
(*	      - redo reuse_uuns to maintain a bit map for 18 bit UUNS	*)
(*		and change the add back scheme to be a dated list	*)
(*	      - change merge_month_changed to delay_uun_merger;		*)
(*		the merge_uun process will be delayed in the uun_merger	*)
(*		queue until it is time to perform the merge; it is	*)
(*		continued by the check_time procedure			*)
(*	      - change merge_month to last_merge			*)
(*	13Feb86 - rsb							*)
(*		- create WAIT_FOR_STOP_IS_EMPTY for mud_updater_delay	*)
(*	23Jan86	- rsb							*)
(*		- Create WRITE_HEADER_TO_DISC				*)
(*		  crash_utility.halt_slot if disc write fails		*)
(*		- Initialize						*)
(*		  set_merge_date					*)
(*		  set_supervisor					*)
(*		  set_schedule						*)
(*		  set_table_date					*)
(*		  cud_change_in_progress				*)
(*		  set_sup_table_status					*)
(*		  abort_cud_change					*)
(*		  mud_update_complete					*)
(*		  report_consistency_error				*)
(*		  - call write_header to write header to disc		*)
(*		- Set_Supervisor: remove possibility of setting		*)
(*		  success = set_sup_disc_error, since 			*)
(*		  write_header_to_disc will crash if an error occurs.	*)
(*		- read_eof_buffer					*)
(*		  - change "success" into local variable "read_ok"	*)
(*		  - crash_utility.halt_slot if read_ok = FALSE		*)
(*		- change every "success: boolean" into either		*)
(*		  "write_ok" or "read_ok" as appropriate.		*)
(*		- Set_Merge_date: remove "success" as call parameter	*)
(*	13Jan86	- rsb							*)
(*		- Set_Supervisor: add messages in case Supervisor	*)
(*		  status changes between Command Level and Mud Change 	*)
(*		  Handler  - i.e. 2 validators setting same sup off 	*)
(*		  simultaneously.					*)
(*		- rename SUP_DELAY_QUE as MUD_UPDATER_DELAY_QUE in order*)
(*		  to make name more related to function			*)
(*		- Create WAIT_FOR_STOP_QUE in case setting a Supervisor *)
(*		  Off and need to wait for a mud update or 		*)
(*		  automatic consistency block to finish movement to sup	*)
(*		- Mud_Update_Complete and Report_Consistency_Over: 	*)
(*		  add attempt to continue procedure in wait_for_stop_que*)
(*		  if real_sup not in pseudo_sup_table then		*)
(*		  crash_utility.halt_slot				*)
(*	02Jan86 - rsb							*)
(*		- Eliminate SUPERVISOR_SINK_INFORMATION.		*)
(*		- Redefine SUP_SINK as just supervisor_in_core_infor-	*)
(*		  mation						*)
(*		- rewrite find_update_waiter for USN enhancement	*)
(*		- rewrite find_consistency_to_run for USN		*)
(*		- change rewrite check_time for USN			*)
(*		- rewrite check_time for USN				*)
(*		- add init of "aux_io(mutil)" to initialization		*)
(*	23Dec85	- rsb							*)
(*		- Sup_Sink: remove ".waiter" from "supervisor_sink	*)
(*		  information."						*)
(*		-  Sup_Delay_Que: create to replace ".waiter."		*)
(*		-  Circuit_Handler: include an instance and init it.	*)
(*		-  Pseudo_Sup_Table: create and initialize		*)
(*		-  any_mud_updates,  stop_consistency,:			*)
(*		-  change to "real_sup : real_sup_index."		*)
(*		-  re: Mudupd_disc_header:  "sup_info[sup]" becomes	*)
(* 		   "sup_info[real_sup]."				*)
(*		-  stop_consistency:  use "real_supervisor_index."	*)
(*		-  All above for USN.					*)
(*	10Jan85 - jrn							*)
(*	      - perform a time validity check				*)
(*	      - write a message to the operator log when the MUD	*)
(*		change file is caught up				*)
(*	18Dec84 - jrn							*)
(*	      - add all logical volume code				*)
(*	13Dec84 - neb							*)
(*	      - add merge_month_changed and set_merge_date for 		*)
(*		conditional assembly parameter reuse_uuns		*)
(*	16Aug84 - jrn							*)
(*	      - change calls to dsksys for NVDM				*)
(*	20Jun84 - jrn							*)
(*	      - removed get_schedule routine				*)
(*	      - add NVDM code (including removal of archive restore	*)
(*		handling)						*)
(*	14Mar84	Version 2.01 - jrn					*)
(*	      - do not attempt a MUD update or automatic consistency if	*)
(*		a manual consistency is running				*)
(*	      - set all Supervisors to OFF and the last_cg_creation to	*)
(*		zero on ARCHIVE store and restore			*)
(*		Original -- jrn						*)
(*									*)
(************************************************************************)



type
  SUPERVISOR_IN_CORE_INFORMATION = record
    consistency			: consistency_info;
    nochange			: boolean (* TRUE if no change consistency *);
    run_init_auto_consistency	: boolean (* run consis after set_sup:on *);
    to_be_stopped		: boolean (* abort current auto consistency *);
    last_cg_status		: class_group_status;
$if INCLUDE_DNIC    last_dnic_status		: dnic_table_status;
    current_un2_activity	: current_comm_activity
  end (* supervisor_in_core_information *);



(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code
type MUD_CHANGE_HANDLER = class(
$if logical_volumes	lv_dir	: logical_volume_directory;
	dsksys		: disk_system;
	format		: internal_to_string;
	user_terminal	: circuit_handler);

const
  INCARNATION_0_MUD_UPDATE_FILE_START = 150 (* hard-coded, as in Version 1 *);


var
  calendar 	: date_time_converter;
  schedtable	: actual_schedtable_data;

$endif disk_maintenance_code
$ifnone disk_maintenance_code
type MUD_CHANGE_HANDLER =  monitor(
	statistics	: statistics_gatherer;
	file_system	: file_system_manager;
	oplog		: operator_log);


const
  ACCEPTABLE_TIME_DIFFERENCE = 10 * 60 (* seconds *);



(*	The following describes the in-core buffer	*)
(*	from the MUD_UPDATE file.			*)

type
  in_core_buffer = record
    data    : page		(* page from file *);
    address : mudupd_address	(* points to eof byte, page *)
  end (* in_core_buffer *);



(* This record helps in computing all sorts of consistency/time		*)
(* relationships, and was added to deal with schedules across midnight.	*)

  current_consistency_information = record
    this_time		: integer;
    start_time		: integer;
    stop_time		: integer;
    during_period	: boolean
  end (* current_consistency_information *);



var
  mutil            : misc_utility;
  crash_util       : crash_utility;
  next             : fifo;
  calendar         : date_time_converter;
  format           : internal_to_string;
  oper_messages    : operator_messages;
  mud_file         : file_utility;
  sched_file	   : file_utility;
$if INCLUDE_DNIC  dnic_file_util	: file_utility;
  mud_utility      : mudupd_utility;
  dsksys           : disk_system;
  cud_block_reader : cud_block_utility;
  aux_io           : circuit_handler;


  current_consistency : current_consistency_information;

  schedtable : actual_schedtable_data;



(* compare the time with last_time to check for	*)
(* valid time received from the node.		*)

  last_time : integer;



(* the last page and its address from the file. *)
(* used to update file, so that it  *)
(* does not have to be read in all  *)
(* the time when updating.          *)

  eof_buffer : in_core_buffer;



(* mud_updater processes are delayed here until either:		*)
(* 1)  a Mud change is pending for the Mud_Updater's Supervisor *)
(* 2)  it is time to start an Automatic Consistency on the Sup	*)

  mud_updater_delay_que : array [pseudo_supervisor_index] of queue;


(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if force_password_change
(* Passchanger process is delayed here until 			*)
(* realtime > next_passchanger_start_time			*)

  passchanger_delay_que : queue;


$endif force_password_change
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(* Mud_change.set_supervisor waits here if it is trying 	*)
(* to set a Supervisor OFF and the Supervisor is currently	*)
(* in the process of receiving either: 1) Mud change block	*)
(* or 2) Automatic Consistency mud block.  Setting the Sup	*)
(* OFF will be done after block transmission completes.		*)

  wait_for_stop_que : array [pseudo_supervisor_index] of queue;



(* in core data for all Supervisors *)
(* includes current consistency information, *)
(* a delay queue and Class/group status.     *)

  sup_core_info : array [real_supervisor_index] of
					supervisor_in_core_information;



(* 	The file pointer to the byte following the last good 	*)
(* data to be distributed to MUDs.  This should match the	*)
(* disk pointer (header_info.disk_eof) EXCEPT during the time that	*)
(* CUD_CHANGE_PENDING in TRUE (after cud_change_in_progress	*)
(* is called and before abort_cud_change or confirm_cud_change	*)
(* is called).							*)

  updater_eof : mudupd_data_index;



(* TRUE if file is locked during a CUD update (it is	*)
(* locked to other CUD updates only).  This is set to   *)
(* TRUE in the cud_change_in_progress routine and set	*)
(* to FALSE in either the confirm_cud_change or the	*)
(* abort_cud_change routine.		                *)

  cud_change_pending : boolean;



(*	This is where validators are delayed while	*)
(* cud_change_pending is TRUE. Validators are delayed	*)
(* in a queue in the cud_change_in_progress routine	*)
(* and continued in either the abort_cud_change or	*)
(* confirm_cud_change routine.  Validators are delayed	*)
(* in their validator_index entry.			*)

  waiting_for_mud_change : array [validator_index] of queue;



(*	This is the ordered list of validators waiting	*)
(* to add CUD changes to the MUD_UPDATE file. It is	*)
(* controlled by the FIFO Class, which is set up for	*)
(* MAXIMUM_VALIDATOR entries. Validators are added to	*)
(* the list indexed by fifo.arrival and are removed	*)
(* from the list at fifo.departure.			*)

  mud_change_waiting_list : array [validator_index] of validator_index;



(*	This is the value that is checked (when a new record	*)
(* is written to the file) to see if the operator_log should	*)
(* be notified that the file is getting "full".  It is		*)
(* initialized to halfway between the current size and the	*)
(* end-of-file and is updated when the operator_log message is	*)
(* sent or when the disk_eof is reset to zero.			*)

  getting_full_mark : mudupd_data_index;



(* the disk header...to be read at initialization, and written when *)
(* appropriate; should always match the values on the disk.         *)

  header : mudupd_disk_header;

$if INCLUDE_DNIC
(* the dnic table header...to be read at initialization, written    *)
(* when sent and updated					    *)

  dnic_header : dnic_table_header;
$endif INCLUDE_DNIC
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if reuse_uuns



(* delay merge_uunfile process here until time to run a merge. *)

  uun_merger_queue : queue;
$endif reuse_uuns


(* table to maintain correlation between a Supervisor's number	*)
(* (real_supervisor_index) and MUD_UPDATER			*)
(* process number (pseudo_sup_index).				*)

  pseudo_sup_table : array [pseudo_supervisor_index] of ps_table_search_range;
$endif disk_maintenance_code
$if check_time_status
$ifnone disk_maintenance_code



(* the oplog_reporter is delayed here for  *)
(* OPLOG_REPORTER_DELAY seconds *)

  oplog_reporter_queue : queue;
!



(************************  mud_change_handler  **************************)
(*									*)
(*			set_oplog_reporter_time				*)
(*									*)
(************************************************************************)

procedure set_oplog_reporter_time;

var
  io_status	: file_utility_status;

begin
  schedtable.data.continue_oplog_reporter_time := REALTIME +
    OPLOG_REPORTER_DELAY;
  mud_utility.write_schedtable_to_disc(schedtable, io_status)
end (* set_oplog_reporter_time *);
$endif disk_maintenance_code
$endif check_time_status
$ifnone disk_maintenance_code



(************************  mud_change_handler  **************************)
(*									*)
(*			    search_ps_table				*)
(*									*)
(************************************************************************)

procedure search_ps_table(
      search_value           : ps_table_search_range;
  var pseudo_sup_table_entry : pseudo_supervisor_index;
  var found                  : boolean);

var
  done : boolean;

begin (* search_ps_table *)
  pseudo_sup_table_entry := FIRST_SUPERVISOR;
  done := FALSE;
  found := FALSE;
  repeat
   If Pseudo_sup_Table[pseudo_sup_table_entry] = search_value
   then found := TRUE
   else
     if pseudo_sup_table_entry = MAXIMUM_EXPECTED_SUPERVISORS
     then done := TRUE
     else pseudo_sup_table_entry := pseudo_sup_table_entry + 1;
  until found or done;
end (* search_ps_table *);



(**************************  mud_change_handler  ************************)
(*									*)
(*				xlate_ps_to_rs				*)
(*									*)
(* 	Given pseudo_sup_number return real_sup_number.			*)
(*									*)
(************************************************************************)

procedure xlate_ps_to_rs(
      pseudo_sup : pseudo_supervisor_index;
  var real_sup   : real_supervisor_index;
  var found	 : boolean);

begin (* xlate_ps_to_rs *)
  found := FALSE;
  real_sup := pseudo_sup_table[pseudo_sup];
  if real_sup <> EMPTY_ENTRY
  then found := TRUE
end (* xlate_ps_to_rs *);



(*************************  mud_change_handler  *************************)
(*									*)
(*                       translate_rs_to_ps				*)
(*									*)
(*   Find a Supervisor's entry in the pseudo_sup_table for an external  *)
(*   procedure.								*)
(*									*)
(************************************************************************)

procedure entry TRANSLATE_RS_TO_PS(
      real_sup		: real_supervisor_index;
  var pseudo_sup	: pseudo_supervisor_index);

var
  found : boolean;

begin (* translate_rs_to_ps *)
  search_ps_table(real_sup, pseudo_sup, found);
  if not found
  then crash_util.halt_slot
end (* translate_rs_to_ps *);



(******************  mud_change_handler  ********************************)
(*									*)
(*			write_header_to_disc				*)
(*									*)
(*	write disc header for Supervisor.  Crash on a disc error	*)
(*									*)
(************************************************************************)

procedure write_header_to_disc;

var
  write_ok : boolean;

begin (* write_header_to_disc *)
  mud_utility.write_page(MUDUPD_HEADER_ADDRESS, header, write_ok);
  if not write_ok
  then crash_util.halt_slot
end (* write_header_to_disc *);
$if INCLUDE_DNIC


(******************  mud_change_handler  ********************************)
(*									*)
(*			write_dnic_header_to_disc			*)
(*									*)
(*	write disc dnic_header for Supervisor.  Crash on a disc error	*)
(*									*)
(************************************************************************)

procedure write_dnic_header_to_disc;

var
  write_ok : boolean;

begin (* write_dnic_header_to_disc *)
  mud_utility.write_dnic_header_to_disc(DNIC_HEADER_ADDRESS,
    dnic_header, write_ok);
  if not write_ok
  then crash_util.halt_slot
end (* write_dnic_header_to_disc *);
$endif INCLUDE_DNIC
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
"
		Routines common to NVAL and NVDM
"



(************************  mud_change_handler  **************************)
(*									*)
(*			   init_sup_disc_info				*)
(*									*)
(*	initialize mud_update_file header, which is disc-resident	*)
(*									*)
(************************************************************************)

procedure init_sup_disc_info(
      real_sup	    : real_supervisor_index;
  var sup_disc_info : supervisor_disk_information);

begin (* init_sup_disc_info *)
  with sup_disc_info do
    begin
      state := real_sup;
      pointer := 0;
      last_mud_update := 0;
      last_cg_update := 0;
      with history.consistency do
	begin
	  start_date := 0;
	  block := 0;
	  manual := FALSE;
	  stopped := FALSE
	end;
      history.stop_date := 0
    end
end (* init_sup_disc_info *);



(*************************  mud_change_handler  *************************)
(*									*)
(*			   set_sup_off					*)
(*									*)
(************************************************************************)

procedure set_sup_off(
      real_sup  	: real_supervisor_index;
  var header_info  	: mudupd_disk_header);

begin
  header_info.sup_disc_info[real_sup].state := SUPERVISOR_OFF;
  header_info.sup_disc_info[real_sup].pointer := 0;
end (* set_sup_off *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code



(*************************  mud_change_handler  *************************)
(*									*)
(*			   continue_wait_for_stop_que			*)
(*									*)
(*	Entry point so mud_updater can continue a delayed set_sup:off	*)
(*	command.							*)
(*									*)
(************************************************************************)

procedure entry CONTINUE_WAIT_FOR_STOP_QUE(
      pseudo_sup  	: pseudo_supervisor_index);

begin (* continue_wait_for_stop_que *)
  continue(wait_for_stop_que[pseudo_sup])
end (* continue_wait_for_stop_que *);
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(*************************  mud_change_handler  *************************)
(*									*)
(*			    clear_mudupd_header				*)
(*									*)
(*      Clear the end-of-file pointer and set all Supervisors to OFF	*)
(*	for an ARCHIVE operation.					*)
(*	This forces the validator to turn Supervisors ON after a	*)
(*	RESTORE.							*)
(*									*)
(************************************************************************)

procedure clear_mudupd_header(
  var header : univ mudupd_disk_header);

var
  real_sup : real_supervisor_index;

begin
  header.disk_eof := 0;
  header.last_record := 0;
  header.last_cg_creation := 0;
$if INCLUDE_DNIC
  header.last_dnic_update := 0;
  header.dnic_on_all_sups := FALSE;
  header.dnic_on_some_sups := FALSE;
$endif INCLUDE_DNIC
  for real_sup := FIRST_SUPERVISOR to MAXIMUM_REAL_SUPERVISOR do
    set_sup_off(real_sup, header)
end (* clear_mudupd_header *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code
!
"
		Initialization Routines
"



(*************************  mud_change_handler  *************************)
(*									*)
(*			    reset_getting_full				*)
(*									*)
(*      Set getting_full_mark to halfway between the logical		*)
(*	end-of-file (header.disk_eof) and the physical end-of-file	*)
(*	(MUDUPD_DATA_MAX).						*)
(*									*)
(************************************************************************)

procedure reset_getting_full;

begin
  getting_full_mark := header.disk_eof +
    ((MUDUPD_DATA_MAX - header.disk_eof) div 2)
end (* reset_getting_full *);



(*************************  mud_change_handler  *************************)
(*									*)
(*		    clear_current_consistency_sup_core_info		*)
(*									*)
(*      Clear current consistency Supervisor info in sup_core_info.	*)
(*									*)
(************************************************************************)

procedure clear_current_consistency_sup_core_info(
      real_sup	: real_supervisor_index);

begin
  sup_core_info[real_sup].consistency.start_date := 0;
  sup_core_info[real_sup].consistency.block := 0;
  sup_core_info[real_sup].consistency.manual := FALSE;
  sup_core_info[real_sup].consistency.stopped := FALSE
end (* clear_current_consistency_sup_core_info *);



(*************************  mud_change_handler  *************************)
(*									*)
(*			  init_sup_core_info				*)
(*									*)
(*      Clear current Supervisor info in sup_core_info.			*)
(*									*)
(************************************************************************)

procedure init_sup_core_info(
      real_sup	: real_supervisor_index);

begin
  clear_current_consistency_sup_core_info(real_sup);
  sup_core_info[real_sup].run_init_auto_consistency := FALSE;
  sup_core_info[real_sup].to_be_stopped := FALSE;
  sup_core_info[real_sup].last_cg_status := CLASS_GROUP_NOT_TRIED;
$if INCLUDE_DNIC
  sup_core_info[real_sup].last_dnic_status := DNIC_UPDATE_NOT_TRIED;
$endif INCLUDE_DNIC
  sup_core_info[real_sup].current_un2_activity := NOT_BUSY
end (* init_sup_core_info *);



(*************************  mud_change_handler  *************************)
(*									*)
(*			      read_eof_buffer				*)
(*									*)
(*      Read in the page pointed to by eof_pointer from the		*)
(*	MUD_UPDATE file and set up eof_buffer.				*)
(*									*)
(************************************************************************)

procedure read_eof_buffer;

var
  read_ok : boolean;

begin
  mud_utility.compute_mudupd_address(header.disk_eof, eof_buffer.address);
  mud_utility.read_page(eof_buffer.address.page_offset, eof_buffer.data,
    read_ok);
  if not read_ok
  then crash_util.halt_slot
end (* read_eof_buffer *);



(*************************  mud_change_handler  *************************)
(*									*)
(*			       legal_sup				*)
(*									*)
(*      Return TRUE if Supervisor is in-use.				*)
(*									*)
(************************************************************************)

function legal_sup(
      real_sup	: real_supervisor_index) : boolean;

begin
  legal_sup := header.sup_disc_info[real_sup].state = real_sup
end (* legal_sup *);



(*************************  mud_change_handler  *************************)
(*									*)
(*  Name:	fetch_consistency_schedule				*)
(*									*)
(*  Purpose:	return consistency schedule for screen display		*)
(*									*)
(************************************************************************)

procedure entry FETCH_CONSISTENCY_SCHEDULE(
  var enabled		: boolean;
  var start_time	: integer;
  var end_time		: integer);

begin (* fetch_consistency_schedule *)
  enabled := schedtable.data.consistency_enabled;
  start_time := schedtable.data.consistency_start;
  end_time := schedtable.data.consistency_end
end (* fetch_consistency_schedule *);
$if force_password_change



(*************************  mud_change_handler  *************************)
(*									*)
(*  Name:	fetch_passchanger_schedule				*)
(*									*)
(*  Purpose:	return passchanger schedule for screen display		*)
(*									*)
(************************************************************************)

procedure entry FETCH_PASSCHANGER_SCHEDULE(
  var enabled		: boolean;
  var start_time	: integer);

begin (* fetch_passchanger_schedule *)
  enabled := schedtable.data.passchanger_enabled;
  start_time := schedtable.data.passchanger_schedule
end (* fetch_passchanger_schedule *);
$endif force_password_change
$if reuse_uuns



(*************************  mud_change_handler  *************************)
(*									*)
(*  Name:	fetch_uun_merge_schedule				*)
(*									*)
(*  Purpose:	return uun_merge schedule for screen display		*)
(*									*)
(************************************************************************)

procedure entry FETCH_UUN_MERGE_SCHEDULE(
  var enabled		: boolean;
  var start_time	: integer);

begin (* fetch_uun_merge_schedule *)
  enabled := schedtable.data.uunmerge_enabled;
  start_time := schedtable.data.uunmerge_schedule
end (* fetch_uun_merge_schedule *);
$endif reuse_uuns
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$endif none disk_maintenance_code
$if disk_maintenance_code
$ifany (password_expiration_by_user, prevent_duplicate_passwords)



(*************************  mud_change_handler  *************************)
(*									*)
(*			   read_schedtable_file				*)
(*									*)
(************************************************************************)

procedure read_schedtable_file(
  var schedtable_buffer	: univ actual_schedtable_data;
  var ok		: boolean);

begin
  dsksys.page_request(
$if logical_volumes     lv_dir.files_unit, 
$ifnone logical_volumes     FILE_SYSTEM_DISK,
    DISK_READ,SCHEDTABLE_FILE_START, schedtable_buffer, ok);
  if not ok
  then format.report_file_error(SCHEDTABLE_FILE, READING_MESSAGE,
    SCHEDTABLE_FILE_START, user_terminal)
end (* read_schedtable_file *);
$endif (password_expiration_by_user, prevent_duplicate_passwords)



(*************************  mud_change_handler  *************************)
(*									*)
(*			   write_schedtable_file			*)
(*									*)
(************************************************************************)

procedure write_schedtable_file(
  var schedtable_buffer	: univ actual_schedtable_data;
  var ok		: boolean);

begin
  dsksys.page_request(
$if logical_volumes	lv_dir.files_unit, 
$ifnone logical_volumes	FILE_SYSTEM_DISK,
    DISK_WRITE,	SCHEDTABLE_FILE_START, schedtable_buffer, ok);
  if not ok
  then format.report_file_error(SCHEDTABLE_FILE, WRITING_MESSAGE,
    SCHEDTABLE_FILE_START, user_terminal)
end (* write_schedtable_file *);



(*************************  mud_change_handler  *************************)
(*									*)
(*  Name:	move_schedtable_to_disc					*)
(*									*)
(*  Purpose:	write schedtable just read from tape out to disc in	*)
(*		order to Restore Schedtable				*)
(*									*)
(************************************************************************)

procedure entry MOVE_SCHEDTABLE_TO_DISC( 
  var tape_schedtable 	: univ actual_schedtable_data;
  var ok		: boolean);

begin (* write_tape_schedtable_to_disc *)
  schedtable := tape_schedtable;
  write_schedtable_file(tape_schedtable, ok)
end (* move_schedtable_to_disc *);
$endif disk_maintenance_code
$if password_expiration_by_user


(*************************  mud_change_handler  *************************)
(*									*)
(*		standard_password_validity_in_seconds			*)
(*									*)
(************************************************************************)

function entry STANDARD_PASSWORD_VALIDITY_IN_SECONDS : integer;

$if disk_maintenance_code
var
  ok : boolean;

$endif disk_maintenance_code
begin
$if disk_maintenance_code   read_schedtable_file(schedtable, ok);
  STANDARD_PASSWORD_VALIDITY_IN_SECONDS :=
    schedtable.data.standard_password_validity_period
end (* standard_password_validity_in_seconds *);



(*************************  mud_change_handler  *************************)
(*									*)
(*		set_standard_password_validity_period			*)
(*									*)
(*  Purpose:	write new standard_password_validity_period to disk	*)
(*									*)
(************************************************************************)

procedure entry SET_STANDARD_PASSWORD_VALIDITY_PERIOD(
     validity_period	: integer;
$ifnone disk_maintenance_code  var io_status	: univ file_utility_status);
$if disk_maintenance_code   var ok		: boolean);

begin
$if disk_maintenance_code   read_schedtable_file(schedtable, ok);
  schedtable.data.standard_password_validity_period := validity_period;
$if disk_maintenance_code
  if ok
  then write_schedtable_file(schedtable, ok)
$endif disk_maintenance_code
$ifnone disk_maintenance_code
    mud_utility.write_schedtable_to_disc(schedtable, io_status)
$endif disk_maintenance_code
end (* set_standard_password_validity_period *);
$endif password_expiration_by_user
$if prevent_duplicate_passwords



(*************************  mud_change_handler  *************************)
(*									*)
(*		minimum_password_change_time_in_seconds			*)
(*									*)
(************************************************************************)

function entry MINIMUM_PASSWORD_CHANGE_TIME_IN_SECONDS : integer;

$if disk_maintenance_code
var
  ok : boolean;

$endif disk_maintenance_code
begin
$if disk_maintenance_code   read_schedtable_file(schedtable, ok);
  MINIMUM_PASSWORD_CHANGE_TIME_IN_SECONDS :=
    schedtable.data.password_change_time_in_seconds
end (* minimum_password_change_time_in_seconds *);



(*************************  mud_change_handler  *************************)
(*									*)
(*  Name:	set_minimum_password_change_time			*)
(*									*)
(*  Purpose:	write new password_change_time_in_seconds to disk	*)
(*									*)
(************************************************************************)

procedure entry SET_MINIMUM_PASSWORD_CHANGE_TIME(
  var new_time	: integer;
$ifnone disk_maintenance_code   var io_status	: univ file_utility_status);
$if disk_maintenance_code   var ok	: boolean);

begin
$if disk_maintenance_code   read_schedtable_file(schedtable, ok);
  schedtable.data.password_change_time_in_seconds := new_time;
$if disk_maintenance_code
  if ok
  then write_schedtable_file(schedtable, ok)
$endif disk_maintenance_code
$ifnone disk_maintenance_code
    mud_utility.write_schedtable_to_disc(schedtable, io_status)
$endif disk_maintenance_code
end (* set_minimum_password_change_time *);
$endif prevent_duplicate_passwords
$ifnone disk_maintenance_code



(********************* mud_change_handler *******************************)
(*									*)
(*  Name:	fetch_schedtable					*)
(*									*)
(*  Purpose:	return schedtable to arccmd so it can be saved on tape	*)
(*									*)
(************************************************************************)

procedure entry FETCH_SCHEDTABLE(
  var schedtable_to_store : univ actual_schedtable_data);

begin (* fetch_schedtable *)
  schedtable_to_store := schedtable
end (* fetch_schedtable *);



(*************************  mud_change_handler  *************************)
(*									*)
(*  Name:	clear_consistency_schedule				*)
(*									*)
(*  Called By:	command_level.primary_clear				*)
(*									*)
(*  Purpose:	prevent scheduled consistency execution			*)
(*									*)
(*  Method:	set both start & end times to 0				*)
(*									*)
(************************************************************************)

procedure entry CLEAR_CONSISTENCY_SCHEDULE(
  var io_status : univ file_utility_status);

begin (* clear_consistency_schedule *)
  schedtable.data.consistency_enabled := FALSE;
  schedtable.data.consistency_start := 0;
  schedtable.data.consistency_end := 0;
  mud_utility.write_schedtable_to_disc(schedtable, io_status)
end (* clear_consistency_schedule *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if force_password_change



(*************************  mud_change_handler  *************************)
(*									*)
(*  Name:	clear_passchanger_schedule				*)
(*									*)
(*  Called By:	command_level.primary_clear				*)
(*									*)
(*  Purpose:	make everyone safe from the passchanger reaper		*)
(*									*)
(*  Method:	set passchanger_enabled = FALSE, & start/end times to 0	*) 
(*									*)
(************************************************************************)

procedure entry CLEAR_PASSCHANGER_SCHEDULE(
  var io_status		: univ file_utility_status);

begin (* clear_passchanger_schedule *)
  schedtable.data.passchanger_enabled := FALSE;		 
  schedtable.data.passchanger_schedule := 0;
  schedtable.data.passchanger_next_time := 0;
  mud_utility.write_schedtable_to_disc(schedtable, io_status)
end (* clear_passchanger_schedule *);
$endif force_password_change
$if reuse_uuns



(********************** mud_change_handler  *****************************)
(*									*)
(*  Name:	clear_uunmerge 						*)
(*									*)
(*  Purpose:	disable execution of uunmerge process			*)
(*									*)
(************************************************************************)

procedure entry CLEAR_UUNMERGE_SCHEDULE(
  var io_status		: univ file_utility_status);

begin (* clear_uunmerge *)
  schedtable.data.uunmerge_enabled := FALSE;
  schedtable.data.uunmerge_schedule := 0;
  schedtable.data.uunmerge_next_time := 0;
  mud_utility.write_schedtable_to_disc(schedtable, io_status)
end (* clear_uunmerge *);



(*************************  mud_change_handler  *************************)
(*									*)
(*			   set_next_merge_time				*)
(*									*)
(*      Set next_merge_time.						*)
(*									*)
(************************************************************************)

procedure set_next_merge_time(
  var io_status	: univ file_utility_status);

var
  now_time : print_time;
  previous_time : integer;

begin
  calendar.date_from_ISIS_time(REALTIME, now_time);
				
(* clear time of day so it can be reset *)
  now_time.hour := 0; now_time.minute := 0;
  now_time.second := schedtable.data.uunmerge_schedule * 60; 

  previous_time := calendar.isis_time(now_time);

  if realtime > previous_time then
    now_time.second := now_time.second + SECONDS_PER_DAY;
  
  schedtable.data.uunmerge_next_time := calendar.isis_time(now_time);
  mud_utility.write_schedtable_to_disc(schedtable, io_status)
end (* set_next_merge_time *);
$endif reuse_uuns
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(*************************  mud_change_handler  *************************)
(*									*)
(*			   schedule_consistency				*)
(*									*)
(*      Update the consistency schedule parameters: 			*)
(*				consistency_start			*)
(*				consistency_end				*)
(*									*)
(************************************************************************)

procedure entry SCHEDULE_CONSISTENCY(
      new_start_time	: integer;
      new_stop_time	: integer;
  var io_status		: univ file_utility_status);

begin (* schedule_consistency *)
  schedtable.data.consistency_start := new_start_time;
  schedtable.data.consistency_end := new_stop_time;
  schedtable.data.consistency_enabled := true;
  mud_utility.write_schedtable_to_disc(schedtable, io_status)
end (* schedule_consistency *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if force_password_change



(*************************  mud_change_handler  *************************)
(*									*)
(*  Name:	set_next_passchanger_time				*)
(*									*)
(*  Called By:	schedule_passchanger					*)
(*									*)
(*  Purpose:	define first time Passchanger will run after its 	*)
(*		diily run time has been changed via schedule_passchanger*)
(*									*)
(*  Method:	same as set_next_merge_time				*)
(*									*)
(*  On Return:	Passchanger's next run time is in schedtable.next_pass-	*)
(*		changer_time						*)
(*									*)
(************************************************************************)

procedure set_next_passchanger_time(
  var io_status			: file_utility_status);

var
  now_time : print_time;
  previous_time : integer;

begin (* set_next_passchanger_time *)
  calendar.date_from_ISIS_time(REALTIME, now_time);

    (* clear time of day so it can be reset *)
    now_time.hour := 0; 
    now_time.minute := 0;
    now_time.second := schedtable.data.passchanger_schedule * 60;
	    (* now_time = time into day to schedule passchanger *)

  previous_time := calendar.isis_time(now_time);
  
  if REALTIME > previous_time
  then now_time.second := now_time.second + SECONDS_PER_DAY;
  
  schedtable.data.passchanger_next_time := calendar.isis_time(now_time);
  mud_utility.write_schedtable_to_disc(schedtable, io_status)
end (* set_next_passchanger_time *);



(*************************  mud_change_handler  *************************)
(*									*)
(*			   schedule_passchanger				*)
(*									*)
(*      Update schedule parameter: passchanger_next_time		*)
(*									*)
(************************************************************************)

procedure entry SCHEDULE_PASSCHANGER(
      new_start_time	: integer;
  var io_status		: file_utility_status);

begin (* schedule_passchanger *)
  schedtable.data.passchanger_schedule := new_start_time;
  schedtable.data.passchanger_enabled := TRUE;
  set_next_passchanger_time(io_status)
end (* schedule_passchanger *);
$endif force_password_change
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if reuse_uuns


(*************************  mud_change_handler  *************************)
(*									*)
(*			   schedule_uunmerge				*)
(*									*)
(*      Update schedule parameter: passchanger_next_time		*)
(*									*)
(************************************************************************)

procedure entry SCHEDULE_UUNMERGE(
      new_start_time	: integer;
  var io_status		: file_utility_status);

begin (* schedule_uunmerge *)
  schedtable.data.uunmerge_enabled := TRUE;
  schedtable.data.uunmerge_schedule := new_start_time;
  set_next_merge_time(io_status)
end (* schedule_passchanger *);
$endif reuse_uuns
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(*************************  mud_change_handler  *************************)
(*									*)
(*				initialize				*)
(*									*)
(*      Check the data in the last change in the MUD_UPDATE file	*)
(*	against the CUD data (and remove it if it is not valid) and	*)
(*	initialize permanent variables.					*)
(*									*)
(************************************************************************)

procedure initialize;

var
  real_sup		: real_supervisor_index;
  cud_pointer 		: cud_data_index;
  mudchg_pointer	: cud_data_index;
  change		: cud_change_information;
  file_address		: mudupd_address;
  cud_buffer		: cud_disk_block;
  result		: cud_operation_result;
  legal_sup_count	: ps_table_search_range;
  pseudo_sup		: pseudo_supervisor_index;
  match			: boolean;
  read_ok		: boolean;

begin
  last_time := REALTIME;
$if INCLUDE_DNIC
  mud_utility.read_dnic_header_from_disc(DNIC_HEADER_ADDRESS,
    dnic_header, read_ok);
  if not read_ok or (dnic_header.file_id <> DNIC_FILE_ID)
  then crash_util.halt_slot;
$endif INCLUDE_DNIC
  mud_utility.read_page(MUDUPD_HEADER_ADDRESS, header, read_ok);
  if not read_ok or (header.file_id <> MUDUPD_ID)
  then crash_util.halt_slot;
  if header.disk_eof > header.last_record
  then
    begin (* correct Mud_Update_file *)
(*      If data in the record pointed to by the last record pointer	*)
(*	does not match the actual CUD data, remove the record from	*)
(*	the MUD_UPDATE file.						*)

      mud_utility.compute_mudupd_address(header.last_record, file_address);
      mud_utility.extract_cud_change(file_address, read_ok, change);
      if not read_ok
      then crash_util.halt_slot;
      cud_block_reader.read_cud_block(change.header.block, result, cud_buffer);
      if result <> CUD_OPERATION_OK
      then crash_util.halt_slot;
      match := TRUE (* check to see if change is in CUD *);
(* if before 43, offset and size are words; *)
(* if after 43, offset and size are bytes *)
      cud_pointer := change.header.offset
$if BEFORE_SUP_V43      * MAXIMUM_BYTES_IN_WORD
;
      with change do
        for mudchg_pointer := 0 to
$if BEFORE_SUP_V43         (header.size * MAXIMUM_BYTES_IN_WORD)-1 do
$ifnot BEFORE_SUP_V43        header.size - 1 do
          begin
            if cud_buffer.data[cud_pointer] <> data[mudchg_pointer]
            then match := FALSE;
            cud_pointer := cud_pointer + 1
          end;
      if not match
      then
        begin (* remove last mud change file record *)
          header.disk_eof := header.last_record;
          write_header_to_disc
        end (* remove last mud change file record *)
    end (* correct mud_update_file *);

  read_eof_buffer;
  for real_sup := FIRST_SUPERVISOR to MAXIMUM_REAL_SUPERVISOR do
    init_sup_core_info(real_sup);
  cud_change_pending := FALSE;
  reset_getting_full;
  updater_eof := header.disk_eof;

(* initialize Pseudo_Sup_Table *)
  for pseudo_sup := FIRST_SUPERVISOR to MAXIMUM_EXPECTED_SUPERVISORS do
    pseudo_sup_table[pseudo_sup] := EMPTY_ENTRY;
  legal_sup_count := 0;
  pseudo_sup := FIRST_SUPERVISOR;
  for real_sup := FIRST_SUPERVISOR to MAXIMUM_REAL_SUPERVISOR do
    If legal_sup(real_sup)
    then
      begin (* MUF Header thinks Sup is legal *)
 	legal_sup_count := legal_sup_count + 1;
        if legal_sup_count > MAXIMUM_EXPECTED_SUPERVISORS
        then crash_util.halt_slot;
 	Pseudo_Sup_Table[pseudo_sup] := real_sup;
 	pseudo_sup := pseudo_sup + 1
      end (* MUF Header thinks Sup is legal *);

(*	Initialize Schedtable			*)
  mud_utility.read_schedtable_from_disc(schedtable, read_ok);

  if not read_ok or (schedtable.header <> schedtable_file_id)
  then crash_util.halt_slot;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if check_time_status
  set_oplog_reporter_time
$endif check_time_status
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
end (* initial statement *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if reuse_uuns
!
"
			merge routines
"


(*************************  mud_change_handler  *************************)
(*									*)
(*			     delay_uun_merger				*)
(*									*)
(*	Delay MERGE_UUNFILE process until time for UUN merge.		*)
(*									*)
(************************************************************************)

procedure entry DELAY_UUN_MERGER;

begin
  delay(uun_merger_queue)
end (* delay_uun_merger *);



(*************************  mud_change_handler  *************************)
(*									*)
(*			      merge_complete				*)
(*									*)
(*	This procedure sets the last_merge time in the header to   	*)
(*	the current time.					        *)
(*									*)
(************************************************************************)

procedure entry MERGE_COMPLETE;

var
  io_status	: file_utility_status;

begin
  header.last_merge := REALTIME;
  write_header_to_disc;
  set_next_merge_time(io_status)
end (* merge_complete *);
$endif reuse_uuns
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!

$if force_password_change
(*************************  mud_change_handler  *************************)
(*									*)
(*			   passchanger_complete				*)
(*									*)
(*	This procedure sets the last_passchanger time in the header to  *)
(*	the current time.					        *)
(*									*)
(************************************************************************)

procedure entry PASSCHANGER_COMPLETE;

var
  io_status	: file_utility_status;

begin
  header.last_passchanger := REALTIME;
  write_header_to_disc;
  set_next_passchanger_time(io_status)
end (* passchanger_complete *);
$endif force_password_change
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
"
		legal Supervisor routines

    The following calls to CHANGE_MASTER allow access
to the list of legal Supervisors stored in the MUD_UPDATE file
"



(*************************  mud_change_handler  *************************)
(*									*)
(*			     legal_supervisor				*)
(*									*)
(*      Return TRUE if Supervisor is in-use.				*)
(*									*)
(************************************************************************)

function entry LEGAL_SUPERVISOR(
      real_sup	: real_supervisor_index) : boolean;

begin
  legal_supervisor := legal_sup(real_sup)
end (* legal_supervisor *);



(*************************  mud_change_handler  *************************)
(*									*)
(*			 check_all_sups_caught_up			*)
(*									*)
(*      If all legal Supervisor pointers match disk_eof reset all	*)
(*	MUD_UPDATE data pointers.					*)
(*									*)
(************************************************************************)

procedure check_all_sups_caught_up;

var
  real_sup : real_supervisor_index;
  all_sups_caught_up : boolean;

begin
  if header.disk_eof <> 0
  then
    begin (* there is data in the file *)
      all_sups_caught_up := TRUE;
      for real_sup := FIRST_SUPERVISOR to MAXIMUM_REAL_SUPERVISOR do
        if legal_sup(real_sup) 
	   and (header.sup_disc_info[real_sup].pointer <> header.disk_eof)
	then all_sups_caught_up := FALSE;
      if all_sups_caught_up
      then
        begin (* clear all waiting changes *)
	  updater_eof := 0;
	  eof_buffer.address.page_offset := PAGES_IN_MUDUPD_HEADER;
	  eof_buffer.address.byte_offset := 0;
	  header.disk_eof := 0;
	  header.last_record := 0;
	  for real_sup := FIRST_SUPERVISOR to MAXIMUM_REAL_SUPERVISOR do
	    header.sup_disc_info[real_sup].pointer := 0;
	  reset_getting_full;
	  format.start_message('MUD updates caught up\');
	  oper_messages.report_message(MUDUPD_OPLOG_MSG)
	end (* clear all waiting changes *)
    end (* there is data in the file *)
end (* check_all_sups_caught_up *);



(*************************  mud_change_handler  *************************)
(*									*)
(*			  wait_for_stop_is_empty			*)
(*									*)
(************************************************************************)

function entry WAIT_FOR_STOP_IS_EMPTY(
      pseudo_sup	: pseudo_supervisor_index) : boolean;

begin (* wait_for_stop_is_empty *)
  wait_for_stop_is_empty := empty(wait_for_stop_que[pseudo_sup])
end (* wait_for_stop_is_empty *);



(*************************  mud_change_handler  *************************)
(*									*)
(*                         start_sup_shutdown				*)
(*									*)
(************************************************************************)

procedure start_sup_shutdown(
      real_sup       : real_supervisor_index;
      pseudo_sup     : pseudo_supervisor_index);

begin (* start_sup_shutdown *)
  set_sup_off(real_sup, header);
  sup_core_info[real_sup].run_init_auto_consistency := FALSE;
(* clear file eof's if all sups are now caught up *)
  check_all_sups_caught_up;
  aux_io.use_circuit(pseudo_sup, AUX_CIRCUIT, [COMPLETE]);
  aux_io.clear_circuit;
  sup_core_info[real_sup].current_un2_activity := NOT_BUSY
end (* start_sup_shutdown *);



(*************************  mud_change_handler  *************************)
(*									*)
(*			      set_supervisor				*)
(*									*)
(*      Turn the Supervisor REAL_SUP on or off.				*)
(*									*)
(************************************************************************)

procedure entry SET_SUPERVISOR(
      real_sup          : real_supervisor_index;
      make_legal	: boolean;
  var success      	: set_supervisor_status);

var
  pseudo_sup	  : pseudo_supervisor_index;
  found,
  write_ok,
  currently_legal : boolean;

begin (* mud_change.set_supervisor *)
  success := SET_SUP_SUCCESSFULL;
  write_ok := FALSE;
  currently_legal := header.sup_disc_info[real_sup].state <> SUPERVISOR_OFF;

  if not make_legal and not currently_legal
  then success := SET_SUP_ALREADY_OFF;

  if make_legal and currently_legal
  then success := SET_SUP_ALREADY_ON;

  if make_legal and not currently_legal
  then
    begin (* attempt to turn supervisor on *)
      search_ps_table(real_sup, pseudo_sup, found);
      if found
      then success := SET_SUP_ALREADY_IN_PSEUDO_SUP_TABLE
      else
	begin (* can turn sup on *)
          search_ps_table(EMPTY_ENTRY, pseudo_sup, found);
          if found
          then
            begin (* initialize Netval for supervisor wake-up *)
	      pseudo_sup_table[pseudo_sup] := real_sup;
              init_sup_disc_info(real_sup, header.sup_disc_info[real_sup]);
              init_sup_core_info(real_sup);
              if RUN_AUTO_CONSISTENCY_ON_SUP_INIT and
	                                   mutil.legal_consistency(real_sup)
              then
                begin (* set run_init_auto_consistency flag *)
	          sup_core_info[real_sup].run_init_auto_consistency := TRUE;
                  header.sup_disc_info[real_sup].pointer := updater_eof
                end (* set run_init_auto_consistency flag *)
            end (* initialize Netval for supervisor wake-up *)
          else success := SET_SUP_NO_ROOM_IN_PSEUDO_SUP_TABLE
	end (* can turn sup on *)
    end (* attempt to turn supervisor on *);

  if not make_legal and currently_legal
  then
    begin (* attempt to make Supervisor not legal *)
      search_ps_table(real_sup, pseudo_sup, found);
      if found
      then
        begin (* turn off Supervisor is in pseudo_sup_table *)
          If not empty(wait_for_stop_que[pseudo_sup])
          then success := SET_SUP_OFF_ALREADY_IN_PROGRESS
          else
            begin (* no other turn offs got here first; what's happening? *)
	      case sup_core_info[real_sup].current_un2_activity of
	        NOT_BUSY:	
		  start_sup_shutdown(real_sup, pseudo_sup);
		AUTO_CONSISTENCY:
                  begin (* shut down after auto consistency is stopped *)
                    sup_core_info[real_sup].to_be_stopped := TRUE;
                    delay(wait_for_stop_que[pseudo_sup]);
                    start_sup_shutdown(real_sup, pseudo_sup);
		    success := SET_SUP_AUTO_CONSISTENCY_HALTED
                  end  (* shut down after auto consistency is stopped *);
		MANUAL_CONSISTENCY:
                  success := SET_SUP_MANUAL_CONSISTENCY_IN_PROGRESS;
		MUD_UPDATING:
                  begin (* shut down after current update block is sent *)
                    delay(wait_for_stop_que[pseudo_sup]);
                    start_sup_shutdown(real_sup, pseudo_sup)
                  end (* shut down after current update block is sent *)
	      end (* case of current_un2_activity *)
            end (* no other turn offs got here first; what's happening? *)
        end (* turn off Supervisor is in pseudo_sup_table *)
      else crash_util.halt_slot
    end (* attempt to make Supervisor not legal *);

  if (success = SET_SUP_SUCCESSFULL)
     or (success = SET_SUP_AUTO_CONSISTENCY_HALTED)
  then
    begin (* disc writing and pseudo_sup_table updating *)
      write_header_to_disc;
      if make_legal
      then pseudo_sup_table[pseudo_sup] := real_sup
      else pseudo_sup_table[pseudo_sup] := EMPTY_ENTRY
    end (* disc writing and pseudo_sup_table updating *)
end (* set_supervisor *);
!
"
	Consistency Schedule Routines

    The following calls to CHANGE_MASTER allow access to the
consistency schedule
"

!
"
		Class group Routines

    The following routines are called by the SYSMSG1_UPDATER Process
and the SYSMSG1_HANDLER Monitor to update class and group tables and
if idis enabled to update DNIC tables.
"


(*************************  mud_change_handler  *************************)
(*									*)
(*			     set_table_date				*)
(*									*)
(*      Set the NETVAL Class/group Table updated date to the		*)
(*	present and all Supervisor last_class_group_status to		*)
(*	CLASS_GROUP_NOT_TRIED.						*)
(*									*)
(************************************************************************)

procedure entry SET_TABLE_DATE;

var
  real_sup : real_supervisor_index;

begin (* set_table_date *)
  header.last_cg_creation := REALTIME;
  write_header_to_disc;
  for real_sup := FIRST_SUPERVISOR to MAXIMUM_REAL_SUPERVISOR do
    sup_core_info[real_sup].last_cg_status := CLASS_GROUP_NOT_TRIED
end (* set_table_date *);



(*************************  mud_change_handler  *************************)
(*									*)
(*			  set_sup_table_status				*)
(*									*)
(*      Update the Supervisor Class/group update status and/or date.	*)
(*									*)
(************************************************************************)

procedure entry SET_SUP_TABLE_STATUS(
      real_sup          : real_supervisor_index;
      new_status	: class_group_status);

begin
  sup_core_info[real_sup].last_cg_status := new_status;
  if new_status = CLASS_GROUP_UPDATED
  then
    begin (* write new time *)
      header.sup_disc_info[real_sup].last_cg_update := REALTIME;
      write_header_to_disc
    end (* write new time *)
end (* set_sup_table_status *);



(*************************  mud_change_handler  *************************)
(*									*)
(*				table_date				*)
(*									*)
(*      Return the NETVAL Class/group Table updated date.		*)
(*									*)
(************************************************************************)

function entry TABLE_DATE : integer;

begin
  table_date := header.last_cg_creation
end (* table_date *);



(*************************  mud_change_handler  *************************)
(*									*)
(*			     sup_table_status				*)
(*									*)
(*      Return the Class/group Table status for the supervisor.		*)
(*									*)
(************************************************************************)

function entry SUP_TABLE_STATUS(
      real_sup	: real_supervisor_index) : class_group_status;

begin (* sup_table_status *)
  sup_table_status := sup_core_info[real_sup].last_cg_status
end (* sup_table_status *);



(*************************  mud_change_handler  *************************)
(*									*)
(*			     table_to_send				*)
(*									*)
(*      Return TRUE if the sup should be sent the Class/group Table.	*)
(*									*)
(************************************************************************)

function entry TABLE_TO_SEND(
      real_sup	: real_supervisor_index) : boolean;

begin
  table_to_send := legal_sup(real_sup) and
    (header.last_cg_creation > header.sup_disc_info[real_sup].last_cg_update)
end (* table_to_send *);
$if INCLUDE_DNIC
!
"
		DNIC table Routines

"


(*************************  mud_change_handler  *************************)
(*									*)
(*			     set_dnic_update				*)
(*									*)
(*      Set the NETVAL DNIC File updated date to the present.		*)
(*									*)
(************************************************************************)

procedure entry SET_DNIC_UPDATE;

begin (* set_dnic_update *)
  dnic_header.date_updated := REALTIME
end (* set_dnic_update *);


(*************************  mud_change_handler  *************************)
(*									*)
(*			     set_dnic_sent				*)
(*									*)
(*      Set the NETVAL DNIC Table last sent date to the present		*)
(*	and all Supervisor last_dnic_status to DNIC_UPDATE_NOT_TRIED.	*)
(*									*)
(************************************************************************)

procedure entry SET_DNIC_SENT;

var
  real_sup : real_supervisor_index;

begin (* set_dnic_sent *)
  dnic_header.was_sent := TRUE;
  write_dnic_header_to_disc;
  header.last_dnic_update := REALTIME;
  header.dnic_on_all_sups := FALSE;
  header.dnic_on_some_sups := FALSE;
  write_header_to_disc;
  for real_sup := FIRST_SUPERVISOR to MAXIMUM_REAL_SUPERVISOR do
    sup_core_info[real_sup].last_dnic_status := DNIC_UPDATE_NOT_TRIED
end (* set_dnic_sent *);



(*************************  mud_change_handler  *************************)
(*									*)
(*			  set_sup_dnic_status				*)
(*									*)
(*      Update the Supervisor DNIC table update status and/or date.	*)
(*									*)
(************************************************************************)

procedure entry SET_SUP_DNIC_STATUS(
      real_sup          : real_supervisor_index;
      new_status	: dnic_table_status);

var
  sup : real_supervisor_index;

begin
  sup_core_info[real_sup].last_dnic_status := new_status;
  if new_status = DNIC_UPDATED
  then
    begin (* set header flags *)
      dnic_header.sup_update[real_sup] := REALTIME;
      dnic_header.last_sent := REALTIME;
      write_dnic_header_to_disc;
      header.dnic_on_some_sups := TRUE;
      header.dnic_on_all_sups := TRUE;
      for sup := FIRST_SUPERVISOR to MAXIMUM_REAL_SUPERVISOR do
        if (sup_core_info[sup].last_dnic_status <> DNIC_UPDATED)
	  and legal_sup(sup)
	then header.dnic_on_all_sups := FALSE;
      if header.dnic_on_all_sups
      then dnic_header.was_sent := FALSE;
      write_header_to_disc
    end (* set header flags *)
end (* set_sup_dnic_status *);



(*************************  mud_change_handler  *************************)
(*									*)
(*			     sub_dnic_count				*)
(*									*)
(*      Return TRUE if DNIC can be deleted, decrement count.		*)
(*									*)
(************************************************************************)

function entry SUB_DNIC_COUNT : boolean;

begin (* sub_dnic_count *)
  if dnic_header.dnic_count > 0
  then
    begin
      sub_dnic_count := TRUE;
      dnic_header.dnic_count := dnic_header.dnic_count - 1;
      write_dnic_header_to_disc
    end
  else sub_dnic_count := FALSE
end (* sub_dnic_count *);


(*************************  mud_change_handler  *************************)
(*									*)
(*			     add_dnic_count				*)
(*									*)
(*      Return TRUE if DNIC can be added, increment count.		*)
(*									*)
(************************************************************************)

function entry ADD_DNIC_COUNT : boolean;

begin (* add_dnic_count *)
  if dnic_header.dnic_count < NON_DEFAULT_RECORD_COUNT
  then
    begin
      add_dnic_count := TRUE;
      if dnic_header.dnic_count < 0
      then dnic_header.dnic_count := 1
      else dnic_header.dnic_count := dnic_header.dnic_count + 1;
      write_dnic_header_to_disc
    end
  else add_dnic_count := FALSE
end (* add_dnic_count *);



(*************************  mud_change_handler  *************************)
(*									*)
(*			     get_dnic_count				*)
(*									*)
(*      Return current dnic count.					*)
(*									*)
(************************************************************************)

function entry GET_DNIC_COUNT : non_default_data_size;

begin (* get_dnic_count *)
  get_dnic_count := dnic_header.dnic_count
end (* get_dnic_count *);


(*************************  mud_change_handler  *************************)
(*									*)
(*				set_all_dnic_sent			*)
(*									*)
(*      Update header for DNIC sent to all sups.			*)
(*									*)
(************************************************************************)

function entry ALL_DNIC_SENT : boolean;

begin
  all_dnic_sent := header.dnic_on_all_sups
end (* set_all_dnic_sent *);


(*************************  mud_change_handler  *************************)
(*									*)
(*				dnic_update				*)
(*									*)
(*      Return the NETVAL DNIC File updated date.			*)
(*									*)
(************************************************************************)

function entry DNIC_UPDATE : integer;

begin
  dnic_update := dnic_header.date_updated
end (* dnic_update *);



(*************************  mud_change_handler  *************************)
(*									*)
(*				dnic_date				*)
(*									*)
(*      Return the NETVAL DNIC Table updated date.			*)
(*									*)
(************************************************************************)

function entry DNIC_DATE : integer;

begin
  dnic_date := header.last_dnic_update
end (* dnic_date *);


(*************************  mud_change_handler  *************************)
(*									*)
(*			     sup_dnic_status				*)
(*									*)
(*      Return the DNIC Table status for the supervisor.		*)
(*									*)
(************************************************************************)

function entry SUP_DNIC_STATUS(
      real_sup	: real_supervisor_index) : dnic_table_status;

begin (* sup_dnic_status *)
  sup_dnic_status := sup_core_info[real_sup].last_dnic_status
end (* sup_dnic_status *);



(*************************  mud_change_handler  *************************)
(*									*)
(*			     dnic_to_send				*)
(*									*)
(*      Return TRUE if the sup should be sent the DNIC Table.		*)
(*									*)
(************************************************************************)

function entry DNIC_TO_SEND(
      real_sup	: real_supervisor_index) : boolean;

begin
  dnic_to_send := (legal_sup(real_sup) and dnic_header.was_sent)
    and (dnic_header.sup_update[real_sup] < header.last_dnic_update)
end (* dnic_to_send *);
$endif INCLUDE_DNIC
!
"
		CUD_ENTRY_UPDATER Routines
"


(*************************  mud_change_handler  *************************)
(*									*)
(*			      save_two_bytes				*)
(*									*)
(*      Save the rightmost two bytes in value in eof_buffer, adjusting	*)
(*	the eof_buffer.address.						*)
(*									*)
(************************************************************************)

procedure save_two_bytes(
      value    : univ word_in_bytes;
  var write_ok : boolean);

begin
  mud_utility.put_mudupd_byte(value[2], eof_buffer.address, eof_buffer.data,
    write_ok);
  if write_ok
  then mud_utility.put_mudupd_byte(value[3], eof_buffer.address,
    eof_buffer.data, write_ok)
end (* save_two_bytes *);



(*************************  mud_change_handler  *************************)
(*									*)
(*			      save_word					*)
(*									*)
(*      Save the rightmost two bytes in value in eof_buffer, adjusting	*)
(*	the eof_buffer.address.						*)
(*									*)
(************************************************************************)

procedure save_word(
      value    : univ word_in_bytes;
  var write_ok : boolean);

begin
  mud_utility.put_mudupd_byte(value[0], eof_buffer.address, eof_buffer.data,
    write_ok);
  if write_ok
  then mud_utility.put_mudupd_byte(value[1], eof_buffer.address,
    eof_buffer.data, write_ok);
  if write_ok
  then mud_utility.put_mudupd_byte(value[2], eof_buffer.address,
    eof_buffer.data, write_ok);
  if write_ok
  then mud_utility.put_mudupd_byte(value[3], eof_buffer.address,
    eof_buffer.data, write_ok)
end (* save_word *);



(*************************  mud_change_handler  *************************)
(*									*)
(*			  cud_change_in_progress			*)
(*									*)
(*      Append the change to the MUD_UPDATE file and leave it		*)
(*	locked against other updates until the change is		*)
(*	confirmed or aborted.						*)
(*									*)
(************************************************************************)

procedure entry CUD_CHANGE_IN_PROGRESS(
      caller   : validator_index;
      change   : cud_change_information;
  var write_ok : boolean);

var
  count : cud_data_size;
  cud_pointer : cud_data_index;
$if BEFORE_SUP_V43   filler : integer;

begin
  if cud_change_pending
  then
    begin
      mud_change_waiting_list[next.arrival] := caller;
      delay(waiting_for_mud_change[caller])
    end (* cud_change_pending *);

(*	Write the CUD change to the MUD_UPDATE file.			*)
(* first save header information (block, offset, size and filler)	*)
  save_two_bytes(change.header.block, write_ok);
  if write_ok
  then save_two_bytes(change.header.offset, write_ok);
  if write_ok
  then save_two_bytes(change.header.size, write_ok);
$if BEFORE_SUP_V43   filler := 0;
  if write_ok
  then
$if BEFORE_SUP_V43   save_two_bytes(filler,
$ifnone BEFORE_SUP_V43   save_word(change.header.time,
    write_ok);
  if write_ok
  then
    begin (* save data to mud change file *)
      count := change.header.size
$if BEFORE_SUP_V43        * MAXIMUM_BYTES_IN_WORD (* before 43 size in words *)
;
      cud_pointer := 0;
      repeat
        mud_utility.put_mudupd_byte(change.data[cud_pointer],
  	  eof_buffer.address, eof_buffer.data, write_ok);
	count := count - 1;
	if count > 0
	then cud_pointer := cud_pointer + 1
      until not write_ok or (count = 0);
      if (eof_buffer.address.byte_offset <> 0) and write_ok
      then mud_utility.write_page(eof_buffer.address.page_offset,
        eof_buffer.data, write_ok)
    end (* save data to mud change file *);

  if write_ok
  then
    begin
      header.disk_eof := mud_utility.disk_byte_address(eof_buffer.address);
      header.last_record := updater_eof;
      write_header_to_disc
    end;

  if write_ok
  then cud_change_pending := TRUE
end (* cud_change_in_progress *);



(*************************  mud_change_handler  *************************)
(*									*)
(*			    confirm_cud_change				*)
(*									*)
(*      The CUD change was successful, allow MUD_UPDATER readers to	*)
(*	recognize it, unlock updates and continue any validators	*)
(*	waiting and check for MUD_UPDATE file getting full.		*)
(*									*)
(************************************************************************)

procedure entry CONFIRM_CUD_CHANGE;

begin
  updater_eof := header.disk_eof;
  cud_change_pending := FALSE;
  if header.disk_eof >= getting_full_mark (* see if file is getting full *)
  then
    begin
      format.start_message('MUD_UPDATE file is \');
      format.number((header.disk_eof * 100) div MUDUPD_DATA_MAX, 10);
      format.string(' percent full\');
      oper_messages.report_message(MUDUPD_OPLOG_MSG);
      reset_getting_full
    end;
  if not next.empty
  then
    continue(waiting_for_mud_change[mud_change_waiting_list[next.departure]])
end (* confirm_cud_change *);



(*************************  mud_change_handler  *************************)
(*									*)
(*			     abort_cud_change				*)
(*									*)
(*      The CUD change was NOT successful, discount the change,		*)
(*	unlock updates and continue a waiting validator.		*)
(*									*)
(************************************************************************)

procedure entry ABORT_CUD_CHANGE;

begin
  header.disk_eof := updater_eof;
  write_header_to_disc;
  read_eof_buffer;
  cud_change_pending := FALSE;
  if not next.empty
  then
    continue(waiting_for_mud_change[mud_change_waiting_list[next.departure]])
end (* abort_cud_change *);

!
"
	MUD_UPDATER Process Routines
"


(*************************  mud_change_handler  *************************)
(*									*)
(*			      update_waiting				*)
(*									*)
(*      Return TRUE if sup is a legal supervisor			*)
(*		       and it is not running an initial auto consistency*)
(*	               and there is a pending CUD change for the Sup	*)
(*									*)
(************************************************************************)

function update_waiting(
      real_sup	: real_supervisor_index) : boolean;

begin (* update waiting *)
  (* wait 10 seconds after end of consistency for UN2 *)
  with header.sup_disc_info[real_sup].history do
    while (REALTIME < stop_date + 10) do
      wait;

  update_waiting := legal_sup(real_sup) 
    	    	    and not sup_core_info[real_sup].run_init_auto_consistency 
    		    and (header.sup_disc_info[real_sup].pointer < updater_eof)
end (* update_waiting *);



(*************************  mud_change_handler  *************************)
(*									*)
(*			 in_current_consistency_period			*)
(*									*)
(*      Return TRUE if TIME_TO_CHECK is during the CURRENT		*)
(*	consistency period.  Called by WAITING_FOR_CONSISTENCY routine	*)
(*	only if the current time is during a consistency period.	*)
(*	This is required since just checking DURING_CONSISTENCY_PERIOD	*)
(*	does not reflect the possibility of 2 periods during one day	*)
(*	if the schedule runs across midnight.  There is an assumption	*)
(*	made that time_to_check will always be less than REALTIME.	*)
(*	      - to see if a consistency has been stopped during this	*)
(*		period							*)
(*	      - to see if a consistency has run during this period	*)
(*									*)
(************************************************************************)

function in_current_consistency_period(
      time_to_check		: integer) : boolean;

begin
  in_current_consistency_period :=
    (time_to_check >= current_consistency.start_time) and
    (time_to_check < current_consistency.stop_time)
end (* in_current_consistency_period *);



(*************************  mud_change_handler  *************************)
(*									*)
(*			      get_mud_change				*)
(*									*)
(*      Retrieve information about the next change to be made		*)
(*	to the Supervisor.						*)
(*									*)
(************************************************************************)

procedure entry GET_MUD_CHANGE(
      pseudo_sup	: pseudo_supervisor_index;
  var run_consistency	: boolean;
  var block		: cud_block_index;
  var change_pointer	: mudupd_address;
  var real_sup		: real_supervisor_index);

var
  need_to_delay : boolean;
  found		: boolean;

begin (* get_mud_change *)
  run_consistency:= FALSE;
  need_to_delay := FALSE;
  block := 0;
  xlate_ps_to_rs(pseudo_sup, real_sup, found);
  if found
  then
    if update_waiting(real_sup)
       and ((sup_core_info[real_sup].current_un2_activity = NOT_BUSY)
	    or (sup_core_info[real_sup].current_un2_activity = MUD_UPDATING))
    then mud_utility.compute_mudupd_address(
      			header.sup_disc_info[real_sup].pointer, change_pointer)
    else need_to_delay := TRUE
  else need_to_delay := TRUE;

  If need_to_delay
  then delay(mud_updater_delay_que[pseudo_sup]);

  xlate_ps_to_rs(pseudo_sup, real_sup, found);
  if found
  then
    begin (* delay ended for mud update or start auto consistency? *)
      if update_waiting(real_sup)
      then 
	begin (* send a mud update block to the Sup *)
	  sup_core_info[real_sup].current_un2_activity := MUD_UPDATING;
	  mud_utility.compute_mudupd_address(
                              header.sup_disc_info[real_sup].pointer, 
			      change_pointer)
	end (* send a mud update block to the Sup *)
      else
        begin (* start a consistency *)
	  run_consistency := TRUE;
          with header.sup_disc_info[real_sup].history do
            if consistency_restartable 
	       and (in_current_consistency_period(stop_date)
	            or sup_core_info[real_sup].run_init_auto_consistency)
            then block := consistency.block
        end (* start a consistency *)
    end (* delay ended for mud update or start auto consistency? *)
  else crash_util.halt_slot
end (* get_mud_change *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if force_password_change


(************************** mud_change **********************************)
(*									*)
(*  Name:	delay_passchanger					*)
(*									*)
(*  Purpose:	unconditionally delay passhcanger.  Check_time will	*)
(*		continue passchanger at an appropriate time.		*)
(*									*)
(************************************************************************)

procedure entry DELAY_PASSCHANGER;

begin (* delay_passchanger *)
  delay(passchanger_delay_que)
end (* delay_passchanger *);
$endif force_password_change
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)


(*************************  mud_change_handler  *************************)
(*									*)
(*			    mud_update_complete				*)
(*									*)
(*      Update the MUD pointer for the Supervisor to new_pointer,	*)
(*	and if all Supervisors are up-to-date, reset disk_eof.		*)
(*									*)
(************************************************************************)

procedure entry MUD_UPDATE_COMPLETE(
      real_sup		: real_supervisor_index;
      new_pointer	: mudupd_address);

var
  pseudo_sup : pseudo_supervisor_index;
  found : boolean;

begin (* mud_update_complete *)
  header.sup_disc_info[real_sup].pointer :=
    mud_utility.disk_byte_address(new_pointer);
  header.sup_disc_info[real_sup].last_mud_update := REALTIME;
  check_all_sups_caught_up;
  write_header_to_disc
end (* mud_update_complete *);



(*************************  mud_change_handler  *************************)
(*									*)
(*			    any_mud_updates				*)
(*									*)
(*      Return TRUE if there are any outstanding MUD updates for	*)
(*	this supervisor.						*)
(*									*)
(************************************************************************)

function entry ANY_MUD_UPDATES(
      real_sup	: real_supervisor_index) : boolean;

begin
  any_mud_updates := header.sup_disc_info[real_sup].pointer < updater_eof
end (* any_mud_updaters *);
!
"
		Consistency Routines
"


(*************************  mud_change_handler  *************************)
(*									*)
(*			 set_un2_activity_not_busy			*)
(*									*)
(*									*)
(************************************************************************)

procedure entry SET_UN2_ACTIVITY_NOT_BUSY(
      real_sup	: real_supervisor_index);

begin (* set_un2_activity_not_busy *)
  sup_core_info[real_sup].current_un2_activity := NOT_BUSY
end (* set_un2_activity_not_busy *);


(*************************  mud_change_handler  *************************)
(*									*)
(*			 record_consistency_started			*)
(*									*)
(*      Record start of transmission of consistency blocks.		*)
(*	This record is kept in core until the consistency completes,	*)
(*	at which time it is written to disc.				*)
(*	This is only called after a UN2 Circuit has been established.	*)
(*									*)
(************************************************************************)

procedure entry RECORD_CONSISTENCY_STARTED(
      real_sup		: real_supervisor_index;
      block		: cud_block_index;
      run_manual	: boolean;
      nochange      	: boolean);

begin (* record_consistency_started *);
  sup_core_info[real_sup].consistency.start_date := REALTIME;
  sup_core_info[real_sup].consistency.block := block;
  sup_core_info[real_sup].consistency.stopped := FALSE;
  sup_core_info[real_sup].consistency.manual := run_manual;
  sup_core_info[real_sup].nochange := nochange;
  if run_manual
  then sup_core_info[real_sup].current_un2_activity := MANUAL_CONSISTENCY
  else sup_core_info[real_sup].current_un2_activity := AUTO_CONSISTENCY
end (* record_consistency_started *);



(*************************  mud_change_handler  *************************)
(*									*)
(*			 report_consistency_block			*)
(*									*)
(*      Report that next_block has been processed.			*)
(*									*)
(************************************************************************)

procedure entry REPORT_CONSISTENCY_BLOCK(
      real_sup		: real_supervisor_index;
      next_block	: cud_block_index);

begin
  sup_core_info[real_sup].consistency.block := next_block
end (* report_consistency_block *);



(*************************  mud_change_handler  *************************)
(*									*)
(*			  check_consistency_stop			*)
(*									*)
(*      Return TRUE if consistency should be stopped (from the STOP	*)
(*	command OR time running out during the consistency period).	*)
(*									*)
(************************************************************************)

function entry CHECK_CONSISTENCY_STOP(
      real_sup	: real_supervisor_index) : boolean;

begin
  check_consistency_stop := sup_core_info[real_sup].to_be_stopped
end (* check_consistency_stop *);



(*************************  mud_change_handler  *************************)
(*									*)
(*			  report_consistency_over			*)
(*									*)
(*      Report that the consistency run is over; stopped is TRUE if the	*)
(*	consistency was stopped by force; if nochange is TRUE, do not	*)
(*	update any header information.	 				*)
(*									*)
(************************************************************************)

procedure entry REPORT_CONSISTENCY_OVER(
      real_sup	: real_supervisor_index;
      stopped	: boolean);

var
  pseudo_sup : pseudo_supervisor_index;
  found      : boolean;

begin (* report_consistency_over *)
  sup_core_info[real_sup].consistency.stopped := STOPPED;
  sup_core_info[real_sup].to_be_stopped := FALSE;
  sup_core_info[real_sup].current_un2_activity := NOT_BUSY;
  if not sup_core_info[real_sup].nochange
  then
    with header.sup_disc_info[real_sup].history do
      begin (* update disc header for sup *)
        consistency := sup_core_info[real_sup].consistency;
	stop_date := REALTIME;
	write_header_to_disc
      end (* update disc header for sup *);
  
  with sup_core_info[real_sup] do
    if run_init_auto_consistency
    then
      if not consistency.stopped 
	 and (consistency.block = CUD_BLOCK_LIMIT)
      then run_init_auto_consistency := FALSE;
  clear_current_consistency_sup_core_info(real_sup);
  search_ps_table(real_sup, pseudo_sup, found);
  if found
  then continue(wait_for_stop_que[pseudo_sup])
  else crash_util.halt_slot
end (* report_consistency_over *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if check_time_status
!
"
		OPLOG_REPORTER routine
"



(*************************  mud_change_handler  *************************)
(*									*)
(*			     delay_oplog_rptr				*)
(*									*)
(************************************************************************)

procedure entry DELAY_OPLOG_RPTR;

begin
  delay(oplog_reporter_queue);

  set_oplog_reporter_time
end (* delay_oplog_rptr *);
$endif check_time_status
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
"
		TICK Process Routines

    The following contains the routines called by the TICK Process (and
the internal routines used by it) which performs all the
continuing of updaters in queues.
"


(*************************  mud_change_handler  *************************)
(*									*)
(*			  find_mud_update_waiter			*)
(*									*)
(*      Find a supervisor delayed in a waiter queue that has		*)
(*	outstanding mud updates to perform and does not have a manual	*)
(*	consistency running (since only delayed supervisor updaters	*)
(*	are checked, an automatic consistency could not be running).	*)
(*									*)
(************************************************************************)

procedure find_mud_update_waiter(
  var pseudo_sup	: pseudo_supervisor_index;
  var found		: boolean);

var
  done : boolean;
  real_sup : real_supervisor_index;

begin (* find_mud_update_waiter *)
  pseudo_sup := FIRST_SUPERVISOR; 
  found := FALSE; 
  done := FALSE;
  
  repeat
    real_sup := Pseudo_Sup_Table[pseudo_sup];
    if real_sup <> EMPTY_ENTRY
    then (* mud update waiting for a delayed Sup not doing consistency? *)
      if not empty(mud_updater_delay_que[pseudo_sup])
         and update_waiting(real_sup)
	 and (sup_core_info[real_sup].current_un2_activity <> 
							MANUAL_CONSISTENCY)
      then
        begin (* found one with an update *)
	  found := TRUE;
	  done := TRUE
	end (* found one with an update *);
    if not done
    then
      if pseudo_sup = MAXIMUM_EXPECTED_SUPERVISORS
      then done := TRUE
      else pseudo_sup := pseudo_sup + 1
  until done
end (* find_mud_update_waiter *);



(*************************  mud_change_handler  *************************)
(*									*)
(*			 waiting_for_consistency			*)
(*									*)
(*      Return TRUE if Supervisor updater could run a consistency,	*)
(*	i.e., consistency has not completed today and consistency has	*)
(*	not been stopped today.						*)
(*									*)
(************************************************************************)

function waiting_for_consistency(
      real_sup	: real_supervisor_index) : boolean;

begin
    with header.sup_disc_info[real_sup].history do
    waiting_for_consistency :=
(* consistency has not run to completion during this period: *)
      ((consistency.block <> CUD_BLOCK_LIMIT) 
       or not in_current_consistency_period(stop_date))
      and
(* consistency has neither been started nor stopped during this period: *)
       (not in_current_consistency_period(consistency.start_date)
        or not consistency.stopped)
end (* waiting_for_consistency *);



(*************************  mud_change_handler  *************************)
(*									*)
(*			 find_consistency_to_run			*)
(*									*)
(*      Find a Supervisor delayed in a waiter queue to run a		*)
(*	consistency, i.e., a mud_updater that is delayed and has not	*)
(*	completed a consistency during today's consistency period OR	*)
(*	a mud_updater that is delayed and run_init_auto_consistency 	*)
(*	is TRUE.							*)
(*									*)
(************************************************************************)

procedure find_consistency_to_run(
  var pseudo_sup		: pseudo_supervisor_index;
  var found			: boolean);

var
  done : boolean;
  real_sup : real_supervisor_index;

begin (* find_consistency_to_run *)
  pseudo_sup := FIRST_SUPERVISOR; 
  found := FALSE; 
  done := FALSE;
  repeat
    real_sup := Pseudo_Sup_Table[pseudo_sup];
    if real_sup <> EMPTY_ENTRY
    then (* is it consistency time for the Supervisor? *)
      if legal_sup(real_sup) 
	 and mutil.legal_consistency(real_sup)
         and not empty(mud_updater_delay_que[pseudo_sup])
      then
        if (sup_core_info[real_sup].run_init_auto_consistency 
	   or (current_consistency.during_period
	       and waiting_for_consistency(real_sup))) 
	   and (sup_core_info[real_sup].current_un2_activity <> 
							MANUAL_CONSISTENCY)
	then
	  begin (* found one to start consistency on *)
	    found := TRUE;
	    done := TRUE
	  end (* found one to start consistency on *);
	
     if not done
     then
       if pseudo_sup = MAXIMUM_EXPECTED_SUPERVISORS
       then done := TRUE
       else pseudo_sup := pseudo_sup + 1
  until done
end (* find_consistency_to_run *);



(*************************  mud_change_handler  *************************)
(*									*)
(*			  set_up_for_consistency			*)
(*									*)
(*	compute current_consistency.during_period			*)
(*									*)
(************************************************************************)

procedure set_up_for_consistency;

var
  now_print_time : print_time;
  temp_print_time : print_time;
  previous_midnight : integer;

begin
  current_consistency.this_time := REALTIME;

  calendar.date_from_isis_time(current_consistency.this_time, now_print_time);
  temp_print_time := now_print_time;
  temp_print_time.hour := 0;
  temp_print_time.minute := 0;
  temp_print_time.second := 0;
  previous_midnight := calendar.isis_time(temp_print_time);

  current_consistency.start_time := previous_midnight +
    (schedtable.data.consistency_start * 60);
  current_consistency.stop_time := previous_midnight +
    (schedtable.data.consistency_end * 60);

  if schedtable.data.consistency_start > schedtable.data.consistency_end 
						(* across midnight *)
  then
    if (now_print_time.minute + (now_print_time.hour * 60)) <
      schedtable.data.consistency_end
    then current_consistency.start_time :=
      current_consistency.start_time - SECONDS_PER_DAY
    else current_consistency.stop_time :=
      current_consistency.stop_time + SECONDS_PER_DAY;

  current_consistency.during_period :=
    in_current_consistency_period(current_consistency.this_time)
end (* set_up_for_consistency *);



(*************************  mud_change_handler  *************************)
(*									*)
(*				check_time				*)
(*									*)
(*   1. Check to see if Netval's time has changed more than the defined	*)
(*	ACCEPTABLE_TIME_DIFFERENCE, and crash if it has (otherwise,	*)
(*	scheduling goes haywire).					*)
(*   2. If there is a MUD_UPDATER Process delayed that has a MUD	*)
(*	change waiting to be sent, and there is not a consistency	*)
(*	running, continue that process.					*)
(*   3. If no process was found in step 2, then if it is not during the	*)
(*	scheduled consistency period, stop any running automatic	*)
(*	consistencies.							*)
(*   4. If any automatic consistencies can run, start one.		*)
(*   5. If Tymshare, continue operlog_reporter if time.			*)
(*   6. If reuse_uuns is enabled, and it is time to start a		*)
(*	UUN ADD_BACK merge, continue uun_merger_queue.			*)
(*									*)
(************************************************************************)

procedure entry CHECK_TIME;

var
  real_sup : real_supervisor_index;
  pseudo_sup : pseudo_supervisor_index;
  found : boolean;
  this_time : integer;

begin
  this_time := REALTIME;
  if ((last_time - this_time) > ACCEPTABLE_TIME_DIFFERENCE)
     or ((this_time - last_time) > ACCEPTABLE_TIME_DIFFERENCE)
  then crash_util.halt_slot
  else last_time := this_time;

  find_mud_update_waiter(pseudo_sup, found);
  
  if not found
  then
    begin (* stop consistencies and/or find one to start *)
      set_up_for_consistency; 
      if not current_consistency.during_period
      then (* stop scheduled automatic consistencies *)
        for real_sup := FIRST_SUPERVISOR to MAXIMUM_REAL_SUPERVISOR do
          with sup_core_info[real_sup] do
	    if (current_un2_activity = AUTO_CONSISTENCY) 
	       and not run_init_auto_consistency
	    then to_be_stopped := TRUE;

      find_consistency_to_run(pseudo_sup, found)      
    end (* stop consistencies and/or find one to start *);
   
  if found
  then continue(mud_updater_delay_que[pseudo_sup])

(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if reuse_uuns
  else
    if schedtable.data.uunmerge_enabled and 
	(this_time > schedtable.data.uunmerge_next_time)
    then continue(uun_merger_queue)
$endif reuse_uuns
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if check_time_status
    else
      if REALTIME > schedtable.data.continue_oplog_reporter_time
      then continue(oplog_reporter_queue)
$endif check_time_status
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if force_password_change
      else
	if schedtable.data.passchanger_enabled and
	  (this_time > schedtable.data.passchanger_next_time)
	then continue(passchanger_delay_que)
$endif force_password_change
end (* check_time *);
!
"
		Validator Command Routines

    The following routines are called by various validator routines
"



(*************************  mud_change_handler  *************************)
(*									*)
(*			    get_sup_update_info				*)
(*									*)
(*      Return info for the Supervisor.					*)
(*									*)
(************************************************************************)

procedure entry GET_SUP_UPDATE_INFO(
      real_sup		: real_supervisor_index;
  var in_core_info	: supervisor_in_core_information);

begin (* get_sup_update_info *)
  in_core_info := sup_core_info[real_sup]
end (* get_sup_update_info *);



(*************************  mud_change_handler  *************************)
(*									*)
(*			     get_header					*)
(*									*)
(*      Return MUD_UPDATE_FILE header.					*)
(*									*)
(************************************************************************)

procedure entry GET_HEADER_INFO(
  var header_info	: mudupd_disk_header);

begin
  header_info := header
end (* get_header_info *);
$if INCLUDE_DNIC



(*************************  mud_change_handler  *************************)
(*									*)
(*			     get_dnic_header_info			*)
(*									*)
(*      Return DNIC_DATA_FILE header.					*)
(*									*)
(************************************************************************)

procedure entry GET_DNIC_HEADER_INFO(
  var header_info	: dnic_table_header);

begin
  header_info := dnic_header
end (* get_dnic_header_info *);
$endif INCLUDE_DNIC



(*************************  mud_change_handler  *************************)
(*									*)
(*			      mud_change_eof				*)
(*									*)
(*      Return the EOF pointer from MUD_UPDATE file.			*)
(*									*)
(************************************************************************)

function entry MUD_CHANGE_EOF : mudupd_data_index;

begin
  mud_change_eof := header.disk_eof
end (* mud_change_eof *);



(*************************  mud_change_handler  *************************)
(*									*)
(*			     set_to_be_stopped_true			*)
(*									*)
(*      Set the flag to say consistency should be stopped.		*)
(*									*)
(************************************************************************)

procedure entry SET_TO_BE_STOPPED_TRUE(
      real_sup	: real_supervisor_index);

begin
  sup_core_info[real_sup].to_be_stopped := TRUE
end (* set_to_be_stopped_true *);
$ifnone BEFORE_SUP_V43



(*************************  mud_change_handler  *************************)
(*									*)
(*				turn_sup_off				*)
(*									*)
(************************************************************************) 

procedure entry TURN_SUP_OFF(
      real_sup  	: real_supervisor_index;
  var header_info  	: mudupd_disk_header);

begin
  set_sup_off(real_sup, header_info)
end;
$endif BEFORE_SUP_V43
!
"
		Archive Routines

    The MUD_UPDATE file header ONLY is written to tape during a STORE,
and the end-of-file pointer is cleared; when the MUD_UPDATE file is
restored from tape to disk, the end-of-file pointer is also cleared.
"



(*************************  mud_change_handler  *************************)
(*									*)
(*			    read_mudupd_header				*)
(*									*)
(*      Return the header for the MUD_UPDATE file with the		*)
(*	end-of-file pointer cleared and all Supervisors set to OFF.	*)
(*	This forces the validator to turn Supervisors ON after a	*)
(*	RESTORE.							*)
(*									*)
(************************************************************************)

procedure entry READ_MUDUPD_HEADER(
  var header_info : univ mudupd_disk_header);

begin
  header_info := header;
  clear_mudupd_header(header_info)
end (* read_mudupd_header *);



(************************************************************************)
(************************************************************************)

begin (* initial statement *)
  init mutil, crash_util, next(0, VALIDATOR_LIMIT), calendar, format,
    oper_messages(oplog, format),
    mud_file(MUD_UPDATE_FILE, statistics, file_system, oper_messages,
      format),
    sched_file(SCHEDTABLE_FILE, statistics, file_system, oper_messages,
	format),
$if INCLUDE_DNIC
    dnic_file_util(DNIC_FILE, statistics, file_system, oper_messages,
	format),
$endif INCLUDE_DNIC
    mud_utility(mutil, format, oper_messages, mud_file,
$if INCLUDE_DNIC        dnic_file_util,
    sched_file),
    aux_io(mutil),
    dsksys(statistics),
    cud_block_reader(mutil, oper_messages, format, dsksys);
  initialize
end (* initialize *);
$endif disk_maintenance_code
$if disk_maintenance_code
!



(************************  mud_change_handler  **************************)
(*									*)
(*			  clear_muf_header_info	 			*)
(*									*)
(************************************************************************)

procedure clear_muf_header_info(
  var header	: mudupd_disk_header);

begin
  header.file_id := MUDUPD_ID;
  header.disk_eof := 0;
  header.last_cg_creation := 0;
$if INCLUDE_DNIC
  header.last_dnic_update := 0;
  header.dnic_on_all_sups := FALSE;
  header.dnic_on_some_sups := FALSE;
$endif INCLUDE_DNIC
  header.last_passchanger := 0;
  header.last_record := 0;
  header.last_merge := 0
end (* clear_muf_header_info *);



(************************  mud_change_handler  **************************)
(*									*)
(*			    do_write_header	 			*)
(*									*)
(************************************************************************)

procedure do_write_header(
  var header		: mudupd_disk_header;
  var ok		: boolean);

begin
  dsksys.page_request(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if logical_volumes      lv_dir.files_unit,
$ifnone logical_volumes     FILE_SYSTEM_DISK,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    DISK_WRITE, MUD_UPDATE_FILE_START, header, ok);
  if not ok
  then format.report_file_error(MUD_UPDATE_FILE, WRITING_MESSAGE,
    MUD_UPDATE_FILE_START, user_terminal)
end (* do_write_header *);



(************************  mud_change_handler  **************************)
(*									*)
(*			     make_new_file	 			*)
(*									*)
(************************************************************************)

procedure make_new_file(
  var ok	:  boolean);

var
  header : mudupd_disk_header;
  real_sup : real_supervisor_index;

begin
  clear_muf_header_info(header);
  for real_sup := FIRST_SUPERVISOR to MAXIMUM_REAL_SUPERVISOR do
    begin
      init_sup_disc_info(real_sup, header.sup_disc_info[real_sup]);
      header.sup_disc_info[real_sup].state := SUPERVISOR_OFF
    end (* for *);
  do_write_header(header, ok)
end (* make_new_file *);



(*************************  mud_change_handler  *************************)
(*									*)
(*			     make_new_mudupd				*)
(*									*)
(*									*)
(************************************************************************)

procedure entry MAKE_NEW_MUDUPD(
  var ok	: boolean);

begin
  make_new_file(ok)
end (* make_new_mudupd *);



(************************  mud_change_handler  **************************)
(*									*)
(*			       do_new_file	 			*)
(*									*)
(*	Initialize the MUDUPDATE file.					*)
(*									*)
(************************************************************************)

procedure do_new_file;

var
  ok : boolean;

begin
  make_new_file(ok);
  if ok
  then user_terminal.write_line_and_quoted_text_line('MUDUPDATE initialized\')
end (* do_new_file *);



(************************  mud_change_handler  **************************)
(*									*)
(*			       new_file		 			*)
(*									*)
(*	Initialize the MUDUPDATE file.					*)
(*									*)
(************************************************************************)

procedure entry NEW_FILE;

begin
  do_new_file
end (* new_file *);
$if INCLUDE_DNIC



(************************  mud_change_handler  **************************)
(*									*)
(*			  new_dnic_header	 			*)
(*									*)
(************************************************************************)

procedure entry NEW_DNIC_HEADER;

var
  real_sup : real_supervisor_index;
  header : dnic_table_header;
  ok : boolean;

begin
  header.file_id := DNIC_FILE_ID;
  header.dnic_count := 0;
  header.was_sent := FALSE;
  header.date_updated := 0;
  header.last_sent := 0;
  for real_sup := FIRST_SUPERVISOR to MAXIMUM_REAL_SUPERVISOR do
    header.sup_update[real_sup] := 0;
  dsksys.page_request(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if logical_volumes      lv_dir.files_unit,
$ifnone logical_volumes     FILE_SYSTEM_DISK,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    DISK_WRITE, DNIC_FILE_HEADER_START, header, ok);
  if not ok
  then format.report_file_error(DNIC_FILE, WRITING_MESSAGE,
    DNIC_FILE_HEADER_START, user_terminal)
  else user_terminal.write_quoted_text_line(
    '(:13:)(:10:)DNIC header initialized\')
end (* new_dnic_header *);
$endif INCLUDE_DNIC



(************************  mud_change_handler  **************************)
(*									*)
(*			     make_new_schedtable_file 			*)
(*									*)
(************************************************************************)

procedure make_new_schedtable_file(
  var ok :  boolean);

var
  i : integer;

begin (* make_new_schedtable_file *)
  schedtable.header := SCHEDTABLE_FILE_ID;
  schedtable.data.consistency_enabled := FALSE;
  schedtable.data.passchanger_enabled := FALSE;
  schedtable.data.uunmerge_enabled := FALSE;
  schedtable.data.continue_oplog_reporter_time := 0;
  schedtable.data.password_change_time_in_seconds := 0;
  schedtable.data.standard_password_validity_period := 0;
  write_schedtable_file(schedtable, ok)
end (* make_new_schedtable_file *);



(*************************  mud_change_handler  *************************)
(*									*)
(*			      do_new_schedtable_file 			*)
(*									*)
(*	Initialize the SCHEDTABLE file.					*)
(*									*)
(************************************************************************)

procedure do_new_schedtable_file;

var
  ok : boolean;

begin
  make_new_schedtable_file(ok);
  if ok
  then user_terminal.write_line_and_quoted_text_line(
    'SCHEDTABLE initialized\ ')
end (* do_new_schedtable_file *);



(*************************  mud_change_handler  *************************)
(*									*)
(*			       new_schedtable_file 			*)
(*									*)
(*	Initialize the SCHEDTABLE file.					*)
(*									*)
(************************************************************************)

procedure entry NEW_SCHEDTABLE_FILE;

begin
  do_new_schedtable_file
end (* new_schedtable_file *);



(************************  mud_change_handler  **************************)
(*									*)
(*			     supervisor_legal	 			*)
(*									*)
(************************************************************************)

function supervisor_legal(
     test	: univ integer) : boolean;

begin
  supervisor_legal := test <> 0
end (* supervisor_legal *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if convert_0_to_1



(*************************  mud_change_handler  *************************)
(*									*)
(*			    convert_file	 			*)
(*									*)
(*	Convert file to the current incarnation.			*)
(*									*)
(************************************************************************)

procedure entry CONVERT_FILE;

var
  header : mudupd_disk_header;
  real_sup : real_supervisor_index;
  ok : boolean;

begin
  dsksys.page_request(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if logical_volumes      lv_dir.files_unit,
$ifnone logical_volumes     FILE_SYSTEM_DISK,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    DISK_READ, INCARNATION_0_MUD_UPDATE_FILE_START, header, ok);
  if ok
  then
    if header.file_id = MUDUPD_ID
    then
      begin
        clear_muf_header_info(header);
	for real_sup := FIRST_SUPERVISOR to MAXIMUM_REAL_SUPERVISOR do
	  if supervisor_legal(header.sup_disc_info[real_sup].state)
	  then init_sup_disc_info(real_sup, header.sup_disc_info[real_sup]);
        do_write_header(header, ok);
        if ok
        then user_terminal.write_line_and_quoted_text_line(
	  'MUDUPDATE updated\')
      end
    else
      begin
        user_terminal.write_quoted_text_line('bad mud_update file\');
	do_new_file;
      end
  else
    begin
      format.report_file_error(MUD_UPDATE_FILE, READING_MESSAGE,
        MUD_UPDATE_FILE_START, user_terminal);
      do_new_file
    end
end (* convert_file *);
$endif convert_0_to_1
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)


(*************************  mud_change_handler  *************************)
(*									*)
(*			      check_file				*)
(*									*)
(************************************************************************)

procedure entry CHECK_FILE(
  var all_match		: boolean);

var
  read_ok : boolean;
  header  : mudupd_disk_header;

begin
  dsksys.page_request(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if logical_volumes      lv_dir.files_unit,
$ifnone logical_volumes     FILE_SYSTEM_DISK,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    DISK_READ, MUD_UPDATE_FILE_START, header, read_ok);
  if not read_ok
  then user_terminal.write_quoted_text_line('Error reading MUD update file\')
  else
    if header.file_id <> MUDUPD_ID
    then
      begin
        all_match := FALSE;
	user_terminal.write_quoted_text_line('Error on MUD update file ID\')
      end
end (* check_file *);



(*************************  mud_change_handler  *************************)
(*									*)
(*			      write_header				*)
(*									*)
(*      Write the header for the MUD_UPDATE file with the		*)
(*	end-of-file pointer cleared (used by ARCHIVE restore command.)	*)
(*									*)
(************************************************************************)

procedure entry WRITE_HEADER(
      header_info	: univ mudupd_disk_header;
  var write_ok		: boolean);

var
  header : mudupd_disk_header;

begin
  header := header_info;
  clear_mudupd_header(header) (* in case of a restore from version 1 *);
  dsksys.page_request(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if logical_volumes      lv_dir.files_unit,
$ifnone logical_volumes     FILE_SYSTEM_DISK,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    DISK_WRITE, MUD_UPDATE_FILE_START, header, write_ok)
end (* write_header *);



(************************************************************************)
(************************************************************************)

begin	(* initial statement *)
  init calendar
$if change_by_whom
(**  updated by SHSUE at 20-May-87 16:05:42			**)
(**  added init, changed mudupd_utility to mud_utility		**)
(**  commented out by SHSUE at 10-Jun-87 17:03:19		**)
(**  init mud_utility pass arg: mutil, format, oper_message, file_util	**)
$endif
end (* mud_change_handler *);
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
(************************************************************************)
(*									*)
(*	tick.ntv							*)
(*									*)
(*				mud_change_tick				*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*		Original -- jrn						*)
(*									*)
(************************************************************************)

type MUD_CHANGE_TICK = process(
      mud_change	: mud_change_handler);



begin (* initial statement *)
  cycle
    mud_change.check_time;
    wait
  end (* cycle *)
end (* mud_change_tick *);
!
(************************************************************************)
(*									*)
(*	UN2ACC.NTV							*)
(*									*)
(*			    un2_access_controller			*)
(*									*)
(*	The un2_access_controller Monitor is used to gain access	*)
(*	to a circuit to the Supervisor UN2 slave.			*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	18Aug86 - jrn							*)
(*	      - modify and simplify the UN2 access scheme		*)
(*	03Jan86	- rsb							*)
(*	      - change un2_access_manager array declaration to		*)
(*		use "real_supervisor_index"				*)
(*	19Jun85 - jrn							*)
(*		- add circuit_busy function				*)
(*		Original -- jrn						*)
(*									*)
(************************************************************************)



type UN2_ACCESS_CONTROLLER = monitor;


var
  un2_circuit_available : boolean (* the current circuit access *);



(************************  un2_access_controller  ***********************)
(*									*)
(*			      access_circuit				*)
(*									*)
(*	Access the UN2 circuit.						*)
(*									*)
(************************************************************************)

function entry ACCESS_CIRCUIT : boolean;

begin (* access_circuit *)
  if un2_circuit_available
  then
    begin
      access_circuit := TRUE;
      un2_circuit_available := FALSE
    end
  else access_circuit := FALSE
end (* access_circuit *);



(***********************  un2_access_controller  ************************)
(*									*)
(*			     release_circuit				*)
(*									*)
(*      Release the circuit.						*)
(*									*)
(************************************************************************)

procedure entry RELEASE_CIRCUIT;

begin (* release_circuit *)
  un2_circuit_available := TRUE
end (* release_circuit *);



(************************************************************************)
(************************************************************************)

begin (* initial statement *)
  un2_circuit_available := TRUE
end (* un2_access_controller *);
!


(*	An access manager for each Supervisor.		*)

type
  un2_access_manager =
    array [pseudo_supervisor_index] of un2_access_controller;
!
(************************************************************************)
(*									*)
(*	CIRUTL.NTV							*)
(*									*)
(*				circuit_utility				*)
(*									*)
(*	The circuit_utility Class performs general circuit functions.	*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	11/10/83	Original -- jrn					*)
(*									*)
(************************************************************************)


const
  HANDSHAKE_CHARACTERS_MAXIMUM = 4;
  HANDSHAKE_CHARACTERS_LIMIT = handshake_characters_maximum - 1;


type
  HANDSHAKE_CHARACTER_INDEX = 0..handshake_characters_limit;
  HANDSHAKE_CHARACTERS = array [HANDSHAKE_CHARACTER_INDEX] of char;


const
  STANDARD_HANDSHAKE = '(:1:)(:2:)(:3:)(:4:)' (* not very secure!! *);



type CIRCUIT_UTILITY = class(
	aux_io		: circuit_handler);



(**************************  circuit_utility  ***************************)
(*									*)
(*			    exchange_handshake				*)
(*									*)
(*      Exchange the supplied handshake.				*)
(*									*)
(************************************************************************)

procedure entry EXCHANGE_HANDSHAKE(
      handshake	: handshake_characters);

var
  receive_buffer : char;
  index : handshake_character_index;
  done : boolean;

begin	(* send the handshake first *)
  aux_io.write_word(handshake);
  if aux_io.available
  then
    begin	(* get the handshake *)
      index := 0; done := FALSE;
      while (aux_io.available) and not done do
        begin
          aux_io.read_one_character(receive_buffer);
          if aux_io.available
	  then
	    if receive_buffer <> handshake[index]
	    then index := 0
	    else
	      if index = HANDSHAKE_CHARACTERS_LIMIT
	      then done := TRUE
	      else index := index + 1
	end
    end
end (* exchange_handshake *);


(************************************************************************)
(************************************************************************)

begin (* initial statement *)
end (* circuit_utility *);
!
(************************************************************************)
(*									*)
(*	UN2UTL.NTV							*)
(*									*)
(*				un2_utility				*)
(*									*)
(*	The un2_utility class performs un2 slave functions.		*)
(*									*)
(*	The routines are organized as follows:				*)
(*		Miscellaneous Routines					*)
(*		Circuit Routines					*)
(*		MUD Change Routines					*)
(*		CONSISTENCY Routines					*)
(*		Programmer Process Routines				*)
(*									*)
(*      The following identifiers must be defined externally:		*)
(*	  circuit_handler, internal_to_string, operator_messages,	*)
(*	  un2_access_manager, login_string, un2_status, cud_block_index,*)
(*	  supervisor_index, cud_change_information, un2_user_index,	*)
(*	  character_set, cud_data_word_size, cud_data, cud_disk_block	*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	12Feb87 - neh							*)
(*	      - add UN2_DISK_ERROR					*)
(*	      - add check_version to build_un2_circuit to get the	*)
(*		version number from UN2 and verify and get options	*)
(*	      - change mud update to send byte count and offset		*)
(*		instead of word count and offset			*)
(*	      - include UN2_DISK_ERROR as characters to get from sup	*)
(*	29Jan87 - neh							*)
(*	      - change send_block to use cud_checksum instead of	*)
(*		supervisor_checksum if BEFORE_SUP_V43 is disabled	*)
(*	15Jan87 - neh							*)
(*	      - change send_data to use mud_entry_data if		*)
(*		BEFORE_SUP_V43 is disabled				*)
(*	      - change send_consistency to use mud_disk_block		*)
(*		if BEFORE_SUP_V43 is disabled				*)
(*	      - change write_mud_block and read_mud_block to use	*)
(*		mud_disk_block instead of cud_disk_block		*)
(*	09Sep86 - neh							*) 
(*	       - Change report_message to report_supervisor_message.	*)
(*	18Aug86 - jrn							*)
(*	      - modify and simplify the UN2 access scheme		*)
(*	21Jan86 - jrn							*)
(*	      - use control-I in login string				*)
(*	20Jan86 - jrn							*)
(*	      - modify USN code for NVDM				*)
(*	03Jan86	- rsb							*)
(*	      - expand "sup: Supervisor_index" in "var' list		*)
(*		into "pseudo_sup" and "real_sup".			*)
(*	      - Report_error: add call to translate_ps_to_rs to insure	*)
(*		proper Supervisor is specified in the error message.	*)
(*	      - Send_mud_changes:					*)
(*		Read_mud_block:						*)
(*		Write_mud_block:					*)
(*		Initialize_consistency:					*)
(*		Add call to translate_rs_to_ps to start of procedure	*)
(*		so correct instance of circuit_handler can be called.	*)
(*	      - send_consistency_block: change "supervisor" 		*)
(*		into "real_sup".					*)
(*	23May85 - jrn							*)
(*	      -	call system_handler routine supervisor_checksum to	*)
(*		compute the Tymcom-IX checksum for UN2			*)
(*	12Apr85 jrn							*)
(*	      - fix Supervisor checksum					*)
(*	09Aug84 jrn							*)
(*	      - when building a circuit, if one is already built,	*)
(*		zap it							*)
(*	      - use engine checksum for disk, so move supervisor	*)
(*		checksum here						*)
(*	      - use MAXIMUM_UN2_RETRIES for both consistency and MUD	*)
(*		change updates						*)
(*	15Jun84	jrn							*)
(*	      - add consistency restart capability			*)
(*	      - add disk_maintenance_code assembly parameter		*)
(*	26Apr84 Version 2.02 - jrn					*)
(*	      - re-use circuit on consecutive MUD changes		*)
(*	14Mar84	Version 2.01 - jrn					*)
(*	      - set a timeout of 30 seconds on circuits built		*)
(*	      - change the error reporting to eliminate multiple	*)
(*		reports and report ranges of blocks transmitted in	*)
(*		consistencies						*)
(*		Original -- jrn						*)
(*									*)
(************************************************************************)



type UN2_UTILITY = class(
	aux_io		: circuit_handler;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code 	oper_messages	: operator_messages;
$if disk_maintenance_code	user_terminal	: circuit_handler;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	format		: internal_to_string;
	circuit_access	: un2_access_manager
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code );
$ifnone disk_maintenance_code
;
	mud_change	: mud_change_handler);
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

const		(* UN2 login string information *)
  LOGIN_STRING_SIZE = 10;
  LOGIN_STRING_SUP_CHAR = 8 (* place to store sup no. *);
  LOGIN_STRING_TEXT =
    '(:9:)(:4:)UN2:12x;                                                ';



(* UN2 commands *)
  UN2_CONSISTENCY_COMMAND = '(:1:)';
  UN2_WRITE_MUD_COMMAND = '(:2:)';
  UN2_READ_MUD_COMMAND = '(:3:)';
  UN2_CONSISTENCY_RESTART_COMMAND = '(:4:)';



(* UN2 consistency codes *)
  UN2_COMMAND_ACCEPTED = '(:1:)' (* used for all commands *);
  UN2_CONSISTENCY_CHECKSUM_OK = '(:1:)';
  UN2_CONSISTENCY_MISMATCH = '(:2:)';
  UN2_DATA_CHECKSUM_OK = '(:1:)' (* also used for write MUD *);
  UN2_CONSISTENCY_BAD_DATA_CHECKSUM = '(:3:)';



(* UN2 write MUD codes *)
  UN2_BLOCK_FOLLOWS = '(:1:)' (* also used for read MUD *);
  UN2_BAD_DATA_CHECKSUM = '(:2:)';
  UN2_DISK_ERROR = '(:4:)' (* UN2 error writing to MUD *);


var
  sys_io : system_handler;
  cir_utility : circuit_utility;
  mutil	: misc_utility;

(* current supervisor *)
  pseudo_sup : pseudo_supervisor_index;
  real_sup : real_supervisor_index;

!
"
		Miscellaneous Routines
"



(****************************  un2_utility  *****************************)
(*									*)
(*			      report_error				*)
(*									*)
(*      Report the status to the operator_log.				*)
(*									*)
(************************************************************************)

procedure report_error(
      status	: un2_status;
      block	: cud_block_index);

begin
  format.start;
  with aux_io do
    format.un2_sup_error(status, param.status, param.arg2, block);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code   oper_messages.report_supervisor_message(real_sup, UN2_OPLOG_MSG)
$if disk_maintenance_code   format.write_line(user_terminal)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
end (* report_error *);
"


(****************************  un2_utility  *****************************)
(*									*)
(*			  do_supervisor_checksum			*)
(*									*)
(*      Return the checksum for the CUD data; code in-line for speed.	*)
(*	The checksum is rotated 7 bits to the left; this is the		*)
(*	TYMCOM-IX left cycle instruction.				*)
(*									*)
(************************************************************************)

procedure do_supervisor_checksum(
      size	: cud_data_size;
  var data	: cud_data;
  var checksum	: integer);

var
  cksum : integer;
  index : cud_data_index;

begin
  cksum := 0;
  for index := 0 to size - 1 do
    begin
      cksum := (cksum * BIT24) + (cksum div BIT14) + ord(data[index]);
      if cksum < 0
      then cksum := cksum - BIT0;
      cksum := cksum mod BIT7
    end (* for *);
  do_supervisor_checksum := cksum
end (* do_supervisor_checksum *);"



(****************************  un2_utility  *****************************)
(*									*)
(*			   check_circuit_status				*)
(*									*)
(*      Set un2_status if there is a circuit problem and report.	*)
(*									*)
(************************************************************************)

procedure check_circuit_status(
      error_status	: un2_status;
      block		: cud_block_index;
  var status		: un2_status);

begin
  if not aux_io.available
  then
    begin
      status := error_status;
      report_error(status, block)
    end
end (* check_circuit_status *);
!
"
		Circuit Routines
"


(****************************  un2_utility  *****************************)
(*									*)
(*			    get_sup_character				*)
(*									*)
(*      Input a character and check the circuit; if circuit error or	*)
(*	byte_input is not in acceptable_chars, set status,		*)
(*	zap the circuit and report the error.				*)
(*									*)
(************************************************************************)

procedure get_sup_character(
      acceptable_chars	: character_set;
      block		: cud_block_index;
  var byte_input	: char;
  var status		: un2_status);

begin
  aux_io.read_one_character(byte_input);
  check_circuit_status(UN2_CIRCUIT_ERROR, block, status);
  if status = UN2_SUCCESSFUL
  then
    if not (byte_input in acceptable_chars)
    then
      begin
        status := UN2_UNEXPECTED_INPUT;
	aux_io.clear_circuit;
	report_error(status, block)
      end
end (* get_sup_character *);


(****************************  un2_utility  *****************************)
(*									*)
(*			   build_un2_circuit				*)
(*									*)
(*      Be sure there is a circuit in tact for the sup.			*)
(*									*)
(************************************************************************)

procedure build_un2_circuit(
    var status	: un2_status);

var
  login : login_string;
$ifnone BEFORE_SUP_V43  check_word : integer;

begin
  if aux_io.available
  then aux_io.clear_circuit;
  status := UN2_SUCCESSFUL;
  login.size := LOGIN_STRING_SIZE;
  login.text := LOGIN_STRING_TEXT;
  login.text[LOGIN_STRING_SUP_CHAR] := chr(ord('0') + real_sup);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code
  aux_io.build_aux_circuit(pseudo_sup, [COMPLETE], 60, login);
$endif disk_maintenance_code
$if disk_maintenance_code
  aux_io.build_aux_circuit(0, [COMPLETE], 60, login);
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  aux_io.set_timeout(30);
  check_circuit_status(UN2_BUILD_FAILURE, 0, status);
  if status = UN2_SUCCESSFUL
  then
    begin
      cir_utility.exchange_handshake(STANDARD_HANDSHAKE);
      check_circuit_status(UN2_HANDSHAKE_ERROR, 0, status)
$ifnone BEFORE_SUP_V43
;
      if status = UN2_SUCCESSFUL
      then
	begin
  	  aux_io.read_word(check_word);
  	  if check_word < MUD_SUP_VERSION
  	  then aux_io.clear_circuit;
	  check_circuit_status(UN2_VERSION_ERROR, 0, status)
	end;
      if status = UN2_SUCCESSFUL
      then
	begin
	  aux_io.read_word(check_word);
	  check_circuit_status(UN2_OPTION_ERROR, 0, status)
	end
$endif BEFORE_SUP_V43
    end
end (* build_un2_circuit *);



(****************************  un2_utility  *****************************)
(*									*)
(*				send_command				*)
(*									*)
(*      Send a UN2 command and receive confirmation.			*)
(*									*)
(************************************************************************)

procedure send_command(
      un2_cmd	: char;
  var status	: un2_status);

var
  input_char : char;

begin
  aux_io.write_one_character(un2_cmd);
  get_sup_character([UN2_COMMAND_ACCEPTED], 0, input_char, status)
end (* send_command *);


(****************************  un2_utility  *****************************)
(*									*)
(*				send_data				*)
(*									*)
(*      Send word_count (in 2 bytes), data and checksum to UN2		*)
(*	(called by send_block and send_consistency_block routines).	*)
(*									*)
(************************************************************************)

procedure send_data(
$if BEFORE_SUP_V43 word_count	: cud_data_word_size;
$ifnone BEFORE_SUP_V43 byte_count	: mud_data_size;
      block		: cud_block_index;
      checksum		: integer;
$if BEFORE_SUP_V43  var data		: cud_data;
$ifnone BEFORE_SUP_V43  var data		: mud_data;
  var status		: un2_status);

begin
  aux_io.write_mud_data(
$if BEFORE_SUP_V43
    (word_count * MAXIMUM_BYTES_IN_WORD), data);
  aux_io.write_three_characters(checksum);
$endif BEFORE_SUP_V43
$ifnone BEFORE_SUP_V43
    byte_count, data);
  aux_io.write_word(checksum);
$endif BEFORE_SUP_V43
  check_circuit_status(UN2_CIRCUIT_ERROR, block, status)
end (* send_data *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code



(****************************  un2_utility  *****************************)
(*									*)
(*				send_block				*)
(*									*)
(*      Send a MUD block to UN2 (called by send_mud_change		*)
(*	and write_mud_block routines).					*)
(*									*)
(************************************************************************)

procedure send_block(
$ifnone (BEFORE_SUP_V43, disk_maintenance_code)       turn_off_sup	: boolean;
  var change_info	: mud_update_information;
  var status		: un2_status);

var
$ifnone BEFORE_SUP_V43
  disk_error_count : integer;
  header_info : mudupd_disk_header;
$endif BEFORE_SUP_V43
  done : boolean;
  retries : integer;
  byte_input : char;

begin
  aux_io.write_one_character(UN2_BLOCK_FOLLOWS);
  if status <> UN2_SUCCESSFUL
  then report_error(status, change_info.cud_info.header.block)
  else
    begin (* status = UN2_SUCCESSFUL *)
      done := FALSE;
$ifnone BEFORE_SUP_V43
      disk_error_count := 0;
$endif BEFORE_SUP_V43
      retries := 0;
      with change_info, cud_info, header do
	begin
$ifnone BEFORE_SUP_V43 sys_io.mud_checksum(size, data, checksum);
$if BEFORE_SUP_V43 sys_io.supervisor_checksum(size * 4, data, checksum);
	  repeat
            aux_io.write_two_characters(block);
	    aux_io.write_two_characters(offset);
	    aux_io.write_two_characters(size);
$ifnone BEFORE_SUP_V43            aux_io.write_word(time);
	    send_data(size, block, checksum, data, status);
	    get_sup_character([UN2_DATA_CHECKSUM_OK, UN2_BAD_DATA_CHECKSUM,
	      UN2_DISK_ERROR], block, byte_input, status);
            if status <> UN2_SUCCESSFUL
	    then done := TRUE
	    else
              if byte_input = UN2_DATA_CHECKSUM_OK
	      then done := TRUE
	        else
	        if retries = MAXIMUM_UN2_RETRIES
	        then
		  begin
$ifnone BEFORE_SUP_V43
		    if disk_error_count = retries
	  	    then
$ifnone disk_maintenance_code
		      begin
 	      	        if turn_off_sup
		        then
	                  begin
	  		    oper_messages.report_supervisor_message(real_sup,
			      UPDATE_OFF_MSG);
	  		    mud_change.get_header_info(header_info);
	  		    mud_change.turn_sup_off(real_sup, header_info)
			  end (* turn_off_sup *);
$endif disk_maintenance_code
		        status := UN2_TOO_MANY_DISK_ERRORS
$ifnone disk_maintenance_code 			end (* disk_error_count = retries *)
		  else
$endif BEFORE_SUP_V43
		    status := UN2_TOO_MANY_RETRIES;
		    report_error(status, change_info.cud_info.header.block)
		  end (* retries = MAXIMUM_UN2_RETRIES *)
	        else
$ifnone BEFORE_SUP_V43
		  if byte_input = UN2_DISK_ERROR
		  then
	            begin
	              disk_error_count := disk_error_count + 1;
$endif BEFORE_SUP_V43
	              retries := retries + 1
$ifnone BEFORE_SUP_V43		end
          until done
        end
    end (* status = UN2_SUCCESSFUL *)
end (* send_block *);
!
"
		MUD Change Routine

	The following is used by the MUD_UPDATER process when
sending mud updates to the Supervisors.
"



(****************************  un2_utility  *****************************)
(*									*)
(*			    send_mud_change				*)
(*									*)
(*      Update the MUD block with the information described by		*)
(*	change_info.							*)
(*									*)
(************************************************************************)

procedure entry SEND_MUD_CHANGE(
      sup               : real_supervisor_index;
  var change_info	: mud_update_information;
  var status		: un2_status);

begin (* send_mud_change *)
  real_sup := sup;
  mud_change.translate_rs_to_ps(real_sup, pseudo_sup);
  if circuit_access[pseudo_sup].access_circuit 
  then
    begin (* actually send a mud change *)
      status := UN2_SUCCESSFUL;
      aux_io.use_circuit(pseudo_sup, AUX_CIRCUIT, [COMPLETE]);
      aux_io.check_circuit;
(* if circuit is already built, the last command must have also been *)
(* a "send_mud_change", so just continue with sending the block data *)
      if aux_io.available
      then aux_io.set_timeout(30)
      else
        begin (* obtain a circuit *)
          build_un2_circuit(status);
   	  if aux_io.available
	  then send_command(UN2_WRITE_MUD_COMMAND, status)
  	end (* obtain a circuit *);
      if aux_io.available
      then send_block(
$ifnone BEFORE_SUP_V43  TRUE,
	change_info, status);
      circuit_access[pseudo_sup].release_circuit
    end (* actually send a mud change *)
  else status := UN2_BUSY
end (* send_mud_change *);
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
"

		Consistency Routines
The following routines are used to perform a consistency check.
They are called by the CONSISTENCY Class from both the MUD_UPDATER
Processes and the privileged validator Processes.
"



(****************************  un2_utility  *****************************)
(*									*)
(*			initialize_consistency				*)
(*									*)
(*      Lock the Monitor for the consistency and be sure there is	*)
(*	a circuit built.						*)
(*									*)
(************************************************************************)

procedure entry INITIALIZE_CONSISTENCY(
      sup               : real_supervisor_index;
      start_block	: cud_block_index;
  var status		: un2_status);

var
  input_char : char;

begin (* initialize_consistency *)
  real_sup := sup;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code   pseudo_sup := real_sup;
$ifnone disk_maintenance_code
  mud_change.translate_rs_to_ps(real_sup, pseudo_sup);
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  if circuit_access[pseudo_sup].access_circuit
  then
    begin (* obtain and use a circuit *)
      build_un2_circuit(status);
      if status = UN2_SUCCESSFUL
      then
	if CONSISTENCY_RESTARTABLE and (start_block <> 0)
	then
          begin (* send some consistency data *)
	    aux_io.write_one_character(UN2_CONSISTENCY_RESTART_COMMAND);
	    aux_io.write_two_characters(start_block);
	    get_sup_character([UN2_COMMAND_ACCEPTED], 0, input_char,
	         status)
	  end (* send some consistency data *)
 	else send_command(UN2_CONSISTENCY_COMMAND, status);
          if status <> UN2_SUCCESSFUL
          then circuit_access[pseudo_sup].release_circuit
        end (* obtain and use a circuit *)
      else  
        begin (* cannot use circuit for consistency now *)
          status := UN2_BUSY;
          report_error(status, 0)
        end (* cannot use circuit for consistency now *)
end (* initialize_consistency *);



(****************************  un2_utility  *****************************)
(*									*)
(*			    get_mud_checksum				*)
(*									*)
(*      Input 3 bytes of checksum for the next MUD block.		*)
(*									*)
(************************************************************************)

procedure entry GET_MUD_CHECKSUM(
  var checksum	: integer;
  var status	: un2_status);

begin
$if BEFORE_SUP_V43  aux_io.read_three_characters(checksum);
$ifnone BEFORE_SUP_V43  aux_io.read_word(checksum);
  check_circuit_status(UN2_CIRCUIT_ERROR, 0, status)
end (* get_mud_checksum *);



(****************************  un2_utility  *****************************)
(*									*)
(*			    checksum_matched				*)
(*									*)
(*      Tell UN2 that checksums matched.				*)
(*									*)
(************************************************************************)

procedure entry CHECKSUM_MATCHED(
  var status	: un2_status);

begin
  aux_io.write_one_character(UN2_CONSISTENCY_CHECKSUM_OK);
  check_circuit_status(UN2_CIRCUIT_ERROR, 0, status)
end (* checksum_matched *);



(****************************  un2_utility  *****************************)
(*									*)
(*			send_consistency_block				*)
(*									*)
(*      Consistency block checksums did not match, tell UN2; send CUD	*)
(*	information; keep track of retries and report any to operator	*)
(*	log.								*)
(*									*)
(************************************************************************)

procedure entry SEND_CONSISTENCY_BLOCK(
      block		: cud_block_index;
$if BEFORE_SUP_V43
      word_count	: cud_data_word_size;
  var cud_buffer	: cud_disk_block;
$endif BEFORE_SUP_V43
$ifnone BEFORE_SUP_V43
      word_count	: mud_data_word_size;
      turn_sup_off	: boolean;
  var mud_buffer	: mud_disk_block;
$endif BEFORE_SUP_V43
  var retries		: integer;
  var status		: un2_status);

var
$ifnone BEFORE_SUP_V43
  disk_error_count  : integer;
  header_info : mudupd_disk_header;
$endif BEFORE_SUP_V43
  success : boolean;
  byte_input : char;

begin
  aux_io.write_one_character(UN2_CONSISTENCY_MISMATCH);
$ifnone BEFORE_SUP_V43 disk_error_count := 0;
  retries := 0;
  repeat	(* send the consistency block data *)
    if status = UN2_SUCCESSFUL
    then aux_io.write_two_characters(word_count);
$if BEFORE_SUP_V43    with cud_buffer do
$ifnone BEFORE_SUP_V43    with mud_buffer do
      if status = UN2_SUCCESSFUL
      then send_data(
$ifnot BEFORE_SUP_V43        (word_count * 4),
$if BEFORE_SUP_V43        word_count,
	block, checksum, data, status);
    if status = UN2_SUCCESSFUL
    then get_sup_character(
      [UN2_CONSISTENCY_CHECKSUM_OK, UN2_CONSISTENCY_BAD_DATA_CHECKSUM,
        UN2_DISK_ERROR], block, byte_input, status);
    if status = UN2_SUCCESSFUL
    then success :=  byte_input = UN2_CONSISTENCY_CHECKSUM_OK;
    if not success
    then
      if retries = MAXIMUM_UN2_RETRIES
      then
        begin
$ifnone BEFORE_SUP_V43
	  if retries = disk_error_count
	  then
$ifnone disk_maintenance_code
	  if turn_sup_off
	  then
	    begin
	      oper_messages.report_supervisor_message(real_sup,
		UPDATE_OFF_MSG);
	      mud_change.get_header_info(header_info);
	      mud_change.turn_sup_off(real_sup, header_info)
	    end (* disk_error_count *);
$endif disk_maintenance_code
	  status := UN2_TOO_MANY_DISK_ERRORS;
$endif BEFORE_SUP_V43
$if BEFORE_SUP_V43      		status := UN2_TOO_MANY_RETRIES;
	  report_error(status, block)
	end
      else
$ifnone BEFORE_SUP_V43
	if byte_input = UN2_DISK_ERROR
	then
	  begin
	    disk_error_count := disk_error_count + 1;
$endif BEFORE_SUP_V43
	    retries := retries + 1
$ifnone BEFORE_SUP_V43	      end
    until success or (status <> UN2_SUCCESSFUL);
  if not success
  then aux_io.clear_circuit
  else
    if retries > 0
    then
      begin
        format.start_message('UN2 report: \ ');
	format.string(' resent block \ ');
	format.number(block, 10);
	format.character(ASCII_SPACE);
	format.number(retries + 1, 10);
	format.string(' times\ ');
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code
        oper_messages.report_supervisor_message(real_sup, UN2_OPLOG_MSG)
$endif disk_maintenance_code
$if disk_maintenance_code user_terminal.write_format_buffer(format.buffer)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      end (* retries > 0 *)
end (* send_consistency_block *);
!
"
		Programmer Process Routines

The following calls to the UN2_UTILITY Class allows access to the
Supervisor UN2 slave to read and write a MUD block.
"



(****************************  un2_utility  *****************************)
(*									*)
(*			      read_mud_block				*)
(*									*)
(*      Read the specified MUD block; if called by the NETVAL READ MUD	*)
(*	command, zap the circuit; if NVDM, keep the circuit.		*)
(*									*)
(************************************************************************)

procedure entry READ_MUD_BLOCK(
      sup               : real_supervisor_index;
      block		: cud_block_index;
  var status		: un2_status;
$if BEFORE_SUP_V43   var buffer		: cud_disk_block);
$ifnone BEFORE_SUP_V43   var buffer	: mud_disk_block);

begin (* read_mud_block *)
  real_sup := sup;
  status := UN2_SUCCESSFUL;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code   pseudo_sup := real_sup;
$ifnone disk_maintenance_code
  mud_change.translate_rs_to_ps(real_sup, pseudo_sup);
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  if circuit_access[pseudo_sup].access_circuit
  then
    begin (* block moving *)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code
      if not aux_io.available
      then
        begin (* build a circuit *)
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	  build_un2_circuit(status);
	  if status = UN2_SUCCESSFUL
	  then send_command(UN2_READ_MUD_COMMAND, status);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code	end (* build a circuit *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
          if status = UN2_SUCCESSFUL
          then
            begin (* actually read a mud block *)
	      aux_io.write_one_character(UN2_BLOCK_FOLLOWS);
	      aux_io.write_two_characters(block);
	      aux_io.read_mud_data(buffer);
	      check_circuit_status(UN2_CIRCUIT_ERROR, 0, status)
	    end (* actually read a mud block *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code      aux_io.clear_circuit;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
          circuit_access[pseudo_sup].release_circuit
        end (* block moving *)
      else status := UN2_BUSY
end (* read_mud_block *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code



(****************************  un2_utility  *****************************)
(*									*)
(*			     write_mud_block				*)
(*									*)
(*                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  entry_info.user.packed_name_size of the entry in data		*)
(*	pointed to by entry_info.mud_pointer; set entry_found to	*)
(*	FALSE if the end of the CUD information is found.		*)
(*									*)
(************************************************************************)

procedure next_cud_entry(
      data	: cud_entry_data;
  var entry_name: username_string;
  var entry_info: mud_entry_descriptor);

$if overflow_cud_entries
var
  mud_header : mud_block_header;
$endif overflow_cud_entries

begin
$if overflow_cud_entries
  cud_utility.unpack_mud_header(data.mud_block.data, mud_header);
$endif overflow_cud_entries
  cud_utility.set_entry_sizes(data, entry_info.mud_pointer,
    entry_info.nud_pointer, entry_info.user.block,
$if overflow_cud_entries    mud_header,
    last_status, entry_info.size_of_mud_entry, entry_info.size_of_nud_entry);
  if last_status = CUD_ENTRY_OK
  then
    begin
      set_entry_sizes(
        mud_entry_type_of_char(data.mud_block.data[entry_info.mud_pointer]),
	entry_info);
      unpack_entry_name(entry_info, data.mud_block.data, entry_name)
    end (* CUD_ENTRY_OK *);
  if last_status = CUD_ENTRY_OK
  then entry_info.user.packed_name_size := packed_size_of_name(entry_name)
end (* next_cud_entry *);


(*********************  mud_entry_updater  ******************************)
(*									*)
(*			     get_user_entry				*)
(*									*)
(*      Scan buffer.data for entry_info.user.name; if not found, set	*)
(*	name_found to FALSE; otherwise, set name_found to TRUE,		*)
(*	and set up the rest of the entry_info information (size,	*)
(*	pointer and user.packed_name_size).				*)
(*									*)
(************************************************************************)

procedure get_user_entry(
      data		: cud_entry_data;
  var entry_info	: mud_entry_descriptor);

var
  name_found : boolean;
  entry_name : username_string;


begin
  entry_info.mud_pointer := START_MUD_ENTRY_OFFSET;
  entry_info.nud_pointer := NUD_DATA_ENTRY_OFFSET;
  name_found := FALSE;
  repeat
    next_cud_entry(data, entry_name, entry_info);
    if last_status = CUD_ENTRY_OK
    then
      if mutil.username_match(entry_name, entry_info.user.name)
      then name_found := TRUE
      else cud_utility.increment_entry_pointer(entry_info.user.block,
	entry_info.size_of_mud_entry, entry_info.size_of_nud_entry,
	last_status, entry_info.mud_pointer, entry_info.nud_pointer)
  until (last_status <> CUD_ENTRY_OK) or name_found
end (* get_user_entry *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(*********************  mud_entry_updater  ******************************)
(*									*)
(*			     find_user_entry				*)
(*									*)
(*      Find a user's CUD entry, given entry_info.user information.	*)
(*	If lock_block is TRUE, lock the block.				*)
(*	This routine is separate from locate_name because the hash	*)
(*	should not be repeated unless necessary (used by locate_name,	*)
(*	delete_entry, all external update_x routines).			*)
(*									*)
(************************************************************************)

procedure find_user_entry(
$ifnone CONVERT_TO_43       lock_block	: boolean (* lock block *);
  var buffer		: univ cud_data_block;
  var entry_info	: mud_entry_descriptor);

$if OVERFLOW_CUD_ENTRIES
var
  first_block : integer;
$endif OVERFLOW_CUD_ENTRIES

begin
$ifnone CONVERT_TO_43   read_block(lock_block, entry_info, buffer);
$if CONVERT_TO_43   read_cud_block(entry_info.user.block, buffer);
  if last_status = CUD_ENTRY_OK
  then get_user_entry(buffer.data, entry_info);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if OVERFLOW_CUD_ENTRIES
  if last_status = CUD_ENTRY_OVERFLOW_FOUND
  then
    begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+	*)
$if convert_to_43
      if CONVERT_OVERFLOW_BLOCKS <= 0
      then last_status := CUD_ENTRY_NOT_FOUND
      else
	begin
$endif convert_to_43
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+	*)
          first_block := entry_info.user.block;
	  entry_info.user.block := second_hash(entry_info.user.name);
	  last_status := CUD_ENTRY_OK;
$if CONVERT_TO_43
	  entry_info.mud_pointer := START_MUD_ENTRY_OFFSET;
	  read_cud_block(entry_info.user.block, buffer)
	end;
$endif CONVERT_TO_43
$ifnone CONVERT_TO_43         read_block(lock_block, entry_info, buffer);
      if last_status = CUD_ENTRY_OK
      then get_user_entry(buffer.data, entry_info);
      if last_status = CUD_ENTRY_NOT_FOUND
$if CONVERT_TO_43
      then read_cud_block(first_block, buffer)
$endif CONVERT_TO_43
$ifnot CONVERT_TO_43
      then
        begin
          if entry_info.block_locked
          then cud_access.unlock_cud_block(entry_info.user.block);
          entry_info.user.block := first_block;
          read_block(lock_block, entry_info, buffer)
        end
      else
        if entry_info.block_locked
        then cud_access.unlock_cud_block(first_block)
$endif CONVERT_TO_43
    end
$endif OVERFLOW_CUD_ENTRIES
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+	*)
end (* find_user_entry *);



(*********************  mud_entry_updater  ******************************)
(*									*)
(*				locate_name				*)
(*									*)
(*      Locate a user's CUD entry; set up entry_info (used by		*)
(*	get_name_entry, valid_cud_name and reserve_name routines).	*)
(*									*)
(************************************************************************)

procedure locate_name(
  var buffer		: cud_disk_block;
  var entry_info	: mud_entry_descriptor);

begin
  if (entry_info.user.name.size > 0)
  then
    begin
      entry_info.user.block := hashed_block(entry_info.user.name);
      find_user_entry(
$ifnone CONVERT_TO_43     FALSE,
        buffer, entry_info)
    end
  else last_status := CUD_ENTRY_ILLEGAL_NAME
end (* locate_name *);
$ifnone convert_to_43



(*********************  mud_entry_updater  ******************************)
(*									*)
(*			     get_name_entry				*)
(*									*)
(*      Find and return a user's CUD entry (used by read_cud_entry	*)
(*	and modify_mud_entry routines).					*)
(*									*)
(************************************************************************)

procedure get_name_entry(
  var buffer		: cud_disk_block;
  var entry_info	: mud_entry_descriptor;
  var mud_entry		: mud_user_entry;
  var nud_entry		: nud_user_entry);

begin
  locate_name(buffer, entry_info);
  if last_status = CUD_ENTRY_OK
  then
    begin
      mud_entry.name := entry_info.user.name;
      unpack_cud_entry(entry_info, buffer.data, mud_entry, nud_entry)
    end
end (* get_name_entry *);
$endif convert_to_43
!
"
	General Value Storage Routines
"



(*********************  mud_entry_updater  ******************************)
(*									*)
(*			   store_two_mud_bytes				*)
(*									*)
(*      Save the rightmost two bytes in word_to_save			*)
(*	in data indexed by save_location.				*)
(*									*)
(************************************************************************)

procedure store_two_mud_bytes(
      word_to_save	: univ word_in_bytes;
      save_location	: mud_data_index;
  var data		: cud_data);

begin
  data[save_location] := word_to_save[2];
  data[save_location + 1] := word_to_save[3]
end (* store_two_mud_bytes *);



(*********************  mud_entry_updater  ******************************)
(*									*)
(*			      remove_entry				*)
(*									*)
(*      Remove the cud entry in data described by entry_info; move	*)
(*	any following entries up to the deleted space, zero any		*)
(*	vacated words and return the total size of the modification	*)
(*	in change_size.  Called by DELETE_ENTRY and MOVE_ENTRY routines.*)
(*									*)
(************************************************************************)

procedure remove_entry(
      entry_info	: mud_entry_descriptor;
  var data		: univ cud_entry_data;
  var change_size	: mud_data_size);

var
  mud_to_pointer : mud_data_index;
  mud_from_pointer : mud_data_index;
  mud_end_pointer : mud_data_index;
  nud_to_pointer : nud_data_index;
  nud_from_pointer : nud_data_index;
  nud_end_pointer : nud_data_index;
  mud_count,
  mud_bytes_to_move : mud_data_size;
  nud_count,
  nud_bytes_to_move : nud_data_size;

begin
  mud_to_pointer := entry_info.mud_pointer;
  mud_from_pointer := entry_info.mud_pointer + entry_info.size_of_mud_entry;
  nud_to_pointer := entry_info.nud_pointer;
  nud_from_pointer := nud_to_pointer + entry_info.size_of_nud_entry;
  cud_utility.find_end_of_entries(data, entry_info.user.block, last_status,
    mud_end_pointer, nud_end_pointer);
  if (last_status = CUD_ENTRY_NOT_FOUND)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if OVERFLOW_CUD_ENTRIES or (last_status = CUD_ENTRY_OVERFLOW_FOUND)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-  *)
  then
(* move MUD data *)
    begin (* move enough to insure a zero word at end *)
      last_status := CUD_ENTRY_OK;
      mud_bytes_to_move := (mud_end_pointer - mud_from_pointer) +
	MAXIMUM_BYTES_IN_WORD;
      change_size := entry_info.size_of_mud_entry + mud_bytes_to_move;
      for mud_count := 0 to mud_bytes_to_move - 1 do (* move entries up *)
        begin
          data.mud_block.data[mud_to_pointer] :=
	    data.mud_block.data[mud_from_pointer];
	  mud_from_pointer := mud_from_pointer + 1;
	  mud_to_pointer := mud_to_pointer + 1
        end (* for *);
      for mud_end_pointer := mud_to_pointer to (mud_from_pointer - 1) do
        data.mud_block.data[mud_end_pointer] := ZERO;
(* move NUD data *)
      nud_bytes_to_move := (nud_end_pointer - nud_from_pointer) +
	MAXIMUM_BYTES_IN_WORD;
      for nud_count := 0 to nud_bytes_to_move - 1 do (* move entries up *)
        begin
          data.nud_block[nud_to_pointer] := data.nud_block[nud_from_pointer];
	  nud_from_pointer := nud_from_pointer + 1;
	  nud_to_pointer := nud_to_pointer + 1
        end (* for *);
      for nud_end_pointer := nud_to_pointer to (nud_from_pointer - 1) do
        data.nud_block[nud_end_pointer] := ZERO
    end (* move enough to insure a zero word at end *)
end (* remove_entry *);



(*********************  mud_entry_updater  ******************************)
(*									*)
(*			      store_mud_options				*)
(*									*)
(*      Save new_options in data in the entry described by entry_info.	*)
(*									*)
(************************************************************************)

procedure store_mud_options(
      new_options	: mud_user_options;
      entry_info	: mud_entry_descriptor;
  var data		: cud_data);

var
  save_ptr : mud_data_index;
  temp_word : integer;

begin
  save_ptr := mud_control_location(entry_info);
  cud_utility.pack_mud_options(new_options, temp_word);
  mutil.save_word_to_two_chars(temp_word, data[save_ptr],
    data[save_ptr + 1])
end (* store_mud_options *);



(*********************  mud_entry_updater  ******************************)
(*									*)
(*				store_uun				*)
(*									*)
(*     Store the UUN in data in the entry described by entry_info       *)
(*									*)
(************************************************************************)

procedure store_uun(
      new_uun		: univ integer;
      entry_info	: mud_entry_descriptor;
  var data		: cud_data);

var
  save_ptr : mud_data_index;

begin
  save_ptr := mud_uun_location(entry_info);
  mutil.save_word_in_characters(new_uun, data[save_ptr], data[save_ptr + 1],
    data[save_ptr + 2], data[save_ptr + 3])
end (* store_uun *);



(*********************  mud_entry_updater  ******************************)
(*									*)
(*			     store_cipher				*)
(*									*)
(************************************************************************)

procedure store_cipher(
      new_cipher	: integer;
      entry_info	: mud_entry_descriptor;
  var data		: cud_data);

var
  save_ptr : mud_data_index;

begin
  save_ptr := mud_password_location(entry_info);
  mutil.save_word_in_characters(new_cipher, data[save_ptr],
    data[save_ptr + 1], data[save_ptr + 2], data[save_ptr + 3])
end (* store_cipher *);



(*********************  mud_entry_updater  ******************************)
(*									*)
(*			     store_expire_date				*)
(*									*)
(************************************************************************)

procedure store_expire_date(
      new_expire_date	: integer;
      entry_info	: mud_entry_descriptor;
  var data		: cud_data);

var
  save_ptr : mud_data_index;

begin
  save_ptr := expiration_date_location(entry_info);
  mutil.save_word_in_characters(new_expire_date, data[save_ptr],
    data[save_ptr + 1], data[save_ptr + 2], data[save_ptr + 3])
end (* store_expire_date *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if restrict_users_by_time


(*********************  mud_entry_updater  ******************************)
(*									*)
(*			pack_allowable_times				*)
(*									*)
(*      Save new_times in data in the entry described by entry_info.	*)
(*									*)
(************************************************************************)

procedure pack_allowable_times(
      new_times		: allowable_login_times;
      entry_info	: mud_entry_descriptor;
  var data		: cud_data);

var
  save_ptr : mud_data_index;
  temp_word : integer;

begin
  save_ptr := allowable_times_location(entry_info);
  cud_utility.pack_allowable_times(new_times, temp_word);
  mutil.save_word_in_characters(temp_word, data[save_ptr], data[save_ptr + 1],
    data[save_ptr + 2], data[save_ptr + 3])
end (* pack_allowable_times *);
$endif restrict_users_by_time
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(*********************  mud_entry_updater  ******************************)
(*									*)
(*			   store_access_profile				*)
(*									*)
(*      Save new_profile in data in the entry described by entry_info.	*)
(*	Called by PACK_CUD_ENTRY and SAVE_ACCESS_PROFILE.		*)
(*									*)
(************************************************************************)

procedure store_access_profile(
      new_profile	: mud_access_profile_description;
      entry_info	: mud_entry_descriptor;
  var data		: cud_data);

var
  profile_pointer : mud_data_index;
  profile_index : mud_access_profile_description_index;

begin
  profile_pointer := mud_profile_location(entry_info);
  for profile_index := 0 to (packed_access_profile_size(new_profile) - 1) do
    begin
      data[profile_pointer] := new_profile[profile_index];
      profile_pointer := succ(profile_pointer)
    end
end (* store_access_profile *);



(*********************  mud_entry_updater  ******************************)
(*									*)
(*			   store_change_date				*)
(*									*)
(*      Store the entry change date.					*)
(*									*)
(************************************************************************)

procedure store_change_date(
      time_to_store	: integer;
      entry_info	: mud_entry_descriptor;
  var data		: cud_data);

var
  temp_time : integer;
  save_ptr : nud_data_index;

begin
  temp_time := time_to_store;
  save_ptr := nud_entry_change_date_location(entry_info);
  mutil.save_word_in_characters(temp_time, data[save_ptr], data[save_ptr + 1],
    data[save_ptr + 2], data[save_ptr + 3])
end (* store_change_date *);
$if include_gan



(*********************  mud_entry_updater  ******************************)
(*									*)
(*				store_gan				*)
(*									*)
(*     Store the GAN in data in the entry described by entry_info       *)
(*									*)
(************************************************************************)

procedure store_gan(
      new_gan		: integer;
      entry_info	: mud_entry_descriptor;
  var data		: cud_data);

var
  save_ptr : cud_data_index;

begin
  save_ptr := nud_gan_location(entry_info);
  mutil.save_word_in_characters(new_gan, data[save_ptr], data[save_ptr + 1],
    data[save_ptr + 2], data[save_ptr + 3])
end (* store_gan *);
$endif include_gan



(*********************  mud_entry_updater  ******************************)
(*									*)
(*			      store_nud_options				*)
(*									*)
(*      Save new_options in data in the entry described by entry_info.	*)
(*									*)
(************************************************************************)

procedure store_nud_options(
      new_options	: nud_user_options;
      entry_info	: mud_entry_descriptor;
  var data		: cud_data);

var
  save_ptr : nud_data_index;
  temp_word : integer;

begin
  save_ptr := nud_options_location(entry_info);
  cud_utility.pack_nud_options(new_options, temp_word);
  mutil.save_word_to_two_chars(temp_word, data[save_ptr],
    data[save_ptr + 1])
end (* store_nud_options *);
$if prevent_duplicate_passwords



(*************************  nud_entry_updater  **************************)
(*									*)
(*			 store_previous_cipher				*)
(*									*)
(*	Store the users previous cipher in the NUD entry.		*)
(*									*)
(************************************************************************)

procedure store_previous_cipher(
      old_cipher	: integer;
      entry_info	: mud_entry_descriptor;
  var data		: cud_data);

var
  save_ptr : nud_data_index;

begin
  save_ptr := nud_cipher_location(entry_info);
  mutil.save_word_in_characters(old_cipher, data[save_ptr], data[save_ptr + 1],
    data[save_ptr + 2], data[save_ptr + 3])
end (* store_previous_cipher *);



(*********************  mud_entry_updater  ******************************)
(*									*)
(*			pack_previous_cipher				*)
(*									*)
(*	If previous_cipher exists and user does not have NO PASSWORD	*)
(*	set, save previous_cipher in data in the entry described by	*)
(*	entry_info.							*)
(*									*)
(************************************************************************)

procedure pack_previous_cipher(
      mud_options	: mud_user_options;
      entry_info	: mud_entry_descriptor;
      old_cipher	: integer;
      disk_has_previous_password	: boolean;
  var nud_options	: nud_user_options;
  var data		: cud_data);

var
  temp_mud_pointer : mud_data_index;
  to_pointer : nud_data_index;
  from_pointer : nud_data_index;

begin
  if disk_has_previous_password
  then
    if old_cipher <> NO_PREVIOUS_CIPHER (* already 1 there, store it *)
    then store_previous_cipher(old_cipher, entry_info, data)
    else
      begin (* NUD has old password, need to eliminate it *)
        nud_options := nud_options - [PREVIOUS_PASSWORD_STORED];
	store_nud_options(nud_options, entry_info, data);

(* move data up to eliminate previous cipher word *)
	to_pointer := nud_cipher_location(entry_info) (* zap 1 word *);
	for from_pointer := (to_pointer + MAXIMUM_BYTES_IN_WORD) to
	  NUD_DATA_LIMIT do
	  begin
	    data[to_pointer] := data[from_pointer];
	    to_pointer := to_pointer + 1
	  end (* for *);
	for to_pointer := (NUD_DATA_LIMIT - MAXIMUM_BYTES_IN_WORD + 1)
	  to NUD_DATA_LIMIT do (* clear the last 4 bytes in the block *)
	  data[to_pointer] := ZERO;
      end (* NUD has old password, need to eliminate it *)
  else (* no previous password on disk *)
    if old_cipher <> NO_PREVIOUS_CIPHER
    then
      begin (* no old password in NUD, add it *)
        nud_options := nud_options or [PREVIOUS_PASSWORD_STORED];
	store_nud_options(nud_options, entry_info, data);

(* move data down to make room for previous cipher word *)
	cud_utility.find_end_of_entries(data, entry_info.user.block,
	  last_status, temp_mud_pointer, to_pointer);
	if last_status <> CUD_ENTRY_NOT_FOUND
	then cud_utility.set_format_error(entry_info.user.block,
	  entry_info.nud_pointer, last_status)
	else (* check for room in NUD data *)
	  if (to_pointer + MAXIMUM_BYTES_IN_WORD) < NUD_DATA_LIMIT
	  then
	    begin (* there IS room for new previous cipher word...move data *)
	      last_status := CUD_ENTRY_OK;
	      to_pointer := to_pointer + MAXIMUM_BYTES_IN_WORD - 1;
	      for from_pointer := (to_pointer - MAXIMUM_BYTES_IN_WORD) downto
	        nud_cipher_location(entry_info) do
		begin
		  data[to_pointer] := data[from_pointer];
		  to_pointer := to_pointer - 1;
		end (* there IS room for previous cipher word...move data *);
	      store_previous_cipher(old_cipher, entry_info, data)
	    end (* there IS room for new previous cipher word...move data *)
	  else last_status := CUD_ENTRY_DOES_NOT_FIT
      end (* no old password in NUD, add it *)
end (* pack_previous_cipher *);
$endif prevent_duplicate_passwords
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(*********************  mud_entry_updater  ******************************)
(*									*)
(*			     store_district				*)
(*									*)
(*      Save new_district in data in the entry described by entry_info. *)
(*									*)
(************************************************************************)

procedure store_district(
      new_district	: district_number;
      entry_info	: mud_entry_descriptor;
  var data		: cud_data);

var
  save_ptr : nud_data_index;

begin
  save_ptr := nud_district_location(entry_info);
  mutil.save_word_in_two_chars(new_district, data[save_ptr],
    data[save_ptr + 1])
end (* store_district *);



(*********************  mud_entry_updater  ******************************)
(*									*)
(*			   store_password_date				*)
(*									*)
(*      Save new_date in data in the entry described by entry_info.	*)
(*									*)
(************************************************************************)

procedure store_password_date(
      new_date		: integer;
      entry_info	: mud_entry_descriptor;
  var data		: cud_data);

var
  save_ptr : nud_data_index;
  temp_date : integer;

begin
  save_ptr := nud_password_change_date_location(entry_info);
  temp_date := new_date;
  mutil.save_word_in_characters(temp_date, data[save_ptr], data[save_ptr + 1],
    data[save_ptr + 2], data[save_ptr + 3])
end (* store_password_change_date *);



(*********************  mud_entry_updater  ******************************)
(*									*)
(*			    pack_cud_entry				*)
(*									*)
(*      Save mud_user_entry and nud_user_entry in data indexed by	*)
(*	entry_info.mud_pointer. Called by ADD_NEW_ENTRY and MOVE_ENTRY.	*)
(*									*)
(************************************************************************)

procedure pack_cud_entry(
      entry_info	: mud_entry_descriptor;
      mud_entry		: mud_user_entry;
      nud_entry		: nud_user_entry;
      mud_access	: mud_access_profile_description;
  var data		: univ cud_data);

var
  get_pointer : username_text_index (* used to pick up chars from name *);
  save_ptr : mud_data_index;
  temp_word : integer;

begin
(* store MUD entry type and AP offset *)
  save_ptr := entry_info.mud_pointer;
  data[save_ptr] := char_of_mud_entry_type(mud_entry.entry_type);
  data[save_ptr + 1] := chr(packed_data_size(entry_info));

(* store two bytes of mud entry size *)
  store_two_mud_bytes(entry_info.size_of_mud_entry,
    mud_entry_size_location(entry_info.mud_pointer), data);

(*	save options	*)
  store_mud_options(mud_entry.mud_options, entry_info, data);

(*	save irc	*)
  if mud_entry.entry_type <> MINIMUM_ENTRY
  then data[mud_irc_location(entry_info)] :=
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if INCLUDE_IRC    chr(mud_entry.irc);
$ifnot INCLUDE_IRC   chr(0);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

(*	save UUN	*)
  store_uun(mud_entry.uun, entry_info, data);

(*	save password	*)
  store_cipher(mud_entry.password.cipher, entry_info, data);

(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	store password expiration date	 *)
$if PASSWORD_EXPIRATION_BY_USER
"$if ALLOW_GLOBAL_PASSWORD_EXPIRE"
  if mud_entry.entry_type <> MINIMUM_ENTRY
  then store_expire_date(mud_entry.password.expire_date, entry_info, data);

$endif PASSWORD_EXPIRATION_BY_USER
"$endif ALLOW_GLOBAL_PASSWORD_EXPIRE)"
$ifnot PASSWORD_EXPIRATION_BY_USER
"$ifnot ALLOW_GLOBAL_PASSWORD_EXPIRE"
  if mud_entry.entry_type <> MINIMUM_ENTRY
  then store_expire_date(0, entry_info, data);

$endif PASSWORD_EXPIRATION_BY_USER
"$endif ALLOW_GLOBAL_PASSWORD_EXPIRE"

$if restrict_users_by_time
(*	store allowable login times	*)
  if mud_entry.entry_type = TIME_RESTRICTED_ENTRY
  then pack_allowable_times(mud_entry.allowable_times, entry_info, data);

$endif restrict_users_by_time
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	store entry name	*)
  save_ptr := mud_name_location(entry_info);
  data[save_ptr] := chr(entry_info.user.name.size);
  save_ptr := succ(save_ptr);
  for get_pointer := 0 to entry_info.user.name.size - 1 do
    begin
      data[save_ptr] := entry_info.user.name.text[get_pointer];
      save_ptr := save_ptr + 1
    end (* for *);
  if (entry_info.user.name.size mod 2) = 0
  then
    begin
      data[save_ptr] := PAD_CHAR;
      save_ptr := save_ptr + 1
    end (* for *);

(*	save access profile	*)
  store_access_profile(mud_access, entry_info, data);

(*	save entry change date	*)
  store_change_date(REALTIME, entry_info, data);

(*	save GAN	*)
$if include_gan  store_gan(nud_entry.gan, entry_info, data);

(*	save NUD options *)
  store_nud_options(nud_entry.nud_options, entry_info, data);

(*	save district	*)
  if include_district
  then store_district(nud_entry.district, entry_info, data)
  else store_district(0, entry_info, data);

(*	save password change date	*)
  store_password_date(nud_entry.password_change_date, entry_info, data);

(* save terminating word of zero *)
  save_ptr := mud_terminator_location(entry_info);
  temp_word := MUD_BLOCK_TERMINATOR;
  mutil.save_word_in_characters(temp_word, data[save_ptr],
    data[save_ptr + 1], data[save_ptr + 2], data[save_ptr + 3])
end (* pack_cud_entry *);
!
"
	Procedures to convert old access_profile to MUD 43 access_profile
	and to pack as MUD data.  Could be conditional on CONVERT_TO_V43
	if command level inputs directly to MUD 43 format.
"


(*********************  mud_entry_updater  ******************************)
(*                                                                      *)
(*                           next_value		                        *)
(*                                                                      *)
(************************************************************************)

procedure next_value(
      value	: integer;
  var ac_set	: access_set);

var
  index : access_converted_set_index;
  duplicate : boolean;
  temp_half : halfword;

begin
  duplicate := FALSE;
  with ac_set do
    if size <= MAX_CONVERTED_ACCESS_SET_SIZE
    then
      begin
        mutil.save_word_in_halfword(value, temp_half);
	for index := 0 to size - 1 do
	  if not duplicate
	  then duplicate := temp_half = set_data[index];
	if not duplicate
	then
	  begin
            index := size;
            set_data[index] := temp_half;      
            size := size + 1
	  end
      end
end (* next_value *);



(*********************  mud_entry_updater  ******************************)
(*                                                                      *)
(*                           next_origin	                        *)
(*                                                                      *)
(************************************************************************)

procedure next_origin(
      access_entry	: access_entry_description;
  var access_origin	: access_origin_description);

var
  temp_word : integer;
  origin_index : in_place_origin_index;

begin
  with access_entry, access_origin do
    begin
      local := FALSE;
      origin_op := [];
      if exception
      then origin_op := origin_op or [APE_NOT];
      if in_place_origin
      then
        begin
          local := TRUE;
          for origin_index := 0 to (origin.size - 1) do
            with origin.list[origin_index] do
	      begin
		temp_word := value;
	        if not host_flag
	        then mutil.set_bit(NODE_FLAG_BIT, temp_word);
                next_value(temp_word, local_set_data)
	      end (* with origin.list *)
        end (* if in_place_origin *)
(* copy global origin *)
      else global_origin := class_no
    end (* with access_origin *)
end (* next_origin *);



(*********************  mud_entry_updater  ******************************)
(*                                                                      *)
(*                           next_home		                        *)
(*                                                                      *)
(************************************************************************)

procedure next_home(
      value	: integer;
  var ac_set	: access_set;
  var home_type	: boolean);

begin
  home_type := TRUE;
  next_value(value, ac_set)
end (* next_home *);



(*********************  mud_entry_updater  ******************************)
(*                                                                      *)
(*                           next_destination	                        *)
(*                                                                      *)
(************************************************************************)

procedure next_destination(
      destination	: destination_entry;
  var access_destination: access_destination_description);

begin
  with destination, access_destination do
    if group_flag
    then
      begin
        if home_flag
        then next_home(value, home_destination_global_set, home_destination)
        else non_home_destination := TRUE;
        if exception
        then next_value(value, not_destination_global_set)
(* add all home groups to destination *)
        else next_value(value, destination_global_set)
      end (* if group_flag *)
    else
      begin
	if home_flag
        then next_home(value, home_destination_local_set, home_destination)
	else non_home_destination := TRUE;
        if exception
        then next_value(value, not_destination_local_set)
	else next_value(value, destination_local_set)
      end (* else group_flag *)
end (* next_destination *);



(*********************  mud_entry_updater  ******************************)
(*                                                                      *)
(*                           copy_origin_spec	                        *)
(*                                                                      *)
(************************************************************************)

procedure copy_origin_spec(
      ac_origin		: access_origin_description;
  var next_offset	: ap_definition_size;
  var ap_index		: mud_access_profile_description_index;
  var ap_profile	: mud_access_profile_description);

var
  temp_word : integer;
  ch1,
  ch2 : char;
  oper : ape_operators;

begin
  with ac_origin do
    begin
      for oper := FIRST_APE_OPER to LAST_APE_OPER do
        if oper in origin_op
        then
	  begin
	    ap_profile[ap_index] := char_of_ap_oper(oper);
            ap_profile[ap_index + 1] := chr(1);
            ap_index := ap_index + 2
          end;
      if local
      then
	begin
	  temp_word := word_of_ap_token(
	    APE_LOCAL, chr(2 * local_set_data.size), chr(next_offset));
	  next_offset := next_offset + (2 * local_set_data.size)
	end (* if local *)
      else
	begin
	  mutil.save_word_in_two_chars(global_origin, ch1, ch2);
	  temp_word := word_of_ap_token(
	    APE_CLASS, ch1, ch2)
	end (* else global origin *);
      mutil.save_word_in_characters(temp_word,
	ap_profile[ap_index], ap_profile[ap_index + 1],
	ap_profile[ap_index + 2], ap_profile[ap_index + 3]);
      ap_index := ap_index + AP_ORIGIN_MINIMUM
    end (* with ac_origin *)
end (* copy_origin_spec *);
"
	Convert ACCESS_SET to MUD_ACCESS_PROFILE_DESCRIPTION
"



(*********************  mud_entry_updater  ******************************)
(*                                                                      *)
(*                           do_copy_global 	                     	*)
(*                                                                      *)
(************************************************************************)


procedure do_copy_global(
      global_data	: halfword;
  var ap_ch1		: char;
  var ap_ch2		: char;
  var ap_ch3		: char;
  var ap_ch4		: char);

var
  ch1,
  ch2 : char;
  temp_word : integer;

begin
(* save token flag and data *)
  mutil.save_halfword_in_characters(global_data, ch1, ch2);
  temp_word := word_of_ap_token(APE_GROUP, ch1, ch2);
  mutil.save_word_in_characters(temp_word, ap_ch1, ap_ch2, ap_ch3, ap_ch4)
end (* do_copy_global *);


(*********************  mud_entry_updater  ******************************)
(*                                                                      *)
(*                           copy_global 	                     	*)
(*                                                                      *)
(************************************************************************)


procedure copy_global(
      global_data	: halfword;
  var ap_index		: mud_access_profile_description_index;
  var ap_profile	: mud_access_profile_description);

begin
(* save token flag and data *)
  do_copy_global(global_data, ap_profile[ap_index], ap_profile[ap_index + 1],
    ap_profile[ap_index + 2], ap_profile[ap_index + 3]);
  ap_index := ap_index + AP_DESTINATION_MINIMUM
end (* copy_global *);



(*********************  mud_entry_updater  ******************************)
(*                                                                      *)
(*                           copy_not_global 	                     	*)
(*                                                                      *)
(************************************************************************)


procedure copy_not_global(
      global_data	: halfword;
  var ap_index		: mud_access_profile_description_index;
  var ap_profile	: mud_access_profile_description);

begin
(* save token flag and data *)
  ap_profile[ap_index] := char_of_ap_oper(APE_NOT);
  ap_profile[ap_index + 1] := chr(1);
  ap_index := ap_index + 2;
  do_copy_global(global_data, ap_profile[ap_index], ap_profile[ap_index + 1],
    ap_profile[ap_index + 2], ap_profile[ap_index + 3]);
  ap_index := ap_index + AP_DESTINATION_MINIMUM
end (* copy_not_global *);



(*********************  mud_entry_updater  ******************************)
(*                                                                      *)
(*                           copy_union_spec                      	*)
(*                                                                      *)
(************************************************************************)

procedure copy_union_spec(
      local_set     	: boolean;
      count         	: access_converted_set_index;
  var ap_index		: mud_access_profile_description_index;
  var ap_profile	: mud_access_profile_description);

var
  union_count : access_converted_set_index;

begin
  if local_set
  then union_count := count + 1
  else union_count := count;
  if union_count > 1
  then
    begin
      ap_profile[ap_index] := char_of_ap_oper(APE_UNION);
      ap_profile[ap_index + 1] := chr(union_count);
      ap_index := ap_index + 2
    end (* union_count > 1 *)
end (* copy_union_spec *);



(*********************  mud_entry_updater  ******************************)
(*                                                                      *)
(*                           copy_non_home_spec                      	*)
(*                                                                      *)
(************************************************************************)

procedure copy_non_home_spec(
      not_global_set	: access_set;
      not_local_set_size: access_converted_set_index;
      global_set	: access_set;
      local_set_size	: access_converted_set_index;
  var next_offset	: mud_access_profile_description_index;
  var ap_index		: mud_access_profile_description_index;
  var ap_profile	: mud_access_profile_description);

var
  count,
  temp_word : integer;

begin
  if ((not_global_set.size > 0) and
   ((global_set.size > 0) or (local_set_size > 0))) or
    ((not_local_set_size > 0) and
    ((global_set.size > 0) or (local_set_size > 0)))
(* union of negative set and positive set, union count 2, neg and pos *)
  then copy_union_spec(FALSE, 2, ap_index, ap_profile);
(* save token flag and data *)
  if not_global_set.size > 0
  then
    begin
      copy_union_spec((not_local_set_size > 0),
	not_global_set.size, ap_index, ap_profile);
      for count := 0 to (not_global_set.size -  1) do
        copy_not_global(not_global_set.set_data[count], ap_index, ap_profile)
    end;
  if not_local_set_size > 0
  then
    begin
      ap_profile[ap_index] := char_of_ap_oper(APE_NOT);
      ap_profile[ap_index + 1] := chr(1);
      ap_index := ap_index + 2;
      temp_word := word_of_ap_token(APE_LOCAL,
	chr(2 * not_local_set_size), chr(next_offset));
      next_offset := next_offset + (2 * not_local_set_size);
      mutil.save_word_in_characters(temp_word, ap_profile[ap_index],
	ap_profile[ap_index + 1], ap_profile[ap_index + 2],
	ap_profile[ap_index + 3]);
      ap_index := ap_index + AP_DESTINATION_MINIMUM
    end (* not_local_set_size > 0 *);
  if global_set.size > 0
  then
    begin
(* include union of local set, if any, with global set *)
      copy_union_spec((local_set_size>0), global_set.size, ap_index,ap_profile);
      for count := 0 to (global_set.size - 1) do
        copy_global(global_set.set_data[count], ap_index, ap_profile)
    end;
  if local_set_size > 0
  then
    begin
      temp_word := word_of_ap_token(APE_LOCAL,
	chr(2 * local_set_size), chr(next_offset));
      next_offset := next_offset + (2 * local_set_size);
      mutil.save_word_in_characters(temp_word, ap_profile[ap_index],
	ap_profile[ap_index + 1], ap_profile[ap_index + 2],
	ap_profile[ap_index + 3]);
      ap_index := ap_index + AP_DESTINATION_MINIMUM
    end (* local_set_size > 0 *)
end (* copy_non_home_spec *);



(*********************  mud_entry_updater  ******************************)
(*                                                                      *)
(*                           copy_home_spec                      	*)
(*                                                                      *)
(************************************************************************)

procedure copy_home_spec(
      global_set	: access_set;
      local_set_size	: access_converted_set_index;
      next_offset	: mud_access_profile_description_index;
  var ap_index		: mud_access_profile_description_index;
  var ap_profile	: mud_access_profile_description);

var
  count,
  temp_word : integer;

begin
  copy_union_spec((local_set_size > 0), global_set.size, ap_index, ap_profile);
  if global_set.size > 0
  then
    for count := 0 to (global_set.size - 1) do
      copy_global(global_set.set_data[count], ap_index, ap_profile);
  if local_set_size > 0
  then
    begin
      temp_word := word_of_ap_token(APE_LOCAL,
	chr(2 * local_set_size), chr(next_offset));
      mutil.save_word_in_characters(temp_word, ap_profile[ap_index],
	ap_profile[ap_index + 1], ap_profile[ap_index + 2],
	ap_profile[ap_index + 3]);
      ap_index := ap_index + AP_DESTINATION_MINIMUM
    end (* local_set > 0 *)
end (* copy_home_spec *);



(**************************  mud_entry_updater  **** **********************)
(*									*)
(*			      sort_ape_set				*)
(*									*)
(************************************************************************)

procedure sort_ape_set(
  var list_to_sort : access_set);

var
  temp : halfword;
  switch_index,
  scan_index,
  index : access_converted_set_index;

begin
  for scan_index := 0 to list_to_sort.size - 2 do
    begin
      switch_index := scan_index;
      for index := scan_index + 1 to list_to_sort.size - 1 do
	if mutil.value_of_halfword(list_to_sort.set_data[index]) <
	  mutil.value_of_halfword(list_to_sort.set_data[switch_index])
	then switch_index := index;
      temp := list_to_sort.set_data[scan_index];
      list_to_sort.set_data[scan_index] :=
	list_to_sort.set_data[switch_index];
      list_to_sort.set_data[switch_index] := temp
    end (* for *)
end (* sort_ape_set *);



(*********************  mud_entry_updater  ******************************)
(*                                                                      *)
(*                           copy_local_set	                      	*)
(*                                                                      *)
(************************************************************************)

procedure copy_local_set(
  var ac_local_set	: access_set;
  var ap_index		: mud_access_profile_description_index;
  var ap_profile	: mud_access_profile_description);

var
  count : access_converted_set_index;

begin
  if ac_local_set.size > 1
  then sort_ape_set(ac_local_set);
  with ac_local_set do
    for count := 0 to size - 1 do
      begin
	mutil.save_halfword_in_characters(set_data[count],
	  ap_profile[ap_index], ap_profile[ap_index +1]);
	ap_index := ap_index + 2
      end (* for count *)
end (* copy_local_set *);



(*********************  mud_entry_updater  ******************************)
(*									*)
(*			   pack_profile					*)
(*									*)
(*	Format access profile information for new MUD.			*)
(*									*)
(************************************************************************)

procedure pack_profile(
      access_profile		: access_profile_description;
  var mud_access_profile	: mud_access_profile_description);

var
  index : access_entry_index;
  next_offset : ap_definition_size;
  oper : ape_operators;
  ap_index : mud_access_profile_description_index;
  dest_index : destination_index;
  ap_size : integer;
  access_origin : access_origin_description;
  access_destination : access_destination_description;

begin
(* copy access profile, init ap_index and ap_control *)
  cud_utility.clear_mud_access_profile(mud_access_profile);
  ap_index := 0; last_status := CUD_ENTRY_OK;
  with access_profile do
    for index := 0 to count - 1 do
      begin
(* clear access definitions *)
        access_origin.local_set_data.size := 0;
        clear_access_destination(access_destination);
(* convert in-place-origin, if defined *)
        next_origin(entries[index], access_origin);
(* convert destinations *)
        for dest_index := 0 to (entries[index].destination.size - 1) do
	  next_destination(entries[index].destination.list[dest_index],
  	    access_destination);
(* store APE type *)
        mud_access_profile[APE_TYPE_OFFSET + ap_index] :=
	   char_of_ape_type(APE_BASIC);
(* store origin offset *)
        next_offset := APE_ORIGIN_START;
        mud_access_profile[APE_ORIGIN_OFFSET + ap_index] := chr(next_offset);
        next_offset := next_offset + AP_ORIGIN_MINIMUM;
	for oper := FIRST_APE_OPER to LAST_APE_OPER do
	  if oper in access_origin.origin_op
	  then next_offset := next_offset + 2;
        if access_destination.non_home_destination
        then
(* destination offset *)
          begin
	    mud_access_profile[APE_DEST_OFFSET + ap_index] := chr(next_offset);
	    with access_destination do
	      begin
	        if destination_local_set.size > 0
	        then next_offset := next_offset + AP_DESTINATION_MINIMUM;
(* add up union operators *)
		(* add a union oper count if *)
		(* union of local and global *)
		if ((destination_global_set.size > 0) and
		  (destination_local_set.size > 0)) or
		  (* or union of not global with local or with global *)
		  (((destination_local_set.size > 0) or
		  (destination_global_set.size > 0)) and
		  (not_destination_global_set.size > 0)) or
		  (* or more than one global *)
		  (destination_global_set.size > 1) or
		  (* or more than one not global *)
		  (not_destination_global_set.size > 1) or
		  (* or not global and not local *)
		  ((not_destination_global_set.size > 0) and
		  (not_destination_local_set.size > 0)) or
                  (* or union of not local with local or with global *)
                  (((destination_local_set.size > 0) or
                  (destination_global_set.size > 0)) and
                  (not_destination_local_set.size > 0))
		then next_offset := next_offset + 2;
		(* if union of not global with local or global *)
		if (not_destination_global_set.size > 0) and
		  ((destination_global_set.size > 0) or
		  (destination_local_set.size > 0))
		then
		  begin
		    (* add if global and local or more than one global *)
		    if ((destination_global_set.size > 0) and
		      (destination_local_set.size > 0)) or
		      (destination_global_set.size > 1)
		    then next_offset := next_offset + 2;
		    (* add if more than one not global *)
		    (* or not global and not local *)
		    if (not_destination_global_set.size > 1) or
		      ((not_destination_global_set.size > 0) and
		      (not_destination_local_set.size > 0))
		    then next_offset := next_offset + 2
		  end;
                if not_destination_local_set.size > 0
                then next_offset := next_offset + 6;
	        next_offset := (4*destination_global_set.size) +
	          (6*not_destination_global_set.size) + next_offset 
	      end
	  end
        else mud_access_profile[APE_DEST_OFFSET + ap_index] :=chr(next_offset);
(* home offset *)
        if access_destination.home_destination
        then
	  begin
            mud_access_profile[APE_HOME_OFFSET + ap_index] := chr(next_offset);
	    with access_destination do
	      begin
	        if ((home_destination_local_set.size > 0) and
		  (home_destination_global_set.size > 0)) or
		   (home_destination_global_set.size > 1)
		then next_offset := next_offset + 2;
		if home_destination_local_set.size > 0
		then next_offset := next_offset + AP_ORIGIN_MINIMUM;
	        next_offset := (4 * home_destination_global_set.size) +
		  next_offset
	      end
	  end
        else mud_access_profile[APE_HOME_OFFSET + ap_index] := chr(0);
(* local offset *)
        if (access_origin.local or 
          (access_destination.destination_local_set.size <> 0)) or
          (access_destination.not_destination_local_set.size <> 0) or
          (access_destination.home_destination_local_set.size <> 0)
        then mud_access_profile[APE_LOCAL_OFFSET + ap_index] :=
	    chr(next_offset)
        else mud_access_profile[APE_LOCAL_OFFSET + ap_index] := chr(0);
	ap_size := next_offset +
          2 * access_origin.local_set_data.size +
          2 * access_destination.home_destination_local_set.size;
	if access_destination.non_home_destination
	then
          begin
            ap_size :=
    	      2 * access_destination.destination_local_set.size + ap_size;
            ap_size :=
              2 * access_destination.not_destination_local_set.size + ap_size;
          end (* non_home_destination *);
	mud_access_profile[APE_SIZE_OFFSET + ap_index] := chr(ap_size);
(* store APE control bits *)
        mutil.save_word_in_two_chars(entries[index].access_control,
          mud_access_profile[APE_CONTROL_START + ap_index],
	  mud_access_profile[APE_CONTROL_START + ap_index + 1]);
        ap_index := ap_index + APE_ORIGIN_START;
        copy_origin_spec(access_origin, next_offset, ap_index,
          mud_access_profile);
        with access_destination do
          begin
	    if non_home_destination
	    then copy_non_home_spec(not_destination_global_set,
	      not_destination_local_set.size, destination_global_set,
	      destination_local_set.size, next_offset, ap_index,
	      mud_access_profile);
            copy_home_spec(home_destination_global_set,
	      home_destination_local_set.size,
	      next_offset, ap_index, mud_access_profile)
	  end (* with access_destination *);
       
	copy_local_set(access_origin.local_set_data,
          ap_index, mud_access_profile);
	if access_destination.non_home_destination
	then
	  begin
            if access_destination.not_destination_local_set.size > 0
            then copy_local_set(access_destination.not_destination_local_set,
              ap_index, mud_access_profile);
	    if access_destination.destination_local_set.size > 0
            then copy_local_set(access_destination.destination_local_set,
              ap_index, mud_access_profile);
	  end;
        copy_local_set(access_destination.home_destination_local_set,
          ap_index, mud_access_profile)
      end (* with access_profile *)
end (* pack_profile *);
$if overflow_cud_entries



(*********************  mud_entry_updater  ******************************)
(*									*)
(*			  write_overflowing_block			*)
(*									*)
(*	Called by MAKE_OVERFLOW_BLOCK and FIND_ROOM_FOR_ENTRY.		*)
(*									*)
(************************************************************************)

procedure write_overflowing_block(
  var change_size	: mud_data_size (* if not adding new entry *);
  var change_offset	: mud_data_index (* if not adding new entry *);
  var entry_info	: mud_entry_descriptor;
$ifnone CONVERT_TO_43   var change_header	: mud_change_header;
   var buffer		: univ cud_data_block);

begin
$ifnone convert_to_43
  set_up_mud_change_header(entry_info.user.block, OVERFLOW_OFFSET,
    (change_offset - OVERFLOW_OFFSET) + change_size, change_header);
$endif convert_to_43
  update_block(entry_info,
$ifnone convert_to_43     change_header, TRUE,
    buffer)
end (* write_overflowing_block *);



(*********************  mud_entry_updater  ******************************)
(*									*)
(*			   make_overflow_block				*)
(*									*)
(*     Make the existing block into an overflow block and write it out.	*)
(*	Only called from FIND_ROOM_FOR_ENTRY routine.			*)
(*									*)
(************************************************************************)

procedure make_overflow_block(
      adding_new_entry	: boolean (* FALSE if expanding current entry *);
  var change_size	: mud_data_size (* if not adding new entry *);
  var change_offset	: mud_data_index (* if not adding new entry *);
  var entry_info	: mud_entry_descriptor;
  var buffer		: univ cud_data_block
$if CONVERT_TO_43 );
$ifnone CONVERT_TO_43
;
  var change_header	: mud_change_header);
$endif CONVERT_TO_43

var
  mud_head : mud_block_header;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+	*)
$ifnone CONVERT_TO_43
  data_in_block : mud_data_size;
$if changes_to_oper_log   change_being_made : cud_change_indicator;
$endif CONVERT_TO_43

begin
  if (entry_info.user.block = second_hash(entry_info.user.name)) or
    (entry_info.user.block > MAXIMUM_NORMAL_CUD_BLOCK)
  then last_status := CUD_ENTRY_DOES_NOT_FIT
  else
    begin
      cud_utility.unpack_mud_header(buffer.data.mud_block.data, mud_head);
$ifnone CONVERT_TO_43
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+	*)
$if changes_to_oper_log
      change_being_made := cud_change_type (* save original change type *);
      cud_change_type := CREATE_OVERFLOW_BLOCK;
$endif changes_to_oper_log
$endif CONVERT_TO_43
      mud_head.overflow := mud_head.overflow or [BLOCK_HAS_OVERFLOWS];
      cud_utility.pack_mud_header(mud_head, buffer.data.mud_block.data);
      if adding_new_entry
      then
        begin (* adding new entry, just write out new overflow word *)
$ifnone CONVERT_TO_43
	  set_up_mud_change_header(entry_info.user.block, OVERFLOW_OFFSET,
	    OVERFLOW_BYTES, change_header);
$endif CONVERT_TO_43
	  update_block(entry_info,
$ifnone CONVERT_TO_43      change_header, TRUE,
            buffer)
	end (* adding new entry, just write out new overflow word *)
      else (* write out entire block, since entry is being moved *)
        write_overflowing_block(change_size, change_offset, entry_info,
$ifnone CONVERT_TO_43       change_header,
	buffer);
$ifnone CONVERT_TO_43
$if changes_to_oper_log
      cud_change_type := change_being_made (* restore original change type *)
$endif changes_to_oper_log
$endif CONVERT_TO_43
    end (* update first hash block *)
end (* make_overflow_block *);
$endif OVERFLOW_CUD_ENTRIES



(*********************  mud_entry_updater  ******************************)
(*									*)
(*			    entry_fits					*)
(*									*)
(*	Return TRUE if NUD and MUD data fits into the current block.    *)
(*									*)
(************************************************************************)

function entry_fits(
      entry_info	: mud_entry_descriptor) : boolean;

begin
  entry_fits :=
    ((MAXIMUM_MUD_DATA - (2*MAXIMUM_BYTES_IN_WORD) - entry_info.mud_pointer) >
      entry_info.size_of_mud_entry) and
    ((MAXIMUM_NUD_DATA - (entry_info.nud_pointer - NUD_DATA_ENTRY_OFFSET)) >
      entry_info.size_of_nud_entry)
end (* entry_fits *);



(*********************  mud_entry_updater  ******************************)
(*									*)
(*			   find_room_for_entry				*)
(*									*)
(*      Find room for the entry described in entry_info.  Called by	*)
(*	ADD_NEW_ENTRY and MOVE_ENTRY.					*)
(*									*)
(************************************************************************)

procedure find_room_for_entry(
      adding_new_entry	: boolean (* FALSE if expanding current entry *);
  var change_size	: mud_data_size (* if not adding new entry *);
  var change_offset	: mud_data_index (* if not adding new entry *);
$ifnone CONVERT_TO_43
$if OVERFLOW_CUD_ENTRIES   var change_header 	: mud_change_header;
$endif CONVERT_TO_43
  var buffer		: univ cud_data_block;
  var entry_info	: mud_entry_descriptor);

var
  room_found : boolean;

begin
  room_found := FALSE;
  repeat
(* if find_end_of_entries is successful:				*)
(*	last_status = CUD_ENTRY_NOT_FOUND or CUD_ENTRY_OVERFLOW_FOUND	*)
    cud_utility.find_end_of_entries(buffer.data, entry_info.user.block,
      last_status, entry_info.mud_pointer, entry_info.nud_pointer);
    if last_status = CUD_FORMAT_ERROR
    then cud_utility.set_format_error(entry_info.user.block,
      entry_info.mud_pointer, last_status)
    else
      if ((last_status = CUD_ENTRY_NOT_FOUND)
$if overflow_cud_entries 	or (last_status = CUD_ENTRY_OVERFLOW_FOUND)
	) and entry_fits(entry_info)
      then
	begin (* room for new entry found *)
	  room_found := TRUE;
	  last_status := CUD_ENTRY_OK
	end (* room for new entry found *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone OVERFLOW_CUD_ENTRIES
    if last_status = CUD_ENTRY_NOT_FOUND
    then last_status := CUD_ENTRY_DOES_NOT_FIT;
$endif OVERFLOW_CUD_ENTRIES
$if OVERFLOW_CUD_ENTRIES
    if last_status = CUD_ENTRY_NOT_FOUND
    then
      begin
	last_status := CUD_ENTRY_OK;
	make_overflow_block(adding_new_entry, change_size, change_offset,
	  entry_info, buffer
$ifnone CONVERT_TO_43 	  , change_header
)
      end
    else
      if last_status = CUD_ENTRY_OVERFLOW_FOUND
      then
        begin
	  last_status := CUD_ENTRY_OK (* look 4 room in overflow block next *);
	  if not adding_new_entry
	  then (* write out block that entry was removed from *)
	    write_overflowing_block(change_size, change_offset, entry_info,
$ifnone convert_to_43 	    change_header,
	    buffer)
	end;
    if not room_found and (last_status = CUD_ENTRY_OK)
    then
$if CONVERT_TO_43
    if CONVERT_OVERFLOW_BLOCKS <= 0
    then last_status := CUD_ENTRY_DOES_NOT_FIT
    else
$endif CONVERT_TO_43
      begin
$ifnone CONVERT_TO_43 	unlock_block(entry_info);
	entry_info.user.block := second_hash(entry_info.user.name);
$ifnone CONVERT_TO_43
	change_header.block := entry_info.user.block;
	read_block(TRUE, entry_info, buffer)
$endif CONVERT_TO_43
$if CONVERT_TO_43 	read_cud_block(entry_info.user.block, buffer)
      end (* last_status = CUD_ENTRY_OK *)
$endif OVERFLOW_CUD_ENTRIES
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+      *)
  until (last_status <> CUD_ENTRY_OK) or room_found
end (* find_room_for_entry *);



(*********************  mud_entry_updater  ******************************)
(*									*)
(*			      add_new_entry				*)
(*									*)
(*      Set up new_entry in the appropriate CUD block; used by		*)
(*	NEW_CUD_ENTRY and RENAME routines (restore_old_name and		*)
(*	rename_cud_entry).						*)
(*									*)
(************************************************************************)

procedure add_new_entry(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone CONVERT_TO_43
$if REUSE_UUNS       bit17_flag	: boolean;
$endif CONVERT_TO_43
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  var entry_info	: mud_entry_descriptor;
  var mud_entry	: mud_user_entry;
  var nud_entry	: nud_user_entry);

var
  buffer : cud_disk_block;
$ifnone CONVERT_TO_43   change_header : mud_change_header;
  dummy_change_size : integer;
  dummy_change_offset : mud_data_index;
  result : cud_operation_result;
  mud_access_profile : mud_access_profile_description;

begin
$if CONVERT_TO_43
  last_status := CUD_ENTRY_OK;
  locate_name(buffer, entry_info);
  if last_status = CUD_ENTRY_NOT_FOUND
  then
    begin
      last_status := CUD_ENTRY_OK;
$endif CONVERT_TO_43
      pack_profile(mud_entry.mud_access_profile, mud_access_profile);
      if last_status = CUD_ENTRY_OK
      then
        begin
          set_entry_sizes(mud_entry.entry_type, entry_info);
          entry_info.size_of_mud_entry :=
	    packed_entry_size(entry_info, mud_access_profile);
	  entry_info.size_of_nud_entry := NUD_MINIMUM_ENTRY_SIZE;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if prevent_duplicate_passwords
	  if PREVIOUS_PASSWORD_STORED in nud_entry.nud_options
	  then entry_info.size_of_nud_entry := entry_info.size_of_nud_entry +
	    MAXIMUM_BYTES_IN_WORD;
$endif prevent_duplicate_passwords
$ifnone CONVERT_TO_43
      read_block(TRUE, entry_info, buffer);
      if last_status = CUD_ENTRY_OK
      then
$endif CONVERT_TO_43
	find_room_for_entry(TRUE, dummy_change_size, dummy_change_offset,
$ifnone CONVERT_TO_43
$if OVERFLOW_CUD_ENTRIES 	  change_header,
$endif CONVERT_TO_43
	  buffer, entry_info)
         end
       else cud_utility.set_format_error(entry_info.user.block,
	 mud_profile_location(entry_info), last_status)
$if CONVERT_TO_43
    end
  else 
    if last_status = CUD_ENTRY_OK
    then last_status := CUD_NAME_TAKEN
$endif CONVERT_TO_43
;
$ifnone CONVERT_TO_43
$ifnone disk_maintenance_code
(*      Assign new parameters (GAN and/or UUN), if needed,		*)
(*	for the cud entry.						*)
(*	If used by NVDM - GAN and UUN must be assigned by user.		*)

  if last_status = CUD_ENTRY_OK
  then
    begin
      param_manager.assign_user_numbers(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if REUSE_UUNS         bit17_flag,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
        nud_entry.gan, mud_entry.uun, result);
      set_status_from_cud_io(result)
    end (* last_status = CUD_ENTRY_OK *);
$endif disk_maintenance_code
$endif CONVERT_TO_43
  if last_status = CUD_ENTRY_OK
  then
    begin
      if not include_district
      then nud_entry.district := 0;
      pack_cud_entry(entry_info, mud_entry, nud_entry, mud_access_profile,
        buffer.data);
      if last_status = CUD_ENTRY_OK
      then
$ifnone CONVERT_TO_43
      set_up_mud_change_header(entry_info.user.block, entry_info.mud_pointer,
        entry_info.size_of_mud_entry + MAXIMUM_BYTES_IN_WORD, change_header);
      if last_status = CUD_ENTRY_OK
      then
$endif CONVERT_TO_43
      update_block(entry_info,
$ifnone CONVERT_TO_43      change_header, TRUE,
	buffer)
    end (* last_status = CUD_ENTRY_OK *)
end (* add_new_entry *);



(**********************  mud_entry_updater  *****************************)
(*									*)
(*			     move_entry					*)
(*									*)
(*	Move the entry to the end of the block if there is room;	*)
(*	update entry_info.  Before this routine is called:		*)
(*		entry_info.size_of_mud_entry should be old entry size	*)
(*		entry should be unpacked into mud_entry and nud_entry	*)
(*									*)
(************************************************************************)

procedure move_entry(
      new_mud_entry_size: mud_data_size;
      packed_profile	: mud_access_profile_description;
      mud_entry		: mud_user_entry;
      nud_entry		: nud_user_entry;
$if OVERFLOW_CUD_ENTRIES   var change_header 	: mud_change_header;
  var entry_info	: mud_entry_descriptor;
  var buffer		: univ cud_disk_block;
  var change_offset	: mud_data_index;
  var change_size	: mud_data_size);

var
  old_mud_entry_size : mud_data_size;
  original_location : mud_data_index;
$if OVERFLOW_CUD_ENTRIES   original_block : cud_block_index;

begin
$if OVERFLOW_CUD_ENTRIES   original_block := entry_info.user.block;
  original_location := entry_info.mud_pointer;
  old_mud_entry_size := entry_info.size_of_mud_entry;
  remove_entry(entry_info, buffer.data, change_size);
  if last_status = CUD_ENTRY_OK
  then
    begin
      entry_info.size_of_mud_entry := new_mud_entry_size;
      find_room_for_entry(FALSE, change_size, original_location,
$ifnot convert_to_43
$if OVERFLOW_CUD_ENTRIES       change_header,
$endif convert_to_43
	buffer, entry_info);
      if last_status = CUD_ENTRY_OK
      then
	begin
	  pack_cud_entry(entry_info, mud_entry, nud_entry, packed_profile,
	    buffer.data);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if OVERFLOW_CUD_ENTRIES
	  if original_block <> entry_info.user.block
	  then
	    begin (* entry is in an overflow block *)
	      change_offset := entry_info.mud_pointer;
	      change_size := entry_info.size_of_mud_entry +
	        MAXIMUM_BYTES_IN_WORD
	    end (* entry is in an overflow block *)
	  else
	    begin (* entry is NOT in overflow block *)
$endif OVERFLOW_CUD_ENTRIES
	      change_offset := original_location;
	      if new_mud_entry_size > old_mud_entry_size
	      then change_size := change_size +
	        (new_mud_entry_size - old_mud_entry_size)
$if OVERFLOW_CUD_ENTRIES
	    end (* entry is NOT in overflow block *)
$endif OVERFLOW_CUD_ENTRIES
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
        end (* last_status = CUD_ENTRY_OK *)
    end (* last_status = CUD_ENTRY_OK *)
end (* move_entry *);
$ifnot convert_to_43



(**********************  mud_entry_updater  *****************************)
(*									*)
(*			   save_access_profile				*)
(*									*)
(*      Save new profile in data in the entry described by entry_info;	*)
(*	set change_offset to the beginning of the change and		*)
(*	change_size to the size of the change; if the old and new	*)
(*	profile are the same size, store the new one over the old one;	*)
(*	otherwise, move the entry to the end of the block if there is	*)
(*	room, or to an overflow block if possible; update entry_info	*)
(*	if the entry is moved.  Called by UPDATE_MUD_OPTIONS and	*)
(*	UPDATE_PROFILE routines.					*)
(*									*)
(************************************************************************)

procedure save_access_profile(
  var mud_entry		: mud_user_entry;
  var nud_entry		: nud_user_entry;
$if OVERFLOW_CUD_ENTRIES   var change_header 	: mud_change_header;
  var entry_info	: mud_entry_descriptor;
  var buffer		: cud_disk_block;
  var change_offset	: mud_data_index;
  var change_size	: mud_data_size);

var
  new_profile : access_profile_description;
  new_packed_profile : mud_access_profile_description;
  new_packed_profile_size : mud_data_size;
  new_mud_entry_size : mud_data_size;
  old_packed_profile :  mud_access_profile_description;

begin
  new_profile := mud_entry.mud_access_profile;
  pack_profile(mud_entry.mud_access_profile, new_packed_profile);
  if last_status <> CUD_ENTRY_OK
  then cud_utility.set_format_error(entry_info.user.block,
    mud_profile_location(entry_info), last_status)
  else
    begin
      new_packed_profile_size :=
        packed_access_profile_size(new_packed_profile);
      new_mud_entry_size := packed_entry_size(entry_info, new_packed_profile);
      unpack_cud_entry(entry_info, buffer.data, mud_entry, nud_entry);
      if last_status = CUD_ENTRY_OK
      then
        begin
	  pack_profile(mud_entry.mud_access_profile, old_packed_profile);
	  if last_status <> CUD_ENTRY_OK
	  then cud_utility.set_format_error(entry_info.user.block,
	    mud_profile_location(entry_info), last_status)
	  else
	    if new_packed_profile_size =
	      packed_access_profile_size(old_packed_profile)
	    then
	      begin (* entries are same size, just store A. P. *)
		store_access_profile(new_packed_profile, entry_info,
		  buffer.data);
		change_offset := mud_profile_location(entry_info);
		change_size := new_packed_profile_size
	      end (* entries are same size, just store A. P. *)
	    else
	      begin (* old and new entries differ in size *)
		mud_entry.mud_access_profile := new_profile;
		move_entry(new_mud_entry_size, new_packed_profile, mud_entry,
		  nud_entry,
$if overflow_cud_entries 	    change_header,
		entry_info, buffer, change_offset, change_size);
	      end (* old and new entries differ in size *)
        end
    end
end (* save_access_profile *);



(*********************  mud_entry_updater  ******************************)
(*									*)
(*			      delete_entry				*)
(*									*)
(*      Delete an entry.						*)
(*									*)
(************************************************************************)

procedure delete_entry(
  var entry_info	: mud_entry_descriptor);

var
  buffer : cud_disk_block;
  change_header : mud_change_header;
  change_size : mud_data_size;

begin
  entry_info.user := modify_user;
  find_user_entry(TRUE, buffer, entry_info);
  if last_status = CUD_ENTRY_OK
  then
    begin
      remove_entry(entry_info, buffer.data, change_size);
      if last_status = CUD_ENTRY_OK
      then
        begin
          set_up_mud_change_header(entry_info.user.block,
	    entry_info.mud_pointer, change_size, change_header);
          update_block(entry_info, change_header, TRUE, buffer)
        end
    end
end (* delete_entry *);
$endif convert_to_43
!
"
	External Routines
"
$if include_non_dmc


(*********************  mud_entry_updater  ******************************)
(*									*)
(*			format_profile_size				*)
(*									*)
(************************************************************************)

function entry FORMAT_PROFILE_SIZE(
      access_profile		: access_profile_description) : mud_data_size;
var
  mud_access_profile : mud_access_profile_description;

begin
  pack_profile(access_profile, mud_access_profile);
  format_profile_size := packed_access_profile_size(mud_access_profile)
end (* format_profile_size *);


(*********************  mud_entry_updater  ******************************)
(*									*)
(*				hash_number				*)
(*									*)
(*									*)
(************************************************************************)

function entry HASH_NUMBER(
     name	: username_string) : normal_cud_block_index;

begin
  last_status := CUD_ENTRY_OK;
  hash_number := hashed_block(name)
end (* hash_number *);
$if overflow_cud_entries

(*********************  mud_entry_updater  ******************************)
(*									*)
(*				overflow_number				*)
(*									*)
(*									*)
(************************************************************************)

function entry OVERFLOW_NUMBER(
     name	: username_string) : normal_cud_block_index;

begin
  last_status := CUD_ENTRY_OK;
  overflow_number := second_hash(name)
end (* overflow_number *);
$endif overflow_cud_entries


(*********************  mud_entry_updater  ******************************)
(*									*)
(*			profile_host_ok					*)
(*									*)
(*	Return True if APE has entry with hostname ok.			*)
(*									*)
(************************************************************************)

function entry PROFILE_HOST_OK(
    mud_access_profile : mud_access_profile_description) : boolean;

begin
  profile_host_ok := do_profile_host_ok(mud_access_profile)
end (* profile_host_ok *);  


(*********************  mud_entry_updater  ******************************)
(*									*)
(*			profile_user_ok					*)
(*									*)
(*	Return True if APE has entry with username ok.			*)
(*									*)
(************************************************************************)

function entry PROFILE_USER_OK(
    mud_access_profile : mud_access_profile_description) : boolean;

begin
  profile_user_ok := do_profile_user_ok(mud_access_profile)
end (* profile_user_ok *);



(*********************  mud_entry_updater  ******************************)
(*									*)
(*			  check_for_name_in_cud				*)
(*									*)
(*      Set last_status according to whether or not name is in CUD;	*)
(*	use CUD_ENTRY_NOT_FOUND, CUD_NAME_TAKEN, or other error code.	*)
(*	Only used by the CHECk command.					*)
(*									*)
(************************************************************************)

procedure entry CHECK_FOR_NAME_IN_CUD(
      name	: username_string);

var
  entry_info : mud_entry_descriptor;
  buffer : cud_disk_block;

begin
  last_status := CUD_ENTRY_OK;
  entry_info.user.name := name;
  locate_name(buffer, entry_info);
  if last_status = CUD_ENTRY_OK
  then last_status := CUD_NAME_TAKEN
end (* check_for_name_in_cud *);
$endif include_non_dmc
$ifnone disk_maintenance_code



(*********************  mud_entry_updater  ******************************)
(*									*)
(*			      reserve_name				*)
(*									*)
(*	Reserve name for future use; if it already exists, return FALSE.*)
(*	If the name is of the format Gnnnn or GnnnnT<anything>,		*)
(*	where n = a digit, return CUD_ENTRY_ILLEGAL_NAME because of	*)
(*	conflicts with target profile names.				*)
(*									*)
(************************************************************************)

function entry RESERVE_NAME(
      name	: username_string) : boolean;

var
  entry_info : mud_entry_descriptor;
  buffer : cud_disk_block;

begin
  last_status := CUD_ENTRY_OK;
  reserve_name := FALSE;
  entry_info.user.name := name;
  name_access.lock_cud_entry(cud_user, entry_info.user.name, TRUE,
    entry_info.user.name_locked);
  if not entry_info.user.name_locked
  then last_status := CUD_ENTRY_LOCKED
  else
    begin (* name locked successfully *)
      locate_name(buffer, entry_info);
      if last_status = CUD_ENTRY_NOT_FOUND
      then
	begin (* name is not currently being used *)
	  reserve_name := TRUE;
	  new_user := entry_info.user;
	  new_user.packed_name_size := packed_size_of_name(name)
	end (* name is not currently being used *)
      else
	begin (* name is already used *)
          if last_status = CUD_ENTRY_OK
	  then last_status := CUD_NAME_TAKEN;
	  unlock_username(entry_info.user)
	end (* name is already used *)
      end (* name locked successfully *)
end (* reserve_name *);



(*********************  mud_entry_updater  ******************************)
(*									*)
(*			     read_cud_entry				*)
(*									*)
(*      Find and return the mud_entry for name.				*)
(*									*)
(************************************************************************)

procedure entry READ_CUD_ENTRY(
  var mud_entry	: mud_user_entry;
  var nud_entry : nud_user_entry);

var
  buffer : cud_disk_block;
  entry_info : mud_entry_descriptor;

begin
  last_status := CUD_ENTRY_OK;
  entry_info.user.name := mud_entry.name;
  get_name_entry(buffer, entry_info, mud_entry, nud_entry)
end (* read_cud_entry *);



(*********************  mud_entry_updater  ******************************)
(*									*)
(*			  read_small_cud_entry				*)
(*									*)
(*      Find and return cud info for name.				*)
(*									*)
(************************************************************************)

procedure entry READ_SMALL_CUD_ENTRY(
  var cud_entry	: small_cud_entry);

var
  entry_info : mud_entry_descriptor;
  buffer : cud_disk_block;

begin
  last_status := CUD_ENTRY_OK;
  entry_info.user.name := cud_entry.name;
  locate_name(buffer, entry_info);
  if last_status = CUD_ENTRY_OK
  then unpack_small_cud_entry(buffer, entry_info, cud_entry)
end (* read_small_cud_entry *);



(*********************  mud_entry_updater  ******************************)
(*									*)
(*			    modify_cud_entry				*)
(*									*)
(*      Lock the name, then find and return the cud_entry; if found,	*)
(*	leave the name locked, otherwise, unlock it.			*)
(*									*)
(************************************************************************)

procedure entry MODIFY_CUD_ENTRY(
  var mud_entry	: mud_user_entry;
  var nud_entry : nud_user_entry);

var
  modify_entry : mud_entry_descriptor;
  buffer : cud_disk_block;

begin
  last_status := CUD_ENTRY_OK;
  modify_entry.user.name := mud_entry.name;
  name_access.lock_cud_entry(cud_user, modify_entry.user.name, FALSE,
    modify_entry.user.name_locked);
  if modify_entry.user.name_locked
  then
    begin
      get_name_entry(buffer, modify_entry, mud_entry, nud_entry);
      if last_status = CUD_ENTRY_OK
      then modify_user := modify_entry.user (* save for future update *)
      else unlock_username(modify_entry.user)
    end
  else last_status := CUD_ENTRY_LOCKED
end (* modify_cud_entry *);



(*********************  mud_entry_updater  ******************************)
(*									*)
(*			    modify_cud_password				*)
(*									*)
(*      Lock the name, then find it in the CUD; if found,		*)
(*	leave the name locked, otherwise, unlock it; this routine	*)
(*	is used for those processes that never need to have an entire	*)
(*	unpacked mud_user_entry (password_command_level).		*)
(*									*)
(************************************************************************)

procedure entry MODIFY_CUD_PASSWORD(
  var cud_entry	: small_cud_entry);

var
  entry_info : mud_entry_descriptor;
  buffer : cud_disk_block;

begin
  last_status := CUD_ENTRY_OK; entry_info.user.name := cud_entry.name;
  name_access.lock_cud_entry(CUD_USER, entry_info.user.name, FALSE,
    entry_info.user.name_locked);
  if entry_info.user.name_locked
  then
    begin
      locate_name(buffer, entry_info);
      if last_status = CUD_ENTRY_OK
      then
        begin
	  modify_user := entry_info.user (* save for future update *);
	  unpack_small_cud_entry(buffer, entry_info, cud_entry)
	end
      else unlock_username(entry_info.user)
    end
  else last_status := CUD_ENTRY_LOCKED
end (* modify_cud_password *);


(*********************  mud_entry_updater  ******************************)
(*									*)
(*			    abort_cud_change				*)
(*									*)
(*      Unlock names.							*)
(*									*)
(************************************************************************)

procedure entry ABORT_CUD_CHANGE;

begin
  last_status := CUD_ENTRY_OK;
  unlock_username(modify_user);
  unlock_username(new_user)
end (* abort_cud_change *);



(*********************  mud_entry_updater  ******************************)
(*									*)
(*			     do_update_password				*)
(*									*)
(*      Update modify_user's CUD entry with a new password		*)
(*	(modify_mud_entry must have been previously called).		*)
(*									*)
(************************************************************************)

procedure do_update_password(
      new_password	: univ integer;
      new_date		: integer
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if force_password_change
      ;
      update_password_date : boolean
$endif force_password_change
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
);

var
  entry_info : mud_entry_descriptor;
  buffer : cud_disk_block;
  change_header : mud_change_header;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if prevent_duplicate_passwords
  old_cipher : integer;
  mud_options : mud_user_options;
  nud_options : nud_user_options;
$endif prevent_duplicate_passwords

(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

begin
  last_status := CUD_ENTRY_OK;
  entry_info.block_locked := FALSE;
  entry_info.user := modify_user;
  if last_status = CUD_ENTRY_OK
  then find_user_entry(TRUE, buffer, entry_info);
  if last_status = CUD_ENTRY_OK
  then
    begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if prevent_duplicate_passwords
      unpack_mud_cipher(entry_info, buffer.data, old_cipher);
      unpack_mud_options(entry_info, buffer.data, mud_options);
      if NO_PASSWORD_REQUIRED in mud_options
      then old_cipher := NO_PREVIOUS_CIPHER;
      unpack_nud_options(entry_info, buffer.data, nud_options);
      pack_previous_cipher(mud_options, entry_info, old_cipher,
        PREVIOUS_PASSWORD_STORED in nud_options, nud_options, buffer.data);
$endif prevent_duplicate_passwords
      store_cipher(new_password, entry_info, buffer.data);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if force_password_change
      if update_password_date
      then
$endif force_password_change
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      store_password_date(new_date, entry_info, buffer.data);
      set_up_mud_change_header(entry_info.user.block,
        mud_password_location(entry_info), MUD_CIPHER_BYTES, change_header);
      update_block(entry_info, change_header, TRUE, buffer)
    end (* last_status = CUD_ENTRY_OK *);
  unlock_block(entry_info);
  unlock_username(modify_user)
end (* do_update_password *);



(*********************  mud_entry_updater  ******************************)
(*									*)
(*				update_cud_password			*)
(*									*)
(*	Update the cud password; called from password_command_utility,	*)
(*	passchanger and master_command_level.  Only passchanges sets	*)
(*	do_change_date to FALSE.					*)
(*									*)
(*	This routine does not worry about NUD entries overflowing with	*)
(*	previous passwords, since the computation for the size of the	*)
(*	NUD data area uses the minimum MUD entry size, i.e., there	*)
(*	SHOULD be room...						*)
(*									*)
(************************************************************************)

procedure entry UPDATE_CUD_PASSWORD(
      password	: univ integer
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if force_password_change
      ;
      do_change_date    : boolean
$endif force_password_change
(*      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-  *)
);

begin
(*      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-    *)
$if CHANGES_TO_OPER_LOG
$if force_password_change
  if not do_change_date then
    cud_change_type := PASSCHANGER_PASSWORD_CHANGE
  else
$endif force_password_change
  cud_change_type := CHANGE_PASSWORD_CUD_CHANGE;
$endif CHANGES_TO_OPER_LOG
(*      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-    *)
  do_update_password(password, REALTIME
(*      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-  *)
$if force_password_change       , do_change_date 
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	  )
end (* update_cud_password *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if INCLUDE_IRC



(*********************  mud_entry_updater  ******************************)
(*                                                                      *)
(*                              update_irc                              *)
(*                                                                      *)
(*     Update modify_users's CUD entry with new_irc (modify_mud_entry   *)
(*     must have been previously called).                               *)
(*                                                                      *)
(************************************************************************)

procedure entry UPDATE_IRC(
      new_irc   : integer);

var
  entry_info : mud_entry_descriptor;
  buffer : cud_disk_block;
  change_header : mud_change_header;
  mud_entry : mud_user_entry;
  nud_entry : nud_user_entry;
  type_must_change : boolean;
  old_entry_type : mud_entry_type;
  packed_profile : mud_access_profile_description;
  change_offset : mud_data_index;
  change_size : mud_data_size;

begin
  last_status := CUD_ENTRY_OK;
  entry_info.block_locked := FALSE;
  entry_info.user := modify_user;
  find_user_entry(TRUE, buffer, entry_info);
  if last_status = CUD_ENTRY_OK
  then
    begin
      store_change_date(REALTIME, entry_info, buffer.data);
(*      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-    *)
$if CHANGES_TO_OPER_LOG
      cud_change_type := CHANGE_IRC_CUD_CHANGE;
$endif CHANGES_TO_OPER_LOG
(*      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-    *)
(* determine if type of entry must change...NOTE: if entry_type	is	*)
(* greater than EXPIRE_DATE_IRC_ENTRY, the type must NOT change	 	*)
      old_entry_type :=
        mud_entry_type_of_char(buffer.data[entry_info.mud_pointer]);
      type_must_change := FALSE;
      if (old_entry_type = MINIMUM_ENTRY) and (new_irc > 0)
      then type_must_change := TRUE;
      if (old_entry_type = EXPIRE_DATE_IRC_ENTRY) and (new_irc = 0)
      then
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone password_expiration_date_in_cud       type_must_change := TRUE;
$if password_expiration_date_in_cud
        begin (* unpack password expire date to see if type s/be changed *)
	  unpack_expiration_date(entry_info, buffer.data, old_entry_type,
	    mud_entry.password.expire_date);
	  if mud_entry.password.expire_date = 0
	  then type_must_change := TRUE
	end (* unpack password expire date to see if type s/be changed *);
$endif password_expiration_date_in_cud
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      if not type_must_change
      then
        begin (* just store IRC and make change *)
          buffer.data[mud_irc_location(entry_info)] := chr(new_irc);
          set_up_mud_change_header(entry_info.user.block,
            mud_irc_location(entry_info), MUD_IRC_BYTES, change_header);
        end (* just store IRC and make change *)
      else
        begin (* entry must change...recreate it *)
          mud_entry.name := entry_info.user.name;
          unpack_cud_entry(entry_info, buffer.data, mud_entry, nud_entry);
          if new_irc = 0
          then mud_entry.entry_type := MINIMUM_ENTRY
          else
	    begin (* new_irc <> 0 *)
	      mud_entry.entry_type := EXPIRE_DATE_IRC_ENTRY;
	      mud_entry.irc := new_irc
	    end (* new_irc <> 0 *);
	  pack_profile(mud_entry.mud_access_profile, packed_profile);
          set_entry_sizes(mud_entry.entry_type, entry_info);
	  move_entry(packed_entry_size(entry_info, packed_profile),
	    packed_profile, mud_entry, nud_entry,
$if overflow_cud_entries 	    change_header,
	    entry_info, buffer, change_offset, change_size);
	  set_up_mud_change_header(entry_info.user.block, change_offset,
	    change_size, change_header);
        end (* entry must change...recreate it *);
      update_block(entry_info, change_header, TRUE, buffer)
    end (* last_status = CUD_ENTRY_OK *);
  unlock_block(entry_info);
  unlock_username(modify_user)
end (* update_irc *);
$endif INCLUDE_IRC
$if PASSWORD_EXPIRATION_BY_USER
"$if ALLOW_GLOBAL_PASSWORD_EXPIRE"



(*********************  mud_entry_updater  ******************************)
(*                                                                      *)
(*                   update_password_expiration_date                    *)
(*                                                                      *)
(*	Update modify_users's CUD entry to have a password expiration	*)
(*	date of cud_entry.password_date plus validity_period.		*)
(*	(modify_mud_entry must have been previously called).		*)
(*	This procedure is called from PASSWORD_COMMAND_UTILITY		*)
(*	and MASTER_COMMAND_LEVEL.					*)
(*                                                                      *)
(************************************************************************)

procedure entry UPDATE_PASSWORD_EXPIRATION_DATE(
      validity_period	  	: integer;
  var cud_entry			: small_cud_entry);

var
  entry_info : mud_entry_descriptor;
  buffer : cud_disk_block;
  change_header : mud_change_header;
  mud_entry : mud_user_entry;
  nud_entry : nud_user_entry;
  type_must_change : boolean;
  old_entry_type : mud_entry_type;
  packed_profile : mud_access_profile_description;
  change_offset : mud_data_index;
  change_size : mud_data_size;

begin
  last_status := CUD_ENTRY_OK;
  entry_info.block_locked := FALSE;
  entry_info.user := modify_user;
  find_user_entry(TRUE, buffer, entry_info);
  if last_status = CUD_ENTRY_OK
  then
    begin
      if validity_period = 0
      then cud_entry.expire_date := 0
      else cud_entry.expire_date := validity_period + cud_entry.password_date;
      store_change_date(REALTIME, entry_info, buffer.data);
(*      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-    *)
$if CHANGES_TO_OPER_LOG       cud_change_type := CHANGE_PASSWORD_EXPIRE;
(*      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-    *)
(* determine if type of entry must change...NOTE: if entry_type	is	*)
(* greater than EXPIRE_DATE_IRC_ENTRY, the type must NOT change	 	*)
      old_entry_type :=
        mud_entry_type_of_char(buffer.data[entry_info.mud_pointer]);
      type_must_change := FALSE;
      if (old_entry_type = MINIMUM_ENTRY) and (validity_period > 0)
      then type_must_change := TRUE;
      if (old_entry_type = EXPIRE_DATE_IRC_ENTRY) and (validity_period = 0)
      then 
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone include_irc 	type_must_change := TRUE;
$if include_irc
(* unpack IRC to see if type s/be changed *)
        if ord(buffer.data[mud_irc_location(entry_info)]) = 0
	then type_must_change := TRUE;
$endif include_irc
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      if not type_must_change
      then
        begin (* just store expiration date and make change *)
	  store_expire_date(cud_entry.expire_date,entry_info,buffer.data);
	  set_up_mud_change_header(entry_info.user.block,
	    expiration_date_location(entry_info), MUD_EXPIRE_DATE_BYTES,
	    change_header)
        end (* type does not change *)
      else
        begin (* entry must change...recreate it *)
          mud_entry.name := entry_info.user.name;
          unpack_cud_entry(entry_info, buffer.data, mud_entry, nud_entry);
	  if validity_period = 0
	  then mud_entry.entry_type := MINIMUM_ENTRY
	  else
	    begin
	      mud_entry.entry_type := EXPIRE_DATE_IRC_ENTRY;
	      mud_entry.password.expire_date := cud_entry.expire_date
	    end (* non-zero validity_period *);
	  pack_profile(mud_entry.mud_access_profile, packed_profile);
	  set_entry_sizes(mud_entry.entry_type, entry_info);
	  move_entry(packed_entry_size(entry_info, packed_profile),
	    packed_profile, mud_entry, nud_entry,
$if overflow_cud_entries 	    change_header,
	    entry_info, buffer, change_offset, change_size);
	  set_up_mud_change_header(entry_info.user.block, change_offset,
	    change_size, change_header);
        end (* entry must change...recreate it *);
      if not ((old_entry_type = MINIMUM_ENTRY) and (validity_period = 0))
      then update_block(entry_info, change_header, TRUE, buffer)
    end (* last_status = CUD_ENTRY_OK *);
  unlock_block(entry_info);
  unlock_username(modify_user)
end (* update_password_expiration_date *);
$endif PASSWORD_EXPIRATION_BY_USER
"$endif ALLOW_GLOBAL_PASSWORD_EXPIRE"
$if restrict_users_by_time



(*********************  mud_entry_updater  ******************************)
(*                                                                      *)
(*                    update_allowable_times                            *)
(*                                                                      *)
(*     Update modify_users's CUD entry with new_allowable_times		*)
(*	(modify_mud_entry must have been previously called).		*)
(*                                                                      *)
(************************************************************************)

procedure entry UPDATE_ALLOWABLE_TIMES(
      new_allowable_times   : allowable_login_times);

var
  entry_info : mud_entry_descriptor;
  buffer : cud_disk_block;
  change_header : mud_change_header;
  mud_entry : mud_user_entry;
  nud_entry : nud_user_entry;
  type_must_change : boolean;
  old_entry_type : mud_entry_type;
  packed_profile : mud_access_profile_description;
  change_offset : mud_data_index;
  change_size : mud_data_size;

begin
  last_status := CUD_ENTRY_OK;
  entry_info.block_locked := FALSE;
  entry_info.user := modify_user;
  find_user_entry(TRUE, buffer, entry_info);
  if last_status = CUD_ENTRY_OK
  then
    begin
      store_change_date(REALTIME, entry_info, buffer.data);
(*      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-    *)
$if CHANGES_TO_OPER_LOG
      cud_change_type := CHANGE_ALLOWABLE_TIMES_CUD_CHANGE;
$endif CHANGES_TO_OPER_LOG
(*      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-    *)
      mud_entry.name := entry_info.user.name;
      unpack_cud_entry(entry_info, buffer.data, mud_entry, nud_entry);
(* determine if type of entry must change...	*)
      old_entry_type :=
        mud_entry_type_of_char(buffer.data[entry_info.mud_pointer]);
      type_must_change := FALSE;
      if (old_entry_type < TIME_RESTRICTED_ENTRY) and
         (new_allowable_times <> [ALL_HOURS])
      then
        begin (* make entry a time restricted one *)
	  type_must_change := TRUE;
	  mud_entry.entry_type := TIME_RESTRICTED_ENTRY
	end (* make entry a time restricted one *)
      else
        if (old_entry_type = TIME_RESTRICTED_ENTRY) and
	  (new_allowable_times = [ALL_HOURS])
        then
          begin (* removing time restriction from entry *)
	    type_must_change := TRUE;
	    if (mud_entry.password.expire_date = 0) and (mud_entry.irc = 0)
	    then mud_entry.entry_type := MINIMUM_ENTRY
	    else mud_entry.entry_type := EXPIRE_DATE_IRC_ENTRY
	  end (* removing time restriction from entry *);
	if not type_must_change
	then
	  begin (* just store allowable times and make change *)
	    pack_allowable_times(new_allowable_times, entry_info, buffer.data);
	    set_up_mud_change_header(entry_info.user.block,
	      allowable_times_location(entry_info), MUD_TIME_RESTRICT_BYTES,
	      change_header)
	  end (* just store allowable times and make change *)
	else
	  begin (* entry must change...recreate it *)
	    mud_entry.allowable_times := new_allowable_times;
	    pack_profile(mud_entry.mud_access_profile, packed_profile);
	    set_entry_sizes(mud_entry.entry_type, entry_info);
	    move_entry(packed_entry_size(entry_info, packed_profile),
	      packed_profile, mud_entry, nud_entry,
$if overflow_cud_entries 	    change_header,
	      entry_info, buffer, change_offset, change_size);
	    set_up_mud_change_header(entry_info.user.block, change_offset,
	      change_size, change_header)
        end (* entry must change...recreate it *);
      update_block(entry_info, change_header, TRUE, buffer)
    end (* last_status = CUD_ENTRY_OK *);
  unlock_block(entry_info);
  unlock_username(modify_user)
end (* update_allowable_times *);
$endif restrict_users_by_time
$if NETVAL_IS_A_SLAVE


(*********************  mud_entry_updater  ******************************)
(*                                                                      *)
(*                              update_gfd_only                         *)
(*                                                                      *)
(*     Make the user a GFD only user by storing "garbage" as the        *)
(*     password.                                                        *)
(*                                                                      *)
(************************************************************************)

procedure entry UPDATE_GFD_ONLY;

begin
(*      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-    *)
$if CHANGES_TO_OPER_LOG
  cud_change_type := SET_GFD_ONLY_CUD_CHANGE;
$endif CHANGES_TO_OPER_LOG
(*      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-    *)
  do_update_password(GFD_ONLY_PASSWORD, GFD_ONLY_PASSWORD_DATE
$if force_password_change    , TRUE
)
end (* update_gfd_only *);
(*      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-  *)



(*********************  mud_entry_updater  ******************************)
(*                                                                      *)
(*                         update_uun_and_gan                           *)
(*                                                                      *)
(*    Update modify_users's CUD entry with new_gan and new_uun          *)
(*                                                                      *)
(************************************************************************)

procedure entry UPDATE_UUN_AND_GAN(
      new_gan   : integer;
      new_uun   : integer);

var
  entry_info : mud_entry_descriptor;
  buffer : cud_disk_block;
  change_header : mud_change_header;

begin
  last_status := CUD_ENTRY_OK;
  entry_info.block_locked := FALSE;
  entry_info.user := modify_user;
  find_user_entry(TRUE, buffer, entry_info);
  if last_status = CUD_ENTRY_OK
  then
    begin
$if include_gan       store_gan(new_gan, entry_info, buffer.data);
      store_uun(new_uun, entry_info, buffer.data);
      store_change_date(REALTIME, entry_info, buffer.data);
      set_up_mud_change_header(entry_info.user.block,
        mud_uun_location(entry_info), MUD_UUN_BYTES, change_header);
$if CHANGES_TO_OPER_LOG
      cud_change_type := CHANGE_UUN_AND_GAN_CUD_CHANGE;
$endif CHANGES_TO_OPER_LOG
(*      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-    *)
      update_block(entry_info, change_header, TRUE, buffer)
    end (* last_status = CUD_ENTRY_OK *);
  unlock_block(entry_info);
  unlock_username(modify_user)
end (* update_uun_and_gan *);
$endif NETVAL_IS_A_SLAVE
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(*********************  mud_entry_updater  ******************************)
(*									*)
(*				update_gan				*)
(*									*)
(*      Update modify_user's CUD entry with a new GAN			*)
(*	(modify_mud_entry must have been previously called).		*)
(*									*)
(************************************************************************)

procedure entry UPDATE_GAN(
      new_gan	: integer);

var
  entry_info : mud_entry_descriptor;
  buffer : cud_disk_block;
  change_header : mud_change_header;

begin
  last_status := CUD_ENTRY_OK;
  entry_info.block_locked := FALSE;
  entry_info.user := modify_user;
  find_user_entry(TRUE, buffer, entry_info);
  if last_status = CUD_ENTRY_OK
  then
    begin
$if include_gan      store_gan(new_gan, entry_info, buffer.data);
      store_change_date(REALTIME, entry_info, buffer.data);
$if CHANGES_TO_OPER_LOG
      cud_change_type := CHANGE_GAN_CUD_CHANGE;
$endif CHANGES_TO_OPER_LOG
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      update_block(entry_info, change_header, FALSE, buffer)
    end (* last_status = CUD_ENTRY_OK *);
  unlock_block(entry_info);
  unlock_username(modify_user)
end (* update_gan *);



(*********************  mud_entry_updater  ******************************)
(*									*)
(*				update_uun				*)
(*									*)
(*      Update modify_user's CUD entry with a new UUN			*)
(*	(modify_mud_entry must have been previously called).		*)
(*									*)
(************************************************************************)

procedure entry UPDATE_UUN(
      new_uun	: univ word_in_bytes);

var
  entry_info : mud_entry_descriptor;
  buffer : cud_disk_block;
  change_header : mud_change_header;

begin
  last_status := CUD_ENTRY_OK;
  entry_info.block_locked := FALSE;
  entry_info.user := modify_user;
  find_user_entry(TRUE, buffer, entry_info);
  if last_status = CUD_ENTRY_OK
  then
    begin
      store_uun(new_uun, entry_info, buffer.data);
      store_change_date(REALTIME, entry_info, buffer.data);
      set_up_mud_change_header(entry_info.user.block,
        mud_uun_location(entry_info), MUD_UUN_BYTES, change_header);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if CHANGES_TO_OPER_LOG
      cud_change_type := CHANGE_UUN_CUD_CHANGE;
$endif CHANGES_TO_OPER_LOG
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      update_block(entry_info, change_header, TRUE, buffer)
    end (* last_status = CUD_ENTRY_OK *);
  unlock_block(entry_info);
  unlock_username(modify_user)
end (* update_uun *);



(*********************  mud_entry_updater  ******************************)
(*									*)
(*			     update_mud_options				*)
(*									*)
(*      Update modify_user's CUD entry with new_options			*)
(*	(modify_mud_entry must have been previously called).		*)
(*	If password_changed is TRUE, the CHANGE CONTROL command caused	*)
(*	the password to be changed; if profile_changed is TRUE, the	*)
(*	CHANGE CONTROL command caused the access profile to be changed. *)
(*      If the mud_access_profile was changed, the change was to set all*)
(*	the destinations to home, so the size of the entry will not	*)
(*	have changed.							*)
(*									*)
(************************************************************************)

procedure entry UPDATE_MUD_OPTIONS(
      password_changed	: boolean;
      profile_changed	: boolean;
  var mud_entry		: mud_user_entry;
  var nud_entry		: nud_user_entry);

var
  entry_info : mud_entry_descriptor;
  buffer : cud_disk_block;
  change_offset : mud_data_index;
  change_size : mud_data_size;
  change_date : integer;
  change_header : mud_change_header;
  new_cipher : integer;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if prevent_duplicate_passwords   old_nud_options : nud_user_options;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

begin
  last_status := CUD_ENTRY_OK;
  new_cipher := mud_entry.password.cipher;
  entry_info.block_locked := FALSE;
  entry_info.user := modify_user;
  find_user_entry(TRUE, buffer, entry_info);
  if last_status = CUD_ENTRY_OK
  then
    begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if prevent_duplicate_passwords
      unpack_nud_options(entry_info, buffer.data, old_nud_options);
$endif prevent_duplicate_passwords
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(* store options and entry change date *)
      store_mud_options(mud_entry.mud_options, entry_info, buffer.data);
      change_date := REALTIME;
      store_nud_options(nud_entry.nud_options, entry_info, buffer.data);
      store_change_date(change_date, entry_info, buffer.data);

(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if CHANGES_TO_OPER_LOG
      cud_change_type := CHANGE_OPTIONS_CUD_CHANGE;
$endif CHANGES_TO_OPER_LOG
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(* store changed profile if necessary - change_offset and	*)
(* change_size are set by save_access_profile routine.		*)
(* the save_access_profile routine UNPACKS THE ENTRY IN THE	*)
(* BUFFER INTO MUD_ENTRY...(any new info will be wiped out,	*)
(* i.e., need to save new password).				*)
      if profile_changed
      then
        begin
	  save_access_profile(mud_entry, nud_entry,
$if OVERFLOW_CUD_ENTRIES 	    change_header,
	    entry_info, buffer, change_offset, change_size);
	  if change_offset = mud_profile_location(entry_info)
	  then
	    begin (* size of A.P. stayed the same, adjust values *)
	      change_offset := mud_control_location(entry_info);
	      change_size := change_size +
	        (mud_profile_location(entry_info) - 
		 mud_control_location(entry_info));
	    end (* size of A.P. stayed the same, adjust values *)
        end (* profile_changed *)
      else
	begin (* no profile change, just options so far *)
	  change_offset := mud_control_location(entry_info);
	  change_size := MUD_CONTROL_BYTES
	end (* no profile change, just options so far *);

(* store password and password change date if necessary *)
      if password_changed and (last_status = CUD_ENTRY_OK)
      then
        begin
$if prevent_duplicate_passwords
	  pack_previous_cipher(mud_entry.mud_options, entry_info,
	    NO_PREVIOUS_CIPHER, PREVIOUS_PASSWORD_STORED in old_nud_options,
	    nud_entry.nud_options, buffer.data);
$endif prevent_duplicate_passwords
	  store_cipher(new_cipher, entry_info, buffer.data);
	  store_password_date(change_date, entry_info, buffer.data);
	  if not profile_changed
	  then
	    begin (* adjust change_size *)
	      change_size := change_size + MUD_UUN_BYTES + MUD_CIPHER_BYTES;
	      if mud_entry.entry_type <> MINIMUM_ENTRY
	      then change_size := change_size + MUD_IRC_BYTES
	    end (* adjust change_size *)
	end (* password_changed *);

      if last_status = CUD_ENTRY_OK
      then set_up_mud_change_header(entry_info.user.block, change_offset,
        change_size, change_header);
      update_block(entry_info, change_header, TRUE, buffer)
    end (* last_status = CUD_ENTRY_OK *);
  unlock_block(entry_info);
  unlock_username(modify_user)
end (* update_mud_options *);



(*********************  mud_entry_updater  ******************************)
(*									*)
(*			     update_nud_options				*)
(*									*)
(*	Update nud_options						*)
(*									*)
(************************************************************************)

procedure entry UPDATE_NUD_OPTIONS(
      change_date	: boolean;
  var new_entry		: nud_user_entry);

var
  entry_info : mud_entry_descriptor;
  buffer : cud_disk_block;
  change_header : mud_change_header;

begin
  last_status := CUD_ENTRY_OK;
  entry_info.block_locked := FALSE;
  entry_info.user := modify_user;
  find_user_entry(TRUE, buffer, entry_info);
  if last_status = CUD_ENTRY_OK
  then
    begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if CHANGES_TO_OPER_LOG       cud_change_type := CHANGE_NUD_OPTIONS_CUD_CHANGE;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(* store options and entry change date *)
      store_nud_options(new_entry.nud_options, entry_info, buffer.data);
      if change_date
      then store_change_date(REALTIME, entry_info, buffer.data);
      update_block(entry_info, change_header, FALSE, buffer)
    end (* last_status = CUD_ENTRY_OK *);
  unlock_block(entry_info);
  unlock_username(modify_user)
end (* update_nud_options *);



(*********************  mud_entry_updater  ******************************)
(*									*)
(*				update_district				*)
(*									*)
(*      Update modify_user's CUD entry with new_district		*)
(*	(modify_mud_entry must have been previously called).		*)
(*									*)
(************************************************************************)

procedure entry UPDATE_DISTRICT(
      new_district	: integer);

var
  entry_info : mud_entry_descriptor;
  buffer : cud_disk_block;
  change_header : mud_change_header;

begin
  last_status := CUD_ENTRY_OK;
  entry_info.block_locked := FALSE;
  entry_info.user := modify_user;
  find_user_entry(TRUE, buffer, entry_info);
  if last_status = CUD_ENTRY_OK
  then
    begin
      store_district(new_district, entry_info, buffer.data);
      store_change_date(REALTIME, entry_info, buffer.data);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if CHANGES_TO_OPER_LOG
      cud_change_type := CHANGE_DISTRICT_CUD_CHANGE;
$endif CHANGES_TO_OPER_LOG
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      update_block(entry_info, change_header, FALSE, buffer)
    end (* last_status = CUD_ENTRY_OK *);
  unlock_block(entry_info);
  unlock_username(modify_user)
end (* update_district *);



(*********************  mud_entry_updater  ******************************)
(*									*)
(*			     update_profile				*)
(*									*)
(*      Update modify_user's CUD entry with profile in mud_entry;	*)
(*	(modify_mud_entry must have been previously called).		*)
(*									*)
(************************************************************************)

procedure entry UPDATE_PROFILE(
  var mud_entry	: mud_user_entry;
  var nud_entry	: nud_user_entry);

var
  entry_info : mud_entry_descriptor;
  buffer : cud_disk_block;
  change_offset : mud_data_index;
  change_size : mud_data_size;
  change_header : mud_change_header;

begin
  last_status := CUD_ENTRY_OK;
  entry_info.block_locked := FALSE;
  entry_info.user := modify_user;
  find_user_entry(TRUE, buffer, entry_info);
  if last_status = CUD_ENTRY_OK
  then
    begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if CHANGES_TO_OPER_LOG
      cud_change_type := CHANGE_ACCESS_CUD_CHANGE;
$endif CHANGES_TO_OPER_LOG
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      save_access_profile(mud_entry, nud_entry,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if OVERFLOW_CUD_ENTRIES 	change_header,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      entry_info, buffer, change_offset, change_size)
    end (* last_status = CUD_ENTRY_OK *);
  if last_status = CUD_ENTRY_OK
  then
    begin
      store_change_date(REALTIME, entry_info, buffer.data);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      set_up_mud_change_header(entry_info.user.block, change_offset,
        change_size, change_header);
      update_block(entry_info, change_header, TRUE, buffer)
    end (* last_status = CUD_ENTRY_OK *);
  unlock_block(entry_info);
  unlock_username(modify_user)
end (* update_profile *);
$endif disk_maintenance_code
$if include_non_dmc



(*********************  mud_entry_updater  ******************************)
(*									*)
(*				new_cud_entry				*)
(*									*)
(*      Write the new_entry into the appropriate block			*)
(*	(reserve_cud_name must have already been called to		*)
(*	set up new_user.name). Calling procedure sets entry_type.	*)
(*	Called by COMMAND_LEVEL and MASTER_COMMAND_LEVEL.		*)
(*									*)
(************************************************************************)

procedure entry NEW_CUD_ENTRY(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone CONVERT_TO_43
$if REUSE_UUNS       bit17_flag	: boolean;
$endif CONVERT_TO_43
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  var new_mud_entry		: mud_user_entry;
  var new_nud_entry		: nud_user_entry);

var
  entry_info : mud_entry_descriptor;
  buffer : cud_data_block;

begin
  last_status := CUD_ENTRY_OK;
  entry_info.block_locked := FALSE;
$if CONVERT_TO_43
  entry_info.user.name := new_mud_entry.name;
  entry_info.user.packed_name_size := packed_size_of_name(new_mud_entry.name);
$endif CONVERT_TO_43
$ifnone CONVERT_TO_43   entry_info.user := new_user;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone CONVERT_TO_43
$if CHANGES_TO_OPER_LOG   cud_change_type := NEW_USER_CUD_CHANGE;
$endif CONVERT_TO_43
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  add_new_entry(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone CONVERT_TO_43
$if REUSE_UUNS    bit17_flag,
$endif CONVERT_TO_43
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    entry_info, new_mud_entry, new_nud_entry)
$ifnone disk_maintenance_code
;
  unlock_block(entry_info);
  unlock_username(new_user)
$endif disk_maintenance_code
end (* new_cud_entry *);
$endif include_non_dmc
$ifnone disk_maintenance_code



(*********************  mud_entry_updater  ******************************)
(*									*)
(*			    do_delete_cud_entry				*)
(*									*)
(*      Remove modify_user.name from the CUD (modify_cud_entry		*)
(*	must have previously been called).				*)
(*									*)
(************************************************************************)

procedure do_delete_cud_entry
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if REUSE_UUNS
(
      uun_to_return	: integer)
$endif REUSE_UUNS
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
;

var
  entry_info : mud_entry_descriptor;

begin
  last_status := CUD_ENTRY_OK;
  entry_info.block_locked := FALSE;
  delete_entry(entry_info);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if REUSE_UUNS
  if last_status = CUD_ENTRY_OK
  then param_manager.put_back_uun(uun_to_return);
$endif REUSE_UUNS
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  unlock_block(entry_info);
  unlock_username(modify_user)
end (* do_delete_cud_entry *);



(*********************  mud_entry_updater  ******************************)
(*									*)
(*			    delete_cud_entry				*)
(*									*)
(*	Delete the name from the CUD.				        *)
(*									*)
(************************************************************************)

procedure entry DELETE_CUD_ENTRY
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if REUSE_UUNS
(
       uun_to_return	: integer)
$endif REUSE_UUNS
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
;

begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if CHANGES_TO_OPER_LOG
  cud_change_type := DELETE_USER_CUD_CHANGE;
$endif CHANGES_TO_OPER_LOG
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  do_delete_cud_entry
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if REUSE_UUNS      (uun_to_return)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
end (* delete_cud_entry *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if special



(*********************  mud_entry_updater  ******************************)
(*									*)
(*			 delete_mud_slide_entry				*)
(*									*)
(*	Delete the entry for the name in the speicified block from	*)
(*	the CUD.  This routine is only used for "MUD slide" entries	*)
(*	that are not located in the proper CUD block.		        *)
(*									*)
(************************************************************************)

procedure entry DELETE_MUD_SLIDE_ENTRY(
      block	: cud_block_index;
  var mud_entry	: mud_user_entry);

var
  entry_info : mud_entry_descriptor;
  buffer : cud_data_block;
  nud_entry : nud_user_entry;

begin
  last_status := CUD_ENTRY_OK;
  entry_info.user.name := mud_entry.name;
  name_access.lock_cud_entry(cud_user, entry_info.user.name, FALSE,
    entry_info.user.name_locked);
  if entry_info.user.name_locked
  then
    begin
      entry_info.user.block := block;
      find_user_entry(FALSE, buffer, entry_info);
      if last_status = CUD_ENTRY_OK
      then
        begin
	  mud_entry.name := entry_info.user.name;
	  unpack_cud_entry(entry_info, buffer.data, mud_entry, nud_entry)
	end;
      if last_status = CUD_ENTRY_OK
      then modify_user := entry_info.user (* save for future update *)
      else unlock_username(entry_info.user)
    end
  else last_status := CUD_ENTRY_LOCKED;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if CHANGES_TO_OPER_LOG
  cud_change_type := DELETE_USER_CUD_CHANGE;
$endif CHANGES_TO_OPER_LOG
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  if last_status = CUD_ENTRY_OK
  then
    begin
      entry_info.block_locked := FALSE;
      delete_entry(entry_info);
      unlock_block(entry_info);
      unlock_username(modify_user)
    end
end (* delete_mud_slide_entry *);
$endif special
$endif disk_maintenance_code
$ifnone convert_to_43
!
"
	CUD List Routines
"



(*********************  mud_entry_updater  ******************************)
(*									*)
(*			     get_cud_entry				*)
(*									*)
(*      Return the next sequential CUD entry.				*)
(*									*)
(************************************************************************)

procedure get_cud_entry(
      data		: cud_entry_data;
  var entry_found	: boolean;
  var entry_name	: username_string;
  var entry_info	: mud_entry_descriptor);

begin
  next_cud_entry(data, entry_name, entry_info);
  entry_found := (last_status = CUD_ENTRY_OK);
  if (last_status = CUD_ENTRY_NOT_FOUND)
$if OVERFLOW_CUD_ENTRIES    or (last_status = CUD_ENTRY_OVERFLOW_FOUND)
  then last_status := CUD_ENTRY_OK;
  if last_status <> CUD_ENTRY_OK
  then cud_utility.set_format_error(entry_info.user.block,
      entry_info.mud_pointer, last_status)
end (* get_cud_entry *);


(*********************  mud_entry_updater  ******************************)
(*									*)
(*			     next_list_entry				*)
(*									*)
(*      Return the next sequential CUD entry.				*)
(*									*)
(************************************************************************)

procedure next_list_entry(
      data		: univ cud_entry_data;
  var entry_found	: boolean;
  var entry_info	: mud_entry_descriptor;
  var mud_entry		: mud_user_entry;
  var nud_entry		: nud_user_entry);

var
  entry_name : username_string;

begin
  next_cud_entry(data, entry_name, entry_info);
  entry_found := (last_status = CUD_ENTRY_OK);
  if entry_found
  then
    begin
      mud_entry.name := entry_name;
      cud_utility.clear_access_profile(mud_entry.mud_access_profile);
      unpack_cud_entry(entry_info, data, mud_entry, nud_entry);
      entry_found := last_status = CUD_ENTRY_OK
    end (* entry found *)
  else (* entry not found *)
   if (last_status = CUD_ENTRY_NOT_FOUND)
$if OVERFLOW_CUD_ENTRIES    or (last_status = CUD_ENTRY_OVERFLOW_FOUND)
   then last_status := CUD_ENTRY_OK
end (* next_list_entry *);



(*********************  mud_entry_updater  ******************************)
(*									*)
(*			     start_cud_list				*)
(*									*)
(*      Initialize a sequential list of the CUD; the cud_data is	*)
(*	passed so that a disk read does not have to be done for		*)
(*	each individual CUD entry.					*)
(*									*)
(************************************************************************)

procedure entry START_CUD_LIST(
      initial_block	: cud_block_index;
  var buffer		: cud_disk_block);

begin
  last_status := CUD_ENTRY_OK;
  mud_listing_pointer := START_MUD_ENTRY_OFFSET;
  nud_listing_pointer := NUD_DATA_ENTRY_OFFSET;
  listing_block := initial_block;
  read_cud_block(listing_block, buffer)
end (* start_cud_list *);



(*********************  mud_entry_updater  ******************************)
(*									*)
(*			      next_cud_list				*)
(*									*)
(*      Return the next sequential CUD entry; called by			*)
(*	command_level_utility routine display_directory.		*)
(*									*)
(************************************************************************)

procedure entry NEXT_CUD_LIST(
  var buffer	: univ cud_data_block;
  var block	: cud_block_index;
  var mud_entry	: mud_user_entry;
  var nud_entry : nud_user_entry);

var
  entry_found : boolean;
  entry_info : mud_entry_descriptor;

begin
  last_status := CUD_ENTRY_OK;
  repeat
    entry_info.user.block := listing_block;
    entry_info.mud_pointer := mud_listing_pointer;
    entry_info.nud_pointer := nud_listing_pointer;
    next_list_entry(buffer.data, entry_found, entry_info, mud_entry,
      nud_entry);
    if last_status = CUD_ENTRY_OK
    then
      begin
        if not entry_found
	then
	  if listing_block = CUD_BLOCK_LIMIT
	  then last_status := CUD_ENTRY_NOT_FOUND (* end of users *)
	  else
	    begin (* get next block *)
	      listing_block := listing_block + 1;
	      mud_listing_pointer := START_MUD_ENTRY_OFFSET;
	      nud_listing_pointer := NUD_DATA_ENTRY_OFFSET;
	      read_cud_block(listing_block, buffer)
	    end (* get next block *)
      end (* last_status = CUD_ENTRY_OK *);
    if last_status <> CUD_ENTRY_OK
    then
      begin
 (* so next block will be read on next call *)
        mud_listing_pointer := START_MUD_ENTRY_OFFSET;
	nud_listing_pointer := NUD_DATA_ENTRY_OFFSET;
	mutil.clear_block(buffer.data)
      end (* last_status <> CUD_ENTRY_OK *)
  until entry_found or (last_status <> CUD_ENTRY_OK);
  if entry_found
  then
    begin
      cud_utility.increment_entry_pointer(listing_block,
        entry_info.size_of_mud_entry, entry_info.size_of_nud_entry,
	last_status, mud_listing_pointer, nud_listing_pointer);
      if hashed_block(mud_entry.name) <> listing_block
      then last_status := CUD_ENTRY_IN_WRONG_BLOCK
    end (* entry found *);
  block := listing_block
end (* next_cud_list *);
$endif convert_to_43
$ifnone disk_maintenance_code
!
"
	Rename Routine
"



(**********************  mud_entry_updater  *****************************)
(*									*)
(*			    rename_cud_entry				*)
(*									*)
(*      Rename the CUD entry for modify_user.name to new_user.name	*)
(*	by first deleting the old entry, then adding the new entry	*)
(*	(modify_cud_entry must have been previously called with the	*)
(*	old name, and reserve_cud_name must have been previously	*)
(*	called with the new name).					*)
(*									*)
(************************************************************************)

procedure entry RENAME_CUD_ENTRY(
  var mud_entry		: mud_user_entry;
  var nud_entry		: nud_user_entry);

var
  new_user_info : mud_entry_descriptor;
  old_user_info : mud_entry_descriptor;
  result : cud_access_status;
  save_status : cud_entry_result;

begin
  if (MUDUPD_DATA_MAX - mud_change.mud_change_eof) >
    (2 * MAXIMUM_VALIDATOR * (MAXIMUM_CUD_DATA + CUD_CHANGE_HEADER_SIZE))
  then
    begin (* there is room in the mudupd file for the rename chages *)
      last_status := CUD_ENTRY_OK;
      new_user_info.block_locked := FALSE;
      new_user_info.user := new_user;
      old_user_info.block_locked := FALSE;
      old_user_info.user := modify_user;

(* lock the rename blocks *)
      cud_access.lock_cud_block(cud_user, old_user_info.user.block, FALSE,
        result);
      set_access_status(result);
      if last_status = CUD_ENTRY_OK
      then
        begin
          old_user_info.block_locked := TRUE;
          if new_user_info.user.block = old_user_info.user.block
          then old_user_info.block_locked := TRUE
          else cud_access.lock_cud_block(cud_user, new_user_info.user.block,
            FALSE, result);
          set_access_status(result);
          if last_status = CUD_ENTRY_OK
          then new_user_info.block_locked := TRUE
          else
            begin
	      new_user_info.block_locked := FALSE;
	      unlock_block(old_user_info)
	    end
        end
      else old_user_info.block_locked := FALSE;

      if last_status = CUD_ENTRY_OK
      then
        begin (* blocks locked successfully *)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if CHANGES_TO_OPER_LOG
	  cud_change_type := RENAME_DELETE_USER_CUD_CHANGE;
$endif CHANGES_TO_OPER_LOG
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	  delete_entry(old_user_info);
	  new_user_info.user := new_user;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if CHANGES_TO_OPER_LOG 	  cud_change_type :=RENAME_NEW_USER_CUD_CHANGE;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	  if last_status = CUD_ENTRY_OK
	  then add_new_entry(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if REUSE_UUNS 	  FALSE,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	    new_user_info, mud_entry, nud_entry);
	  if last_status <> CUD_ENTRY_OK
	  then
	    begin (* attempt to restore the old username to the CUD. *)
	      save_status := last_status;
	      last_status := CUD_ENTRY_OK;
	      mud_entry.name := modify_user.name;
	      old_user_info.user := modify_user;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if CHANGES_TO_OPER_LOG
	      cud_change_type := RENAME_RESTORE_OLD_NAME;
$endif CHANGES_TO_OPER_LOG
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	      add_new_entry(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if REUSE_UUNS 	      FALSE,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	        old_user_info, mud_entry, nud_entry)
	    end (* last_status <> CUD_ENTRY_OK *);

(*      Unlock both the old and new rename blocks.			*)

	  unlock_block(new_user_info);
	  if new_user_info.user.block <> old_user_info.user.block
	  then unlock_block(old_user_info)
	end (* last_status = CUD_ENTRY_OK *);
    end
  else last_status := CUD_ENTRY_MUD_CHANGE_FILE_FULL;
  unlock_username(modify_user);
  unlock_username(new_user)
end (* rename_cud_entry *);
!
(*	The following routine(s) are here because all		*)
(*	the CUD entry logic is here.				*)




(**********************  mud_entry_updater  *****************************)
(*									*)
(*			    unpack_next_entry				*)
(*									*)
(*	This routine returns consecutive entries from a CUD/MUD buffer	*)
(*	to a programmer performing a DISPLAY FORMATTED command.  It	*)
(*	also increments mud_pointer and nud_pointer (10/5/88).		*)
(*									*)
(************************************************************************)

procedure entry UNPACK_NEXT_ENTRY(
      buffer		: univ cud_data;
      block		: cud_block_index;
  var mud_pointer	: mud_data_index;
  var nud_pointer	: nud_data_index;
  var mud_entry		: mud_user_entry;
  var nud_entry		: nud_user_entry);

var
  entry_info : mud_entry_descriptor;
  found: boolean;

begin
  last_status := CUD_ENTRY_OK;
  entry_info.user.block := block;
  entry_info.mud_pointer := mud_pointer;
  entry_info.nud_pointer := nud_pointer;
  next_list_entry(buffer, found, entry_info, mud_entry, nud_entry);
  if last_status = CUD_ENTRY_OK
  then
    if found
    then cud_utility.increment_entry_pointer(block,
      entry_info.size_of_mud_entry, entry_info.size_of_nud_entry, last_status,
      mud_pointer, nud_pointer)
    else last_status := CUD_ENTRY_NOT_FOUND
end (* unpack_next_entry *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if changes_to_oper_log



(**********************  mud_entry_updater  *****************************)
(*									*)
(*				set_remark				*)
(*									*)
(************************************************************************)

procedure entry SET_REMARK(
      new_remark	: oplog_remark_message);

begin
  oplog_remark := new_remark
end (* set_remark *);
$endif changes_to_oper_log
$endif disk_maintenance_code
$if disk_load_test


(**********************  mud_entry_updater  *****************************)
(*									*)
(*			      dummy_update				*)
(*									*)
(************************************************************************)

procedure entry DUMMY_UPDATE(
      block	: cud_block_index);

var
  entry_info : mud_entry_descriptor;
  buffer : cud_disk_block;
  change_header : mud_change_header;

begin
  last_status := CUD_ENTRY_OK;
  entry_info.block_locked := FALSE;
  entry_info.user.block := block;
  read_block(TRUE, entry_info, buffer);
  
  set_up_mud_change_header(block, 0, 100, change_header);
  update_block(entry_info, change_header, TRUE, buffer);
  unlock_block(entry_info)
end (* dummy_update *);
$endif disk_load_test
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code
$ifnone CONVERT_TO_43
$if password_expiration_by_user



(*********************  mud_entry_updater  ******************************)
(*									*)
(*			 assign_expiration_date				*)
(*									*)
(*	This procedure is used during the SET VALIDITY command in NVDM	*)
(*	when the validator wishes to assign users an expiration date.	*)
(*	A sequential scan of the CUD is being done via calls to		*)
(*	NEXT_CUD_LIST; this routine is called to update the data on the	*)
(*	disk when necessary.						*)
(*									*)
(************************************************************************)

procedure entry ASSIGN_EXPIRATION_DATE(
      block	: cud_block_index;
  var buffer	: univ cud_data_block;
  var mud_entry	: mud_user_entry;
  var nud_entry : nud_user_entry);

var
  entry_info : mud_entry_descriptor;
  packed_profile : mud_access_profile_description;
  change_offset : mud_data_index;
  change_size : mud_data_size;
  change_header : mud_change_header;


begin
(* this is because entry will have moved...it insures that calling	*)
(* routine will check all entries in the block				*)
  mud_listing_pointer := START_MUD_ENTRY_OFFSET;
  nud_listing_pointer := NUD_DATA_ENTRY_OFFSET;

  last_status := CUD_ENTRY_OK;
  entry_info.user.name := mud_entry.name;
  entry_info.user.block := block;
  get_user_entry(buffer.data, entry_info);
  if last_status = CUD_ENTRY_OK
  then
    begin
      mud_entry.password.expire_date := nud_entry.password_change_date +
        mud_change.standard_password_validity_in_seconds;
      nud_entry.entry_change_date := REALTIME;
      if mud_entry.entry_type = MINIMUM_ENTRY
      then mud_entry.entry_type := EXPIRE_DATE_IRC_ENTRY;
      pack_profile(mud_entry.mud_access_profile, packed_profile);
      set_entry_sizes(mud_entry.entry_type, entry_info);
      move_entry(packed_entry_size(entry_info, packed_profile),
	packed_profile, mud_entry, nud_entry,
$if overflow_cud_entries 	change_header,
	entry_info, buffer, change_offset, change_size);
      update_block(entry_info,
$ifnone convert_to_43 	change_header, FALSE,
	buffer)
    end
end (* assign_expiration_date *);
$endif password_expiration_by_user



(**********************  mud_entry_updater  *****************************)
(*									*)
(*			       print_error				*)
(*									*)
(************************************************************************)

procedure entry PRINT_ERROR(
      block	: cud_block_index);

begin
  format.start;
  format.cud_entry_status(last_status);
  format.colon_space;
  format.number(block, 10);
  format.write_line(user_terminal)
end (* print_error *);



(**********************  mud_entry_updater  *****************************)
(*									*)
(*			       get_entries				*)
(*									*)
(************************************************************************)

procedure entry GET_ENTRIES(
      cud_flag		: boolean (* TRUE if CUD entries, else MUD *);
      block		: cud_block_index;
      buffer		: univ cud_entry_data;
  var entries		: compare_entries;
  var line_length	: integer);

var
  entry_info : mud_entry_descriptor;
  compare_index : compare_user_entry_index;
  entry_found,
  done : boolean;

begin
  cud_utility.set_cud_or_mud(cud_flag);
  entries.count := 0; compare_index := 0;
  last_status := CUD_ENTRY_OK; done := FALSE;
  entry_info.mud_pointer := START_MUD_ENTRY_OFFSET;
  entry_info.nud_pointer := NUD_DATA_ENTRY_OFFSET;
  entry_info.user.block := block;
  repeat
    get_cud_entry(buffer, entry_found, entries.users[compare_index],
      entry_info);
    if entry_found
    then
      begin
        entries.count := entries.count + 1 (* count entry just found *);
        if entries.count = MAXIMUM_MUD_BLOCK_USER_COUNT
	then
	  begin
	    if line_length = 0
	    then format.start
	    else format.start_and_newline;
	    done := TRUE;
	    format.string('maximum compare entries found in block \');
	    format.number(block, 10);
	    format.string(', skipping any subsequent entries\');
	    format.write_line(user_terminal);
	    line_length := 0
	  end
	else compare_index := compare_index + 1;
	cud_utility.increment_entry_pointer(block,
	  entry_info.size_of_mud_entry, entry_info.size_of_nud_entry,
	  last_status, entry_info.mud_pointer, entry_info.nud_pointer)	
      end
  until done or not entry_found or (last_status <> CUD_ENTRY_OK);
  cud_utility.set_cud_or_mud(TRUE)
end (* get_entries *);



(*********************  mud_entry_updater  ******************************)
(*									*)
(*			     find_name_entry				*)
(*									*)
(*      Find and return a user's MUD entry.				*)
(*									*)
(************************************************************************)

procedure entry FIND_NAME_ENTRY(
      block		: mud_data_index;
      buffer		: univ cud_entry_data;
  var mud_entry		: mud_user_entry);

var
  entry_info : mud_entry_descriptor;
  nud_entry : nud_user_entry (* dummy nud data *);

begin
  entry_info.user.name := mud_entry.name;
  entry_info.user.block := block;
  get_user_entry(buffer, entry_info);
  if last_status = CUD_ENTRY_OK
  then unpack_cud_entry(entry_info, buffer, mud_entry, nud_entry)
end (* find_name_entry *);
$endif CONVERT_TO_43
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(************************************************************************)
(************************************************************************)

begin (* initial statement *)
  modify_user.name_locked := FALSE;
  new_user.name_locked := FALSE
end (* mud_entry_updater *);
$endif BEFORE_SUP_V43
!
(************************************************************************)
(*									*)
(*	CUPUTL.NTV							*)
(*									*)
(*			   cud_updater_utility				*)
(*									*)
(*	This class performs CUD functions and types error explanations.	*)
(*									*)
(*      The following identifiers must be defined externally:		*)
(*	  username_string, cud_user_entry, user_options, access_profile	*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*		Original -- jrn						*)
(*									*)
(************************************************************************)



type CUD_UPDATER_UTILITY = class(
	format		: internal_to_string;
$ifnone BEFORE_SUP_V43      cud_updater	    : mud_entry_updater;
$if BEFORE_SUP_V43	cud_updater	: cud_entry_updater;
	user_terminal	: circuit_handler);
!
(************************  cud_updater_utility  *************************)
(*									*)
(*			 do_print_cud_entry_message			*)
(*									*)
(*      Print message from last_status.					*)
(*									*)
(************************************************************************)

procedure do_print_cud_entry_message;

begin
  format.start_and_newline;
  format.cud_entry_status(cud_updater.last_status);
  format.write_line(user_terminal)
end (* do_print_cud_entry_message *);



(************************  cud_updater_utility  *************************)
(*									*)
(*			 print_cud_entry_message			*)
(*									*)
(*      Print message from last_status.					*)
(*									*)
(************************************************************************)

procedure entry PRINT_CUD_ENTRY_MESSAGE;

begin
  do_print_cud_entry_message
end (* print_cud_entry_message *);



(************************  cud_updater_utility  *************************)
(*									*)
(*			  print_cud_entry_error				*)
(*									*)
(*      Print any error from last_status.				*)
(*									*)
(************************************************************************)

procedure entry PRINT_CUD_ENTRY_ERROR;

begin
  if cud_updater.last_status <> CUD_ENTRY_OK
  then do_print_cud_entry_message
end (* print_cud_entry_error *);



(************************************************************************)
(************************************************************************)

begin (* initial statement *)
end (* cud_updater_utility *);
!
(************************************************************************)
(*									*)
(*	MUDUPD.NTV							*)
(*									*)
(*				mud_updater				*)
(*									*)
(*	The MUD_UPDATER Process controls all MUD updates.		*)
(*									*)
(*      The following identifiers must be defined externally:		*)
(*	  mudupd_address						*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	18Dec87 - neh							*)
(*	      - add dnic_update file_utility				*)
(*	18Aug86 - jrn							*)
(*	      - modify and simplify the UN2 access scheme		*)
(*	07Aug86 - rsb							*)
(*		  add call to MUD_CHANGE.SET_UN2_ACTIVITY_NOT_BUSY after*)
(*		  mud update circuit is zapped.				*)
(*	03Mar86 - rsb							*)
(*		- add NO_SUP_UPDATES flag				*)
(*	02Feb86	- rsb							*)
(*		- create MUD_UPDATER_DELAY so a Set_sup:off command	*)
(*		  doesn't get hung up waiting for delay_util to come	*)
(*		  back if a mud update is pending and a sup is unable	*)
(*		  to receive data.					*)
(*		- Update_mud:  change delay call from delay_util.delay	*)
(*		  to mud_updater_delay.					*)
(*		  delete "or not mud_change.legal_supervisor(real_sup)"	*)
(*		  from repeat loop until statement.  Update_mud will	*)
(*		  now have done returned as TRUE from mud_updater_delay *)
(*		  if the sup is no longer legal, it will then procede	*)
(*		  to be delayed in get_mud_change.			*)
(*	        - change parameter values of FIRST_CIRCUIT_RETRY_DELAY	*)
(*		  and MAXIMUM_CIRCUIT_RETRY_DELAY to	 		*)
(*		  WAIT_FOR_STOP_QUE_CHECK_DELAY				*)
(*		  in call to init delay_utility so delay_util always 	*)
(*		  waits same amount of time				*)	
(*	03Jan86 - rsb							*)
(*		- in "type" statement change "sup : supervisor_index;"	*)
(*		  "pseudo_sup : pseudo_supervisor_index;"		*)
(*		-  add "real_sup : real_supervisor_index;" to var list	*)
(*	09Aug84 jrn							*)
(*	      - use engine checksum for disk				*)
(*	02Aug84 Version 3.00 - jrn/pgl					*)
(*	      - added parameter values of FIRST_CIRCUIT_RETRY_DELAY	*)
(*		and MAXIMUM_CIRCUIT_RETRY_DELAY to init of 		*)
(*		delay_utility						*)
(*	28Jun84 jrn							*)
(*	      - add restart for consistency				*)
(*	15Jun84 jrn							*)
(*	      - removed oper_messages from initialization of		*)
(*		cud_block_updater					*)
(*		Original -- jrn						*)
(*									*)
(************************************************************************)

type MUD_UPDATER = process(
        pseudo_sup      : pseudo_supervisor_index;
	statistics	: statistics_gatherer;
	file_system	: file_system_manager;
	oplog		: operator_log;
	cud_access	: cud_access_controller;
	mud_change	: mud_change_handler;
	circuit_access	: un2_access_manager);

const
  MUD_UPDATER_DELAY_INTERVAL = 5;

var
  mud_utility   : mudupd_utility;
  mutil         : misc_utility;
  delay_utility : circuit_delay_utility;
  crash_util    : crash_utility;
  format        : internal_to_string;
  oper_messages : operator_messages;
  aux_io        : circuit_handler;
  dsksys        : disk_system;
  mud_update    : file_utility;
  sched_update	: file_utility;
$if INCLUDE_DNIC  dnic_update   : file_utility;
  block_updater : cud_block_updater;
  cud_utility	: cud_entry_utility;
  block_utility : cud_block_utility;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone no_sup_updates
  un2_util : un2_utility;
  consistency : consistency_handler;
$endif no_sup_updates
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)  
  major_delay_period : integer;
!



(************************  mud_updater  *********************************)
(*									*)
(*			mud_updater_delay				*)
(*									*)
(************************************************************************)

procedure mud_updater_delay(
  var done : boolean);

var
  restart_time : integer;

begin (* mud_updater_delay *)
  restart_time := major_delay_period + REALTIME;
  while (REALTIME < restart_time) and not done do 
    begin (* check wait_for_stop_que while in comm delay state *)
      if mud_change.wait_for_stop_is_empty(pseudo_sup)
      then delay_utility.delay
      else done := TRUE
    end (* check wait_for_stop_que while in comm delay state *);

  if not done
  then 
    begin (* increase delay period, if possible *)
      if major_delay_period < MAXIMUM_CIRCUIT_RETRY_DELAY
      then major_delay_period := major_delay_period * 2;
      if major_delay_period > MAXIMUM_CIRCUIT_RETRY_DELAY
      then major_delay_period := MAXIMUM_CIRCUIT_RETRY_DELAY
    end (* increase delay period, if possible *);
end (* mud_updater_delay *);




(****************************  mud_updater  *****************************)
(*									*)
(*				update_mud				*)
(*									*)
(*      This is the main loop in the process.  Perform a MUD change	*)
(*	or run a consistency.						*)
(*	If a mud change is to be sent it will loop until either the 	*)
(*	change is sent or the Sup becomes not legal.  If the Sup becomes*)
(*	not legal mud_updater_delay will set "done" to TRUE, which will *)
(*	terminate the mud change send attempt upon the next return from *)
(*	mud_updater_delay to update_mud.				*)
(************************************************************************)

procedure update_mud;

var
  consistency_start_block : cud_block_index;
  change_pointer 	  : mudupd_address;
  change 		  : mud_update_information;
  status 		  : un2_status;
  real_sup                : real_supervisor_index;
  run_consistency,
  done,
  success 		  : boolean;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if no_sup_updates   end_delay_period : integer;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

begin (* update_mud *)
  mud_change.get_mud_change(pseudo_sup, run_consistency, 
                            consistency_start_block, change_pointer, real_sup);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone no_sup_updates
  done := FALSE;	
  If run_consistency
  then
    begin (* start an automatic consistency *)
      consistency.automatic_consistency(real_sup, consistency_start_block);
      if consistency.last_un2_status <> UN2_SUCCESSFUL
      then mud_updater_delay(done)
      else major_delay_period := FIRST_CIRCUIT_RETRY_DELAY
    end (* start an automatic consistency *)
  else
    begin (* change mud *)
      mud_utility.extract_cud_change(change_pointer, success, change.cud_info);
      if not success
      then crash_util.signal_process_error; 
      while not done and mud_change.wait_for_stop_is_empty(pseudo_sup) do
      	begin (* loop until either mud change sent or sup not legal *)
          un2_util.send_mud_change(real_sup, change, status);
          if status <> UN2_SUCCESSFUL
          then mud_updater_delay(done)
          else 
	    begin (* status = UN2_SUCCESSFUL *)
	      mud_change.mud_update_complete(real_sup, change_pointer);
	      done := TRUE;
	      major_delay_period := FIRST_CIRCUIT_RETRY_DELAY;
	      if not mud_change.any_mud_updates(real_sup)
	      then
	        begin (* release control of the circuit *)
		  aux_io.clear_circuit;
		  circuit_access[pseudo_sup].release_circuit;
		  mud_change.set_un2_activity_not_busy(real_sup)
	        end (* release control of the circuit *)
	    end (* status = UN2_SUCCESSFUL *)
	end (* loop until either mud change sent or sup not legal *);
    end (* change mud *);
  mud_change.continue_wait_for_stop_que(pseudo_sup)
$endif no_sup_updates
$if no_sup_updates
  if run_consistency
  then delay_utility.delay
  else
    begin (* change mud *)
      mud_utility.extract_cud_change(change_pointer, success, change.cud_info);
      if success
      then
        begin (* delay for a bit *)
	  end_delay_period := REALTIME + 5 (* usual 5 sec. to update Sup *);
	  repeat
	    wait
	  until REALTIME > end_delay_period
	end
      else crash_util.signal_process_error;
      mud_change.mud_update_complete(sup, change_pointer)
    end (* change mud *)
$endif no_sup_updates
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
end (* update mud *);


(************************************************************************)
(************************************************************************)

begin (* initial statement *)
  init mutil, aux_io(mutil),
    delay_utility(MUD_UPDATER_DELAY_INTERVAL, MUD_UPDATER_DELAY_INTERVAL),
    format, oper_messages(oplog, format),
    mud_update(MUD_UPDATE_FILE, statistics, file_system, oper_messages,
      format),
    sched_update(SCHEDTABLE_FILE, statistics, file_system, oper_messages,
	format),
$if INCLUDE_DNIC
    dnic_update(DNIC_FILE, statistics, file_system, oper_messages, format),
$endif INCLUDE_DNIC
    mud_utility(mutil, format, oper_messages, mud_update,
$if INCLUDE_DNIC      dnic_update,
      sched_update),
    dsksys(statistics),
    cud_utility(mutil, format, oper_messages),
    block_utility(mutil, oper_messages, format, dsksys),
    block_updater(mutil, statistics, dsksys, cud_access, block_utility,
      format)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if no_sup_updates ;
$ifnone no_sup_updates
,
    un2_util(aux_io, oper_messages, format, circuit_access, mud_change),
    consistency(mutil, mud_change, un2_util, circuit_access,
      block_updater, cud_utility, oper_messages, format, aux_io);
$endif no_sup_updates
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

    major_delay_period := FIRST_CIRCUIT_RETRY_DELAY;

  cycle
    update_mud
  end (* cycle *)
end (* mud_updater *);
$if INCLUDE_DNIC
!
(************************************************************************)
(*									*)
(*	DNICON.NTV							*)
(*									*)
(*			dnic_file_handler				*)
(*									*)
(*	This monitor controls access to the DNIC table files.		*)
(*									*)
(*      The following identifiers must be defined externally:		*)
(*	  dnic_table_in_pages, dnic_table_in_bytes, file_utility	*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	19Nov87 - Original -- neh					*)
(*									*)
(************************************************************************)



(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code
type DNIC_FILE_HANDLER = class(
$if logical_volumes	lv_dir	: logical_volume_directory;
	mutil		: misc_utility;
	dsksys		: disk_system;
	format		: internal_to_string;
	user_terminal	: circuit_handler);
$endif disk_maintenance_code
$ifnone disk_maintenance_code
type DNIC_FILE_HANDLER = monitor(
	statistics	: statistics_gatherer;
	file_system	: file_system_manager;
	oplog		: operator_log);


var
  format 		: internal_to_string;
  oper_msgs		: operator_messages;
  dnic_table_util	: file_utility;
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(*************************  dnic_file_handler  **************************)
(*									*)
(*			      do_write_dnic_table			*)
(*									*)
(*	Write the DNIC_FILE.						*)
(*									*)
(************************************************************************)

procedure do_write_dnic_table(
      location	: integer;
  var dnic_table: univ dnic_table_in_bytes;
  var success	: boolean);

$ifnone disk_maintenance_code
var
  io_status : file_utility_status;
$endif disk_maintenance_code

begin
$ifnone disk_maintenance_code
  dnic_table_util.write_dnic_file_data(location, dnic_table, io_status);
  success := io_status = FU_SUCCESS
$endif disk_maintenance_code
$if disk_maintenance_code
  dsksys.dnic_data_request(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if logical_volumes    lv_dir.files_unit,
$ifnone logical_volumes    FILE_SYSTEM_DISK,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    DISK_WRITE, DNIC_FILE_HEADER_START + location, dnic_table, success);
  if not success
  then format.report_file_error(DNIC_FILE, WRITING_MESSAGE,
    location, user_terminal)
$endif disk_maintenance_code
end (* do_write_dnic_table *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code



(*************************  dnic_file_handler  **************************)
(*									*)
(*			      write_dnic_table				*)
(*									*)
(*      Write an updated DNIC_FILE.					*)
(*									*)
(************************************************************************)

procedure entry WRITE_DNIC_TABLE(
  var dnic	: univ dnic_table_in_bytes;
  var success	: boolean);

begin
  do_write_dnic_table(DNIC_TABLE_ADDRESS, dnic, success)
end (* write_dnic_table *);



(*************************  dnic_file_handler  **************************)
(*									*)
(*				read_dnic_table				*)
(*									*)
(*      Return the DNIC table.						*)
(*									*)
(************************************************************************)

procedure entry READ_DNIC_TABLE(
  var dnic_table: univ dnic_table_in_bytes;
  var success	: boolean);


var
  io_status : file_utility_status;
  dnic_index : dnic_table_index;

begin
  dnic_table_util.read_dnic_file_data(DNIC_TABLE_ADDRESS,
    dnic_table, io_status);
  for dnic_index := (DNIC_TABLE_LIMIT - (2 * MAXIMUM_BYTES_IN_WORD))
    to DNIC_TABLE_LIMIT do
      dnic_table[dnic_index] := '(:0:)';
  success := io_status = FU_SUCCESS
end (* read_dnic_table *);



(*************************  dnic_file_handler  **************************)
(*									*)
(*			      write_dnic_data				*)
(*									*)
(*      Write an updated DNIC_FILE.					*)
(*									*)
(************************************************************************)

procedure entry WRITE_DNIC_DATA(
  var dnic_data	: univ dnic_table_in_bytes;
  var success	: boolean);

begin
  do_write_dnic_table(DNIC_FILE_START, dnic_data, success)
end (* write_dnic_data *);



(*************************  dnic_file_handler  **************************)
(*									*)
(*				read_dnic_data				*)
(*									*)
(*      Return the DNIC data.						*)
(*									*)
(************************************************************************)

procedure entry READ_DNIC_DATA(
  var dnic_data	: univ dnic_table_in_bytes;
  var success	: boolean);

var
  io_status : file_utility_status;

begin
  dnic_table_util.read_dnic_file_data(DNIC_FILE_START,
    dnic_data, io_status);
  success := io_status = FU_SUCCESS
end (* read_dnic_data *);
$endif disk_maintenance_code
$if disk_maintenance_code


(*************************  dnic_file_handler  **************************)
(*									*)
(*			      move_dnic_to_disc				*)
(*									*)
(*      Move entire DNIC file to disc.					*)
(*									*)
(************************************************************************)

procedure entry MOVE_DNIC_TO_DISC(
  var dnic	: univ dnic_file_data;
  var success	: boolean);

begin
  dsksys.page_request(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if logical_volumes    lv_dir.files_unit,
$ifnone logical_volumes    FILE_SYSTEM_DISK,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    DISK_WRITE, DNIC_FILE_HEADER_START, dnic.header, success);
  if not success
  then format.report_file_error(DNIC_FILE, WRITING_MESSAGE,
    DNIC_FILE_HEADER_START, user_terminal)
  else do_write_dnic_table(DNIC_FILE_START, dnic.data, success)
end (* move_dnic_to_disc *);


(*************************  dnic_file_handler  **************************)
(*									*)
(*			      new_dnic_table				*)
(*									*)
(*      Write an empty DNIC_FILE.					*)
(*									*)
(************************************************************************)

procedure entry NEW_DNIC_TABLE;

var
  dnic : dnic_table_in_pages;
  page_no : dnic_table_page_index;
  success : boolean;

begin
  for page_no := 0 to DNIC_TABLE_PAGE_LIMIT do
    mutil.clear_page(dnic[page_no]);
  do_write_dnic_table(DNIC_FILE_START, dnic, success);
  if success
  then user_terminal.write_quoted_text_line(
    '(:13:)(:10:)DNIC File initialized\')
end (* new_dnic_table *);
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)




(*************************************************************************)
(*************************************************************************)

begin (* initial statement *)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code
  init format,
    oper_msgs(oplog, format),
    dnic_table_util(DNIC_FILE, statistics, file_system, oper_msgs, format)
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
end (* dnic_file_handler *);
$endif INCLUDE_DNIC
!
(************************************************************************)
(*									*)
(*	SYMACC.NTV							*)
(*									*)
(*			 sysmsg1_access_manager				*)
(*									*)
(*	The sysmsg1_access_manager Monitor controls access to the	*)
(*	SYSMSG circuit.							*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*	24APR86 - rsb							*)
(*		- remove "+1" from after subtraction operation in 	*)
(*		  definition of MAXIMUM_SYSMSG1_USERS			*)
(*	10Oct83	Original -- jrn						*)
(*									*)
(************************************************************************)

type SYSMSG1_ACCESS_MANAGER = monitor;


(*	The following describes users of SYSMSG1.		*)
(*	Privileged validators and the CLASS_GROUP_UPDATER	*)
(*	Process are the only users.  The FIFO Class, NEXT,	*)
(*	which controls the ordered list of waiters for the	*)
(*	circuit is initialized with ORIGIN as			*)
(*	FIRST_SYSMSG1_USER, limit as MAXIMUM_SYSMSG1_USERS.	*)

const
  FIRST_SYSMSG1_USER = first_licensed_validator;
  TABLE_UPDATER_USER = validator_limit + 1;
  LAST_SYSMSG1_USER = table_updater_user;

  MAXIMUM_SYSMSG1_USERS = last_sysmsg1_user - first_sysmsg1_user;


type
  SYSMSG1_USER_INDEX = first_sysmsg1_user..last_sysmsg1_user;


var
  next : fifo;


(* The current circuit access: *)
  sysmsg1_available : boolean;



(* The following is the ordered list of waiters for the	*)
(* circuit.  Users are added to the list at fifo.arrival*)
(* and removed at fifo.departure.			*)

  waiting_for_circuit : array [sysmsg1_user_index] of queue;
!



(**********************  sysmsg1_access_manager  ************************)
(*									*)
(*			     access_circuit				*)
(*									*)
(*      Access the SYSMSG1 circuit.					*)
(*									*)
(************************************************************************)

procedure entry ACCESS_CIRCUIT;

begin
  if not sysmsg1_available
  then delay(waiting_for_circuit[next.arrival]) (* delay caller *);

  sysmsg1_available := FALSE (* user got the circuit *)
end (* access_circuit *);



(**********************  sysmsg1_access_manager  ************************)
(*									*)
(*			     release_circuit				*)
(*									*)
(*      Release the circuit.						*)
(*									*)
(************************************************************************)

procedure entry RELEASE_CIRCUIT;

begin
  sysmsg1_available := TRUE;
  if not next.empty
  then continue(waiting_for_circuit[next.departure])
end (* release_circuit *);



(************************************************************************)
(************************************************************************)

begin (* initial statement *)
  init next(FIRST_SYSMSG1_USER, MAXIMUM_SYSMSG1_USERS);

  sysmsg1_available := TRUE
end (* sysmsg1_access_manager *);
!
(************************************************************************)
(*									*)
(*	SYMUTL.NTV							*)
(*									*)
(*				sysmsg1_utility				*)
(*									*)
(*	The SYSMSG1_UTILITY Class communicates with the Supervisor	*)
(*	slave SYSMSG1 in order to transmit and recieve copies of the	*)
(*	Supervisor Class/group Table.					*)
(*									*)
(*      The following identifiers must be defined externally:		*)
(*	  real_supervisor_index, login_string, sysmsg1_user_index,	*)
(*	  table_in_chars						*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	05Nov87 - neh							*)
(*	      - add send and receive DNIC tables			*)
(*	23Oct86 - neh							*) 
(*	      - Change report_message to report_supervisor_message	*)
(*	21Jan86 - jrn							*)
(*	      - use control-I in login string				*)
(*	03Jan86	- rsb
(*		- every "sup : supervisor_index" changes into
(*                      "real_sup : real_supervisor_index"
(*		- every "sup" changes into "real_sup"
(*	06Jul84	Version 2.02 - jrn					*)
(*	      - add SYSMSG1_UNEXPECTED_INPUT to sysmsg1_status		*)
(*	11/10/83	Original -- jrn					*)
(*									*)
(************************************************************************)


type SYSMSG1_UTILITY = class(
	aux_io		: circuit_handler;
	format		: internal_to_string;
	oper_messages	: operator_messages;
	sysmsg1_access	: sysmsg1_access_manager);


const (* SYSMSG1 login string information: *)
  SYSMSG1_LOGIN_STRING_SIZE = 14 (* total size of string *);
  SYSMSG1_LOGIN_STRING_SUP_CHAR = 12 (* place to store sup no. *);

  SYSMSG1_LOGIN_STRING_TEXT =
    '(:9:)(:4:)SYSMSG1:12x;                                            ';


(* SYSMSG1 commands: *)
  SYSMSG1_RECEIVE_TABLE = '(:10:)';
  SYSMSG1_TRANSMIT_TABLE = '(:11:)';

  SYSMSG1_SEND_DNIC_TABLE = '(:21:)';
  SYSMSG1_RECEIVE_DNIC_TABLE = '(:22:)';

(* SYSMSG1 answer code: *)
  SYSMSG1_RECEIVED_TABLE = '(:6:)';


var
  circuit_util : circuit_utility;
!



(**************************  sysmsg1_utility  ***************************)
(*									*)
(*			      report_error				*)
(*									*)
(*      Report the status to the operator_log; if status is		*)
(*	SYSMSG1_CIRUIT_ERROR or SYSMSG1_BUILD_FAILURE, report		*)
(*	port_handler.param.status.					*)
(*									*)
(************************************************************************)

procedure report_error(
      real_sup	: real_supervisor_index;
      status	:  sysmsg1_status);

begin
  format.start;
  format.sysmsg1_error(status, aux_io.param.status,
    aux_io.param.arg2);
  oper_messages.report_supervisor_message(real_sup, SYSMSG1_OPLOG_MSG)
end (* report_error *);



(**************************  sysmsg1_utility  ***************************)
(*									*)
(*			   check_circuit_status				*)
(*									*)
(*      Set sysmsg_status if there is a circuit problem.		*)
(*									*)
(************************************************************************)

procedure check_circuit_status(
      real_sup          : real_supervisor_index;
      error_status	: sysmsg1_status;
  var status		: sysmsg1_status);

begin
  if not aux_io.available
  then
    begin
      status := error_status;
      report_error(real_sup, status)
    end
end (* check_circuit_status *);



(**************************  sysmsg1_utility  ***************************)
(*									*)
(*			  build_sysmsg1_circuit				*)
(*									*)
(*      Build a circuit to SYSMSG1 for the supervisor.			*)
(*									*)
(************************************************************************)

procedure build_sysmsg1_circuit(
      real_sup  : real_supervisor_index;
  var status	: sysmsg1_status);

var
  login : login_string;
  receive_buffer : char;

begin
  status := SYSMSG1_SUCCESSFUL;
  sysmsg1_access.access_circuit;
  login.size := SYSMSG1_LOGIN_STRING_SIZE;
  login.text := SYSMSG1_LOGIN_STRING_TEXT;
  login.text[SYSMSG1_LOGIN_STRING_SUP_CHAR] := chr(ord('0') + real_sup);
  aux_io.build_aux_circuit(SYSMSG_CIRCUIT, [COMPLETE], 60, login);
  aux_io.set_timeout(300);
  check_circuit_status(real_sup, SYSMSG1_BUILD_FAILURE, status);
  if status = SYSMSG1_SUCCESSFUL
  then
    begin
      circuit_util.exchange_handshake(STANDARD_HANDSHAKE);
      check_circuit_status(real_sup, SYSMSG1_HANDSHAKE_ERROR, status);
      if status = SYSMSG1_SUCCESSFUL
      then
        begin
	  aux_io.read_one_character(receive_buffer);
	  check_circuit_status(real_sup, SYSMSG1_HANDSHAKE_ERROR, status);
	  if ord(receive_buffer) <> (real_sup + PRINT_SUPERVISOR_OFFSET)
	  then status := SYSMSG1_HANDSHAKE_ERROR
	end
    end;
  if status <> SYSMSG1_SUCCESSFUL
  then sysmsg1_access.release_circuit
end (* build_sysmsg1_circuit *);



(**************************  sysmsg1_utility  ***************************)
(*									*)
(*			    send_table_to_sup				*)
(*									*)
(*      Transmit a new Class/group table to a Supervisor.		*)
(*									*)
(************************************************************************)

procedure entry SEND_TABLE_TO_SUP(
      real_sup	: real_supervisor_index;
  var new_table	: univ table_in_bytes;
  var status	: sysmsg1_status);

var
  byte_input : char;

begin 
  build_sysmsg1_circuit(real_sup, status);
  if status = SYSMSG1_SUCCESSFUL
  then
    begin
      aux_io.write_one_character(SYSMSG1_TRANSMIT_TABLE);
      check_circuit_status(real_sup, SYSMSG1_CIRCUIT_ERROR, status);
      if status = SYSMSG1_SUCCESSFUL
      then
        begin
          aux_io.write_class_group_table(new_table);
          check_circuit_status(real_sup, SYSMSG1_CIRCUIT_ERROR, status)
        end;
      if status = SYSMSG1_SUCCESSFUL
      then

(*      Input a character, check the circuit and be sure character	*)
(*	is SYSMSG1_RECEIVED_TABLE; if error, set status and report	*)
(*	the error.							*)

        begin
	  aux_io.read_one_character(byte_input);
	  check_circuit_status(real_sup, SYSMSG1_CIRCUIT_ERROR, status);
	  if (status = SYSMSG1_SUCCESSFUL) and
	    (byte_input <> SYSMSG1_RECEIVED_TABLE)
	  then
	    begin
	      status := SYSMSG1_UNEXPECTED_INPUT;
	      report_error(real_sup, status)
	    end
	end;

      aux_io.clear_circuit;
      sysmsg1_access.release_circuit
    end
end (* send_table_to_sup *);



(**************************  sysmsg1_utility  ***************************)
(*									*)
(*			     read_sup_table				*)
(*									*)
(*      Return the Class/group table for a Supervisor.			*)
(*									*)
(************************************************************************)

procedure entry READ_SUP_TABLE(
      real_sup  : real_supervisor_index;
  var table	: univ table_in_bytes;
  var status	: sysmsg1_status);

begin
  build_sysmsg1_circuit(real_sup, status);
  if status = SYSMSG1_SUCCESSFUL
  then
    begin
      aux_io.write_one_character(SYSMSG1_RECEIVE_TABLE);
      check_circuit_status(real_sup, SYSMSG1_CIRCUIT_ERROR, status);
      if status = SYSMSG1_SUCCESSFUL
      then
        begin
          aux_io.read_class_group_table(table);
          check_circuit_status(real_sup, SYSMSG1_CIRCUIT_ERROR, status)
        end;
      aux_io.clear_circuit;
      sysmsg1_access.release_circuit
    end
end (* read_sup_table *);
$if INCLUDE_DNIC


(**************************  sysmsg1_utility  ***************************)
(*									*)
(*			    send_dnic_to_sup				*)
(*									*)
(*      Transmit a new dnic table to a Supervisor.			*)
(*									*)
(************************************************************************)

procedure entry SEND_DNIC_TO_SUP(
      real_sup	: real_supervisor_index;
  var new_dnic	: univ dnic_table_in_bytes;
  var status	: sysmsg1_status);

var
  byte_input : char;

begin 
  build_sysmsg1_circuit(real_sup, status);
  if status = SYSMSG1_SUCCESSFUL
  then
    begin
      aux_io.write_one_character(SYSMSG1_SEND_DNIC_TABLE);
      check_circuit_status(real_sup, SYSMSG1_CIRCUIT_ERROR, status);
      if status = SYSMSG1_SUCCESSFUL
      then
        begin
          aux_io.write_dnic_table(new_dnic);
          check_circuit_status(real_sup, SYSMSG1_CIRCUIT_ERROR, status)
        end;
      if status = SYSMSG1_SUCCESSFUL
      then

(*      Input a character, check the circuit and be sure character	*)
(*	is SYSMSG1_RECEIVED_TABLE; if error, set status and report	*)
(*	the error.							*)

        begin
	  aux_io.read_one_character(byte_input);
	  check_circuit_status(real_sup, SYSMSG1_CIRCUIT_ERROR, status);
	  if (status = SYSMSG1_SUCCESSFUL) and
	    (byte_input <> SYSMSG1_RECEIVED_TABLE)
	  then
	    begin
	      status := SYSMSG1_UNEXPECTED_INPUT;
	      report_error(real_sup, status)
	    end
	end;

      aux_io.clear_circuit;
      sysmsg1_access.release_circuit
    end
end (* send_dnic_to_sup *);



(**************************  sysmsg1_utility  ***************************)
(*									*)
(*			     read_sup_dnic				*)
(*									*)
(*      Return the Class/group dnic for a Supervisor.			*)
(*									*)
(************************************************************************)

procedure entry READ_SUP_DNIC(
      real_sup  : real_supervisor_index;
  var dnic_table: univ dnic_table_in_bytes;
  var status	: sysmsg1_status);

begin
  build_sysmsg1_circuit(real_sup, status);
  if status = SYSMSG1_SUCCESSFUL
  then
    begin
      aux_io.write_one_character(SYSMSG1_RECEIVE_DNIC_TABLE);
      check_circuit_status(real_sup, SYSMSG1_CIRCUIT_ERROR, status);
      if status = SYSMSG1_SUCCESSFUL
      then
        begin
          aux_io.read_dnic_table(dnic_table);
          check_circuit_status(real_sup, SYSMSG1_CIRCUIT_ERROR, status)
        end;
      aux_io.clear_circuit;
      sysmsg1_access.release_circuit
    end
end (* read_sup_dnic *);
$endif INCLUDE_DNIC


(************************************************************************)
(************************************************************************)

begin (* initial statement *)
  init circuit_util(aux_io)
end (* sysmsg1_utility *);
!
(************************************************************************)
(*									*)
(*	SYMUPD.NTV							*)
(*									*)
(*			    sysmsg1_updater				*)
(*									*)
(*	The sysmsg1_updater Process is responsible for updating		*)
(*	the Supervisor Class/group and DNIC tables.			*)
(*									*)
		(* Previously class_group_updater, cgupd.ntv. *)
(*									*)
(*      The following identifiers must be defined externally:		*)
(*	  supervisor_index, table_in_bytes, dnic_table_in_bytes,	*)
(*	  sysmsg1_status						*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	09Nov87 - neh							*)
(*	      - add parameter dnic_access				*)
(*	      - change update_class_group_tables to			*)
(*		update_sysmsg1_tables, include update DNIC tables	*)
(*	06Jan86	- rsb							*)
(*		- every "sup : supervisor_index" changes into		*)
(*                      "real_sup : real_supervisor_index"		*)
(*		- every "sup" changes into "real_sup"			*)
(*		- Loop counter changes from MAXIMUM_EXPECTED_SUPERVISOR	*)
(*		  to MAXIMUM_REAL_SUPERVISOR.				*)
(*	21Jul84 Version 3.00 - jrn/pgl					*)
(*	      - added parameter values of FIRST_CIRCUIT_RETRY_DELAY	*)
(*		and MAXIMUM_CIRCUIT_RETRY_DELAY to init of 		*)
(*		delay_utility						*)
(*	11Oct83	Original -- jrn						*)
(*									*)
(************************************************************************)

type sysmsg1_updater = process(
	oplog		: operator_log;
	mud_change	: mud_change_handler;
	sysmsg1_access	: sysmsg1_access_manager;
$if INCLUDE_DNIC	dnic_access	: dnic_file_handler;
	table_access	: class_group_handler);


var
  mutil         : misc_utility;
  delay_utility : circuit_delay_utility;
  aux_io        : circuit_handler;
  format        : internal_to_string;
  oper_messages : operator_messages;
  sysmsg1_util  : sysmsg1_utility;
!
(***************************  symsg1_updater  ***************************)
(*									*)
(*			  update_sysmsg1_tables				*)
(*									*)
(*      This is the main control loop.  The mud_change_handler is	*)
(*	checked for legal supervisors and out-of-date tables.		*)
(*									*)
(************************************************************************)

procedure update_sysmsg1_tables;

var
  real_sup : real_supervisor_index;
  table : table_in_bytes;
  no_failure, (* TRUE if no updates necessary or all were successful *)
  success : boolean;
  status : sysmsg1_status;
$if INCLUDE_DNIC
  no_dnic_fail : boolean (* TRUE if no need to update DNIC *);
  dnic : dnic_table_in_bytes;
$endif INCLUDE_DNIC

begin
  cycle
    no_failure := TRUE;
$if INCLUDE_DNIC
    no_dnic_fail := TRUE;
    if not mud_change.all_dnic_sent
    then for real_sup := FIRST_SUPERVISOR to MAXIMUM_REAL_SUPERVISOR do
      begin
        success := TRUE;
        if mud_change.dnic_to_send(real_sup)
        then
          begin (* get and send table to Supervisor *)
	    dnic_access.read_dnic_table(dnic, success);
	    if success
	    then

(*      Transmit the dnic to the supervisor, and notify the		*)
(*	mud_change_handler of the result.  Set success to FALSE		*)
(*	if failure.							*)

	      begin (* got dnic, send it *)
		sysmsg1_util.send_dnic_to_sup(real_sup, dnic, status);
		success := status = SYSMSG1_SUCCESSFUL;
		if success
		then mud_change.set_sup_dnic_status(
                                             real_sup, DNIC_UPDATED)
		else mud_change.set_sup_dnic_status(
                                             real_sup, DNIC_UPDATE_FAILED)
	      end (* got dnic, send it *)
	  end (* get and send dnic to Supervisor *);
	if not success
	then no_dnic_fail := FALSE;
      end (* not all_dnic_sent *);
$endif INCLUDE_DNIC
    for real_sup := FIRST_SUPERVISOR to MAXIMUM_REAL_SUPERVISOR do
      begin
        success := TRUE;
        if mud_change.table_to_send(real_sup)
        then
          begin (* get and send table to Supervisor *)
	    table_access.read_table(table, success);
	    if success
	    then

(*      Transmit the table to the supervisor, and notify the		*)
(*	mud_change_handler of the result.  Set success to FALSE		*)
(*	if failure.							*)

	      begin (* got table, send it *)
		sysmsg1_util.send_table_to_sup(real_sup, table, status);
		success := status = SYSMSG1_SUCCESSFUL;
		if success
		then mud_change.set_sup_table_status(
                                             real_sup, CLASS_GROUP_UPDATED)
		else mud_change.set_sup_table_status(
                                             real_sup, CLASS_GROUP_FAILED)
	      end (* got table, send it *)
	  end (* get and send table to Supervisor *);
	if not success
	then no_failure := FALSE
      end (* for *);

    if no_failure
$if INCLUDE_DNIC    or no_dnic_fail
    then delay_utility.reset_delay;
    delay_utility.delay
  end (* cycle *)
end (* update_sysmsg1_tables *);



(************************************************************************)
(************************************************************************)

begin (* initial statement *)
  init mutil, delay_utility(FIRST_CIRCUIT_RETRY_DELAY, SEND_TABLE_DELAY),
    aux_io(mutil), format, oper_messages(oplog, format),
    sysmsg1_util(aux_io, format, oper_messages, sysmsg1_access);

  update_sysmsg1_tables
end (* sysmsg1_updater *);
!
(************************************************************************)
(*									*)
(*	logutl.ntv							*)
(*									*)
(*				LOGIN_UTILITY				*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	Original - jrn							*)
(*									*)
(************************************************************************)

type login_utility = class(
	mutil		: misc_utility;
	user_terminal	: circuit_handler;
	format		: internal_to_string
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code	);
$ifnone disk_maintenance_code
;
	login_pool	: login_distributer);
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)


var
  entry unit : terminal_unit_index;



(**************************  login_utility  *****************************)
(*									*)
(*			       access_denied				*)
(*									*)
(************************************************************************)

procedure entry ACCESS_DENIED(
      deny_message	: quoted_text);

begin
  user_terminal.write_line_and_quoted_text_line(DENY_MESSAGE);
  user_terminal.wait_for_output;
  user_terminal.clear_circuit;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code   login_pool.release_unit(unit)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
end (* access_denied *);



(**************************  login_utility  *****************************)
(*									*)
(*				get_login				*)
(*									*)
(************************************************************************)

procedure entry GET_LOGIN(
  var name	: username_string;
  var needle	: needle_record);

var
  name_pointer : username_text_index;
  needle_pointer : needle_name_index;
  first_needle_char : needle_name_index;

begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code   unit := 0;
$ifnone disk_maintenance_code   login_pool.get_available_unit(unit);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  user_terminal.login(unit, [COMPLETE, BREAK_KEY, ORANGE_BALL], needle);

(*	Translate the needle name (already in UPPER case) to a		*)
(*	username_string.  The needle.number_of_characters includes	*)
(*	a carriage-return character at the end; if the user has "login	*)
(*	over shut", there will be a leading "!" character in the name,	*)
(*	so ignore it.							*)

  if needle.login_name[0] = '!'
  then first_needle_char := 1 (* user has login over shut option *)
  else first_needle_char := 0;
  name.size := needle.number_of_characters - first_needle_char - 1;
  name_pointer := 0;
  for needle_pointer := first_needle_char to
    needle.number_of_characters - 2 do
    begin
      name.text[name_pointer] := needle.login_name[needle_pointer];
      name_pointer := name_pointer + 1
    end
end (* get_login *);



(************************************************************************)
(************************************************************************)

begin (* initial statement *)
end (* login_utility *);
!
(************************************************************************)
(*									*)
(*	LOGONP.NTV							*)
(*									*)
(*				ACCEPT_LOGIN				*)
(*									*)
(*      The following identifiers must be defined externally:		*)
(*	  terminal_unit_index, username_string, validator_index,	*)
(*	  validator_type, circuit_handler				*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	03Oct88 - jrn							*)
(*		- add code for password_expiration_date_in_cud		*)
(*		- use small_cud_entry to retrieve CUD info		*)
(*	12Aug87 - neh 5.00						*)
(*	      - add BEFORE_SUP_V43 flag					*)
(*	      - include global_password login				*)
(*	21Jul86 - jrn							*)
(*	      - if user is logging in with an auxilliary circuit,	*)
(*		prompt and check for password				*)
(*	08Jan86 - jrn							*)
(*	      - remove UPDATE_TYMCOM_LUDS				*)
(*	09Dec85 - jrn							*)
(*	      - remove ASSIGN_CUSTOMER_NUMBERS_FROM_TYMCOM_IX		*)
(*	11Dec84 - jrn							*)
(*	      - move code to login_utility for use by initial process	*)
(*		for logical volumes					*)
(*	04Aug84 jrn/pgl							*)
(*	      - removed functions, user_is_operator and 		*)
(*		user_is_programmer					*)
(*	      - added function name_match				*)
(*	      - changed procedure process_validator_login to handle	*)
(*		MASTER_VALIDATOR					*)
(*	15Jun84 jrn							*)
(*	      - removed oper_messages from initialization of		*)
(*		cud_block_updater					*)
(*	14Apr84 Version 2.02	jrn					*)
(*	      - added licenses (passes options to login monitor)	*)
(*		Original -- jrn						*)
(*									*)
(************************************************************************)

(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code
type ACCEPT_LOGIN = process(
	statistics	: statistics_gatherer;
	oplog		: operator_log;
	mud_change	: mud_change_handler;
	cud_access	: cud_access_controller;
	cud_parameter	: cud_parameter_controller;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifall (overflow_cud_entries, BEFORE_SUP_V43)
	overflow_controller	: cud_overflow_controller;
$endif (overflow_cud_entries, BEFORE_SUP_V43)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	name_access	: cud_name_controller;
	login_pool	: login_distributer);


var
  mutil		: misc_utility;
  user_terminal : circuit_handler;
  format	: internal_to_string;
  log_util	: login_utility;
  oper_messages	: operator_messages;

  dsksys	: disk_system;
  block_updater : cud_block_updater;
  block_utility : cud_block_utility;
  cud_utility	: cud_entry_utility;
$if BEFORE_SUP_V43   cud_updater	: cud_entry_updater;
$ifnone BEFORE_SUP_V43
  cud_updater	: mud_entry_updater;
  list_utility	: node_host_list_utility;
$endif BEFORE_SUP_V43
  password_read	: password_reader;
$endif disk_maintenance_code
$if disk_maintenance_code
type ACCEPT_LOGIN = class(
	user_terminal	: circuit_handler;
	mutil		: misc_utility);


var
  log_util	: login_utility;
  format	: internal_to_string;
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code



(***************************  accept_login  *****************************)
(*									*)
(*			aux_circuit_password_ok				*)
(*									*)
(************************************************************************)

function aux_circuit_password_ok(
      cipher		: integer (* user's cipher from CUD entry *);
      login_info	: validator_login_information) : boolean;

begin
  aux_circuit_password_ok := TRUE;
  if (ord(login_info.needle.terminal_id) mod 64) = 0
  then (* logging in on AUX CIRCUIT *)
    if password_read.ciphered_password <> cipher
    then
      begin (* illegal password entered *)
	log_util.access_denied(PASSWORD_ERROR);
	aux_circuit_password_ok := FALSE
      end (* illegal password entered *);
end (*  aux_circuit_password_ok *);



(***************************  accept_login  *****************************)
(*									*)
(*		      report_validator_not_in_cud			*)
(*									*)
(************************************************************************)

procedure report_validator_not_in_cud;

begin
  if cud_updater.last_status = CUD_ENTRY_NOT_FOUND
  then log_util.access_denied('your username is not in the CUD\')
  else
    begin (* cud_updater.last_status <> CUD_ENTRY_NOT_FOUND *)
      format.start;
      format.cud_entry_status(cud_updater.last_status);
      format.write_line(user_terminal)
    end (* cud_updater.last_status <> CUD_ENTRY_NOT_FOUND *);
end (* report_validator_not_in_cud *);



(***************************  accept_login  *****************************)
(*									*)
(*			  store_profile_info				*)
(*									*)
(************************************************************************)

procedure store_profile_info(
      cud_entry	: small_cud_entry;
  var login_info: validator_login_information);

begin
  login_info.level := PASSWORD_ONLY_VALIDATOR;
  login_info.unit := log_util.unit;
  login_info.gan := cud_entry.gan;
$if BEFORE_SUP_V43   login_info.options := cud_entry.options;
$ifnone BEFORE_SUP_V43
  login_info.mud_options := cud_entry.options;
  login_info.options := cud_entry.nud_options
$endif BEFORE_SUP_V43
end (* store_profile_info *);



(***************************  accept_login  *****************************)
(*									*)
(*			set_programmer_info				*)
(*									*)
(************************************************************************)

procedure set_programmer_info(
  var login_info	: validator_login_information);

begin
  login_info.level := PROGRAMMER_VALIDATOR;
  login_info.unit := log_util.unit;
  login_info.gan := 0;
$ifnone BEFORE_SUP_V43   login_info.mud_options := [];
  login_info.options := []
end (* set_programmer_info *);



(***************************  accept_login  *****************************)
(*									*)
(*			process_validator_login				*)
(*									*)
(************************************************************************)

procedure process_validator_login;

var
  login_info : validator_login_information;
  valid_netval_user : boolean;
  success : boolean;
  programmer : boolean;
  cud_entry : small_cud_entry;

begin
  valid_netval_user := TRUE;
  log_util.get_login(login_info.name, login_info.needle);
  programmer := mutil.same_name(PROGRAMMER_NAME,
    PROGRAMMER_NAME_SIZE, login_info.name);
  cud_entry.name := login_info.name;
  cud_updater.read_small_cud_entry(cud_entry);
  if cud_updater.last_status <> CUD_ENTRY_OK
  then
    begin (* allow programmer to login if cud entry bad and not aux circuit *)
      valid_netval_user := programmer and
       ((ord(login_info.needle.terminal_id) mod 64) <> 0);
      if not valid_netval_user
      then report_validator_not_in_cud
    end
  else
    begin (* cud_updater.last_status = CUD_ENTRY_OK *)
      (* copy cud info to login info and set level to PASSWORD_ONLY_VALIDATOR *)
      store_profile_info(cud_entry, login_info);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if password_expiration_date_in_cud
$if allow_password_only
      if (cud_entry.expire_date > 0) and (cud_entry.expire_date < REALTIME)
      then
	begin (* user's password has expired *)
	  programmer := FALSE (* not allowed as prog if password expired *);
	  login_info.options := login_info.options - [AUDITOR, OPERATOR]
	end (* user's password has expired *)
      else
$endif allow_password_only
$endif password_expiration_date_in_cud
$if netval_is_a_slave
      if mutil.same_name(MASTER_VALIDATOR_NAME, MASTER_VALIDATOR_NAME_SIZE,
        cud_entry.name)
      then login_info.level := MASTER_VALIDATOR
      else
$endif NETVAL_IS_A_SLAVE
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      if aux_circuit_password_ok(cud_entry.cipher, login_info)
	and not programmer
      then (* non-programmer logging in, check CUD info *)
        begin (* process any other type of user logging in *)
$if global_password_only_login
	  if mutil.same_name(GPO_NAME, GPO_NAME_SIZE, cud_entry.name)
	  then login_info.level := GPO_VALIDATOR
	  else
$endif global_password_only_login
	  if NETWORK_ADMINISTRATOR in login_info.options
	  then login_info.level := NETWORK_ADMINISTRATOR_VALIDATOR
	  else
	    if ACCOUNT_SUPERVISOR in login_info.options
	    then login_info.level := ACCOUNT_SUPERVISOR_VALIDATOR
	    else
              with login_info do
$ifnone BEFORE_SUP_V43 		  if (NO_PASSWORD_REQUIRED in mud_options)
$if BEFORE_SUP_V43 		  if (NO_PASSWORD_REQUIRED in options)
$if no_password_only_validators
		  or (not (AUDITOR in options) and not (OPERATOR in options))
$endif no_password_only_validators
		then valid_netval_user := FALSE
	end (* process any other type of user logging in *);
    end (*  cud_updater.last_status = CUD_ENTRY_OK *);
  if valid_netval_user
  then
    begin
      if programmer
      then set_programmer_info(login_info);
      login_pool.login_validator(login_info, success);
      if not success
      then log_util.access_denied('no port available\')
    end (* valid_netval_user *)
  else log_util.access_denied('you are not valid to use NETVAL\')
end (* process_validator_login *);
$endif disk_maintenance_code
$if disk_maintenance_code



(***************************  accept_login  *****************************)
(*									*)
(*			process_validator_login				*)
(*									*)
(************************************************************************)

procedure entry PROCESS_VALIDATOR_LOGIN(
  var needle	: needle_record;
  var name	: username_string;
  var level	: validator_type);

var
  valid_netval_user : boolean;

begin
  repeat
    log_util.get_login(name, needle);
    valid_netval_user := TRUE;
    if mutil.same_name(PROGRAMMER_NAME, PROGRAMMER_NAME_SIZE, name)
    then level := PROGRAMMER_VALIDATOR
    else
      if mutil.same_name(NVDM_OPERATOR_NAME, NVDM_OPERATOR_NAME_SIZE, name)
      then level := PASSWORD_ONLY_VALIDATOR
      else
        begin
	  valid_netval_user := FALSE;
	  log_util.access_denied('Netval is currently unavailable\')
	end
  until valid_netval_user
end (* process_validator_login *);
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(************************************************************************)
(************************************************************************)

begin (* initial statement *)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code
  init format, log_util(mutil, user_terminal, format)
$endif disk_maintenance_code
$ifnone disk_maintenance_code
  init mutil, user_terminal(mutil), format,
    log_util(mutil, user_terminal, format, login_pool),
    oper_messages(oplog, format),
    dsksys(statistics),
    block_utility(mutil, oper_messages, format, dsksys),
    block_updater(mutil, statistics, dsksys, cud_access, block_utility,
      format),
    cud_utility(mutil, format, oper_messages),
    cud_updater(CUD_READER, mutil, format, login_pool, mud_change,
      oper_messages,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifall (overflow_cud_entries, BEFORE_SUP_V43)     overflow_controller,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      cud_utility, cud_access, block_updater,
$ifnone BEFORE_SUP_V43       list_utility,     
      cud_parameter, name_access),
    password_read(mutil, format, user_terminal);

  cycle
    process_validator_login
  end (* cycle *)
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
end (* accept_login *);
!
(************************************************************************)
(*									*)
(*	CONUTL.NTV							*)
(*									*)
(*		    configuration_utility class				*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	17Oct88 - jrn							*)
(*		- fixed a format error (right/left parens switched)	*)
(*	19Nov87 - neh							*)
(*            - add code to include DNIC table definiton.               *)
(*	      - remove creation date from file_index			*)
(*	27Apr87 - neh							*)
(*	      - change CHECK_CONFIGURATION to print results		*)
		(*		merge 4.00 and 5.00 neh        *)
(*	19Mar87 - rsb                                                   *)
(*            - add code to DO_GET_PROGRAM_FILE_DEFINITION to deal      *)
(*              with Passtable.                                         *)
(*            - Have display_disk_configuration use                     *)
(*              CUD_MUD_BUFFER_LOCATION instead of                      *)
(*              CUD_BUFFER_LOCATION, in order to match a change to      *)
(*              the file name made in fildef.ntv                        *)
(*	19Dec85 - jrn							*)
(*	      - change sys_io.tym_file_terminal_count to		*)
(*		sys_io.sys_info.number_of_terminals, and		*)
(*		sys_io.tym_file_aux_circuit_count to			*)
(*		sys_io.sys_info.number_of_aux_circuits			*)
(*	04Jan85 - jrn							*)
(*	      - add all common configuration checking code here for use	*)
(*		in both NETVAL and NVDM					*)
(*	      - add logical_volume_directory				*)
(*	13Aug84 - jrn							*)
(*	      - handle all configuration file operations here		*)
(*	      - make configuration comparasion routines available	*)
(*		to archive class					*)
(*									*)
(************************************************************************)


type configuration_utility = class(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code
		user_terminal	: circuit_handler;
		format		: internal_to_string;
$if logical_volumes	lv_dir	: logical_volume_directory;
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
		dsksys		: disk_system;
		sys_io		: system_handler);


(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code
const
  CLASS_0_GROUP_0_ASSIGNABLE_MESSAGE = 'CLASS_0_GROUP_0_ASSIGNABLE\ ';
  CURRENT_INCARNATION_MESSAGE = 'CURRENT_INCARNATION\';
  DISK_UNIT_ONE_SIZE_MESSAGE = 'DISK_UNIT_ONE_SIZE\ ';
  DISK_UNIT_ZERO_SIZE_MESSAGE = 'DISK_UNIT_ZERO_SIZE\';
  DOES_NOT_MATCH_DISK_VALUE_MESSAGE = ') does not match disk value\';
  FALSE_MESSAGE = 'FALSE\';
  INCLUDE_DISTRICT_MESSAGE = 'INCLUDE_DISTRICT\ ';
  INCLUDE_GAN_MESSAGE = 'INCLUDE_GAN\';
  MAXIMUM_CLASS_TABLE_SIZE_MESSAGE = 'MAXIMUM_CLASS_TABLE_SIZE\ ';
  MAXIMUM_CUD_BLOCK_MESSAGE = 'MAXIMUM_CUD_BLOCK\';
  MAXIMUM_CUD_BLOCK_SIZE_IN_SECTORS_MESSAGE =
    'MAXIMUM_CUD_BLOCK_SIZE_IN_SECTORS\';
$if INCLUDE_DNIC
  MAXIMUM_DNIC_TABLE_SIZE_MESSAGE = 'MAXIMUM_DNIC_TABLE_SIZE\';
$endif INCLUDE_DNIC
  MAXIMUM_EXPECTED_SUPERVISORS_MESSAGE = 'MAXIMUM_EXPECTED_SUPERVISORS\ ';
  MAXIMUM_GROUP_TABLE_SIZE_MESSAGE = 'MAXIMUM_GROUP_TABLE_SIZE\ ';
  MAXIMUM_HOST_MESSAGE = 'MAXIMUM_HOST\ ';
  MAXIMUM_NODE_MESSAGE = 'MAXIMUM_NODE\ ';
  MAXIMUM_VALIDATOR_MESSAGE = 'MAXIMUM_VALIDATOR\';
  MINIMUM_PASSWORD_SIZE_MESSAGE = 'MINIMUM_PASSWORD_SIZE\';
$ifnone BEFORE_SUP_V43  MUD_VERSION_MESSAGE = 'MUD_SUP_VERSION\';
$if BEFORE_SUP_V43  NETVAL_CUD_IS_A_MUD_MESSAGE = 'NETVAL_CUD_IS_A_MUD\';
  OPEN_PARENS_MESSAGE = ' (\ ';
  PROGRAMMER_NAME_MESSAGE = 'PROGRAMMER_NAME\';
  PROGRAMMER_NAME_SIZE_MESSAGE = 'PROGRAMMER_NAME_SIZE\ ';
  REQUIRE_NONALPHANUMERIC_MESSAGE = 'REQUIRE_NONALPHANUMERIC\';
  TRUE_MESSAGE = 'TRUE\ ';
  UNIT_NUMBER_MESSAGE = '  unit number\';
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)


var
  dummy : integer (* to make conditional compliation flags correct *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code   crash_util : crash_utility;
$if logical_volumes   lv_utility : lvol_utility;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
(**********************  configuration_utility  *************************)
(*									*)
(*		     	    file_checksum				*)
(*									*)
(************************************************************************)

procedure file_checksum(
  var configuration	: univ configuration_information;
  var computed_checksum	: integer);

begin
  sys_io.page_checksum(PAGE_SIZE - MAXIMUM_BYTES_IN_WORD, configuration,
    computed_checksum)
end (* file_checksum *);



(**********************  configuration_utility  *************************)
(*									*)
(*		     	    do_read_file				*)
(*									*)
(************************************************************************)

procedure do_read_file(
  var configuration	: univ configuration_information;
  var status		: file_utility_status);

var
  computed_checksum : integer;
  success : boolean;

begin
  status := FU_SUCCESS;
  dsksys.page_request(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code
$if logical_volumes     lv_dir.files_unit,
$ifnone logical_volumes     FILE_SYSTEM_DISK,
    DISK_READ,
$endif disk_maintenance_code
$ifnone disk_maintenance_code
    FILE_SYSTEM_DISK,
$if logical_volumes     LVOL_READ,
$ifnone logical_volumes     DISK_READ,
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    CONFIGURATION_FILE_START, configuration, success);
  if success
  then
    begin
      file_checksum(configuration, computed_checksum);
      success := computed_checksum = configuration.checksum;
      if not success
      then
        begin
	  status := FU_CHECKSUM_ERROR;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code
	  user_terminal.write_quoted_text_line(
           'checksum error reading configuration file\')
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	end
    end
  else
    begin
      status := FU_IO_ERROR;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code
      format.report_file_error(CONFIGURATION_FILE, READING_MESSAGE, 0,
        user_terminal)
    end
$endif disk_maintenance_code
$ifnone disk_maintenance_code    end
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
end (* do_read_file *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code



(**********************  configuration_utility  *************************)
(*									*)
(*		     	     read_file					*)
(*									*)
(************************************************************************)

procedure entry READ_FILE(
  var configuration	: univ configuration_information;
  var status		: file_utility_status);

begin
  do_read_file(configuration, status)
end (* read_file *);
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(**********************  configuration_utility  *************************)
(*									*)
(*		     do_get_program_file_definition			*)
(*									*)
(************************************************************************)

procedure do_get_program_file_definition(
      index		: file_index;
  var defined_desc	: file_descriptor);

begin
  case index of
    CONFIGURATION_FILE:
      begin
        defined_desc.unit := FILE_SYSTEM_DISK;
	defined_desc.address := CONFIGURATION_FILE_START;
	defined_desc.length := CONFIGURATION_FILE_LENGTH
      end (* CONFIGURATION_FILE *);
    CUD_FILE:
      begin
        defined_desc.unit := CUD_DISK_UNIT;
	defined_desc.address := CUD_FILE_START;
	defined_desc.length := CUD_FILE_LENGTH
      end (* CUD_FILE *);
    CUD_PARAMETER_FILE:
      begin
        defined_desc.unit := CUD_DISK_UNIT;
	defined_desc.address := CUD_PARAMETER_FILE_START;
	defined_desc.length := CUD_PARAMETER_FILE_LENGTH
      end (* CUD_PARAMETER_FILE *);
    NODE_HOST_FILE:
      begin
        defined_desc.unit := FILE_SYSTEM_DISK;
	defined_desc.address := NODE_HOST_FILE_START;
	defined_desc.length := NODE_HOST_FILE_LENGTH
      end (* NODE_HOST_FILE *);
    MUD_UPDATE_FILE:
      begin
        defined_desc.unit := FILE_SYSTEM_DISK;
	defined_desc.address := MUD_UPDATE_FILE_START;
	defined_desc.length := MUD_UPDATE_FILE_LENGTH
      end (* MUD_UPDATE_FILE *);
    CLASS_GROUP_FILE:
      begin
        defined_desc.unit := FILE_SYSTEM_DISK;
	defined_desc.address := CLASS_GROUP_FILE_START;
	defined_desc.length := CLASS_GROUP_FILE_LENGTH
      end (* CLASS_GROUP_FILE *);
$if INCLUDE_DNIC
    DNIC_FILE:
      begin
        defined_desc.unit := FILE_SYSTEM_DISK;
	defined_desc.address := DNIC_FILE_HEADER_START;
	defined_desc.length := DNIC_FILE_HEADER_LENGTH + DNIC_FILE_DATA_LENGTH +
	  DNIC_BUFFER_LENGTH
      end (* DNIC_FILE *);
$endif INCLUDE_DNIC
$if change_by_whom
" added schedtable_file by SHSUE at 30-Jun-87 10:26:07"
$endif
    SCHEDTABLE_FILE:
      begin
        defined_desc.unit := FILE_SYSTEM_DISK;
        defined_desc.address := SCHEDTABLE_FILE_START;
        defined_desc.length := SCHEDTABLE_FILE_LENGTH_IN_PAGES
      end (* SCHEDTABLE_FILE *);
    OPERLOG_FILE:
      begin
        defined_desc.unit := FILE_SYSTEM_DISK;
	defined_desc.address := OPERLOG_FILE_START;
	defined_desc.length := OPERLOG_FILE_LENGTH
      end (* OPERLOG_FILE *)
(*    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-  *)
$ifany (force_password_change, global_password_only_login)
;
    PASSTABLE_FILE:
      begin
        defined_desc.unit := FILE_SYSTEM_DISK;
        defined_desc.address := PASSTABLE_FILE_START;
        defined_desc.length := PASSTABLE_FILE_LENGTH_IN_PAGES
      end (* PASSTABLE_FILE *)
$endif any(force_password_change, global_password_only_login)
(*    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-  *)
  end (* case *)
end (* do_get_program_file_definition *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code



(***********************  configuration_utility  ************************)
(*									*)
(*			  set_boolean_mismatch				*)
(*									*)
(*	This procedure does not perform the actual comparison, due to	*)
(*	possible range errors occuring if the value is not a legal	*)
(*	boolean value.							*)
(*									*)
(************************************************************************)

procedure set_boolean_mismatch(
      print_results	: boolean;
      program_value	: boolean;
      mismatch_message	: quoted_text;
  var all_match		: boolean);

begin
  all_match := FALSE;
  if print_results and user_terminal.sendable
  then
    begin
      format.start_message(mismatch_message);
      format.string(OPEN_PARENS_MESSAGE);
      if program_value
      then format.string(TRUE_MESSAGE)
      else format.string(FALSE_MESSAGE);
      format.string(DOES_NOT_MATCH_DISK_VALUE_MESSAGE);
      format.write_line(user_terminal)
    end
end (* set_boolean_mismatch *);
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(***********************  configuration_utility  ************************)
(*									*)
(*			do_check_integer_mismatch			*)
(*									*)
(************************************************************************)

procedure do_check_integer_mismatch(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code
      print_results	: boolean;
      mismatch_message	: quoted_text;
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      program_value	: univ integer;
      file_value	: univ integer;
  var all_match		: boolean);

begin
  if program_value <> file_value
  then
    begin
      all_match := FALSE;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code
      if print_results and user_terminal.sendable
      then
        begin
	  format.start_message(mismatch_message);
	  format.string(OPEN_PARENS_MESSAGE);
	  format.number(program_value, 10);
	  format.string(DOES_NOT_MATCH_DISK_VALUE_MESSAGE);
	  format.write_line(user_terminal)
	end
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    end
end (* do_check_integer_mismatch *);



(***********************  configuration_utility  ************************)
(*									*)
(*			check_file_configuration_value			*)
(*									*)
(************************************************************************)

procedure check_file_configuration_value(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code
      print_results	: boolean;
      index		: file_index;
      mismatch_message	: quoted_text;
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      program_value	: univ integer;
      file_value	: univ integer;
  var all_match 	: boolean);

begin
  if program_value <> file_value
  then
    begin
      all_match := FALSE;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code
      if print_results and user_terminal.sendable
      then
        begin
	  format.start_message('Mismatch on \ ');
	  format.file_name(index);
	  format.string(' file: \');
	  format.string(mismatch_message);
	  format.string(OPEN_PARENS_MESSAGE);
	  format.number(program_value, 10);
	  format.string(DOES_NOT_MATCH_DISK_VALUE_MESSAGE);
	  format.write_line(user_terminal)
	end
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    end
end (* check_file_configuration_value *);



(***********************  configuration_utility  ************************)
(*									*)
(*			 check_file_descriptions			*)
(*									*)
(************************************************************************)

procedure check_file_descriptions(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code       print_results	: boolean;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      config_file	: file_system_descriptor;
  var all_match		: boolean);

var
  index : file_index;
  program_def : file_descriptor;

begin
  for index := FIRST_FILE to LAST_FILE do
    begin
      do_get_program_file_definition(index, program_def);

      check_file_configuration_value(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code        print_results, index, UNIT_NUMBER_MESSAGE,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	program_def.unit, config_file[index].unit, all_match);

      check_file_configuration_value(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code        print_results, index, 'start address\',
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	program_def.address, config_file[index].address, all_match);

      check_file_configuration_value(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code        print_results, index, 'length\ ',
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	program_def.length, config_file[index].length, all_match)
    end
end (* check_file_descriptions *);



(***********************  configuration_utility  ************************)
(*									*)
(*		          do_check_configuration			*)
(*									*)
(*	Check configuration against constants defined in NVALvv.Arr.	*)
(*									*)
(************************************************************************)

procedure do_check_configuration(
      configuration	: univ configuration_information;
      print_results	: boolean;
$if CONVERT_TO_43  var sup_43	  : boolean;
  var all_match		: boolean);

begin
  with configuration do
    begin
      if id <> NETVAL_ID
      then
        begin
	  all_match := FALSE;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code
	  if print_results
	  then user_terminal.write_quoted_text_line(
	    'DISK does not have correct NETVAL id\ ')
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	end (* id <> NETVAL_ID *);

      do_check_integer_mismatch(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code        print_results, CURRENT_INCARNATION_MESSAGE,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	CURRENT_INCARNATION, incarnation_number, all_match);

      do_check_integer_mismatch(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code        print_results, DISK_UNIT_ONE_SIZE_MESSAGE,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	DISK_UNIT_ONE_SIZE, pages_on_disk_one, all_match);

      do_check_integer_mismatch(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code        print_results, DISK_UNIT_ZERO_SIZE_MESSAGE,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	DISK_UNIT_ZERO_SIZE, pages_on_disk_zero, all_match);

      check_file_descriptions(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code        print_results,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	files, all_match);

      do_check_integer_mismatch(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code
	print_results, MAXIMUM_CUD_BLOCK_SIZE_IN_SECTORS_MESSAGE,
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
        
	MAXIMUM_CUD_BLOCK_SIZE_IN_SECTORS ,
	cud_block_size_in_sectors, all_match);

      do_check_integer_mismatch(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code
	print_results, MAXIMUM_EXPECTED_SUPERVISORS_MESSAGE,
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	MAXIMUM_EXPECTED_SUPERVISORS, supervisors, all_match);

      do_check_integer_mismatch(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code        print_results, MAXIMUM_CUD_BLOCK_MESSAGE,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	  MAXIMUM_CUD_BLOCK, cud_blocks, all_match);

$ifnone BEFORE_SUP_V43
      do_check_integer_mismatch(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code
	print_results, MUD_VERSION_MESSAGE,
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	MUD_SUP_VERSION, mud_version, all_match);
$if CONVERT_TO_43      sup_43 := mud_version >= 430;
$endif BEFORE_SUP_V43

      if INCLUDE_GAN <> gans
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code       then all_match := FALSE;
$if disk_maintenance_code
      then set_boolean_mismatch(print_results, INCLUDE_GAN,
        INCLUDE_GAN_MESSAGE, all_match);

$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      if INCLUDE_DISTRICT <> districts
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code      then all_match := FALSE;
$if disk_maintenance_code
      then set_boolean_mismatch(print_results, INCLUDE_DISTRICT,
        INCLUDE_DISTRICT_MESSAGE, all_match);

$endif disk_maintenance_code
$if allow_password_only
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      do_check_integer_mismatch(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code        print_results, MINIMUM_PASSWORD_SIZE_MESSAGE,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	MINIMUM_PASSWORD_SIZE, password_size, all_match);
$endif allow_password_only

      if REQUIRE_NONALPHANUMERIC <> non_alpha_password
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code       then all_match := FALSE;
$if disk_maintenance_code
	then set_boolean_mismatch(print_results, REQUIRE_NONALPHANUMERIC,
	  REQUIRE_NONALPHANUMERIC_MESSAGE, all_match);

$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      if CLASS_0_GROUP_0_ASSIGNABLE <> zero_class_group_assignable
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code       then all_match := FALSE;
$if disk_maintenance_code
	then set_boolean_mismatch(print_results, CLASS_0_GROUP_0_ASSIGNABLE,
	  CLASS_0_GROUP_0_ASSIGNABLE_MESSAGE, all_match);

$endif disk_maintenance_code
$if BEFORE_SUP_V43
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      if NETVAL_CUD_IS_A_MUD <> cud_is_mud
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code       then all_match := FALSE;
$if disk_maintenance_code
      then set_boolean_mismatch(print_results, NETVAL_CUD_IS_A_MUD,
        NETVAL_CUD_IS_A_MUD_MESSAGE, all_match);
$endif disk_maintenance_code
$endif BEFORE_SUP_V43
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      do_check_integer_mismatch(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code        print_results, PROGRAMMER_NAME_SIZE_MESSAGE,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	PROGRAMMER_NAME_SIZE, programmer_size, all_match);

      if PROGRAMMER_NAME <> programmer
      then
        begin
	  all_match := FALSE;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code
	  if print_results
	  then user_terminal.write_quoted_text_line(
	    'PROGRAMMER_NAME does not match disk value\')
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	end;

      do_check_integer_mismatch(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code        print_results, MAXIMUM_HOST_MESSAGE,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	MAXIMUM_HOST, hosts, all_match);

      do_check_integer_mismatch(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code        print_results, MAXIMUM_NODE_MESSAGE,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	MAXIMUM_NODE, nodes, all_match);

      do_check_integer_mismatch(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code        print_results, MAXIMUM_CLASS_MESSAGE,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	MAXIMUM_CLASS, classes, all_match);

      do_check_integer_mismatch(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code
	print_results, MAXIMUM_CLASS_TABLE_SIZE_MESSAGE,
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	MAXIMUM_CLASS_TABLE_SIZE, class_table_size, all_match);

      do_check_integer_mismatch(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code        print_results, MAXIMUM_GROUP_MESSAGE,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	MAXIMUM_GROUP, groups, all_match);

      do_check_integer_mismatch(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code
	print_results, MAXIMUM_GROUP_TABLE_SIZE_MESSAGE,
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	MAXIMUM_GROUP_TABLE_SIZE, group_table_size, all_match);
$if INCLUDE_DNIC
      do_check_integer_mismatch(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code
	print_results, MAXIMUM_DNIC_TABLE_SIZE_MESSAGE,
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	MAXIMUM_DNIC_TABLE_SIZE, dnic_table_size, all_match)
$endif INCLUDE_DNIC
    end
end (* do_check_configuration *);



(***********************  configuration_utility  ************************)
(*									*)
(*			   check_tym_file_value				*)
(*									*)
(************************************************************************)

procedure check_tym_file_value(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code
      tym_file_message	: quoted_text;
      program_message	: quoted_text;
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      tym_file_value	: univ integer;
      program_value	: univ integer;
  var all_match		: boolean);

begin
  if program_value <> tym_file_value
  then
    begin
      all_match := FALSE;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code
      if user_terminal.sendable
      then
        begin
	  format.start_message(tym_file_message);
	  format.string(' from TYM file (\ ');
	  format.number(tym_file_value, 10);
	  format.string(') does not match program value\ ');
	  format.newline;
	  format.string('     \');
	  format.string(program_message);
	  format.string(OPEN_PARENS_MESSAGE);
	  format.number(program_value, 10);
	  format.character(ASCII_RIGHT_PARENS);
	  format.write_line(user_terminal)
	end
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    end
end (* check_tym_file_value *);



(***********************  configuration_utility  ************************)
(*									*)
(*			     check_disk_sizes	 			*)
(*									*)
(************************************************************************)

procedure check_disk_sizes(
      first_unit	: integer;
      config_value	: integer;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code       unit_message	: quoted_text;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  var disk_tape_info	: disk_tape_information;
  var all_match		: boolean);

var
  param : disk_param;

begin
  disk_tape_info.number_of_sectors := 0 (* in case of failure *);
  param.operation := DISK_INFO (* get size of unit from NUCLEUS *);
  io(disk_tape_info, param, DISK, first_unit);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if logical_volumes
  if param.status <> COMPLETE
  then io(disk_tape_info, param, DISK, first_unit + 2);
$endif logical_volumes
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  if config_value <> disk_tape_info.number_of_sectors
  then
    begin
      all_match := FALSE;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code
      format.start_message(unit_message);
      format.string(' does not match DSC file value (\ ');
      format.number(disk_tape_info.number_of_sectors, 10);
      format.character(')');
      format.write_line(user_terminal)
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    end (* config_value <> disk_tape_info.number_of_sectors *)
end (* check_disk_sizes *);



(***********************  configuration_utility  ************************)
(*									*)
(*			      check_tym_file	 			*)
(*									*)
(*	Check all TYM file values against NETVAL values.		*)
(*									*)
(************************************************************************)

procedure check_tym_file(
  var all_match	: boolean);

var
  disk_tape_info : disk_tape_information;
  required_unit_zero_size : integer;

begin
  required_unit_zero_size := CUD_FILE_LENGTH + CUD_PARAMETER_FILE_LENGTH;
  check_disk_sizes(0, DISK_UNIT_ZERO_SIZE,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code     DISK_UNIT_ZERO_SIZE_MESSAGE,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    disk_tape_info, all_match);

  if required_unit_zero_size > disk_tape_info.number_of_sectors
  then
    begin
      all_match := FALSE;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code
      format.start_message('CUD disk unit 0 requires a minimum of \ ');
      format.number(required_unit_zero_size, 10);
      format.string(' sectors\ ');
      format.write_line(user_terminal);
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    end (* required_unit_zero_size > disk_tape_info.number_of_sectors *);

(* check the size of disk unit 1, NUCLEUS vs. NVALvv.Arr. *)
  check_disk_sizes(1, DISK_UNIT_ONE_SIZE,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code     DISK_UNIT_ONE_SIZE_MESSAGE,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    disk_tape_info, all_match);

  check_tym_file_value(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code    'NVUSRS\ ', MAXIMUM_VALIDATOR_MESSAGE,
$if logical_volumes     sys_io.sys_info.number_of_terminals - 1,
$ifnone logical_volumes     sys_io.sys_info.number_of_terminals,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    MAXIMUM_VALIDATOR, all_match);

  check_tym_file_value(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code    'NVSUPS\ ', MAXIMUM_EXPECTED_SUPERVISORS_MESSAGE,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    sys_io.sys_info.number_of_aux_circuits-1, MAXIMUM_EXPECTED_SUPERVISORS,
    all_match)
end (* check_tym_file *);



(***********************  configuration_utility  ************************)
(*									*)
(*		             do_write_file				*)
(*									*)
(************************************************************************)

procedure do_write_file(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code       print_results	: boolean;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  var configuration	: configuration_information;
  var ok		: boolean);

begin
  file_checksum(configuration, configuration.checksum);
  dsksys.page_request(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code
$if logical_volumes     lv_dir.files_unit,
$ifnone logical_volumes     FILE_SYSTEM_DISK,
    DISK_WRITE,
$endif disk_maintenance_code
$ifnone disk_maintenance_code
    FILE_SYSTEM_DISK,
$if logical_volumes     LVOL_WRITE,
$ifnone logical_volumes     DISK_WRITE,
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    CONFIGURATION_FILE_START, configuration, ok);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code
  if print_results
  then
    if ok
    then user_terminal.write_line_and_quoted_text_line(
      'configuration file written\ ')
    else format.report_file_error(CONFIGURATION_FILE, WRITING_MESSAGE, 0,
      user_terminal)
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
end (* do_write_file *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifany (logical_volumes,disk_maintenance_code)



(***********************  configuration_utility  ************************)
(*									*)
(*		              write_file				*)
(*									*)
(*	If Netval, only used for Logical volumes (called by lvol status	*)
(*	manager).							*)
(*									*)
(************************************************************************)

procedure entry WRITE_FILE(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code       print_results	: boolean;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  var configuration	: configuration_information;
  var ok		: boolean);

begin
  do_write_file(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code     print_results,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    configuration, ok)
end (* write_file *);
$endif (disk_maintenance,logical_volumes)
$if disk_maintenance_code


(***********************  configuration_utility  ************************)
(*									*)
(*			 check_integer_mismatch				*)
(*									*)
(************************************************************************)

procedure entry CHECK_INTEGER_MISMATCH(
      program_value	: univ integer;
      file_value	: univ integer;
      mismatch_message	: quoted_text;
  var all_match		: boolean);

begin
  do_check_integer_mismatch(TRUE, mismatch_message, program_value, file_value,
    all_match)
end (* check_integer_mismatch *);



(***********************  configuration_utility  ************************)
(*									*)
(*			   check_configuration				*)
(*									*)
(*	Check configuration against constants defined in NVALvv.Arr.	*)
(*	This routine is only called by the archive system (in NVDM)	*)
(*	in the RESTORE command.						*)
(*									*)
(************************************************************************)

procedure entry CHECK_CONFIGURATION(
      configuration	: univ configuration_information;
$if CONVERT_TO_43  var sup_43            : boolean;
  var all_match		: boolean);

begin
  do_check_configuration(configuration,
$ifnot CONVERT_TO_43    TRUE,
$if CONVERT_TO_43    FALSE, sup_43,
    all_match)
end (* check_configuration *);



(***********************  configuration_utility  ************************)
(*									*)
(*			      check_command	 			*)
(*									*)
(*	Execute the check command.					*)
(*									*)
(************************************************************************)

procedure entry CHECK_COMMAND(
  var all_match	: boolean);

var
  configuration : configuration_information;
  status : file_utility_status;
$if CONVERT_TO_43  sup_43 : boolean;

begin
  do_read_file(configuration, status);
  all_match := status = FU_SUCCESS;
  if all_match
  then
    begin
      check_tym_file(all_match);
      do_check_configuration(configuration, TRUE,
$if CONVERT_TO_43        sup_43,
	all_match)
    end
end (* check_command *);



(***********************  configuration_utility  ************************)
(*									*)
(*			      this_incarnation	 			*)
(*									*)
(************************************************************************)

function entry THIS_INCARNATION : integer;

var
  configuration : configuration_information;
  status : file_utility_status;

begin
  do_read_file(configuration, status);
  if status = FU_SUCCESS
  then this_incarnation := configuration.incarnation_number
  else this_incarnation := -1
end (* this_incarnation *);



(***********************  configuration_utility  ************************)
(*									*)
(*		       do_display_param_and_integer 			*)
(*									*)
(************************************************************************)

procedure do_display_param_and_integer(
      param	: quoted_text;
      value	: integer);

begin
  format.start_message(param);
  format.colon_space;
  format.number(value, 10);
  format.write_line(user_terminal)
end (* do_display_param_and_integer *);



(***********************  configuration_utility  ************************)
(*									*)
(*		          display_param_and_integer 			*)
(*									*)
(************************************************************************)

procedure entry DISPLAY_PARAM_AND_INTEGER(
      param	: quoted_text;
      value	: integer);

begin
  do_display_param_and_integer(param, value)
end (* display_param_and_integer *);



(***********************  configuration_utility  ************************)
(*									*)
(*		         display_param_and_boolean 			*)
(*									*)
(************************************************************************)

procedure display_param_and_boolean(
      param	: quoted_text;
      value	: boolean);

begin
  format.start_message(param);
  format.colon_space;
  if value
  then format.string(TRUE_MESSAGE)
  else format.string(FALSE_MESSAGE);
  format.write_line(user_terminal)
end (* display_param_and_boolean *);



(***********************  configuration_utility  ************************)
(*									*)
(*		         display_param_and_username 			*)
(*									*)
(************************************************************************)

procedure display_username(
      value_size	: username_text_size;
      value		: username_text);

var
  programmer : username_string;

begin
  do_display_param_and_integer(PROGRAMMER_NAME_SIZE_MESSAGE, value_size);
  format.start_message(PROGRAMMER_NAME_MESSAGE);
  format.colon_space;
  programmer.size := value_size;
  programmer.text := value;
  format.username(programmer);
  format.write_line(user_terminal)
end (* display_param_and_username *);



(***********************  configuration_utility  ************************)
(*									*)
(*			 	display_date				*)
(*									*)
(************************************************************************)

procedure display_date(
      text 	: quoted_text;
      value	: integer);

begin
  format.start_message(text);
  format.time(value);
  format.write_line(user_terminal)
end (* display_date *);



(***********************  configuration_utility  ************************)
(*									*)
(*			display_file_configuration			*)
(*									*)
(************************************************************************)

procedure display_file_configuration(
      unit	: integer;
      address	: integer;
      length	: integer);

begin
  do_display_param_and_integer(UNIT_NUMBER_MESSAGE, unit);
  do_display_param_and_integer('  start sector\ ', address);
  do_display_param_and_integer('  length in sectors\', length)
end (* display_file_configuration *);



(***********************  configuration_utility  ************************)
(*									*)
(*			display_disk_configuration			*)
(*									*)
(*	Display configuration from the disk.				*)
(*									*)
(************************************************************************)

procedure display_disk_configuration(
      configuration	: configuration_information);

var
  index : file_index;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if overflow_cud_entries   cud_file_length : integer;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

begin
  with configuration do
    begin
      for index := FIRST_FILE to LAST_FILE do
        begin
	  format.start_and_newline;
	  format.file_name(index);
	  format.character(ASCII_COLON);
	  format.write_line(user_terminal);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if overflow_cud_entries
	  if index = CUD_FILE
	  then
	    begin (* report on overflow info too *)
	      cud_file_length := files[index].length -
		(MAXIMUM_CUD_BLOCK_SIZE_IN_SECTORS * NUMBER_OF_OVERFLOW_BLOCKS);
	      display_file_configuration(files[index].unit,
	        files[index].address, cud_file_length);
	      user_terminal.write_line_and_quoted_text_line(
	        'CUD Overflow blocks:\ ');
(* now output CUD overflow information *)
	      display_file_configuration(files[index].unit, (* same as CUD *)
	        files[index].address + cud_file_length,
		NUMBER_OF_OVERFLOW_BLOCKS * MAXIMUM_CUD_BLOCK_SIZE_IN_SECTORS)
	     end (* index = CUD_FILE, report on overflow info too *)
	  else
$endif overflow_cud_entries
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	    display_file_configuration(files[index].unit, files[index].address,
	      files[index].length);
	    if index = CLASS_GROUP_FILE
	  then
	    begin (* output CUD/MUD buffer information *)
	      user_terminal.write_line_and_quoted_text_line(
	        'CUD/MUD buffers:\ ');
(* tell where the actual CUD/MUD buffers are...see fildef.ntv comments *)
	      display_file_configuration(files[index].unit, (* same as file *)
	        CUD_MUD_BUFFER_LOCATION * MAXIMUM_CUD_BLOCK_SIZE_IN_SECTORS,
		(2 * MAXIMUM_CUD_BLOCK_SIZE_IN_SECTORS)
$ifnot BEFORE_SUP_V43                - MAXIMUM_NUD_BLOCK_SIZE_IN_SECTORS
		)
	    end (* output CUD/MUD buffer information *)
        end (* for *);
      user_terminal.write_newline;
      display_date('label initialized: \', label_date_and_time);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if logical_volumes
      display_date('last time stamp: \', last_pvol_time_stamp);
$endif logical_volumes
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      do_display_param_and_integer(CURRENT_INCARNATION_MESSAGE,
        incarnation_number);
      do_display_param_and_integer(DISK_UNIT_ZERO_SIZE_MESSAGE,
        pages_on_disk_zero);
      do_display_param_and_integer(DISK_UNIT_ONE_SIZE_MESSAGE,
        pages_on_disk_one);
      do_display_param_and_integer(MAXIMUM_CUD_BLOCK_SIZE_IN_SECTORS_MESSAGE,
        cud_block_size_in_sectors);
      do_display_param_and_integer(MAXIMUM_EXPECTED_SUPERVISORS_MESSAGE,
        supervisors);
      do_display_param_and_integer(MAXIMUM_CUD_BLOCK_MESSAGE, cud_blocks);
$if BEFORE_SUP_V43      display_param_and_boolean(NETVAL_CUD_IS_A_MUD_MESSAGE, cud_is_mud);
$ifnone BEFORE_SUP_V43      do_display_param_and_integer(MUD_VERSION_MESSAGE, mud_version);
      display_param_and_boolean(INCLUDE_GAN_MESSAGE, gans);
      display_param_and_boolean(INCLUDE_DISTRICT_MESSAGE, districts);
      do_display_param_and_integer(MINIMUM_PASSWORD_SIZE_MESSAGE,
        password_size);
      display_param_and_boolean(REQUIRE_NONALPHANUMERIC_MESSAGE,
        non_alpha_password);
      display_param_and_boolean(CLASS_0_GROUP_0_ASSIGNABLE_MESSAGE,
        zero_class_group_assignable);
      display_username(programmer_size, programmer);
      do_display_param_and_integer(MAXIMUM_HOST_MESSAGE, hosts);
      do_display_param_and_integer(MAXIMUM_NODE_MESSAGE, nodes);
      do_display_param_and_integer(MAXIMUM_CLASS_MESSAGE, classes);
      do_display_param_and_integer(MAXIMUM_CLASS_TABLE_SIZE_MESSAGE,
        class_table_size);
      do_display_param_and_integer(MAXIMUM_GROUP_MESSAGE, groups);
      do_display_param_and_integer(MAXIMUM_GROUP_TABLE_SIZE_MESSAGE,
        group_table_size)
$if INCLUDE_DNIC
; 
      do_display_param_and_integer(MAXIMUM_DNIC_TABLE_SIZE_MESSAGE,
	dnic_table_size);
$endif INCLUDE_DNIC
    end
end (* display_disk_configuration *);



(***********************  configuration_utility  ************************)
(*									*)
(*		      	    display_configuration 			*)
(*									*)
(*	Execute the display configuration command.			*)
(*									*)
(************************************************************************)

procedure entry DISPLAY_CONFIGURATION;

var
  configuration : configuration_information;
  status : file_utility_status;

begin
  do_read_file(configuration, status);
  if status = FU_SUCCESS
  then
    begin
      display_disk_configuration(configuration);
      user_terminal.write_newline;
      do_display_param_and_integer(MAXIMUM_VALIDATOR_MESSAGE,
        MAXIMUM_VALIDATOR);
      do_display_param_and_integer('AUX_CIRCUIT_UNIT_MAX\ ',
        AUX_CIRCUIT_UNIT_MAX)
    end
end (* display_configuration *);



(***********************  configuration_utility  ************************)
(*									*)
(*			store_disk_configuration			*)
(*									*)
(*	Store configuration to the disk.				*)
(*									*)
(************************************************************************)

procedure store_disk_configuration(
  var configuration	: configuration_information);

begin
  with configuration do
    begin
      id := NETVAL_ID;
      incarnation_number := current_incarnation;
      pages_on_disk_one := DISK_UNIT_ONE_SIZE;
      cud_block_size_in_sectors := MAXIMUM_CUD_BLOCK_SIZE_IN_SECTORS;
      supervisors := MAXIMUM_EXPECTED_SUPERVISORS;
      cud_blocks := MAXIMUM_CUD_BLOCK;
      gans := INCLUDE_GAN;
      districts := INCLUDE_DISTRICT;
      password_size := MINIMUM_PASSWORD_SIZE;
      non_alpha_password := REQUIRE_NONALPHANUMERIC;
      zero_class_group_assignable := CLASS_0_GROUP_0_ASSIGNABLE;
$if BEFORE_SUP_V43      cud_is_mud := NETVAL_CUD_IS_A_MUD;
$ifnone BEFORE_SUP_V43      mud_version := MUD_SUP_VERSION;
      programmer_size := PROGRAMMER_NAME_SIZE;
      programmer := PROGRAMMER_NAME;
      hosts := MAXIMUM_HOST;
      nodes := MAXIMUM_NODE;
      classes := MAXIMUM_CLASS;
      class_table_size := MAXIMUM_CLASS_TABLE_SIZE;
      groups := MAXIMUM_GROUP;
      group_table_size := MAXIMUM_GROUP_TABLE_SIZE;
$if INCLUDE_DNIC
      dnic_table_size := MAXIMUM_DNIC_TABLE_SIZE;
$endif INCLUDE_DNIC
      last_pvol_time_stamp := REALTIME;
      pages_on_disk_zero := DISK_UNIT_ZERO_SIZE
  end
end (* store_disk_configuration *);



(***********************  configuration_utility  ************************)
(*									*)
(*		          new_configuration_file			*)
(*									*)
(************************************************************************)

procedure entry NEW_CONFIGURATION_FILE;

var
  configuration : configuration_information;
  index : file_index;
  ok : boolean;

begin
  store_disk_configuration(configuration);
  configuration.label_date_and_time := REALTIME;
  with configuration do
    for index := FIRST_FILE to LAST_FILE do
        do_get_program_file_definition(index, files[index]);
"
 remove creation_date from file info, same for all
        files[index].creation_date := label_date_and_time
"
  do_write_file(TRUE, configuration, ok)
end (* new_configuration_file *);
$endif disk_maintenance_code
$ifnone logical_volumes
$ifnone disk_maintenance_code



(***********************  configuration_utility  ************************)
(*									*)
(*			 check_drive_configuration			*)
(*									*)
(*	For the givin unit, read and check the configuration file;	*)
(*	used at NETVAL initialization check the disk.  Crash if not ok.	*)
(*									*)
(************************************************************************)

procedure entry CHECK_DRIVE_CONFIGURATION(
      unit		: integer;
  var configuration	: configuration_information);

var
  status : file_utility_status;
  success : boolean;

begin
  success := TRUE;
  check_tym_file(success);
  if not success
  then crash_util.halt_slot;
  do_read_file(configuration, status);
  if status = FU_SUCCESS
  then do_check_configuration(configuration, FALSE, success);
  if not success
  then crash_util.halt_slot
end (* check_drive_configuration *);
$endif disk_maintenance_code
$endif logical_volumes
$if logical_volumes



(***********************  configuration_utility  ************************)
(*									*)
(*			 do_get_lvol_configuration			*)
(*									*)
(*	Return information in lvol_state about the 2 drives that make	*)
(*	up the logical volume system.  Set configuration to the "good"	*)
(*	configuration data, if any.					*)
(*									*)
(************************************************************************)

procedure do_get_lvol_configuration(
      print_results	: boolean;
  var configuration	: configuration_information;
  var lvol_state	: lvol_disk_state);

var
  temp_config : configuration_information;
  incarnation : incarnation_index;
  computed_checksum : integer;
$if CONVERT_TO_43  sup_43 : boolean;

begin
  for incarnation := 0 to 1 do
    begin
      lvol_state[incarnation].time_stamp := -1;
      with dsksys, lv_utility do
        disk_io_page_request(
	  unit_partner(first_incarnation_disk_unit(incarnation)),
          DISK_READ, CONFIGURATION_FILE_START, temp_config,
	  lvol_state[incarnation].legal_disk);
      if lvol_state[incarnation].legal_disk
      then
        begin
	  file_checksum(temp_config, computed_checksum);
	  lvol_state[incarnation].legal_disk :=
	    temp_config.checksum = computed_checksum
	end;
      if lvol_state[incarnation].legal_disk
      then do_check_configuration(temp_config, print_results,
$if CONVERT_TO_43        sup_43,
        lvol_state[incarnation].legal_disk);
      if lvol_state[incarnation].legal_disk
      then
        begin
	  configuration := temp_config;
	  lvol_state[incarnation].time_stamp :=
	    configuration.last_pvol_time_stamp
	end (* lvol_state[incarnation].legal_disk *)
    end (* for incarnation... *)
end (* do_get_lvol_configuration *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code



(***********************  configuration_utility  ************************)
(*									*)
(*			 get_lvol_configuration				*)
(*									*)
(*	Return information in lvol_state about the 2 drives that make	*)
(*	up the logical volume system.					*)
(*									*)
(************************************************************************)

procedure entry GET_LVOL_CONFIGURATION(
  var configuration	: configuration_information;
  var lvol_state	: lvol_disk_state);

begin
  do_get_lvol_configuration(FALSE, configuration, lvol_state)
end (* get_lvol_configuration *);
$endif disk_maintenance_code
$ifnone disk_maintenance_code



(***********************  configuration_utility  ************************)
(*									*)
(*			 check_lvol_configuration			*)
(*									*)
(*	Return information in lvol_state about the 2 drives that make	*)
(*	up the logical volume system.  If neither disk is good or the	*)
(*	TYM file parameters do not match, crash.			*)
(*									*)
(************************************************************************)

procedure entry CHECK_LVOL_CONFIGURATION(
  var configuration	: configuration_information;
  var lvol_state	: lvol_disk_state);

var
  ok : boolean;

begin
  ok := TRUE;
  check_tym_file(ok);
  if not ok
  then crash_util.halt_slot;
  do_get_lvol_configuration(FALSE, configuration, lvol_state);
  if not lvol_state[0].legal_disk and not lvol_state[1].legal_disk
  then crash_util.halt_slot (* crash if BOTH drives are no good *)
end (* check_lvol_configuration *);
$endif disk_maintenance_code
$endif logical_volumes
$ifnone disk_maintenance_code




(***********************  configuration_utility  ************************)
(*									*)
(*			  report_error_to_oplog				*)
(*									*)
(************************************************************************)

procedure entry REPORT_ERROR_TO_OPLOG(
      format		: internal_to_string;
      oper_messages	: operator_messages);

begin
  format.start_message('error on CONFIGURATION file\');
  oper_messages.report_message(FILE_OPLOG_MSG)
end (* report_error_to_oplog *);
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(************************************************************************)
(************************************************************************)

begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code
  init crash_util;
$if logical_volumes   init lv_utility
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
end (* configuration_utility *);
!
(************************************************************************)
(*									*)
(*	CMDTAB.NTV							*)
(*									*)
(*			   command_table monitor			*)
(*									*)
(*	 This monitor contains the definition of all commands.	  	*)
(*	 It is accessed by terminal_input_scanner to lookup the	 	*)
(*	 particular command in question and returns the complete	*)
(*	 definition record for the command found.			*)
(*									*)
(*	The commands are distributed into command classes. Each class	*)
(*	has an array of command definitions associated with it.		*)
(*									*)
(*	The following identifiers must be defined externally:	   	*)
(*	  command_definition    keyword_definition			*)
(*	  scanned_command       command_token				*)
(*	  end_of_(class)	command_class_index			*)
(*									*)
(************************************************************************)
(*									*)
(*			     Revision Record				*)
(*									*)
(*	23Jan89 - neh							*)
(*		- add filter modify expire date and filter supervisor	*)
(*		  off to NVDM commands to match CMDDEF			*)
(*	04Nov88 - jrn							*)
(*		- change license requirements for commands not needed	*)
(*		  by operators						*)
(*		- add display_oper_log_license for FILTER, MESSAGES	*)
(*		- add allow_temporary_apes and perform_daily_cud_scan	*)
(*		  commands						*)
(*	03Oct88 - jrn							*)
(*		- add definitions for the following NETVAL commands:	*)
(*				CHANGE VALIDITY				*)
(*				DISPLAY VALIDITY			*)
(*				SET VALIDITY				*)
(*				SELECT CONTROL EE			*)
(*		- add definitions for the following NVDM commands:	*)
(*				DISPLAY PASSPERIOD			*)
(*				DISPLAY VALIDITY			*)
(*				SET PASSPERIOD				*)
(*				SET VALIDITY				*)
(*		- add PRIMARY_SELECT_CONTROL_LOGON_INHIBIT_KEYWORD	*)
(*		- change allow_user_password_expire to			*)
(*		  password_expiration_by_user and check out code	*)
(*		- use password_expiration_date_in_cud for code that is	*)
(*		  required for global or user password expiration	*)
(*		- use ganpass_file_exists				*)
(*		- add code for prevent_duplicate_passwords		*)
(*		- add code for restrict_users_by_time			*)
(*	        - add allow_logon_inhibit code				*)
(*	22Feb88 - neh							*)
(*	      - add change validity user, change validity gan		*)
(*		and display validity					*)
(*	09Nov87 - neh							*)
(*	      - add delete, display, new, replace, read, restore and	*)
(*		send dnic table commands				*)
(*	15Aug87 - neh							*)
(*	      - remove TYMSHARE_CUD_FORMAT flag, add INCLUDE_IRC and	*)
(*		check_time_status and change GFD to be conditional	*)
(*		on NETVAL_IS_A_SLAVE					*)
(*	18Sep87 - neh							*)
(*	      - merge FPC and GPO with 5.00				*)
(*	19Feb87 - rsb							*)
(*		- remove SET_SCHEDULE from SET command set.		*)
(*		- add code to add the following commands:		*)
(*		  CLEAR_CONSISTENCY, CLEAR_GANPASS, CLEAR_GPOGAN,	*)
(*		  CLEAR_PASSCHANGER, CLEAR_UUNMERGE, DISPLAY_GANPASS,	*)
(*		  DISPLAY_GPOGAN, DISPLAY_SCHEDULE, 			*)
(*		  SCHEDULE_CONSISTENCY, SCHEDULE_PASSCHANGER,		*)
(*		  SCHEDULE_UUNMERGE, SELECT_EXPIREDATE, SET_GANPASS,	*)
(*		  SET_GPOGAN 						*)
(*	22Oct86 - neh							*)
(*	24Feb87 - neh							*)
(*	      - add REFORMAT command					*)
(*	22Oct86 - neh							*)
(*	      - Change license for new user, change user, new access,	*)
(*		delete user and delete access to NETWORK ADMINISTRATOR	*)
(*		if NETVAL_IS_A_SLAVE is enabled.			*)
(*	03Sep86 - neh							*)
(*	      - Changes made to add FILTER commands			*)
(*	      - Add string constants FILTER_KEYWORD_STRING,		*)
(*		PASSWORD_KEYWORD_STRING, 				*)
(*		DELETE_KEYWORD_STRING and NEW_KEYWORD_STRING.		*)
(*	      - Change MESSAGE command to primary from global.		*)
(*	      - Add command definitions for DISPLAY FILTER and		*)
(*		FILTER commands.					*)
(*	14Aug86 - jrn							*)
(*	      - add DELETE CLASS, DELETE GROUP for clearing classes	*)
(*		and groups after a configuration change			*)
(*	08Jul86 - jrn							*)
(*	      - add REMARK command					*)
(*	      - add SPECIAL flag (CLEAN and OLDPASS commands)		*)
(*	      - if TYMSHARE_CUD_FORMAT, change license for COMPARE,	*)
(*		GET, DISPLAY CUD/MUD and READ CUD/MUD commands		*)
(*	06Aug86 - jrn							*)
(*	      - add GFDONLY to SELECT PASSWORDDATE command		*)
(*	31Jul86 - jrn							*)
(*	      - add MESSAGE FROM command to NVDM			*)
(*	13May86 - neh							*)
(*	      - if INCLUDE_DUMP, add DUMP keyword to INITIALIZE 	*)
(*		PARAMETERS command					*)
(*	30Apr86 - jrn							*)
(*	      - remove RESET command					*)
(*	28Apr86 - jrn							*)
(*	      - make REGENERATE PARAMETERS and RECOLLECT commands	*)
(*		restartable at a CUD block				*)
(*	24Apr86 - jrn							*)
(*	      - if REUSE_UUNS, add PARAMETERS keyword to NVDM		*)
(*		CHECK command						*)
(*	15Apr86 - jrn							*)
(*	      - add ADDBACK keyword to the INITIALIZE PARAMETERS	*)
(*		command							*)
(*	      - change DISPLAY NEXT to DISPLAY PARAMETERS		*)
(*	08Mar86 - jrn							*)
(*	      - add COPY command to Tymnet's NVDM			*)
(*	10Mar86 - jrn							*)
(*	      - redo REUSE_UUNS to maintain a bit map for 18 bit UUNS	*)
(*		and change the add back scheme to be a dated list	*)
(*	      - add APPEND keyword to REGENERATE command, and		*)
(*		COLLECT command						*)
(*	22Jan86 - jrn							*)
(*	      - add add_to_prompts procedure				*)
(*	      - create command and keyword table with procedures	*)
(*	      - remove abbreviations and sizes in command and keyword	*)
(*	        definitions (handle in code)				*)
(*	      - change the UP and SHUT commands to HOST UP and HOST	*)
(*		SHUT, and add the HOST STATUS command			*)
(*	14Jan85 -  jrn							*)
(*	      - change DISPLAY LVOL to DISPLAY VOLUME for both Netval	*)
(*		and NVDM						*)
(*	20Dec85 - jrn							*)
(*	      - add the FROM SUPERVISOR keywords to the WRITE CUD	*)
(*		command							*)
(*	01Nov85 - jrn							*)
(*	      - add the REPEAT keyword for DISPLAY UPDATES, and the	*)
(*		SHUT and UP commands					*)
(*	29Oct84 - jrn							*)
(*	      - change the license required for the NETVAL CHECK	*)
(*		command, so that operators may use it to check for	*)
(*		usernames when there has been a disk problem		*)
(*	07Oct85 - jrn							*)
(*	      - add the X25 keyword for the NEW USER command if		*)
(*		VALIDATE_X25_NAMES is enabled				*)
(*	17Jul85 -	 jrn						*)
(*	     - add NVDM COMPARE command					*)
(*	31Jan85 - jrn							*)
(*	      - if NETVAL_IS_A_SLAVE, only allow programmer to perform	*)
(*		CUD update commands					*)
(*	16Jan85 - pgl							*)
(*	      - if LOGICAL_VOLUMES, add COPY, DISPLAY LVOL and		*)
(*		SET DRIVE OFFLINE commands				*)
(*	09Jan85 - jrn							*)
(*	      - remove UNIT keyword from Archive commands		*)
(*	08Jan85 - jrn							*)
(*	      - use INCLUDE_LIST_DESCRIPTIONS				*)
(*	14Apr84 Version 2.02    jrn - pgl				*)
(*	      - removed DISPLAY SCHEDULE and DISPLAY SUPERVISORS	*)
(*		commands						*)
(*	      - added DISPLAY DIRECTORY, DISPLAY SELECT and		*)
(*		SELECT commands						*)
(*	      - consolidated command and keyword strings		*)
(*	      - added licenses, AUDITOR_LICENSE, OPERATOR_LICENSE	*)
(*		and DISPLAY_CUD_LICENSE					*)
(*	14Mar84 Version 2.01 - jrn					*)
(*	      - added NO_CHANGE keyword to CONSISTENCY command		*)
(*	29SEP83  Original from (patrol)cmds.bas				*)
(*		 Add HELP message routines - jrn			*)
(*									*)
(************************************************************************)


type COMMAND_TABLE = monitor;


const
  display_command_string = 'DISPLAY\';
$if logical_volumes
  copy_command_string = 'COPY\ ';
  copy_help_string = 'Copy data from one drive to the other\';
$endif logical_volumes

$if disk_maintenance_code
$if reuse_uuns
  addback_keyword_string = 'ADDBACK\';
$endif reuse_uuns
$endif disk_maintenance_code
  all_keyword_string = 'ALL\';
  class_keyword_string = 'CLASS\';
  consistency_keyword_string = 'CONSISTENCY\';
  control_keyword_string = 'CONTROL\';
  cudmaintenance_keyword_string = 'CUDMAINTENA\';
  delete_keyword_string = 'DELETE\ ';
$if include_dnic
  dnic_keyword_string = 'DNIC\ ';
  default_keyword_string = 'DEFAULT\';
  nondefault_keyword_string = 'NON-DEFAULT\';
$endif include_dnic
  filter_keyword_string = 'FILTER\ ';
  name_keyword_string = 'NAME\ ';
  new_keyword_string = 'NEW\';
  password_keyword_string = 'PASSWORD\ ';
  access_keyword_string = 'ACCESS\ ';
$ifnone disk_maintenance_code   description_keyword_string = 'DESCRIPTION\';
  district_keyword_string = 'DISTRICT\ ';
$ifnone disk_maintenance_code   entrydate_keyword_string = 'ENTRYDATE\';
$ifany (force_password_change,password_expiration_by_user,allow_temporary_apes)
  expiredate_keyword_string = 'EXPIREDATE\ ';
$endif (force_password_change,password_expiration_by_user,allow_temporary_apes)
$if allow_temporary_apes   expire_keyword_string = 'EXPIRE\ ';
  gan_keyword_string = 'GAN\';
  from_keyword_string = 'FROM\ ';
  group_keyword_string = 'GROUP\';
  host_keyword_string = 'HOST\ ';
  hostlist_keyword_string = 'HOSTLIST\ ';
  node_keyword_string = 'NODE\ ';
  nodelist_keyword_string = 'NODELIST\ ';
  parameters_keyword_string = 'PARAMETERS\ ';
$ifnone disk_maintenance_code   passworddate_keyword_string = 'PASSWORDDAT\';
$if prevent_duplicate_passwords   passperiod_string = 'PASSPERIOD\ ';
  user_keyword_string = 'USER\ ';
  uun_keyword_string = 'UUN\';
$if password_expiration_by_user   validity_string = 'VALIDITY\ ';
  supervisor_keyword_string = 'SUPERVISOR\ ';
$if restrict_users_by_time   time_keyword_string = 'TIME\ ';

  global_prompt_string = '* \ ';



type
  HELP_COMMAND_INFORMATION = record
    current_command_class	: command_class_index;
    current_command		: command_index;
    last_command_in_class	: command_index
  end (* help_command_information *);



var

(* command class definitions *)

  global_defs : array [global_command_index]  of command_definition;
  archive_defs : array [archive_command_index] of command_definition;
  primary_defs : array [primary_command_index] of command_definition;


(* prompt array definition *)

  class_prompt : array [command_class_index] of command_prompt;



(* keywords for all commands *)

  keyword_table : array [keyword_index] of keyword_definition;



(* Help command and sub-command pointers for all validator that *)
(* may access the HELP command.  This array is accessed by a	*)
(* call to START_HELP, then successive calls to			*)
(* NEXT_HELP_COMMAND_INFO AND NEXT_HELP_SUBCOMMAND_INFO		*)

  help_info : array [licensed_validator_index] of help_command_information;

(* The last keyword offset added tocommand table during initialization	*)

  last_keyword_offset : keyword_index;
!
(*************************  command_table  ******************************)
(*									*)
(*			     get_header					*)
(*									*)
(*	Move command header to command definition block.		*)
(*									*)
(************************************************************************)

procedure get_header(
      command_class	: command_class_index;
      command		: command_index;
  var header		: command_definition);

begin
  case command_class of
    global_class: header := global_defs[command];
    archive_class: header := archive_defs[command];
    primary_class: header := primary_defs[command]
  end (* case *)
end (* get_header *);



(*************************  command_table  ******************************)
(*									*)
(*			  get_keyword_entry				*)
(*									*)
(*	Move keyword for this command to definition block.		*)
(*									*)
(************************************************************************)

procedure get_keyword_entry(
      keyword_offset	: keyword_index;
      keyword		: command_keyword_index;
  var keyword_entry	: keyword_definition);

begin
  keyword_entry := keyword_table[keyword_offset+keyword]
end (* get_keyword_entry *);
!
(**************************  command_table  *****************************)
(*									*)
(*			    get_class_bounds				*)
(*									*)
(*  Routine to set up the start and end of a command class index	*)
(*									*)
(************************************************************************)

procedure get_class_bounds(
      command_class	: command_class_index;
  var start_class	: command_index;
  var end_class		: command_index);

begin
  case command_class of

    GLOBAL_CLASS:
      begin
	start_class := START_GLOBAL_COMMANDS;
	end_class   := END_GLOBAL_COMMANDS
      end (* GLOBAL_CLASS *);

    ARCHIVE_CLASS:
      begin
	start_class := START_ARCHIVE_COMMANDS;
	end_class   := END_ARCHIVE_COMMANDS
      end (* ARCHIVE_CLASS *);

    PRIMARY_CLASS:
      begin
	start_class := START_PRIMARY_COMMANDS;
	end_class   := END_PRIMARY_COMMANDS
      end (* PRIMARY_CLASS *)

  end (* case *)
end (* get_class_bounds *);



(**************************  command_table  *****************************)
(*									*)
(*			     find_command				*)
(*									*)
(*	 Routine to lookup specified command.				*)
(*									*)
(************************************************************************)

procedure entry FIND_COMMAND(
      command_context	: context_set;
      token		: command_token;
  var scanned		: scanned_command;
  var header		: command_definition;
  var found		: boolean);

var
  i			: command_name_index;
  token_size		: command_token_size;
  match			: boolean;
  exact			: boolean;
  count			: integer;
  last_command		: command_index;
  test_command		: command_index;
  test_class		: command_class_index;

begin
  exact := FALSE; count := 0; test_class := succ(START_OF_COMMAND_CLASSES);
  token_size := token.finish - token.start;

  while (test_class < END_OF_COMMAND_CLASSES) and not exact do
    begin
      if test_class in command_context
      then
	begin
	  get_class_bounds(test_class, test_command, last_command);

	  while (test_command < last_command) and (count <= 1) do
	    begin
	      get_header(test_class, test_command, header);

	      i := 0;
	      repeat
		match := (header.name[i] <> END_MESSAGE_CHARACTER) and
		  (header.name[i] = scanned.input_line.text[token.start + i]);
		i := i + 1
	      until (i >= token_size) or not match;

	      if match
	      then
	        begin
		  exact := header.name[i] = END_MESSAGE_CHARACTER;
		  scanned.command := test_command;
		  scanned.command_class := test_class;
		  count := count + 1
		end (* if match *);
	      test_command := succ(test_command)
	    end (* while *)
	end (* if test_class in command_context *);
      test_class := succ(test_class)
    end (* while *);

  found := (count = 1) or exact;
  if found
  then get_header(scanned.command_class, scanned.command, header)
end (* find_command *);



(**************************  command_table  *****************************)
(*									*)
(*			check_next_keyword_entry			*)
(*									*)
(************************************************************************)

procedure check_next_keyword_entry(
      keyword_offset	: keyword_index;
      scanned		: scanned_command;
      token		: command_token;
      token_size	: command_token_size;
  var test_keyword	: command_keyword_index;
  var keyword_entry	: keyword_definition;
  var keyword		: command_keyword_index;
  var exact		: boolean;
  var count		: integer);

var
  i			: command_token_index;
  match			: boolean;

begin
  get_keyword_entry(keyword_offset, test_keyword, keyword_entry);
  i := 0;
  repeat
    match := (keyword_entry.name[i] <> END_MESSAGE_CHARACTER) and
      (keyword_entry.name[i] = scanned.input_line.text[token.start + i]);
    i := i + 1
  until (i >= token_size) or not match;
  if match
  then
    begin
      exact := keyword_entry.name[i] = END_MESSAGE_CHARACTER;
      count := count + 1;
      keyword := test_keyword
    end (* match *)
end (* check_next_keyword_entry *);



(**************************  command_table  *****************************)
(*									*)
(*			      find_keyword				*)
(*									*)
(*	 Routine to lookup a keyword for a command (subcommand or not).	*)
(*									*)
(************************************************************************)

procedure find_keyword(
      first_keyword	: command_keyword_index (* one to start with *);
      keyword_offset	: keyword_index	(* offset for this command *);
      keyword_count	: command_keyword_total (* number to check *);
      scanned		: scanned_command;
      token		: command_token (* token to match *);
  var keyword		: command_keyword_index;
  var keyword_entry	: keyword_definition;
  var found		: boolean);

var
  token_size		: command_token_size;
  test_keyword		: command_keyword_index;
  exact			: boolean;
  count			: integer;

begin
  exact := FALSE; count := 0; test_keyword := first_keyword;
  token_size := token.finish - token.start;
  while (test_keyword < keyword_count) and not exact do
    begin
      check_next_keyword_entry(keyword_offset, scanned, token,
        token_size, test_keyword, keyword_entry, keyword, exact, count);
      test_keyword := succ(test_keyword)
    end (* while *);
  found := (count = 1) or exact;
  if found
  then get_keyword_entry(keyword_offset, keyword, keyword_entry)
end (* find_keyword *);



(**************************  command_table  *****************************)
(*									*)
(*			 find_subcommand_keyword			*)
(*									*)
(*	 Routine to lookup a sub-command for a command.			*)
(*									*)
(************************************************************************)

procedure entry FIND_SUBCOMMAND_KEYWORD(
      header		: command_definition;
      scanned		: scanned_command;
      token		: command_token;
  var keyword		: command_keyword_index;
  var keyword_entry	: keyword_definition;
  var found		: boolean);

begin
  find_keyword(0, header.keyword_offset, header.subcommand_count, scanned,
    token, keyword, keyword_entry, found)
end (* find_subcommand_keyword *);



(**************************  command_table  *****************************)
(*									*)
(*			  find_command_keyword				*)
(*									*)
(*	 Routine to lookup a keyword for a command.			*)
(*									*)
(************************************************************************)

procedure entry FIND_COMMAND_KEYWORD(
      header		: command_definition;
      scanned		: scanned_command;
      token		: command_token;
  var keyword		: command_keyword_index;
  var keyword_entry	: keyword_definition;
  var found		: boolean);

begin
  find_keyword(header.subcommand_count, header.keyword_offset,
    header.keyword_count, scanned, token, keyword, keyword_entry, found)
end (* find_command_keyword *);



(**************************  command_table  *****************************)
(*									*)
(*			  find_line_keyword				*)
(*									*)
(*	 Routine to lookup a keyword for an input line.			*)
(*									*)
(************************************************************************)

procedure entry FIND_LINE_KEYWORD(
      keyword_choices	: keyword_choice_set;
      scanned		: scanned_command;
      token		: command_token;
  var keyword		: command_keyword_index;
  var keyword_entry	: keyword_definition;
  var found		: boolean);

var
  token_size		: command_token_size;
  test_keyword		: command_keyword_index;
  exact			: boolean;
  count			: integer;

begin
  exact := FALSE; count := 0; test_keyword := 0;
  token_size := token.finish - token.start;
  while (test_keyword < LINE_KEYWORD_COUNT) and not exact do
    begin
      if test_keyword in keyword_choices
      then check_next_keyword_entry(LINE_KEYWORD_OFFSET, scanned, token,
        token_size, test_keyword, keyword_entry, keyword, exact, count);
      test_keyword := succ(test_keyword)
    end (* while *);
  found := (count = 1) or exact;
  if found
  then get_keyword_entry(LINE_KEYWORD_OFFSET, keyword, keyword_entry)
end (* find_line_keyword *);
!
(*************************  command_table  ******************************)
(*									*)
(*			     get_keyword				*)
(*									*)
(*	Return the keyword_definition for the specified command		*)
(*	and keyword.							*)
(*									*)
(************************************************************************)

procedure entry GET_KEYWORD(
      keyword_offset	: keyword_index;
      keyword		: command_keyword_index;
  var keyword_entry	: keyword_definition);

begin
  get_keyword_entry(keyword_offset, keyword, keyword_entry)
end (* get_keyword *);
!
(***************************  command_table  ****************************)
(*									*)
(*				get_prompt				*)
(*									*)
(*  Returns the prompt of the highest priority class			*)
(*									*)
(************************************************************************)

procedure entry GET_PROMPT(
      context : context_set;
  var scanned : scanned_command);

var
  command_class : command_class_index;

begin
  command_class := succ(START_OF_COMMAND_CLASSES);
  while not (command_class in context) do
    command_class := succ(command_class);
  scanned.prompt := class_prompt[command_class]
end (* get_prompt *);
!
"
		HELP command routines
"



(***************************  command_table  ****************************)
(*									*)
(*			 next_help_command_class			*)
(*									*)
(*	Increment the current_command_class for the validator.  If at	*)
(*	the end of the list, set done to TRUE, otherwise, set up	*)
(*	current_command to be the start of the command class, and	*)
(*	last_command_in_class to be the end of the command class.	*)
(*									*)
(************************************************************************)

procedure next_help_command_class(
      validator		: licensed_validator_index;
      command_context	: context_set;
  var done		: boolean);

begin
  done := FALSE;
  with help_info[validator] do
    begin
      repeat
	current_command_class := succ(current_command_class);
	if current_command_class = END_OF_COMMAND_CLASSES
	then done := TRUE
      until done or (current_command_class in command_context);
      if not done
      then get_class_bounds(current_command_class, current_command,
	    last_command_in_class)
    end
end (* next_help_command_class *);



(***************************  command_table  ****************************)
(*									*)
(*				start_help				*)
(*									*)
(*	Initialize the help_info for the validator.  Use		*)
(*	command_context to set up the first legal command_class.	*)
(*									*)
(************************************************************************)

procedure entry START_HELP(
      validator		: licensed_validator_index;
      command_context	: context_set);

var
  done : boolean;

begin
  with help_info[validator] do
    begin
      current_command_class := START_OF_COMMAND_CLASSES;
      next_help_command_class(validator, command_context, done)
    end
end (* start_help *);



(***************************  command_table  ****************************)
(*									*)
(*			  next_help_command_info			*)
(*									*)
(*	Increment current_command, and return the header		*)
(*	(command_definition) for the next legal command			*)
(*	for the validator, validator_type, and command_context.		*)
(*	Set done to TRUE if there are no more legal commands		*)
(*	for the validator.						*)
(*									*)
(************************************************************************)

procedure entry NEXT_HELP_COMMAND_INFO(
      profile		: validator_profile;
      command_context	: context_set;
  var done		: boolean;
  var header		: command_definition);

begin
  done := FALSE;
  with help_info[profile.validator] do
    repeat
      repeat
	current_command := succ(current_command);
	if current_command = last_command_in_class
	then
	  begin
	    next_help_command_class(profile.validator, command_context, done);
	    if not done
	    then current_command := succ(current_command)
	  end
      until done or (current_command <> last_command_in_class);
      if not done
      then get_header(current_command_class, current_command, header)
    until done or profile.access_to_command(header.required_license)
end (* next_help_command_info *);
!
"
		Initialization routines
"


(***************************  command_table  ****************************)
(*									*)
(*			       add_command				*)
(*									*)
(************************************************************************)

procedure add_command(
      name		: command_name;
      required_license	: command_license;
      freeword_allowed	: boolean;
      keyword_offset	: keyword_index;
      keyword_count	: command_keyword_total;
      subcommand_count	: command_keyword_total;
      explanation	: help_string;
  var header		: command_definition);

begin
  header.name := name;
  header.required_license := required_license;
  header.freeword_allowed := freeword_allowed;
  header.keyword_offset := keyword_offset;
  header.keyword_count := keyword_count;
  header.subcommand_count := subcommand_count;
  header.explanation := explanation;
  last_keyword_offset := keyword_offset
end (* add_command *);




(***************************  command_table  ****************************)
(*									*)
(*				add_keyword				*)
(*									*)
(************************************************************************)

procedure add_keyword(
      name		: keyword_name;
      required_license	: command_license;
      explanation	: help_string;
      index		: keyword_index);

begin
  keyword_table[last_keyword_offset + index].name := name;
  keyword_table[last_keyword_offset+index].required_license:=required_license;
  keyword_table[last_keyword_offset + index].value_required := FALSE;
  keyword_table[last_keyword_offset + index].explanation := explanation
end (* add_keyword *);




(***************************  command_table  ****************************)
(*									*)
(*			add_non_subcommand_keyword			*)
(*									*)
(************************************************************************)

procedure add_non_subcommand_keyword(
      name	: keyword_name;
      index	: keyword_index);

begin
  add_keyword(name, NO_LICENSE, NULL_STRING, index)
end (* add_non_subcommand_keyword *);



(***************************  command_table  ****************************)
(*									*)
(*			    add_value_required				*)
(*									*)
(************************************************************************)

procedure add_value_required(
      index	: keyword_index);

begin
  keyword_table[last_keyword_offset + index].value_required := TRUE
end (* add_value_required *);



(***************************  command_table  ****************************)
(*									*)
(*			   add_required_license				*)
(*									*)
(************************************************************************)

procedure add_required_license(
      required_license	: command_license;
      index		: keyword_index);

begin
  keyword_table[last_keyword_offset + index].required_license :=
    required_license
end (* add_required_license *);



(***************************  command_table  ****************************)
(*									*)
(*			     add_to_prompts				*)
(*									*)
(************************************************************************)

procedure add_to_prompts(
      index	: command_class_index;
      prompt	: command_prompt);

begin
  class_prompt[index] := prompt
end (* add_to_prompts *);



(***************************  command_table  ****************************)
(*									*)
(*	Always define sub-command words as first sub_defs.  Sub_defs	*)
(*	that are options for an argument should be defined sequentially.*)
(*									*)
(************************************************************************)


begin (* initial statement *)
$ifnone disk_maintenance_code
(* global command definitions *)


(* Netval DATE Command *)

  add_command('DATE\ ', NO_LICENSE, FALSE, GLOBAL_DATE_KEYWORD_OFFSET,
    GLOBAL_DATE_KEYWORD_MAX, GLOBAL_DATE_SUBCOMMAND_MAX,
    'Type current UTC date and time\ ', global_defs[GLOBAL_DATE]);


(* Netval HELP Command *)

  add_command('HELP\ ', NO_LICENSE, FALSE, GLOBAL_HELP_KEYWORD_OFFSET,
     GLOBAL_HELP_KEYWORD_MAX, GLOBAL_HELP_SUBCOMMAND_MAX,
     'Type legal commands\', global_defs[GLOBAL_HELP]);


(* Netval STATISTICS Command *)

  add_command('STATISTICS\ ', OPERATOR_LICENSE, FALSE,
    GLOBAL_STATISTICS_KEYWORD_OFFSET, GLOBAL_STATISTICS_KEYWORD_MAX,
    GLOBAL_STATISTICS_SUBCOMMAND_MAX,
    'Print collected disk I/O information\ ', global_defs[GLOBAL_STATISTICS]);


(* Netval VERSION Command *)

  add_command('VERSION\', NO_LICENSE, FALSE,
    GLOBAL_VERSION_KEYWORD_OFFSET, GLOBAL_VERSION_KEYWORD_MAX,
    GLOBAL_VERSION_SUBCOMMAND_MAX,
    'Type current NETVAL version number\ ', global_defs[GLOBAL_VERSION]);
!
(* archive command definitions *)


(* Netval Archive ASSIGN Command *)

  add_command('ASSIGN\ ', OPERATOR_LICENSE, TRUE,
    ARCHIVE_ASSIGN_KEYWORD_OFFSET, ARCHIVE_ASSIGN_KEYWORD_MAX,
    ARCHIVE_ASSIGN_SUBCOMMAND_MAX,
    'Reserve tape unit for validator\', archive_defs[ARCHIVE_ASSIGN]);


(* Netval Archive ATTACH Command *)

  add_command('ATTACH\ ', OPERATOR_LICENSE, TRUE,
    ARCHIVE_ATTACH_KEYWORD_OFFSET, ARCHIVE_ATTACH_KEYWORD_MAX,
    ARCHIVE_ATTACH_SUBCOMMAND_MAX,
    'Reserve tape unit for NETVAL slot\', archive_defs[ARCHIVE_ATTACH]);


(* Netval Archive DEASSIGN Command *)

  add_command('DEASSIGN\ ', OPERATOR_LICENSE, FALSE,
    ARCHIVE_DEASSIGN_KEYWORD_OFFSET, ARCHIVE_DEASSIGN_KEYWORD_MAX,
    ARCHIVE_DEASSIGN_SUBCOMMAND_MAX,
    'Free tape unit from validator\', archive_defs[ARCHIVE_DEASSIGN]);


(* Netval Archive DETACH Command *)

  add_command('DETACH\ ', OPERATOR_LICENSE, TRUE,
    ARCHIVE_DETACH_KEYWORD_OFFSET, ARCHIVE_DETACH_KEYWORD_MAX,
    ARCHIVE_DETACH_SUBCOMMAND_MAX,
    'Free tape unit from slot\ ', archive_defs[ARCHIVE_DETACH]);


(* Netval Archive DISPLAY Command *)

  add_command(DISPLAY_COMMAND_STRING, OPERATOR_LICENSE, TRUE,
    ARCHIVE_DISPLAY_KEYWORD_OFFSET, ARCHIVE_DISPLAY_KEYWORD_MAX,
    ARCHIVE_DISPLAY_SUBCOMMAND_MAX,
    'Type Archive tape information\', archive_defs[ARCHIVE_DISPLAY]);

  add_keyword('ID\ ', OPERATOR_LICENSE,
    'Display Archive tape ID\', ARCHIVE_DISPLAY_ID_KEYWORD);

  add_keyword('STATUS\ ', OPERATOR_LICENSE,
    'Display status of all tape units\ ', ARCHIVE_DISPLAY_STATUS_KEYWORD);

$if include_dump
(* Netval Archive DUMP command *)

  add_command('DUMP\ ', OPERATOR_LICENSE, TRUE,
    ARCHIVE_DUMP_KEYWORD_OFFSET, ARCHIVE_DUMP_KEYWORD_MAX,
    ARCHIVE_DUMP_SUBCOMMAND_MAX,
    'Dump CUD to tape in ASCII format\ ', archive_defs[ARCHIVE_DUMP]);

  add_non_subcommand_keyword(FROM_KEYWORD_STRING, ARCHIVE_DUMP_FROM_KEYWORD);
  add_value_required(ARCHIVE_DUMP_FROM_KEYWORD);
$endif include_dump


(* Netval Archive RETURN Command *)

  add_command('RETURN\ ', OPERATOR_LICENSE, FALSE,
    ARCHIVE_RETURN_KEYWORD_OFFSET, ARCHIVE_RETURN_KEYWORD_MAX,
    ARCHIVE_RETURN_SUBCOMMAND_MAX,
    'Return to system level\ ', archive_defs[ARCHIVE_RETURN]);


(* Netval Archive REWIND Command *)

  add_command('REWIND\ ', OPERATOR_LICENSE, TRUE,
    ARCHIVE_REWIND_KEYWORD_OFFSET, ARCHIVE_REWIND_KEYWORD_MAX,
    ARCHIVE_REWIND_SUBCOMMAND_MAX,
    'Return tape to beginning of reel\ ', archive_defs[ARCHIVE_REWIND]);

(* Netval Archive STORE Command *)

  add_command('STORE\', OPERATOR_LICENSE, TRUE,
    ARCHIVE_STORE_KEYWORD_OFFSET, ARCHIVE_STORE_KEYWORD_MAX,
    ARCHIVE_STORE_SUBCOMMAND_MAX,
    'Copy files from disk to tape\ ', archive_defs[ARCHIVE_STORE]);
!
(* validation command definitions *)


(* Netval ARCHIVE Command *)

  add_command('ARCHIVE\', OPERATOR_LICENSE, FALSE,
    PRIMARY_ARCHIVE_KEYWORD_OFFSET, PRIMARY_ARCHIVE_KEYWORD_MAX,
    PRIMARY_ARCHIVE_SUBCOMMAND_MAX,
    'Enter the Archive sub-system\ ', primary_defs[PRIMARY_ARCHIVE]);


(* Netval CHANGE Command *)

  add_command('CHANGE\ ',
$if NETVAL_IS_BOTH     NO_LICENSE,
$ifnone NETVAL_IS_BOTH
$ifnone NETVAL_IS_A_SLAVE     NO_LICENSE,
$if NETVAL_IS_A_SLAVE     NETWORK_ADMINISTRATOR_LICENSE,
$endif NETVAL_IS_BOTH
    TRUE, PRIMARY_CHANGE_KEYWORD_OFFSET, PRIMARY_CHANGE_KEYWORD_MAX,
    PRIMARY_CHANGE_SUBCOMMAND_MAX,
    'Modify an existing value\ ', primary_defs[PRIMARY_CHANGE]);

  add_keyword(ACCESS_KEYWORD_STRING,
$if NETVAL_IS_BOTH     ACCOUNT_SUPERVISOR_LICENSE,
$ifnone NETVAL_IS_BOTH
$ifnone NETVAL_IS_A_SLAVE     ACCOUNT_SUPERVISOR_LICENSE,
$if NETVAL_IS_A_SLAVE     NETWORK_ADMINISTRATOR_LICENSE,
$endif NETVAL_IS_BOTH
    'Modify an access profile for a user\', PRIMARY_CHANGE_ACCESS_KEYWORD);

  add_keyword(CLASS_KEYWORD_STRING, NETWORK_ADMINISTRATOR_LICENSE,
    'Modify the definition of a class\ ', PRIMARY_CHANGE_CLASS_KEYWORD);

  add_keyword(CONTROL_KEYWORD_STRING,
$if NETVAL_IS_BOTH     ACCOUNT_SUPERVISOR_LICENSE,
$ifnone NETVAL_IS_BOTH
$ifnone NETVAL_IS_A_SLAVE     ACCOUNT_SUPERVISOR_LICENSE,
$if NETVAL_IS_A_SLAVE     NETWORK_ADMINISTRATOR_LICENSE,
$endif NETVAL_IS_BOTH
    'Modify the control options for a user\', PRIMARY_CHANGE_CONTROL_KEYWORD);

  add_keyword(CUD_FILE_MESSAGE, PROGRAMMER_LICENSE,
    'Modify the in-core CUD buffer\', PRIMARY_CHANGE_CUD_KEYWORD);

  add_keyword(DISTRICT_KEYWORD_STRING,
$if NETVAL_IS_BOTH     ACCOUNT_SUPERVISOR_LICENSE,
$ifnone NETVAL_IS_BOTH
$ifnone NETVAL_IS_A_SLAVE     ACCOUNT_SUPERVISOR_LICENSE,
$if NETVAL_IS_A_SLAVE     NETWORK_ADMINISTRATOR_LICENSE,
$endif NETVAL_IS_BOTH
    'Modify the district for a user\ ', PRIMARY_CHANGE_DISTRICT_KEYWORD);
$if include_dnic

  add_keyword(DNIC_KEYWORD_STRING, NETWORK_ADMINISTRATOR_LICENSE,
    'Modify DNIC definition\ ', PRIMARY_CHANGE_DNIC_KEYWORD);
$endif INCLUDE_DNIC

  add_keyword(GAN_KEYWORD_STRING, NETWORK_ADMINISTRATOR_LICENSE,
    'Modify the GAN for a user\', PRIMARY_CHANGE_GAN_KEYWORD);

  add_keyword(GROUP_KEYWORD_STRING, NETWORK_ADMINISTRATOR_LICENSE,
    'Modify the definition of a group\ ', PRIMARY_CHANGE_GROUP_KEYWORD);

  add_keyword(HOSTLIST_KEYWORD_STRING, NETWORK_ADMINISTRATOR_LICENSE,
    'Modify the definition of a hostlist\', PRIMARY_CHANGE_HOSTLIST_KEYWORD);
$ifnot BEFORE_SUP_V43
$if allow_logon_inhibit

  add_keyword('INHIBIT\', NETWORK_ADMINISTRATOR_LICENSE,
    'Modify logon inhibit for a user\', PRIMARY_CHANGE_INHIBIT_KEYWORD);
$endif allow_logon_inhibit
$endif BEFORE_SUP_V43
$if INCLUDE_IRC

  add_keyword('IRC\', PROGRAMMER_LICENSE,
    'Modify the IRC number for a user\ ', PRIMARY_CHANGE_IRC_KEYWORD);
$endif INCLUDE_IRC

  add_keyword(NAME_KEYWORD_STRING,
$if NETVAL_IS_BOTH     ACCOUNT_SUPERVISOR_LICENSE,
$ifnone NETVAL_IS_BOTH
$ifnone NETVAL_IS_A_SLAVE     ACCOUNT_SUPERVISOR_LICENSE,
$if NETVAL_IS_A_SLAVE     NETWORK_ADMINISTRATOR_LICENSE,
$endif NETVAL_IS_BOTH
    'Modify the name for a user\ ', PRIMARY_CHANGE_NAME_KEYWORD);

  add_keyword(NODELIST_KEYWORD_STRING, NETWORK_ADMINISTRATOR_LICENSE,
    'Modify the definition a nodelist\ ', PRIMARY_CHANGE_NODELIST_KEYWORD);

$if restrict_users_by_time
  add_keyword(TIME_KEYWORD_STRING,
$if NETVAL_IS_BOTH     ACCOUNT_SUPERVISOR_LICENSE,
$ifnone NETVAL_IS_BOTH
$ifnone NETVAL_IS_A_SLAVE     ACCOUNT_SUPERVISOR_LICENSE,
$if NETVAL_IS_A_SLAVE     NETWORK_ADMINISTRATOR_LICENSE,
$endif NETVAL_IS_BOTH
    'Modify time restrictions for a user\', PRIMARY_CHANGE_TIME_KEYWORD);

$endif restrict_users_by_time
  add_keyword(PASSWORD_KEYWORD_STRING,
$if NETVAL_IS_BOTH     NO_LICENSE,
$ifnone NETVAL_IS_BOTH
$ifnone NETVAL_IS_A_SLAVE     NO_LICENSE,
$if NETVAL_IS_A_SLAVE     NETWORK_ADMINISTRATOR_LICENSE,
$endif NETVAL_IS_BOTH
    'Modify the password for a user\ ', PRIMARY_CHANGE_PASSWORD_KEYWORD);
$if UUNSassignable

  add_keyword(UUN_KEYWORD_STRING,
$if NETVAL_IS_BOTH     ACCOUNT_SUPERVISOR_LICENSE,
$ifnone NETVAL_IS_BOTH
$ifnone NETVAL_IS_A_SLAVE     ACCOUNT_SUPERVISOR_LICENSE,
$if NETVAL_IS_A_SLAVE     NETWORK_ADMINISTRATOR_LICENSE,
$endif NETVAL_IS_BOTH
    'Modify the UUN for a user\', PRIMARY_CHANGE_UUN_KEYWORD);
$endif UUNSassignable
$if password_expiration_date_in_cud

  add_keyword(validity_string, ACCOUNT_SUPERVISOR_LICENSE,
    'Modify the password validity period\', PRIMARY_CHANGE_VALIDITY_KEYWORD);
$endif password_expiration_date_in_cud
$if allow_temporary_apes

  add_non_subcommand_keyword(EXPIRE_KEYWORD_STRING,
    PRIMARY_CHANGE_ACCESS_EXPIRE_KEYWORD);
$endif allow_temporary_apes
$if INCLUDE_DNIC

  add_non_subcommand_keyword(DEFAULT_KEYWORD_STRING,
    PRIMARY_CHANGE_DNIC_DEFAULT_KEYWORD);
$endif include_dnic
$if include_list_descriptions

  add_non_subcommand_keyword(DESCRIPTION_KEYWORD_STRING,
    PRIMARY_CHANGE_LIST_DESCRIPTION_KEYWORD);
$endif include_list_descriptions

  add_non_subcommand_keyword('OFFSET\ ', PRIMARY_CHANGE_OFFSET_KEYWORD);
  add_value_required(PRIMARY_CHANGE_OFFSET_KEYWORD) (* buffer word offset *);


(* Netval CHECK Command *)

  add_command('CHECK\', AUDITOR_LICENSE, TRUE,
    PRIMARY_CHECK_KEYWORD_OFFSET, PRIMARY_CHECK_KEYWORD_MAX,
    PRIMARY_CHECK_SUBCOMMAND_MAX,
    'Report on the existence of a username\', primary_defs[PRIMARY_CHECK]);
$if special


(* Netval CLEAN Command *)

  add_command('CLEAN\', NO_LICENSE, TRUE, PRIMARY_CLEAN_KEYWORD_OFFSET,
    PRIMARY_CLEAN_KEYWORD_MAX, PRIMARY_CLEAN_SUBCOMMAND_MAX,
    'Clean up from MUD slide\', primary_defs[PRIMARY_CLEAN]);
$endif special


(* Netval CLEAR Command *)

  add_command('CLEAR\', NO_LICENSE, TRUE,
    PRIMARY_CLEAR_KEYWORD_OFFSET, PRIMARY_CLEAR_KEYWORD_MAX,
    PRIMARY_CLEAR_SUBCOMMAND_MAX, 'Turn off schedules \',
    primary_defs[PRIMARY_CLEAR]);

  add_keyword(CONSISTENCY_KEYWORD_STRING, OPERATOR_LICENSE,
    'Clear Automatic Consistency schedule\ ',
    PRIMARY_CLEAR_CONSISTENCY_KEYWORD);
$if force_password_change

  add_keyword('GANPASS\', ACCOUNT_SUPERVISOR_LICENSE,
    'Clear force password change designation\', PRIMARY_CLEAR_GANPASS_KEYWORD);
$endif force_password_change
$if global_password_only_login

  add_keyword('GPOGAN\ ', ACCOUNT_SUPERVISOR_LICENSE,
    'Clear global_password_only_login eligibility\ ',
    PRIMARY_CLEAR_GPOGAN_KEYWORD);
$endif global_password_only_login
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if force_password_change
  add_keyword('PASSCHANGER\', OPERATOR_LICENSE, 
    'Clear Passchanger schedule\ ', PRIMARY_CLEAR_PASSCHANGER_KEYWORD);
$endif force_password_change

(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if perform_daily_cud_scan

  add_keyword(CUDMAINTENANCE_KEYWORD_STRING, OPERATOR_LICENSE,
    'Clear CUD maintenance schedule\ ', PRIMARY_CLEAR_CUDMAINTENANCE_KEYWORD);
$endif perform_daily_cud_scan
$if reuse_uuns

  add_keyword('UUNMERGE\ ', OPERATOR_LICENSE,
    'Clear UUN Merge schedule\ ', PRIMARY_CLEAR_UUNMERGE_KEYWORD);
$endif reuse_uuns


(* Netval COMPARE Command *)

  add_command('COMPARE\',
$if check_time_status     NETWORK_ADMINISTRATOR_LICENSE,
$ifnone check_time_status    PROGRAMMER_LICENSE,
    FALSE, PRIMARY_COMPARE_KEYWORD_OFFSET, PRIMARY_COMPARE_KEYWORD_MAX,
    primary_compare_subcommand_max,
    'Display differences between CUD and MUD buffer\ ',
    primary_defs[PRIMARY_COMPARE]);


(* Netval CONSISTENCY Command *)

  add_command('CONSISTENCY\', OPERATOR_LICENSE, FALSE,
    PRIMARY_CONSISTENCY_KEYWORD_OFFSET, PRIMARY_CONSISTENCY_KEYWORD_MAX,
    PRIMARY_CONSISTENCY_SUBCOMMAND_MAX,
    'Perform a manual consistency\ ', primary_defs[PRIMARY_CONSISTENCY]);

  add_non_subcommand_keyword('NOCHANGE\ ',
    PRIMARY_CONSISTENCY_NOCHANGE_KEYWORD);

  add_non_subcommand_keyword(SUPERVISOR_KEYWORD_STRING,
    PRIMARY_CONSISTENCY_SUPERVISOR_KEYWORD);
  add_value_required(PRIMARY_CONSISTENCY_SUPERVISOR_KEYWORD) (* Sup number *);

  add_non_subcommand_keyword(FROM_KEYWORD_STRING,
    PRIMARY_CONSISTENCY_FROM_KEYWORD);
  add_value_required(PRIMARY_CONSISTENCY_FROM_KEYWORD) (* Block number *);
$if logical_volumes


(* Netval COPY Command *)

  add_command(COPY_COMMAND_STRING, OPERATOR_LICENSE, FALSE,
    PRIMARY_COPY_KEYWORD_OFFSET, PRIMARY_COPY_KEYWORD_MAX,
    PRIMARY_COPY_SUBCOMMAND_MAX, COPY_HELP_STRING, primary_defs[PRIMARY_COPY]);
$endif logical_volumes


(* Netval DELETE Command *)

  add_command(DELETE_KEYWORD_STRING, ACCOUNT_SUPERVISOR_LICENSE, TRUE,
    PRIMARY_DELETE_KEYWORD_OFFSET, PRIMARY_DELETE_KEYWORD_MAX,
    PRIMARY_DELETE_SUBCOMMAND_MAX,
    'Remove an existing value\ ', primary_defs[PRIMARY_DELETE]);

  add_keyword(ACCESS_KEYWORD_STRING,
$if NETVAL_IS_BOTH     NO_LICENSE,
$ifnone NETVAL_IS_BOTH
$ifnone NETVAL_IS_A_SLAVE     NO_LICENSE,
$if NETVAL_IS_A_SLAVE     NETWORK_ADMINISTRATOR_LICENSE,
$endif NETVAL_IS_BOTH
    'Remove an access profile for a user\', PRIMARY_DELETE_ACCESS_KEYWORD);

  add_keyword(CLASS_KEYWORD_STRING, NETWORK_ADMINISTRATOR_LICENSE,
    'Clear a class definition\ ', PRIMARY_DELETE_CLASS_KEYWORD);

$if INCLUDE_DNIC
  add_keyword(DNIC_KEYWORD_STRING, NETWORK_ADMINISTRATOR_LICENSE,
    'Remove a DNIC definition\ ', PRIMARY_DELETE_DNIC_KEYWORD);
$endif INCLUDE_DNIC

  add_keyword(GROUP_KEYWORD_STRING, NETWORK_ADMINISTRATOR_LICENSE,
    'Clear a group definition\ ', PRIMARY_DELETE_GROUP_KEYWORD);

  add_keyword(HOSTLIST_KEYWORD_STRING, NETWORK_ADMINISTRATOR_LICENSE,
    'Remove a hostlist definition\ ', PRIMARY_DELETE_HOSTLIST_KEYWORD);

  add_keyword(NODELIST_KEYWORD_STRING, NETWORK_ADMINISTRATOR_LICENSE,
    'Remove a nodelist definition\ ', PRIMARY_DELETE_NODELIST_KEYWORD);

  add_keyword(USER_KEYWORD_STRING,
$if NETVAL_IS_BOTH     NO_LICENSE,
$ifnone NETVAL_IS_BOTH
$ifnone NETVAL_IS_A_SLAVE     NO_LICENSE,
$if NETVAL_IS_A_SLAVE     NETWORK_ADMINISTRATOR_LICENSE,
$endif NETVAL_IS_BOTH
    'Invalidate a user\', PRIMARY_DELETE_USER_KEYWORD);


(* Netval DISPLAY Command *)

  add_command(DISPLAY_COMMAND_STRING, NO_LICENSE, TRUE,
    PRIMARY_DISPLAY_KEYWORD_OFFSET, PRIMARY_DISPLAY_KEYWORD_MAX,
    PRIMARY_DISPLAY_SUBCOMMAND_MAX,
    'Type Netval information\', primary_defs[PRIMARY_DISPLAY]);

  add_keyword(CLASS_KEYWORD_STRING, AUDITOR_LICENSE,
    'Type a class or all classes\', PRIMARY_DISPLAY_CLASS_KEYWORD);

  add_keyword(CUD_FILE_MESSAGE,
$if check_time_status     NETWORK_ADMINISTRATOR_LICENSE,
$ifnone check_time_status    PROGRAMMER_LICENSE,
    'Type contents of the CUD buffer\', PRIMARY_DISPLAY_CUD_KEYWORD);

  add_keyword('DIRECTORY\', DISPLAY_CUD_LICENSE,
    'Type specified fields of selected users\',
    PRIMARY_DISPLAY_DIRECTORY_KEYWORD);
$if INCLUDE_DNIC

  add_keyword(DNIC_KEYWORD_STRING, NETWORK_ADMINISTRATOR_LICENSE,
    'Type contents of DNIC file\ ', PRIMARY_DISPLAY_DNIC_KEYWORD);
$endif INCLUDE_DNIC

  add_keyword(FILTER_KEYWORD_STRING, OPERATOR_LICENSE,
    'Type current filter selections\ ', PRIMARY_DISPLAY_FILTER_KEYWORD);
$if force_password_change

  add_keyword('GANPASS\', ACCOUNT_SUPERVISOR_LICENSE,
    'Type GANS affected by Passchanger\', PRIMARY_DISPLAY_GANPASS_KEYWORD);
$endif force_password_change
$if global_password_only_login

  add_keyword('GPOGAN\ ', ACCOUNT_SUPERVISOR_LICENSE,
    'Type GANS eligible for global_password_only_login\',
    PRIMARY_DISPLAY_GPOGAN_KEYWORD);
$endif global_password_only_login

  add_keyword(GROUP_KEYWORD_STRING, AUDITOR_LICENSE,
    'Type a group or all groups\ ', PRIMARY_DISPLAY_GROUP_KEYWORD);

  add_keyword(HOSTLIST_KEYWORD_STRING, AUDITOR_LICENSE,
    'Type hostlist information\', PRIMARY_DISPLAY_HOSTLIST_KEYWORD);

  add_keyword(MUD_FILE_MESSAGE,
$if check_time_status     NETWORK_ADMINISTRATOR_LICENSE,
$ifnone check_time_status    PROGRAMMER_LICENSE,
    'Type the contents of the MUD buffer\', PRIMARY_DISPLAY_MUD_KEYWORD);

  add_keyword(NODELIST_KEYWORD_STRING, AUDITOR_LICENSE,
    'Type nodelist information\', PRIMARY_DISPLAY_NODELIST_KEYWORD);
$if prevent_duplicate_passwords

  add_keyword(PASSPERIOD_STRING, AUDITOR_LICENSE,
    'Type the minimum password change period\',
    PRIMARY_DISPLAY_PASSPERIOD_KEYWORD);
$endif prevent_duplicate_passwords

  add_keyword(PARAMETERS_KEYWORD_STRING, AUDITOR_LICENSE,
    'Type the next GAN and UUN to be assigned\ ',
    PRIMARY_DISPLAY_PARAMETERS_KEYWORD);

  add_keyword('SCHEDULE\ ', OPERATOR_LICENSE,
    'Type run times of scheduled processes\',
    PRIMARY_DISPLAY_SCHEDULE_KEYWORD);

  add_keyword('SELECT\ ', DISPLAY_CUD_LICENSE,
    'Type criteria created by Select Command\',PRIMARY_DISPLAY_SELECT_KEYWORD);
$if password_expiration_by_user

  add_keyword(VALIDITY_STRING, AUDITOR_LICENSE,
    'Type the standard password validity period\ ',
    PRIMARY_DISPLAY_VALIDITY_KEYWORD);
$endif password_expiration_by_user

  add_keyword('UPDATES\', OPERATOR_LICENSE,
    'Type Supervisor update information\ ', PRIMARY_DISPLAY_UPDATES_KEYWORD);

  add_keyword(USER_KEYWORD_STRING, DISPLAY_CUD_LICENSE,
    'Type the user entry for the specified name\ ',
    PRIMARY_DISPLAY_USER_KEYWORD);
$if logical_volumes

  add_keyword('VOLUMES\', OPERATOR_LICENSE,
    'Type current logical volume information\',
    PRIMARY_DISPLAY_VOLUMES_KEYWORD);
$endif logical_volumes

  add_non_subcommand_keyword(ALL_KEYWORD_STRING,
    PRIMARY_DISPLAY_CUD_ALL_KEYWORD);

  add_non_subcommand_keyword('FORMATTED\',
    PRIMARY_DISPLAY_CUD_FORMATTED_KEYWORD);
$if include_list_descriptions

  add_non_subcommand_keyword(DESCRIPTION_KEYWORD_STRING,
    PRIMARY_DISPLAY_LIST_DESCRIPTIONS_KEYWORD);
$endif include_list_descriptions

  add_non_subcommand_keyword('NAMES\', PRIMARY_DISPLAY_LIST_NAMES_KEYWORD);

  add_non_subcommand_keyword(UUN_KEYWORD_STRING,
    PRIMARY_DISPLAY_DIRECTORY_UUN_KEYWORD);

  add_non_subcommand_keyword(GAN_KEYWORD_STRING,
    PRIMARY_DISPLAY_DIRECTORY_GAN_KEYWORD);
  add_required_license(AUDITOR_LICENSE, PRIMARY_DISPLAY_DIRECTORY_GAN_KEYWORD);

  add_non_subcommand_keyword(DISTRICT_KEYWORD_STRING,
    PRIMARY_DISPLAY_DIRECTORY_DISTRICT_KEYWORD);

  add_non_subcommand_keyword(CONTROL_KEYWORD_STRING,
    PRIMARY_DISPLAY_DIRECTORY_CONTROL_KEYWORD);

  add_non_subcommand_keyword(PASSWORDDATE_KEYWORD_STRING,
    PRIMARY_DISPLAY_DIRECTORY_PASSWORDDATE_KEYWORD);

  add_non_subcommand_keyword(ENTRYDATE_KEYWORD_STRING,
    PRIMARY_DISPLAY_DIRECTORY_ENTRYDATE_KEYWORD);
$ifany (force_password_change, password_expiration_by_user)

  add_non_subcommand_keyword(EXPIREDATE_KEYWORD_STRING,
    PRIMARY_DISPLAY_DIRECTORY_EXPIREDATE_KEYWORD);
$endif (force_password_change, password_expiration_by_user)
$if restrict_users_by_time

  add_non_subcommand_keyword('TIMERESTRIC\',
    PRIMARY_DISPLAY_DIRECTORY_TIMERESTRICT_KEYWORD);

$endif restrict_users_by_time
  add_non_subcommand_keyword(ACCESS_KEYWORD_STRING,
    PRIMARY_DISPLAY_DIRECTORY_ACCESS_KEYWORD);

  add_non_subcommand_keyword('LINES\',PRIMARY_DISPLAY_DIRECTORY_LINES_KEYWORD);
  add_value_required(PRIMARY_DISPLAY_DIRECTORY_LINES_KEYWORD) (* page size *);
$if INCLUDE_DNIC

  add_non_subcommand_keyword(DEFAULT_KEYWORD_STRING,
    PRIMARY_DISPLAY_DNIC_DEFAULT_KEYWORD);

  add_non_subcommand_keyword(NONDEFAULT_KEYWORD_STRING,
    PRIMARY_DISPLAY_DNIC_ENTRY_KEYWORD);

$endif INCLUDE_DNIC
  add_non_subcommand_keyword('REPEAT\ ',
    PRIMARY_DISPLAY_UPDATES_REPEAT_KEYWORD);


(* Netval FILTER Command *)

  add_command(FILTER_KEYWORD_STRING, OPERATOR_LICENSE, TRUE,
    PRIMARY_FILTER_KEYWORD_OFFSET, PRIMARY_FILTER_KEYWORD_MAX,
    PRIMARY_FILTER_SUBCOMMAND_MAX,
    'Selects filter for Message Command display\ ',
    primary_defs[PRIMARY_FILTER]);

  add_non_subcommand_keyword(ALL_KEYWORD_STRING, PRIMARY_FILTER_ALL_KEYWORD);

  add_non_subcommand_keyword('ARCHIVE\', PRIMARY_FILTER_ARCHIVE_KEYWORD);
  add_required_license(OPERATOR_LICENSE, PRIMARY_FILTER_ARCHIVE_KEYWORD);

  add_non_subcommand_keyword(CONSISTENCY_KEYWORD_STRING,
    PRIMARY_FILTER_CONSISTENCY_KEYWORD);
  add_required_license(OPERATOR_LICENSE, PRIMARY_FILTER_CONSISTENCY_KEYWORD);

  add_non_subcommand_keyword('CUDERROR\ ', PRIMARY_FILTER_CUDERROR_KEYWORD);
  add_required_license(OPERATOR_LICENSE, PRIMARY_FILTER_CUDERROR_KEYWORD);
$if perform_daily_cud_scan

  add_non_subcommand_keyword(CUDMAINTENANCE_KEYWORD_STRING,
    PRIMARY_FILTER_CUDMAINTENANCE_KEYWORD);
  add_required_license(OPERATOR_LICENSE,PRIMARY_FILTER_CUDMAINTENANCE_KEYWORD);
$endif perform_daily_cud_scan

  add_non_subcommand_keyword('DEBUG\', PRIMARY_FILTER_DEBUG_KEYWORD);
  add_required_license(OPERATOR_LICENSE, PRIMARY_FILTER_DEBUG_KEYWORD);

  add_non_subcommand_keyword('FILE\ ', PRIMARY_FILTER_FILE_KEYWORD);
  add_required_license(OPERATOR_LICENSE, PRIMARY_FILTER_FILE_KEYWORD);
$if NETVAL_IS_A_SLAVE

  add_non_subcommand_keyword('MASTER\ ', PRIMARY_FILTER_MASTER_KEYWORD);
  add_required_license(AUDITOR_LICENSE, PRIMARY_FILTER_MASTER_KEYWORD);
$endif NETVAL_IS_A_SLAVE
$if CHANGES_TO_OPER_LOG

  add_non_subcommand_keyword('MODIFY\ ', PRIMARY_FILTER_MODIFY_KEYWORD);
  add_required_license(AUDITOR_LICENSE, PRIMARY_FILTER_MODIFY_KEYWORD);
$endif CHANGES_TO_OPER_LOG

  add_non_subcommand_keyword('MUDUPDATE\', PRIMARY_FILTER_MUDUPDATE_KEYWORD);
  add_required_license(OPERATOR_LICENSE, PRIMARY_FILTER_MUDUPDATE_KEYWORD);

  add_non_subcommand_keyword('OPERATOR\ ', PRIMARY_FILTER_OPERATOR_KEYWORD);
  add_required_license(OPERATOR_LICENSE, PRIMARY_FILTER_OPERATOR_KEYWORD);

  add_non_subcommand_keyword('PARAMETER\', PRIMARY_FILTER_PARAMETER_KEYWORD);
  add_required_license(OPERATOR_LICENSE, PRIMARY_FILTER_PARAMETER_KEYWORD);

  add_non_subcommand_keyword(SUPERVISOR_KEYWORD_STRING,
    PRIMARY_FILTER_SUPERVISOR_KEYWORD);
  add_required_license(OPERATOR_LICENSE, PRIMARY_FILTER_SUPERVISOR_KEYWORD);

  add_non_subcommand_keyword('SYSMSG1\', PRIMARY_FILTER_SYSMSG1_KEYWORD);
  add_required_license(OPERATOR_LICENSE, PRIMARY_FILTER_SYSMSG1_KEYWORD);
$ifany (force_password_change, global_password_only_login)

  add_non_subcommand_keyword('PASSCHANGER\', PRIMARY_FILTER_PASSCHANGER_KEYWORD);
$endif (force_password_change, global_password_only_login)

  add_non_subcommand_keyword('UN2\', PRIMARY_FILTER_UN2_KEYWORD);
  add_required_license(OPERATOR_LICENSE, PRIMARY_FILTER_UN2_KEYWORD);
$if REUSE_UUNS

  add_non_subcommand_keyword('UUNMERGE\ ', PRIMARY_FILTER_UUNMERGE_KEYWORD);
  add_required_license(OPERATOR_LICENSE, PRIMARY_FILTER_UUNMERGE_KEYWORD);
$endif REUSE_UUNS

  add_non_subcommand_keyword('VALIDATOR\', PRIMARY_FILTER_VALIDATOR_KEYWORD);
  add_required_license(OPERATOR_LICENSE, PRIMARY_FILTER_VALIDATOR_KEYWORD);
$if LOGICAL_VOLUMES

  add_non_subcommand_keyword('VOLUMES\', PRIMARY_FILTER_VOLUMES_KEYWORD);
  add_required_license(OPERATOR_LICENSE, PRIMARY_FILTER_VOLUMES_KEYWORD);
$endif LOGICAL_VOLUMES

  add_non_subcommand_keyword('NUMBER\ ',
    PRIMARY_FILTER_VALIDATOR_NUMBER_KEYWORD);
  add_value_required(PRIMARY_FILTER_VALIDATOR_NUMBER_KEYWORD);

  add_non_subcommand_keyword(USER_KEYWORD_STRING,
    PRIMARY_FILTER_VALIDATOR_USER_KEYWORD);
  add_value_required(PRIMARY_FILTER_VALIDATOR_USER_KEYWORD);
$if CHANGES_TO_OPER_LOG

  add_non_subcommand_keyword(ACCESS_KEYWORD_STRING,
    PRIMARY_FILTER_MODIFY_ACCESS_KEYWORD);

  add_non_subcommand_keyword(CONTROL_KEYWORD_STRING,
    PRIMARY_FILTER_MODIFY_CONTROL_KEYWORD);

  add_non_subcommand_keyword(DISTRICT_KEYWORD_STRING,
    PRIMARY_FILTER_MODIFY_DISTRICT_KEYWORD);
$if password_expiration_date_in_cud

  add_non_subcommand_keyword(EXPIREDATE_KEYWORD_STRING,
    PRIMARY_FILTER_MODIFY_EXPIRE_DATE_KEYWORD);
$endif password_expiration_date_in_cud

  add_non_subcommand_keyword(GAN_KEYWORD_STRING,
    PRIMARY_FILTER_MODIFY_GAN_KEYWORD);

  add_non_subcommand_keyword(NAME_KEYWORD_STRING,
    PRIMARY_FILTER_MODIFY_NAME_KEYWORD);
$ifnone before_sup_v43

  add_non_subcommand_keyword('NUD\', PRIMARY_FILTER_MODIFY_NUD_KEYWORD);
$endif before_sup_v43

  add_non_subcommand_keyword(PASSWORD_KEYWORD_STRING,
    PRIMARY_FILTER_MODIFY_PASSWORD_KEYWORD);
$if restrict_users_by_time

  add_non_subcommand_keyword(TIME_KEYWORD_STRING,
    PRIMARY_FILTER_MODIFY_TIME_KEYWORD);
$endif restrict_users_by_time

  add_non_subcommand_keyword(UUN_KEYWORD_STRING,
    PRIMARY_FILTER_MODIFY_UUN_KEYWORD);
$if NETVAL_IS_A_SLAVE

  add_non_subcommand_keyword('GFD\', PRIMARY_FILTER_MODIFY_GFD_KEYWORD);
$if INCLUDE_IRC

  add_non_subcommand_keyword('IRC\', PRIMARY_FILTER_MODIFY_IRC_KEYWORD);
$endif INCLUDE_IRC
$endif NETVAL_IS_A_SLAVE
$if OVERFLOW_CUD_ENTRIES

  add_non_subcommand_keyword('OVERFLOW\ ',
    PRIMARY_FILTER_MODIFY_OVERFLOW_KEYWORD);
$endif OVERFLOW_CUD_ENTRIES

  add_non_subcommand_keyword(DELETE_KEYWORD_STRING,
    PRIMARY_FILTER_MODIFY_DELETE_KEYWORD);

  add_non_subcommand_keyword(NEW_KEYWORD_STRING,
    PRIMARY_FILTER_MODIFY_NEW_KEYWORD);
$endif CHANGES_TO_OPER_LOG

  add_non_subcommand_keyword('OFF\', PRIMARY_FILTER_SUPERVISOR_OFF_KEYWORD);


(* Netval GET Command *)

  add_command('GET\',
$if check_time_status     NETWORK_ADMINISTRATOR_LICENSE,
$ifnone check_time_status    PROGRAMMER_LICENSE,
    TRUE, PRIMARY_GET_KEYWORD_OFFSET, PRIMARY_GET_KEYWORD_MAX,
    PRIMARY_GET_SUBCOMMAND_MAX,
    'Type the CUD block number of a username\', primary_defs[PRIMARY_GET]);


(* Netval HOST Command *)

  add_command('HOST\ ', OPERATOR_LICENSE, FALSE,
    PRIMARY_HOST_KEYWORD_OFFSET, PRIMARY_HOST_KEYWORD_MAX,
    PRIMARY_HOST_SUBCOMMAND_MAX,
    'Display host information or set host state\ ',primary_defs[PRIMARY_HOST]);

  add_keyword('SHUT\ ', NO_LICENSE,
    'Set Netval to be accessible only by shut override users\',
    PRIMARY_HOST_SHUT_KEYWORD);

  add_keyword('STATUS\ ', NO_LICENSE,
    'Display current host information\ ', PRIMARY_HOST_STATUS_KEYWORD);

  add_keyword('UP\ ', NO_LICENSE,
    'Allow all users access to Netval\ ', PRIMARY_HOST_UP_KEYWORD);


(* Netval MESSAGE Command *)

  add_command('MESSAGE\', OPERATOR_LICENSE, TRUE,
    PRIMARY_MESSAGE_KEYWORD_OFFSET, PRIMARY_MESSAGE_KEYWORD_MAX,
    PRIMARY_MESSAGE_SUBCOMMAND_MAX,
    'Display information from the Operator log\',
    primary_defs[PRIMARY_MESSAGE]);

  add_non_subcommand_keyword(FROM_KEYWORD_STRING,PRIMARY_MESSAGE_FROM_KEYWORD);


(* Netval NEW Command *)

  add_command(NEW_KEYWORD_STRING, ACCOUNT_SUPERVISOR_LICENSE, TRUE,
    PRIMARY_NEW_KEYWORD_OFFSET, PRIMARY_NEW_KEYWORD_MAX,
    PRIMARY_NEW_SUBCOMMAND_MAX,
    'Validate a new value\ ', primary_defs[PRIMARY_NEW]);

  add_keyword(ACCESS_KEYWORD_STRING,
$if NETVAL_IS_BOTH     NO_LICENSE,
$ifnone NETVAL_IS_BOTH
$ifnone NETVAL_IS_A_SLAVE     NO_LICENSE,
$if NETVAL_IS_A_SLAVE     NETWORK_ADMINISTRATOR_LICENSE,
$endif NETVAL_IS_BOTH
    'Add an access entry to a user\', PRIMARY_NEW_ACCESS_KEYWORD);

$if INCLUDE_DNIC
  add_keyword(DNIC_KEYWORD_STRING, NETWORK_ADMINISTRATOR_LICENSE,
    'Define a new DNIC definition\ ', PRIMARY_NEW_DNIC_KEYWORD);
$endif INCLUDE_DNIC

  add_keyword(HOSTLIST_KEYWORD_STRING, NETWORK_ADMINISTRATOR_LICENSE,
    'Define a new hostlist\', PRIMARY_NEW_HOSTLIST_KEYWORD);

  add_keyword(NODELIST_KEYWORD_STRING, NETWORK_ADMINISTRATOR_LICENSE,
    'Define a new nodelist\', PRIMARY_NEW_NODELIST_KEYWORD);

  add_keyword(USER_KEYWORD_STRING,
$if NETVAL_IS_BOTH     NO_LICENSE,
$ifnone NETVAL_IS_BOTH
$ifnone NETVAL_IS_A_SLAVE     NO_LICENSE,
$if NETVAL_IS_A_SLAVE     NETWORK_ADMINISTRATOR_LICENSE,
$endif NETVAL_IS_BOTH
    'Add a new user\ ', PRIMARY_NEW_USER_KEYWORD);
$if allow_temporary_apes

  add_non_subcommand_keyword(EXPIRE_KEYWORD_STRING,
    PRIMARY_NEW_ACCESS_EXPIRE_KEYWORD);
$endif allow_temporary_apes
  add_non_subcommand_keyword('AS\ ', PRIMARY_NEW_USER_AS_KEYWORD);
$if validate_x25_names

  add_non_subcommand_keyword('X25\', PRIMARY_NEW_USER_X25_KEYWORD);
$endif validate_x25_names
$if special


(* Netval OLDPASS Command *)

  add_command('OLDPASS\', NO_LICENSE, FALSE, PRIMARY_OLDPASS_KEYWORD_OFFSET,
    PRIMARY_OLDPASS_KEYWORD_MAX, PRIMARY_OLDPASS_SUBCOMMAND_MAX,
    'List old password users\', primary_defs[PRIMARY_OLDPASS]);
$endif special


(* Netval QUIT Command *)

  add_command('QUIT\ ', NO_LICENSE, FALSE,
    PRIMARY_QUIT_KEYWORD_OFFSET, PRIMARY_QUIT_KEYWORD_MAX,
    PRIMARY_QUIT_SUBCOMMAND_MAX,
    'Exit from NETVAL\ ', primary_defs[PRIMARY_QUIT]);


(* Netval READ Command *)

  add_command('READ\ ', NETWORK_ADMINISTRATOR_LICENSE, FALSE,
    PRIMARY_READ_KEYWORD_OFFSET, PRIMARY_READ_KEYWORD_MAX,
    PRIMARY_READ_SUBCOMMAND_MAX,
    'Read Supervisor or NETVAL information\', primary_defs[PRIMARY_READ]);

  add_keyword(CUD_FILE_MESSAGE,
$if check_time_status     NETWORK_ADMINISTRATOR_LICENSE,
$ifnone check_time_status    PROGRAMMER_LICENSE,
    'Input a block of the CUD into the CUD buffer\ ',PRIMARY_READ_CUD_KEYWORD);
$if INCLUDE_DNIC

  add_keyword(DNIC_KEYWORD_STRING, NETWORK_ADMINISTRATOR_LICENSE,
    'Type Supervisor or NETVAL DNIC table\ ',PRIMARY_READ_DNIC_KEYWORD);
$endif INCLUDE_DNIC

  add_keyword(MUD_FILE_MESSAGE,
$if check_time_status     NETWORK_ADMINISTRATOR_LICENSE,
$ifnone check_time_status    PROGRAMMER_LICENSE,
    'Input a block of MUD into the MUD buffer\ ', PRIMARY_READ_MUD_KEYWORD);
  add_value_required(PRIMARY_READ_MUD_KEYWORD) (* Supervisor number *);

  add_keyword('TABLE\', NETWORK_ADMINISTRATOR_LICENSE,
    'Type Supervisor or NETVAL Class/group table\',PRIMARY_READ_TABLE_KEYWORD);

  add_non_subcommand_keyword('BLOCK\', PRIMARY_READ_BLOCK_KEYWORD);
  add_value_required(PRIMARY_READ_BLOCK_KEYWORD) (* CUD/MUD block number *);
$if INCLUDE_DNIC

  add_non_subcommand_keyword(DEFAULT_KEYWORD_STRING,
    PRIMARY_READ_DNIC_DEFAULT_KEYWORD);

  add_non_subcommand_keyword(NONDEFAULT_KEYWORD_STRING,
    PRIMARY_READ_DNIC_ENTRY_KEYWORD);
$endif INCLUDE_DNIC

  add_non_subcommand_keyword('LOCK\ ', PRIMARY_READ_LOCK_KEYWORD);
  add_required_license(PROGRAMMER_LICENSE, PRIMARY_READ_LOCK_KEYWORD);

  add_non_subcommand_keyword(SUPERVISOR_KEYWORD_STRING,
    PRIMARY_READ_SUPERVISOR_KEYWORD);
  add_value_required(PRIMARY_READ_SUPERVISOR_KEYWORD) (* Sup number *);

  add_non_subcommand_keyword(CLASS_KEYWORD_STRING,
    PRIMARY_READ_TABLE_CLASS_KEYWORD);
  add_value_required(PRIMARY_READ_TABLE_CLASS_KEYWORD);

  add_non_subcommand_keyword(GROUP_KEYWORD_STRING,
    PRIMARY_READ_TABLE_GROUP_KEYWORD);
  add_value_required(PRIMARY_READ_TABLE_GROUP_KEYWORD);
$if changes_to_oper_log


(* Netval REMARK Command *)

  add_command('REMARK\ ',
$if NETVAL_IS_BOTH     ACCOUNT_SUPERVISOR_LICENSE,
$ifnone NETVAL_IS_BOTH
$ifnone NETVAL_IS_A_SLAVE     ACCOUNT_SUPERVISOR_LICENSE,
$if NETVAL_IS_A_SLAVE     NETWORK_ADMINISTRATOR_LICENSE,
$endif NETVAL_IS_BOTH
    FALSE, PRIMARY_REMARK_KEYWORD_OFFSET, PRIMARY_REMARK_KEYWORD_MAX,
    PRIMARY_REMARK_SUBCOMMAND_MAX,
    'Enter a string to be added to CHANGE CUD oper log messages\ ',
    primary_defs[PRIMARY_REMARK]);
$endif changes_to_oper_log


(* Netval SCHEDULE Command *)

  add_command('SCHEDULE\ ', OPERATOR_LICENSE, FALSE,
    PRIMARY_SCHEDULE_KEYWORD_OFFSET, PRIMARY_SCHEDULE_KEYWORD_MAX,
    PRIMARY_SCHEDULE_SUBCOMMAND_MAX,
    'Designate run times for scheduled processes\',
    primary_defs[PRIMARY_SCHEDULE]);

  add_keyword(CONSISTENCY_KEYWORD_STRING, OPERATOR_LICENSE,
    'Define the automatic consistency period\',
    PRIMARY_SCHEDULE_CONSISTENCY_KEYWORD);
  
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if force_password_change
  add_keyword('PASSCHANGER\', OPERATOR_LICENSE, 
  'Designate run time for Passchanger\ ', PRIMARY_SCHEDULE_PASSCHANGER_KEYWORD);
$endif force_password_change
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if reuse_uuns

  add_keyword('UUNMERGE\ ', OPERATOR_LICENSE,
    'Designate run time for UUN merger\', PRIMARY_SCHEDULE_UUNMERGE_KEYWORD);
$endif reuse_uuns


(* Netval SELECT Command *)

  add_command('SELECT\ ', DISPLAY_CUD_LICENSE, TRUE,
    PRIMARY_SELECT_KEYWORD_OFFSET, PRIMARY_SELECT_KEYWORD_MAX,
    PRIMARY_SELECT_SUBCOMMAND_MAX,
    'Designate criteria for Display Directory Command selections\',
    primary_defs[PRIMARY_SELECT]);

  add_non_subcommand_keyword(ALL_KEYWORD_STRING, PRIMARY_SELECT_ALL_KEYWORD);

  add_non_subcommand_keyword(ACCESS_KEYWORD_STRING,
    PRIMARY_SELECT_ACCESS_KEYWORD);

  add_non_subcommand_keyword(GAN_KEYWORD_STRING, PRIMARY_SELECT_GAN_KEYWORD);
  add_required_license(AUDITOR_LICENSE, PRIMARY_SELECT_GAN_KEYWORD);

  add_non_subcommand_keyword(DISTRICT_KEYWORD_STRING,
    PRIMARY_SELECT_DISTRICT_KEYWORD);

  add_non_subcommand_keyword(UUN_KEYWORD_STRING, PRIMARY_SELECT_UUN_KEYWORD);

  add_non_subcommand_keyword(CONTROL_KEYWORD_STRING,
    PRIMARY_SELECT_CONTROL_KEYWORD);

  add_non_subcommand_keyword(ENTRYDATE_KEYWORD_STRING,
    PRIMARY_SELECT_ENTRYDATE_KEYWORD);
$ifany (force_password_change, password_expiration_by_user)

  add_non_subcommand_keyword(EXPIREDATE_KEYWORD_STRING,
    PRIMARY_SELECT_EXPIREDATE_KEYWORD);
$endif (force_password_change, password_expiration_by_user)

  add_non_subcommand_keyword(PASSWORDDATE_KEYWORD_STRING,
    PRIMARY_SELECT_PASSWORDDATE_KEYWORD);

  add_non_subcommand_keyword(CLASS_KEYWORD_STRING,
    PRIMARY_SELECT_CLASS_ACCESS_KEYWORD);
$if allow_temporary_apes

  add_non_subcommand_keyword('TEMPORARY\',
    PRIMARY_SELECT_TEMP_ACCESS_KEYWORD);
$endif allow_temporary_apes

  add_non_subcommand_keyword(GROUP_KEYWORD_STRING,
    PRIMARY_SELECT_GROUP_ACCESS_KEYWORD);

  add_non_subcommand_keyword(HOST_KEYWORD_STRING,
    PRIMARY_SELECT_HOST_ACCESS_KEYWORD);

  add_non_subcommand_keyword(NODE_KEYWORD_STRING,
    PRIMARY_SELECT_NODE_ACCESS_KEYWORD);
$ifnot BEFORE_SUP_V43

  add_non_subcommand_keyword('UOK\',
    PRIMARY_SELECT_ACCESS_CONTROL_USERNAME_OK_KEYWORD);

  add_non_subcommand_keyword('DOK\',
    PRIMARY_SELECT_ACCESS_CONTROL_HOSTNAME_OK_KEYWORD);

  add_non_subcommand_keyword('ANC\',
    PRIMARY_SELECT_ACCESS_CONTROL_NORMAL_KEYWORD);

  add_non_subcommand_keyword('AAC\',
    PRIMARY_SELECT_ACCESS_CONTROL_AUXILIARY_KEYWORD);

  add_non_subcommand_keyword('URC\',
    PRIMARY_SELECT_ACCESS_CONTROL_USER_REGULAR_CALL_KEYWORD);

  add_non_subcommand_keyword('UCC\',
    PRIMARY_SELECT_ACCESS_CONTROL_USER_COLLECT_CALL_KEYWORD);

  add_non_subcommand_keyword('DRC\',
    PRIMARY_SELECT_ACCESS_CONTROL_HOST_REGULAR_CALL_KEYWORD);

  add_non_subcommand_keyword('DCC\',
    PRIMARY_SELECT_ACCESS_CONTROL_HOST_COLLECT_CALL_KEYWORD);

  add_non_subcommand_keyword('SO\ ',
    PRIMARY_SELECT_ACCESS_CONTROL_SHUT_OVERRIDE_KEYWORD);

  add_non_subcommand_keyword('RD\ ',
    PRIMARY_SELECT_ACCESS_CONTROL_REQUIRE_HOSTNAME_KEYWORD);

  add_non_subcommand_keyword('TD\ ',
    PRIMARY_SELECT_ACCESS_CONTROL_TARGET_DESTINATION_KEYWORD);

  add_non_subcommand_keyword('PC\ ',
    PRIMARY_SELECT_ACCESS_CONTROL_PRIORITY_CONTINUE_KEYWORD);

$endif BEFORE_SUP_V43


  add_non_subcommand_keyword('AFTER\', PRIMARY_SELECT_AFTER_DATE_KEYWORD);


  add_non_subcommand_keyword('BEFORE\ ', PRIMARY_SELECT_BEFORE_DATE_KEYWORD);
$if NETVAL_IS_A_SLAVE


  add_non_subcommand_keyword('GFDONLY\', PRIMARY_SELECT_GFD_ONLY_DATE_KEYWORD);
$endif NETVAL_IS_A_SLAVE

  add_non_subcommand_keyword('LI\ ', PRIMARY_SELECT_CONTROL_LICENSED_KEYWORD);

  add_non_subcommand_keyword('PO\ ',
    PRIMARY_SELECT_CONTROL_PASSWORD_ONLY_KEYWORD);

  add_non_subcommand_keyword('AS\ ',
    PRIMARY_SELECT_CONTROL_ACCOUNT_SUPERVISOR_KEYWORD);

  add_non_subcommand_keyword('ID\ ',
    PRIMARY_SELECT_CONTROL_IGNORE_DESTINATION_KEYWORD);
$ifnone BEFORE_SUP_V43

  add_non_subcommand_keyword('UT\ ', PRIMARY_SELECT_CONTROL_USERTYPE_KEYWORD);

  add_non_subcommand_keyword('DT\ ', PRIMARY_SELECT_CONTROL_HOSTTYPE_KEYWORD);
$if allow_logon_inhibit

  add_non_subcommand_keyword('LG\ ',
    PRIMARY_SELECT_CONTROL_LOGON_INHIBIT_KEYWORD);
$endif allow_logon_inhibit
$endif BEFORE_SUP_V43

  add_non_subcommand_keyword('NA\ ',
    PRIMARY_SELECT_CONTROL_NETWORK_ADMINISTRATOR_KEYWORD);

  add_non_subcommand_keyword('NP\ ',
    PRIMARY_SELECT_CONTROL_NO_PASSWORD_REQUIRED_KEYWORD);
$ifnot BEFORE_SUP_V43

  add_non_subcommand_keyword('AP\ ',
    PRIMARY_SELECT_CONTROL_AUX_PASSWORD_KEYWORD);

  add_non_subcommand_keyword('TE\ ',
    PRIMARY_SELECT_CONTROL_TARGET_ENTRY_KEYWORD);

  add_non_subcommand_keyword('PD\ ',
    PRIMARY_SELECT_CONTROL_PROHIBIT_DEFAULT_KEYWORD);
$endif BEFORE_SUP_V43
$if BEFORE_SUP_V43

  add_non_subcommand_keyword('SO\ ',
    PRIMARY_SELECT_CONTROL_SHUT_OVERRIDE_KEYWORD);
$endif BEFORE_SUP_V43

  add_non_subcommand_keyword('AU\ ', PRIMARY_SELECT_CONTROL_AUDITOR_KEYWORD);

  add_non_subcommand_keyword('OP\ ', PRIMARY_SELECT_CONTROL_OPERATOR_KEYWORD);
$if force_password_change

  add_non_subcommand_keyword('FE\ ',
    PRIMARY_SELECT_CONTROL_FORCE_PASSWD_CHG_EXEMPT_KEYWORD);
$endif force_password_change
$if password_expiration_by_user

  add_non_subcommand_keyword('EE\ ',
    PRIMARY_SELECT_CONTROL_EXPIRATION_EXEMPT_KEYWORD);
$endif password_expiration_by_user
$if no_self_password_change

  add_non_subcommand_keyword('NS\ ',
    PRIMARY_SELECT_CONTROL_NO_SELF_PASSWD_CHANGE_KEYWORD);
$endif no_self_password_change

  add_non_subcommand_keyword('TL\ ',
    PRIMARY_SELECT_CONTROL_TRANSPARENT_LOGIN_KEYWORD);


(* Netval SEND Command *)

  add_command('SEND\ ', NETWORK_ADMINISTRATOR_LICENSE, FALSE,
    PRIMARY_SEND_KEYWORD_OFFSET, PRIMARY_SEND_KEYWORD_MAX,
    PRIMARY_SEND_SUBCOMMAND_MAX,
    'Initiate transmission of Supervisor table\',
    primary_defs[PRIMARY_SEND]);
$if include_dnic

  add_keyword(DNIC_KEYWORD_STRING, NETWORK_ADMINISTRATOR_LICENSE,
    'Send DNIC table\', PRIMARY_SEND_DNIC_KEYWORD);

  add_keyword('TABLE\', NETWORK_ADMINISTRATOR_LICENSE,
    'Send Class/group table\ ', PRIMARY_SEND_TABLE_KEYWORD);
$endif include_dnic

  add_non_subcommand_keyword('WAIT\ ', PRIMARY_SEND_WAIT_KEYWORD);


(* Netval SET Command *)

  add_command('SET\', OPERATOR_LICENSE, TRUE,
    PRIMARY_SET_KEYWORD_OFFSET, PRIMARY_SET_KEYWORD_MAX,
    PRIMARY_SET_SUBCOMMAND_MAX,
    'Define a system value\', primary_defs[PRIMARY_SET]);
$if logical_volumes

  add_keyword('DRIVE\', NO_LICENSE,
    'Set designated drive offline\ ', PRIMARY_SET_DRIVE_KEYWORD);
  add_value_required(PRIMARY_SET_DRIVE_KEYWORD) (* Drive number *);
$endif logical_volumes
$if force_password_change

  add_keyword('GANPASS\', NETWORK_ADMINISTRATOR_LICENSE,
    'Designate the members of a GAN as subject to Passchanger\ ',
    PRIMARY_SET_GANPASS_KEYWORD);
$endif force_password_change
$if global_password_only_login

  add_keyword('GPOGAN\ ', NETWORK_ADMINISTRATOR_LICENSE,
    'Designate a gan as eligible for global_password_only_login\ ',
    PRIMARY_SET_GPOGAN_KEYWORD);
$endif global_password_only_login
$if prevent_duplicate_passwords

  add_keyword(PASSPERIOD_STRING, NETWORK_ADMINISTRATOR_LICENSE,
    'Define the minimum password change period\',
    PRIMARY_SET_PASSPERIOD_KEYWORD);
$endif prevent_duplicate_passwords
$if password_expiration_by_user

  add_keyword(VALIDITY_STRING, NETWORK_ADMINISTRATOR_LICENSE,
    'Define the standard password validity period\ ',
    PRIMARY_SET_VALIDITY_KEYWORD);
$endif password_expiration_by_user

  add_keyword(SUPERVISOR_KEYWORD_STRING, OPERATOR_LICENSE,
    'Define the legal Netval Supervisors\', PRIMARY_SET_SUPERVISOR_KEYWORD);
  add_value_required(PRIMARY_SET_SUPERVISOR_KEYWORD) (* Supervisor number *);
$if logical_volumes

  add_non_subcommand_keyword('OFFLINE\', PRIMARY_SET_DRIVE_OFFLINE_KEYWORD);
$endif logical_volumes

  add_non_subcommand_keyword('ON\ ', PRIMARY_SET_SUPERVISOR_ON_KEYWORD);

  add_non_subcommand_keyword('OFF\', PRIMARY_SET_SUPERVISOR_OFF_KEYWORD);


(* Netval STOP Command *)

  add_command('STOP\ ', OPERATOR_LICENSE, FALSE,
    PRIMARY_STOP_KEYWORD_OFFSET, PRIMARY_STOP_KEYWORD_MAX,
    PRIMARY_STOP_SUBCOMMAND_MAX,
    'Halt a running automatic consistency\ ', primary_defs[PRIMARY_STOP]);

  add_non_subcommand_keyword(SUPERVISOR_KEYWORD_STRING,
    PRIMARY_STOP_SUPERVISOR_KEYWORD);
  add_value_required(PRIMARY_STOP_SUPERVISOR_KEYWORD) (* Supervisor number *);


(* Netval UNLOCK Command *)

  add_command('UNLOCK\ ', PROGRAMMER_LICENSE, FALSE,
    PRIMARY_UNLOCK_KEYWORD_OFFSET, PRIMARY_UNLOCK_KEYWORD_MAX,
    PRIMARY_UNLOCK_SUBCOMMAND_MAX,
    'Unlock a locked CUD block\', primary_defs[PRIMARY_UNLOCK]);


(* Netval WRITE Command *)

  add_command('WRITE\', PROGRAMMER_LICENSE, FALSE,
    PRIMARY_WRITE_KEYWORD_OFFSET, PRIMARY_WRITE_KEYWORD_MAX,
    PRIMARY_WRITE_SUBCOMMAND_MAX,
    'Record CUD or MUD buffer\ ', primary_defs[PRIMARY_WRITE]);

  add_keyword(CUD_FILE_MESSAGE, PROGRAMMER_LICENSE,
    'Record CUD buffer\', PRIMARY_WRITE_CUD_KEYWORD);

  add_keyword(MUD_FILE_MESSAGE, PROGRAMMER_LICENSE,
    'Record MUD buffer to specified Supervisor\', PRIMARY_WRITE_MUD_KEYWORD);
  add_value_required(PRIMARY_WRITE_MUD_KEYWORD) (* Supervisor number *);

  add_non_subcommand_keyword(FROM_KEYWORD_STRING,
    PRIMARY_WRITE_CUD_FROM_KEYWORD);
  add_non_subcommand_keyword(SUPERVISOR_KEYWORD_STRING,
    PRIMARY_WRITE_CUD_FROM_SUPERVISOR_KEYWORD);
$endif disk_maintenance_code
$if disk_maintenance_code


(* global command definitions *)


(* NVDM DATE Command *)

  add_command('DATE\ ', NO_LICENSE, FALSE,
    GLOBAL_DATE_KEYWORD_OFFSET, GLOBAL_DATE_KEYWORD_MAX,
    GLOBAL_DATE_SUBCOMMAND_MAX,
    'Type current UTC date and time\ ', global_defs[global_date]);


(* NVDM HELP Command *)

  add_command('HELP\ ', NO_LICENSE, FALSE,
    GLOBAL_HELP_KEYWORD_OFFSET, GLOBAL_HELP_KEYWORD_MAX,
    GLOBAL_HELP_SUBCOMMAND_MAX,
    'Type list of legal commands\', global_defs[global_help]);


(* NVDM STATISTICS Command *)

  add_command('STATISTICS\ ', NO_LICENSE, FALSE,
    GLOBAL_STATISTICS_KEYWORD_OFFSET, GLOBAL_STATISTICS_KEYWORD_MAX,
    GLOBAL_STATISTICS_SUBCOMMAND_MAX,
    'Print collected disk I/O information\ ', global_defs[global_statistics]);


(* NVDM VERSION Command *)

  add_command('VERSION\', NO_LICENSE, FALSE,
    GLOBAL_VERSION_KEYWORD_OFFSET, GLOBAL_VERSION_KEYWORD_MAX,
    GLOBAL_VERSION_SUBCOMMAND_MAX,
    'Type current NETVAL Disk Maintenance version number\',
    global_defs[global_version]);
!
(* archive command definitions *)


(* NVDM Archive ATTACH Command *)

  add_command('ATTACH\ ', NO_LICENSE, TRUE,
    ARCHIVE_ATTACH_KEYWORD_OFFSET, ARCHIVE_ATTACH_KEYWORD_MAX,
    ARCHIVE_ATTACH_SUBCOMMAND_MAX,
    'Reserve tape unit for NETVAL slot\', archive_defs[ARCHIVE_ATTACH]);


(* NVDM Archive DETACH Command *)

  add_command('DETACH\ ', NO_LICENSE, TRUE,
    ARCHIVE_DETACH_KEYWORD_OFFSET, ARCHIVE_DETACH_KEYWORD_MAX,
    ARCHIVE_DETACH_SUBCOMMAND_MAX,
    'Free tape unit from slot\ ', archive_defs[ARCHIVE_DETACH]);


(* NVDM Archive DISPLAY Command *)

  add_command(DISPLAY_COMMAND_STRING, NO_LICENSE, TRUE,
    ARCHIVE_DISPLAY_KEYWORD_OFFSET, ARCHIVE_DISPLAY_KEYWORD_MAX,
    ARCHIVE_DISPLAY_SUBCOMMAND_MAX,
    'Type Archive tape information\', archive_defs[ARCHIVE_DISPLAY]);
$if convert_to_43


(* NVDM Archive REFORMAT Command *)

  add_command('REFORMAT\ ', PROGRAMMER_LICENSE, TRUE,
    ARCHIVE_REFORMAT_KEYWORD_OFFSET, ARCHIVE_REFORMAT_KEYWORD_MAX,
    ARCHIVE_REFORMAT_SUBCOMMAND_MAX,
    'Convert CUD prior to version 43 to the version 43 format\ ',
    archive_defs[ARCHIVE_REFORMAT]);
$endif convert_to_43
$ifnone convert_to_43


(* NVDM Archive RESTORE Command *)

  add_command('RESTORE\', NO_LICENSE, TRUE,
    ARCHIVE_RESTORE_KEYWORD_OFFSET, ARCHIVE_RESTORE_KEYWORD_MAX,
    ARCHIVE_RESTORE_SUBCOMMAND_MAX,
    'Copy file(s) from tape to disk\ ', archive_defs[ARCHIVE_RESTORE]);

  add_keyword(ALL_KEYWORD_STRING, NO_LICENSE,
    'Copy all files from tape to disk\ ', ARCHIVE_RESTORE_ALL_KEYWORD);

  add_keyword(CUD_FILE_MESSAGE, NO_LICENSE,
    'Copy the CUD and CUD Parameter files from tape to disk\ ',
    ARCHIVE_RESTORE_CUD_KEYWORD);

  add_keyword('MUDUPDATE\', NO_LICENSE,
    'Copy the MUDUPDATE file header from tape to disk\ ',
    ARCHIVE_RESTORE_MUDUPDATE_KEYWORD);
$if include_dnic

  add_keyword(DNIC_KEYWORD_STRING, NO_LICENSE,
    'Copy the DNIC file from tape to disk\ ',
    ARCHIVE_RESTORE_DNIC_FILE_KEYWORD);
$endif include_dnic

  add_keyword(NODE_KEYWORD_STRING, NO_LICENSE,
    'Copy the NODE HOST files from tape to disk\ ',
    ARCHIVE_RESTORE_NODE_KEYWORD);

  add_keyword('OPERLOG\', NO_LICENSE,
    'Copy the OPERATOR LOG file from tape to disk\ ',
    ARCHIVE_RESTORE_OPERLOG_KEYWORD);
$if ganpass_file_exists

  add_keyword('PASSTABLE\', NO_LICENSE,
    'Copy the PASSTABLE file from tape to disk\',
    ARCHIVE_RESTORE_PASSTABLE_KEYWORD);
$endif ganpass_file_exists

  add_keyword('SCHEDTABLE\ ', NO_LICENSE,
    'Copy the SCHEDTABLE file from tape to disk\ ',
    ARCHIVE_RESTORE_SCHEDTABLE_KEYWORD);

  add_non_subcommand_keyword('BLOCK\', ARCHIVE_RESTORE_BLOCK_KEYWORD);
$endif convert_to_43


(* NVDM Archive RETURN Command *)

  add_command('RETURN\ ', NO_LICENSE, FALSE,
    ARCHIVE_RETURN_KEYWORD_OFFSET, ARCHIVE_RETURN_KEYWORD_MAX,
    ARCHIVE_RETURN_SUBCOMMAND_MAX,
    'Return to system level\ ', archive_defs[ARCHIVE_RETURN]);


(* NVDM Archive REWIND Command *)

  add_command('REWIND\ ', NO_LICENSE, TRUE,
    ARCHIVE_REWIND_KEYWORD_OFFSET, ARCHIVE_REWIND_KEYWORD_MAX,
    ARCHIVE_REWIND_SUBCOMMAND_MAX,
    'Return tape to beginning of reel\ ', archive_defs[ARCHIVE_REWIND]);
!
(* primary command defintions *)


(* NVDM ARCHIVE Command *)

  add_command('ARCHIVE\', NO_LICENSE, FALSE,
    PRIMARY_ARCHIVE_KEYWORD_OFFSET, PRIMARY_ARCHIVE_KEYWORD_MAX,
    PRIMARY_ARCHIVE_SUBCOMMAND_MAX,
    'Enter the Archive sub-system\ ', primary_defs[PRIMARY_ARCHIVE]);


(* NVDM CHECK Command *)

  add_command('CHECK\', NO_LICENSE, FALSE,
    PRIMARY_CHECK_KEYWORD_OFFSET, PRIMARY_CHECK_KEYWORD_MAX,
    PRIMARY_CHECK_SUBCOMMAND_MAX,
    'Compare disk configuration against memory configuration\',
    primary_defs[PRIMARY_CHECK]);

  add_non_subcommand_keyword(CUD_FILE_MESSAGE, PRIMARY_CHECK_CUD_KEYWORD);
$if reuse_uuns

  add_non_subcommand_keyword(PARAMETERS_KEYWORD_STRING,
    PRIMARY_CHECK_PARAMETERS_KEYWORD);
$endif reuse_uuns
$ifnot convert_to_43


(* NVDM COMPARE Command *)

  add_command('COMPARE\',
$if check_time_status     PROGRAMMER_LICENSE,
$ifnone check_time_status    NO_LICENSE,
    FALSE, PRIMARY_COMPARE_KEYWORD_OFFSET, PRIMARY_COMPARE_KEYWORD_MAX,
    PRIMARY_COMPARE_SUBCOMMAND_MAX,
    'Display differences between CUD and MUD blocks\ ',
    primary_defs[PRIMARY_COMPARE]);

  add_non_subcommand_keyword(FROM_KEYWORD_STRING,PRIMARY_COMPARE_FROM_KEYWORD);
  add_value_required(PRIMARY_COMPARE_FROM_KEYWORD) (* Block number *);
$if BEFORE_SUP_V43

  add_non_subcommand_keyword('NODATES\', PRIMARY_COMPARE_NODATES_KEYWORD);

  add_non_subcommand_keyword('NOGANS\ ', PRIMARY_COMPARE_NOGANS_KEYWORD);
$endif BEFORE_SUP_V43

  add_non_subcommand_keyword('NOORDER\', PRIMARY_COMPARE_NOORDER_KEYWORD);

  add_non_subcommand_keyword('NOUUNS\ ', PRIMARY_COMPARE_NOUUNS_KEYWORD);

  add_non_subcommand_keyword(SUPERVISOR_KEYWORD_STRING,
    PRIMARY_COMPARE_SUPERVISOR_KEYWORD);
  add_value_required(PRIMARY_COMPARE_SUPERVISOR_KEYWORD) (* Sup number *);
$endif convert_to_43


(* NVDM CONSISTENCY Command *)

  add_command('CONSISTENCY\',
$if check_time_status     PROGRAMMER_LICENSE,
$ifnone check_time_status    NO_LICENSE,
    FALSE, PRIMARY_CONSISTENCY_KEYWORD_OFFSET, PRIMARY_CONSISTENCY_KEYWORD_MAX,
    PRIMARY_CONSISTENCY_SUBCOMMAND_MAX,
    'Compare contents of CUD against specified MUD\',
    primary_defs[PRIMARY_CONSISTENCY]);

  add_non_subcommand_keyword('NOCHANGE\ ',
    PRIMARY_CONSISTENCY_NOCHANGE_KEYWORD);

  add_non_subcommand_keyword(SUPERVISOR_KEYWORD_STRING,
    PRIMARY_CONSISTENCY_SUPERVISOR_KEYWORD);
  add_value_required(PRIMARY_CONSISTENCY_SUPERVISOR_KEYWORD) (* Sup number *);

  add_non_subcommand_keyword(FROM_KEYWORD_STRING,
    PRIMARY_CONSISTENCY_FROM_KEYWORD);
  add_value_required(PRIMARY_CONSISTENCY_FROM_KEYWORD) (* Block number *);
$ifnot convert_to_43


(* NVDM CONVERT Command *)

  add_command('CONVERT\',
$if check_time_status     PROGRAMMER_LICENSE,
$ifnone check_time_status    NO_LICENSE,
    FALSE, PRIMARY_CONVERT_KEYWORD_OFFSET, PRIMARY_CONVERT_KEYWORD_MAX,
    PRIMARY_CONVERT_SUBCOMMAND_MAX,
$ifnone convert_0_to_1
    'This compilation of NETVAL has no CONVERT command\',
$endif convert_0_to_1
$if convert_0_to_1
    'Change current NETVAL disk files from version 2.xx to 3.xx\ ',
$endif convert_0_to_1
     primary_defs[PRIMARY_CONVERT]);
$endif convert_to_43
$ifall (logical_volumes, check_time_status)


(* NVDM COPY Command *)

  add_command(COPY_COMMAND_STRING, NO_LICENSE, FALSE,
    PRIMARY_COPY_KEYWORD_OFFSET, PRIMARY_COPY_KEYWORD_MAX,
    PRIMARY_COPY_SUBCOMMAND_MAX, COPY_HELP_STRING, primary_defs[PRIMARY_COPY]);
$endif (logical_volumes, check_time_status)


(* NVDM DISPLAY Command *)

  add_command(DISPLAY_COMMAND_STRING, NO_LICENSE, FALSE,
    PRIMARY_DISPLAY_KEYWORD_OFFSET, PRIMARY_DISPLAY_KEYWORD_MAX,
    PRIMARY_DISPLAY_SUBCOMMAND_MAX,
    'Type NETVAL Disk Maintenance information\ ',
    primary_defs[PRIMARY_DISPLAY]);

  add_keyword('CONFIG\ ', NO_LICENSE,
    'Type current disk configuration parameters\ ',
    PRIMARY_DISPLAY_CONFIGURATION_KEYWORD);

  add_keyword(FILTER_KEYWORD_STRING, NO_LICENSE,
    'Type current filter selections\ ', PRIMARY_DISPLAY_FILTER_KEYWORD);

  add_keyword('PAGE\ ', PROGRAMMER_LICENSE,
    'Type the contents of a disk page in hexadecimal\',
    PRIMARY_DISPLAY_PAGE_KEYWORD);
  add_value_required(PRIMARY_DISPLAY_PAGE_KEYWORD) (* Page number *);
$if prevent_duplicate_passwords

  add_keyword(PASSPERIOD_STRING, PROGRAMMER_LICENSE,
    'Type the minimum password change period\',
    PRIMARY_DISPLAY_PASSPERIOD_KEYWORD);
$endif prevent_duplicate_passwords
$if password_expiration_by_user

  add_keyword(VALIDITY_STRING, PROGRAMMER_LICENSE,
    'Type the standard password validity period\ ',
    PRIMARY_DISPLAY_VALIDITY_KEYWORD);
$endif password_expiration_by_user
$if logical_volumes

  add_keyword('VOLUMES\', NO_LICENSE,
    'Type current logical volume information\',
    PRIMARY_DISPLAY_VOLUMES_KEYWORD);
$endif logical_volumes

  add_non_subcommand_keyword('UNIT\ ', PRIMARY_DISPLAY_UNIT_KEYWORD);
  add_value_required(PRIMARY_DISPLAY_UNIT_KEYWORD) (* Unit number *);

(* NVDM FILTER Command *)

  add_command(FILTER_KEYWORD_STRING, NO_LICENSE, TRUE,
    PRIMARY_FILTER_KEYWORD_OFFSET, PRIMARY_FILTER_KEYWORD_MAX,
    PRIMARY_FILTER_SUBCOMMAND_MAX,
    'Selects filter for Message Command display\ ',
    primary_defs[PRIMARY_FILTER]);

  add_non_subcommand_keyword(ALL_KEYWORD_STRING, PRIMARY_FILTER_ALL_KEYWORD);

  add_non_subcommand_keyword('ARCHIVE\', PRIMARY_FILTER_ARCHIVE_KEYWORD);

  add_non_subcommand_keyword(CONSISTENCY_KEYWORD_STRING,
    PRIMARY_FILTER_CONSISTENCY_KEYWORD);

  add_non_subcommand_keyword('CUDERROR\ ', PRIMARY_FILTER_CUDERROR_KEYWORD);
$if perform_daily_cud_scan

  add_non_subcommand_keyword(CUDMAINTENANCE_KEYWORD_STRING,
    PRIMARY_FILTER_CUDMAINTENANCE_KEYWORD);
$endif perform_daily_cud_scan

  add_non_subcommand_keyword('DEBUG\', PRIMARY_FILTER_DEBUG_KEYWORD);

  add_non_subcommand_keyword('FILE\ ', PRIMARY_FILTER_FILE_KEYWORD);
$if NETVAL_IS_A_SLAVE

  add_non_subcommand_keyword('MASTER\ ', PRIMARY_FILTER_MASTER_KEYWORD);
  add_required_license(PROGRAMMER_LICENSE, PRIMARY_FILTER_MASTER_KEYWORD);
$endif NETVAL_IS_A_SLAVE
$if CHANGES_TO_OPER_LOG

  add_non_subcommand_keyword('MODIFY\ ', PRIMARY_FILTER_MODIFY_KEYWORD);
  add_required_license(PROGRAMMER_LICENSE, PRIMARY_FILTER_MODIFY_KEYWORD);
$endif CHANGES_TO_OPER_LOG

  add_non_subcommand_keyword('MUDUPDATE\', PRIMARY_FILTER_MUDUPDATE_KEYWORD);

  add_non_subcommand_keyword('OPERATOR\ ', PRIMARY_FILTER_OPERATOR_KEYWORD);

  add_non_subcommand_keyword('PARAMETER\', PRIMARY_FILTER_PARAMETER_KEYWORD);

  add_non_subcommand_keyword('SYSMSG1\', PRIMARY_FILTER_SYSMSG1_KEYWORD);
$ifany (force_password_change, global_password_only_login)

  add_non_subcommand_keyword('PASSCHANGER\', PRIMARY_FILTER_PASSCHANGER_KEYWORD);
$endif (force_password_change, global_password_only_login)

  add_non_subcommand_keyword('UN2\', PRIMARY_FILTER_UN2_KEYWORD);
$if REUSE_UUNS

  add_non_subcommand_keyword('UUNMERGE\ ', PRIMARY_FILTER_UUNMERGE_KEYWORD);
$endif REUSE_UUNS

  add_non_subcommand_keyword('VALIDATOR\', PRIMARY_FILTER_VALIDATOR_KEYWORD);
$if LOGICAL_VOLUMES

  add_non_subcommand_keyword('VOLUMES\', PRIMARY_FILTER_VOLUMES_KEYWORD);
$endif LOGICAL_VOLUMES

  add_non_subcommand_keyword(SUPERVISOR_KEYWORD_STRING,
    PRIMARY_FILTER_SUPERVISOR_KEYWORD);

  add_non_subcommand_keyword('NUMBER\ ',
    PRIMARY_FILTER_VALIDATOR_NUMBER_KEYWORD);
  add_value_required(PRIMARY_FILTER_VALIDATOR_NUMBER_KEYWORD);

  add_non_subcommand_keyword(USER_KEYWORD_STRING,
    PRIMARY_FILTER_VALIDATOR_USER_KEYWORD);
  add_value_required(PRIMARY_FILTER_VALIDATOR_USER_KEYWORD);
$if CHANGES_TO_OPER_LOG

  add_non_subcommand_keyword(ACCESS_KEYWORD_STRING,
    PRIMARY_FILTER_MODIFY_ACCESS_KEYWORD);

  add_non_subcommand_keyword(CONTROL_KEYWORD_STRING,
    PRIMARY_FILTER_MODIFY_CONTROL_KEYWORD);

  add_non_subcommand_keyword(DISTRICT_KEYWORD_STRING,
    PRIMARY_FILTER_MODIFY_DISTRICT_KEYWORD);
$if password_expiration_date_in_cud

  add_non_subcommand_keyword(EXPIREDATE_KEYWORD_STRING,
    PRIMARY_FILTER_MODIFY_EXPIRE_DATE_KEYWORD);
$endif password_expiration_date_in_cud

  add_non_subcommand_keyword(GAN_KEYWORD_STRING,
    PRIMARY_FILTER_MODIFY_GAN_KEYWORD);

  add_non_subcommand_keyword(NAME_KEYWORD_STRING,
    PRIMARY_FILTER_MODIFY_NAME_KEYWORD);
$ifnone before_sup_v43

  add_non_subcommand_keyword('NUD\', PRIMARY_FILTER_MODIFY_NUD_KEYWORD);
$endif before_sup_v43

  add_non_subcommand_keyword(PASSWORD_KEYWORD_STRING,
    PRIMARY_FILTER_MODIFY_PASSWORD_KEYWORD);
$if restrict_users_by_time

  add_non_subcommand_keyword(TIME_KEYWORD_STRING,
    PRIMARY_FILTER_MODIFY_TIME_KEYWORD);
$endif restrict_users_by_time

  add_non_subcommand_keyword(UUN_KEYWORD_STRING,
    PRIMARY_FILTER_MODIFY_UUN_KEYWORD);
$if NETVAL_IS_A_SLAVE

  add_non_subcommand_keyword('GFD\', PRIMARY_FILTER_MODIFY_GFD_KEYWORD);
$if INCLUDE_IRC

  add_non_subcommand_keyword('IRC\', PRIMARY_FILTER_MODIFY_IRC_KEYWORD);
$endif INCLUDE_IRC
$endif NETVAL_IS_A_SLAVE
$if OVERFLOW_CUD_ENTRIES

  add_non_subcommand_keyword('OVERFLOW\ ',
    PRIMARY_FILTER_MODIFY_OVERFLOW_KEYWORD);
$endif OVERFLOW_CUD_ENTRIES

  add_non_subcommand_keyword(DELETE_KEYWORD_STRING,
    PRIMARY_FILTER_MODIFY_DELETE_KEYWORD);

  add_non_subcommand_keyword(NEW_KEYWORD_STRING,
    PRIMARY_FILTER_MODIFY_NEW_KEYWORD);
$endif CHANGES_TO_OPER_LOG

  add_non_subcommand_keyword('OFF\', PRIMARY_FILTER_SUPERVISOR_OFF_KEYWORD);


(* NVDM INITIALIZE Command *)

  add_command('INITIALIZE\ ',
$if check_time_status     PROGRAMMER_LICENSE,
$ifnone check_time_status    NO_LICENSE,
    FALSE, PRIMARY_INITIALIZE_KEYWORD_OFFSET, PRIMARY_INITIALIZE_KEYWORD_MAX,
    PRIMARY_INITIALIZE_SUBCOMMAND_MAX,
    'Create new NETVAL disk files\ ', primary_defs[PRIMARY_INITIALIZE]);

  add_keyword(ALL_KEYWORD_STRING, NO_LICENSE,
    'Create all new NETVAL disk files\ ', PRIMARY_INITIALIZE_ALL_KEYWORD);

  add_keyword('CONFIG\ ', NO_LICENSE,
    'Record memory configuration parameters on the disk\ ',
    PRIMARY_INITIALIZE_CONFIGURATION_KEYWORD);

  add_keyword(CUD_FILE_MESSAGE, NO_LICENSE,
    'Create an empty CUD file\ ', PRIMARY_INITIALIZE_CUD_KEYWORD);
$if INCLUDE_DNIC

  add_keyword(DNIC_FILE_MESSAGE, NO_LICENSE,
    'Create an empty DNIC file\', PRIMARY_INITIALIZE_DNIC_KEYWORD);
$endif INCLUDE_DNIC

  add_keyword('MUDUPDATE\', NO_LICENSE,
    'Create an empty MUD UPDATE file\', PRIMARY_INITIALIZE_MUDUPDATE_KEYWORD);

  add_keyword(NODE_KEYWORD_STRING, NO_LICENSE,
    'Create an empty NODE file\', PRIMARY_INITIALIZE_NODE_KEYWORD);

  add_keyword('OPERLOG\', NO_LICENSE,
    'Create an empty OPERATOR LOG file\', PRIMARY_INITIALIZE_OPERLOG_KEYWORD);

  add_keyword(PARAMETERS_KEYWORD_STRING, NO_LICENSE,
    'Create an empty PARAMETER file\ ', PRIMARY_INITIALIZE_PARAMETERS_KEYWORD);
$if ganpass_file_exists

  add_keyword('PASSTABLE\', NO_LICENSE,
    'Create an empty PASSTABLE file\ ', PRIMARY_INITIALIZE_PASSTABLE_KEYWORD);
$endif ganpass_file_exists

  add_keyword('SCHEDTABLE\ ', NO_LICENSE,
    'Create an empty SCHEDTABLE file\', PRIMARY_INITIALIZE_SCHEDTABLE_KEYWORD);
$if reuse_uuns

  add_non_subcommand_keyword(ADDBACK_KEYWORD_STRING,
    PRIMARY_INITIALIZE_PARAMETERS_ADDBACK_KEYWORD);
$endif reuse_uuns


(* NVDM MESSAGE Command *)

  add_command('MESSAGE\', NO_LICENSE, TRUE,
    PRIMARY_MESSAGE_KEYWORD_OFFSET, PRIMARY_MESSAGE_KEYWORD_MAX,
    PRIMARY_MESSAGE_SUBCOMMAND_MAX,
    'Display information from the Operator log\',
    primary_defs[PRIMARY_MESSAGE]);

  add_non_subcommand_keyword(FROM_KEYWORD_STRING,
    PRIMARY_MESSAGE_FROM_KEYWORD);


(* NVDM QUIT Command *)

  add_command('QUIT\ ', NO_LICENSE, FALSE,
    PRIMARY_QUIT_KEYWORD_OFFSET, PRIMARY_QUIT_KEYWORD_MAX,
    PRIMARY_QUIT_SUBCOMMAND_MAX,
    'Exit from NETVAL Disk Maintenance program\', primary_defs[PRIMARY_QUIT]);
$ifnone convert_to_43
$if reuse_uuns


(* NVDM RECOLLECT Command *)

  add_command('RECOLLECT\', NO_LICENSE, FALSE,
    PRIMARY_RECOLLECT_KEYWORD_OFFSET, PRIMARY_RECOLLECT_KEYWORD_MAX,
    PRIMARY_RECOLLECT_SUBCOMMAND_MAX,
    'Recover lost UUNs\', primary_defs[PRIMARY_RECOLLECT]);

  add_non_subcommand_keyword(FROM_KEYWORD_STRING,
    PRIMARY_RECOLLECT_FROM_KEYWORD);
  add_value_required(PRIMARY_RECOLLECT_FROM_KEYWORD) (* Block number *);
$endif reuse_uuns


(* NVDM REGENERATE Command *)

  add_command('REGENERATE\ ',
$if check_time_status     PROGRAMMER_LICENSE,
$ifnone check_time_status    NO_LICENSE,
    FALSE, PRIMARY_REGENERATE_KEYWORD_OFFSET, PRIMARY_REGENERATE_KEYWORD_MAX,
    PRIMARY_REGENERATE_SUBCOMMAND_MAX,
    'Recreate NETVAL file\ ', primary_defs[PRIMARY_REGENERATE]);

  add_keyword(CUD_FILE_MESSAGE, NO_LICENSE,
$if before_sup_v43 'Recreate the NETVAL CUD by copying the specified MUD\ ',
$ifnone before_sup_v43
     'Recreate part of the NETVAL CUD by copying the specified MUD\ ',
$endif before_sup_v43
    PRIMARY_REGENERATE_CUD_KEYWORD);

  add_keyword(PARAMETERS_KEYWORD_STRING, NO_LICENSE,
    'Recreate GAN-UUN file from the CUD entries\ ',
    PRIMARY_REGENERATE_PARAMETERS_KEYWORD);

  add_non_subcommand_keyword(FROM_KEYWORD_STRING,
    PRIMARY_REGENERATE_FROM_KEYWORD);
  add_value_required(PRIMARY_REGENERATE_FROM_KEYWORD) (* Block number *);

  add_non_subcommand_keyword(SUPERVISOR_KEYWORD_STRING,
    PRIMARY_REGENERATE_CUD_SUPERVISOR_KEYWORD);
  add_value_required(PRIMARY_REGENERATE_CUD_SUPERVISOR_KEYWORD) (* Sup no. *);
$if reuse_uuns

  add_non_subcommand_keyword('APPEND\ ',
    PRIMARY_REGENERATE_PARAMETERS_APPEND_KEYWORD);

  add_non_subcommand_keyword(ADDBACK_KEYWORD_STRING,
    PRIMARY_REGENERATE_PARAMETERS_ADDBACK_KEYWORD);
(* old size of addback file: *)
  add_value_required(PRIMARY_REGENERATE_PARAMETERS_ADDBACK_KEYWORD);
$endif reuse_uuns
$endif convert_to_43
$ifany (prevent_duplicate_passwords, password_expiration_by_user)


(* NVDM SET Command *)

  add_command('SET\', PROGRAMMER_LICENSE, TRUE, PRIMARY_SET_KEYWORD_OFFSET,
    PRIMARY_SET_KEYWORD_MAX, PRIMARY_SET_SUBCOMMAND_MAX,
    'Initialize NETVAL values on disk\ ', primary_defs[PRIMARY_SET]);
$endif (prevent_duplicate_passwords, password_expiration_by_user)
$if prevent_duplicate_passwords

  add_keyword(PASSPERIOD_STRING, NO_LICENSE,
    'Define the minimum password change period\',
    PRIMARY_SET_PASSPERIOD_KEYWORD);
$endif prevent_duplicate_passwords
$if password_expiration_by_user

  add_keyword(VALIDITY_STRING, NO_LICENSE,
    'Define the standard password validity period\ ',
    PRIMARY_SET_VALIDITY_KEYWORD);

  add_non_subcommand_keyword(GAN_KEYWORD_STRING,
    PRIMARY_SET_VALIDITY_GAN_KEYWORD);
$endif password_expiration_by_user
$endif disk_maintenance_code
!
(* the following keywords only apply to parsed lines, not commands *)

  last_keyword_offset := LINE_KEYWORD_OFFSET;

  add_non_subcommand_keyword('YES\', LINE_YES_KEYWORD);

  add_non_subcommand_keyword('NO\ ', LINE_NO_KEYWORD);

  add_non_subcommand_keyword(NODE_KEYWORD_STRING, LINE_NODE_KEYWORD);

  add_non_subcommand_keyword(HOST_KEYWORD_STRING, LINE_HOST_KEYWORD);

  add_non_subcommand_keyword('COMPLETE\ ', LINE_COMPLETE_KEYWORD);

  add_non_subcommand_keyword(GROUP_KEYWORD_STRING, LINE_GROUP_KEYWORD);

  add_non_subcommand_keyword(HOSTLIST_KEYWORD_STRING, LINE_HOSTLIST_KEYWORD);

  add_non_subcommand_keyword(NODELIST_KEYWORD_STRING, LINE_NODELIST_KEYWORD);

  add_non_subcommand_keyword('ADD\', LINE_ADD_KEYWORD);

  add_non_subcommand_keyword(DELETE_KEYWORD_STRING, LINE_DELETE_KEYWORD);

  add_non_subcommand_keyword('REPLACE\', LINE_REPLACE_KEYWORD);

  add_non_subcommand_keyword('END\', LINE_END_KEYWORD);



(* set up class prompt definitions *)
  add_to_prompts(ARCHIVE_CLASS, 'arch> \ ');
  add_to_prompts(PRIMARY_CLASS, GLOBAL_PROMPT_STRING);
  add_to_prompts(GLOBAL_CLASS, GLOBAL_PROMPT_STRING)
end (* command_table *);
!
(************************************************************************)
(*									*)
(*	ARGSCN.NTV							*)
(*									*)
(*			   argument_scanner 				*)
(*									*)
(*	Set of routines to convert arguments.				*)
(*									*)
(*	The following identifiers must be identified externally:	*)
(*	  ascii_space, ascii_minus					*)
(*									*)
(************************************************************************)
(*									*)
(*			Revision Record					*)
(*									*)
(*	13Oct88 - jrn							*)
(*		- add allow_future_years to routines so that a future	*)
(*		  expiration date may be entered			*)
(*	06Nov87 - neh							*)
(*	      - add freeword_dnicname					*)
(*	01Oct86 - neh							*)
(*	      - Remove conditional ifnone disk_maintenance for 		*)
(*		argument_username.					*)
(*	      - Add keyword_username.					*)
(*	      - Add freeword_list procedure.				*)
(*	02Jun86 - jrn							*)
(*	      - use new mutil.legal_username_character function		*)
(*	28Feb86 - jrn							*)
(*	      - clean up and modify freeword_date to use default date	*)
(*		of today.						*)
(*	31AUG84 Version 2.03 - jrn					*)
(*	      - changed format of listname				*)
(*	16Jun84 Version 2.02	pgl					*)
(*	      - added freeword_range, get_freeword_date, 		*)
(*		and freeword_date_only					*)
(*	29SEP83 original from (patrol)argscn.bas - jrn			*)
(*									*)
(************************************************************************)


type ARGUMENT_SCANNER = class(
	mutil	: misc_utility);



var
  calendar: date_time_converter;



(*	The following set is constructed while a command is scanned.    *)
(*	It will contain all the keywords that a command uses.		*)
(*	The putting of keywords in this set is done in 'check_keyword'.	*)
(*	This routine also checks for keyword presents, so it is used	*)
(*	to both check if a keyword is present and to record its use.	*)
(*	The set is used in 'extra_keyword_check' to determine if any	*)
(*	extra keywords were entered. It is cleared in the entry		*)
(*	'reset_argument_check'.						*)
(*	cleared at the start of each command compile.			*)

  keyword_used : command_keyword_set;

(*	The following counter counts the number of freewords used in a	*)
(*	command. After the command is completely scanned, this number	*)
(*	is compared with FREEWORD_COUNT in SCANNED. If it is less, than	*)
(*	there are							*)
(*	free words in the command which have not been used. If so,	*)
(*	STATUS is set to ARG_ERROR. This is done in check_allowed.	*)

  freeword_used : command_freeword_total;



(**************************  argument_scanner  **************************)
(*									*)
(*			 check_freeword_available			*)
(*									*)
(*	Check that freeword is available and remember last used.	*)
(*									*)
(************************************************************************)

procedure check_freeword_available(
      freeword	: command_freeword_index;
  var scanned	: scanned_command);

begin
  if (freeword + 1) > scanned.freeword_count
  then scanned.status := ARG_FREEWORD_MISSING
  else
    if (freeword + 1) > freeword_used
    then freeword_used := freeword + 1
end (* check_freeword_available *);



(**************************  argument_scanner  **************************)
(*									*)
(*			    check_argument_end				*)
(*									*)
(*	Check that all the characters in a token have been scanned.	*)
(*									*)
(************************************************************************)

procedure check_argument_end(
      token	: command_token;
  var scanned	: scanned_command);

begin
  if scanned.status = CMD_OK
  then
    if token.start < token.finish
    then scanned.status := ARG_ERROR
end (* check_argument_end *);



(**************************  argument_scanner  **************************)
(*									*)
(*			    get_unsigned_number				*)
(*									*)
(*	Convert an argument in value to a integer.			*)
(*									*)
(************************************************************************)

procedure get_unsigned_number(
      base	: integer;
  var token	: command_token;
  var scanned	: scanned_command;
  var value	: integer);

var
  start    : command_token_index;
  scanning : boolean;
  next_char : char;
  digit    : integer (* the internal value of digit scanned *);

begin
  start := token.start;
  scanning := TRUE;
  value := 0;
  while (token.start < token.finish) and scanning do
    begin
      next_char := scanned.input_line.text[token.start];
      if mutil.decimal_digit(next_char)
      then digit := ord(next_char) - ord(ASCII_ZERO)
      else
        if (ASCII_A <= next_char) and (next_char <= ASCII_F)
	then digit := ord(next_char) - ord(ASCII_A) + 10
	else scanning := FALSE;
      if scanning
      then scanning := digit < base;
      if scanning
      then
	begin
	  value := value*base + digit;
	  token.start := token.start + 1
	end
    end (* while *);

  if start = token.start
  then scanned.status := ARG_ERROR
end (* get_unsigned_number *);



(**************************  argument_scanner  **************************)
(*									*)
(*			      argument_number				*)
(*									*)
(*	Convert a token to a signed integer.				*)
(*									*)
(************************************************************************)

procedure argument_number(
      base	: integer;
  var token	: command_token;
  var scanned	: scanned_command;
  var value	: integer);

var
  negative: boolean;

begin
(* Scan for sign on value and remove. *)
  negative := FALSE (* assume positive *);
  if scanned.input_line.text[token.start] = ASCII_MINUS
  then
    begin
      negative := TRUE;
      token.start := token.start + 1
    end
  else
    if scanned.input_line.text[token.start] = ASCII_PLUS
    then token.start := token.start + 1;

  get_unsigned_number(base, token, scanned, value);
  check_argument_end(token, scanned);
  if scanned.status = CMD_OK
  then
    if negative
    then value := -value
end (* argument_number *);



(**************************  argument_scanner  **************************)
(*									*)
(*			      keyword_number				*)
(*									*)
(*	Convert a keyword to an integer.				*)
(*									*)
(************************************************************************)

procedure entry KEYWORD_NUMBER(
      keyword	: command_keyword_index;
      base	: integer;
  var scanned	: scanned_command;
  var value	: integer);

var
  token: command_token;

begin
  token := scanned.keyword_value[keyword];
  argument_number(base, token, scanned, value)
end (* keyword_number *);



(**************************  argument_scanner  **************************)
(*									*)
(*			     freeword_number				*)
(*									*)
(*	Convert a freeword to an integer.				*)
(*									*)
(************************************************************************)

procedure entry FREEWORD_NUMBER(
      freeword	: command_freeword_index;
      base	: integer;
  var scanned	: scanned_command;
  var value	: integer);

var
  token : command_token;

begin
  check_freeword_available(freeword, scanned);
  if scanned.status = CMD_OK
  then
    begin
      token := scanned.freeword_value[freeword];
      argument_number(base, token, scanned, value)
    end
end (* freeword_number *);
!
"
		date and time routines
"



(*************************  argument_scanner  ***************************)
(*									*)
(*			      argument_value				*)
(*									*)
(*	Convert argument in the form NN<delimiter> to an integer value.	*)
(*									*)
(************************************************************************)

procedure argument_value(
      min_value			: integer (* minimum acceptable value *);
      max_value			: integer (* maximum acceptable value *);
      radix			: integer (* radix of value *);
      delimiter_required	: boolean (* TRUE if there must be a del. *);
      delimiter			: char (* acceptble delimiter *);
  var token			: command_token;
  var delimiter_found		: boolean (* TRUE if a delimiter was found *);
  var scanned			: scanned_command;
  var value			: integer);

begin
  get_unsigned_number(radix, token, scanned, value);
  if scanned.status = CMD_OK
  then
    if (value < min_value) or (value > max_value)
    then scanned.status := ARG_NUMBER_OUT_OF_BOUNDS
    else
      if scanned.input_line.text[token.start] = delimiter
      then
        begin (* delimiter was entered *)
	  delimiter_found := TRUE;
	  token.start := token.start + 1 (* skip delimiter *)
	end (* delimiter was entered *)
      else
        begin (* no delimiter found *)
	  delimiter_found := FALSE;
	  if delimiter_required
	  then scanned.status := ARG_ERROR 
	end (* no delimiter found *)
end (* argument_value *);



(****************************  argument_scan  ***************************)
(*									*)
(*		 	       freeword_list				*)
(*									*)
(*	 Return value in a list seperated by commas.			*)
(*									*)
(************************************************************************)

procedure entry FREEWORD_LIST(
      freeword	: command_freeword_index;
      min_value : integer;
      max_value : integer;
      base	: integer;
  var scanned	: scanned_command;
  var value	: univ integer);

var
  token : command_token;
  delimiter_found : boolean;

begin
  check_freeword_available(freeword, scanned);
  if scanned.status = CMD_OK
  then
    begin
      token := scanned.freeword_value[freeword];
      argument_value(min_value, max_value, base, FALSE, ASCII_COMMA, token,
        delimiter_found, scanned, value)
    end (* if CMD_OK *)
end (* freeword_list *);



(*************************  argument_scanner  ***************************)
(*									*)
(*			      argument_time				*)
(*									*)
(*	Convert argument in the form HH:MM<:SS> to a time.		*)
(*									*)
(************************************************************************)

procedure argument_time(
      freeword	: command_freeword_index;
  var scanned	: scanned_command;
  var time	: integer);

var
  token : command_token;
  hour : integer;
  minute : integer;
  second : integer;
  delimiter_found : boolean;

begin
  check_freeword_available(freeword, scanned);

  if scanned.status = CMD_OK
  then
    begin (* get hour *)
      token := scanned.freeword_value[freeword];
      argument_value(0, 23, 10, TRUE, ASCII_COLON, token, delimiter_found,
        scanned, hour)
    end (* get hour *);

  if scanned.status = CMD_OK
  then(* get minutes *)
    argument_value(0, 59, 10, FALSE, ASCII_COLON, token, delimiter_found,
      scanned, minute);

  if scanned.status = CMD_OK
  then
    if token.start = token.finish
    then (* no more characters to parse *)
      if delimiter_found
      then scanned.status := ARG_ERROR (* user entered trailing delimiter *)
      else second := 0 (* use default *)
    else (* more characters left *)
      if delimiter_found
      then (* get seconds *)
        argument_value(0, 59, 10, FALSE, ASCII_COLON, token, delimiter_found,
	  scanned, second)
      else scanned.status := ARG_ERROR (* no delimiter found *);

  check_argument_end(token, scanned);
  time := calendar.seconds_in_time(hour, minute, second)
end (* argument_time *);



(*************************  argument_scanner  ***************************)
(*									*)
(*			     argument_date				*)
(*									*)
(*	Convert freeword in the form MM/DD</YY> to an ISIS time.	*)
(*									*)
(************************************************************************)

procedure argument_date(
      allow_future_years: boolean;
  var token		: command_token;
  var scanned		: scanned_command;
  var time		: integer);

var
  month : integer;
  day : integer;
  year : integer;
  current_year : integer;
  leap : boolean;
  delimiter_found : boolean;

begin
(* set year for default use or checking input value*)
  time := REALTIME (* default is current year *);
  calendar.compute_year(time, current_year);

(* get month *)
  argument_value(1, 12, 10, TRUE, ASCII_SLASH, token, delimiter_found,
    scanned, month);

(* get day *)
  if scanned.status = CMD_OK
  then argument_value(1, 31, 10, FALSE, ASCII_SLASH, token, delimiter_found,
    scanned, day);

(* get year *)
  if scanned.status = CMD_OK
  then
    if token.start = token.finish
    then (* no more characters to parse *)
      if delimiter_found
      then scanned.status := ARG_ERROR (* user entered trailing delimiter *)
      else year := current_year (* use default *)
    else (* more characters left *)
      if delimiter_found
      then
        begin (* get year *)
	  get_unsigned_number(10, token, scanned, year);
	  if scanned.status = CMD_OK
	  then
	    begin
	      if year < 100
	      then year := year + 1900;
	      if year < BASE_YEAR
	      then scanned.status := ARG_ERROR
	      else
	        if not allow_future_years and (year > current_year)
		then scanned.status := ARG_ERROR
	    end
        end (* get year *)
      else scanned.status := ARG_ERROR (* no delimiter found *);

  if scanned.status = CMD_OK
  then
    begin (* determine if year is a leap year and check month value *)
      leap := calendar.leap_year(year);
      if calendar.days_in_month(month, leap) < day
      then scanned.status := ARG_ERROR
    end (* determine if year is a leap year and check month value *);

  check_argument_end(token, scanned);
  if scanned.status = CMD_OK
  then time := calendar.seconds_in_date(month, day, year, leap)
end (* argument_date *);



(*************************  argument_scanner  ***************************)
(*									*)
(*			  freeword_date_and_time			*)
(*									*)
(*	Convert freeword in the form MM/DD/YY HH:MM:SS to an ISIS time.	*)
(*	If entire date is omitted, day will be set to today; if YY is	*)
(*	omitted, current year will be set; if HH:MM is omitted, 00:00	*)
(*	is used; if SS is omitted, 0 is used.				*)
(*	This procedure is only used by the MESSAGES command.		*)
(*									*)
(************************************************************************)

procedure entry FREEWORD_DATE_AND_TIME(
      freeword	: command_freeword_index;
      max_time	: integer;
  var scanned	: scanned_command;
  var time	: integer);

var
  date : integer;
  date_time : print_time;
  time_freeword : command_freeword_index;
  token : command_token;
  first_token_is_date : boolean;
  first_token_is_time : boolean;
  next_char : char;

begin
  check_freeword_available(freeword, scanned);
  if scanned.status = CMD_OK
  then
    begin
      token := scanned.freeword_value[freeword] (* get first token to scan *);
      first_token_is_date := FALSE; first_token_is_time := FALSE;
      repeat
        next_char := scanned.input_line.text[token.start];
	if next_char = ASCII_SLASH
	then first_token_is_date := TRUE
	else
	  if next_char = ASCII_COLON
	  then first_token_is_time := TRUE
	  else token.start := token.start + 1
      until first_token_is_date or first_token_is_time or
        (token.start = token.finish);
      token := scanned.freeword_value[freeword] (* restore first token *);
      if first_token_is_date
      then
        begin (* pick up date from first token *)
	  argument_date(FALSE, token, scanned, date);
	  time_freeword := freeword + 1 (* next freeword would be time *)
	end (* pick up date from first token *)
      else
        begin (* first token is not date, compute time of start of today *)
	  calendar.date_from_isis_time(REALTIME, date_time);
	  date := calendar.seconds_in_date(date_time.month, date_time.day,
	    date_time.year, calendar.leap_year(date_time.year));
	  if first_token_is_time
	  then time_freeword := freeword (* first freeword was time *)
	  else scanned.status := ARG_FREEWORD_MISSING
	end (* first token is not date, compute time of start of today *)
    end (* scanned.status = CMD_OK *);

  if scanned.status = CMD_OK
  then
    begin (* get time of day *)
      check_freeword_available(time_freeword, scanned) (* time entered? *);
      if scanned.status = CMD_OK
      then argument_time(time_freeword, scanned, time)
      else
        if scanned.status = ARG_FREEWORD_MISSING
	then
	  begin (* no time entered *)
	    time := 0 (* set default *);
	    scanned.status := CMD_OK
	  end (* no time entered *)
    end (* get time of day *);

(* add time of year and time of day *)
  if scanned.status = CMD_OK
  then
    begin
      time := date + time;
      if time > max_time
      then scanned.status := ARG_ERROR
    end;
end (* freeword_date_and_time *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code



(***************************  argument_scanner  *************************)
(*									*)
(*			       freeword_date				*)
(*									*)
(*      Picks up MM/DD/YY only.						*)
(*									*)
(************************************************************************)

procedure entry FREEWORD_DATE(
      allow_future_years: boolean;
      freeword		: command_freeword_index;
  var scanned		: scanned_command;
  var time		: integer);

var
  token : command_token;

begin
  check_freeword_available(freeword, scanned);
  if scanned.status = CMD_OK
  then
    begin
      token :=  scanned.freeword_value[freeword];
      argument_date(allow_future_years, token, scanned, time)
    end
end (* freeword_date *);



(*************************  argument_scanner  ***************************)
(*									*)
(*			 freeword_time_in_minutes		   	*)
(*									*)
(*	Convert freeword to minutes since midnight.			*)
(*									*)
(************************************************************************)

procedure entry FREEWORD_TIME_IN_MINUTES(
      freeword	: command_freeword_index;
  var scanned	: scanned_command;
  var time	: integer);

begin
  argument_time(freeword, scanned, time);
  time := (time div 60) mod MINUTES_PER_DAY
end (* freeword_time_in_minutes *);
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(***************************  argument_scanner  *************************)
(*									*)
(*				freeword_range				*)
(*									*)
(* Convert token to a pair of integers; the pair is separated by a dash.*)
(*									*)
(************************************************************************)

procedure entry FREEWORD_RANGE(
      freeword		: command_freeword_index;
      min_value		: integer;
      max_value		: integer;
      radix		: integer;
  var scanned		: scanned_command;
  var number_range	: range);

var
  token	: command_token;
  delimiter_found : boolean;

begin
  check_freeword_available(freeword, scanned);

  if scanned.status = CMD_OK
  then
    begin (* input first value *)
      token := scanned.freeword_value[freeword];
      argument_value(min_value, max_value, radix, FALSE, ASCII_MINUS, token,
        delimiter_found, scanned, number_range.first)
    end (* input first value *);

  if scanned.status = CMD_OK
  then (* input optional second value *)
    if token.start = token.finish (* single integer found *)
    then (* no more characters to parse *)
      if delimiter_found
      then scanned.status := ARG_ERROR (* user entered trailing delimiter *)
      else number_range.last := number_range.first
    else argument_value(number_range.first + 1, max_value, radix, FALSE,
      ASCII_MINUS, token, delimiter_found, scanned, number_range.last);

  check_argument_end(token, scanned)
end (* freeword_range *);



(*************************  argument_scanner  ***************************)
(*                                                                      *)
(*                          argument_username                           *)
(*                                                                      *)
(************************************************************************)

procedure argument_username(
  var token     : command_token;
  var scanned   : scanned_command;
  var username  : username_string);

var
  finished : boolean;
  x : username_text_index;
$if INCLUDE_DNIC  dnic : boolean;

begin
  if scanned.input_line.text[token.start] = ASCII_SINGLE_QUOTE
  then
    begin
      token.start := token.start + 1;
      token.finish := token.finish - 1;
      if token.start = token.finish
      then scanned.status := ARG_ERROR
    end;

  for x := 0 to USERNAME_TEXT_LIMIT do
    username.text[x] := ZERO;
  x := 0;
  if scanned.status = CMD_OK
  then finished := FALSE
  else finished  := TRUE;

$if INCLUDE_DNIC  dnic := FALSE;
  with scanned.input_line do
    while not finished and (scanned.status = CMD_OK) do
$ifnot BEFORE_SUP_V43
        begin
      if x = 0
      then
$if INCLUDE_DNIC
	dnic := text[token.start] = ASCII_MINUS
        else
          if dnic and ((x mod 5) <> 0)
	  then
	    if not mutil.decimal_digit(text[token.start])
$endif INCLUDE_DNIC
$ifnot INCLUDE_DNIC      if text[token.start] = ASCII_MINUS
        then scanned.status := ILLEGAL_CHAR;
        if scanned.status = CMD_OK
	then
$endif BEFORE_SUP_V43
      if mutil.legal_username_character(text[token.start])
      then
        begin
          username.text[x] := text[token.start];
          if token.start = token.finish - 1
          then finished := TRUE
          else
            begin
              token.start := token.start + 1;
              if x = USERNAME_TEXT_LIMIT
              then scanned.status := ARG_TOO_MANY_CHARS
              else x := x + 1
            end
          end
      else scanned.status := ILLEGAL_CHAR;
$ifnot BEFORE_SUP_V43      end;
  if scanned.status = CMD_OK
  then username.size := x + 1
end (* argument_username *);



(*************************  argument_scanner  ***************************)
(*                                                                      *)
(*                          freeword_username                           *)
(*                                                                      *)
(************************************************************************)

procedure entry FREEWORD_USERNAME(
      freeword  : command_freeword_index;
  var scanned   : scanned_command;
  var username  : username_string);

var
  token : command_token;

begin
  check_freeword_available(freeword, scanned);
  if scanned.status = CMD_OK
  then
    begin
      token := scanned.freeword_value[freeword];
      argument_username(token, scanned, username)
    end
end (* freeword_username *);

(*************************  argument_scanner  ***************************)
(*                                                                      *)
(*                          keyword_username                            *)
(*                                                                      *)
(************************************************************************)

procedure entry KEYWORD_USERNAME(
      keyword   : command_keyword_index;
  var scanned   : scanned_command;
  var username  : username_string);

var
  token : command_token;

begin
  token := scanned.keyword_value[keyword];
  argument_username(token, scanned, username)
end (* keyword_username *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code



(*************************  argument_scanner  ***************************)
(*									*)
(*			    freeword_listname				*)
(*									*)
(************************************************************************)

procedure entry FREEWORD_LISTNAME(
      freeword	: command_freeword_index;
  var scanned	: scanned_command;
  var name	: named_list_name);

var
  token : command_token;
  index : named_list_name_index;
  done : boolean;

begin
  check_freeword_available(freeword, scanned);
  if scanned.status = CMD_OK
  then
    begin
      token := scanned.freeword_value[freeword];
      done := FALSE;
      for index := 0 to NAMED_LIST_NAME_SIZE_LIMIT do
        name.text[index] := ASCII_SPACE;
      index := 0;
      with scanned.input_line do
        while not done and (scanned.status = CMD_OK) do
	  if mutil.alpha_numeric(text[token.start]) or
	    (text[token.start] = '_') or
	    (text[token.start] = ASCII_AMPERSAND)
	  then
	    begin
	      name.text[index] := text[token.start];
	      if token.start = token.finish - 1
	      then
	        begin
		  done := TRUE;
		  name.size := index + 1
		end
	      else
	        begin
	          token.start := token.start + 1;
		  if index = NAMED_LIST_NAME_SIZE_LIMIT
		  then scanned.status := ARG_TOO_MANY_CHARS
		  else index := index + 1
	        end
	    end
          else scanned.status := ILLEGAL_CHAR
    end
end (* freeword_listname *);
$if INCLUDE_DNIC



(*************************  argument_scanner  ***************************)
(*									*)
(*			    freeword_dnicname				*)
(*									*)
(************************************************************************)

procedure entry FREEWORD_DNICNAME(
      freeword	: command_freeword_index;
  var scanned	: scanned_command;
  var name	: dnicname_string);

var
  token : command_token;
  index : dnicname_index;
  done : boolean;

begin
  check_freeword_available(freeword, scanned);
  if scanned.status = CMD_OK
  then
    begin
      token := scanned.freeword_value[freeword];
      done := FALSE;
      index := 0;
      with scanned.input_line do
        while not done and (scanned.status = CMD_OK) do
	  if mutil.decimal_digit(text[token.start])
	  then
	    begin
	      name[index] := text[token.start];
	      if token.start = token.finish - 1
	      then
		begin
		  if index = DNICNAME_LIMIT
		  then done := TRUE
		  else scanned.status := ARG_NOT_ENOUGH_CHARS
		end
	      else
	        begin
	          token.start := token.start + 1;
		  if index = DNICNAME_LIMIT
		  then scanned.status := ARG_TOO_MANY_CHARS
		  else index := index + 1
	        end
	    end
          else scanned.status := ILLEGAL_CHAR
    end
end (* freeword_dnicname *);
$endif INCLUDE_DNIC
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(**************************  argument_scanner  **************************)
(*                                                                      *)
(*                             find_keyword                             *)
(*                                                                      *)
(*      Given the first and last values of the range of possible key    *)
(*      words, return the one and only one that the user entered.       *)
(*      Set scanned_command status if any error.                        *)
(*                                                                      *)
(************************************************************************)

procedure entry FIND_KEYWORD(
      first_keyword     : command_keyword_index;
      last_keyword      : command_keyword_index;
  var scanned           : scanned_command;
  var keyword           : command_keyword_index);

var
  k     : integer;
  found : boolean;

begin
  found := FALSE;
  for k := first_keyword to last_keyword do
    if k in scanned.keyword_present
    then
      if found
      then scanned.status := ARG_ERROR
      else
        begin
          found := TRUE;
          keyword := k
        end (* for *);

  if found
  then keyword_used := keyword_used or [keyword]
  else scanned.status := ARG_MISSING
end (* find_keyword *);



(**************************  argument_scanner  **************************)
(*									*)
(*			      check_keyword				*)
(*									*)
(*	Check and return whether a given keyword was entered. If so,	*)
(*	put keyword in 'keyword_used' for check of extra keywords.	*)
(*									*)
(************************************************************************)

function entry CHECK_KEYWORD(
      keyword : command_keyword_index;
      scanned : scanned_command) : boolean;

begin
  if keyword in scanned.keyword_present
  then
    begin
      keyword_used := keyword_used or [keyword];
      check_keyword := TRUE
    end
  else check_keyword := FALSE
end (* check_keyword *);



(**************************  argument_scanner  **************************)
(*									*)
(*			  reset_argument_check				*)
(*									*)
(*	Set up for extra keyword and freeword check.			*)
(*									*)
(************************************************************************)

procedure entry RESET_ARGUMENT_CHECK;

begin
  keyword_used := [];
  freeword_used := 0
end (* reset_argument_check *);



(**************************  argument_scanner  **************************)
(*									*)
(*			  extra_argument_check				*)
(*									*)
(*	Check if any extra keywords or freewords entered.		*)
(*									*)
(************************************************************************)

procedure entry EXTRA_ARGUMENT_CHECK(
  var scanned	: scanned_command);

begin
  if scanned.status = CMD_OK
  then
    if scanned.keyword_present <> keyword_used
    then scanned.status := TOO_MANY_ARGS
    else
      if scanned.freeword_count <> freeword_used
      then scanned.status := TOO_MANY_ARGS
end (* extra_argument_check *);



(************************************************************************)
(************************************************************************)

begin (* initial statement *)
  init calendar
end (* argument_scanner *);
!
(************************************************************************)
(*									*)
(*	KEYUTL.NTV							*)
(*									*)
(*			keyword utility class				*)
(*									*)
(*	This class resides within any process wishing to process	*)
(*	keywords.							*)
(*									*)
(*	The following identifiers must be defined externally:		*)
(*	  command_scanned, command_definition,				*)
(*	  keyword_definition, ascii_space, max_key_value_size		*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	14Apr84 Version 2.02	jrn					*)
(*	      - added licenses						*)
(*	29SEP83  original from (patrol)cmdscn.bas - jnm			*)
(*									*)
(************************************************************************)



type KEYWORD_UTILITY = class(
	profile		: validator_profile;
	format		: internal_to_string;
	user_terminal	: circuit_handler;
	commands	: command_table;
	argument_scan	: argument_scanner);



(**************************  keyword_utility  ***************************)
(*									*)
(*			    add_last_keyword				*)
(*									*)
(************************************************************************)

procedure add_last_keyword(
      keyword	: keyword_name);

begin
  if format.buffer.size> 0
  then format.character(ASCII_SPACE);
  format.string('or \');
  format.keyword_string(keyword)
end (* add_last_keyword *);



(*************************  keyword_utility  ****************************)
(*									*)
(*		          output_next_keyword				*)
(*									*)
(************************************************************************)

procedure add_next_keyword(
      offset    	: keyword_index;
      keyword		: command_keyword_index;
      check_access	: boolean (* if TRUE, check keyword license *);
      subcommand_count	: command_keyword_total (* subcommands found *);
  var found_one		: boolean (* TRUE if keyword added *);
  var last_keyword	: keyword_name);

var
  keyword_entry : keyword_definition;

begin
  commands.get_keyword(offset, keyword, keyword_entry);
  if check_access and
    not profile.access_to_command(keyword_entry.required_license)
  then found_one := FALSE
  else
    begin (* validator has access to subcommand *)
      found_one := TRUE;
      if subcommand_count > 0
      then
        begin (* first one was previously found *)
	  if format.buffer.size > 0
	  then format.string(COMMA_SPACE);
	  format.keyword_string(last_keyword);
	  if format.buffer.size >=
	    (COMMAND_LINE_TEXT_MAX - (KEYWORD_NAME_MAX + 4))
	  then (* in case buffer overflows! *)
	    begin
	      format.string(COMMA_SPACE);
	      format.write_line(user_terminal);
	      format.start
	    end
	end (* first one was previously found *);
      last_keyword := keyword_entry.name
    end (* validator has access to subcommand *)
end (* add_next_keyword *);



(*************************  keyword_utility  ****************************)
(*									*)
(*		       output_or_set_command_keywords			*)
(*									*)
(*      For the command_definition, and validator license, either	*)
(*	output all keywords and prompt for the new sub-command or	*)
(*	return the one and only sub-command possible.			*)
(*									*)
(************************************************************************)

procedure entry OUTPUT_OR_SET_COMMAND_KEYWORDS(
      header    	: command_definition;
  var subcommand_count	: command_keyword_total (* subcommands found *);
  var only_subcommand	: command_keyword_index);

var
  keyword : command_keyword_index;
  found_one : boolean;
  last_keyword : keyword_name;

begin
  format.start; subcommand_count := 0;
  for keyword := 0 to header.subcommand_count - 1 do
    begin
      add_next_keyword(header.keyword_offset, keyword, TRUE, subcommand_count,
        found_one, last_keyword);
      if found_one
      then
        begin
	  subcommand_count := subcommand_count + 1 (* count it *);
	  only_subcommand := keyword
	end (* found_one *);
    end (* for *);
 if subcommand_count > 1
 then
   begin
     add_last_keyword(last_keyword);
     format.write_line(user_terminal) (* output all possible options *)
   end (* subcommand_count > 1 *)
end (* output_or_set_command_keywords *);
!



(*************************  keyword_utility  ****************************)
(*									*)
(*		         output_line_keywords				*)
(*									*)
(*      For the keywords_choices, output the keyword strings.		*)
(*									*)
(************************************************************************)

procedure entry OUTPUT_LINE_KEYWORDS(
      keyword_choices	: keyword_choice_set);

var
  keyword : line_keyword_index;
  found_one : boolean;
  subcommand_count : command_keyword_total;
  last_keyword : keyword_name;

begin
  format.start; subcommand_count := 0;
  for keyword := 0 to LINE_KEYWORD_LIMIT do
    if keyword in keyword_choices
    then
      begin
        add_next_keyword(LINE_KEYWORD_OFFSET, keyword, FALSE,
	  subcommand_count, found_one, last_keyword);
	if found_one
	then subcommand_count := subcommand_count + 1
      end (* keyword in keyword_choices *);
  add_last_keyword(last_keyword);
  format.write_block(user_terminal) (* output options *)
end (* output_line_keywords *);



(*************************  keyword_utility  ****************************)
(*									*)
(*		       get_numeric_keyword_value			*)
(*									*)
(************************************************************************)

procedure entry GET_NUMERIC_KEYWORD_VALUE(
      keyword		: command_keyword_index;
      base		: integer;
      lower_limit	: integer;
      upper_limit	: integer;
  var scanned		: scanned_command;
  var value		: univ integer);

var
  temp : integer;

begin
  if argument_scan.check_keyword(keyword, scanned)
  then 
    begin
      argument_scan.keyword_number(keyword, base, scanned, temp);
      if scanned.status = CMD_OK
      then
        if (temp >= lower_limit) and (temp <= upper_limit)
        then value := temp
	else scanned.status := ARG_NUMBER_OUT_OF_BOUNDS
    end
  else scanned.status := ARG_MISSING
end (* get_numeric_keyword_value *);



(*************************  keyword_utility  ****************************)
(************************************************************************)

begin
end (* keyword_utility *);
!
(************************************************************************)
(*									*)
(*	INPSCN.NTV							*)
(*									*)
(*			terminal input scanner class			*)
(*									*)
(*	This class resides within any process wishing to scan a text	*)
(*	line.  It handles scanning both command lines (the command	*)
(*	definitions reside within command_table monitor) and non-command*)
(*	text lines.							*)
(*									*)
(*	The following identifiers must be defined externally:		*)
(*	  command_scanned, command_definition,				*)
(*	  keyword_definition, context_set, ascii_space,			*) 
(*	  max_key_value_size						*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	21Oct88 - jrn							*)
(*		- remove disk_maintenance_code code restrictions	*)
(*	27Jan86 - jrn							*)
(*	      - remove the use of size from COMMAND_PROMPT, and get rid	*)
(*		of scanned.error_column					*)
(*	14Nov84 Version 2.03 jrn					*)
(*	      - add input_list_description				*)
(*	14Apr84 Version 2.02	jrn					*)
(*	      - added licenses						*)
(*	29SEP83  original from (patrol)cmdscn.bas - jnm			*)
(*									*)
(************************************************************************)



type TERMINAL_INPUT_SCANNER = class(
	profile		: validator_profile;
	mutil		: misc_utility;
	format		: internal_to_string;
	user_terminal	: circuit_handler;
	commands	: command_table;
	argument_scan	: argument_scanner;
	keyword_util	: keyword_utility);



const
  NULL_PROMPT = '\       ';
  KEYWORD_PROMPT = 'enter one: \';



(***********************  terminal_input_scanner  ***********************)
(*									*)
(*				skip_spaces				*)
(*									*)
(*      Skip past all spaces.						*)
(*									*)
(************************************************************************)

procedure SKIP_SPACES(
      scanned	: scanned_command;
  var token	: command_token);

begin
  while scanned.input_line.text[token.finish] = ASCII_SPACE do
    token.finish := token.finish + 1
end (* skip_spaces *);



(**********************  terminal_input_scanner  ************************)
(*									*)
(*			      command_break				*)
(*									*)
(*	Determine if character is a command break character.		*)
(*									*)
(************************************************************************)

function command_break(
      test	: char) : boolean;

begin
  command_break := (test = ASCII_SPACE) or
    (test = ASCII_COMMA) or (test = ASCII_CARRIAGE_RETURN)
end (* command_break *);



(**********************  terminal_input_scanner  ************************)
(*									*)
(*				quote_break				*)
(*									*)
(*	Determine if character is the end of quoted text.		*)
(*									*)
(************************************************************************)

function quote_break(
      test	: char) : boolean;

begin
  quote_break := (test = ASCII_SINGLE_QUOTE) or (test = ASCII_CARRIAGE_RETURN)
end (* quote_break *);



(**********************  terminal_input_scanner  ************************)
(*									*)
(*				find_token				*)
(*									*)
(*	Find next separator.  Sets up token.				*)
(*									*)
(************************************************************************)

procedure find_token(
  var scanned	: scanned_command;
  var token	: command_token;
  var found	: boolean);

var
  skipped_comma : boolean;

begin
  skipped_comma := FALSE;
  skip_spaces(scanned, token);
  if token.finish > 0
  then
    if scanned.input_line.text[token.finish] = ASCII_COMMA
    then
      begin
        token.finish := token.finish + 1;
	skipped_comma := TRUE;
        skip_spaces(scanned, token)
      end;
  token.start := token.finish;

  if scanned.input_line.text[token.start] = ASCII_SINGLE_QUOTE
  then
    begin
      repeat
	token.finish := token.finish+1
      until quote_break(scanned.input_line.text[token.finish]);
      if scanned.input_line.text[token.finish] <> ASCII_SINGLE_QUOTE
      then scanned.status := BREAK_ERROR
      else
	begin
	  token.finish := token.finish+1;
	  if not command_break(scanned.input_line.text[token.finish])
	  then scanned.status := BREAK_ERROR
	end
    end
      else
	while not command_break(scanned.input_line.text[token.finish]) do
	  token.finish := token.finish + 1;
  if scanned.status = CMD_OK
  then
    if token.finish > token.start
    then found := TRUE
    else (* empty token *)
      if token.finish <> scanned.input_line.size - 1
      then scanned.status := ARG_ERROR (* error if not at end of line *)
      else
        if skipped_comma
        then scanned.status := ARG_ERROR (* trailing comma found *)
        else found := FALSE
end (* find_token *);
!
(***********************  terminal_input_scanner  ***********************)
(*									*)
(*			      process_keyword				*)
(*									*)
(*     Routine to process command keyword.				*)
(*									*)
(************************************************************************)

procedure process_keyword(
      keyword	    : command_keyword_index;
      keyword_entry : keyword_definition;
  var scanned	    : scanned_command;
  var token	    : command_token);

var 
  found : boolean;

begin
  if not profile.access_to_command(keyword_entry.required_license)
  then scanned.status := AUTH_ERROR (* authorization error for keyword *)
  else
    if keyword in scanned.keyword_present
    then scanned.status := DUPLICATE_KEYWORDS
    else
      begin
        scanned.keyword_present := scanned.keyword_present or [keyword];
        scanned.keyword_count := scanned.keyword_count + 1;
        if keyword_entry.value_required
        then
          begin (* process command keyword value *)
	    find_token(scanned, token, found);
	    if found
	    then scanned.keyword_value[keyword] := token
	    else scanned.status := INV_KEYWORD
	  end (* process command keyword value *)
      end
end (* process_keyword *);
!
(***********************  terminal_input_scanner  ***********************)
(*									*)
(*			     process_freeword				*)
(*									*)
(*      Routine to handle token described by token.			*)
(*	This routine sets up token as freeword if appropriate.		*)
(*									*)
(************************************************************************)

procedure process_freeword(
  var scanned : scanned_command;
  var token   : command_token);

begin
  if scanned.freeword_count < COMMAND_FREEWORD_MAX
  then
    begin (* freewords allowed and we have room for more *)
      scanned.freeword_value[scanned.freeword_count] := token;
      scanned.freeword_count := scanned.freeword_count + 1
    end (* freewords allowed and we have room for more *)
  else scanned.status := TOO_MANY_ARGS
end (* process_freeword *);
!
(***********************  terminal_input_scanner  ***********************)
(*									*)
(*			    initialize_scanned				*)
(*									*)
(************************************************************************)

procedure initialize_scanned(
  var scanned	: scanned_command);

var
  i : command_line_text_index;

begin
  for i := 0 to scanned.input_line.size - 1 do
    if (LOWER_CASE_A <= scanned.input_line.text[i]) and
       (scanned.input_line.text[i] <= LOWER_CASE_Z)
    then scanned.input_line.text[i] :=
      chr(ord(scanned.input_line.text[i]) - 32);

  scanned.status := CMD_OK;
  scanned.keyword_count := 0;
  scanned.keyword_present := [];
  scanned.freeword_count := 0;

  argument_scan.reset_argument_check
end (* initialize_scanned *);



(**********************  terminal_input_scanner  ************************)
(*									*)
(*			    tokenize_command				*)
(*									*)
(*      Tokenize command line.						*)
(*									*)
(************************************************************************)

procedure tokenize_command(
      header	: command_definition;
  var scanned	: scanned_command;
  var token	: command_token);

var
  found_token : boolean;
  subcommand_satisfied : boolean;
  keyword_entry : keyword_definition;
  keyword : command_keyword_index;
  found_keyword : boolean;

begin
  subcommand_satisfied := header.subcommand_count = 0;

(* Pick up each token and call process_token to identify it	*)
(* as a subcommand, keyword or a freeword.			*)
  repeat
    find_token(scanned, token, found_token);
    if found_token
    then
      begin (* found a token *)
        if subcommand_satisfied (* check for a keyword *)
	then commands.find_command_keyword(header, scanned, token,
	  keyword, keyword_entry, found_keyword)
	else (* check for a subcommand *)
	  commands.find_subcommand_keyword(header, scanned, token,
	    keyword, keyword_entry, found_keyword);
	if found_keyword
	then
	  begin (* found subcommand or keyword, process it *)
	    process_keyword(keyword, keyword_entry, scanned, token);
	    if not subcommand_satisfied
	    then
	      if argument_scan.check_keyword(keyword, scanned)
	      then
	        begin (* got the required subcmd, save it *)
		  subcommand_satisfied := TRUE;
		  scanned.subcommand := keyword
		end (* got the required subcmd, save it *)
	  end (* found subcommand or keyword, process it *)
	else (* no subcommand or keyword identified *)
	  if not subcommand_satisfied
	  then scanned.status := SUBCOMMAND_MISSING
	  else (* check for possible freeword *)
	    if header.freeword_allowed
	    then process_freeword(scanned, token)
	    else scanned.status := ARG_ERROR
      end (* found token, identify it as a subcommand *)
    else
      if not subcommand_satisfied
      then scanned.status := SUBCOMMAND_MISSING (* no token available *)
  until not found_token or (scanned.status <> CMD_OK)
end (* tokenize_command *);

        

(***********************  terminal_input_scanner  ***********************)
(*									*)
(*			      process_command				*)
(*									*)
(*      Routine to scan input string (inline) in scanned and return	*)
(*	command information in scanned.					*)
(*									*)
(************************************************************************)

procedure process_command(
      context	: context_set;
  var header    : command_definition;
  var scanned	: scanned_command);

var
  found  : boolean;
  token  : command_token;

begin
  initialize_scanned(scanned) (* clear values *);
  token.finish := 0;

  find_token(scanned, token, found);
  if not found
  then scanned.status := NO_CMD (* no command *);

  if scanned.status = CMD_OK
  then
    begin (* Lookup string in command table *)
      commands.find_command(context, token, scanned, header, found);
      if not found
      then scanned.status := CMD_ERROR
    end (* Lookup string in command table *);

  if scanned.status = CMD_OK
  then (* Check validator_type requirements for command *)
    if not profile.access_to_command(header.required_license)
    then scanned.status := AUTH_ERROR;

  if scanned.status = CMD_OK
  then tokenize_command(header, scanned, token)
end (* process_command *);



(***********************  terminal_input_scanner  ***********************)
(*									*)
(*			  input_and_scan_command			*)
(*									*)
(*      Routine to output the appropriate prompt, input a line		*)
(*	(scanned.input_line), scan the line, and return command		*)
(*	information in scanned.						*)
(*									*)
(************************************************************************)

procedure entry INPUT_AND_SCAN_COMMAND(
      command_context	: context_set;
  var scanned    	: scanned_command);

var
  header : command_definition;
  token  : command_token;
  subcommand_count : command_keyword_total;

begin
  commands.get_prompt(command_context, scanned);
  repeat

(* clear break status and tell user *)
    while user_terminal.break_pending do
      begin
        user_terminal.clear_break_status;
        user_terminal.write_quoted_text_line('<break>\')
      end (* while *);

    if user_terminal.sendable
    then
      begin (* prompt and read command *)
        format.start_and_newline;
	format.prompt(scanned.prompt);
	format.write_block(user_terminal);
	user_terminal.read_command_line(scanned.input_line)
      end (* prompt and read command *)
  until not user_terminal.break_pending;

  if user_terminal.sendable
  then
    begin
      process_command(command_context, header, scanned);

(*      The validator has entered a command without a required		*)
(*	subcommand.  If there is more than one choice, output all the	*)
(*	possible choices, and pretend it is a prompt.  Input the new	*)
(*	line into scanned.  Scan input_line and return command		*)
(*	information or error.  If there is a single subcommand choice,	*)
(*	set it as the subcommand entered.				*)

      while user_terminal.sendable and (scanned.status=SUBCOMMAND_MISSING) do
	begin
	  keyword_util.output_or_set_command_keywords(header, subcommand_count,
	    scanned.subcommand);
	  if subcommand_count = 0
	  then scanned.status := AUTH_ERROR (* no choices found for user! *)
	  else
	    if subcommand_count = 1
	    then scanned.status := CMD_OK (* only one choice found *)
	    else
	      begin (* re-prompt and re-process input line *)
	        user_terminal.write_line_and_quoted_text(KEYWORD_PROMPT);
		scanned.prompt := NULL_PROMPT;
		if user_terminal.sendable
		then user_terminal.read_command_line(scanned.input_line);
		if user_terminal.sendable
		then
		  begin
		    initialize_scanned(scanned) (* clear values *);
		    token.finish := 0 (* process all tokens *);
		    tokenize_command(header, scanned, token)
		  end (* user_terminal.sendable *)
	      end (* re-prompt and re-process input line *)
	end (* while *)
    end (* user_terminal.sendable *)
end (* input_and_scan_command *);



(***********************  terminal_input_scanner  ***********************)
(*									*)
(*			     scan_line_keyword				*)
(*									*)
(************************************************************************)

procedure scan_line_keyword(
      keyword_choices	: keyword_choice_set;
  var keyword		: line_keyword_index);

var
  found : boolean;
  scanned : scanned_command;
  token : command_token;
  keyword_entry	: keyword_definition;

begin
  repeat
    found := FALSE;
    user_terminal.read_command_line(scanned.input_line);
    if user_terminal.sendable
    then
      begin
        initialize_scanned(scanned);
        token.finish := 0;
	find_token(scanned, token, found);
        if found
        then commands.find_line_keyword(keyword_choices, scanned, token,
	  keyword, keyword_entry, found);
      end (* sendable *);
    if user_terminal.sendable and not found
    then
      begin (* re-prompt *)
	keyword_util.output_line_keywords(keyword_choices);
	user_terminal.write_line_and_quoted_text(KEYWORD_PROMPT)
      end (* re-prompt *)
  until found or not user_terminal.sendable
end (* scan_line_keyword *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(***********************  terminal_input_scanner  ***********************)
(*									*)
(*			    input_and_scan_line				*)
(*									*)
(*      Routine to output the supplied prompt, input a line		*)
(*	(scanned.input_line) and tokenize the line in scanned.		*)
(*									*)
(************************************************************************)

procedure entry INPUT_AND_SCAN_LINE(
      line_prompt	: quoted_text;
  var scanned    	: scanned_command);

var
  found  : boolean;
  token  : command_token;

begin
  user_terminal.write_quoted_text(line_prompt);
  user_terminal.read_command_line(scanned.input_line);
  if user_terminal.sendable
  then
    begin (* scan scanned.inline and return token info in scanned *)
      initialize_scanned(scanned) (* clear values *);
      scanned.prompt := NULL_PROMPT;
      token.finish := 0;

      repeat
        find_token(scanned, token, found);
        if found
        then process_freeword(scanned, token)
      until not found or (scanned.status <> CMD_OK);
      if (scanned.status = CMD_OK) and (scanned.freeword_count = 0)
      then scanned.status := NO_CMD
    end
end (* input_and_scan_line *);



(***********************  terminal_input_scanner  ***********************)
(*									*)
(*			  prompt_and_scan_keyword			*)
(*									*)
(*      Routine to output the supplied prompt, input a line		*)
(*	(scanned.input_line), tokenize the line and return		*)
(*	one of a number of keywords.					*)
(*									*)
(************************************************************************)

procedure entry PROMPT_AND_SCAN_KEYWORD(
      keyword_choices	: keyword_choice_set;
  var keyword		: line_keyword_index);

begin
  keyword_util.output_line_keywords(keyword_choices);
  user_terminal.write_quoted_text('? \ ');
  scan_line_keyword(keyword_choices, keyword)
end (* prompt_and_scan_keyword *);



(***********************  terminal_input_scanner  ***********************)
(*									*)
(*			  input_and_scan_keyword			*)
(*									*)
(*      Routine to input a line (scanned.input_line), tokenize the line	*)
(*	and return one of a number of keywords.				*)
(*									*)
(************************************************************************)

procedure entry INPUT_AND_SCAN_KEYWORD(
      keyword_choices	: keyword_choice_set;
  var keyword		: line_keyword_index);

begin
  scan_line_keyword(keyword_choices, keyword)
end (* input_and_scan_keyword *);


(************************************************************************)
(************************************************************************)

begin
end (* terminal_input_scanner *);
!
(************************************************************************)
(*									*)
(*	CMDERR.NTV							*)
(*									*)
(*			command_error_message				*)
(*									*)
(*	This class contains all command error message processing.	*)
(*	It will handle all command_scan_state messages except		*)
(*	CMD_OK, RUN_ERROR and NO_CMD. (Because there is nothing to	*)
(*	print.								*)
(*									*)
(*	The following identifiers must be defined externally:		*)
(*	  command_scan_state						*)
(*	  scanned_command						*)
(*									*)
(************************************************************************)
(*									*)
(*	                     Revision Record                            *)
(*									*)
(*	18Nov87 - neh							*)
(*	      - add ARG_NOT_ENOUGH_CHARS				*)
(*	29SEP83 original from (patrol)cmderr.bas - jrn			*)
(*									*)
(************************************************************************)


type COMMAND_ERROR_MESSAGE = class(
	user_terminal	: circuit_handler;
	format		: internal_to_string);



(************************  command_error_message  ***********************)
(*									*)
(*			   display_command_error			*)
(*									*)
(*	Display the appropriate command scanning error.			*)
(*									*)
(************************************************************************)

procedure entry DISPLAY_COMMAND_ERROR(
      scanned	: scanned_command);

begin
  with user_terminal, scanned do
    if (status <> CMD_OK) and (status <> RUN_ERROR)
    then
      case status of
        CMD_OK,
	RUN_ERROR,
	NO_CMD: (* no message *);
	CMD_ERROR:	write_quoted_text_line('invalid command\');
	ILLEGAL_CHAR:	write_quoted_text_line('illegal character entered\');
	BREAK_ERROR:	write_quoted_text_line('break char missing\ ');
	DUPLICATE_KEYWORDS:
	  write_quoted_text_line('duplicate keyword entered\');
	INV_KEYWORD:	write_quoted_text_line('illegal value\');
	AUTH_ERROR:
	  write_quoted_text_line('do not have proper authorization\ ');
	ARG_ERROR:	write_quoted_text_line('invalid argument\ ');
	ARG_MISSING:	write_quoted_text_line('argument missing\ ');
	TOO_MANY_ARGS:	write_quoted_text_line('too many arguments\ ');
	ARG_TOO_MANY_CHARS:	write_quoted_text_line('argument too long\');
	ARG_NOT_ENOUGH_CHARS:	write_quoted_text_line('argument too short\ ');
	ARG_NUMBER_OUT_OF_BOUNDS:
	  write_quoted_text_line('number out of bounds\ ');
	ARG_FREEWORD_MISSING:	write_quoted_text_line('parameter missing\')
      end (* case *)
end (* display_command_error *);



(************************  command_error_message  ***********************)
(************************************************************************)

begin (* initial statement *) 
end (* command_error_message *);
!
(************************************************************************)
(*									*)
(*	FRUTIL.NTV							*)
(*			           					*)
(*			freeword_response_utility			*)
(*									*)
(*	This Class handles freeword values, both in scanned command	*)
(*	lines and as "prompted" for values.  Common routines are used	*)
(*	to re-prompt for errors.					*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	06Mar89 - neh							*)
(*		- change get_freeword_username to check extra if	*)
(*		  freeword was prompted					*)
(*	19Jan89 - neh							*)
(*		- change fpc_start to use MAXIMUM_EFFECTIVE_PERIOD	*)
(*		- add message that set validity must be set before	*)
(*		  passperiod if password_expiration_by_user is enabled.	*)
(*	04Jan89 - neh							*)
(*		- add prompt_for_fpc_start				*)
(*	21Dec88 - neh							*)
(*		- change get_freeword_username to have limit on		*)
(*		  retries when name is not entered correctly		*)
(*		  add prompt_username_count to pass limit		*)
(*		- add semi-colon at end of conditional lines		*)
(*	04Nov88 - jrn							*)
(*		- add allow_temporary_apes code				*)
(*	03Oct88 - jrn							*)
(*		- add get_array_of_ranges for NVDM			*)
(*		- change allow_user_password_expire to			*)
(*		  password_expiration_by_user and check out code	*)
(*		- use password_expiration_date_in_cud for code that is	*)
(*		  required for global or user password expiration	*)
(*	19Sep88 - jrn							*)
(*		- add code for prevent_duplicate_passwords		*)
(*		- add code for restrict_users_by_time			*)
(*	09Nov87 - neh							*)
(*	      - add get_freeword_dnicname,PROMPT_DNICNAME,GET_DNICNAME, *)
(*		PROMPT_LOOKUP and PROMPT_SECOND_LOOKUP			*)
(*	12Jan87 - rsb							*)
(*		- add GET_PASSLIFE, GET_GPOGAN, FETCH_TIME_IN_MINUTES,	*)
(*		  and PUT_24_HOUR_TIME					*)
(*	27Jan86 - jrn							*)
(*	      - change NULL_PROMPT to NULL_STRING			*)
(*	07Oct85 - jrn							*)
(*	      - add prompt_link_host (for VALIDATE_X25_NAMES flag)	*)
(*	10Jan85 - jrn							*)
(*	      - add get_numeric_freeword_value				*)
(*	31May84	Version 2.02 - jrn					*)
(*	      - add prompt_uun routine					*)
(*		Original -- jrn						*)
(*									*)
(************************************************************************)


type FREEWORD_RESPONSE_UTILITY = class(
	user_terminal	: circuit_handler;
	format		: internal_to_string;
	argument_scan	: argument_scanner;
	input_scanner	: terminal_input_scanner;
	scan_error	: command_error_message);





(*********************  freeword_response_utility  **********************)
(*									*)
(*			     input_number				*)
(*									*)
(************************************************************************)

procedure input_number(
      freeword	: command_freeword_index;
      base	: integer;
      min_value	: integer;
      max_value	: integer;
  var scanned   : scanned_command;
  var value	: univ integer);

var
  temp : integer;
  ptr : command_line_text_index;

begin
  argument_scan.freeword_number(freeword, base, scanned, temp);
  if scanned.status = CMD_OK
  then
    if (temp >= min_value) and (temp <= max_value)
    then value := temp
    else scanned.status := ARG_NUMBER_OUT_OF_BOUNDS;
  if scanned.status <> CMD_OK
  then
    begin	(* output command error *)
      scan_error.display_command_error(scanned);
      if scanned.status = ARG_NUMBER_OUT_OF_BOUNDS
      then
        if min_value = max_value
	then
	  begin
	    format.start_message('number should be the value: \ ');
	    format.number(min_value, base);
	    format.write_line(user_terminal)
	  end
	else
          begin
            format.start_message('"\');
	    for ptr := scanned.freeword_value[freeword].start to
	      scanned.freeword_value[freeword].finish - 1 do
	        format.character(scanned.input_line.text[ptr]);
	    format.string('" should be a\');
            if base = 10
            then format.string(' decimal\ ')
            else
              if base = 8
	      then format.string('n octal\')
	      else format.string(' hex\ ');
	    format.string(' number between \ ');
	    format.number(min_value, base);
	    format.string(' and \');
	    format.number(max_value, base);
	    format.write_line(user_terminal)
          end
    end
end (* input_number *);



(*********************  freeword_response_utility  **********************)
(*									*)
(*			   get_freeword_number				*)
(*									*)
(************************************************************************)

procedure get_freeword_number(
      freeword		: command_freeword_index;
      base		: integer;
      min_value		: integer;
      max_value		: integer;
      was_prompted	: boolean (* TRUE if  prompted for freeword *);
			(* FALSE if user entered info on command line *)
  var scanned		: scanned_command;
  var value		: univ integer);

var
  done : boolean;
  this_freeword : command_freeword_index;

begin
  done := FALSE;
  this_freeword := freeword;
  while user_terminal.sendable and not done do
    begin
      if was_prompted and (scanned.freeword_count > 1)
      then scanned.status := TOO_MANY_ARGS;
      if scanned.status = CMD_OK
      then input_number(this_freeword, base, min_value, max_value, scanned,
        value)
      else scan_error.display_command_error(scanned);
      if scanned.status = CMD_OK
      then done := TRUE
      else input_scanner.input_and_scan_line('reenter value: \', scanned)
    end
end (* get_freeword_number *);
$ifany (force_password_change, password_expiration_by_user)



(*********************  freeword_response_utility  **********************)
(*									*)
(*			  minimum_validity_value			*)
(*									*)
(************************************************************************)

function minimum_validity_value
$ifall (prevent_duplicate_passwords, password_expiration_by_user)
      (min_password_change_time	: integer)
$endif (prevent_duplicate_passwords, password_expiration_by_user)
	: integer;

begin
$if password_expiration_by_user
$if prevent_duplicate_passwords
  if min_password_change_time > MINIMUM_STANDARD_PASSWORD_VALIDITY_PERIOD
  then minimum_validity_value := min_password_change_time + 1
  else
$endif prevent_duplicate_passwords
  minimum_validity_value := MINIMUM_STANDARD_PASSWORD_VALIDITY_PERIOD;
$endif password_expiration_by_user
$if force_password_change
  minimum_validity_value := MINIMUM_GANPASS_PERIOD
$endif force_password_change
end (* minimum_validity_value *);
$endif (force_password_change, password_expiration_by_user)
$if password_expiration_by_user



(*********************  freeword_response_utility  **********************)
(*									*)
(*			prompt_standard_validity			*)
(*									*)
(*      Ask for and input legal validity period.			*)
(*									*)
(************************************************************************)

procedure entry PROMPT_STANDARD_VALIDITY(
$if prevent_duplicate_passwords       min_password_change_time	: integer;
  var scanned		: scanned_command;
  var validity_period	: integer);

begin
  if scanned.freeword_count = 0
  then
    begin
      input_scanner.input_and_scan_line(
        STANDARD_PASSWORD_VALIDITY_PERIOD_IN_DAYS_MESSAGE, scanned);
      get_freeword_number(0, 10, minimum_validity_value
$if prevent_duplicate_passwords       (min_password_change_time)
	, MAXIMUM_STANDARD_PASSWORD_VALIDITY_PERIOD, TRUE, scanned,
	validity_period)
    end
  else get_freeword_number(0, 10, minimum_validity_value
$if prevent_duplicate_passwords       (min_password_change_time)
    , MAXIMUM_STANDARD_PASSWORD_VALIDITY_PERIOD, FALSE, scanned,
    validity_period)
end (* prompt_standard_validity *);
$endif password_expiration_by_user
$ifany (force_password_change, password_expiration_by_user)



(*********************  freeword_response_utility  **********************)
(*									*)
(*			     prompt_validity				*)
(*									*)
(*      Ask for and input legal validity period.			*)
(*									*)
(************************************************************************)

procedure prompt_validity(
$ifall (prevent_duplicate_passwords, password_expiration_by_user)
      min_password_change_time	: integer;
$endif (prevent_duplicate_passwords, password_expiration_by_user)
  var scanned		: scanned_command;
  var validity_period	: integer);

begin
  input_scanner.input_and_scan_line(PASSWORD_VALIDITY_PERIOD_IN_DAYS_MESSAGE,
    scanned);
  get_freeword_number(0, 10, minimum_validity_value
$if force_password_change     , MAXIMUM_GANPASS_PERIOD,
$if password_expiration_by_user
$if prevent_duplicate_passwords       (min_password_change_time)
    , MAXIMUM_STANDARD_PASSWORD_VALIDITY_PERIOD,
$endif password_expiration_by_user
    TRUE, scanned, validity_period)
end (* prompt_validity *);



(*********************  freeword_response_utility  **********************)
(*									*)
(*			       get_validity				*)
(*									*)
(*      Get a validity period from the freeword specified, and reprompt	*)
(*	if any error.							*)
(*									*)
(************************************************************************)

procedure entry GET_VALIDITY(
$ifall (prevent_duplicate_passwords, password_expiration_by_user)
      min_password_change_time	: integer;
$endif (prevent_duplicate_passwords, password_expiration_by_user)
  var scanned		: scanned_command;
  var validity_period	: integer);

begin
  if scanned.freeword_count = 0
  then prompt_validity(
$ifall (prevent_duplicate_passwords, password_expiration_by_user)
    minimum_validity_value(min_password_change_time),
$endif (prevent_duplicate_passwords, password_expiration_by_user)
    scanned, validity_period)
  else
    if scanned.freeword_count = 1
    then get_freeword_number(1, 10, minimum_validity_value
$if force_password_change     , MAXIMUM_GANPASS_PERIOD,
$if password_expiration_by_user
$if prevent_duplicate_passwords      (min_password_change_time)
      , MAXIMUM_STANDARD_PASSWORD_VALIDITY_PERIOD,
$endif password_expiration_by_user
      FALSE, scanned, validity_period)
end (* get_validity *);
$endif (force_password_change, password_expiration_by_user)
$ifnone disk_maintenance_code



(*********************  freeword_response_utility  **********************)
(*									*)
(*			    reset_number_list				*)
(*									*)
(************************************************************************)

procedure reset_number_list(
      max_entries	: general_number_list_size;
  var index		: general_number_list_index;
  var freeword		: command_freeword_index;
  var size		: general_number_list_size;
  var scanned		: scanned_command);

begin
  index := 0;
  freeword := 0;
  size := 0;
  if scanned.freeword_count > max_entries
  then scanned.status := TOO_MANY_ARGS
end (* reset_number_list *);



(*********************  freeword_response_utility  **********************)
(*									*)
(*			     prompt_number_list				*)
(*									*)
(*      Input and validate a list of numbers.				*)
(*									*)
(************************************************************************)

procedure entry PROMPT_NUMBER_LIST(
      max_entries	: general_number_list_size;
      base		: integer;
      min_value		: integer;
      max_value		: integer;
  var numbers		: general_number_list);

var
  scanned : scanned_command;
  add_value,
  done : boolean;
  freeword : command_freeword_index;
  temp_index,
  index : general_number_list_index;

begin
  done := FALSE;
  input_scanner.input_and_scan_line('\ ', scanned);
  reset_number_list(max_entries, index, freeword, numbers.size, scanned);
  while user_terminal.sendable and not done do
    begin
      if scanned.status = CMD_OK
      then input_number(freeword, base, min_value, max_value,
        scanned, numbers.list[index])
      else
        if scanned.status = TOO_MANY_ARGS
	then
	  begin	(* report list too long *)
	    format.start_message('there may be a maximum of \ ');
	    format.number(max_entries, 10);
	    format.string(' entries in the list entered\ ');
	    format.write_line(user_terminal)
  	  end
	else scan_error.display_command_error(scanned);
      if scanned.status = CMD_OK
      then
	begin
	  add_value := TRUE;
          if index > 0
          then
  	    for temp_index := 0 to index - 1 do
  	      if numbers.list[temp_index] = numbers.list[index]
	      then add_value := FALSE;
	  if add_value
	  then numbers.size := numbers.size + 1
	  else numbers.list[index] := 0
	end;
      if (scanned.status = CMD_OK) or
        (scanned.status = ARG_NUMBER_OUT_OF_BOUNDS)
      then
        if freeword + 1 >= scanned.freeword_count (* used all freewords *)
        then
	  if numbers.size > 0 (* any entries good? *)
	  then done := TRUE
	  else done := FALSE
        else
	  begin
	    freeword := freeword + 1	(* proceed to next freeword *);
	    if (scanned.status = CMD_OK) and add_value
	    then index := index + 1		(* increment numbers index *)
	    else scanned.status := CMD_OK
	  end;
      if not done and (scanned.status <> CMD_OK)
      then
        begin
	  input_scanner.input_and_scan_line('reenter list: \ ', scanned);
	  reset_number_list(max_entries, index, freeword, numbers.size,
	    scanned)
        end
    end
end (* prompt_number_list *);
$if INCLUDE_DNIC
!



(*********************  freeword_response_utility  **********************)
(*									*)
(*			     prompt_lookup				*)
(*									*)
(*      Ask for, input and validate number of first lookups.		*)
(*									*)
(************************************************************************)

procedure entry PROMPT_LOOKUP(
      lookup_prompt	: quoted_text;
  var scanned		: scanned_command;
  var lookups		: lookup_index);

begin
  user_terminal.write_newline;
  input_scanner.input_and_scan_line(lookup_prompt, scanned);
  get_freeword_number(0, 10, MINIMUM_LOOKUP, MAXIMUM_LOOKUP,
    TRUE, scanned, lookups)
end (* prompt_lookup *);



(*********************  freeword_response_utility  **********************)
(*									*)
(*			     prompt_second_lookup			*)
(*									*)
(*      Ask for, input and validate number of first lookups.		*)
(*									*)
(************************************************************************)

procedure entry PROMPT_SECOND_LOOKUP(
      max_second	: integer;
  var scanned		: scanned_command;
  var lookups		: lookup_index);

var
  temp_second : integer;

begin
  input_scanner.input_and_scan_line('Number of secondary MUD lookups: \',
    scanned);
  if max_second > MAXIMUM_LOOKUP
  then temp_second := MAXIMUM_LOOKUP
  else temp_second := max_second - 1;
  get_freeword_number(0, 10, MINIMUM_LOOKUP, temp_second,
    TRUE, scanned, lookups)
end (* prompt_second_lookup *);
$endif INCLUDE_DNIC



(*********************  freeword_response_utility  **********************)
(*									*)
(*			     do_prompt_class				*)
(*									*)
(*      Ask for, input and validate class number.			*)
(*									*)
(************************************************************************)

procedure do_prompt_class(
      min_class		: integer;
  var scanned		: scanned_command;
  var class_number	: class_index);

begin
  input_scanner.input_and_scan_line('class: \', scanned);
  get_freeword_number(0, 10, min_class, MAXIMUM_CLASS, TRUE, scanned,
    class_number)
end (* do_prompt_class *);



(*********************  freeword_response_utility  **********************)
(*									*)
(*			     prompt_class				*)
(*									*)
(*      Ask for, input and validate class number.			*)
(*									*)
(************************************************************************)

procedure entry PROMPT_CLASS(
      min_class		: integer;
  var scanned		: scanned_command;
  var class_number	: class_index);

begin
  do_prompt_class(min_class, scanned, class_number)
end (* prompt_class *);



(*********************  freeword_response_utility  **********************)
(*									*)
(*			       get_class				*)
(*									*)
(*      Get a class number from the freeword specified, and reprompt	*)
(*	if any error.							*)
(*									*)
(************************************************************************)

procedure entry GET_CLASS(
      freeword   : command_freeword_index;
  var scanned	 : scanned_command;
  var class_num	 : class_index);

begin
  if scanned.freeword_count = 0
  then do_prompt_class(FIRST_CLASS, scanned, class_num)
  else get_freeword_number(0, 10, FIRST_CLASS, MAXIMUM_CLASS, FALSE,
    scanned, class_num)
end (* get_class *);



(*********************  freeword_response_utility  **********************)
(*									*)
(*			      get_group					*)
(*									*)
(*      Get a group number from the freeword specified, and reprompt	*)
(*	if any error.							*)
(*									*)
(************************************************************************)

procedure entry GET_GROUP(
      freeword   : command_freeword_index;
  var scanned	 : scanned_command;
  var group_num	 : group_index);

begin
  if scanned.freeword_count = 0
  then
    begin
      input_scanner.input_and_scan_line('group: \', scanned);
      get_freeword_number(0, 10, FIRST_GROUP, MAXIMUM_GROUP, TRUE, scanned,
        group_num)
    end
  else get_freeword_number(freeword, 10, FIRST_GROUP, MAXIMUM_GROUP, FALSE,
    scanned, group_num)
end (* get_group *);
$if force_password_change
$if request_fpc_start



(*********************  freeword_response_utility  **********************)
(*                                                                      *)
(*                           prompt_start                               *)
(*                                                                      *)
(*      Ask for and input effective start date.                         *)
(*                                                                      *)
(************************************************************************)

procedure prompt_start(
  var scanned   : scanned_command;
  var startdate : integer);
 
var
  start : integer;

begin
  if scanned.status = CMD_OK
  then
    begin
      input_scanner.input_and_scan_line(
        'enter number of days before effective (cr if immediate): \', scanned);
      if (scanned.freeword_count = 0) and (scanned.status = NO_CMD)
      then
        begin
	  scanned.status := CMD_OK;
          start := 0
        end
      else get_freeword_number(0, 10, 0, MAXIMUM_EFFECTIVE_PERIOD, TRUE,
			scanned, start);
      if scanned.status = CMD_OK
      then startdate := REALTIME + (start * SECONDS_PER_DAY);
    end
end (* prompt_start *);
$endif request_fpc_start




(*********************  freeword_response_utility  **********************)
(*									*)
(*			     prompt_ganpass				*)
(*									*)
(*      Ask for, input and validate ganpass.				*)
(*									*)
(************************************************************************)

procedure prompt_ganpass(
      max_gan	: integer;
  var scanned	: scanned_command;
  var new_gan	: integer;
$if request_fpc_start   var startdate   : integer;
  var passlife	: integer);

begin
  input_scanner.input_and_scan_line('GAN: \', scanned);
  get_freeword_number(0, 8, 1, max_gan, TRUE, scanned, new_gan);
  prompt_validity(scanned, passlife);
$if request_fpc_start   prompt_start(scanned, startdate)
end (* prompt_ganpass *);



(*********************  freeword_response_utility  **********************)
(*									*)
(*			       get_ganpass				*)
(*									*)
(*      Get a ganpass number from the freeword specified, and reprompt	*)
(*	if any error.							*)
(*									*)
(************************************************************************)

procedure entry GET_GANPASS(
  var scanned	: scanned_command;
      max_gan	: integer;
  var new_gan	: integer;
$ifnot request_fpc_start  var passlife	: integer);
$if request_fpc_start
  var passlife	: integer;
  var startdate : integer);
$endif request_fpc_start

begin
  if scanned.freeword_count = 0
  then prompt_ganpass(max_gan, scanned, new_gan,
$if request_fpc_start   startdate,
    passlife)
  else
    if scanned.freeword_count = 2
    then
      begin (* fetch gan and passlife from command line *)
	get_freeword_number(0, 8, 1, max_gan, FALSE, scanned, new_gan);
	get_freeword_number(1, 10, MINIMUM_GANPASS_PERIOD,
			     MAXIMUM_GANPASS_PERIOD, FALSE, scanned, passlife);
$if request_fpc_start         prompt_start(scanned, startdate)
      end  (* fetch gan and passlife from command line *)
end (* get_ganpass *);
$endif force_password_change
$if ganpass_file_exists



(*********************  freeword_response_utility  **********************)
(*									*)
(*			       get_gan					*)
(*									*)
(*      Get a gpogan number from the freeword specified, and reprompt	*)
(*	if any error.							*)
(*									*)
(************************************************************************)

procedure entry GET_GAN(
  var scanned	: scanned_command;
      max_gan	: integer;
  var new_gan	: integer);

begin
  if scanned.freeword_count = 0
  then
    begin
      input_scanner.input_and_scan_line('GAN: \', scanned);
      get_freeword_number(0, 8, 1, max_gan, TRUE, scanned, new_gan);
      user_terminal.write_newline
    end (* prompt_gpogan *)
  else
    if scanned.freeword_count = 1
    then get_freeword_number(0, 8, 1, max_gan, FALSE, scanned, new_gan)
end (* get_gan *);
$endif ganpass_file_exists
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(*********************  freeword_response_utility  **********************)
(*									*)
(*			      prompt_host				*)
(*									*)
(*      Ask for, input and validate host number.			*)
(*									*)
(************************************************************************)

procedure entry PROMPT_HOST(
      host_prompt	: quoted_text;
  var scanned		: scanned_command;
  var host		: integer);

begin
  input_scanner.input_and_scan_line(host_prompt, scanned);
  get_freeword_number(0, 10, MINIMUM_HOST, MAXIMUM_HOST, TRUE, scanned, host)
end (* prompt_host *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if restrict_users_by_time



(*********************  freeword_response_utility  **********************)
(*									*)
(*			  prompt_allowable_times			*)
(*									*)
(*      Ask for, input and validate allowable times.			*)
(*									*)
(************************************************************************)

procedure entry PROMPT_ALLOWABLE_TIMES(
  var scanned		: scanned_command;
  var allowable_times	: allowable_login_times);

var
  hours_index : allowable_login_hours;
  hour_range : range;
  done : boolean;
  all_hours_specified : boolean;
  freeword : command_freeword_index;

begin
  done := FALSE;
  input_scanner.input_and_scan_line(
    'enter allowable time period(s), in UTC: \ ', scanned);
  if scanned.freeword_count = 0
  then allowable_times := [ALL_HOURS]
  else
  while user_terminal.sendable and not done do
    begin
      freeword := 0; allowable_times := [];
      repeat
        argument_scan.freeword_range(freeword, FIRST_HOUR, LAST_HOUR, 10,
	  scanned, hour_range);
	if scanned.status = CMD_OK
	then
	  if (hour_range.first = hour_range.last) and
	    (hour_range.first = LAST_HOUR)
	  then
	    begin (* cannot enter just "24" *)
	      scanned.status := ARG_NUMBER_OUT_OF_BOUNDS;
	      scan_error.display_command_error(scanned)
	    end (* cannot enter just "24" *)
	  else
	  begin	(* convert hour range into set of allowable hours *)
	    if hour_range.first <> hour_range.last
	    then hour_range.last := hour_range.last - 1 (* UP TO last hour *);
	    for hours_index := hour_range.first to hour_range.last do
	      allowable_times := allowable_times or [hours_index];
            if freeword + 1 >= scanned.freeword_count (* used all freewords *)
	    then done := TRUE
	    else freeword := freeword + 1
  	  end (* convert hour range into set of allowable hours *)
	else scan_error.display_command_error(scanned)
      until not user_terminal.sendable or done or (scanned.status <> CMD_OK);
      if scanned.status <> CMD_OK
      then input_scanner.input_and_scan_line('reenter hours: \', scanned)
      else
        begin (* check for all hours input *)
	  all_hours_specified := TRUE;
	  for hours_index := FIRST_HOUR TO LAST_HOUR - 1 DO
	    if not (hours_index in allowable_times)
	    then all_hours_specified := FALSE;
	  if all_hours_specified
	  then allowable_times := [ALL_HOURS]
	end (* check for all hours input *)
    end (* while *)
end (* prompt_allowable_times *);
$endif restrict_users_by_time
$if validate_x25_names



(*********************  freeword_response_utility  **********************)
(*									*)
(*			      prompt_link_host				*)
(*									*)
(*      Ask for, input and validate an X25 link host number.		*)
(*									*)
(************************************************************************)

procedure entry PROMPT_LINK_HOST(
  var scanned		: scanned_command;
  var link_host		: integer);

begin
  input_scanner.input_and_scan_line('link host: \', scanned);
  get_freeword_number(0, 10, MINIMUM_HOST, MAXIMUM_HOST, TRUE, scanned,
    link_host)
end (* prompt_link_host *);
$endif validate_x25_names
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
(*********************  freeword_response_utility  **********************)
(*									*)
(*			      prompt_node				*)
(*									*)
(*      Ask for, input and validate node number.			*)
(*									*)
(************************************************************************)

procedure entry PROMPT_NODE(
      node_prompt	: quoted_text;
  var scanned		: scanned_command;
  var node		: integer);

begin
  input_scanner.input_and_scan_line(node_prompt, scanned);
  get_freeword_number(0, 8, MINIMUM_NODE, MAXIMUM_NODE, TRUE, scanned, node)
end (* prompt_node *);
!
(*********************  freeword_response_utility  **********************)
(*									*)
(*			    prompt_district				*)
(*									*)
(*      Ask for, input and validate district number.			*)
(*									*)
(************************************************************************)

procedure entry PROMPT_DISTRICT(
  var scanned	: scanned_command;
  var district	: district_number);

begin
  input_scanner.input_and_scan_line('district: \ ', scanned);
  get_freeword_number(0, 10, MINIMUM_DISTRICT, MAXIMUM_DISTRICT,
    TRUE, scanned, district)
end (* prompt_district *);
!
(*********************  freeword_response_utility  **********************)
(*									*)
(*			      prompt_gan				*)
(*									*)
(*      Ask for, input and validate a gan.				*)
(*									*)
(************************************************************************)

procedure entry PROMPT_GAN(
      maximum_gan	: integer;
  var scanned		: scanned_command;
  var gan	 	: integer);

begin
  input_scanner.input_and_scan_line(GAN_PROMPT, scanned);
  get_freeword_number(0, 8, MINIMUM_GAN, maximum_gan, TRUE, scanned, gan)
end (* prompt_gan_number *);
$if include_irc


!
(*********************  freeword_response_utility  **********************)
(*									*)
(*			    prompt_irc					*)
(*									*)
(*      Ask for, input and validate irc number.				*)
(*									*)
(************************************************************************)

procedure entry PROMPT_IRC(
  var scanned	: scanned_command;
  var irc	: irc_number);

begin
  input_scanner.input_and_scan_line('irc: \', scanned);
  get_freeword_number(0, 10, MINIMUM_IRC, MAXIMUM_IRC,
    TRUE, scanned, irc)
end (* prompt_irc *);
$endif include_irc
!
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if UUNSassignable



(*********************  freeword_response_utility  **********************)
(*									*)
(*			      prompt_uun				*)
(*									*)
(*      Ask for, input and validate a uun.				*)
(*									*)
(************************************************************************)

procedure entry PROMPT_UUN(
  var scanned		: scanned_command;
  var uun	 	: integer);

begin
  input_scanner.input_and_scan_line(UUN_PROMPT, scanned);
  get_freeword_number(0, UUN_RADIX, MINIMUM_UUN, MAXIMUM_UUN, TRUE,
    scanned, uun)
end (* prompt_uun_number *);
$endif UUNSassignable
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!


(*********************  freeword_response_utility  **********************)
(*									*)
(*		      prompt_access_entry_position			*)
(*									*)
(*      Ask for, input and validate an access entry position.		*)
(*									*)
(************************************************************************)

procedure entry prompt_access_entry_position(
      prompt		: quoted_text;
      max_position	: access_entry_size;
  var scanned		: scanned_command;
  var access_entry	: access_entry_index);

var
  temp : integer;

begin
  input_scanner.input_and_scan_line(prompt, scanned);
  get_freeword_number(0, 10, 1, max_position, TRUE, scanned, temp);
  if user_terminal.sendable
  then access_entry := temp - 1
end (* prompt_access_entry_position *);
!
(*********************  freeword_response_utility  **********************)
(*									*)
(*			    prompt_cud_word				*)
(*									*)
(************************************************************************)

procedure entry prompt_cud_word(
  var scanned	: scanned_command;
  var value	: univ integer);

begin
  input_scanner.input_and_scan_line(NULL_STRING, scanned);
  get_freeword_number(0, 16, MIN_INTEGER, MAX_INTEGER, TRUE, scanned, value)
end (* prompt_cud_word *);
!


(************************  freeword_response_utility  *******************)
(*									*)
(*			  get_freeword_username				*)
(*									*)
(************************************************************************)

procedure get_freeword_username(
      freeword	: command_freeword_index;
      max_entry : integer;
      was_prompted	: boolean (* TRUE if  prompted for freeword *);
			(* FALSE if user entered info on command line *)
  var retries	: integer;
  var scanned	: scanned_command;
  var username	: username_string);

var
  done : boolean;
  this_freeword : command_freeword_index;

begin
  done := FALSE; retries := 0;
  this_freeword := freeword;
  while user_terminal.sendable and not done do
    begin
      if scanned.status = CMD_OK
      then argument_scan.freeword_username(this_freeword, scanned, username);
      if was_prompted
      then argument_scan.extra_argument_check(scanned);
      if (scanned.status = CMD_OK) or (retries = max_entry)
      then done := TRUE
      else
	begin
	  retries := retries + 1;
          if scanned.status <> ARG_FREEWORD_MISSING
      	  then scan_error.display_command_error(scanned);
      	  input_scanner.input_and_scan_line(USERNAME_QUERY, scanned)
	end
    end
end (* get_freeword_username *);



(**********************  freeword_response_utility  *********************)
(*									*)
(*			     prompt_username_count			*)
(*									*)
(*      Ask for and input a legal username.				*)
(*									*)
(************************************************************************)

procedure entry PROMPT_USERNAME_COUNT(
      username_prompt	: quoted_text;
      max_entry 	: integer;
  var retries		: integer;
  var username		: username_string);

var
  scanned : scanned_command;

begin
  input_scanner.input_and_scan_line(username_prompt, scanned);
  get_freeword_username(0, max_entry, TRUE, retries, scanned, username)
end (* prompt_username_count *);



(**********************  freeword_response_utility  *********************)
(*									*)
(*			     prompt_username				*)
(*									*)
(*      Ask for and input a legal username.				*)
(*									*)
(************************************************************************)

procedure entry PROMPT_USERNAME(
      username_prompt	: quoted_text;
  var username		: username_string);

var
  scanned : scanned_command;
  retries : integer;

begin
  input_scanner.input_and_scan_line(username_prompt, scanned);
  get_freeword_username(0, MAX_INTEGER, TRUE, retries, scanned, username)
end (* prompt_username *);



(**********************  freeword_response_utility  *********************)
(*									*)
(*				get_username				*)
(*									*)
(*      Input a legal username; if one is not already on the input	*)
(*	line in scanned, prompt for one.				*)
(*									*)
(************************************************************************)

procedure entry get_username(
      freeword		: command_freeword_index;
  var scanned		: scanned_command;
  var username		: username_string);

var
  retries : integer;

begin
  get_freeword_username(freeword, MAX_INTEGER, FALSE,
    retries, scanned, username)
end (* get_username *);
!
(**********************  freeword_response_utility  *********************)
(*									*)
(*			   get_freeword_listname			*)
(*									*)
(************************************************************************)

procedure get_freeword_listname(
      freeword	: command_freeword_index;
  var scanned	: scanned_command;
  var listname	: named_list_name);

var
  done : boolean;
  this_freeword : command_freeword_index;

begin
  done := FALSE;
  this_freeword := freeword;
  while user_terminal.sendable and not done do
    begin
      if scanned.status = CMD_OK
      then argument_scan.freeword_listname(this_freeword, scanned, listname);
      if scanned.status = CMD_OK
      then done := TRUE
      else
        begin
          if scanned.status <> ARG_FREEWORD_MISSING
	  then scan_error.display_command_error(scanned);
	  input_scanner.input_and_scan_line('listname: \ ', scanned)
        end
    end
end (* get_freeword_listname *);



(*********************  freeword_response_utility  **********************)
(*									*)
(*			     prompt_listname				*)
(*									*)
(************************************************************************)

procedure entry PROMPT_LISTNAME(
      list_prompt	: quoted_text;
  var listname		: named_list_name);

var
  scanned : scanned_command;

begin
  input_scanner.input_and_scan_line(list_prompt, scanned);
  get_freeword_listname(0, scanned, listname)
end (* prompt_listname *);




(***********************  freeword_response_utility  ********************)
(*									*)
(*		              get_listname                              *)
(*									*)
(************************************************************************)

procedure entry GET_LISTNAME(
      freeword	: command_freeword_index;
  var scanned	: scanned_command;
  var listname	: named_list_name);

begin
  get_freeword_listname(freeword, scanned, listname)
end (* get_freeword_listname *);
$if INCLUDE_DNIC
!


(**********************  freeword_response_utility  *********************)
(*									*)
(*			   get_freeword_dnicname			*)
(*									*)
(************************************************************************)

procedure get_freeword_dnicname(
      freeword	: command_freeword_index;
  var scanned	: scanned_command;
  var dnicname	: dnicname_string);

var
  done : boolean;
  this_freeword : command_freeword_index;

begin
  done := FALSE;
  this_freeword := freeword;
  while user_terminal.sendable and not done do
    begin
      if scanned.status = CMD_OK
      then argument_scan.freeword_dnicname(this_freeword, scanned, dnicname);
      if scanned.status = CMD_OK
      then done := TRUE
      else
        begin
          if scanned.status <> ARG_FREEWORD_MISSING
	  then scan_error.display_command_error(scanned);
	  input_scanner.input_and_scan_line('enter dnicname: \ ', scanned)
        end
    end
end (* get_freeword_dnicname *);



(**********************  freeword_response_utility  *********************)
(*									*)
(*			     prompt_dnicname				*)
(*									*)
(*      Ask for and input a legal dnicname.				*)
(*									*)
(************************************************************************)

procedure entry PROMPT_DNICNAME(
      dnicname_prompt	: quoted_text;
  var dnicname		: dnicname_string);

var
  scanned : scanned_command;

begin
  input_scanner.input_and_scan_line(dnicname_prompt, scanned);
  get_freeword_dnicname(0, scanned, dnicname)
end (* prompt_dnicname *);



(**********************  freeword_response_utility  *********************)
(*									*)
(*				get_dnicname				*)
(*									*)
(*      Input a legal dnicname; if one is not already on the input	*)
(*	line in scanned, prompt for one.				*)
(*									*)
(************************************************************************)

procedure entry GET_DNICNAME(
      freeword		: command_freeword_index;
  var scanned		: scanned_command;
  var dnicname		: dnicname_string);

begin
  get_freeword_dnicname(freeword, scanned, dnicname)
end (* get_dnicname *);
$endif INCLUDE_DNIC



(*********************  freeword_response_utility  **********************)
(*									*)
(*			  prompt_time_in_minutes			*)
(*									*)
(************************************************************************)

procedure entry PROMPT_TIME_IN_MINUTES(
      list_prompt	: quoted_text;
  var time		: integer);

var
  scanned : scanned_command;
  done : boolean;

begin
  input_scanner.input_and_scan_line(list_prompt, scanned);
  done := FALSE;
  while user_terminal.sendable and not done do
    begin
      if scanned.status = CMD_OK
      then argument_scan.freeword_time_in_minutes(0, scanned, time);
      if scanned.status = CMD_OK
      then done := TRUE
      else
        begin
          scan_error.display_command_error(scanned);
	  input_scanner.input_and_scan_line('reenter time: \ ', scanned)
        end
    end
end (* prompt_time_in_minutes *);
$ifany (force_password_change, reuse_uuns)



(*******************  freeword_response_utility  ************************)
(*									*)
(*  Name:	fetch_time_in_minutes					*)
(*									*)
(*  Purpose:	return passtable or uun merge time from original	*)
(*		command line, without further prompting.		*)
(*									*)
(************************************************************************)

procedure entry FETCH_TIME_IN_MINUTES(
  var start_time : integer);

var
  scanned 	: scanned_command;
  done 		: boolean;

begin
  done := FALSE;
  while user_terminal.sendable and not done do
    begin (* get time from user *)
      argument_scan.freeword_time_in_minutes(0, scanned, start_time);
      if scanned.status = CMD_OK
      then done := TRUE
      else
        begin (* invalid time entered, try again *)
          scan_error.display_command_error(scanned);
          input_scanner.input_and_scan_line('reenter time: \ ', scanned)
        end (* invalid time entered, try again *)
    end (* get time from user *)
end (* fetch_time_in_minutes *);
$endif (force_password_change, reuse_uuns)
$endif disk_maintenance_code
$if prevent_duplicate_passwords



(*********************  freeword_response_utility  **********************)
(*									*)
(*			   prompt_passperiod				*)
(*									*)
(************************************************************************)

procedure entry PROMPT_PASSPERIOD(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if password_expiration_by_user         standard_validity	: integer;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  var scanned		: scanned_command;
  var time_in_days	: integer);

var
  maximum_value : integer;

begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if password_expiration_by_user
  if standard_validity < MAX_PASSWORD_CHANGE_PERIOD
  then maximum_value := standard_validity - 1
  else
$endif password_expiration_by_user
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  maximum_value := MAX_PASSWORD_CHANGE_PERIOD;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if password_expiration_by_user
  if standard_validity = 0
  then
    begin
      format.start_message('validity must be set before passperiod is set\');
      format.write_line(user_terminal)
    end
  else
$endif password_expiration_by_user
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  if scanned.freeword_count = 0
  then
    begin
      input_scanner.input_and_scan_line(
	'enter minimum password change time period, in days: \ ', scanned);
      get_freeword_number(0, 10, MIN_PASSWORD_CHANGE_PERIOD, maximum_value,
	TRUE, scanned, time_in_days)
    end
  else get_freeword_number(0, 10, MIN_PASSWORD_CHANGE_PERIOD, maximum_value,
    FALSE, scanned, time_in_days)
end (* prompt_passperiod *);
$endif prevent_duplicate_passwords
$if allow_temporary_apes



(*********************  freeword_response_utility  **********************)
(*									*)
(*			get_date_and_time				*)
(*									*)
(*									*)
(************************************************************************)

procedure get_date_and_time(
  var scanned		: scanned_command;
  var date_and_time	: integer);

var
  done : boolean;

begin
  done := FALSE;
  while user_terminal.sendable and not done do
    if scanned.status = NO_CMD
    then
      begin
	scanned.status := CMD_OK; done := TRUE;
	date_and_time := 0
      end
    else
      begin
	if scanned.status = CMD_OK
	then
	  begin
	    argument_scan.freeword_date_and_time(0, MAX_INTEGER, scanned,
	      date_and_time);
	    if date_and_time < REALTIME
	    then scanned.status := ARG_ERROR
	  end (* CMD_OK *);
	if scanned.status = CMD_OK
	then done := TRUE
	else
	  begin
	    scan_error.display_command_error(scanned);
	    input_scanner.input_and_scan_line('reenter date: \ ', scanned)
	  end
      end (* scanned.status <> NO_CMD *)
end (* get_date_and_time *);



(*********************  freeword_response_utility  **********************)
(*									*)
(*			prompt_for_ape_expiration			*)
(*									*)
(************************************************************************)

procedure entry PROMPT_FOR_APE_EXPIRATION(
  var scanned		: scanned_command;
  var date_and_time	: integer);

begin
  input_scanner.input_and_scan_line(
    'enter expiration date and time (cr if none): \', scanned);
  get_date_and_time(scanned, date_and_time)
end (* prompt_for_ape_expiration *);
$endif allow_temporary_apes
$if disk_maintenance_code
$if password_expiration_by_user



(***********************  freeword_response_utility  ********************)
(*									*)
(*			    get_array_of_ranges				*)
(*									*)
(************************************************************************)

procedure entry GET_ARRAY_OF_RANGES(
      base	: integer;
      min_value	: integer;
      max_value	: integer;
  var scanned	: scanned_command;
  var ranges	: array_of_ranges);

var
  freeword : command_freeword_index;
  index : array_of_ranges_index;

begin
  freeword := 0; ranges.size := 0; index := 0;
  if scanned.freeword_count > MAXIMUM_ARRAY_OF_RANGES
  then
    begin
      scanned.status := TOO_MANY_ARGS;
      format.start_line_message('there may be a maximum of \ ');
      format.number(MAXIMUM_ARRAY_OF_RANGES, 10);
      format.string(' ranges entered\');
      format.write_line(user_terminal)
    end;
  while user_terminal.sendable and (scanned.status = CMD_OK) and
    (freeword < scanned.freeword_count) do
    begin
      argument_scan.freeword_range(freeword, min_value, max_value, base,
	  scanned, ranges.list[index]);
      if scanned.status = CMD_OK
      then
	begin
	  ranges.size := ranges.size + 1;
	  freeword := freeword + 1 (* proceed to next freeword *);
	  if freeword <> scanned.freeword_count
	  then index := index + 1 (* increment numbers index *)
	end (* scanned.status = CMD_OK *)
    end (* while *)
end (* get_array_of_ranges *);
$endif password_expiration_by_user
$endif disk_maintenance_code



(***********************  freeword_response_utility  ********************)
(*									*)
(*			  get_numeric_freeword_value			*)
(*									*)
(************************************************************************)

procedure entry GET_NUMERIC_FREEWORD_VALUE(
      freeword	: command_freeword_index;
      base	: integer;
      min_value	: integer;
      max_value	: integer;
  var scanned	: scanned_command;
  var number	: integer);

begin
  input_number(freeword, base, min_value, max_value, scanned, number);
  if scanned.status <> CMD_OK
  then scanned.status := RUN_ERROR
end (* get_numeric_freeword_value *);



(************************************************************************)
(************************************************************************)

begin (* initial statement *)
end (* freeword_response_utility *);
!
(************************************************************************)
(*									*)
(*	KEYSCN.NTV							*)
(*									*)
(*			keyword scanner class				*)
(*									*)
(*	This class resides within any process wishing to process	*)
(*	keywords.							*)
(*									*)
(*	The following identifiers must be defined externally:		*)
(*	  command_scanned, command_definition,				*)
(*	  keyword_definition, context_set, ascii_space,			*) 
(*	  max_key_value_size						*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	03Apr84	Version 2.02 0- jrn					*)
(*	      - append "? " to questions here				*)
(*	29SEP83  original from (patrol)cmdscn.bas - jnm			*)
(*									*)
(************************************************************************)

type KEYWORD_SCANNER = class(
	user_terminal	: circuit_handler;
	input_scanner	: terminal_input_scanner);

!



(***************************  keyword_scanner  **************************)
(*									*)
(*			    input_answer				*)
(*									*)
(*      Routine to output the supplied prompt, input a line		*)
(*	(scanned.input_line) and return TRUE if a yes was entered.	*)
(*									*)
(************************************************************************)

function entry INPUT_ANSWER(
      line_prompt	: quoted_text) : boolean;

var
  keyword : line_keyword_index;

begin
  user_terminal.write_quoted_text(line_prompt);
  user_terminal.write_quoted_text('? \ ');
  input_scanner.input_and_scan_keyword([LINE_YES_KEYWORD, LINE_NO_KEYWORD],
    keyword);
  if user_terminal.sendable
  then input_answer := keyword = LINE_YES_KEYWORD
  else input_answer := FALSE
end (* input_answer *) ;



(************************************************************************)
(************************************************************************)

begin
end (* keyword_scanner *) ;
!
(************************************************************************)
(*									*)
(*	GLBCMD.NTV							*)
(*									*)
(*				global_commands 			*)
(*									*)
(*	This class contains the global commands which should be 	*)
(*	accessable from all contexts.					*)
(*									*)
(*	The routines are organized as follows:				*)
(*		HELP Command						*)
(*		MESSAGE Command						*)
(*		General scan_command					*)
(*									*)
(*	The following identifiers must be defined externally:		*)
(*	  operator_log							*)
(*	  argument_scanner, scanned_command				*)
(*	  terminal_input_scanner, operator_messages			*)
(*	  log_message, oper_log_page_index				*)
(*									*)
(************************************************************************)
(*									*)
(*			     Revision Record				*)
(*									*)
(*	04Jan88 - neh							*)
(*	      - change version command to outpu NVDM or NETVAL and	*)
(*		mud version.						*)
(*	23Oct87 - version 5.00 neh					*)
(*	      - change GMT to UTC					*)
(*	03Sep86 - neh							*) 
(*	      - Move PRINT_LOG_MESSAGE and SCAN_MESSAGE_COMMAND		*)
(*		to command_level_utility.				*)
(*	      - Remove GLOBAL_MESSAGE in scan_command.			*)
(*            - Remove the parameter for operator_log.                  *)
(*	31Jul86 - jrn							*)
(*	      - add MESSAGES FROM command to NVDM			*)
(*	24JAN86 - jrn							*)
(*	      - use format COMMAND_STRING and KEYWORD_STRING routines	*)
(*	      - change processing of HELP command to accomodate the	*)
(*		removal of command and keyword sizes			*)
(*	29Jul85 - jrn							*)
(*	      - move find_timed_message from oplog; add <break>		*)
(*		handling; change search to handle bigger files		*)
(*	21Jun84 - jrn							*)
(*	      - add disk_maintenenace_code				*)
(*	14Apr84 Version 2.02	jrn					*)
(*	      - added licenses						*)
(*	29SEP83 original - from (patrol)glbcmd.bas - jrn		*)
(*									*)
(************************************************************************)


type GLOBAL_COMMANDS = class(
      validator		: licensed_validator_index;
      profile		: validator_profile;
      statistics	: statistics_gatherer;
      user_terminal	: circuit_handler;
      argument_scan	: argument_scanner;
      format		: internal_to_string;
      input_scanner	: terminal_input_scanner;
      scan_error	: command_error_message;
      commands		: command_table);


const
  HELP_COLUMN_START = KEYWORD_NAME_MAX + 1;
!
"
		HELP command
"


(**************************  global_commands  ***************************)
(*									*)
(*		              help_command	           		*)
(*									*)
(************************************************************************)

procedure help_command(
      context	: context_set;
  var scanned	: scanned_command);

var
  done : boolean;
  header : command_definition;
  subcommands_done : boolean;
  keyword : command_keyword_index;
  keyword_entry : keyword_definition;

begin
  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    begin
      commands.start_help(validator, context);
      repeat
	user_terminal.write_newline;
        commands.next_help_command_info(profile, context, done, header);
	if not done
	then
	  begin
	    format.start;
	    format.command_string(header.name);
	    format.skip_to(HELP_COLUMN_START);
	    format.help_text_string(header.explanation);
	    format.write_line(user_terminal);
	    if header.subcommand_count > 0
	    then
	      begin (* output all appropriate subcommands *)
	        subcommands_done := FALSE; keyword := 0;
	        repeat
	          commands.get_keyword(header.keyword_offset, keyword,
		    keyword_entry);
	          if profile.access_to_command(keyword_entry.required_license)
	          then
	            begin
		      format.start_message(' \') (* output subcommand line *);
		      format.keyword_string(keyword_entry.name);
		      format.skip_to(HELP_COLUMN_START);
		      format.help_text_string(keyword_entry.explanation);
		      format.write_line(user_terminal)
	            end;
	          if keyword = header.subcommand_count - 1
	          then subcommands_done := TRUE
	          else keyword := keyword + 1
	        until subcommands_done or not user_terminal.sendable
	      end
	  end
      until done or not user_terminal.sendable;
      user_terminal.write_newline
    end
end (* help_command *);
!


(**************************  global_commands  ***************************)
(*									*)
(*			      scan_command	 			*)
(*									*)
(*	Parse and execute the global command just entered.		*)
(*									*)
(************************************************************************)


procedure entry SCAN_COMMAND(
      context	: context_set;
  var scanned	: scanned_command);

begin
  case scanned.command of

    GLOBAL_DATE:
      begin
	format.start;
	format.time(realtime);
	format.string('  UTC\');
	format.write_line(user_terminal)
      end (* global_date *);

    GLOBAL_HELP: help_command(context, scanned);

    GLOBAL_VERSION:
      begin
	format.start;
$if disk_maintenance_code        format.string('NVDM \');
$ifnone disk_maintenance_code        format.string('Netval \');
	format.scaled_number(version*100+revision, 10, 2);
	format.string(', MUD\');
$if BEFORE_SUP_V43        format.string(' I\ ');
$ifnone BEFORE_SUP_V43
        format.string(' II, sup version \');
	format.scaled_number(mud_sup_version*10, 10, 2);
$endif BEFORE_SUP_V43
	format.write_line(user_terminal)
      end (* global_version *);

      GLOBAL_STATISTICS: statistics.print_statistics(format, user_terminal)

  end (* case *);

  scan_error.display_command_error(scanned)

end (* scan_command *);

(************************************************************************)
(************************************************************************)

begin (* initial statement *)
end (* global_command *);
!
(************************************************************************)
(*									*)
(*	CMDLP.NTV							*)
(*									*)
(*				command_loop				*)
(*									*)
(*	This class contains the command loop for all command input.	*)
(*	It is called to request a command in the context which it	*)
(*	maintains. It handles all global command processing,		*)
(*	i.e., commands to be recognized in all contexts which do not	*)
(*	do a context switch. It returns when either it scans a		*)
(*	command not in the global context or when the circuit is	*)
(*	lost. The caller must be able to handle any command returned.	*)
(*	This is accomplished by manipulating the context.		*)
(*									*)
(*	The following identifiers must be defined externally:		*)
(*	  validator_index, command_table				*)
(*	  scanned_command						*)
(*	  terminal_input_scanner					*)
(*									*)
(************************************************************************)
(*									*)
(*	                     Revision Record                            *)
(*									*)
(*	31Jul86 - jrn							*)
(*	      - add MESSAGES FROM command to NVDM			*)
(*	29SEP83	Original from (patrol)cmdlp.bas - jrn			*)
(*									*)
(************************************************************************)


type COMMAND_LOOP = class(
      validator  	: validator_index;
      profile		: validator_profile;
      statistics	: statistics_gatherer;
      user_terminal	: circuit_handler;
      argument_scan	: argument_scanner;
      format		: internal_to_string;
      input_scanner	: terminal_input_scanner;
      scan_error	: command_error_message;
      commands		: command_table);

var
  global  : global_commands;

  entry context : context_set (* validator's current context set *);
!
(***************************  command_loop  *****************************)
(*									*)
(*			      	add_class				*)
(*									*)
(*	Add a command class to the 'context' used to determine which	*)
(*	commands are recognized by the command scanned.			*)
(*									*)
(************************************************************************)

procedure entry ADD_CLASS(
      command_class	: command_class_index);

begin
  context := context or [command_class]
end (* add_class *);



(***************************  command_loop  *****************************)
(*									*)
(*			       remove_class				*)
(*									*)
(*	Remove a command class from the 'context' used to determine	*)
(*	which commands are recognized by the command scanned.		*)
(*									*)
(************************************************************************)

procedure entry REMOVE_CLASS(
      command_class	: command_class_index);

begin
  context := context - [command_class]
end (* remove_class *);



(***************************  command_loop  *****************************)
(*									*)
(*			      get_command				*)
(*									*)
(*	This is where all commands are read. It calls input_scanner	*)
(*	to retrieve a command line that has been input and parsed,	*)
(*	filters out global command and only returns with a well		*)
(*	scanned non global command from the current context, or when	*)
(*	the user terminal is lost.					*)
(*									*)
(************************************************************************)

procedure entry GET_COMMAND(
  var scanned	: scanned_command);

var
  found : boolean (* TRUE if non global command found *);

begin
  repeat
    found := FALSE;
    input_scanner.input_and_scan_command(context, scanned);
    if user_terminal.available
    then
      begin
        if scanned.status <> CMD_OK
	then scan_error.display_command_error(scanned)
	else
	  if scanned.command_class = GLOBAL_CLASS
	  then global.scan_command(context, scanned)
	  else found := TRUE
      end (* if available then *)
  until found or not user_terminal.available
end (* get_command *);


(*****************************  command_loop  ***************************)
(************************************************************************)

begin (* initial statement *)
  init global(validator, profile, statistics, user_terminal, argument_scan,
    format, input_scanner, scan_error, commands);

  context := [GLOBAL_CLASS]
end (* command_loop *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if logical_volumes
!
(************************************************************************)
(*									*)
(*	LVSTAT.NTV							*)
(*									*)
(*			lvol_status_manager				*)
(*									*)
(*	This monitor maintains information about logical volumes.	*)
(*	It is called by various processes to retrive information	*)
(*	about the current status of logical volumes.			*)
(*	It is called by:						*)
(*	      - lvol_time_stamp Process to update the disk time stamp	*)
(*	      - lvol_disk_maintenance to update the current state	*)
(*		of all units						*)
(*	      - lvol_reporter process to report changes to the		*)
(*		Supervisor errlog and the the operator log		*)
(*	It also keeps track of whether or not there is a logical volume	*)
(*	copy in progress.						*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*		Original - pgl						*)
(*									*)
(************************************************************************)


type lvol_status_manager = monitor(
	statistics	: statistics_gatherer);



type
  logical_volume_status = record
    state	: lvol_states	(* initted to INCARNATION_UNKNOWN *);
    next_msg	: integer	(* time to next send message *);
    msg_waiting	: boolean	(* initted to FALSE *)
  end (* logical_volume_status *);


var
(* system types *)
  crash_util	: crash_utility;
  dsksys	: disk_system;
  lv_utility	: lvol_utility;
  sys_io	: system_handler;
  config_utility: configuration_utility;

(* permanent variables *)

(* since information is returned by lvol_disk_unit_index, an array is 	*)
(* maintained for each unit; however, information is usually returned	*)
(* according to incarnation, or physical drive.				*)

  CURRENT_STATUS : array [lvol_disk_unit_index] of logical_volume_status;


(* lvol_reporter process is delayed here *)

  WAITING_FOR_MESSAGE : queue;


(* Initialized to TRUE; if a copy is not initiated by the main process,	*)
(* (coming up with one drive), it is set to FALSE.  Otherwise, the	*)
(* lvol_copy class sets it to TRUE when a copy operation begins and	*)
(* sets it to to FALSE when the copy is complete or fails.		*)

  COPY_IN_PROGRESS : boolean;


(* Delay lvol_time_stamp Process here during a copy *)

  TIME_STAMP_QUEUE : queue;


(* Delay lvol_disk_maintenance Process here during a copy *)

  DISK_MAINTENANCE_QUEUE : queue;
!


(************************  lvol_status_manager  *************************)
(*									*)
(*			        initialize				*)
(*									*)
(************************************************************************)

procedure initialize;

var
  unit	: lvol_disk_unit_index;

begin
  for unit := 0 to LVOL_DISK_UNIT_LIMIT do
    begin
      current_status[unit].state := INCARNATION_UNKNOWN;
      current_status[unit].msg_waiting := FALSE;
      current_status[unit].next_msg := 0
    end (* for *);
  copy_in_progress := TRUE
end (* initialize *);



(************************  lvol_status_manager  *************************)
(*									*)
(*			     down_or_offline				*)
(*									*)
(************************************************************************)

function DOWN_OR_OFFLINE(
      state	: lvol_states)	: boolean;

begin
  down_or_offline :=
    (state = INCARNATION_DOWN) or (state = INCARNATION_OFFLINE)
end (* down_or_offline *);



(************************  lvol_status_manager  *************************)
(*									*)
(*			      last_state				*)
(*									*)
(*      Returns with state of specified incarnation_index.		*)
(*									*)
(************************************************************************)

function entry LAST_STATE(
      incarnation	: incarnation_index) : lvol_states;

begin
  last_state :=
    current_status[lv_utility.first_incarnation_disk_unit(incarnation)].state
end (* last_state *);



(************************  lvol_status_manager  *************************)
(*									*)
(*				copy_ended				*)
(*									*)
(************************************************************************)

procedure entry COPY_ENDED;

begin
  copy_in_progress := FALSE;
  continue(time_stamp_queue)
end (* copy_ended *);



(************************  lvol_status_manager  *************************)
(*									*)
(*			       copy_locked				*)
(*									*)
(*	Return current state of copy.					*)
(*									*)
(************************************************************************)

function entry COPY_LOCKED : boolean;

begin
  copy_locked := copy_in_progress
end (* copy_locked *);



(************************  lvol_status_manager  *************************)
(*									*)
(*			       lock_for_copy				*)
(*									*)
(*      If copy_in_progress is TRUE, return FALSE to indicate that a	*)
(*	copy is already going; otherwise set copy_in_progress to TRUE	*)
(*	and return TRUE.						*)
(*									*)
(************************************************************************)

function entry LOCK_FOR_COPY : boolean;

begin
  if copy_in_progress
  then lock_for_copy := FALSE
  else
    begin
      lock_for_copy := TRUE;
      copy_in_progress := TRUE
    end
end (* lock_for_copy *);



(************************  lvol_status_manager  *************************)
(*									*)
(*			  either_down_or_offline			*)
(*									*)
(*	Return TRUE if any unit is DOWN or OFFLINE.			*)
(*									*)
(************************************************************************)

function entry EITHER_DOWN_OR_OFFLINE : boolean;

begin
  either_down_or_offline :=
    down_or_offline(current_status[0].state) or
    down_or_offline(current_status[1].state) or
    down_or_offline(current_status[2].state) or
    down_or_offline(current_status[3].state)
end (* either_down_or_offline *);



(************************  lvol_status_manager  *************************)
(*									*)
(*			  disk_down_or_offline				*)
(*									*)
(************************************************************************)

function entry DISK_DOWN_OR_OFFLINE(
      state	: lvol_states) : boolean;

begin
  disk_down_or_offline := down_or_offline(state)
end (* disk_down_or_offline *);



(************************  lvol_status_manager  *************************)
(*									*)
(*			     get_lvol_message				*)
(*									*)
(*      Called by lvol_reporter process. If there are no messages, the  *)
(*	process is delayed; else returns with incarnation_index of the	*)
(*	drive to be reported.						*)
(*									*)
(************************************************************************)

procedure entry GET_LVOL_MESSAGE(
  var incarnation	: incarnation_index);

var
  done,
  found : boolean;
  unit : lvol_disk_unit_index;

begin
  done := FALSE;
  repeat
    found := FALSE;
    unit := 0;
    repeat
      if current_status[unit].msg_waiting
      then
        begin (* found a message, return the incarnation for the unit *)
	  done := TRUE; found := TRUE;
	  incarnation := lv_utility.this_incarnation(unit);
	  current_status[unit].msg_waiting := FALSE;
	  current_status[lv_utility.unit_partner(unit)].msg_waiting := FALSE
	end
      else (* no message for this unit *)
        if unit = LVOL_DISK_UNIT_LIMIT
	then done := TRUE
	else unit := unit + 1
    until done;
    if not found
    then
      begin (* checked all units, did not find any messages *)
        delay(waiting_for_message) (* wait until one comes in *);
	done := FALSE (* a message just arrived, go find it *)
      end
  until done and found
end (* get_lvol_message *);



(************************  lvol_status_manager  *************************)
(*									*)
(*			    record_time_stamp 				*)
(*									*)
(*	Called periodically by lvol_time_stamp Process.  Record a time	*)
(*	stamp on the disk(s) if a copy is NOT in progress.		*)
(*									*)
(************************************************************************)

procedure entry RECORD_TIME_STAMP;

var
  status : file_utility_status;
  ok : boolean;
  configuration : configuration_information;

begin
  if copy_in_progress
  then delay(time_stamp_queue);

(* record time stamp to any writable incarnation(s) *)
  config_utility.read_file(configuration, status);
  if status = FU_SUCCESS
  then
    begin
      configuration.last_pvol_time_stamp := REALTIME;
      config_utility.write_file(configuration, ok)
    end (* status = FU_SUCCESS *)
  else crash_util.halt_slot (* cannot read config file! *);

  continue(disk_maintenance_queue)
end (* record_time_stamp *);



(************************  lvol_status_manager  *************************)
(*									*)
(*			    update_last_status 				*)
(*									*)
(*	Called periodically by lvol_disk_maintenance Process.		*)
(*	Update current_status with new_info; if necessary,		*)
(*	continue lvol_reporter.						*)
(*									*)
(************************************************************************)

procedure entry UPDATE_LAST_STATUS(
      new_info	: lvol_info_buffer);

var
  unit : lvol_disk_unit_index;
  continue_reporter : boolean;
  this_time : integer;

begin
  if copy_in_progress
  then delay(disk_maintenance_queue);

(* check for changes in state of any incarnation *)
  this_time := REALTIME; continue_reporter := FALSE;
  for unit := 0 to LVOL_DISK_UNIT_LIMIT do
    begin
      if not down_or_offline(new_info[unit].disk_states)
      then current_status[unit].next_msg := 0
      else
        begin (* unit is now either down or offline *)
	  if new_info[unit].disk_states = current_status[unit].state
	  then
	    begin (* new state and old state are the same *)
	      if this_time > current_status[unit].next_msg
	      then
	        begin (* time to report that drive is down again *)
		  current_status[unit].next_msg :=
		    this_time + LVOL_REPORT_INTERVAL;
		  current_status[unit].msg_waiting := TRUE;	  
(* set partner so only one message appears *)
		  current_status[lv_utility.unit_partner(unit)].next_msg :=
		    current_status[unit].next_msg;
		  continue_reporter := TRUE
		end (* time to report that drive is down again  *)
	    end (* new state and old state are the same *)
	  else
	    begin (* new, old state are different; new is down or offl *)
(* if old state was read/write, set other unit for same incarnation *)
(* to the same new state; this is done to keep both units in an	    *)
(* incarnation in the same state, for the case where the Nucleus    *)
(* takes a unit out of read/write				    *)
	      if current_status[unit].state = INCARNATION_READ_WRITE
	      then lv_utility.set_state(lv_utility.this_incarnation(unit),
	        SET_LVOL_UNAVAILABLE);
	      current_status[unit].next_msg := this_time+LVOL_REPORT_INTERVAL;
	      current_status[unit].msg_waiting := TRUE;
(* set partner so only one message appears *)
	      current_status[lv_utility.unit_partner(unit)].next_msg :=
	        current_status[unit].next_msg;
	      continue_reporter := TRUE
	    end (* new, old state are different; new is down or offline *)
	end (* unit is now either down or offline *);
      current_status[unit].state:=new_info[unit].disk_states (* save new *)
    end (* for *);

  if continue_reporter
  then continue(waiting_for_message)
end (* update_last_status *);



(************************  lvol_status_manager  *************************)
(*									*)
(*			    set_initial_status 				*)
(*									*)
(*	Called by initial process before copy starts.			*)
(*									*)
(************************************************************************)

procedure entry SET_INITIAL_STATUS;

var
  info_buffer : lvol_info_buffer;
  unit : lvol_disk_unit_index;

begin
  lv_utility.lvol_information(info_buffer);
  for unit := 0 to LVOL_DISK_UNIT_LIMIT do
    current_status[unit].state := info_buffer[unit].disk_states
end (* set_initial_status *);



(************************************************************************)
(************************************************************************)

begin (* initial statement *)
  init crash_util, dsksys(statistics), sys_io, lv_utility,
    config_utility(dsksys, sys_io);
  initialize
end (* lvol_status_manager *);
$endif (* logical_volumes *)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if logical_volumes
!
(************************************************************************)
(*									*)
(*	LVDLG.NTV							*)
(*									*)
(*			    lvol_dialogue				*)
(*									*)
(*	This class performs the interactive portion of the copy		*)
(*	operation and displays logical volume information.		*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	15Aug87 - neh version 5.00					*)
(*	      - change TYMSHARE_CUD_FORMAT to CHAECK_TIME_STATUS	*)
(*		Original - pgl						*)
(*									*)
(************************************************************************)

type lvol_dialogue = class(
	user_terminal	: circuit_handler;
	keyword_scan	: keyword_scanner;
	format		: internal_to_string;
	dsksys		: disk_system;
	sys_io		: system_handler;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code 	lv_dir	: logical_volume_directory;
$ifnone disk_maintenance_code 	status_manager	: lvol_status_manager;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	lv_utility	: lvol_utility;
	config_utility	: configuration_utility);


var
  crash_util : crash_utility;
!
(***************************  lvol_dialogue  ****************************)
(*									*)
(*			     make_lvol_display				*)
(*									*)
(*      Displays current lvol information.				*)
(*									*)
(************************************************************************)

procedure make_lvol_display(
      lvol_state	: lvol_disk_state);

var
  incarnation : incarnation_index;

begin
  for incarnation := 0 to INCARNATION_LIMIT do
    begin
      format.string(DRIVE_MESSAGE);
      format.number(incarnation, 10);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code
      format.string('   legal: \ ');
      if lvol_state[incarnation].legal_disk
      then
        begin
	  format.string(YES_MESSAGE);
	  format.skip(3)
	end
      else
        begin
	  format.string(NO_MESSAGE);
	  format.skip(4);
	end;
      format.string('state: \');
      format.lvol_state(status_manager.last_state(incarnation));
$endif disk_maintenance_code
$if disk_maintenance_code
      format.string('  in use: \ ');
      if lv_utility.this_incarnation(lv_dir.cud_unit) = incarnation
      then
        begin
	  format.string(YES_MESSAGE);
	  format.skip(3)
	end
      else
        begin
	  format.string(NO_MESSAGE);
	  format.skip(4)
	end;
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      format.string('time stamp: \ ');
      if lvol_state[incarnation].legal_disk
      then format.no_sec_time(lvol_state[incarnation].time_stamp)
      else format.string(UNKNOWN_MESSAGE);
      format.newline
    end (* for *)
end (* make_lvol_display *);



(***************************  lvol_dialogue  ****************************)
(*									*)
(*				display_lvol				*)
(*									*)
(************************************************************************)

procedure entry DISPLAY_LVOL;

var
  configuration : configuration_information;
  lvol_state : lvol_disk_state;

begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code
  config_utility.check_lvol_configuration(configuration, lvol_state);
$endif disk_maintenance_code
$if disk_maintenance_code
  config_utility.get_lvol_configuration(configuration, lvol_state);
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  format.start;
  make_lvol_display(lvol_state);
  format.write_block(user_terminal)
end (* display_lvol *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code



(***************************  lvol_dialogue  ****************************)
(*									*)
(*			      get_lvol_info				*)
(*									*)
(************************************************************************)

procedure entry GET_LVOL_INFO;

var
  configuration : configuration_information;
  lvol_state : lvol_disk_state;

begin
  config_utility.check_lvol_configuration(configuration, lvol_state);
  format.start;
  make_lvol_display(lvol_state)
end (* get_lvol_info *);



(***************************  lvol_dialogue  ****************************)
(*									*)
(*		         get_and_display_lvol_age			*)
(*									*)
(************************************************************************)

procedure get_and_display_lvol_age(
      time_stamp	: integer;
  var lvol_age		: logical_volume_age);

var
  incarnation_age : integer;

begin
  format.start_message('the source Netval disk is \ ');
  incarnation_age := REALTIME - time_stamp;
  lvol_age.hours := incarnation_age div SECONDS_PER_HOUR;
  lvol_age.scaled_minutes :=
    ((incarnation_age mod SECONDS_PER_HOUR) * 100) div 60;
  format.lvol_age(lvol_age);
  format.write_line(user_terminal)
end (* get_and_display_lvol_age *);



(***************************  lvol_dialogue  ****************************)
(*									*)
(*		            copy_confirmaation				*)
(*									*)
(*      Displays logical volume information and the direction of the	*)
(*	copy; requests confirmation of the copy.			*)
(*									*)
(************************************************************************)

procedure copy_confirmation(
      lvol_initted	: boolean (* TRUE if logical volumes are up *);
      lvol_state	: lvol_disk_state (* current state of lvols *);
  var to_incarnation	: incarnation_index;
  var from_incarnation	: incarnation_index;
  var lvol_age		: logical_volume_age (* age of source drive *);
  var proceed_with_copy	: boolean (* TRUE if copy should take place *));

begin
  if lvol_initted
  then
    begin
      if status_manager.last_state(0) = INCARNATION_READ_WRITE
      then to_incarnation := 1
      else to_incarnation := 0
    end
  else
    if (lvol_state[0].legal_disk and lvol_state[1].legal_disk and
      (lvol_state[0].time_stamp < lvol_state[1].time_stamp)) or 
      (not lvol_state[0].legal_disk and lvol_state[1].legal_disk)
    then to_incarnation := 0
    else to_incarnation := 1;
  from_incarnation := lv_utility.lvol_partner(to_incarnation);
  format.start_line_message('the direction of the copy will be from drive \');
  format.number(from_incarnation, 10);
  format.string(' to drive \ ');
  format.number(to_incarnation, 10);
  format.write_line(user_terminal);
  get_and_display_lvol_age(lvol_state[from_incarnation].time_stamp, lvol_age);

  if keyword_scan.input_answer(CONTINUE_MESSAGE)
  then
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone CHECK_TIME_STATUS     proceed_with_copy := TRUE (* answer = "Yes" *)
$if CHECK_TIME_STATUS
      if lvol_age.hours > 0
      then
        begin (* ask operator to confirm FROM disk *)
	  user_terminal.write_line_and_quoted_text_line(WARNING_MESSAGE);
	  user_terminal.write_line_and_quoted_text_line(CONFIRM_MESSAGE);
	  user_terminal.write_newline;
	  get_and_display_lvol_age(lvol_state[from_incarnation].time_stamp,
	    lvol_age);
	  proceed_with_copy := keyword_scan.input_answer(CONTINUE_MESSAGE)
	end (* ask operator to confirm FROM disk *)
      else proceed_with_copy := TRUE (* answer = "Yes" *)
$endif CHECK_TIME_STATUS
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  else (* answer was "No" or <break>; proceed_with_copy remains FALSE *)
    if user_terminal.available and not lvol_initted
    then
      begin (* Netval just came up, force user to acknowledge that *)
	    (* system is coming up with one disk *)
	if user_terminal.break_pending (* clear to continue communication *)
	then user_terminal.clear_break_status;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if CHECK_TIME_STATUS
     if lvol_age.hours > 0
      then
        begin (* warn operator about age of disk *)
	  user_terminal.write_line_and_quoted_text_line(WARNING_MESSAGE);
	  get_and_display_lvol_age(lvol_state[from_incarnation].time_stamp,
	    lvol_age)
	end (* ask operator to confirm FROM disk *);
$endif CHECK_TIME_STATUS
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	user_terminal.write_line_and_quoted_text_line(
'If it is necessary to bring the system up with a single disk,\');
        user_terminal.write_quoted_text_line('press the escape key.\');
	user_terminal.write_line_and_quoted_text_line(
'THIS IS ONLY A CORRECT PROCEDURE IF ONE DRIVE IS UNUSABLE.\ ');
	user_terminal.write_line_and_quoted_text('Else, \ ');
	user_terminal.write_quoted_text_line(
'press carriage return when you are ready to have the disks reevaluated.\');
	user_terminal.wait_for_input
      end (* Netval just came up, ... *)
end (* copy_confirmation *);



(***************************  lvol_dialogue  ****************************)
(*									*)
(*			     get_confirmation				*)
(*									*)
(*      Called from command_level and initial process. Returns with	*)
(*	proceed_with_copy = TRUE, if operator gives confirmation.	*)
(*									*)
(************************************************************************)

procedure entry GET_CONFIRMATION(
	(* FALSE if called from initial process since Netval just came up *)
	(* TRUE if called from COPY command *)
      lvol_initted	: boolean;
  var to_incarnation	: incarnation_index;
  var from_incarnation	: incarnation_index;
  var lvol_age		: logical_volume_age (* age of source drive *);
  var proceed_with_copy	: boolean);

var
  configuration : configuration_information;
  lvol_state	: lvol_disk_state;
  save_timeout 	: integer;

begin
  proceed_with_copy := FALSE;
  save_timeout := user_terminal.current_timeout;
  if not lvol_initted (* do not timeout user if initting system *)
  then user_terminal.set_timeout(0);
  repeat
    config_utility.check_lvol_configuration(configuration, lvol_state);
    format.start;
    make_lvol_display(lvol_state);
    format.write_block(user_terminal);
    copy_confirmation(lvol_initted, lvol_state, to_incarnation,
      from_incarnation, lvol_age, proceed_with_copy)
  until lvol_initted or proceed_with_copy or not user_terminal.sendable;

  if user_terminal.break_pending and not lvol_initted
  then user_terminal.clear_break_status;
  user_terminal.set_timeout(save_timeout);
  if proceed_with_copy
  then
    if lvol_initted
    then lv_utility.set_state(to_incarnation, SET_LVOL_WRITE_ONLY)
    else lv_utility.initialize(to_incarnation, SET_LVOL_WRITE_ONLY)
  else
    if not lvol_initted and user_terminal.available
    then (* come up with one disk...set other to unavailable *)
      if not lvol_initted
      then lv_utility.initialize(to_incarnation, SET_LVOL_UNAVAILABLE)
end (* get_confirmation *);
$endif disk_maintenance_code
$if disk_maintenance_code



(***************************  lvol_dialogue  ****************************)
(*									*)
(*		            copy_confirmaation				*)
(*									*)
(*      Displays logical volume information and the direction of the	*)
(*	copy; requests confirmation of the copy.			*)
(*									*)
(************************************************************************)

procedure copy_confirmation(
      to_incarnation	: incarnation_index;
      from_incarnation	: incarnation_index;
  var proceed_with_copy	: boolean (* TRUE if copy should take place *));

begin
  format.start_line_message('the direction of the copy will be from drive \');
  format.number(from_incarnation, 10);
  format.string(' to drive \ ');
  format.number(to_incarnation, 10);
  format.write_line(user_terminal);

  proceed_with_copy := keyword_scan.input_answer(CONTINUE_MESSAGE)
end (* copy_confirmation *);



(***************************  lvol_dialogue  ****************************)
(*									*)
(*			     get_confirmation				*)
(*									*)
(*      Called from COPY command. Returns with proceed_with_copy = TRUE,*)
(*	if operator gives confirmation.					*)
(*									*)
(************************************************************************)

procedure entry GET_CONFIRMATION(
      to_incarnation	: incarnation_index;
      from_incarnation	: incarnation_index;
  var proceed_with_copy	: boolean);

var
  configuration : configuration_information;
  lvol_state	: lvol_disk_state;

begin
  config_utility.get_lvol_configuration(configuration, lvol_state);
  format.start;
  make_lvol_display(lvol_state);
  format.write_block(user_terminal);
  proceed_with_copy := FALSE;
  format.start;
  format.write_block(user_terminal);
  copy_confirmation(to_incarnation, from_incarnation, proceed_with_copy)
end (* get_confirmation *);
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(************************************************************************)
(************************************************************************)

begin (* initial statement *)
  init crash_util
end (* lvol_dialogue *);
$endif (logical_volumes
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if logical_volumes
!
(************************************************************************)
(*									*)
(*	LVCOPY.NTV							*)
(*									*)
(*			   logical_volume_copy				*)
(*									*)
(*	This class performs the logical volume operation COPY.		*)
(*									*)
(*	Copy the time stamp block LAST, so that if the system goes	*)
(*	down during the copy, the wrong drive will not be used when	*)
(*	it comes back up.						*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	23Oct86 - neh							*) 
(*	      - Change report_messages to report_validator_message	*)
(*		in copy command.					*)
(*	08Mar86 - jrn							*)
(*	      - add COPY command to Tymnet's NVDM			*)
(*	07Mar86 - jrn							*)
(*	      - reorganize and clean up					*)
(*		Original - pgl						*)
(*									*)
(************************************************************************)


type logical_volume_copy = class(
	user_terminal	: circuit_handler;
	format		: internal_to_string;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code    status_manager	: lvol_status_manager;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	lv_utility	: lvol_utility;
	oplog		: operator_log;
	statistics	: statistics_gatherer);


const
(* Disks described in terms of blocks of pages to do copy I/O *)
  COPY_BLOCK_SIZE = 100 (* in pages *);
  COPY_BLOCK_LIMIT = COPY_BLOCK_SIZE - 1;

  REPORT_INTERVAL = COPY_BLOCK_SIZE * 100 (* report every 100 copy I/O's *);


type
  COPY_SIZE = 1..COPY_BLOCK_SIZE;
  COPY_BLOCK = array [0..COPY_BLOCK_LIMIT] of page;


const
  UNIT_ZERO_LAST_COPY_PAGE = ((DISK_UNIT_ZERO_SIZE - 1) div COPY_BLOCK_SIZE) *
    COPY_BLOCK_SIZE;

  UNIT_ZERO_LAST_COPY_SIZE = DISK_UNIT_ZERO_SIZE - UNIT_ZERO_LAST_COPY_PAGE;

  UNIT_ONE_LAST_COPY_PAGE = ((DISK_UNIT_ONE_SIZE - 1) div COPY_BLOCK_SIZE) *
    COPY_BLOCK_SIZE;

  UNIT_ONE_LAST_COPY_SIZE = DISK_UNIT_ONE_SIZE - UNIT_ONE_LAST_COPY_PAGE;


type
  COPY_STATUS = (COPY_OK, COPY_COMPLETE, COPY_IO_FAILURE, COPY_TERMINATED);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code

var
  oper_messages	: operator_messages;
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(***********************  logical_volume_copy  **************************)
(*									*)
(*			    initialize_copy				*)
(*									*)
(*	Report to Operator Log that a copy is starting, and set up	*)
(*	the TO and FROM units for the incarnations set by		*)
(*	to_incarnation and from_incarnation.				*)
(*									*)
(************************************************************************)

procedure initialize_copy(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code
      auto_flag		: boolean;
      name		: username_string;
      lvol_age		: logical_volume_age;
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      to_incarnation	: incarnation_index;
      from_incarnation	: incarnation_index;
  var to_unit		: lvol_disk_unit_index;
  var from_unit		: lvol_disk_unit_index);

begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code
  if auto_flag
  then format.start_message('automatic \ ')
  else format.start;
  format.string('copy started from drive \ ');
  format.number(from_incarnation, 10);
  format.string(' to drive \ ');
  format.number(to_incarnation, 10);
  if auto_flag
  then oper_messages.report_message(LV_OPLOG_MSG)
  else
    begin
      format.newline;
      format.string('the source disk is \');
      format.lvol_age(lvol_age);
      format.string(' by \ ');
      oper_messages.report_by_validator_message(name, LV_OPLOG_MSG)
    end (* else auto_flag *);
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

  from_unit := lv_utility.first_incarnation_disk_unit(from_incarnation);
  to_unit := lv_utility.first_incarnation_disk_unit(to_incarnation)
end (* initialize_copy *);



(***********************  logical_volume_copy  **************************)
(*									*)
(*			 initialize_unit_copy				*)
(*									*)
(*	Initialize address to SECOND copy block; the copy of the first	*)
(*	block on the unit will be performed LAST, so if the copy fails,	*)
(*	the time stamp on the TO incarnation will not be set to		*)
(*	the same time as the FROM time.					*)
(*									*)
(************************************************************************)

procedure initialize_unit_copy(
  var address	: integer;
  var status	: copy_status);

begin
  address := COPY_BLOCK_SIZE;
  status := COPY_OK
end (* initialize_unit_copy *);



(***********************  logical_volume_copy  **************************)
(*									*)
(*				finish_copy				*)
(*									*)
(*      Sets to_incarnation appropriately and sends message to oplog	*)
(*	if copy was terminated by user or was complete; if not NVDM,	*)
(*	notifies status_manager that copy is over.			*)
(*									*)
(************************************************************************)

procedure finish_copy(
      manual_copy	: boolean;
      to_incarnation	: incarnation_index;
  var status		: copy_status);

var
  lv_flag : lvol_set_state_flags;

begin
  if (status = COPY_IO_FAILURE) or (status = COPY_TERMINATED)
  then lv_flag := SET_LVOL_UNAVAILABLE
  else lv_flag := SET_LVOL_CLEAR;
  lv_utility.set_state(to_incarnation, lv_flag);
  if status <> COPY_IO_FAILURE
  then
    begin
      if manual_copy
      then format.start_message(MANUAL_MESSAGE)
      else format.start_message('automatic \ ');
      format.string('copy \');
      if status = COPY_COMPLETE
      then format.string(COMPLETE_MESSAGE)
      else format.string('terminated\ ');
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code       oper_messages.report_message(LV_OPLOG_MSG)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    end (* status <> COPY_IO_FAILURE *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code   status_manager.copy_ended
end (* finish_copy *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(***********************  logical_volume_copy  **************************)
(*									*)
(*			     copy_next_block				*)
(*									*)
(*	Copies the appropriate number of pages, and increments		*)
(*	address, sets status to COPY_BLOCKS_COMPLETE if			*)
(*	necessary, and reports copy errors to the operlog.		*)
(*									*)
(************************************************************************)

procedure copy_next_block(
      to_unit	: lvol_disk_unit_index;
      from_unit	: lvol_disk_unit_index;
      last_page	: integer (* maximum address of copy operation *);
      last_size	: integer (* size of copy operation at maximum address *);
  var address	: integer;
  var status	: copy_status);

var
  page_count : copy_size (* number of pages for copy operation *);
  copy_param : lvol_copy_param;
  dummy_unit : integer;
  buffer : copy_block;

begin
  if address = last_page (* about to copy maximum address *)
  then page_count := last_size (* set size for copy at maximum address *)
  else page_count := COPY_BLOCK_SIZE (* normal size of copy *);

  copy_param.operation := LVOL_COPY;
  copy_param.start_addr := address;
  copy_param.byte_count := PAGE_SIZE * page_count;
  copy_param.to_disk := to_unit;
  copy_param.from_disk := from_unit;
  io(buffer, copy_param, LVOL, dummy_unit);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code   statistics.report_lv_copy(copy_param);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

  if copy_param.status <> COMPLETE
  then
    begin
      status := COPY_IO_FAILURE;
      format.start_message('copy failed at page \ ');
      format.number(address, 10);
      format.newline;
      format.status_name(copy_param.status);
      if copy_param.status = FAILURE
      then
        begin
	  format.colon_space;
	  format.isis_error(copy_param.byte_count)
	end (* copy_param.status = FAILURE *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code      oper_messages.report_message(LV_OPLOG_MSG)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
   end (* copy_param.status <> COMPLETE *)
  else (* copy_param.status = COMPLETE *)
    if address = 0 (* copied from page zero last *)
    then status := COPY_COMPLETE
    else
      if address = last_page
      then address := 0	(* copy area from zero last *)
      else address := address + page_count
end (* copy_next_block *);



(***********************  logical_volume_copy  **************************)
(*									*)
(*			   copy_unit_and_report				*)
(*									*)
(************************************************************************)

procedure copy_unit_and_report(
      to_unit	: lvol_disk_unit_index;
      from_unit	: lvol_disk_unit_index;
      last_page	: integer (* maximum address of copy operation *);
      last_size	: integer (* size of copy operation at maximum address *);
  var address	: integer;
  var status	: copy_status);

var
  line_length : integer;
  next_report_address : integer;

begin
  line_length := 0; next_report_address := REPORT_INTERVAL;
  initialize_unit_copy(address, status);
  format.start_line_message('copying to unit: \');
  format.number(to_unit, 10);
  format.write_line(user_terminal);
  repeat
    copy_next_block(to_unit, from_unit, last_page, last_size, address, status);
    if status = COPY_OK
    then
      begin (* status = COPY_OK *)
        if address >= next_report_address
	then
	  begin
	    format.report_progress(user_terminal, address, 0, 0, line_length);
	    next_report_address := next_report_address + REPORT_INTERVAL
	  end (* address >= next_report_address *)
	else user_terminal.check_circuit;
	if not user_terminal.sendable
	then
	  begin
	    if user_terminal.break_pending
	    then user_terminal.clear_break_status;
	    status := COPY_TERMINATED
	  end
      end (* status = COPY_OK *)
  until status <> COPY_OK
end (* copy_unit_and_report *);



(***********************  logical_volume_copy  **************************)
(*									*)
(*				   copy					*)
(*									*)
(*	Copies to incarnation which is legal and most current,		*)
(*	if error, sets status.						*)
(*									*)
(************************************************************************)

procedure entry COPY(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code
      name		: username_string;
      lvol_age		: logical_volume_age;
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      to_incarnation	: incarnation_index;
      from_incarnation	: incarnation_index);

var
  address : integer;
  to_unit : lvol_disk_unit_index;
  from_unit : lvol_disk_unit_index;
  status : copy_status;

begin
  initialize_copy(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code     FALSE, name, lvol_age,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    to_incarnation, from_incarnation, to_unit, from_unit);
  copy_unit_and_report(to_unit, from_unit, UNIT_ZERO_LAST_COPY_PAGE,
    UNIT_ZERO_LAST_COPY_SIZE, address, status);
  if status = COPY_COMPLETE
  then
    begin
      user_terminal.write_newline;
      from_unit := lv_utility.unit_partner(from_unit);
      to_unit := lv_utility.unit_partner(to_unit);
      copy_unit_and_report(to_unit, from_unit, UNIT_ONE_LAST_COPY_PAGE,
        UNIT_ONE_LAST_COPY_SIZE, address, status)
    end (* status = COPY_COMPLETE *);
  finish_copy(TRUE, to_incarnation, status);
  if user_terminal.sendable
  then
    begin
      user_terminal.write_newline;
      format.write_line(user_terminal);
    end
end (* copy *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code



(***********************  logical_volume_copy  **************************)
(*									*)
(*				auto_copy				*)
(*									*)
(*	Copies to incarnation which is legal and most current,		*)
(*	if error, sets status.						*)
(*									*)
(************************************************************************)

procedure entry AUTO_COPY;

var
  to_unit,
  from_unit : lvol_disk_unit_index;
  to_incarnation,
  from_incarnation : incarnation_index;
  address : integer;
  status : copy_status;
  dummy_name : username_string;
  dummy_age : logical_volume_age;

begin
  from_incarnation := 0; to_incarnation := 1;
  dummy_name.size := 0;
  dummy_age.hours := 0; dummy_age.scaled_minutes := 0;
  initialize_copy(TRUE, dummy_name, dummy_age, to_incarnation,
    from_incarnation, to_unit, from_unit);
  initialize_unit_copy(address, status);
  repeat
    copy_next_block(to_unit, from_unit, UNIT_ZERO_LAST_COPY_PAGE,
      UNIT_ZERO_LAST_COPY_SIZE, address, status)
  until status <> COPY_OK;
  if status = COPY_COMPLETE
  then
    begin
      initialize_unit_copy(address, status);
      from_unit := lv_utility.unit_partner(from_unit);
      to_unit := lv_utility.unit_partner(to_unit);
      repeat
        copy_next_block(to_unit, from_unit, UNIT_ONE_LAST_COPY_PAGE,
	  UNIT_ONE_LAST_COPY_SIZE, address, status)
	until status <> COPY_OK
    end (* status = COPY_COMPLETE *);
  finish_copy(FALSE, to_incarnation, status)
end (* auto_copy *);
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(************************************************************************)
(************************************************************************)

begin (* initial statement *)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code   init oper_messages(oplog, format)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
end (* logical_volume_copy *);
$endif (* logical_volumes *)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if logical_volumes
!
(************************************************************************)
(*									*)
(*	LVRPT.NTV							*)
(*									*)
(*			   lvol_state_reporter				*)
(*									*)
(*	This process periodically reports that a disk is down or	*)
(*	offline to the Sup error log and the Netval operator log.  	*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	01Nov85 - jrn							*)
(*	      - move send_errlog_message procedure to CIRCIO.NTV for	*)
(*		more general use					*)
(*		Original - pgl						*)
(*									*)
(************************************************************************)

type LVOL_STATE_REPORTER = process(
	lv_manager	: lvol_status_manager;
	oplog		: operator_log);

var
  mutil : misc_utility;
  aux_io : circuit_handler;
  format : internal_to_string;
  oper_messages	: operator_messages;

  incarnation : incarnation_index;



(***********************  lvol_state_reporter  **************************)
(*									*)
(*			  send_errlog_message				*)
(*									*)
(*      Send a message that a disk is down or offline to the sup error  *)
(*	log ("i" is incarnation of down or offline disk).		*)
(*									*)
(* Supervisor ERR log message:						*)
(*	NODE REPORT nnnn SLOT ss VAL TYPE 10 i				*)
(*									*)
(* TMCS message:							*)
(*	NODE REPORT nnnn FROM SLOT ss VAL, DISK i IS DOWN OR OFFLINE	*)
(*									*)
(************************************************************************)

procedure send_errlog_message;

var
  data2 : halfword;

begin
  data2[0] := ZERO;
  data2[1] := chr(incarnation);
  aux_io.send_errlog_message(ERRLOG_DRIVE_DOWN_MESSAGE_TYPE, ZERO, data2)
end (* send_errlog_message *);



(************************************************************************)
(************************************************************************)

begin (* initial statement *)
  init mutil, aux_io(mutil), format, oper_messages(oplog, format);

  cycle
    lv_manager.get_lvol_message(incarnation) (* delay until message ready *);
    format.start_message('Disk on drive \ ');
    format.number(incarnation, 10);
    format.string(' down or offline\ ');
    oper_messages.report_message(LV_OPLOG_MSG);
    send_errlog_message
  end (* cycle *)
end (* lvol_state_reporter *);
$endif logical_volumes
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if logical_volumes
!
(************************************************************************)
(*									*)
(*	LVSTMP.NTV							*)
(*									*)
(*				lvol_time_stamp				*)
(*									*)
(*	This process  calls the lvol_status_manager periodically to	*)
(*	record time stamps on the disk unit(s).				*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*		Original - jrn						*)
(*									*)
(************************************************************************)

type lvol_time_stamp = process(
	status_manager	: lvol_status_manager);



(**************************  lvol_time_stamp  ***************************)
(*									*)
(*			    delay_time_stamp				*)
(*									*)
(*	Delay this process for at least LVOL_TIME_STAMP_INTERVAL	*)
(*	seconds.							*)
(*									*)
(************************************************************************)

procedure delay_time_stamp;

var
  end_delay_time : integer;

begin
  end_delay_time := REALTIME + LVOL_TIME_STAMP_INTERVAL;
  repeat
    wait; wait; wait; wait; wait
  until REALTIME > end_delay_time
end (* delay_time_stamp *);



(************************************************************************)
(************************************************************************)

begin (* initial statement *)
  cycle
    delay_time_stamp (* use this name so NAD's "?stat" line will be clear *);
    status_manager.record_time_stamp
  end (* cycle *)
end (* lvol_time_stamp *);
$endif (* logical_volumes *)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if logical_volumes
!
(************************************************************************)
(*									*)
(*	LVDMT.NTV							*)
(*									*)
(*			lvol_disk_maintenance				*)
(*									*)
(*	This process performs disk_info operations for each disk and	*)
(*	an lvol_info operation periodically in order to check on the	*)
(*	status of the logical volume system.  It notifies the		*)
(*	lvol_status_manager of the system's status.		  	*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*		Original - pgl						*)
(*									*)
(************************************************************************)

type lvol_disk_maintenance = process(
	status_manager	: lvol_status_manager);


var
  lv_utility : lvol_utility;

  info_buffer : lvol_info_buffer;
  param : disk_param;
  disk_tape_info : disk_tape_information;
  unit : lvol_disk_unit_index;
!
(***********************  lvol_disk_maintenance  ************************)
(*									*)
(*			    delay_lvol_maint				*)
(*									*)
(*	Delay this process.						*)
(*									*)
(************************************************************************)

procedure delay_lvol_maint;

var
  end_delay_time : integer;

begin
  end_delay_time := REALTIME + 60;
  repeat
    wait; wait; wait;wait; wait
  until REALTIME > end_delay_time
end (* delay_lvol_maint *);



(************************************************************************)
(************************************************************************)

begin (* initial statement *)
  init lv_utility;

  cycle
    delay_lvol_maint (* use this name so NAD's "?stat" line will be clear *);
    if not status_manager.copy_locked
    then
      begin
        for unit := 0 to LVOL_DISK_UNIT_LIMIT do
	  begin
	    param.operation := DISK_INFO;
	    io(disk_tape_info, param, DISK, unit);
	    if (param.status = FAILURE) and
	      (disk_tape_info.device_status = 18 (* drive powered down *))
	    then lv_utility.set_state(lv_utility.this_incarnation(unit),
	      SET_LVOL_UNAVAILABLE)
	  end (* for *);
	lv_utility.lvol_information(info_buffer);
	status_manager.update_last_status(info_buffer)
      end (* not status_manager.copy_locked *)
  end (* cycle *)
end (* lvol_disk_maintenance *);
$endif (* logical_volumes *)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
(************************************************************************)
(*									*)
(*	CMDUTL.NTV							*)
(*									*)
(*			command_level_utility				*)
(*									*)
(*	This class performs routines common to command_level and other	*)
(*	processes.							*)
(*									*)
(************************************************************************)
(*									*)
(*			     Revision Record				*)
(*									*)
(*	04Jan89 - neh                                                   *)
(*		-  correct bug in select control command                *)
(*		   by setting LAST_NUD_CRITERIA_CONTROL to              *)
(*		   LAST_NUD_CONTROL_OPTION_TO_PRINT                     *)
(*	03Oct88 - jrn							*)
(*		- add new code for password_expiration_by_user		*)
(*		- add new argument to argument_scanner routine		*)
(*		  freeword_date so that future expiration dates		*)
(*		  may be entered.					*)
(*		- change allow_user_password_expire to			*)
(*		  password_expiration_by_user and check out code	*)
(*		- use ganpass_file_exists				*)
(*		- add code for prevent_duplicate_passwords		*)
(*		- add code for restrict_users_by_time			*)
(*		- add code for allow_logon_inhibit			*)
(*      08Jul88 - neh                                                   *)
(*              - change select date to convert time to days for        *)
(*                matching with cud data.                               *)
(*	20May88 - neh version 5.02					*)
(*	      - add REQUEST_GLOBAL_EXCEPTION				*)
(*	15Aug87 - neh							*)
(*	      - replace TYMSHARE_CUD_FORMAT with NETVAL_IS_A_SLAVE	*)
(*	      - remove old password code				*)
(*	      - change clean_up to reverse account_supervisor and	*)
(*		operator bits and to convert CUBS to ISIS time		*)
(*            - remove calendar.password_date				*)
(*	27May87 - neh							*)
(*	      - Change routines to use Supervisor Version 43 data	*)
(*			merge 4.00 and 5.00 21Sep87			*)
(*	11Dec86 - rsb							*)
(*		- Add password EXPIREDATE as a DISPLAY_DIRECTORY filter *)
(*		- add EXPIREDATE to do_display_select			*)
(*		- add ability to display expiredate to 			*)
(*		  DO_FORMAT_CHANGE_DATES				*)
(*		- add ability to use expiredate_criterion to DATE_CHECK *)
(*		- add DISPLAY_GANPASS, DISPLAY_GPOGAN, DISPLAY_SCHEDULE *)
(*		- conditionally add pasmon to class definition		*)
(*		- add mudchg to class definition			*)
(*		- add CONSISTENCY_DEACTIVATED_MESSAGE 			*)
(*		  PASSCHANGER_DEACTIVATED_MESSAGE and			*)
(*		  UUN_MERGE_DEACTIVATED_MESSAGE				*)
(*	12Sep86 - neh							*) 
(*	      - Changed report_block_written to call			*)
(*		report_validator_sup_message.				*)
(*	28Aug86 - jrn							*)
(*	      - mark all Tymshare "old" password code with:		*)
		(*******...  old password code  ...*******)
(*	08Jul86 - jrn							*)
(*	      - add SPECIAL flag (CLEAN and OLDPASS commands)		*)
(*	06Aug86 - jrn							*)
(*	      - add GFDONLY to SELECT PASSWORDDATE command		*)
(*	18Jul86 - jrn							*)
(*	      - handle CUD_ENTRY_IN_WRONG_BLOCK in DISPLAY DIRECTORY	*)
(*		command							*)
(*      12May86 - neh							*)
(*	      - Move all procedures in command_level process which      *)
(*    	        are used to display the cud to command_level_utility    *)
(*		to be used by other processes. Add the following.	*)
(*		  clear_criteria					*)
(*		  Input Routines					*)
(*		    (get_radix_criteria_values)				*)
(*		  Output Routines					*)
(*    	 	    (check_line_length_and_write, format_origins,	*)
(* 		     write_access_profile)		 		*)
(*	  	  Miscellaneous Programmer routines (CUD/MUD handling)	*)
(*		  Command Routines					*)
(*		    (CHANGE CUD, DISPLAY_SELECT, DISPLAY_BLOCK,		*)
(*		     DISPLAY_DIRECTORY, READ CUD/MUD, SELECT,		*)
(*		     WRITE CUD/MUD)					*)
(*	31Mar86	Original - jrn						*)
(*									*)
(************************************************************************)


const
  CONSISTENCY_DEACTIVATED_MESSAGE = 'consistency deactivated\';
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if NETVAL_IS_A_SLAVE   GFD_ONLY_MESSAGE = 'GFD only\ ';
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  NO_GANS_MESSAGE = 'GANs are not included in CUD entries\ ';
  NO_DISTRICTS_MESSAGE = 'Districts are not included in CUD entries\';
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if force_password_change
  PASSCHANGER_DEACTIVATED_MESSAGE = 'passchanger deactivated\';
$endif force_password_change
$if reuse_uuns   UUN_MERGE_DEACTIVATED_MESSAGE = 'uun merge deactivated\';

  MAX_HOST_OUTPUT = 5;

(* used by the DISPLAY_DIRECTORY_COMMAND and DUMP command *)
type
  DESIGNATED_FIELDS = array [fields] of boolean;


type COMMAND_LEVEL_UTILITY = class(
      validator		: validator_index;
      sys_io		: system_handler;
      mutil		: misc_utility;
$ifall (special, BEFORE_SUP_V43)      calendar		: date_time_converter;
      format		: internal_to_string;
      profile		: validator_profile;
      oper_messages	: operator_messages;
      aux_io		: circuit_handler;
      user_terminal	: circuit_handler;
      mud_change	: mud_change_handler;
      cud_access	: cud_access_controller;
      block_utility	: cud_block_utility;
      block_updater	: cud_block_updater;
      cud_entry_util	: cud_entry_utility;
$if BEFORE_SUP_V43      cud_updater     	: cud_entry_updater;
$ifnot BEFORE_SUP_V43     cud_updater		: mud_entry_updater;
      cud_utility	: cud_updater_utility;
      un2_util		: un2_utility;
      login_pool	: login_distributer;
      argument_scan	: argument_scanner;
      keyword_util	: keyword_utility;
      input_scanner	: terminal_input_scanner;
      freeword_utility	: freeword_response_utility;
      keyword_scan	: keyword_scanner;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if ganpass_file_exists
      pasmon		: passtable_handler;
      param_manager	: cud_parameter_controller;
$endif ganpass_file_exists
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      dsksys		: disk_system);



const
(* Following constant and type definitions are used to display the CUD. *)

  NO_PAGINATION = -1 (* pagination constant *);


(* Maximum lengths of various outputs *)

  MAX_OUTPUT_LINE = COMMAND_LINE_TEXT_MAX;

  MAX_GAN_OUTPUT = 11;

  MAX_UUN_OUTPUT = 11;

$if change_by_whom
"changed 4 to 5 by SHSUE at 31-Aug-87 13:25:14"
$endif
  MAX_DISTRICT_OUTPUT = 5;

  MAX_CONTROL_OUTPUT = 21;

  MAX_USERNAME_OUTPUT = 20;

(* count characters in ", (host), " *)
  MAX_ACCESS_ENTRY_DESTINATION_OUTPUT = max_host_output + 10;

  BLOCK_READ = 'block read\ ';
  BLOCK_WRITTEN = 'block written\';

(* Criteria_control_options are only used in conjunction *)
(* with the permanent variable, criteria. *)

$if BEFORE_SUP_V43
  FIRST_CRITERIA_CONTROL_OPTION = licensed;
  LAST_CRITERIA_CONTROL_OPTION = transparent_login;
$endif BEFORE_SUP_V43
$ifnot BEFORE_SUP_V43
  FIRST_MUD_CRITERIA_CONTROL_OPTION = FIRST_MUD_CONTROL_OPTION;
  LAST_MUD_CRITERIA_CONTROL_OPTION = LAST_MUD_CONTROL_OPTION;
  FIRST_NUD_CRITERIA_CONTROL_OPTION = licensed;
  LAST_NUD_CRITERIA_CONTROL_OPTION = LAST_NUD_CONTROL_OPTION_TO_PRINT;
  FIRST_ACCESS_CRITERIA_CONTROL_OPTION = FIRST_ACCESS_CONTROL_OPTION;
  LAST_ACCESS_CRITERIA_CONTROL_OPTION = LAST_ACCESS_CONTROL_OPTION;
$endif BEFORE_SUP_V43

type
$if BEFORE_SUP_V43
  CRITERIA_CONTROL_OPTIONS =
    first_criteria_control_option..last_criteria_control_option;
$endif BEFORE_SUP_V43
$ifnot BEFORE_SUP_V43
  MUD_CRITERIA_CONTROL_OPTIONS =
    first_mud_criteria_control_option..last_mud_criteria_control_option;

  NUD_CRITERIA_CONTROL_OPTIONS =
    first_nud_criteria_control_option..last_nud_criteria_control_option;

  ACCESS_CRITERIA_CONTROL_OPTIONS =
    first_access_criteria_control_option..last_access_criteria_control_option;
$endif BEFORE_SUP_V43


  BUFFER_DESCRIPTION = record
    empty	: boolean (* TRUE if no data here *);
    block	: cud_block_index
  end (* buffer_description *);


(* The following data structures are used to describe *)
(* the criteria created with the SELECT command. *)

  RANGE_CRITERIA_INDEX = ACCESS_CRITERION..UUN_CRITERION;

  DATE_CRITERIA_INDEX = ENTRYDATE_CRITERION..PASSWORDDATE_CRITERION;

  ACCESS_VALUE_TYPES = (HOST_ACCESS, NODE_ACCESS,
$ifnot BEFORE_SUP_V43    CONTROL_ACCESS,
    CLASS_ACCESS, GROUP_ACCESS);

  DATE_CRITERIA_QUALIFIER = (
    NO_DATE_QUALIFIER,
    AFTER_DATE,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if NETVAL_IS_A_SLAVE     GFD_ONLY_DATE,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    BEFORE_DATE);

  DATE = record
    time      : integer;
    qualifier : date_criteria_qualifier
  end (* date *);

  USER_CRITERIA_SELECTIONS = record
    used		: array [criteria_type] of boolean;
    range_criteria	: array [range_criteria_index] of range;
    access_type		: access_value_types;
    date_criteria	: array [date_criteria_index] of date;
$if BEFORE_SUP_V43    control	: array [criteria_control_options] of boolean
$ifnone BEFORE_SUP_V43
    control		: array [mud_criteria_control_options] of boolean;
    nud_control		: array [nud_criteria_control_options] of boolean;
    access_control	: array [access_criteria_control_options] of boolean
$endif BEFORE_SUP_V43
  end (* user_criteria_selections *);


		(* permanent variables *)

var
  cud_info		: buffer_description;

  mud_info		: buffer_description;

  criteria		: user_criteria_selections;

!
"
	HOST Info Routines
"


(***********************  command_level_utility  ************************)
(*									*)
(*			  make_first_host_info_message			*)
(*									*)
(************************************************************************)

procedure make_first_host_info_message;

begin
  format.string('Host \');
  format.number(sys_io.sys_info.host_number, 10);
  format.string(' is \ ');
  format.host_state_name(sys_io.current_host_state)
end (* make_first_host_info_message *);



(***********************  command_level_utility  ************************)
(*									*)
(*			  make_second_host_info_message			*)
(*									*)
(************************************************************************)

procedure make_second_host_info_message;

begin
  format.newline; format.string('This hardware is identified by:\');
  format.newline; format.string('   node: \');
  format.number(sys_io.sys_info.node_number, 8);
  format.newline; format.string('   kernel host: \ ');
  format.number(sys_io.sys_info.kernel_host_number, 10)
end (* make_second_host_info_message *);



(***********************  command_level_utility  ************************)
(*									*)
(*			   do_display_host_info				*)
(*									*)
(************************************************************************)

procedure do_display_host_info;

begin
  format.start; make_first_host_info_message;
  format.write_line(user_terminal);

  format.start; make_second_host_info_message;
  format.write_line(user_terminal);
  user_terminal.write_newline
end (* do_display_host_info *);



(***********************  command_level_utility  ************************)
(*									*)
(*			    display_host_info				*)
(*									*)
(************************************************************************)

procedure entry DISPLAY_HOST_INFO;

begin
  do_display_host_info
end (* display_host_info *);



(***********************  command_level_utility  ************************)
(*									*)
(*			report_logged_in_validators			*)
(*									*)
(************************************************************************)

procedure report_logged_in_validators(
      count		: univ integer;
      validator_message	: quoted_text);

begin
  if count <> 0
  then
    begin
      format.format_number(count, 10, 4);
      format.character(ASCII_SPACE);
      format.string(validator_message);
      format.string(' validator\ ');
      if count > 1
      then format.character(LOWER_CASE_S);
      format.newline
    end (* count <> 0 *)
end (* report_logged_in_validators *);



(***********************  command_level_utility  ************************)
(*									*)
(*			make_validator_report_message			*)
(*									*)
(************************************************************************)

procedure make_validator_report_message;

var
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if netval_is_a_slave   master_count : master_validator_count;
$ifnone no_password_only_validators
  password_only_count : password_only_validator_count;
$endif no_password_only_validators
$if global_password_only_login
  global_only_count : password_only_validator_count;
$endif global_password_only_login
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  licensed_count : licensed_validator_count;
  programmer_count : integer (* should only be 0 or 1! *);
  total_count : integer;

begin
  total_count := 0;
  login_pool.validator_count(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if netval_is_a_slave     master_count,
$if global_password_only_login      global_only_count,
$ifnone no_password_only_validators     password_only_count,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    licensed_count, programmer_count);
  format.start_message('logged in:\ ');
  format.newline;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if netval_is_a_slave
  report_logged_in_validators(master_count, MASTER_MESSAGE);
  total_count := total_count + master_count;
$endif netval_is_a_slave
$ifnone no_password_only_validators
  report_logged_in_validators(password_only_count, PASSWORD_ONLY_MESSAGE);
  total_count := total_count + password_only_count;
$endif no_password_only_validators
$if global_password_only_login
  report_logged_in_validators(global_only_count, GPO_MESSAGE);
  total_count := total_count + global_only_count;
$endif global_password_only_login
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  report_logged_in_validators(licensed_count, LICENSED_MESSAGE);
  total_count := total_count + licensed_count;
  report_logged_in_validators(programmer_count, PROGRAMMER_MESSAGE);
  total_count := total_count + programmer_count;
  if total_count = 0
  then format.string('   none\')
end (* make_validator_report_message *);



(***********************  command_level_utility  ************************)
(*									*)
(*			   host_status_command				*)
(*									*)
(************************************************************************)

procedure entry HOST_STATUS_COMMAND;

begin
  do_display_host_info;

  make_validator_report_message;
  format.write_block(user_terminal)
end (* host_status_command *);



(***********************  command_level_utility  ************************)
(*									*)
(*			    get_host_info				*)
(*									*)
(*	Add the host info data to format for writing to the		*)
(*	operator log.							*)
(*									*)
(************************************************************************)

procedure entry GET_HOST_INFO;

begin
  make_first_host_info_message;
  format.newline;
  make_second_host_info_message
end (* get_host_info *);



(***********************  command_level_utility  ************************)
(*									*)
(*			    get_validator_info				*)
(*									*)
(*	Add validator info to format for writing to the operator log.	*)
(*									*)
(************************************************************************)

procedure entry GET_VALIDATOR_INFO;

begin
  make_validator_report_message 
end (* get_validator_info *);
!
"
	Clear Criteria for DISPLAY CUD Data
"



(************************  command_level_utility  ***********************)
(*									*)
(*			   do_clear_criteria				*)
(*									*)
(*	Clears all criteria or a specified criteria.			*)
(*									*)
(************************************************************************)

procedure do_clear_criteria(
      criteria_to_clear	: criteria_type);

var
  index : criteria_type;
  no_criteria_used : boolean;

begin
  if criteria_to_clear = ALL_CRITERIA
  then
    begin (* clear all criteria *)
      for index := ALL_CRITERIA to PASSWORDDATE_CRITERION do
	criteria.used[index] := FALSE;
      if (ACCOUNT_SUPERVISOR_LICENSE in profile.licenses) and
        not (AUDITOR_LICENSE in profile.licenses)
      then
	begin (* without proper license, sel. is limited to validator's GAN *)
	  criteria.used[GAN_CRITERION] := TRUE;
	  criteria.range_criteria[GAN_CRITERION].first := profile.gan;
	  criteria.range_criteria[GAN_CRITERION].last := profile.gan
	end (* without proper license, sel. is limited to validator's GAN *)
      else criteria.used[ALL_CRITERIA] := TRUE
    end (* clear all criteria *)
  else
    begin (* clear single specified criteria *)
      criteria.used[criteria_to_clear] := FALSE;
      no_criteria_used := TRUE;
      for index := ACCESS_CRITERION to PASSWORDDATE_CRITERION do
	if criteria.used[index]
	then no_criteria_used := FALSE;
      if no_criteria_used
      then criteria.used[ALL_CRITERIA] := TRUE
    end (* clear single specified criteria *)
end (* do_clear_criteria *);



(************************  command_level_utility  ***********************)
(*									*)
(*			 clear_criteria_and_buffer			*)
(*									*)
(************************************************************************)

procedure entry CLEAR_CRITERIA_AND_BUFFER(
      criteria_to_clear	: criteria_type);

begin
  do_clear_criteria(criteria_to_clear);
  cud_info.empty := TRUE;
  mud_info.empty := TRUE
end (* clear_criteria_and_buffer *);
!
"
	Input Routines
"


(************************  command_level_utility  ***********************)
(*									*)
(*			  criteria_value_radix				*)
(*									*)
(*	Set radix for criteria_index - ACCESS_CRITERION's radix is	*)
(*	based on access_type						*)
(*									*)
(************************************************************************)

function criteria_value_radix(
      criteria_index	: criteria_type;
      access_index	: access_value_types) : integer;

begin
  case criteria_index of
    GAN_CRITERION: criteria_value_radix := 8;
    UUN_CRITERION: criteria_value_radix := UUN_RADIX;
    DISTRICT_CRITERION: criteria_value_radix := 10;
    ACCESS_CRITERION:
      case access_index of
        HOST_ACCESS,
	CLASS_ACCESS,
	GROUP_ACCESS: criteria_value_radix := 10;
	NODE_ACCESS: criteria_value_radix := 8
      end (* case criteria_index *)
  end (* case access_index *)
end (* criteria_value_radix *);



(************************  command_level_utility  ***********************)
(*									*)
(*			 do_clear_designated_fields			*)
(*									*)
(*	Clear fields.							*)
(*									*)
(************************************************************************)

procedure do_clear_designated_fields(
  var selected_fields	: designated_fields);

var
  field_index : fields;

begin
  for field_index :=FIRST_FIELD to LAST_FIELD do
    selected_fields[field_index] := FALSE
end (* do_clear_designated_fields *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if include_dump



(************************  command_level_utility  ***********************)
(*									*)
(*			  clear_designated_fields			*)
(*									*)
(*	Clear fields.							*)
(*									*)
(************************************************************************)

procedure entry CLEAR_DESIGNATED_FIELDS(
  var selected_fields	: designated_fields);

begin
  do_clear_designated_fields(selected_fields)
end (* clear_designated_fields *);
$endif include_dump
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
"
	Output Routines
"
(*				CAUTION					*)
(* The following output routines are used by both display directory 	*)
(* and the Archive dump command. Do not make changes to these routines 	*)
(* without checking that the change will work for both display		*)
(* directory and the dump command.					*)



(************************  command_level_utility  ***********************)
(*									*)
(*	 	     do_check_line_length_and_write    			*)
(*									*)
(*	If not at start_line, output delimiter; if too close to end	*)
(*	of line, output current line and start next; a value should	*)
(*	always be output after this call; max_size should be large 	*)
(*	enuf to accomodate "delimiter value delimiter," i.e.,		*)
(*			, value,					*)
(*									*)
(************************************************************************)

procedure do_check_line_length_and_write(
      max_size		: integer (* max spaces for an entry *);
      start_line	: format_buffer_text_index;
      delimiter		: quoted_text);

begin
  if format.buffer.size + max_size > MAX_OUTPUT_LINE
  then
    begin (* entry will not fit on current line, add delimiter and output *)
      format.string(delimiter);
      format.write_line(user_terminal);
      format.start;
      format.skip_to(start_line);
    end (* entry will not fit on current line, add delimiter and output *)
  else
   if format.buffer.size <> start_line
   then format.string(delimiter) (* entry will fit, output delimiter *)
end (* do_check_line_length_and_write *);



(*********************  command_level_utilty  ***************************)
(*									*)
(*	             check_line_length_and_write			*)
(*									*)
(************************************************************************)

procedure entry CHECK_LINE_LENGTH_AND_WRITE(
      max_size		: integer (* max spaces for an entry *);
      start_line	: format_buffer_text_index;
      delimiter		: quoted_text);

begin
  do_check_line_length_and_write(max_size, start_line, delimiter)  
end (* check_line_length_and_write *);



(********************  command_level_utility  ***************************)
(*									*)
(*			  format_origins				*)
(*									*)
(************************************************************************)

procedure format_origins(
      access_entry	: access_entry_description;
      host_origin	: boolean;
      short_display	: boolean;
      tape_display	: boolean;
  var index		: in_place_origin_index;
  var finished		: boolean);

var
  first_index : boolean;
  not_origin : boolean;
  radix : integer;

begin
  first_index := TRUE;
  if not short_display
  then
    begin
      format.newline;
      format.skip(3)
    end (* not short_display *);
  if access_entry.exception
  then
    begin
      not_origin := TRUE;
      if (not short_display or (index = 0)) and not tape_display
      then
	begin
	  format.string(' (not)\ ');
	  if not short_display
	  then format.skip(1);
	end
    end
  else
    begin
      not_origin := FALSE;
      if not short_display
      then format.skip(7)
    end;

  if host_origin
  then radix := 10
  else radix := 8;
  while (access_entry.origin.list[index].host_flag = host_origin) and
    not finished do
    begin
      if short_display
      then
        begin
	  format.skip(1);
          if tape_display
          then
	    if not_origin
	    then format.character('N')
	    else format.character('O');
          if access_entry.origin.list[index].host_flag
          then format.character('H')
          else format.character('N')
        end
      else
	if first_index
	then
	  begin
	    first_index := FALSE;
	    if host_origin
	    then format.string(HOST_MESSAGE)
	    else format.string(NODE_MESSAGE);
	    format.string('s: \')
	  end
	else format.string(COMMA_SPACE);
      format.number(access_entry.origin.list[index].value, radix);
      if index = access_entry.origin.size - 1
      then finished := TRUE
      else index := index + 1
    end
end (* format_origins *);



(*******************  command_level_utility  ****************************)
(*									*)
(*			write_access_entry				*)
(*									*)
(*	Writes out a single access profile entry.		   	*)
(*									*)
(************************************************************************)

procedure write_access_entry(
      index		: access_entry_index;
      access_entry	: access_entry_description;
      short_display	: boolean;
      tape_display	: boolean);

var
  origin_index : in_place_origin_index;
  dest_index : destination_index;
  printing_groups : boolean (* TRUE if last destination written was group *);
$if REQUEST_GLOBAL_EXCEPTION
  printing_not : boolean (* TRUE if last destination written was exception *);
$endif REQUEST_GLOBAL_EXCEPTION
  finished : boolean;
  start_line : format_buffer_text_index;
$ifnone BEFORE_SUP_V43
  access_option_index : access_control_options;
  access_options : access_user_options;
$endif BEFORE_SUP_V43

begin
  finished := FALSE;
  if not tape_display
  then
    begin
      if short_display
      then format.skip_to(2);
      format.character(ASCII_LEFT_PARENS)
    end (* not tape_display *);
  format.number(index + 1, 10);
$ifnone BEFORE_SUP_V43
  if not tape_display
  then format.string(') \ ');
  if not short_display
  then format.string('Control options:\ ');
  cud_entry_util.unpack_access_options(access_entry.access_control,
    access_options);
  for access_option_index := FIRST_ACCESS_CONTROL_OPTION to
    LAST_ACCESS_CONTROL_OPTION do
      if access_option_index in access_options
      then
	begin (* option applies, output it *)
	  format.skip(1);
	  if short_display
	  then format.short_access_control_option_name(access_option_index)
	  else
	    begin
	      format.write_line(user_terminal);
	      format.start;
	      format.skip(6);
	      format.access_control_option_name(access_option_index)
	    end
	end (* option applies, output it *);
	format.write_line(user_terminal);
	format.start;
$endif BEFORE_SUP_V43
  if not tape_display
  then
    begin
$if BEFORE_SUP_V43     format.string(') Origin\ ');
$ifnone BEFORE_SUP_V43     format.string('    Origin\ ');
      if short_display
      then format.character(ASCII_COLON)
      else
        begin
          format.string('     \');
          format.colon_space
        end (* short_display *)
    end (* not tape_display *);
  origin_index := 0;
  if access_entry.in_place_origin
  then
    begin
      if access_entry.origin.list[origin_index].host_flag
      then format_origins(access_entry, TRUE, short_display, tape_display,
	origin_index, finished);
      if not finished
      then format_origins(access_entry, FALSE, short_display, tape_display,
	origin_index, finished)
    end (* in place origin *)
  else
    begin (* class origin *)
$if REQUEST_GLOBAL_EXCEPTION
      if (not short_display) and (not tape_display)
      then
	begin
          format.newline;
          format.skip(10)
	end;
      if access_entry.exception
      then
        if not tape_display
        then format.string(' (not) \');
$endif REQUEST_GLOBAL_EXCEPTION
      if short_display
      then format.string(' C\ ')
      else 
        begin
$ifnot REQUEST_GLOBAL_EXCEPTION
	  format.newline;
	  format.skip(10);
$endif REQUEST_GLOBAL_EXCEPTION
          format.string('class: \')
	end;
      format.number(access_entry.class_no, 10)
    end (* class origin *);
  if not short_display
  then
    begin
      format.write_line(user_terminal);
      format.start;
      format.skip(2)
    end (* not short_display *);

(* write destination *)
  if not tape_display then format.string('  Destination:\ ');
(* the following insures the printing of the first header, i.e., *)
(* it will not match the first time thru... *)
  printing_groups := not access_entry.destination.list[0].group_flag;
(* it will not match the first time thru... *)
$if REQUEST_GLOBAL_EXCEPTION
  printing_not := not access_entry.destination.list[0].exception;
$endif REQUEST_GLOBAL_EXCEPTION
  for dest_index := 0 to access_entry.destination.size - 1 do
    begin
      if not short_display
      then
$if REQUEST_GLOBAL_EXCEPTION
          if access_entry.destination.list[dest_index].exception <>
            printing_not (* same as last value? *)
          then
            begin (* this value is different from last, output header *)
              format.write_line(user_terminal);
              format.start;
              if not printing_not and not tape_display
              then format.string('        (not)\')
              else
                if tape_display
                then format.skip(1)
                else format.string('        \ ');
              printing_groups := access_entry.destination.list[dest_index].group_flag;
              if printing_groups
              then format.string(' groups: \')
              else format.string('  hosts: \');
              start_line := format.buffer.size;
              printing_not := not printing_not
            end (* this value is different from last, output header *)
        else
$endif REQUEST_GLOBAL_EXCEPTION
        if access_entry.destination.list[dest_index].group_flag =
	  printing_groups (* same as last value? *)
	then do_check_line_length_and_write(
	  MAX_ACCESS_ENTRY_DESTINATION_OUTPUT, start_line, COMMA_SPACE)
	else
	  begin (* this value is different from last, output header *)
	    format.write_line(user_terminal);
	    format.start;
            if not tape_display
            then format.string('   \');
            if tape_display
            then format.skip(1)
$if REQUEST_GLOBAL_EXCEPTION
	    else
	      if access_entry.destination.list[dest_index].exception
              then format.string('(not)\')
$endif REQUEST_GLOBAL_EXCEPTION
              else format.string('     \');
	    if printing_groups
	    then format.string('  hosts: \')
	    else format.string(' groups: \');
	    start_line := format.buffer.size;
	    printing_groups := not printing_groups (* reset *)
	  end (* this value is different from last, output header *)
      else
        begin (* short_display *)
	  format.skip(1);
$if REQUEST_GLOBAL_EXCEPTION
          if access_entry.destination.list[dest_index].exception
          then format.string('(not) \ ')
          else
$endif REQUEST_GLOBAL_EXCEPTION
            if access_entry.destination.list[dest_index].home_flag
	    then format.character('H');
	  if access_entry.destination.list[dest_index].group_flag
	  then format.character('G')
	  else format.character('H')
	end (* short_display *);
      format.number(access_entry.destination.list[dest_index].value, 10);
      if not short_display
      then
        if access_entry.destination.list[dest_index].home_flag
	then format.string(' (home)\')
    end (* for *)
end (* write_access_entry *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if include_dump



(*******************  command_level_utility  ****************************)
(*									*)
(*			write_access_entry_to_tape			*)
(*									*)
(*	Writes out a single access profile entry to tape (short display)*)
(*									*)
(************************************************************************)

procedure entry WRITE_ACCESS_ENTRY_TO_TAPE(
      index		: access_entry_index;
      access_entry	: access_entry_description);

begin
  write_access_entry(index, access_entry, TRUE, TRUE)
end (* write_access_entry_to_tape *);
$endif include_dump
$if restrict_users_by_time



(*******************  command_level_utility  ****************************)
(*									*)
(*		    do_write_allowable_hours				*)
(*									*)
(************************************************************************)

procedure do_write_allowable_hours(
      allowable_hours : allowable_login_times);

var
  hour_index : allowable_login_hours;
  hour_range : range;
  range_forming : boolean;

begin
  range_forming := FALSE;
  for hour_index := FIRST_HOUR to LAST_HOUR do
    begin
      if hour_index in allowable_hours
      then (* hour is in set *)
        if range_forming
	then hour_range.last := hour_index
	else
	  begin (* beginning of a range of hours *)
	    range_forming := TRUE;
	    hour_range.first := hour_index;
	    hour_range.last := hour_index (* in case only one value is there *)
	  end (* beginning of a range of hours *);
      if range_forming and
        (not (hour_index in allowable_hours) or (hour_index = LAST_HOUR))
      then
        begin (* found end of range, output anything in range now *)
	  range_forming := FALSE;
	  format.character(ASCII_SPACE);
	  if hour_range.first <> hour_range.last
	  then hour_range.last := hour_range.last + 1;
	  format.number_range(hour_range.first, hour_range.last, 10)
	end (* found end of range, output anything in range now *)
    end (* for *)
end (* do_write_allowable_hours *);



(*******************  command_level_utility  ****************************)
(*									*)
(*			write_allowable_hours				*)
(*									*)
(************************************************************************)

procedure entry WRITE_ALLOWABLE_HOURS(
      allowable_hours : allowable_login_times);

begin
  if not (ALL_HOURS in allowable_hours)
  then
    begin
      format.start_message('hours user may login:\');
      do_write_allowable_hours(allowable_hours);
      format.write_line(user_terminal)
    end
end (* write_allowable_hours *);
$endif restrict_users_by_time
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(************************  command_level_utility  ***********************)
(*									*)
(*			  do_write_access_profile			*)
(*									*)
(*	Writes out access profile in user's cud entry		   	*)
(*									*)
(************************************************************************)

procedure do_write_access_profile(
      access_profile	: access_profile_description;
      short_display	: boolean);

var
  index : access_entry_index;

begin
  for index := 0 to access_profile.count - 1 do
    begin
      format.start;
      write_access_entry(index, access_profile.entries[index], short_display,
        FALSE);
      format.write_line(user_terminal)
    end
end (* do_write_access_profile *);



(**********************  command_level_utility  *************************)
(*									*)
(*		      	 write_access_profile				*)
(*									*)
(*	External procedure to output access_profile in ASCII string.	*)
(*									*)
(************************************************************************)

procedure entry WRITE_ACCESS_PROFILE(
      access_profile	: access_profile_description;
      short_display	: boolean);

begin
  do_write_access_profile(access_profile, short_display)
end (* write_access_profile *);



(*************************  command_level_utility  **********************)
(*									*)
(*			    do_format_change_dates			*)
(*									*)
(*	Format password change date and entry change date to ASCII	*)
(*	string also format password expiredate.				*)
(*									*)
(************************************************************************)

procedure do_format_change_dates(
      selected_fields	: designated_fields;
$if BEFORE_SUP_V43      cud_entry		: cud_user_entry);
$ifnone BEFORE_SUP_V43
      mud_entry		: mud_user_entry;
      nud_entry		: nud_user_entry);
$endif BEFORE_SUP_V43

var
  found		: boolean;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if force_password_change
  expiredate	: integer;
  passlife	: integer;
$endif force_password_change
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

begin
  if selected_fields[PASSWORDDATE_FIELD] or selected_fields[ALL_FIELDS]
  then
    begin (* PASSWORD DATE is selected *)
$if change_by_whom
"commented out skip(1) by SHSUE at 31-Aug-87 13:16:22"
$endif
(**      format.skip(1); **)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+	*)
$if NETVAL_IS_A_SLAVE
$if BEFORE_SUP_V43      if cud_entry.password_change_date = GFD_ONLY_PASSWORD_DATE
$ifnone BEFORE_SUP_V43      if nud_entry.password_change_date = GFD_ONLY_PASSWORD_DATE
      then format.string(GFD_ONLY_MESSAGE)
      else
$endif NETVAL_IS_A_SLAVE
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+	*)
$if BEFORE_SUP_V43      if cud_entry.password_change_date <> 0
$ifnone BEFORE_SUP_V43      if nud_entry.password_change_date <> 0
	then format.date(
$if BEFORE_SUP_V43        cud_entry.password_change_date*SECONDS_PER_DAY)
$ifnone BEFORE_SUP_V43        nud_entry.password_change_date)
	else format.skip(9)
    end (* PASSWORD DATE is selected *);
  if selected_fields[ENTRYDATE_FIELD] or selected_fields[ALL_FIELDS]
  then
    begin (* ENTRY DATE is selected *)
      format.skip(1);
$if BEFORE_SUP_V43      if (cud_entry.entry_change_date = 0)
$ifnone BEFORE_SUP_V43      if (nud_entry.entry_change_date = 0)
      then format.skip(9)
      else
        begin (* non-zero date, output it *)
	  format.skip(1);
$if BEFORE_SUP_V43     format.date(cud_entry.entry_change_date)
$ifnone BEFORE_SUP_V43 	  format.date(nud_entry.entry_change_date)
        end (* non-zero date, output it *)
    end (* ENTRY DATE is selected *)

(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if password_expiration_by_user
;
  if selected_fields[EXPIREDATE_FIELD] or selected_fields[ALL_FIELDS]
  then
    begin (* EXPIRE DATE is selected *)
      format.skip(1);
      if mud_entry.password.expire_date = 0
      then format.skip(9)
      else
        begin (* non-zero date, output it *)
          format.skip(1);
	  format.date(mud_entry.password.expire_date)
        end (* non-zero date, output it *)
    end (* ENTRY DATE is selected *)
$endif password_expiration_by_user
$if force_password_change
;
  if selected_fields[EXPIREDATE_FIELD] or selected_fields[ALL_FIELDS]
  then
    begin (* attempt to display password expiredate *) 
      if not (NO_PASSWORD_REQUIRED in
$if BEFORE_SUP_V43      cud_entry.options) and
$ifnot BEFORE_SUP_V43      mud_entry.mud_options) and
	 not (FPC_EXEMPT in 
$if BEFORE_SUP_V43      cud_entry.options)
$ifnot BEFORE_SUP_V43      nud_entry.nud_options)
      then
	begin
          found := FALSE;   expiredate := 0;   passlife := 0;
          pasmon.fetch_expiredate(
$if BEFORE_SUP_V43         cud_entry.gan, cud_entry.password_change_date,
$ifnot BEFORE_SUP_V43          nud_entry.gan, nud_entry.password_change_date,
				expiredate, passlife, found);
          if found
          then
            begin (* password will expire for this user, display death date *)
              format.skip(2);
              format.date(expiredate)
            end (* password will expire for this user, display death date *)
          else format.skip(9)
	end (* not NO_PASSWORD and not FPC_EXEMPT *)
      else format.skip(9)
    end (* attempt to display password expiredate *) 
$endif force_password_change
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
end (* do_format_change_dates *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if include_dump



(*************************  command_level_utility  **********************)
(*									*)
(*			     format_change_dates			*)
(*									*)
(*	Format password change date and entry change date to ASCII	*)
(*	string.								*)
(*									*)
(************************************************************************)

procedure entry FORMAT_CHANGE_DATES(
      selected_fields	: designated_fields;
$if BEFORE_SUP_V43      cud_entry		: cud_user_entry);
$ifnone BEFORE_SUP_V43
      mud_entry		: mud_user_entry;
      nud_entry		: nud_user_entry);
$endif BEFORE_SUP_V43

begin
$if BEFORE_SUP_V43  do_format_change_dates(selected_fields, cud_entry)
$ifnone BEFORE_SUP_V43  do_format_change_dates(selected_fields, mud_entry, nud_entry)
end (* format_change_dates *);
$endif include_dump
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(************************  command_level_utilty  ************************)
(*									*)
(*			    do_format_user_data				*)
(*									*)
(*	Format CUD user data to ASCII string. User data formatted is    *)
(*	name, gan, uun, district and control options.			*)
(*									*)
(************************************************************************)

procedure do_format_user_data(
      selected_fields	: designated_fields;
$if BEFORE_SUP_V43       cud_entry		: cud_user_entry);
$ifnone BEFORE_SUP_V43
      cud_flag		: boolean;
      mud_entry		: mud_user_entry;
      nud_entry		: nud_user_entry);
$endif BEFORE_SUP_V43

var
  field_index : fields;
$if BEFORE_SUP_V43  option_index : cud_control_options;
$ifnone BEFORE_SUP_V43
  option_index : mud_control_options;
  nud_option_index : nud_control_options;
  access_option_index : access_control_options;
$endif BEFORE_SUP_V43
  start_of_name : format_buffer_text_size;
  start_of_control : format_buffer_text_size;

begin
  start_of_name := format.buffer.size;
  format.username(
$ifnone BEFORE_SUP_V43    mud_entry.name);
$if BEFORE_SUP_V43     cud_entry.name);
  format.skip_to(MAX_USERNAME_OUTPUT + start_of_name);
  for field_index := UUN_FIELD to CONTROL_FIELD do
    if selected_fields[field_index] or selected_fields[ALL_FIELDS]
    then
      begin (* field is selected *)
	format.skip(1);
	case field_index of
	  UUN_FIELD: format.format_number(
$ifnone BEFORE_SUP_V43	    mud_entry.uun,
$if BEFORE_SUP_V43	     cud_entry.uun,
	     UUN_RADIX, MAX_UUN_OUTPUT);
	  GAN_FIELD: if INCLUDE_GAN
$ifnot BEFORE_SUP_V43		and cud_flag
	    then format.format_number(
$ifnone BEFORE_SUP_V43	    	nud_entry.gan,
$if BEFORE_SUP_V43	    cud_entry.gan,
	      8, MAX_GAN_OUTPUT);
	  DISTRICT_FIELD: if INCLUDE_DISTRICT
$ifnot BEFORE_SUP_V43		and cud_flag
	    then format.format_number(
$ifnone BEFORE_SUP_V43		nud_entry.district,
$if BEFORE_SUP_V43	      cud_entry.district,
	      10, MAX_DISTRICT_OUTPUT);
	  CONTROL_FIELD:
	    begin
	      start_of_control := format.buffer.size;
	      for option_index :=
$ifnone BEFORE_SUP_V43
	        FIRST_MUD_CONTROL_OPTION to
	        LAST_MUD_CONTROL_OPTION do
		if option_index in mud_entry.mud_options
$endif BEFORE_SUP_V43
$if BEFORE_SUP_V43
	        FIRST_CUD_CONTROL_OPTION_TO_PRINT to
	        LAST_CUD_CONTROL_OPTION_TO_PRINT do
		if option_index in cud_entry.options
$endif BEFORE_SUP_V43
		then
		  begin (* option applies, output it *)
		    format.skip(1);
		    format.short_control_option_name(option_index)
		  end (* option applies, output it *);
$ifnone BEFORE_SUP_V43
	      if cud_flag
	      then for nud_option_index := FIRST_NUD_CONTROL_OPTION_TO_PRINT to
	        LAST_NUD_CONTROL_OPTION_TO_PRINT do
		if nud_option_index in nud_entry.nud_options
		then
		  begin (* option applies, output it *)
		    format.skip(1);
		    format.short_nud_control_option_name(nud_option_index)
		  end (* option applies, output it *);
$endif BEFORE_SUP_V43
		format.skip_to(start_of_control + MAX_CONTROL_OUTPUT)
	      end (* CONTROL_FIELD *)
	end (* case *)
      end (* field is selected *);
end (* do_format_user_data *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if include_dump



(************************  command_level_utilty  ************************)
(*									*)
(*			     format_user_data				*)
(*									*)
(*	Format CUD user data to ASCII string. User data formatted is    *)
(*	name, gan, uun, district and control options.			*)
(*									*)
(************************************************************************)

procedure entry FORMAT_USER_DATA(
      selected_fields	: designated_fields;
$if BEFORE_SUP_V43       cud_entry		: cud_user_entry);
$ifnone BEFORE_SUP_V43
      mud_entry		: mud_user_entry;
      nud_entry		: nud_user_entry);
$endif BEFORE_SUP_V43

begin
$if BEFORE_SUP_V43  do_format_user_data(selected_fields, cud_entry)
$ifnone BEFORE_SUP_V43  do_format_user_data(selected_fields, TRUE, mud_entry, nud_entry)
end (* format_user_data *);
$endif include_dump
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
"
	Miscellaneous Programmer Routines
"



(***********************  command_level_utility  ************************)
(*									*)
(*			     empty_buffer 				*)
(*									*)
(*	Check for buffer empty, and report to validator if it is.	*)
(*									*)
(************************************************************************)

function empty_buffer(
      buffer_desc	: buffer_description;
      empty_message	: quoted_text) : boolean;

begin
  empty_buffer := buffer_desc.empty;
  if buffer_desc.empty
  then
    begin
      format.start_message(empty_message);
      format.string(' buffer empty\');
      format.write_line(user_terminal)
    end
end (* empty_buffer *);



(***********************  command_level_utility  ************************)
(*									*)
(*				buffer_is_empty				*)
(*									*)
(*      Return TRUE if selected buffer is empty.			*)
(*									*)
(************************************************************************)

function entry BUFFER_IS_EMPTY(
      writing_from_cud	: boolean) : boolean;

begin
  if writing_from_cud
  then buffer_is_empty := empty_buffer(cud_info, CUD_FILE_MESSAGE)
  else buffer_is_empty := empty_buffer(mud_info, MUD_FILE_MESSAGE)  
end (* buffer_is_empty *);
$ifnone BEFORE_SUP_V43


(************************  command_level_utility  ***********************)
(*									*)
(*			    restore_cud_buffer 				*)
(*									*)
(************************************************************************)

procedure restore_cud_buffer(
  var disk_block	: univ cud_disk_block;
  var success		: boolean);

var
  computed_checksum : integer;

begin
  success := not empty_buffer(cud_info, CUD_FILE_MESSAGE);
  if success
  then
    begin
      dsksys.read_cud_block(FILE_SYSTEM_DISK,
        CUD_MUD_BUFFER_LOCATION, disk_block, success);
      if not success
      then user_terminal.write_quoted_text_line(DISK_READ_ERROR_MESSAGE)
      else
        begin
	  sys_io.cud_checksum(MAXIMUM_CUD_DATA,
	    disk_block.data, computed_checksum);
	  if computed_checksum <> disk_block.checksum
	  then
	    begin
	      success := FALSE;
	      user_terminal.write_quoted_text_line('buffer checksum error\')
	    end
	end
    end
end (* restore_cud_buffer *);



(***********************  command_level_utility  ************************)
(*									*)
(*			    store_cud_buffer 				*)
(*									*)
(************************************************************************)

procedure store_cud_buffer(
      block_number	: cud_block_index;
  var disk_block	: univ cud_disk_block (* VAR so checksum can be set *);
  var buffer_desc	: buffer_description;
  var success		: boolean);

begin
  sys_io.cud_checksum(MAXIMUM_CUD_DATA, disk_block.data, disk_block.checksum);
  dsksys.write_cud_block(FILE_SYSTEM_DISK,
    CUD_MUD_BUFFER_LOCATION, disk_block, success);
  if success
  then
    begin
      buffer_desc.empty := FALSE;
      buffer_desc.block := block_number
    end
  else user_terminal.write_line_and_quoted_text_line(DISK_WRITE_ERROR_MESSAGE)
end (* store_cud_buffer *);
$endif BEFORE_SUP_V43


(***********************  command_level_utility  ************************)
(*									*)
(*			    restore_buffer 				*)
(*									*)
(************************************************************************)

procedure restore_buffer(
$if BEFORE_SUP_V43
      buffer_is_cud	: boolean;
  var disk_block	: cud_disk_block;
$endif BEFORE_SUP_V43
$ifnot BEFORE_SUP_V43  var disk_block	: mud_disk_block;
  var success		: boolean);

var
  computed_checksum : integer;

begin
$if BEFORE_SUP_V43
  if buffer_is_cud
  then success := not empty_buffer(cud_info, CUD_FILE_MESSAGE)
  else
$endif BEFORE_SUP_V43
    success := not empty_buffer(mud_info, MUD_FILE_MESSAGE);
  if success
  then
    begin
$if BEFORE_SUP_V43
      if buffer_is_cud
      then dsksys.read_cud_block(FILE_SYSTEM_DISK,
        CUD_MUD_BUFFER_LOCATION, disk_block, success)
      else dsksys.read_cud_block(FILE_SYSTEM_DISK,
        MUD_BUFFER_LOCATION, disk_block, success);
$endif BEFORE_SUP_V43
$ifnot BEFORE_SUP_V43
      dsksys.read_mud_block(FILE_SYSTEM_DISK,
        MUD_BUFFER_LOCATION, disk_block, success);
$endif BEFORE_SUP_V43
      if not success
      then user_terminal.write_quoted_text_line(DISK_READ_ERROR_MESSAGE)
      else
        begin
$if BEFORE_SUP_V43	  sys_io.cud_checksum(MAXIMUM_CUD_DATA,
$ifnot BEFORE_SUP_V43	  sys_io.mud_checksum(MAXIMUM_MUD_DATA,
	    disk_block.data, computed_checksum);
	  if computed_checksum <> disk_block.checksum
	  then
	    begin
	      success := FALSE;
	      user_terminal.write_quoted_text_line('buffer checksum error\')
	    end
	end
    end
end (* restore_buffer *);



(***********************  command_level_utility  *************************)
(*									*)
(*			    store_buffer 				*)
(*									*)
(************************************************************************)

procedure store_buffer(
$if BEFORE_SUP_V43      buffer_location	: integer;
      block_number	: cud_block_index;
$if BEFORE_SUP_V43  var disk_block	: cud_disk_block (* VAR so checksum can be set *);
$ifnone BEFORE_SUP_V43  var disk_block	    : mud_disk_block;
  var buffer_desc	: buffer_description;
  var success		: boolean);

begin
$if BEFORE_SUP_V43
  sys_io.cud_checksum(MAXIMUM_CUD_DATA, disk_block.data, disk_block.checksum);
  dsksys.write_cud_block(FILE_SYSTEM_DISK, buffer_location,
$endif BEFORE_SUP_V43
$ifnone BEFORE_SUP_V43
  sys_io.mud_checksum(MAXIMUM_MUD_DATA, disk_block.data, disk_block.checksum);
  dsksys.write_mud_block(FILE_SYSTEM_DISK, MUD_BUFFER_LOCATION,
$endif BEFORE_SUP_V43
    disk_block, success);
  if success
  then
    begin
      buffer_desc.empty := FALSE;
      buffer_desc.block := block_number
    end
  else user_terminal.write_line_and_quoted_text_line(DISK_WRITE_ERROR_MESSAGE)
end (* store_buffer *);
!
"
		CHANGE CUD Command
"



(***********************  command_level_utility  ************************)
(*									*)
(*			  start_line_with_index				*)
(*									*)
(************************************************************************)

procedure start_line_with_index(
      byte_index	: cud_data_index);

begin
  format.start;
  format.format_number(byte_index, 16, -MAXIMUM_BYTES_IN_WORD);
  format.skip(2)
end (* start_line_with_index *);



(***********************  command_level_utility  ************************)
(*									*)
(*			     add_next_word 				*)
(*									*)
(************************************************************************)

procedure add_next_word(
      index	: cud_data_index;
      data	: univ cud_data);

var
  number : integer;

begin
  mutil.save_characters_in_word(ZERO, ZERO, data[index],
    data[index + 1], number);
  format.format_number(number, 16, -MAXIMUM_BYTES_IN_WORD);
  format.skip(2);
  mutil.save_characters_in_word(ZERO, ZERO, data[index + 2],
    data[index + 3], number);
  format.format_number(number, 16, -MAXIMUM_BYTES_IN_WORD)
end (* add_next_word *);



(***********************  command_level_utility  ************************)
(*									*)
(*			      change_cud				*)
(*									*)
(************************************************************************)

procedure entry CHANGE_CUD(
  var scanned	: scanned_command);

var
  success : boolean;
  start_offset : cud_data_index;
  disk_block : cud_disk_block;
  done : boolean;
  offset : cud_data_index;
  value : word_in_bytes;

begin
  keyword_util.get_numeric_keyword_value(PRIMARY_CHANGE_OFFSET_KEYWORD, 16, 0,
    CUD_DATA_LIMIT, scanned, start_offset);
  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    begin
      if (start_offset mod 4) <> 0 (* make offset a word boundry *)
      then start_offset := start_offset - (start_offset mod 4);
$if BEFORE_SUP_V43      restore_buffer(TRUE, disk_block, success);
$ifnone BEFORE_SUP_V43      restore_cud_buffer(disk_block, success);
      if success
      then (* change the CUD buffer *)
	begin
	  user_terminal.write_quoted_text_line(
	    'byte   contents    new value\ ');
	  offset := start_offset;
	  done := FALSE;
	  repeat
	(* display the current value *)
	    start_line_with_index(offset);
	    add_next_word(offset, disk_block.data);
	    format.skip(3);
	    user_terminal.write_format_buffer(format.buffer);
	(* change the value *)
	    freeword_utility.prompt_cud_word(scanned, value);
	    if user_terminal.sendable
	    then
	      with disk_block do
	        begin
		  data[offset] := value[0];
		  data[offset + 1] := value[1];
		  data[offset + 2] := value[2];
		  data[offset + 3] := value[3];
		  if offset < (MAXIMUM_CUD_DATA - MAXIMUM_BYTES_IN_WORD)
		  then offset := offset + MAXIMUM_BYTES_IN_WORD
		  else done := TRUE
	        end
	      else done := TRUE
	  until done;
$if BEFORE_SUP_V43	  store_buffer(CUD_MUD_BUFFER_LOCATION,
$ifnone BEFORE_SUP_V43	      store_cud_buffer(
 	    cud_info.block, disk_block, cud_info, success)
	end
    end
end (* change_cud *);
!
"
		COMPARE Command
"


(***********************  command_level_utility  ************************)
(*									*)
(*				compare 				*)
(*									*)
(************************************************************************)

procedure entry COMPARE(
  var scanned	: scanned_command);

var
  cud_buffer,
$if BEFORE_SUP_V43  mud_buffer : cud_disk_block;
$ifnone BEFORE_SUP_V43  mud_buffer : cud_data_block;
  success : boolean;
  done,
  match : boolean;
  index : cud_data_index;

begin
  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    begin
$if BEFORE_SUP_V43      restore_buffer(TRUE,
$ifnone BEFORE_SUP_V43    restore_cud_buffer(
        cud_buffer, success);
      if success
      then restore_buffer(
$if BEFORE_SUP_V43       FALSE, mud_buffer,
$ifnone BEFORE_SUP_V43      mud_buffer.data.mud_block,
	success);
      if success
      then
	begin
	  match := TRUE; done := FALSE;
	  index := 0;
	  repeat (* compare buffer words *)
$if BEFORE_SUP_V43
	    if (cud_buffer.data[index] <> mud_buffer.data[index]) or
	       (cud_buffer.data[index+1] <> mud_buffer.data[index+1]) or
	       (cud_buffer.data[index+2] <> mud_buffer.data[index+2]) or
	       (cud_buffer.data[index+3] <> mud_buffer.data[index+3])
$endif BEFORE_SUP_V43
$ifnone BEFORE_SUP_V43
	    if (cud_buffer.data.mud_block.data[index] <>
		mud_buffer.data.mud_block.data[index]) or
	       (cud_buffer.data.mud_block.data[index+1] <>
	       mud_buffer.data.mud_block.data[index+1]) or
	       (cud_buffer.data.mud_block.data[index+2] <>
	       mud_buffer.data.mud_block.data[index+2]) or
	       (cud_buffer.data.mud_block.data[index+3] <>
	       mud_buffer.data.mud_block.data[index+3])
$endif BEFORE_SUP_V43
	    then
	      begin
		if match
		then
		  begin
		    user_terminal.write_quoted_text_line(
		      'byte      CUD         MUD\');
		    match := FALSE
		  end (* first mismatch found *);
	(* type out the buffer difference *)
		start_line_with_index(index);
		add_next_word(index, cud_buffer.data);
		format.skip(3);
		add_next_word(index, mud_buffer.data);
		format.write_line(user_terminal)
	      end (* mismatch found *);
$if BEFORE_SUP_V43	    if index < (MAXIMUM_CUD_DATA -
$ifnone BEFORE_SUP_V43	    if index < (MAXIMUM_MUD_DATA -
	      MAXIMUM_BYTES_IN_WORD)
	    then index := index + MAXIMUM_BYTES_IN_WORD
	    else done := TRUE
	  until not user_terminal.sendable or done;
	  if match
	  then user_terminal.write_quoted_text_line('no differences\ ')
	end (* success *)
    end (* scanned.status = CMD_OK *)
end (* compare *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if prevent_duplicate_passwords
!
"
		DISPLAY PASSPERIOD Command
"

(************************  command_level_utility  ***********************)
(*									*)
(*			  display_passperiod				*)
(*									*)
(************************************************************************)

procedure entry DISPLAY_PASSPERIOD;

begin
  format.start_message(THE_MINIMUM_PASSWORD_CHANGE_TIME_MESSAGE);
  format.string('is \');
  format.number(
    mud_change.minimum_password_change_time_in_seconds div SECONDS_PER_DAY,10);
  format.string(DAYS_MESSAGE);
  format.write_line(user_terminal)
end (* display_passperiod *);
$endif prevent_duplicate_passwords
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
"
		DISPLAY SELECT Command
"

(************************  command_level_utility  ***********************)
(*									*)
(*			  do_display_select				*)
(*									*)
(*	Displays current criteria to calling process.			*)
(*									*)
(************************************************************************)

procedure do_display_select;

var
  criteria_index 	: criteria_type;
  first_option  	: boolean;
$if BEFORE_SUP_V43   option_index		: criteria_control_options;
$ifnone BEFORE_SUP_V43
  option_index	: mud_criteria_control_options;
  nud_option_index	: nud_criteria_control_options;
  access_option_index	: access_criteria_control_options;
$endif BEFORE_SUP_V43

begin
  if criteria.used[all_criteria]
  then user_terminal.write_quoted_text_line('All users are selected\ ')
  else
    begin
      user_terminal.write_quoted_text_line(
        'User selection is based on the following: \ ');
      for criteria_index := ACCESS_CRITERION to PASSWORDDATE_CRITERION do
	if criteria.used[criteria_index]
	then
	  begin
	    format.start;
	    format.criteria_name(criteria_index);
	    format.skip_to(14);
	    case criteria_index of
	      ACCESS_CRITERION,
	      GAN_CRITERION,
	      DISTRICT_CRITERION,
	      UUN_CRITERION:
$ifnot BEFORE_SUP_V43
		if (criteria_index = ACCESS_CRITERION) and
		  (criteria.access_type = CONTROL_ACCESS)
		then
		  begin
		    format.string('control \ ');
		    first_option := TRUE;
		    for access_option_index :=
		      FIRST_ACCESS_CRITERIA_CONTROL_OPTION to
		        LAST_ACCESS_CRITERIA_CONTROL_OPTION do
		      if criteria.access_control[access_option_index]
		      then
		        begin
		          if first_option
		          then first_option := FALSE
		          else
		            begin
			      format.write_line(user_terminal);
			      format.start;
			      format.skip_to(22)
		            end (* not first_option *);
		          format.access_control_option_name(
			    access_option_index)
		        end (* criteria.access_control[access_option_index *)
		  end (* access_criterion and control_access *)
	  	else
$endif BEFORE_SUP_V43
	        begin
		  if criteria_index = ACCESS_CRITERION
		  then
		    case criteria.access_type of
		      HOST_ACCESS:
		        begin
			  format.string(HOST_MESSAGE);
			  format.character(ASCII_SPACE)
			end (* HOST_ACCESS *);
		      NODE_ACCESS:
		        begin
			  format.string(NODE_MESSAGE);
			  format.character(ASCII_SPACE)
			end (* NODE_ACCESS *);
		      CLASS_ACCESS: format.string(CLASS_MESSAGE);
		      GROUP_ACCESS: format.string(GROUP_MESSAGE)
		    end (* case *);
		  format.number_range(
		    criteria.range_criteria[criteria_index].first,
		    criteria.range_criteria[criteria_index].last,
		    criteria_value_radix(criteria_index, criteria.access_type))
		end (* ACCESS, GAN, DISTRICT, UUN *);
	      CONTROL_CRITERION:
	        begin
		  first_option := TRUE;
$if BEFORE_SUP_V43
		  for option_index := FIRST_CRITERIA_CONTROL_OPTION to
		    LAST_CRITERIA_CONTROL_OPTION do
$endif BEFORE_SUP_V43
$ifnone BEFORE_SUP_V43
		  for option_index := FIRST_MUD_CRITERIA_CONTROL_OPTION to
		    LAST_MUD_CRITERIA_CONTROL_OPTION do
$endif BEFORE_SUP_V43
		  if criteria.control[option_index]
		  then
		    begin
		      if first_option
		      then first_option := FALSE
		      else
		        begin
			  format.write_line(user_terminal);
			  format.start;
			  format.skip_to(14)
			end (* not first_option *);
		      format.control_option_name(option_index)
		    end (* criteria.control[option_index] *);
$ifnone BEFORE_SUP_V43
		  if criteria.access_control[SHUT_OVERRIDE]
		  then
		    begin
		      if first_option
		      then first_option := FALSE
		      else
		        begin
			  format.write_line(user_terminal);
			  format.start;
			  if criteria_index = CONTROL_CRITERION
			  then format.skip_to(14)
			  else format.skip_to(22)
			end (* not first_option *);
		      format.access_control_option_name(SHUT_OVERRIDE)
		    end;
		  for nud_option_index := FIRST_NUD_CRITERIA_CONTROL_OPTION to
		    LAST_NUD_CRITERIA_CONTROL_OPTION do
		  if criteria.nud_control[nud_option_index]
		  then
		    begin
		      if first_option
		      then first_option := FALSE
		      else
		        begin
			  format.write_line(user_terminal);
			  format.start;
			  format.skip_to(14)
			end (* not first_option *);
		      format.nud_control_option_name(nud_option_index)
		    end (* criteria.nud_control[option_index] *);
$endif BEFORE_SUP_V43
		end (* CONTROL_CRITERION *);
	      ENTRYDATE_CRITERION,
$ifany (force_password_change, password_expiration_by_user)
 	      EXPIREDATE_CRITERION,
$endif (force_password_change, password_expiration_by_user)
	      PASSWORDDATE_CRITERION:
	        with criteria.date_criteria[criteria_index] do
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if NETVAL_IS_A_SLAVE
		  if qualifier = GFD_ONLY_DATE
		  then format.string(GFD_ONLY_MESSAGE)
		  else
$endif NETVAL_IS_A_SLAVE
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
		      begin (* not GFD_ONLY_DATE *)
		        if qualifier = BEFORE_DATE
		        then format.string('before \')
		        else
		          if qualifier = AFTER_DATE
			  then format.string('after \ ');
		        format.date(time * SECONDS_PER_DAY);
		    end (* not GFD_ONLY_DATE *)
	      end (* case *);
	    format.write_line(user_terminal)
	  end (* criteria.used *)
    end (* not selecting all users *)
end (* do_display_select *);



(***********************  command_level_utility  ************************)
(*									*)
(*			     display_select				*)
(*									*)
(************************************************************************)

procedure entry DISPLAY_SELECT;

begin
  do_display_select  
end (* display_select *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if password_expiration_by_user
!
"
		DISPLAY VALIDITY Command
"

(************************  command_level_utility  ***********************)
(*									*)
(*			      display_validity				*)
(*									*)
(************************************************************************)

procedure entry DISPLAY_VALIDITY;

begin
  format.start_message(THE_STANDARD_PASSWORD_VALIDITY_PERIOD_MESSAGE);
  format.string('is \');
  format.number(
    mud_change.standard_password_validity_in_seconds div SECONDS_PER_DAY, 10);
  format.string(DAYS_MESSAGE);
  format.write_line(user_terminal)
end (* display_validity *);
$endif password_expiration_by_user
$if force_password_change
"$if allow_global_password_expire"
!



(**********************  command_level_utility  *************************)
(*									*)
(*  Name:	display_ganpass						*)
(*									*)
(*  Purpose:	display designated gan(s) and associated password	*)
(*		validity period(s)					*)
(*									*)
(************************************************************************)

procedure entry DISPLAY_GANPASS(
  var scanned		: scanned_command);

var
  target_entry		: integer;
  target_gan		: integer;
  found_gan		: integer;
  found_passlife	: integer;
  available_entries	: integer;
  found			: boolean;
  done			: boolean;
  gan_count		: integer;
  gan_tba		: integer;
$if request_fpc_start   start		: integer;
$ifnone reuse_uuns  uun_tba : integer;
$if reuse_uuns
  bit17_usable_uuns : integer;
  bit18_usable_uuns : integer;
  usable_add_back_slots : integer;
$endif reuse_uuns

begin
  found_passlife := 0;
  param_manager.next_gan_and_uun(gan_tba,
$ifnone reuse_uuns	uun_tba);
$if reuse_uuns	bit17_usable_uuns, bit18_usable_uuns,usable_add_back_slots);
  if gan_tba > 1 then
  begin
  if scanned.freeword_count = 1 (* target gan on command line *)
"$if allow_global_password_expire"
"if argument_scan.check_keyword(PRIMARY_DISPLAY_VALIDITY_GAN_KEYWORD, scanned)"
"$endif allow_global_password_expire"
  then 
    begin (* display designated gan's passlife *)
      freeword_utility.get_numeric_freeword_value(0, 8, 1,
	    			gan_tba-1, scanned, target_gan);
      argument_scan.extra_argument_check(scanned);

      if scanned.status = CMD_OK
      then
        begin (* fetch one gan's passlife from pasmon *)
	  found := FALSE;
  	  format.start_message(PASSWORD_VALIDITY_PERIOD_MESSAGE);
	  format.skip(-1);
	  format.colon_space;
	  pasmon.fetch_ganpass(target_gan, found_passlife,
$if request_fpc_start		start,
	    found);
	  if found 
	  then 
	    begin
	      format.number(found_passlife, 10);
	      format.string(DAYS_MESSAGE);
$if request_fpc_start
	      format.string(' effective: \ ');
	      format.date(start);
$endif request_fpc_start
	    end
	  else format.string('infinite\ ');
          format.write_line(user_terminal)
        end (* fetch one gan's passlife from pasmon *)
    end (* display designated gan's passlife *);
  
"$if allow_global_password_expire    else"
  if scanned.freeword_count = 0
  then
    begin (* display all gan passlife definitions *)
      argument_scan.extra_argument_check(scanned);

      if scanned.status = CMD_OK
      then
        begin (* display whole ganpass table *) 
          format.start_message('entries available: \');
          pasmon.fetch_remaining_entries(available_entries);
          format.number(available_entries, 10);
          format.write_line(user_terminal);
          if available_entries = NUMBER_OF_PASSTABLE_ENTRIES
          then user_terminal.write_line_and_quoted_text_line(
	    'There are no GANPASS definitions\ ')
          else
	    begin (* display all passlife definitions *)
$ifnot request_fpc_start
	      user_terminal.write_line_and_quoted_text_line(
	        '    GAN        PASSLIFE\');
$endif request_fpc_start
$if request_fpc_start
	      user_terminal.write_line_and_quoted_text_line(
	        '    GAN        PASSLIFE    EFFECTIVE DATE\');
$endif request_fpc_start
	      done := FALSE; target_entry := 0; gan_count := 0;
	      while (not done) and (user_terminal.sendable) do
	        begin (* fetch a passtable entry *)
		  found := false;
	          pasmon.fetch_sequential_ganpass_entry(target_entry,
		    found_gan, found_passlife,
$if request_fpc_start			start,
		    found);
       	          if found 
	          then
      	            begin (* display a gan and its passlife *)
		      gan_count := gan_count + 1;
		      format.start;
		      format.skip(4);
	              format.number(found_gan, 8);
	              format.skip_to(16);
	              format.number(found_passlife, 10);
$if request_fpc_start
		      format.skip_to(30);
		      format.date(start);
$endif request_fpc_start
	              format.write_line(user_terminal)
      	            end (* display a gan and its passlife *);
	            if target_entry = NUMBER_OF_PASSTABLE_ENTRIES 
	            then done:= TRUE
	            else target_entry := target_entry + 1
	        end  (* fetch a passtable entry *)
$if global_password_only_login
    ;
		if gan_count = 0
		then user_terminal.write_line_and_quoted_text_line(
'no GANPASS defined in Passtable, check GPOGAN for data\ ')
$endif global_password_only_login
            end (* display whole ganpass table *)
	end (* display all passlife definitions *)
    end (* display all gan passlife definitions *)
  end (* gan_tba > 1 *)
  else user_terminal.write_quoted_text_line(
    'empty cud parameter - cannot display ganpass\ ')
end (* display_ganpass *);
$endif force_password_change
"$endif allow_global_password_expire"
$if global_password_only_login



(**********************  command_level_utility  *************************)
(*									*)
(*  Name:	display_gpogan						*)
(*									*)
(*  Purpose:	display gan(s) which are eligible for 			*)
(*		global_password_only_login			 	*)
(*									*)
(************************************************************************)

procedure entry DISPLAY_GPOGAN(
  var scanned		: scanned_command);

var
  target_entry		: integer;
  target_gan		: integer;
  found_gan		: integer;
  available_entries	: integer;
  gan_count		: integer;
  found			: boolean;
  done 			: boolean;
  gan_tba		: integer;
$ifnone reuse_uuns  uun_tba : integer;
$if reuse_uuns
  bit17_usable_uuns : integer;
  bit18_usable_uuns : integer;
  usable_add_back_slots : integer;
$endif reuse_uuns

begin
  param_manager.next_gan_and_uun(gan_tba,
$ifnone reuse_uuns	uun_tba);
$if reuse_uuns	bit17_usable_uuns, bit18_usable_uuns,usable_add_back_slots);
  if gan_tba > 1
  then
  begin 

  if scanned.freeword_count = 1 (* target gan on command line *)
  then 
    begin (* display designated gan's eligibility status *)
      freeword_utility.get_numeric_freeword_value(0, 8, 1,
	    			 gan_tba -1, scanned, target_gan);
      argument_scan.extra_argument_check(scanned);
      if scanned.status = CMD_OK
      then
        begin (* check if designated gan is eligible *)
	  found := FALSE;
  	  format.start_message( 'GPO access\ ');
	  pasmon.fetch_gpogan(target_gan, found);
	  if found 
	  then format.string(' approved\')
	  else format.string(' denied\');
          format.write_line(user_terminal)
        end (* check if designated gan is eligible *)
    end (* display designated gan's passlife *)
  else
  if scanned.freeword_count = 0
  then
    begin (* display all defined global_password_only_login gans *)
      argument_scan.extra_argument_check(scanned);
      if scanned.status = CMD_OK
      then
	begin (* display all global_password_only_login gan definitions *)
          format.start_message ('entries available: \');
          pasmon.fetch_remaining_entries(available_entries);
          format.number(available_entries, 10);
          format.write_line(user_terminal);
          if available_entries = NUMBER_OF_PASSTABLE_ENTRIES
          then user_terminal.write_line_and_quoted_text_line(
	    'There are no GPOGAN definitions\')
          else
	    begin (* display all gpo gans*)
	      user_terminal.write_line_and_quoted_text_line(
	        'GPO eligible GANs\');
	      done := FALSE;
	      target_entry := 0;
	      gan_count := 0;
	      while (not done) and (user_terminal.sendable) do
	        begin (* fetch a passtable entry *)
		  found := false;
	          pasmon.fetch_sequential_gpogan_entry(target_entry, found_gan,
									found);
       	          if found 
	          then
      	            begin (* display a gpo gan *)
		      gan_count := gan_count + 1;
		      format.start;
		      format.skip(6);
	              format.number(found_gan, 8);
	              format.write_line(user_terminal)
      	            end (* display a gpo gan *);
	            if target_entry = NUMBER_OF_PASSTABLE_ENTRIES
	            then done:= TRUE
	            else target_entry := target_entry + 1
	        end (* fetch a passtable entry *)
$if force_password_change
	;
	      if gan_count = 0
	      then user_terminal.write_line_and_quoted_text_line(
'no GPOGAN defined in Passtable, check GANPASS for data\ ')
$endif force_password_change
	    end (* display all gpo gans*)
	end (* display all global_password_only_login gan definitions *)
    end (* display all defined global_password_only_login gans *)
  end (* tab_gan > 1*)
  else user_terminal.write_quoted_text_line(
	'empty cud parameter - cannot display gpogan\')
end (* display_gpogan *);
$endif global_password_only_login
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
"
		DISPLAY DIRECTORY Command
"



(************************  command_level_utility  ***********************)
(*									*)
(*				control_check				*)
(*									*)
(*	if options do not match the control_criterion,			*)
(*	select_user is set to FALSE					*)
(*									*)
(************************************************************************)

procedure control_check(
$if BEFORE_SUP_V43      options	: user_options;
$ifnone BEFORE_SUP_V43
      mud_options	: mud_user_options;
      options	: nud_user_options;
$endif BEFORE_SUP_V43
  var select_user	: boolean);

var
  licensed_user	: boolean;
  done		: boolean;
$ifnone BEFORE_SUP_V43
  option_index	: mud_control_options_range;
  nud_option_index  : nud_control_options_range;
$endif BEFORE_SUP_V43
$if BEFORE_SUP_V43   option_index	: control_options;

begin
  done := FALSE;
$ifnone BEFORE_SUP_V43
  nud_option_index := FIRST_NUD_CONTROL_OPTION_TO_PRINT;
  repeat
    if criteria.nud_control[nud_option_index]
    then
      if not (nud_option_index in options)
      then select_user := FALSE;
    if nud_option_index = LAST_NUD_CONTROL_OPTION_TO_PRINT
    then done := TRUE
    else nud_option_index := succ(nud_option_index)
  until done or not select_user;
  done := FALSE;
$endif BEFORE_SUP_V43
$if BEFORE_SUP_V43   option_index := FIRST_CUD_CONTROL_OPTION_TO_PRINT;
$ifnone BEFORE_SUP_V43   option_index := FIRST_MUD_CONTROL_OPTION;
  repeat
    if criteria.control[option_index]
    then
      if not (option_index in
$if BEFORE_SUP_V43       options)
$ifnone BEFORE_SUP_V43     mud_options)
      then select_user := FALSE;
    if option_index =
$if BEFORE_SUP_V43     LAST_CUD_CONTROL_OPTION_TO_PRINT
$ifnone BEFORE_SUP_V43     LAST_MUD_CONTROL_OPTION
    then done := TRUE
    else option_index := succ(option_index)
  until done or not select_user;
  if select_user
  then
    begin
      licensed_user := (ACCOUNT_SUPERVISOR in options) or
       (NETWORK_ADMINISTRATOR in options);
$if BEFORE_SUP_V43      if criteria.control[LICENSED] = TRUE
$ifnone BEFORE_SUP_V43      if criteria.nud_control[LICENSED] = TRUE
      then select_user := licensed_user
      else
$if BEFORE_SUP_V43    if criteria.control[PASSWORD_ONLY]
$ifnone BEFORE_SUP_V43     if criteria.nud_control[PASSWORD_ONLY]
	then select_user := not licensed_user
    end (* select_user *)
end (* control_check *);



(***********************  command_level_utility *************************)
(*									*)
(*				format_time				*)
(*									*)
(*	Takes time in minutes and formats to HH:MM			*)
(*									*)
(************************************************************************)

procedure format_time(
      time	: integer);

begin
  format.format_number(time div 60, 10, -2);
  format.character(ASCII_COLON);
  format.format_number(time mod 60, 10 , -2)
end (* format_time *);


(**********************  command_level_utility  *************************)
(*									*)
(*  Name:	display_schedule					*)
(*									*)
(*  Purpose:	display all process schedules				*)
(*									*)
(************************************************************************)

procedure entry DISPLAY_SCHEDULE(
  var scanned		: scanned_command);

var
  enabled	: boolean;
  start_time	: integer;
  end_time	: integer;

begin (* display_schedule *)
  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    begin (* output schedules *);
      mud_change.fetch_consistency_schedule(enabled, start_time, end_time);
      if enabled
      then
	begin (* display consistency run time *)
          format.start_message('CONSISTENCY period: \ ');
          format_time(start_time);
          format.string(' to \ ');
          format_time(end_time);
          format.write_line(user_terminal)
	end (* display consistency run time *)
      else user_terminal.write_quoted_text_line(
        CONSISTENCY_DEACTIVATED_MESSAGE)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if force_password_change
;
      mud_change.fetch_passchanger_schedule(enabled, start_time);
      if enabled
      then
	begin (* display passchanger run time *)
          format.start_message('PASSCHANGER starts: \ ');
          format_time(start_time);
          format.write_line(user_terminal)
	end (* display passchanger run time *)
      else user_terminal.write_quoted_text_line(
        PASSCHANGER_DEACTIVATED_MESSAGE)
$endif force_password_change
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
;
$if reuse_uuns
      mud_change.fetch_uun_merge_schedule(enabled, start_time);
      if enabled
      then
	begin (* display uun merge run time *)
          format.start_message('UUN MERGE starts: \ ');
          format_time(start_time);
          format.write_line(user_terminal)
	end (* display uun merge run time *)
      else user_terminal.write_quoted_text_line(UUN_MERGE_DEACTIVATED_MESSAGE)
$endif reuse_uun
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    end (* output schedules *)
end (* display_schedule *);



(************************  command_level_utility  ***********************)
(*									*)
(*				date_check				*)
(*									*)
(*	if a match does not occur between the cud_value and the 	*)
(*	  criteria date value, select_user returns FALSE		*)
(*									*)
(************************************************************************)

procedure date_check(
      date_index	: date_criteria_index;
$if BEFORE_SUP_V43      cud_entry		: cud_user_entry;
$ifnone BEFORE_SUP_V43
      mud_entry		: mud_user_entry;
      nud_entry		: nud_user_entry;
$endif BEFORE_SUP_V43
  var select_user	: boolean);

var
  cud_value	: integer;
  found		: boolean;
$if force_password_change
  expiredate	: integer;
  passlife	: integer;
$endif force_password_change

begin (* date_check *)
  select_user := TRUE;
  case date_index of
    PASSWORDDATE_CRITERION:
$ifnone BEFORE_SUP_V43       cud_value := nud_entry.password_change_date;
$if BEFORE_SUP_V43       cud_value := cud_entry.password_change_date;

    ENTRYDATE_CRITERION:
$ifnone BEFORE_SUP_V43       cud_value := nud_entry.entry_change_date
$if BEFORE_SUP_V43       cud_value := cud_entry.entry_change_date
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if password_expiration_by_user
;

    EXPIREDATE_CRITERION:
      if mud_entry.password.expire_date = 0
      then select_user := FALSE
      else cud_value := mud_entry.password.expire_date
$endif password_expiration_by_user
$if force_password_change
;

    EXPIREDATE_CRITERION:
      begin (* fetch user's password expiredate, if it has one *)
	pasmon.fetch_expiredate(
$if BEFORE_SUP_V43         cud_entry.gan, cud_entry.password_change_date,
$ifnot BEFORE_SUP_V43      nud_entry.gan, nud_entry.password_change_date,
					expiredate, passlife, found);
	if found and not (FPC_EXEMPT in
$if BEFORE_SUP_V43            cud_entry.options) and
$ifnot BEFORE_SUP_V43            nud_entry.nud_options) and
	  not (NO_PASSWORD_REQUIRED in
$if BEFORE_SUP_V43            cud_entry.options)
$ifnot BEFORE_SUP_V43             mud_entry.mud_options)
	then cud_value := expiredate
	else select_user := FALSE
      end (* fetch user's password expiredate, if it has one *)
$endif force_password_change
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  end (* case of date_index *);

  if select_user
  then 
    begin (* work with criteria.date_criteria[date_index] *)
      with criteria.date_criteria[date_index] do
        case qualifier of
          AFTER_DATE:
	    if cud_value div SECONDS_PER_DAY <= time
	    then select_user := FALSE;
          BEFORE_DATE:
	    if cud_value div SECONDS_PER_DAY >= time
	    then select_user := FALSE;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if NETVAL_IS_A_SLAVE
          GFD_ONLY_DATE:
            if cud_value <> GFD_ONLY_PASSWORD_DATE
	    then select_user := FALSE;
$endif NETVAL_IS_A_SLAVE
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
          NO_DATE_QUALIFIER:
	    if cud_value div SECONDS_PER_DAY <> time
	    then select_user := FALSE
        end (* case *)
      end (* work with criteria.date_criteria[date_index] *)
end (* date_check *);



(************************  command_level_utility  ***********************)
(*									*)
(*				range_check				*)
(*									*)
(*	If a match occurs between the cud_value and the criteria	*)
(*	match returns TRUE						*)
(*									*)
(************************************************************************)

procedure range_check(
      range_index	: range_criteria_index;
      cud_value		: integer;
  var match		: boolean);

begin
  if criteria.range_criteria[range_index].first =
    criteria.range_criteria[range_index].last
  then (* test cud value against a single number *)
    match := criteria.range_criteria[range_index].first = cud_value
  else (* test cud value against a range *)
    match := (criteria.range_criteria[range_index].first <= cud_value) and
       (criteria.range_criteria[range_index].last  >= cud_value)
end (* range_check *);



(************************  command_level_utility  ***********************)
(*									*)
(*			     destination_check				*)
(*									*)
(*	searchs user's destination list for criteria value		*)
(*									*)
(************************************************************************)

procedure destination_check(
      destination_to_check	: destination_description;
  var access_match		: boolean);

var
  end_of_list 	: boolean;
  index		: destination_index;

begin
  end_of_list := FALSE;
  index := 0;
  repeat (* cycle thru list within entry *)
    with destination_to_check, list[index] do
      begin
	if (group_flag and (criteria.access_type = GROUP_ACCESS)) or
	   (not group_flag and (criteria.access_type = HOST_ACCESS))
	then range_check(ACCESS_CRITERION, value, access_match);
	if index = size - 1
	then end_of_list := TRUE
	else index := index + 1
      end (* with *)
  until access_match or end_of_list
end (* destination_check *);



(************************  command_level_utility  ***********************)
(*									*)
(*				access_search				*)
(*									*)
(*	select_user returns TRUE if access_profile contains an		*)
(*	occurrence of the value specified by access profile criterion 	*)
(*									*)
(************************************************************************)

procedure access_search(
      user_access	: access_profile_description;
  var select_user	: boolean);

var
  profile_index		: access_entry_index;
  access_match		: boolean;
  end_of_profile	: boolean;
  origin_list_index	: in_place_origin_index;
  end_of_list		: boolean;
  host_value_criterion	: boolean;
$ifnone BEFORE_SUP_V43
  done			: boolean;
  access_option_index   : access_control_options_range;
  options		: access_user_options;
$endif BEFORE_SUP_V43

begin
  profile_index := 0; end_of_profile := FALSE;
  access_match := FALSE;
  host_value_criterion := criteria.access_type = HOST_ACCESS;
  repeat (* search profile entries *)
    case criteria.access_type of
      CLASS_ACCESS:
	with user_access.entries[profile_index] do
	  if not in_place_origin
 	  then range_check(ACCESS_CRITERION, class_no, access_match);

		    (* cycle thru destination list within entry *)

$ifnone BEFORE_SUP_V43
      CONTROL_ACCESS:
	begin
	  cud_entry_util.unpack_access_options(
            user_access.entries[profile_index].access_control, options);
  	  done := FALSE; access_match := TRUE;
          access_option_index := FIRST_ACCESS_CONTROL_OPTION;
          repeat
            if criteria.access_control[access_option_index]
            then
              if not (access_option_index in options)
              then access_match := FALSE;
            if access_option_index = LAST_ACCESS_CONTROL_OPTION
            then done := TRUE
            else access_option_index := succ(access_option_index)
          until done or not (access_match)
	end (* control_access *);

$endif BEFORE_SUP_V43
      GROUP_ACCESS: destination_check(
	user_access.entries[profile_index].destination, access_match);

      NODE_ACCESS,
      HOST_ACCESS:
        begin
	  origin_list_index := 0; end_of_list := FALSE;
	  if user_access.entries[profile_index].in_place_origin
	  then
	    repeat (* search thru origin list within entry *)
	      with user_access.entries[profile_index].origin,
	        list[origin_list_index] do
	        begin
		  if (host_flag and host_value_criterion) or
		    (not host_flag and not host_value_criterion)
		  then range_check(ACCESS_CRITERION, value, access_match);
		  if origin_list_index = size - 1
		  then end_of_list := TRUE
		  else origin_list_index := origin_list_index + 1
		end (* with *)
	    until access_match or end_of_list;

	  if host_value_criterion and not access_match (* host_access only *)
	  then destination_check( (* search thru dest list within entry *)
	    user_access.entries[profile_index].destination, access_match)
        end (* node, host_access *)
    end (* case *);
    if profile_index = user_access.count - 1
    then end_of_profile := TRUE
    else profile_index := profile_index + 1
  until access_match or end_of_profile;
  select_user := access_match
end (* access_search *);



(************************  command_level_utility  ***********************)
(*									*)
(*			  user_passes_criteria 				*)
(*									*)
(*	Returns TRUE if user passes all used criteria			*)
(*									*)
(************************************************************************)

function user_passes_criteria(
$if BEFORE_SUP_V43      cud_entry		: cud_user_entry) : boolean;
$ifnone BEFORE_SUP_V43
      mud_entry		: mud_user_entry;
      nud_entry		: nud_user_entry) : boolean;
$endif BEFORE_SUP_V43

var
  select_user,
  end_of_criteria	: boolean;
  cud_value		: integer;
  criteria_index	: criteria_type;

begin
  select_user := TRUE;
  end_of_criteria :=  FALSE;
  criteria_index := ACCESS_CRITERION;
  if not criteria.used[ALL_CRITERIA]
  then
    repeat
      if criteria.used[criteria_index]
      then
	begin
	  if (criteria_index <= UUN_CRITERION) and
	     (criteria_index >= GAN_CRITERION)
	  then
	    begin
	      case criteria_index of
		GAN_CRITERION: cud_value := 
$ifnone BEFORE_SUP_V43	    	nud_entry.gan;
$if BEFORE_SUP_V43	    	cud_entry.gan;
		UUN_CRITERION: cud_value :=
$ifnone BEFORE_SUP_V43 			mud_entry.uun;
$if BEFORE_SUP_V43 			cud_entry.uun;
		DISTRICT_CRITERION: cud_value :=
$ifnone BEFORE_SUP_V43			nud_entry.district
$if BEFORE_SUP_V43			cud_entry.district
	      end (* case *);
	      range_check(criteria_index,cud_value,select_user)
	    end (* (criteria_index <= UUN) and (criteria_index >= GAN) *)
	  else
	    case criteria_index of
	      ACCESS_CRITERION: access_search(
$ifnone BEFORE_SUP_V43		mud_entry.mud_access_profile,
$if BEFORE_SUP_V43		cud_entry.access_profile,
	        select_user);
	      CONTROL_CRITERION: 
$if BEFORE_SUP_V43              control_check(cud_entry.options, select_user);
$ifnot BEFORE_SUP_V43
		begin
		  control_check(mud_entry.mud_options, nud_entry.nud_options,
		    select_user);
		  if select_user and criteria.access_control[SHUT_OVERRIDE]
		  then access_search(mud_entry.mud_access_profile, select_user)
		end (* CONTROL_CRITERION *);
$endif BEFORE_SUP_V43
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifany (force_password_change, password_expiration_by_user)
 	      EXPIREDATE_CRITERION,
$endif (force_password_change, password_expiration_by_user)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	      PASSWORDDATE_CRITERION,
	      ENTRYDATE_CRITERION: date_check(criteria_index,
$ifnot BEFORE_SUP_V43               mud_entry, nud_entry,
$if BEFORE_SUP_V43		 cud_entry,
	        select_user)
	    end (* case *)
	end (* (criteria_index <= UUN) and (criteria_index >= GAN) *);
      if criteria_index = PASSWORDDATE_CRITERION
      then end_of_criteria := TRUE
      else criteria_index := succ(criteria_index)
    until not select_user or end_of_criteria;
  user_passes_criteria := select_user
end (* user_passes_criteria *);



(************************  command_level_utility  ***********************)
(*									*)
(*				display_fields				*)
(*									*)
(*	Writes out selected cud entry fields				*)
(*									*)
(************************************************************************)

procedure display_fields(
      selected_fields	: designated_fields;
$if BEFORE_SUP_V43      cud_entry	: cud_user_entry);
$ifnone BEFORE_SUP_V43
      cud_flag		: boolean;
      mud_entry		: mud_user_entry;
      nud_entry		: nud_user_entry);
$endif BEFORE_SUP_V43

begin
  do_format_user_data(selected_fields,
$if BEFORE_SUP_V43    cud_entry);
$ifnone BEFORE_SUP_V43     cud_flag, mud_entry, nud_entry);
  if selected_fields[ALL_FIELDS]
  then
    begin
      format.write_line(user_terminal);
      format.start
    end (* selected_fields[ALL_FIELDS] *);
$ifnot BEFORE_SUP_V43  if cud_flag then
  do_format_change_dates(selected_fields,
$if BEFORE_SUP_V43     cud_entry);
$ifnone BEFORE_SUP_V43    mud_entry, nud_entry);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if restrict_users_by_time
  if selected_fields[TIMERESTRICT_FIELD] or selected_fields[ALL_FIELDS]
  then
    begin
      format.character(ASCII_SPACE);
      if not (ALL_HOURS in mud_entry.allowable_times)
      then do_write_allowable_hours(mud_entry.allowable_times)
    end;
$endif restrict_users_by_time
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  format.write_line(user_terminal);
  if selected_fields[ACCESS_FIELD] or selected_fields[ALL_FIELDS]
  then do_write_access_profile(
$ifnone BEFORE_SUP_V43    mud_entry.mud_access_profile, TRUE)
$if BEFORE_SUP_V43    cud_entry.access_profile, TRUE)
end (* display_fields *);



(*********************  command_level_utility  **************************)
(*									*)
(*			     write_cud_header				*)
(*									*)
(*	Write the CUD header for all fields or specified fields		*)
(*									*)
(************************************************************************)

procedure write_cud_header(
$ifnot BEFORE_SUP_V43      cud_flag	: boolean (* FALSE if MUD data *);
      selected_fields	: designated_fields);

var
  field_index : fields;

begin
  format.start_message('USERNAME             \');
  for field_index := FIRST_SPECIFIC_FIELD to LAST_FIELD do
    if selected_fields[field_index] or selected_fields[ALL_FIELDS]
    then
      case field_index of
	UUN_FIELD: format.string('        UUN \ ');
	GAN_FIELD: if INCLUDE_GAN
$ifnot BEFORE_SUP_V43			and cud_flag
		   then format.string('        GAN \ ');
	DISTRICT_FIELD: if INCLUDE_DISTRICT
$ifnot BEFORE_SUP_V43			and cud_flag
			then format.string(' DIST\');
	CONTROL_FIELD: format.string('  CONTROL          \');
	PASSWORDDATE_FIELD:
$ifnot BEFORE_SUP_V43
	if not cud_flag
	then
	  begin (* outputting MUD info *)
	    format.write_line(user_terminal);
	    format.start
	  end (* outputting MUD info *)
	else
$endif BEFORE_SUP_V43
	  begin
	    if selected_fields[ALL_FIELDS]
	    then
	      begin
	        format.write_line(user_terminal);
		format.start_message('PASSWORD\ ')
	      end
	    else format.string(' PASSWORD\')
	  end (* PASSWORDDATE_FIELD *);
	ENTRYDATE_FIELD:
$ifnot BEFORE_SUP_V43		if cud_flag then
	  format.string('  ENTRY  \');
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifany (force_password_change, password_expiration_by_user)
 	EXPIREDATE_FIELD:
$ifnot BEFORE_SUP_V43		if cud_flag then
	  format.string('   EXPIRE\');
$endif (force_password_change, password_expiration_by_user)
$if restrict_users_by_time
	TIMERESTRICT_FIELD: format.string('  LOGIN HOURS\');
$endif restrict_users_by_time
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	ACCESS_FIELD: format.string('(:13:)(:10:)   ACCESS\')
      end (* case *);
  format.write_line(user_terminal);
  user_terminal.write_newline
end (* write_cud_header *);



(************************  command_level_utility  ***********************)
(*									*)
(*			      get_next_page				*)
(*									*)
(*									*)
(************************************************************************)

procedure get_next_page(
  var page_count	: integer);

begin
  page_count := page_count + 1;
  format.character(ASCII_FORM_FEED);
  format.newline;
  format.skip_to(70);
  format.string('Page \');
  format.number(page_count,10);
  format.write_line(user_terminal)
end (* get_next_page *);



(************************  command_level_utility  ***********************)
(*									*)
(*				next_page				*)
(*									*)
(*	formats formfeed and page number				*)
(*									*)
(************************************************************************)

procedure next_page(
      selected_fields	: designated_fields;
  var page_count 	: integer);

begin
  get_next_page(page_count);
  write_cud_header(
$ifnot BEFORE_SUP_V43    TRUE,
    selected_fields);
  format.start
end (* next_page *);



(************************  command_level_utility  ***********************)
(*									*)
(*			display_directory				*)
(*									*)
(*	 Selects cud_entries by criteria and displays specified fields	*)
(*									*)
(************************************************************************)

procedure entry DISPLAY_DIRECTORY(
  var scanned	: scanned_command);

var
  buffer		: cud_disk_block;
  block			: cud_block_index;
$if BEFORE_SUP_V43   cud_entry		: cud_user_entry;
$ifnone BEFORE_SUP_V43
  mud_entry		: mud_user_entry;
  nud_entry		: nud_user_entry;
$endif BEFORE_SUP_V43
  criteria_index	: criteria_type;
  selected_fields	: designated_fields;
  users_selected	: integer;

(* used for pagination feature *)
  lines_per_page	: integer;
  line_count		: integer;
  page_count		: integer;
  next_users_lines	: integer;
  count			: integer;
  field_index		: fields;
  field_keyword	: 
    first_display_directory_keyword..last_display_directory_keyword;

begin
  page_count := 1; users_selected := 0; line_count := 0;
(* get designated fields *)
  do_clear_designated_fields(selected_fields);
  count := 0;
  if not argument_scan.check_keyword(PRIMARY_DISPLAY_DIRECTORY_LINES_KEYWORD,
    scanned)
  then lines_per_page := NO_PAGINATION
  else keyword_util.get_numeric_keyword_value(
    PRIMARY_DISPLAY_DIRECTORY_LINES_KEYWORD, 10, 25, MAX_INTEGER, scanned,
    lines_per_page);
  if scanned.status = CMD_OK
  then
    begin
      if ((lines_per_page <> NO_PAGINATION) and
	 (scanned.keyword_count = 2)) or (scanned.keyword_count = 1)
      then selected_fields[ALL_FIELDS] := TRUE
      else
	begin (* check_keyword *)
	  selected_fields[ACCESS_FIELD] := argument_scan.check_keyword(
	      PRIMARY_DISPLAY_DIRECTORY_ACCESS_KEYWORD, scanned);
	  for field_keyword := FIRST_DISPLAY_DIRECTORY_KEYWORD
	    to LAST_DISPLAY_DIRECTORY_KEYWORD do
  	    if argument_scan.check_keyword(field_keyword, scanned)
	    then
	      begin
		case field_keyword of
		  PRIMARY_DISPLAY_DIRECTORY_UUN_KEYWORD:
		    field_index := UUN_FIELD;
		  PRIMARY_DISPLAY_DIRECTORY_GAN_KEYWORD:
		    field_index := GAN_FIELD;
		  PRIMARY_DISPLAY_DIRECTORY_DISTRICT_KEYWORD:
		    field_index := DISTRICT_FIELD;
		  PRIMARY_DISPLAY_DIRECTORY_CONTROL_KEYWORD:
		    field_index := CONTROL_FIELD;
		  PRIMARY_DISPLAY_DIRECTORY_PASSWORDDATE_KEYWORD:
		    field_index := PASSWORDDATE_FIELD;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifany (force_password_change, password_expiration_by_user)
		  PRIMARY_DISPLAY_DIRECTORY_EXPIREDATE_KEYWORD:
		    field_index := EXPIREDATE_FIELD;
$endif (force_password_change, password_expiration_by_user)
$if restrict_users_by_time
		  PRIMARY_DISPLAY_DIRECTORY_TIMERESTRICT_KEYWORD:
		    field_index := TIMERESTRICT_FIELD;
$endif restrict_users_by_time
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
		  PRIMARY_DISPLAY_DIRECTORY_ENTRYDATE_KEYWORD:
		    field_index := ENTRYDATE_FIELD 
		end (* case of field keyword *);
		selected_fields[field_index] := TRUE;
		count := count + 1
	      end (* check_keyword *);
	    if not INCLUDE_GAN and (selected_fields[GAN_FIELD])
	    then
	      begin
		scanned.status := ARG_ERROR;
		user_terminal.write_quoted_text_line(NO_GANS_MESSAGE)
	      end (* not INCLUDE_GAN and (selected_fields[GAN_FIELD]) *);
	    if not INCLUDE_DISTRICT and (selected_fields[DISTRICT_FIELD])
	    then
	      begin
		scanned.status := ARG_ERROR;
		user_terminal.write_quoted_text_line(NO_DISTRICTS_MESSAGE)
	      end;
	    if count > 4 (* max fields not including access *)
	    then scanned.status := TOO_MANY_ARGS
	end (* else *);
      argument_scan.extra_argument_check(scanned)
    end;

  if scanned.status = CMD_OK
  then
    begin
      cud_updater.start_cud_list(0, buffer);
      cud_utility.print_cud_entry_error;

      do_display_select (* write out criteria information *);
      user_terminal.write_newline;
      if lines_per_page <> NO_PAGINATION
      then
	begin
	  (* display_select outputs at least one line and  *)
	  (* both types of header add four *)
	  line_count := 5;
	  for criteria_index := ACCESS_CRITERION to PASSWORDDATE_CRITERION do
	    if criteria.used[criteria_index]
	    then line_count := line_count + 1
	end (* lines_per_page <> NO_PAGINATION *);
      write_cud_header(
$ifnot BEFORE_SUP_V43        TRUE,
	selected_fields);

      repeat
	user_terminal.check_circuit;
	cud_updater.next_cud_list(buffer, block,
$if BEFORE_SUP_V43         cud_entry);
$ifnone BEFORE_SUP_V43         mud_entry, nud_entry);
	if (cud_updater.last_status = CUD_ENTRY_OK) or
	  (cud_updater.last_status = CUD_ENTRY_IN_WRONG_BLOCK)
	then
	  begin
	    if user_passes_criteria(
$if BEFORE_SUP_V43 		cud_entry)
$ifnone BEFORE_SUP_V43		mud_entry, nud_entry)
	    then
	      begin
		format.start;
		if cud_updater.last_status = CUD_ENTRY_IN_WRONG_BLOCK
		then
		  begin
		    format.cud_entry_status(cud_updater.last_status);
		    format.newline
		  end;
		users_selected := users_selected + 1;
		if lines_per_page <> NO_PAGINATION
		then
		  begin
		    if selected_fields[ALL_FIELDS]
		    then next_users_lines :=
$if BEFORE_SUP_V43		cud_entry.access_profile.count + 2
$ifnone BEFORE_SUP_V43		mud_entry.mud_access_profile.count + 2
		    else
		      if selected_fields[ACCESS_FIELD]
		      then next_users_lines :=
$if BEFORE_SUP_V43		cud_entry.access_profile.count+1
$ifnone BEFORE_SUP_V43		mud_entry.mud_access_profile.count+1
		      else next_users_lines := 1;
		    if next_users_lines + line_count <= lines_per_page
		    then line_count := line_count + next_users_lines
		    else
		      begin (* go to next page *)
			line_count := next_users_lines + 7;
			next_page(selected_fields, page_count)
		      end (* go to next page *)
		  end (* if <> NO_PAGINATION *);
		display_fields(selected_fields,
$if BEFORE_SUP_V43		cud_entry)
$ifnone BEFORE_SUP_V43		TRUE, mud_entry, nud_entry)
	      end (* if user_passes_criteria *)
	    end (* cud_updater.last_status = CUD_ENTRY_OK *)
	  else
	    if cud_updater.last_status <> CUD_ENTRY_NOT_FOUND
	    then
	      begin
	        format.start_message('block \ ');
	        format.number(block, 10);
		format.colon_space;
		format.cud_entry_status(cud_updater.last_status);
		format.write_line(user_terminal)
	      end (* cud_updater.last_status <> CUD_ENTRY_NOT_FOUND *)
      until (cud_updater.last_status = CUD_ENTRY_NOT_FOUND) or
        not user_terminal.sendable;
      if lines_per_page <> NO_PAGINATION
      then
        if line_count + 1 > lines_per_page
	then get_next_page(page_count);
      format.start_line_message('Number of users selected: \ ');
      format.number(users_selected, 10);
      format.write_line(user_terminal)
    end (* if CMD_OK *)
end (* display_directory *);
!
"
		DISPLAY CUD and MUD Commands
"


(***********************  command_level_utility  ************************)
(*									*)
(*			     display_block 				*)
(*									*)
(*	Display contents of the CUD or MUD buffer.			*)
(*									*)
(************************************************************************)

procedure entry DISPLAY_BLOCK(
      cud_flag	: boolean (* TRUE if displaying CUD buffer *);
  var scanned	: scanned_command);

var
  cud_status : cud_entry_result;
  output_all,	(* TRUE if ALL keyword was entered *)
  format_output : boolean;
  success : boolean;
  start_line_ptr : cud_data_index;
  record_size : cud_data_size;
  next_record_ptr : cud_data_index;
  done : boolean;
  start_word,
  end_word,
  word_index : cud_data_index;
  selected_fields : designated_fields;
  block : cud_block_index;
$ifnone BEFORE_SUP_V43
  disk_block : cud_data_block;
$if overflow_cud_entries   mud_header : mud_block_header;
  next_mud_ptr : mud_data_index;
  next_nud_ptr : nud_data_index;
  size_of_mud_entry : mud_data_size;
  size_of_nud_entry : nud_entry_size;
  mud_entry : mud_user_entry;
  nud_entry : nud_user_entry;
  result : cud_operation_result;
$endif BEFORE_SUP_V43
$if BEFORE_SUP_V43
  disk_block : cud_disk_block;
  cud_entry : cud_user_entry;
$endif BEFORE_SUP_V43

begin
  format_output := argument_scan.check_keyword(
    PRIMARY_DISPLAY_CUD_FORMATTED_KEYWORD, scanned);
  if not format_output
  then output_all :=
    argument_scan.check_keyword(PRIMARY_DISPLAY_CUD_ALL_KEYWORD, scanned);
  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    begin
$ifnone BEFORE_SUP_V43
      restore_cud_buffer(disk_block, success);
      if not cud_flag
      then
$endif BEFORE_SUP_V43
$ifnone BEFORE_SUP_V43       restore_buffer(disk_block.data.mud_block,success);
$if BEFORE_SUP_V43       restore_buffer(cud_flag, disk_block, success);
      if success
      then
        if format_output
	then
	  begin (* display buffer formatted *)
	    if cud_flag
	    then block := cud_info.block
	    else block := mud_info.block;
	    do_clear_designated_fields(selected_fields);
	    selected_fields[ALL_FIELDS] := TRUE;
	    write_cud_header(
$ifnot BEFORE_SUP_V43              cud_flag,
	      selected_fields);
$if BEFORE_SUP_V43	     next_record_ptr :=0;
$ifnone BEFORE_SUP_V43
	    next_mud_ptr := START_MUD_ENTRY_OFFSET;
	    next_nud_ptr := NUD_DATA_ENTRY_OFFSET;
$endif BEFORE_SUP_V43
	    repeat
	      cud_updater.unpack_next_entry(disk_block.data, block,
$if BEFORE_SUP_V43		next_record_ptr, cud_entry);
$ifnone BEFORE_SUP_V43
		next_mud_ptr, next_nud_ptr, mud_entry, nud_entry);
$endif BEFORE_SUP_V43
	      if cud_updater.last_status = CUD_ENTRY_OK
	      then
	        begin
		  format.start;
		  display_fields(selected_fields,
$if BEFORE_SUP_V43			 cud_entry);
$ifnone BEFORE_SUP_V43		cud_flag, mud_entry, nud_entry);
  (* unpack_next_entry now updates MUD and NUD pointers *)
	        end (* status = CUD_ENTRY_OK *)
	      else
	        if cud_updater.last_status <> CUD_ENTRY_NOT_FOUND
	        then cud_utility.print_cud_entry_message
	   until not user_terminal.sendable or
    	     (cud_updater.last_status <> CUD_ENTRY_OK)
	  end (* display buffer formatted *)
	else
	  begin (* display buffer unformatted *)
	    user_terminal.write_quoted_text_line('byte\ ');
	    start_line_ptr := 0; done := FALSE;
	    next_record_ptr := 0;
     	    if output_all
	    then record_size :=
$if BEFORE_SUP_V43		CUD_DATA_LIMIT
$ifnone BEFORE_SUP_V43		    MUD_DATA_LIMIT
            else record_size :=
$if BEFORE_SUP_V43	    ord(disk_block.data[next_record_ptr]);
$ifnone BEFORE_SUP_V43	    	MUD_HEADER_SIZE;
	    repeat
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifall (overflow_cud_entries, before_sup_v43)
	      cud_status := CUD_ENTRY_OK;
	      cud_entry_util.check_overflow(disk_block.data, next_record_ptr,
		cud_status);
	      if cud_status = CUD_ENTRY_OVERFLOW_FOUND
	      then
	        begin (* overflow indicator found; end of data *)
		  done := TRUE;
		  record_size := MAXIMUM_BYTES_IN_WORD
		end (* overflow indicator found; end of data *);
	      if (cud_status = CUD_ENTRY_OK) or
	        (next_record_ptr + record_size > start_line_ptr)
	      then
$endif (overflow_cud_entries, before_sup_v43)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	        begin
		  if record_size = 0
		  then done := TRUE
		  else
		    begin (* record_size > 0 *)
		      next_record_ptr := next_record_ptr + record_size;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if BEFORE_SUP_V43          record_size:=ord(disk_block.data[next_record_ptr]);
$ifnot BEFORE_SUP_V43
		      with disk_block do
		        begin
		          if next_record_ptr < MUD_DATA_LIMIT
		          then record_size := (ord(data.mud_block.data[
			    next_record_ptr + MUD_ENTRY_SIZE_OFFSET]) * BIT23) +
			    ord(data.mud_block.data[
			    next_record_ptr + MUD_ENTRY_SIZE_OFFSET + 1])
		          else
			    if cud_flag
			    then record_size := MAXIMUM_NUD_BLOCK_SIZE
		        end;
$endif BEFORE_SUP_V43
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
		      if (next_record_ptr > CUD_DATA_LIMIT)
$ifnot BEFORE_SUP_V43 or ((not cud_flag) and (next_record_ptr > MUD_DATA_LIMIT))
		      then
		        begin
		          done := TRUE;
			  user_terminal.write_line_and_quoted_text_line(
			    format_error);
$ifnot BEFORE_SUP_V43
			  if not cud_flag
			  then next_record_ptr := MUD_DATA_LIMIT
			  else
$endif BEFORE_SUP_V43
			  next_record_ptr := CUD_DATA_LIMIT (* output anyway *)
			end (* next_record_ptr > CUD_DATA_LIMIT *);
		      repeat
		        start_line_with_index(start_line_ptr);
			start_word := start_line_ptr div MAXIMUM_BYTES_IN_WORD;
			end_word := start_word + CUD_WORDS_IN_LINE_LIMIT;
			if (end_word >= CUD_DATA_WORD_MAXIMUM)
$ifnot BEFORE_SUP_V43
			  and cud_flag
			then end_word := end_word - 1
			else (* skip MUD checksum *)
			  if (end_word >= MUD_DATA_WORD_MAXIMUM)
			    and not cud_flag
			  then end_word := end_word - 1
			  else (* skip MUD checksum *)
			    if end_word = MUD_DATA_WORD_MAXIMUM
$endif BEFORE_SUP_V43
			then end_word := end_word - 1;
			for word_index := start_word to end_word do
			  begin
			    add_next_word(word_index * MAXIMUM_BYTES_IN_WORD,
			      disk_block.data);
			    format.skip(2)
			  end (* for *);
			format.write_line(user_terminal) (* write out line *);
$ifnot BEFORE_SUP_V43
			if not cud_flag
			then
			  begin
			    if (start_line_ptr + MAXIMUM_CUD_BYTES_IN_LINE) >=
			      MUD_DATA_LIMIT
			    then done := TRUE
			    else start_line_ptr := start_line_ptr
			      + MAXIMUM_CUD_BYTES_IN_LINE
			  end
			else
$endif BEFORE_SUP_V43
			if (start_line_ptr + MAXIMUM_CUD_BYTES_IN_LINE) >=
			  CUD_DATA_LIMIT
			then done := TRUE
			else start_line_ptr := start_line_ptr
			  + MAXIMUM_CUD_BYTES_IN_LINE
		      until done or not user_terminal.sendable or
		        (start_line_ptr >= next_record_ptr);
		      if output_all
		      then
$ifnone BEFORE_SUP_V43
			if cud_flag and (next_record_ptr = MUD_DATA_LIMIT)
			then done := FALSE
			else
$endif BEFORE_SUP_V43
		          done := TRUE
	            end (* record_size > 0 *)
		end
	    until done or not user_terminal.sendable
	  end (* display buffer unformatted *)
    end (* scanned.status = CMD_OK *)
end (* display_block *);
"
		READ Command
"


(***********************  command_level_utility  *************************)
(*									*)
(*			    write_un2_error				*)
(*									*)
(************************************************************************)

procedure write_un2_error(
      real_sup  : real_supervisor_index;
      status	: un2_status;
      block	: cud_block_index);

begin (* write_un2_error *)
  format.start_and_newline;
  with aux_io do
    format.un2_sup_error(status, param.status, param.arg2, block);
  format.write_line(user_terminal)
end (* write_un2_error *);



(***********************  command_level_utility  *************************)
(*									*)
(*			       read_cud 				*)
(*									*)
(************************************************************************)

procedure entry READ_CUD(
      lock_block	: boolean (* TRUE if programmer is locking block *);
      block_number	: cud_block_index;
  var block_is_locked	: boolean;
  var shut_block	: cud_block_index);

var
  status : cud_access_status;
  result : cud_operation_result;
  disk_block : cud_disk_block;
  success : boolean;

begin
  status := CUD_ACCESS_OK;
  if lock_block
  then
    if block_is_locked
    then
      begin (* report that the block is locked *)
        status := CUD_ACCESS_BLOCK_SHUT;
	format.start_message('You already have block \');
	format.number(shut_block, 10);
	format.string(' locked\');
	format.write_line(user_terminal)
      end (* report that the block is locked *)
    else
      begin (* block_is_locked is FALSE *)
        cud_access.lock_cud_block(validator, block_number, TRUE, status);
	if status = CUD_ACCESS_OK
	then
	  begin
	    shut_block := block_number;
	    block_is_locked := TRUE
	  end (* status = CUD_ACCESS_OK *)
        else
          begin (* status <> CUD_ACCESS_OK *)
            format.start;
	    format.cud_access_error(status);
	    format.write_line(user_terminal)
	  end (* status <> CUD_ACCESS_OK *)
	end (* block_is_locked is FALSE *);

  if status = CUD_ACCESS_OK
  then
    begin
      block_updater.read_cud_block(block_number, result, disk_block);
      if result <> CUD_OPERATION_OK
      then
        begin
	  format.cud_block_error(block_number, result);
	  format.write_line(user_terminal)
	end (* result <> CUD_OPERATION_OK *);
      if (result = CUD_OPERATION_OK) or (result = CUD_CHECKSUM_ERROR)
      then
        begin
$if BEFORE_SUP_V43	  store_buffer(CUD_MUD_BUFFER_LOCATION,
$ifnone BEFORE_SUP_V43        store_cud_buffer(
	    block_number, disk_block, cud_info, success);
	  if success
	  then user_terminal.write_quoted_text_line(block_read)
	end (* result = CUD_OPERATION_OK or CUD_CHECKSUM_ERROR *)
    end (* status = CUD_ACCESS_OK *)
end (* read_cud *);



(***********************  command_level_utility  ************************)
(*									*)
(*			       read_mud					*)
(*									*)
(************************************************************************)

procedure entry READ_MUD(
      real_sup  : real_supervisor_index;
      block	: cud_block_index);

var
  status     : un2_status;
$if BEFORE_SUP_V43  disk_block : cud_disk_block;
$ifnone BEFORE_SUP_V43   disk_block : mud_disk_block;
  write_ok   : boolean;

begin
  un2_util.read_mud_block(real_sup, block, status, disk_block);
  if status <> UN2_SUCCESSFUL
  then write_un2_error(real_sup, status, block)
  else
    begin (* status = UN2_SUCCESSFUL *)
      store_buffer(
$if BEFORE_SUP_V43        MUD_BUFFER_LOCATION,
	block, disk_block, mud_info, write_ok);
      if write_ok
      then user_terminal.write_quoted_text_line(block_read)
    end (* status = UN2_SUCCESSFUL *)
end (* read_mud *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifall (special, BEFORE_SUP_V43)
!
"
	CLEAN MUD Routines (clean up from MUD Slide, i.e., delete any users
	that are stored in the wrong block
"
"Comment all this code out...(to end of CLEAN_UP routine)



(***********************  command_level_utility  ************************)
(*									*)
(*			report_mud_slide_error				*)
(*									*)
(************************************************************************)

procedure report_mud_slide_error(
      block	: cud_block_index);

begin
  format.start_message('block \ ');
  format.number(block, 10);
  format.colon_space;
  format.cud_entry_status( cud_updater.last_status);
  format.write_line(user_terminal)
end (* report_mud_slide_error *);



(***********************  command_level_utility  ************************)
(*									*)
(*				clean_up				*)
(*									*)
(*	Scan CUD entries, and display all user entries that are located	*)
(*	in the wrong CUD block; if the keyword DELETE is included,	*)
(*	delete the entry.						*)
(*									*)
(************************************************************************)

procedure entry CLEAN_UP(
  var scanned	: scanned_command);

var
  report_block		: cud_block_index;
  deleting_users	: boolean;
  report_info		: boolean;
  needs_cr		: boolean;
  buffer		: cud_disk_block;
  block			: cud_block_index;
  cud_entry		: cud_user_entry;
  criteria_index	: criteria_type;
  selected_fields	: designated_fields;
  users_selected	: integer;

(* used for pagination feature *)
  lines_per_page	: integer;
  line_count		: integer;
  page_count		: integer;
  next_users_lines	: integer;
  count			: integer;
  field_index		: fields;
  field_keyword		: command_keyword_index;

begin
  page_count := 1; users_selected := 0; line_count := 0;
  report_block := 0; block := 0; needs_cr := FALSE;
(* get designated fields *)
  do_clear_designated_fields(selected_fields);
  count := 0; lines_per_page := NO_PAGINATION;
  deleting_users := argument_scan.check_keyword(PRIMARY_CLEAN_DELETE_KEYWORD,
    scanned);
  if argument_scan.check_keyword(PRIMARY_CLEAN_FROM_KEYWORD, scanned)
  then keyword_util.get_numeric_keyword_value(PRIMARY_CLEAN_FROM_KEYWORD, 10,
    0, CUD_BLOCK_LIMIT, scanned, block);
  argument_scan.extra_argument_check(scanned);
  selected_fields[ALL_FIELDS] := TRUE;

  if scanned.status = CMD_OK
  then
    begin
      cud_updater.start_cud_list(block, buffer);
      cud_utility.print_cud_entry_error;

      write_cud_header(selected_fields);

      repeat
	user_terminal.check_circuit;
	cud_updater.next_cud_list(buffer, block, cud_entry);
	if cud_updater.last_status = CUD_ENTRY_OK
	then
	  begin
	    if report_block <> block
	    then
	      begin
	        needs_cr := TRUE;
	        format.start;
		format.number(report_block, 10);
		format.character(ASCII_SPACE);
		format.write_block(user_terminal);
	        report_block := block
	      end (* report_block <> block *);
	    if cud_updater.hashed_cud_block(cud_entry.name) <> block
	    then
	      begin
	        report_info := TRUE;
	        if deleting_users
		then
		  begin
		    cud_updater.delete_mud_slide_entry(block, cud_entry);
		    if cud_updater.last_status <> CUD_ENTRY_OK
		    then
		      begin (* error in deleting *)
		        report_info := FALSE;
		        format.start_message('error deleting \');
			format.username(cud_entry.name);
			format.write_line(user_terminal);
			report_mud_slide_error(block)
		      end (* error in deleting *)
		  end (* deleting_users *);
		if report_info
		then
		  begin
		    if needs_cr
		    then
		      begin
		        user_terminal.write_newline;
			needs_cr := FALSE
		      end (* needs_cr *);
		    format.start;
		    format.character(ASCII_LEFT_PARENS);
		    format.number(cud_updater.hashed_cud_block(cud_entry.name),
		      10);
		    format.character(ASCII_RIGHT_PARENS);
		    users_selected := users_selected + 1;
		    display_fields(selected_fields, cud_entry)
		  end (* report_info *)
	      end (* if user_in_wrong_block *)
	  end (* cud_updater.last_status = CUD_ENTRY_OK *)
	else
	  if cud_updater.last_status <> CUD_ENTRY_NOT_FOUND
	  then report_mud_slide_error(block)
      until (cud_updater.last_status = CUD_ENTRY_NOT_FOUND) or
        not user_terminal.sendable;
      format.start_line_message('Number of users selected: \ ');
      format.number(users_selected, 10);
      format.write_line(user_terminal)
    end (* if CMD_OK *) 
end (* clean_up *);
...end of commented out code
"



(***********************  command_level_utility  ************************)
(*									*)
(*				clean_up				*)
(*									*)
(*	Scan the CUD, and display the block number of any block that	*)
(*	has bad data after the good data; if the keyword DELETE is	*)
(*	included, remove the data.					*)
(*									*)
(************************************************************************)

procedure entry CLEAN_UP(
  var scanned	: scanned_command);

var
  block : cud_block_index;
  start_block : cud_block_index;
  result : cud_operation_result;
  disk_block : cud_disk_block;
  cud_status : cud_entry_result;
  old_option : user_options;
  next_option : cud_control_options;
  cub_date : integer;
  needs_cr : boolean;

begin
  needs_cr := FALSE;
  if argument_scan.check_keyword(PRIMARY_CLEAN_FROM_KEYWORD, scanned)
  then keyword_util.get_numeric_keyword_value(PRIMARY_CLEAN_FROM_KEYWORD, 10,
    0, CUD_BLOCK_LIMIT, scanned, start_block)
  else start_block := 0;
  block := start_block;
  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    begin
      cud_updater.start_cud_list(block, buffer);
      cud_utility.print_cud_entry_error;

      repeat
	user_terminal.check_circuit;
	cud_updater.next_cud_list(buffer, block, cud_entry);
	if cud_updater.last_status = CUD_ENTRY_OK
	then
	  with cud_entry do
    	    begin
	      cub_date := password_change_date;
	      calendar.cubs_to_isis_days(cub_date, password_change_date);
	      password_change_date := password_change_date * SECONDS_PER_DAY;
	      old_options := options;
	      if (ACCOUNT_SUPERVISOR in old_options) and
		(not OPERATOR in old_options)
	      then
	        begin
	          old_options := old_options - [ACCOUNT_SUPERVISOR];
		  old_options := old_options or [OPERATOR]
	        end;
	      if (OPERATOR in old_options) and
		(not ACCOUNT_SUPERVISR in old_options)
	      then
	        begin
	          old_options := old_options - [OPERATOR];
		  old_options := old_options or [ACCOUNT_SUPERVISOR]
	        end;
	      options := [];
    	      for next_option := FIRST_CUD_CONTROL_OPTION
	        to LAST_CUD_CONTROL_OPTION do
	        if next_option in old_options
	        then options := options or [next_option];
	      cud_updater.update_options(cud_entry)
	    end (* if CUD_ENTRY_OK *);
	  if ((block - start_block + 1) mod 100) = 0
	  then
	    begin
	      needs_cr := TRUE; line_length := 0;
	      format.report_progress(user_terminal, block, 0, 0, line_length)
	    end
      until (cud_updater.last_status = CUD_ENTRY_NOT_FOUND)
        or not user_terminal.sendable;
      if ((block - start_block + 1) mod 100) <> 0
      then
        begin
	  line_length := 0;
	  format.report_progress(user_terminal, block, 0, 0, line_length)
	end
    end (* if CMD_OK *)
end (* clean_up *);
(******...  old password code  ...*******)
(*	see also CMDDEF and CMDTAB	*)
!
"
	DISPLAY OLDPASS Routines
"



(***********************  command_level_utility  ************************)
(*									*)
(*			user_has_old_password				*)
(*									*)
(*      Return TRUE if:							*)
(*		- cud entry has old password AND			*)
(*		-  user entry is located in its correct block		*)
(*		- user is not a GFD ONLY user				*)
(*									*)
(************************************************************************)

function user_has_old_password(
      cud_entry	: cud_user_entry;
      block	: cud_block_index) : boolean;

begin
  user_has_old_password := FALSE;
  if not (NEW_PASSWORD_OPTION in cud_entry.options)
  then
    if cud_updater.hashed_cud_block(cud_entry.name) = block
    then user_has_old_password := TRUE
end (* user_has_old_password *);



(***********************  command_level_utility  ************************)
(*									*)
(*				display_oldpass				*)
(*									*)
(************************************************************************)

procedure entry DISPLAY_OLDPASS(
  var scanned	: scanned_command);

var
  buffer		: cud_disk_block;
  block			: cud_block_index;
  cud_entry		: cud_user_entry;
  criteria_index	: criteria_type;
  selected_fields	: designated_fields;
  users_selected	: integer;

(* used for pagination feature *)
  lines_per_page	: integer;
  line_count		: integer;
  page_count		: integer;
  next_users_lines	: integer;
  count			: integer;
  field_index		: fields;
  field_keyword		: command_keyword_index;

begin
  page_count := 1; users_selected := 0; line_count := 0;
(* get designated fields *)
  do_clear_designated_fields(selected_fields);
  count := 0; lines_per_page := NO_PAGINATION;
  argument_scan.extra_argument_check(scanned);
  selected_fields[ALL_FIELDS] := TRUE;

  if scanned.status = CMD_OK
  then
    begin
      cud_updater.start_cud_list(0, buffer);
      cud_utility.print_cud_entry_error;

      write_cud_header(selected_fields);

      repeat
	user_terminal.check_circuit;
	cud_updater.next_cud_list(buffer, block, cud_entry);
	if cud_updater.last_status = CUD_ENTRY_OK
	then
	  begin
	    if user_has_old_password(cud_entry, block)
	    then
	      begin
		format.start;
		users_selected := users_selected + 1;
		display_fields(selected_fields, cud_entry)
	      end (* if user_has_old_password *)
	    end (* cud_updater.last_status = CUD_ENTRY_OK *)
	  else
	    if cud_updater.last_status <> CUD_ENTRY_NOT_FOUND
	    then
	      begin
	        format.start_message('block \ ');
	        format.number(block, 10);
		format.colon_space;
		format.cud_entry_status(cud_updater.last_status);
		format.write_line(user_terminal)
	      end (* cud_updater.last_status <> CUD_ENTRY_NOT_FOUND *)
      until (cud_updater.last_status = CUD_ENTRY_NOT_FOUND) or
        not user_terminal.sendable;
      format.start_line_message('Number of users selected: \ ');
      format.number(users_selected, 10);
      format.write_line(user_terminal)
    end (* if CMD_OK *)
end (* display_oldpass *);
$endif (special, BEFORE_SUP_V43)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(******...  old password code  ...*******)
!
"
	SELECT Command
"



(************************  command_level_utility  ***********************)
(*									*)
(*			    get_date_selection				*)
(*									*)
(************************************************************************)

procedure get_date_selection(
      expiration_date_selected	: boolean;
  var temp_criteria		: user_criteria_selections;
  var criteria_index		: criteria_type;
  var scanned			: scanned_command);

var
  latest_date : integer;

begin
  with temp_criteria.date_criteria[criteria_index] do
    begin
      if qualifier = NO_DATE_QUALIFIER
      then
        begin (* get date with correct syntax and no earlier than 1/1/74 *)
	  if argument_scan.check_keyword(PRIMARY_SELECT_BEFORE_DATE_KEYWORD,
	    scanned)
	  then qualifier := BEFORE_DATE
	  else
	    if argument_scan.check_keyword(PRIMARY_SELECT_AFTER_DATE_KEYWORD,
	      scanned)
	    then qualifier := AFTER_DATE;
	  argument_scan.freeword_date(expiration_date_selected, 0, scanned,
	    time);
$if force_password_change
	  if expiration_date_selected
	  then latest_date := REALTIME +
	    (MAXIMUM_GANPASS_PERIOD * SECONDS_PER_DAY)
	  else
$endif force_password_change
$if password_expiration_by_user
	  if expiration_date_selected
	  then latest_date := MAX_INTEGER
	  else
$endif password_expiration_by_user
	    latest_date := REALTIME;
	  if time > latest_date
	  then scanned.status := ARG_NUMBER_OUT_OF_BOUNDS
	end (* get date with correct syntax and no earlier than 1/1/74 *);
      if scanned.status = CMD_OK
      then
        if (qualifier = BEFORE_DATE) and (time = 0)
        then scanned.status := ARG_ERROR
	else
	  if (qualifier = AFTER_DATE) and (time = latest_date)
	  then scanned.status := ARG_ERROR;
      time := time div SECONDS_PER_DAY
    end (* with *)
end (* get_date_selection *);



(************************  command_level_utility  ***********************)
(*									*)
(*				select					*)
(*									*)
(*	Sets or clears specified criterion or clears all criteria	*)
(*									*)
(************************************************************************)

procedure entry SELECT(
  var scanned	: scanned_command);
 
var
  temp_criteria		: user_criteria_selections;
  all			: boolean;
  criteria_keyword	: command_keyword_index;
  criteria_index	: criteria_type;
  select_keyword	: command_keyword_index;
$if BEFORE_SUP_V43    option_index		: criteria_control_options;
$ifnone BEFORE_SUP_V43
  option_index		: mud_criteria_control_options;
  nud_option_index	: nud_criteria_control_options;
  access_option_index	: access_criteria_control_options;
$endif BEFORE_SUP_V43

begin
  temp_criteria := criteria;
  all := argument_scan.check_keyword(PRIMARY_SELECT_ALL_KEYWORD, scanned);
  criteria_keyword := PRIMARY_SELECT_ACCESS_KEYWORD;
  if not argument_scan.check_keyword(criteria_keyword, scanned)
  then argument_scan.find_keyword(PRIMARY_SELECT_GAN_KEYWORD,
    PRIMARY_SELECT_PASSWORDDATE_KEYWORD, scanned, criteria_keyword);

  if all and (scanned.status = ARG_MISSING)
  then
    begin (* "ALL" is the only keyword entered - clear all criteria *)
      criteria_index := ALL_CRITERIA;
      scanned.status := CMD_OK
    end (* "ALL" is the only keyword entered - clear all criteria *)
  else
    if scanned.status = CMD_OK
    then
      begin
        case criteria_keyword of
	  PRIMARY_SELECT_ALL_KEYWORD: criteria_index := ALL_CRITERIA;
	  PRIMARY_SELECT_ACCESS_KEYWORD: criteria_index := ACCESS_CRITERION;
	  PRIMARY_SELECT_GAN_KEYWORD: criteria_index := GAN_CRITERION;
	  PRIMARY_SELECT_DISTRICT_KEYWORD: criteria_index :=DISTRICT_CRITERION;
	  PRIMARY_SELECT_UUN_KEYWORD: criteria_index := UUN_CRITERION;
	  PRIMARY_SELECT_CONTROL_KEYWORD: criteria_index := CONTROL_CRITERION;
	  PRIMARY_SELECT_ENTRYDATE_KEYWORD:
	    criteria_index:= ENTRYDATE_CRITERION;
$ifany (force_password_change, password_expiration_by_user)
	  PRIMARY_SELECT_EXPIREDATE_KEYWORD:
	    criteria_index := EXPIREDATE_CRITERION;
$endif (force_password_change, password_expiration_by_user)
	  PRIMARY_SELECT_PASSWORDDATE_KEYWORD:
	    criteria_index := PASSWORDDATE_CRITERION 
	end (* case criteria_keyword *);
	if not all
	then
	  begin (* set specific criteria *)
	    temp_criteria.used[ALL_CRITERIA] := FALSE;
	    temp_criteria.used[criteria_index] := TRUE;
	    case criteria_index of
	      ALL_CRITERIA: (* null *);
	      ACCESS_CRITERION:
	        begin
$ifnot BEFORE_SUP_V43
		  temp_criteria.used[CONTROL_CRITERION] := FALSE;
		  select_keyword := PRIMARY_SELECT_CONTROL_KEYWORD;
		  if not argument_scan.check_keyword(select_keyword, scanned)
		  then
$endif BEFORE_SUP_V43
		  argument_scan.find_keyword(
		    PRIMARY_SELECT_CLASS_ACCESS_KEYWORD,
		    PRIMARY_SELECT_NODE_ACCESS_KEYWORD,
		    scanned, select_keyword);
		  if scanned.status = CMD_OK
		  then
		    case select_keyword of
$ifnot BEFORE_SUP_V43
		      PRIMARY_SELECT_CONTROL_KEYWORD:
		        begin
			  temp_criteria.access_type := CONTROL_ACCESS;
		      for access_option_index :=
	                FIRST_ACCESS_CRITERIA_CONTROL_OPTION to
		          LAST_ACCESS_CRITERIA_CONTROL_OPTION do
			begin
		          case access_option_index of
			    USERNAME_OK: select_keyword :=
PRIMARY_SELECT_ACCESS_CONTROL_USERNAME_OK_KEYWORD;
			    HOSTNAME_OK: select_keyword :=
PRIMARY_SELECT_ACCESS_CONTROL_HOSTNAME_OK_KEYWORD;
			    ALLOW_NORMAL_CIRCUIT: select_keyword :=
PRIMARY_SELECT_ACCESS_CONTROL_NORMAL_KEYWORD;
			    ALLOW_AUX_CIRCUIT: select_keyword :=
PRIMARY_SELECT_ACCESS_CONTROL_AUXILIARY_KEYWORD;
			    USER_REGULAR_CALL: select_keyword :=
PRIMARY_SELECT_ACCESS_CONTROL_USER_REGULAR_CALL_KEYWORD;
			    HOST_REGULAR_CALL: select_keyword :=
PRIMARY_SELECT_ACCESS_CONTROL_HOST_REGULAR_CALL_KEYWORD;
			    USER_COLLECT_CALL: select_keyword :=
PRIMARY_SELECT_ACCESS_CONTROL_USER_COLLECT_CALL_KEYWORD;
			    HOST_COLLECT_CALL: select_keyword :=
PRIMARY_SELECT_ACCESS_CONTROL_HOST_COLLECT_CALL_KEYWORD;
			    SHUT_OVERRIDE: select_keyword :=
PRIMARY_SELECT_ACCESS_CONTROL_SHUT_OVERRIDE_KEYWORD;
			    REQUIRE_HOSTNAME: select_keyword :=
PRIMARY_SELECT_ACCESS_CONTROL_REQUIRE_HOSTNAME_KEYWORD;
			    TARGET_PROFILE_DESTINATION: select_keyword :=
PRIMARY_SELECT_ACCESS_CONTROL_TARGET_DESTINATION_KEYWORD;
			    PRIORITY_CONTINUE: select_keyword :=
PRIMARY_SELECT_ACCESS_CONTROL_PRIORITY_CONTINUE_KEYWORD
		          end (* case access_option_index *);
		          temp_criteria.access_control[access_option_index] :=
		            argument_scan.check_keyword(select_keyword,scanned)
			  end (* for *)
		        end (* PRIMARY_SELECT_CONTROL_KEYWORD *);
$endif BEFORE_SUP_V43
		      PRIMARY_SELECT_CLASS_ACCESS_KEYWORD:
		        begin
			  temp_criteria.access_type := CLASS_ACCESS;
			  argument_scan.freeword_range(0, 0, MAXIMUM_CLASS,
			    criteria_value_radix(criteria_index,
			    temp_criteria.access_type), scanned,
			    temp_criteria.range_criteria[criteria_index])
			end (* PRIMARY_SELECT_CLASS_ACCESS_KEYWORD *);
		      PRIMARY_SELECT_GROUP_ACCESS_KEYWORD:
		        begin
			  temp_criteria.access_type := GROUP_ACCESS;
			  argument_scan.freeword_range(0, 0, MAXIMUM_GROUP,
			    criteria_value_radix(criteria_index,
			    temp_criteria.access_type), scanned,
			    temp_criteria.range_criteria[criteria_index])
			end (* PRIMARY_SELECT_GROUP_ACCESS_KEYWORD *);
		      PRIMARY_SELECT_HOST_ACCESS_KEYWORD:
		        begin
			  temp_criteria.access_type := HOST_ACCESS;
			  argument_scan.freeword_range(0, MINIMUM_HOST,
			    MAXIMUM_HOST, criteria_value_radix(criteria_index,
			    temp_criteria.access_type), scanned,
			    temp_criteria.range_criteria[criteria_index])
			end (* PRIMARY_SELECT_HOST_ACCESS_KEYWORD *);
		      PRIMARY_SELECT_NODE_ACCESS_KEYWORD:
		        begin
			  temp_criteria.access_type := NODE_ACCESS;
			  argument_scan.freeword_range(0, MINIMUM_NODE,
			    MAXIMUM_NODE, criteria_value_radix(criteria_index,
			    temp_criteria.access_type), scanned,
			    temp_criteria.range_criteria[criteria_index])
			end (* PRIMARY_SELECT_NODE_ACCESS_KEYWORD *)
		    end (* case select_keyword *)
	        end (* ACCESS_CRITERION *);
	      GAN_CRITERION:
	        if INCLUDE_GAN
		then argument_scan.freeword_range(0, MINIMUM_GAN, MAXIMUM_GAN,
		  criteria_value_radix(criteria_index,
		  temp_criteria.access_type), scanned,
		  temp_criteria.range_criteria[criteria_index])
		else
	          begin (* not INCLUDE_GAN *)
		    scanned.status := ARG_ERROR;
		    user_terminal.write_quoted_text_line(NO_GANS_MESSAGE)
		  end (* not INCLUDE_GAN *);
	      DISTRICT_CRITERION:
	        if INCLUDE_DISTRICT
		then argument_scan.freeword_range(0, MINIMUM_DISTRICT,
		  MAXIMUM_DISTRICT,
		  criteria_value_radix(criteria_index,
		  temp_criteria.access_type), scanned,
		  temp_criteria.range_criteria[criteria_index])
		else
	          begin (* not INCLUDE_DISTRICT *)
		    scanned.status := ARG_ERROR;
		    user_terminal.write_quoted_text_line(NO_DISTRICTS_MESSAGE)
		  end (* not INCLUDE_DISTRICT *);
	      UUN_CRITERION: argument_scan.freeword_range(0, MINIMUM_UUN,
	        MAXIMUM_UUN, criteria_value_radix(criteria_index,
		temp_criteria.access_type), scanned,
		temp_criteria.range_criteria[criteria_index]);
	      CONTROL_CRITERION:
	        if scanned.keyword_count = 1
		then scanned.status := ARG_MISSING
		else
		  begin (* scanned.keyword_count <> 1 *)
$if BEFORE_SUP_V43
		    for option_index := FIRST_CRITERIA_CONTROL_OPTION to
		      LAST_CRITERIA_CONTROL_OPTION do
$endif BEFORE_SUP_V43
$ifnone BEFORE_SUP_V43
		    temp_criteria.used[ACCESS_CRITERION] := FALSE;
		    for option_index := FIRST_MUD_CRITERIA_CONTROL_OPTION to
		      LAST_MUD_CRITERIA_CONTROL_OPTION do
$endif BEFORE_SUP_V43
		      begin
		        case option_index of
  IGNORE_DESTINATION: select_keyword :=
    PRIMARY_SELECT_CONTROL_IGNORE_DESTINATION_KEYWORD;
  NO_PASSWORD_REQUIRED: select_keyword :=
    PRIMARY_SELECT_CONTROL_NO_PASSWORD_REQUIRED_KEYWORD;
$if BEFORE_SUP_V43
  LICENSED: select_keyword := PRIMARY_SELECT_CONTROL_LICENSED_KEYWORD;
  PASSWORD_ONLY: select_keyword :=
    PRIMARY_SELECT_CONTROL_PASSWORD_ONLY_KEYWORD;
$if force_password_change
  FPC_EXEMPT: select_keyword :=
    PRIMARY_SELECT_CONTROL_FORCE_PASSWD_CHG_EXEMPT_KEYWORD;
$endif force_password_change
$if no_self_password_change
  NSP_CHANGE: select_keyword :=
    PRIMARY_SELECT_CONTROL_NO_SELF_PASSWD_CHANGE_KEYWORD;
$endif no_self_password_change
  ACCOUNT_SUPERVISOR: select_keyword :=
    PRIMARY_SELECT_CONTROL_ACCOUNT_SUPERVISOR_KEYWORD;
  NETWORK_ADMINISTRATOR: select_keyword :=
    PRIMARY_SELECT_CONTROL_NETWORK_ADMINISTRATOR_KEYWORD;
  SHUT_OVERRIDE: select_keyword :=
    PRIMARY_SELECT_CONTROL_SHUT_OVERRIDE_KEYWORD;
  AUDITOR: select_keyword := PRIMARY_SELECT_CONTROL_AUDITOR_KEYWORD;
  OPERATOR: select_keyword := PRIMARY_SELECT_CONTROL_OPERATOR_KEYWORD;
$endif BEFORE_SUP_V43
$ifnot BEFORE_SUP_V43
  USERNAME_TYPE: select_keyword := PRIMARY_SELECT_CONTROL_USERTYPE_KEYWORD;
  HOSTNAME_TYPE: select_keyword := PRIMARY_SELECT_CONTROL_HOSTTYPE_KEYWORD;
  AUX_PASSWORD: select_keyword := PRIMARY_SELECT_CONTROL_AUX_PASSWORD_KEYWORD;
  TARGET_PROFILE_ENTRY: select_keyword :=
    PRIMARY_SELECT_CONTROL_TARGET_ENTRY_KEYWORD;
$if allow_logon_inhibit
  LOGON_INHIBIT: select_keyword :=
    PRIMARY_SELECT_CONTROL_LOGON_INHIBIT_KEYWORD;
$endif allow_logon_inhibit
  PROHIBIT_DEFAULT_USER: select_keyword :=
    PRIMARY_SELECT_CONTROL_PROHIBIT_DEFAULT_KEYWORD;
$endif BEFORE_SUP_V43
  TRANSPARENT_LOGIN: select_keyword :=
    PRIMARY_SELECT_CONTROL_TRANSPARENT_LOGIN_KEYWORD
		        end (* case option_index *);
			temp_criteria.control[option_index] :=
		          argument_scan.check_keyword(select_keyword, scanned)
		      end (* for *);
$if BEFORE_SUP_V43
(* check for mutually exclusive criteria control options *)
		    if (temp_criteria.control[LICENSED] and
		       temp_criteria.control[PASSWORD_ONLY]) or
		      (temp_criteria.control[PASSWORD_ONLY] and
		       temp_criteria.control[ACCOUNT_SUPERVISOR]) or
		      (temp_criteria.control[PASSWORD_ONLY] and
		       temp_criteria.control[NETWORK_ADMINISTRATOR]) or
		      (temp_criteria.control[ACCOUNT_SUPERVISOR] and
		       temp_criteria.control[NETWORK_ADMINISTRATOR])
		    then
		      begin
		        scanned.status := RUN_ERROR;
			user_terminal.write_quoted_text_line(
			  'mutually exclusive parameters\')
		      end
$endif BEFORE_SUP_V43
$ifnot BEFORE_SUP_V43
		    for nud_option_index :=
		      FIRST_NUD_CRITERIA_CONTROL_OPTION to
		      LAST_NUD_CRITERIA_CONTROL_OPTION do
		      begin
		        case nud_option_index of
			  LICENSED: select_keyword :=
			    PRIMARY_SELECT_CONTROL_LICENSED_KEYWORD;
			  PASSWORD_ONLY: select_keyword :=
			    PRIMARY_SELECT_CONTROL_PASSWORD_ONLY_KEYWORD;
$if force_password_change
			  FPC_EXEMPT: select_keyword :=
		    PRIMARY_SELECT_CONTROL_FORCE_PASSWD_CHG_EXEMPT_KEYWORD;
$endif force_password_change
$if password_expiration_by_user
			  EXEMPT_FROM_PASSWORD_EXPIRATION: select_keyword :=
		    PRIMARY_SELECT_CONTROL_EXPIRATION_EXEMPT_KEYWORD;
$endif password_expiration_by_user
$if no_self_password_change
			  NSP_CHANGE: select_keyword :=
		    PRIMARY_SELECT_CONTROL_NO_SELF_PASSWD_CHANGE_KEYWORD;
$endif no_self_password_change
			  ACCOUNT_SUPERVISOR: select_keyword :=
			    PRIMARY_SELECT_CONTROL_ACCOUNT_SUPERVISOR_KEYWORD;
			  NETWORK_ADMINISTRATOR: select_keyword :=
			    PRIMARY_SELECT_CONTROL_NETWORK_ADMINISTRATOR_KEYWORD;
			  AUDITOR: select_keyword :=
			    PRIMARY_SELECT_CONTROL_AUDITOR_KEYWORD;
			  OPERATOR: select_keyword :=
			    PRIMARY_SELECT_CONTROL_OPERATOR_KEYWORD
		        end (* case nud_option_index *);
			temp_criteria.nud_control[nud_option_index] :=
		          argument_scan.check_keyword(select_keyword, scanned)
		      end (* for *);
		    temp_criteria.access_type := CONTROL_ACCESS;
		    temp_criteria.access_control[SHUT_OVERRIDE] :=
		      argument_scan.check_keyword(
			PRIMARY_SELECT_ACCESS_CONTROL_SHUT_OVERRIDE_KEYWORD,
			scanned);
(* check for mutually exclusive criteria control options *)
		    if (temp_criteria.nud_control[LICENSED] and
		       temp_criteria.nud_control[PASSWORD_ONLY]) or
		      (temp_criteria.nud_control[PASSWORD_ONLY] and
		       temp_criteria.nud_control[ACCOUNT_SUPERVISOR]) or
		      (temp_criteria.nud_control[PASSWORD_ONLY] and
		       temp_criteria.nud_control[NETWORK_ADMINISTRATOR]) or
		      (temp_criteria.nud_control[ACCOUNT_SUPERVISOR] and
		       temp_criteria.nud_control[NETWORK_ADMINISTRATOR])
		    then
		      begin
		        scanned.status := RUN_ERROR;
			user_terminal.write_quoted_text_line(
			  'mutually exclusive parameters\')
		      end
$endif BEFORE_SUP_V43
		  end (* scanned.keyword_count <> 1 *);
	      PASSWORDDATE_CRITERION:
	        with temp_criteria.date_criteria[criteria_index] do
		  begin
		    qualifier := NO_DATE_QUALIFIER;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if NETVAL_IS_A_SLAVE
		    if argument_scan.check_keyword(
		      PRIMARY_SELECT_GFD_ONLY_DATE_KEYWORD, scanned)
		    then qualifier := GFD_ONLY_DATE;
$endif NETVAL_IS_A_SLAVE
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
		    get_date_selection(FALSE, temp_criteria, criteria_index,
		      scanned)
		end (* PASSWORDDATE_CRITERION *);
$ifany (force_password_change, password_expiration_by_user)
	      EXPIREDATE_CRITERION:
	        with temp_criteria.date_criteria[criteria_index] do
		  begin
		    qualifier := NO_DATE_QUALIFIER;
		    get_date_selection(TRUE, temp_criteria, criteria_index,
		      scanned)
		  end (* EXPIREDATE_CRITERION *);
$endif (force_password_change, password_expiration_by_user)
	      ENTRYDATE_CRITERION:
	        with temp_criteria.date_criteria[criteria_index] do
		  begin
		    qualifier := NO_DATE_QUALIFIER;
		    get_date_selection(FALSE, temp_criteria, criteria_index,
		      scanned)
		  end (* ENTRYDATE_CRITERION *)
	    end (* case criteria_index *)
	  end (* set specific criteria *)
      end (* scanned.status = CMD_OK *);
  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    begin
      user_terminal.write_quoted_text_line('selection accepted\ ');
      if all
      then do_clear_criteria(criteria_index)
      else criteria := temp_criteria
    end (* scanned.status = CMD_OK *)
end (* select *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if prevent_duplicate_passwords
!
"
		SET PASSPERIOD Command
"



(************************  command_level_utility  ***********************)
(*									*)
(*			     set_passperiod				*)
(*									*)
(************************************************************************)

procedure entry SET_PASSPERIOD(
  var scanned	: scanned_command);

var
  passperiod_in_days : integer;
  passperiod_in_seconds : integer;
  io_status : file_utility_status;

begin
  freeword_utility.prompt_passperiod(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if password_expiration_by_user
        mud_change.standard_password_validity_in_seconds div SECONDS_PER_DAY,
$endif password_expiration_by_user
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    scanned, passperiod_in_days);
  argument_scan.extra_argument_check(scanned);
  if user_terminal.sendable and (scanned.status = CMD_OK)
  then
    begin
      passperiod_in_seconds := passperiod_in_days * SECONDS_PER_DAY;
      mud_change.set_minimum_password_change_time(passperiod_in_seconds,
	io_status);
      if io_status = FU_SUCCESS
      then
	begin
	  user_terminal.write_line_and_quoted_text_line(ENTRY_COMPLETED);
	  format.start_message(THE_MINIMUM_PASSWORD_CHANGE_TIME_MESSAGE);
	  format.string('set to \');
	  format.number(passperiod_in_days, 10);
	  format.string(DAYS_MESSAGE);
	  format.by_validator(profile.name);
	  oper_messages.report_message(MUDUPD_OPLOG_MSG)
	end
      else user_terminal.write_quoted_text_line(DISK_WRITE_ERROR_MESSAGE)
    end
end (* set_passperiod *);
$endif prevent_duplicate_passwords
$if password_expiration_by_user
!
"
		SET VALIDITY Command
"



(************************  command_level_utility  ***********************)
(*									*)
(*			     set_validity				*)
(*									*)
(************************************************************************)

procedure entry SET_VALIDITY(
  var scanned	: scanned_command);

var
  validity_period_in_days : integer;
  validity_period_in_seconds : integer;
  io_status : file_utility_status;

begin
  if scanned.status = CMD_OK
  then freeword_utility.prompt_standard_validity(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if prevent_duplicate_passwords
    mud_change.minimum_password_change_time_in_seconds div SECONDS_PER_DAY,
$endif prevent_duplicate_passwords
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    scanned, validity_period_in_days);
  argument_scan.extra_argument_check(scanned);
  if user_terminal.sendable and (scanned.status = CMD_OK)
  then
    begin
      validity_period_in_seconds := validity_period_in_days * SECONDS_PER_DAY;
      mud_change.set_standard_password_validity_period(
        validity_period_in_seconds, io_status);
      if io_status <> FU_SUCCESS
      then user_terminal.write_quoted_text_line(DISK_WRITE_ERROR_MESSAGE)
      else
        begin
	  user_terminal.write_line_and_quoted_text_line(ENTRY_COMPLETED);
	  format.start_message(
	    THE_STANDARD_PASSWORD_VALIDITY_PERIOD_MESSAGE);
	  format.string('set to \');
	  format.number(validity_period_in_days, 10);
	  format.string(DAYS_MESSAGE);
	  format.by_validator(profile.name);
	  oper_messages.report_message(MUDUPD_OPLOG_MSG)
	end
    end
end (* set_validity *);
$endif password_expiration_by_user
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
"
		WRITE Command
"



(***********************  command_level_utility  ************************)
(*									*)
(*			  report_block_written				*)
(*									*)
(*      Notify operator log that a CUD/MUD block was written.		*)
(*									*)
(************************************************************************)

procedure report_block_written(
      cud_flag		: boolean;
      writing_from_cud	: boolean;
      real_sup		: real_supervisor_index;
      block		: cud_block_index);

begin
  user_terminal.write_line_and_quoted_text_line(BLOCK_WRITTEN);
  format.start_message('block \ ');
  format.number(block, 10);
  format.string(' written to \ ');
  if cud_flag
  then
    begin
      format.string(CUD_FILE_MESSAGE);
      if not writing_from_cud
      then format.string(' (from MUD buffer)\ ')
    end (* cud_flag *)
  else
    begin
      format.string(SUPERVISOR_MESSAGE);
      format.sup_number(real_sup)
    end (* cud_flag *);
  format.by_validator(profile.name);
  oper_messages.report_message(VALIDATOR_OPLOG_MSG)
end (* report_block_written *);



(*************************  command_level_utility  **********************)
(*									*)
(*			     write_cud_buffer				*)
(*									*)
(*      Write disk_block to CUD.					*)
(*									*)
(************************************************************************)

procedure entry WRITE_CUD_BUFFER(
      writing_from_cud	: boolean);

var
  block_to_write : cud_block_index;
  result : cud_operation_result;
$if BEFORE_SUP_V43  disk_block : cud_disk_block;
$ifnot BEFORE_SUP_V43  disk_block : cud_data_block;
  success : boolean;

begin
$ifnot BEFORE_SUP_V43
  restore_cud_buffer(disk_block, success);
  if not writing_from_cud
  then restore_buffer(disk_block.data.mud_block, success);
$endif BEFORE_SUP_V43
$if BEFORE_SUP_V43  restore_buffer(writing_from_cud, disk_block, success);
  if success
  then
    begin
      if not writing_from_cud
      then block_to_write := mud_info.block (* from CUD *)
      else block_to_write := cud_info.block (* from SUPERVISOR *);
      block_updater.update_cud_block(block_to_write, disk_block, result);
      if result = CUD_OPERATION_OK
      then report_block_written(TRUE, writing_from_cud,
        FIRST_SUPERVISOR, block_to_write)
      else
        begin
          user_terminal.write_newline;
          format.cud_block_error(cud_info.block, result);
          format.write_line(user_terminal)
        end (* result <> CUD_OPERATION_OK *)
    end (* success *)
end (* write_cud_buffer *);



(**************************  command_level_utility  *********************)
(*									*)
(*			      write_mud_buffer				*)
(*									*)
(*      Write cud_info to selected supervisor. 				*)
(*									*)
(************************************************************************)

procedure entry WRITE_MUD_BUFFER(
      writing_from_cud	: boolean;
      real_sup		: real_supervisor_index);

var
  status : un2_status;
$if BEFORE_SUP_V43  disk_block : cud_disk_block;
$ifnone BEFORE_SUP_V43  disk_block : cud_data_block;
  success : boolean;

begin
$ifnot BEFORE_SUP_V43
  restore_cud_buffer(disk_block, success);
  if not writing_from_cud
  then restore_buffer(disk_block.data.mud_block, success);
$endif BEFORE_SUP_V43
$if BEFORE_SUP_V43  restore_buffer(writing_from_cud, disk_block, success);
  if success
  then
    begin
      un2_util.write_mud_block(real_sup, cud_info.block,
$if BEFORE_SUP_V43        disk_block,
$ifnot BEFORE_SUP_V43        disk_block.data.mud_block,
	status);
      if status = UN2_SUCCESSFUL
      then report_block_written(FALSE, writing_from_cud, real_sup,
        cud_info.block)
      else write_un2_error(real_sup, status, cud_info.block)
    end
end (* write_mud_buffer *);



(************************************************************************)
(************************************************************************)

begin (* null statement *)
end (* command_level_utility *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if check_time_status
!
(************************************************************************)
(*									*)
(*	OPRRPT.NTV							*)
(*									*)
(*				oplog_reporter				*)
(*									*)
(*	This process writes an operator log record, including host	*)
(*	status and logical volume status, periodically.			*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	13Aug87 - neh							*)
(*	      - make oplog_reporter conditional on check_time_status	*)
	(*		merge 4.00 and 5.00 neh			*)
(*	02Feb87 - rsb							*)
(*		- add mudchg and pasmon to list of vars, and to		*)
(*		  initialization of cmdutl.ntv				*)
(*	01Oct86 - neh							*)
(*	      - Change init lv_dialogue to come before command_util	*)
(*		in inorder to always end on semi-colon.			*)
(*	19Jun86 - neh							*)
(*	      - add parameters to initalize COMMAND_LEVEL_UTILITY	*)
(*	31Mar86	Original -- jrn						*)
(*									*)
(************************************************************************)


type OPLOG_REPORTER = process(
(*	+-+-+-+-+--+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if logical_volumes       lv_status_manager	: lvol_status_manager;
(*	+-+-+-+-+--+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      login_pool	: login_distributer;
      commands		: command_table;
      statistics	: statistics_gatherer;
      oplog		: operator_log;
      mud_change	: mud_change_handler;
$ifnot BEFORE_SUP_V43
      file_system		: file_system_manager;
      list_access		: node_host_list_access;
      list_allocater		: node_host_list_allocater;
$endif BEFORE_SUP_V43
      cud_access	: cud_access_controller;
      name_access	: cud_name_controller;
      param_manager	: cud_parameter_controller;
      un2_access	: un2_access_manager);

var
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifall (overflow_cud_entries, BEFORE_SUP_V43)
  overflow_controller	: cud_overflow_controller;
$endif (overflow_cud_entries, BEFORE_SUP_V43)
$ifall (special, BEFORE_SUP_V43)  calendar      : date_time_converter;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnot BEFORE_SUP_V43
  list_io		: node_host_list_io_utility;
  list_utility		: node_host_list_utility;
$endif BEFORE_SUP_V43
  sys_io		: system_handler;
  mutil			: misc_utility;
  profile		: validator_profile;
  aux_io		: circuit_handler;
  format		: internal_to_string;
  user_terminal		: circuit_handler;
  mudchg		: mud_change_handler;
  oper_messages		: operator_messages;
  block_utility		: cud_block_utility;
  block_updater		: cud_block_updater;
  cud_entry_util	: cud_entry_utility;
$if BEFORE_SUP_V43  cud_updater     	: cud_entry_updater;
$ifnot BEFORE_SUP_V43  cud_updater	   : mud_entry_updater;
  cud_utility		: cud_updater_utility;
  un2_util		: un2_utility;
(* command handlers *)
  argument_scan		: argument_scanner;
  keyword_util		: keyword_utility;
  input_scanner		: terminal_input_scanner;
  freeword_utility	: freeword_response_utility;
  keyword_scan		: keyword_scanner;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if change_by_whom
"added gpo by SHSUE at 20-Jul-87 16:57:42"
$endif
$ifany (force_password_change, global_password_only_login)
  pasmon		: passtable_handler;
$endif any force_password_change global_password_only_login
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  dsksys		: disk_system;
  cmd_utility		: command_level_utility;
(*	+-+-+-+-+--+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if logical_volumes
(* logical volume handlers *)
  lv_utility		: lvol_utility;
  config_utility	: configuration_utility;
  lv_dialogue		: lvol_dialogue;
$endif logical_volumes
(*	+-+-+-+-+--+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(************************************************************************)
(************************************************************************)

begin (* initial statement *)
  init sys_io, mutil, format,
    user_terminal(mutil), oper_messages(oplog, format), profile(0),
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifall (overflow_cud_entries, BEFORE_SUP_V43)
    overflow_controller(oplog, statistics),
$endif (overflow_cud_entries, BEFORE_SUP_V43)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    argument_scan(mutil),
    keyword_util(profile, format, user_terminal, commands, argument_scan),
    input_scanner(profile, mutil, format, user_terminal, commands,
      argument_scan, keyword_util),
    keyword_scan(user_terminal, input_scanner),
(* CUD handlers *)
    dsksys(statistics),
    block_utility(mutil, oper_messages, format, dsksys),
    block_updater(mutil, statistics, dsksys, cud_access, block_utility,
      format),
    cud_entry_util(mutil, format, oper_messages),
$ifnot BEFORE_SUP_V43
    list_io(statistics, file_system, oper_messages, format, list_access),
    list_utility(0, statistics, file_system,
      format, list_io, list_allocater, list_access),
$endif BEFORE_SUP_V43
    cud_updater(0, mutil, format, login_pool, mud_change, oper_messages,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifall (overflow_cud_entries, BEFORE_SUP_V43)       overflow_controller,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      cud_entry_util, cud_access, block_updater,
$ifnot BEFORE_SUP_V43      list_utility,
      param_manager, name_access),
    cud_utility(format, cud_updater, user_terminal),
    un2_util(aux_io, oper_messages, format, un2_access, mud_change),
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if logical_volumes

    lv_utility, config_utility(dsksys, sys_io),
    lv_dialogue(user_terminal, keyword_scan, format, dsksys, sys_io,
      lv_status_manager, lv_utility, config_utility),
$endif logical_volumes
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    cmd_utility(0, sys_io, mutil,
$ifall (special, BEFORE_SUP_V43)      calendar,
      format, profile,
      oper_messages, aux_io, user_terminal, mudchg, cud_access, block_utility,
      block_updater, cud_entry_util, cud_updater, cud_utility,
      un2_util, login_pool, argument_scan, keyword_util,
      input_scanner, freeword_utility, keyword_scan, 
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if change_by_whom
"added gpo by SHSUE at 20-Jul-87 13:42:12"
$endif
$ifany (force_password_change, global_password_only_login)
      pasmon,
      param_manager,
$endif any(force_password_change, global_password_only_login)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      dsksys);


  cycle
    mud_change.delay_oplog_rptr (* until time to report *);
    format.start;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if logical_volumes
    format.start;
    lv_dialogue.get_lvol_info;
    oper_messages.report_message(OPERLOG_REPORT_MSG);
$endif logical_volumes
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    format.start;
    cmd_utility.get_host_info;
    oper_messages.report_message(OPERLOG_REPORT_MSG);

    format.start;
    cmd_utility.get_validator_info;
    oper_messages.report_message(OPERLOG_REPORT_MSG)
  end (* cycle *)
end (* operlog_reporter *);
$endif check_time_status
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
(************************************************************************)
(*                                                              	*)
(*	TAPEIO.NTV							*)
(*                                                                 	*)
(*  			       tape_handler				*)
(*                                                                      *)
(*      This CLASS contains the various tape handling functions.	*)
(*									*)
(*	The following identifiers must be defined externally:		*)
(*	  tape_unit_index, disk_tape_information, ioresult, tape_param	*)
(*	  page, page_index, cud_tape_block				*)
(*                                                                      *)
(************************************************************************)
(*									*)
(*			Revision History:				*)
(*									*)
(*	28Mar88 - neh							*)
(*	     	- change ATTACH to clear tape condition before attach	*)
(*	15Feb88 - neh							*)
(*		- add READ_DNIC_FILE to restore dnic file		*)
(*		- add WRITE_DNIC_FILE to store dnic file		*)
(*	11Oct87 - smh							*)
(*		- add READ_PASSTABLE_FILE, READ_SCHEDTABLE_FILE 	*)
(*		  so Passtable and Schedtable can be restored.		*)
(*		- add WRITE_PASSTABLE_FILE, WRITE_SCHEDTABLE_FILE	*)
(*		  so Passtable and Schedtable can be stored.		*)
(*	13May86 - neh							*)
(*	      - add BACK_TAPE procedure if include_dump is enabled	*)
(*	      - if include_dump is enabled, add write_ascii_dump_block	*)
(*	03Feb86 - jrn							*)
(*	      - add general procedures READ and WRITE			*)
(*	27Jul84 - jrn							*)
(*	      - new format tape - standard ANSII labels, list records	*)
(*		  rather than all page I/O				*)
(*	14Mar84	Version 2.01 - jrn					*)
(*	      - fixed bug in reporting status after retry logic		*)
(*	07jul83 - original - from (basicws)tapeio.bes - jrn		*)
(*									*)
(************************************************************************)



type tape_handler = class;


const
  CONTROLLER = 8 (* for ISIS error codes checked for error recovery *);


var
  entry PARAM : tape_param;
!
(***************************  tape_handler  *****************************)
(*									*)
(*			       drive_status				*)
(*									*)
(************************************************************************)

procedure entry DRIVE_STATUS(
      unit	: tape_unit_index;
  var dev_stat	: disk_tape_information);


begin
  param.operation := TAPE_INFO;
  io(dev_stat, param, TAPE, unit)
end (* drive_status *);
!
(*****************************  tape_handler  ***************************)
(*									*)
(*				detach_unit				*)
(*									*)
(*	DETACH the tape unit specified from the slot.			*)
(*									*)
(************************************************************************)

procedure entry DETACH_UNIT(
      unit	: tape_unit_index);

var
  buffer : char;

begin
  param.operation := TAPE_DETACH;
  io(buffer, param, TAPE, unit)
end (* detach_unit *);
!
(*****************************  tape_handler  ***************************)
(*									*)
(*				attach_unit				*)
(*									*)
(*	ATTACH the tape unit specified to the slot.			*)
(*									*)
(************************************************************************)

procedure entry ATTACH_UNIT(
      unit	: tape_unit_index);

var
  buffer : char;

begin
  param.count := 0 (* init condition *);
  param.operation := TAPE_ATTACH;
  io(buffer, param, TAPE, unit)
end (* attach_unit *);
!
(***************************  tape_handler  *****************************)
(*									*)
(*			      do_position_drive				*)
(*									*)
(************************************************************************)

procedure do_position_drive(
      unit	: tape_unit_index;
      pos_op	: integer);

var
  dummy : integer;

begin
  param.operation := TAPE_ACTION;
  param.arg := pos_op;
  io(dummy, param, TAPE, unit)
end (* do_position_drive *);



(***************************  tape_handler  *****************************)
(*									*)
(*			     position_drive				*)
(*									*)
(************************************************************************)

procedure entry POSITION_DRIVE(
      unit	: tape_unit_index;
      pos_op	: integer);

begin
  do_position_drive(unit, pos_op)
end (* position_drive *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if include_dump



(***************************  tape_handler  *****************************)
(*									*)
(*			     back_tape					*)
(*									*)
(************************************************************************)

procedure entry BACK_TAPE(
      unit	: tape_unit_index;
  var ok	: boolean);

begin
  do_position_drive(unit, TAPE_BACK_SPACE);
  ok := param.status = COMPLETE
end (* back_tape *);
$endif include_dump
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!


(***************************  tape_handler  *****************************)
(*									*)
(*			         read     				*)
(*									*)
(************************************************************************)

procedure read(
      unit		: tape_unit_index;
      io_length		: integer;
  var first_char	: char;
  var ok		: boolean);

var
  retry_count : integer (* count of retries on error *);
  done : boolean (* error, but no re-try *);

begin
  done := FALSE;
  retry_count := 0;
  repeat
    param.operation := TAPE_READ;
    param.count := io_length;
    io(first_char, param, TAPE, unit);
    ok := (param.status = COMPLETE) and (param.arg = io_length);
(*	If there was a controller transmission error, and retry_count	*)
(*	is not MAXIMUM_TAPE_RETRIES, back space tape and try again.	*)
(*	Otherwise, set done to TRUE.					*)
    if (param.status = TRANSMISSION) and (param.count = CONTROLLER) and
      (retry_count < MAXIMUM_TAPE_RETRIES)
    then
      begin (* re-try only if controller error *)
        do_position_drive(unit, TAPE_BACK_SPACE);
	retry_count := succ(retry_count)
      end (* re-try only if controller error *)
    else done := TRUE
  until ok or done
end (* read *);



(***************************  tape_handler  *****************************)
(*									*)
(*			       read_label     				*)
(*									*)
(************************************************************************)

procedure entry READ_LABEL(
      unit	: tape_unit_index;
  var buffer	: ansii_tape_label;
  var ok	: boolean);

begin
  read(unit, MAX_ANSII_TAPE_LABEL_SIZE, buffer[0], ok)
end (* read_label *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code



(***************************  tape_handler  *****************************)
(*									*)
(*			      read_tape_page   				*)
(*									*)
(*	Input a page from unit into buffer.				*)
(*									*)
(************************************************************************)

procedure entry READ_TAPE_PAGE(
      unit	: tape_unit_index;
  var buffer	: univ page;
  var ok	: boolean);

begin
  read(unit, PAGE_SIZE, buffer[0], ok)
end (* read_tape_page *);



(***************************  tape_handler  *****************************)
(*									*)
(*			 read_blocked_tape_page   			*)
(*									*)
(*	Input a blocked page from unit into buffer.			*)
(*									*)
(************************************************************************)

procedure entry READ_BLOCKED_TAPE_PAGE(
      unit	: tape_unit_index;
  var buffer	: univ tape_page_block_in_bytes;
  var ok	: boolean);

begin
  read(unit, TAPE_PAGE_BLOCK_SIZE, buffer[0], ok)
end (* read_blocked_tape_page *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if INCLUDE_DNIC


(***************************  tape_handler  *****************************)
(*									*)
(*  Name:	read_dnic_file						*)
(*									*)
(*  Purpose:	fetch entire dnic file in one block from tape		*)
(*									*)
(************************************************************************)

procedure entry READ_DNIC_FILE(
      unit	: tape_unit_index;
  var buffer	: univ tape_dnic_in_bytes;
  var ok	: boolean);

begin (* read_dnic_file *)
  read(unit, TAPE_DNIC_LENGTH, buffer[0], ok)
end (* read_dnic_file *);
$endif INCLUDE_DNIC
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifany (force_password_change, global_password_only_login)



(***************************  tape_handler  *****************************)
(*									*)
(*  Name:	read_passtable_file					*)
(*									*)
(*  Purpose:	fetch entire Passtable file in one block from tape	*)
(*									*)
(************************************************************************)

procedure entry READ_PASSTABLE_FILE(
      unit	: tape_unit_index;
  var buffer	: univ tape_passtable_in_bytes;
  var ok	: boolean);

begin (* read_passtable_file *)
  read(unit, TAPE_PASSTABLE_LENGTH, buffer[0], ok)
end (* read_passtable_file *);
$endif any(force_password_change, global_password_only_login)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(***************************  tape_handler  *****************************)
(*									*)
(*  Name:	read_schedtable_file					*)
(*									*)
(*  Purpose:	fetch entire schedtable file in one block from tape	*)
(*									*)
(************************************************************************)

procedure entry READ_SCHEDTABLE_FILE(
      unit	: tape_unit_index;
  var buffer	: univ tape_schedtable_in_bytes;
  var ok	: boolean);

begin (* read_schedtable_file *)
  read(unit, TAPE_SCHEDTABLE_LENGTH, buffer[0], ok)
end (* read_schedtable_file *);



(***************************  tape_handler  *****************************)
(*									*)
(*			      read_cud_block   				*)
(*									*)
(*	Input a CUD_TAPE_BLOCK from unit into buffer.			*)
(*									*)
(************************************************************************)

procedure entry READ_CUD_BLOCK(
      unit	: tape_unit_index;
  var buffer	: univ tape_cud_block_in_bytes;
  var ok	: boolean);

begin
  read(unit, TAPE_CUD_BLOCK_SIZE, buffer[0], ok)
end (* read_cud_block *);



(***************************  tape_handler  *****************************)
(*									*)
(*			     read_named_list   				*)
(*									*)
(*	Input a tape_named_list_definition from unit.			*)
(*									*)
(************************************************************************)

procedure entry READ_NAMED_LIST(
      unit	: tape_unit_index;
  var buffer	: univ tape_named_list_definition_in_bytes;
  var ok	: boolean);

begin
  read(unit, TAPE_NAMED_LIST_DEFINITION_SIZE, buffer[0], ok)
end (* read_named_list *);



(***************************  tape_handler  *****************************)
(*									*)
(*			   read_mudupd_header  				*)
(*									*)
(*	Input a tape_mudupd_header_definition from unit.		*)
(*									*)
(************************************************************************)

procedure entry READ_MUDUPD_HEADER(
      unit	: tape_unit_index;
  var buffer	: univ tape_mudupd_header_in_bytes;
  var ok	: boolean);

begin
  read(unit, MAXIMUM_TAPE_MUDUPD_HEADER_SIZE, buffer[0], ok)
end (* read_mudupd_header *);



(***************************  tape_handler  *****************************)
(*									*)
(*			   read_global_access  				*)
(*									*)
(*	Input a tape_global_access_definition from unit.		*)
(*									*)
(************************************************************************)

procedure entry READ_GLOBAL_ACCESS(
      unit	: tape_unit_index;
  var buffer	: univ tape_global_access_definition_in_bytes;
  var ok	: boolean);

begin
  read(unit, MAXIMUM_TAPE_GLOBAL_ACCESS_DEFINITION_SIZE, buffer[0], ok)
end (* read_global_access *);
$endif disk_maintenance_code
$ifnone disk_maintenance_code
!



(***************************  tape_handler  *****************************)
(*									*)
(*			         write					*)
(*									*)
(*	Write out an array of characters.				*)
(*									*)
(************************************************************************)

procedure write(
      unit		: tape_unit_index;
      io_length		: integer;
  var first_char	: char;
  var ok		: boolean);

var
  gaps_written : integer (* count of erase gaps on errors *);
  done : boolean;

begin
  done := FALSE;
  gaps_written := 0;
  repeat
    param.operation := TAPE_WRITE;
    param.count := io_length;
    io(first_char, param, TAPE, unit);
    ok := param.status = COMPLETE;
(*      There has been a write controller error.  Prepare to try the	*)
(*	write again:  backspace, write a gap and increment gaps_written.*)
    if (param.status = TRANSMISSION) and (param.count = CONTROLLER) and
      (gaps_written < MAXIMUM_TAPE_RETRIES)
    then
      begin
        do_position_drive(unit, TAPE_BACK_SPACE);
	do_position_drive(unit, TAPE_GAP);
	gaps_written := succ(gaps_written)
      end
    else done := TRUE
  until ok or done
end (* write *);
$if INCLUDE_DNIC


(***************************  tape_handler  *****************************)
(*									*)
(*  Name:	write_dnic_file						*)
(*									*)
(*  Purpose:	fetch entire dnic file in one block from tape		*)
(*									*)
(************************************************************************)

procedure entry WRITE_DNIC_FILE(
      unit	: tape_unit_index;
  var buffer	: univ tape_dnic_in_bytes;
  var ok	: boolean);

begin (* write_dnic_file *)
  write(unit, TAPE_DNIC_LENGTH, buffer[0], ok)
end (* write_dnic_file *);
$endif INCLUDE_DNIC
$ifany (force_password_change, global_password_only_login)


(***************************  tape_handler  *****************************)
(*									*)
(*  Name:	write_passtable_file					*)
(*									*)
(*  Purpose:	fetch entire Passtable file in one block from tape	*)
(*									*)
(************************************************************************)

procedure entry WRITE_PASSTABLE_FILE(
      unit	: tape_unit_index;
  var buffer	: univ tape_passtable_in_bytes;
  var ok	: boolean);

begin (* write_passtable_file *)
  write(unit, TAPE_PASSTABLE_LENGTH, buffer[0], ok)
end (* write_passtable_file *);
$endif any(force_password_change, global_password_only_login)


(***************************  tape_handler  *****************************)
(*									*)
(*			     write_schedtable_file			*)
(*									*)
(************************************************************************)

procedure entry WRITE_SCHEDTABLE_FILE(
      unit	: tape_unit_index;
  var buffer	: univ tape_schedtable_in_bytes;
  var ok	: boolean);

begin
  write(unit, TAPE_SCHEDTABLE_LENGTH, buffer[0], ok)
end (* write_schedtable_file *);


(***************************  tape_handler  *****************************)
(*									*)
(*			      write_label				*)
(*									*)
(*	Write out an ANSII standard tape label from buffer to unit.	*)
(*	If it fails, backspace over the record and			*)
(*	write an erase gap. Re-try MAXIMUM_TAPE_RETRIES times.		*)
(*									*)
(************************************************************************)

procedure entry WRITE_LABEL(
      unit	: tape_unit_index;
  var buffer	: ansii_tape_label;
  var ok	: boolean);

begin
  write(unit, MAX_ANSII_TAPE_LABEL_SIZE, buffer[0], ok)
end (* write_label *);



(***************************  tape_handler  *****************************)
(*									*)
(*			     write_tape_page 				*)
(*									*)
(*	Write out a NETVAL page from buffer to unit.			*)
(*	If it fails, backspace over the record and			*)
(*	write an erase gap. Re-try MAXIMUM_TAPE_RETRIES times.		*)
(*									*)
(************************************************************************)

procedure entry WRITE_TAPE_PAGE(
      unit	: tape_unit_index;
  var buffer	: page;
  var ok	: boolean);

begin
  write(unit, PAGE_SIZE, buffer[0], ok)
end (* write_tape_page *);



(***************************  tape_handler  *****************************)
(*									*)
(*			write_blocked_tape_page				*)
(*									*)
(*	Write out a NETVAL blocked page from buffer to unit.		*)
(*	If it fails, backspace over the record and			*)
(*	write an erase gap. Re-try MAXIMUM_TAPE_RETRIES times.		*)
(*									*)
(************************************************************************)

procedure entry WRITE_BLOCKED_TAPE_PAGE(
      unit	: tape_unit_index;
  var buffer	: univ tape_page_block_in_bytes;
  var ok	: boolean);

begin
  write(unit, TAPE_PAGE_BLOCK_SIZE, buffer[0], ok)
end (* write_blocked_tape_page *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if include_dump



(******************************  tape_handler  **************************)
(*									*)
(*			write_ascii_dump_tape_block			*)
(*									*)
(* 	Write out a block of ascii formatted CUD data from buffer to    *)
(*	unit. Set end_tape to param.status = END_MEDIUM.		*)
(*									*)
(************************************************************************)

procedure entry WRITE_ASCII_DUMP_TAPE_BLOCK(
      unit	: tape_unit_index;
  var buffer	: univ ascii_dump_block_in_bytes;
  var ok	: boolean;
  var end_tape	: boolean);

begin
  write(unit, ASCII_DUMP_BLOCK_SIZE, buffer[0], ok);
  end_tape := param.status = END_MEDIUM
end (* write_ascii_dump_tape_block *);
$endif include_dump
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(***************************  tape_handler  *****************************)
(*									*)
(*			     write_cud_block 				*)
(*									*)
(*	Write out a NETVAL tape_cud_block from buffer to unit.		*)
(*	If it fails, backspace over the record and			*)
(*	write an erase gap. Re-try MAXIMUM_TAPE_RETRIES times.		*)
(*									*)
(************************************************************************)

procedure entry WRITE_CUD_BLOCK(
      unit	: tape_unit_index;
  var buffer	: univ tape_cud_block_in_bytes;
  var ok	: boolean);

begin
  write(unit, TAPE_CUD_BLOCK_SIZE, buffer[0], ok)
end (* write_cud_block *);





(***************************  tape_handler  *****************************)
(*									*)
(*			     write_mud_change  				*)
(*									*)
(************************************************************************)

procedure entry WRITE_MUD_CHANGE(
      unit	: tape_unit_index;
  var buffer	: univ tape_mudupd_header_in_bytes;
  var ok	: boolean);

begin
  write(unit, MAXIMUM_TAPE_MUDUPD_HEADER_SIZE, buffer[0], ok)
end (* write_mud_change *);



(***************************  tape_handler  *****************************)
(*									*)
(*			     write_named_list				*)
(*									*)
(*	Write out a tape_named_list_definition to unit.			*)
(*									*)
(************************************************************************)

procedure entry WRITE_NAMED_LIST(
      unit	: tape_unit_index;
  var buffer	: univ tape_named_list_definition_in_bytes;
  var ok	: boolean);

begin
  write(unit, TAPE_NAMED_LIST_DEFINITION_SIZE, buffer[0], ok)
end (* write_named_list *);



(***************************  tape_handler  *****************************)
(*									*)
(*			   write_global_access				*)
(*									*)
(*	Write out a tape_global_access_definition to unit.		*)
(*									*)
(************************************************************************)

procedure entry WRITE_GLOBAL_ACCESS(
      unit	: tape_unit_index;
  var buffer	: univ tape_global_access_definition_in_bytes;
  var ok	: boolean);

begin
  write(unit, MAXIMUM_TAPE_GLOBAL_ACCESS_DEFINITION_SIZE, buffer[0], ok)
end (* write_global_access *);
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(***************************  tape_handler  *****************************)
(************************************************************************)

begin
end (* tape_handler *);
!
(************************************************************************)
(*									*)
(*	TALLOC.NTV							*)
(*									*)
(*			     tape_allocater  				*)
(*									*)
(*	This monitor keeps track of tape units attached and assigned. 	*)
(*								 	*)
(*	The following identifiers must be defined externally:      	*)
(*	  tape_unit_index, tape_param, iodevice, disk_tape_information	*)
(*									*)
(************************************************************************)
(*									*)
(*				Revision Record				*)
(*									*)
(*	21Nov83	Original -- jrn						*)
(*									*)
(************************************************************************)



type
  TAPE_ATTACH_STATE = (UNCOMMITTED, IMPLIED, EXPLICIT);



type
  TAPE_DESCRIPTOR = record
    legal	 : boolean;
    attach_state : tape_attach_state;
    assigned	 : boolean;
    assigned_by	 : licensed_validator_index
  end (* TAPE_DESCRIPTOR *);



type TAPE_ALLOCATER = monitor;



var
  tape_io : tape_handler;


  tape_pool : array [tape_unit_index] of tape_descriptor;
!
(***************************  tape_allocater  ***************************)
(*									*)
(*				initialize				*)
(*									*)
(************************************************************************)

procedure initialize;

var
  unit : tape_unit_index;
  dev_stat : disk_tape_information;

begin
  for unit := 0 to TAPE_UNIT_LIMIT do
    begin
      tape_pool[unit].attach_state := UNCOMMITTED;
      tape_pool[unit].assigned := FALSE;
      tape_io.drive_status(unit, dev_stat);
      tape_pool[unit].legal :=
        not ((tape_io.param.status = FAILURE) and (tape_io.param.status2 < 0))
    end (* with *)
end (* initialize *);
!



(***************************  tape_allocater  ***************************)
(*									*)
(*			      do_detach_unit				*)
(*									*)
(*	DETACH the tape unit specified from the slot; set ATTACH_STATE	*)
(*	to UNCOMMITTED.							*)
(*									*)
(************************************************************************)

procedure do_detach_unit(
      unit	: tape_unit_index;
  var param	: tape_param);

begin
  tape_io.detach_unit(unit);
  param := tape_io.param;
  if (param.status = COMPLETE) or (param.status = INTERVENTION)
  then tape_pool[unit].attach_state := UNCOMMITTED
end (* do_detach_unit *);



(***************************  tape_allocater  ***************************)
(*									*)
(*			      do_attach_unit				*)
(*									*)
(*	ATTACH the tape unit specified to the slot; set ATTACH_STATE	*)
(*	to EXPLICIT if attach_explilcitly is TRUE, otherwise, set	*)
(*	ATTACH_STATE to IMPLIED.  UNIT MUST BE A LEGAL TAPE_UNIT_INDEX. *)
(*									*)
(*					attach_explicitly	    	*)
(*				    TRUE		FALSE	    	*)
(*					    			    	*)
(*   current  < UNCOMMITTED	>EXPLICIT	     >IMPLIED		*)
(*    state  <  IMPLIED		>EXPLICIT	     return success	*)
(*	      < EXPLICIT	return success	     return success	*)
(*									*)
(************************************************************************)

procedure do_attach_unit(
      unit		: tape_unit_index;
      attach_explicitly	: boolean;
  var success		: boolean;
  var param		: tape_param);

begin
  success := TRUE;
  with tape_pool[unit] do
    if attach_state = UNCOMMITTED
    then
      begin
	tape_io.attach_unit(unit);
	param := tape_io.param;
	if (param.status <> COMPLETE) and (param.status <> INTERVENTION)
	then success := FALSE
	else
	  if attach_explicitly
	  then attach_state := EXPLICIT
	  else attach_state := IMPLIED
      end
    else
      if attach_explicitly and (attach_state = IMPLIED)
      then attach_state := EXPLICIT
end (* do_attach_unit *);



(***************************  tape_allocater  ***************************)
(*									*)
(*				attach_unit				*)
(*									*)
(*	ATTACH the tape unit specified to the slot:			*)
(*	UNIT MUST BE A LEGAL TAPE_UNIT_INDEX.				*)
(*									*)
(************************************************************************)

procedure entry ATTACH_UNIT(
      unit	: tape_unit_index;
  var success	: boolean;
  var param	: tape_param);

begin
  param.status := COMPLETE;
  do_attach_unit(unit, TRUE, success, param)
end (* attach_unit *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code
!



(***************************  tape_allocater  ***************************)
(*									*)
(*				assign_unit				*)
(*									*)
(*	ASSIGN the tape unit specified to the validator.		*)
(*	Set ASSIGNED to TRUE, and if unit is not attached, set		*)
(*	attach_state to IMPLIED.					*)
(*									*)
(*					assigned			*)
(*		   FALSE     to validator     to other validator	*)
(*  UNCOMMITTED   ass + att      					*)
(*  IMPLIED			success		  failure		*)
(*  EXPLICIT	  assign	success		  failure		*)
(*									*)
(************************************************************************)

procedure entry ASSIGN_UNIT(
      unit	: tape_unit_index;
      validator	: licensed_validator_index;
  var status	: tape_assign_status;
  var param	: tape_param);

var
  success : boolean;

begin
  param.status := COMPLETE;
  if tape_pool[unit].assigned
  then
    if tape_pool[unit].assigned_by = validator
    then status := ASSIGN_OK
    else status := ALREADY_ASSIGNED
  else
    begin
      do_attach_unit(unit, FALSE, success, param);
      if success
      then
        begin
	  status := ASSIGN_OK;
          tape_pool[unit].assigned := TRUE;
          tape_pool[unit].assigned_by := validator
        end
      else status := ATTACH_FAILED
    end
end (* assign_unit *);
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!



(***************************  tape_allocater  ***************************)
(*									*)
(*				detach_unit				*)
(*									*)
(*	DETACH the tape unit specified from the slot.			*)
(*	THE UNIT MUST NOT BE ASSIGNED TO ANY OTHER VALIDATOR.		*)
(*									*)
(*					assigned			*)
(*		   FALSE     to validator     to other validator	*)
(*  UNCOMMITTED   success 	     					*)
(*  IMPLIED		     det + deas		  failure		*)
(*  EXPLICIT	  detach     det + deas		  failure		*)
(*									*)
(************************************************************************)

procedure entry DETACH_UNIT(
      unit	: tape_unit_index;
      validator	: licensed_validator_index;
  var param	: tape_param);

begin
  param.status := COMPLETE;
  with tape_pool[unit] do
    if not assigned or (assigned_by = validator)
    then
      begin
        tape_pool[unit].assigned := FALSE;
        do_detach_unit(unit, param)
      end
end (* detach_unit *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code
!



(***************************  tape_allocater  ***************************)
(*									*)
(*			      deassign_unit				*)
(*									*)
(*	DEASSIGN the tape unit that belongs to the validator.		*)
(*	Set ASSIGNED to FALSE;  if attach_state is IMPLIED,		*)
(*	detach unit.							*)
(*									*)
(*					assigned			*)
(*		   FALSE     to validator     to other validator	*)
(*  UNCOMMITTED     n/a 	     					*)
(*  IMPLIED		     deas + det		     nothing		*)
(*  EXPLICIT	 nothing        deas		     nothing		*)
(*									*)
(************************************************************************)

procedure entry DEASSIGN_UNIT(
      unit	: tape_unit_index;
      validator	: licensed_validator_index;
  var param	: tape_param);

begin
  param.status := COMPLETE;
  with tape_pool[unit] do
    if assigned and (assigned_by = validator)
    then
      begin
        assigned := FALSE;
        if attach_state = IMPLIED
        then do_detach_unit(unit, param)
      end
end (* deassign_unit *);
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!



(**************************  tape_allocater  ****************************)
(*									*)
(*			      legal_tape				*)
(*									*)
(*	This function returns true if the tape unit is legal.		*)
(*									*)
(************************************************************************)

function entry LEGAL_TAPE(
      unit	: tape_unit_index) : boolean;

begin
  legal_tape := tape_pool[unit].legal
end (* legal_tape *);



(**************************  tape_allocater  ****************************)
(*									*)
(*			    tape_information				*)
(*									*)
(*	Return the tape_descriptor for the specified tape unit.		*)
(*									*)
(************************************************************************)

procedure entry TAPE_INFORMATION(
      unit	: tape_unit_index;
  var info	: tape_descriptor);

begin
  info := tape_pool[unit]
end (* tape_information *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code



(**************************  tape_allocater  ****************************)
(*									*)
(*			    validator_tape				*)
(*									*)
(*	Return the unit that the validator has assigned.		*)
(*									*)
(************************************************************************)

procedure entry validator_tape(
      validator	: validator_index;
  var found	: boolean;
  var unit	: tape_unit_index);

var
  unit_index : tape_unit_index;

begin
  found := FALSE;
  for unit_index := 0 to TAPE_UNIT_LIMIT do
    with tape_pool[unit_index] do
    if assigned and (assigned_by = validator)
    then
      begin
        found := TRUE;
	unit := unit_index
      end
end (* validator_tape *);
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(***************************  tape_allocater  ***************************)
(************************************************************************)

begin
  initialize
end (* tape_allocater *);
!
(************************************************************************)
(*									*)
(*	taputl.ntv							*)
(*									*)
(*				tape_utility				*)
(*									*)
(*	This class handles the DISPLAY STATUS and DEASSIGN routines.	*)
(*	It is called both from the archive_commands class and at	*)
(*	logout time for privileged validators.				*)
(*									*)
(*      The following identifiers must be defined externally:		*)
(*	  tape_attach_state, tape_descriptor, tape_unit_index,		*)
(*	  validator_index						*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	08Jan85 - jrn							*)
(*	      - do not output ANY message in deassign_tape routine	*)
(*		if output_message is FALSE				*)
(*	21Jun84	- jrn							*)
(*	      - use disk_maintenance_code				*)
(*	14Mar84	Version 2.01 modified by jrn				*)
(*	      - added flag in the DEASSIGN_TAPE routine that makes it	*)
(*		optional to output the deassign message			*)
(*	Original -- jrn							*)
(*									*)
(************************************************************************)

type TAPE_UTILITY = class(
	validator	: licensed_validator_index;
$ifnone disk_maintenance_code 	login_pool	: login_distributer;
	tape_pool	: tape_allocater;
	format		: internal_to_string;
	user_terminal	: circuit_handler);



!
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code


(***************************  tape_utility  *****************************)
(*									*)
(*			     display_status				*)
(*									*)
(*      Type the status of all in use tape devices.			*)
(*									*)
(************************************************************************)

procedure entry DISPLAY_STATUS(
  var displayed : boolean);

var
  unit : tape_unit_index;
  name : username_string;
  info : tape_descriptor;

begin
  displayed := FALSE;
  for unit := 0 to TAPE_UNIT_LIMIT do
    begin
      tape_pool.tape_information(unit, info);
      if info.legal and (info.assigned or (info.attach_state <> UNCOMMITTED))
      then
	begin
          if not displayed
          then
            begin
	      user_terminal.write_quoted_text_line('unit\ ');
	      displayed := TRUE
	    end (* not displayed *);
          format.start;
	  format.format_number(unit, 10, 3);
	  format.skip_to(8);
	  if info.attach_state = EXPLICIT
	  then format.string('ATTACHED    \ ')
	  else format.skip(12);
	  if info.assigned
	  then
	    begin
	      format.string('ASSIGNED to \ ');
	      login_pool.validator_name(info.assigned_by, name);
	      format.username(name)
	    end;
	  format.write_line(user_terminal)
        end (* if info.legal... *)
    end (* for *)
end (* display_status *);
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)




(****************************  tape_utility  ****************************)
(*									*)
(*			  do_display_tape_error				*)
(*									*)
(************************************************************************)

procedure do_display_tape_error(
      tape_unit	: tape_unit_index;
      param	: tape_param);

begin
  format.start_line_message('Error on tape unit \');
  format.number(tape_unit, 10);
  format.colon_space;
  format.status_name(param.status);
  format.newline;
  format.controller_status(param.status, param.status2, param.count);
  format.write_line(user_terminal)
end (* do_display_tape_error *);
!
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code



(***************************  tape_utility  *****************************)
(*									*)
(*			     deassigned_tape				*)
(*									*)
(************************************************************************)

procedure entry DEASSIGN_TAPE(
      unit		: tape_unit_index;
      output_message	: boolean);

var
  param : tape_param;

begin
  tape_pool.deassign_unit(unit, validator, param);
  if output_message
  then
    if param.status <> COMPLETE
    then do_display_tape_error(unit, param)
    else
      begin
        format.start_message('tape unit \ ');
        format.number(unit, 10);
        format.string(' deassigned\');
        format.write_line(user_terminal)
      end
end (* deassign_tape *);
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(****************************  tape_utility  ****************************)
(*									*)
(*			    display_tape_error				*)
(*									*)
(************************************************************************)

procedure entry display_tape_error(
      tape_unit	: tape_unit_index;
      param	: tape_param);

begin
  do_display_tape_error(tape_unit, param)
end (* display_tape_error *);



(************************************************************************)
(************************************************************************)

begin (* initial statement *)
end (* tape_utility *);
!
(************************************************************************)
(*									*)
(*	FILTER.NTV							*)
(*									*)
(*				filter_utility				*)
(*									*)
(*	This class handles all filter message and print message		*)
(*	routines.							*)
(*									*)
(*      The routines are organized as follows:				*)
(*		clear_filter routine					*)
(*	        DISPLAY FILTER routines					*)
(*              FILTER COMMAND routines					*)
(*		MESSAGE command routines				*)
(*									*) 
(*      The following identifiers must be defined externally:		*)
(*	 	validator_index, username_string, modify_index,		*)
(*	 	message_kind_index, real_supervisor_index		*)
(*									*)
(*									*)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	17Oct88 - jrn							*)
(*		- add FILTER MODIFY EXPIRE, NUD and TIME		*)
(*	09Sep87 - neh							*)
(*	      - make modify conditional on changes_to_operlog		*)
(*	10Nov86 - neh							*)
(*	       - Add misc_utility and username_match			*)
(*	12Sep86 - neh							*) 
(*	      - Move MESSAGE command procedures print_log_message and   *)
(*		scan_message_command from globl_commands with changes   *)
(*		include check_validator, check_modify, check_master	*)
(*		and check_entry functions.				*)
(*	      - Change print_log_message to output modify_type,		*)
(*		supervisor number, cud name change and validator info.	*)
(*	      - Changed scan_message_command to call do_display_filter  *)
(*		and to only print messages if the message type is	*)
(*		selected.						*)
(*		Original -- neh						*)
(*									*)
(************************************************************************) 

type filter_utility = class(
$ifnone disk_maintenance_code	validator	: univ validator_index;
      format		: internal_to_string;
      argument_scan	: argument_scanner;
      keyword_util	: keyword_utility;
      mutil		: misc_utility;
      user_terminal	: circuit_handler;
      oplog		: operator_log);



type

$if changes_to_oper_log  MODIFY_SELECTION = array [modify_index] of boolean;

  FILTER_CRITERIA_SELECTION = record
    all_select 			: boolean;
    sup_to_match 		: array [real_supervisor_index] of boolean;
    message_type 		: array [message_kind_index] of boolean;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if CHANGES_TO_OPER_LOG
    modify_all 			: boolean;
    modify_type 		: modify_selection;
    cud_name_to_match 		: username_string;
$endif CHANGES_TO_OPER_LOG
$if NETVAL_IS_A_SLAVE
    master_number_select 	: boolean;
    master_number_to_match 	: validator_index;
$endif NETVAL_IS_A_SLAVE
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    validator_number_select 	: boolean;
    validator_number_to_match 	: validator_index;
    validator_name_to_match 	: username_string
  end (* filter_criteria_selection *);


(* Permanent Variables *)

var
  filter_selection	: filter_criteria_selection;
!
"
	Clear FILTER selections
"
(***************************  filter_utility  ***************************) 
(*									*) 
(*		 	     do_clear_filter				*) 
(*									*) 
(*	This procedure will clear the values in the filter_selection	*)
(*	record in order to remove previously selected filters.		*) 
(*	This procedure is called by the validator login procedure 	*) 
(*	and by the FILTER ALL command.					*) 
(*									*) 
(************************************************************************) 

procedure do_clear_filter;

var
  sup_index : real_supervisor_index;
  message_index : message_kind_index;
$if changes_to_oper_log  index : modify_index;

begin
  with filter_selection do
    begin
      for sup_index  := FIRST_SUPERVISOR to MAXIMUM_REAL_SUPERVISOR do
        sup_to_match[sup_index] := FALSE;
      for message_index := FIRST_MESSAGE_KIND to LAST_MESSAGE_KIND do
        message_type[message_index] := FALSE;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if CHANGES_TO_OPER_LOG
      modify_all := FALSE;
      for index := FIRST_MODIFY_TYPE to LAST_MODIFY_TYPE do
        modify_type[index] := FALSE;
      cud_name_to_match.size := 0;
$endif CHANGES_TO_OPER_LOG
$if NETVAL_IS_A_SLAVE
      master_number_select := FALSE;
      master_number_to_match := 0;
$endif NETVAL_IS_A_SLAVE
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      validator_number_select := FALSE;
      validator_number_to_match := 0;
      validator_name_to_match.size := 0
    end (* with *)
end (* do_clear_filter *);



(****************************  filter_utility  **************************) 
(*									*) 
(*		 	        clear_filter				*)
(*									*) 
(*	Set all filter selections to FALSE and values to 0.		*)
(*	Set all_select to TRUE.						*)
(*									*) 
(************************************************************************) 

procedure entry CLEAR_FILTER;

begin
  do_clear_filter;
  filter_selection.all_select := TRUE
end (* clear_filter *);
!
"
		Display Filter Selection Routines
"


(***************************  filter_utility  ***************************) 
(*									*) 
(*		 	    display_supervisor				*) 
(*									*) 
(*	Display supervisor numbers which are on in filter_selection.	*)
(*									*) 
(************************************************************************) 

procedure display_supervisor; 

var
  sup_found : boolean;
  sup_index : real_supervisor_index;

begin
  sup_found := FALSE;
  with filter_selection do
    for sup_index := FIRST_SUPERVISOR to MAXIMUM_REAL_SUPERVISOR do
      if sup_to_match[sup_index]
      then
	begin
	  if sup_found
	  then
	    begin
	      format.character(ASCII_COMMA);
	      format.skip (1)
	    end
	  else
            begin
              sup_found := TRUE;
              format.start_message('Supervisor \');
            end (* not sup_found *);
          format.sup_number(sup_index)
        end (* if sup_to_match *);
  if sup_found then format.write_line(user_terminal)
end (* display_supervisor *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if changes_to_oper_log



(*****************************  filter_utility  *************************) 
(*									*)
(*		 	        display_modify				*)
(*									*)
(************************************************************************)

procedure display_modify(
       cud_name	: username_string);

var
  i : modify_index;

begin
  i := FIRST_MODIFY_TYPE;
  while not filter_selection.modify_type[i] and (i < LAST_MODIFY_TYPE) do
    i := succ(i);
  if filter_selection.modify_type[i]
  then
    begin
      format.put_modify_description(i);
      for i := succ(i) to LAST_MODIFY_TYPE do
        if filter_selection.modify_type[i]
        then
          begin
	    format.write_line(user_terminal);
	    format.start_message('modify \');
            format.put_modify_description(i)
          end (* if modify_type[i] *);
	  if cud_name.size > 0
	  then
	    begin
	      format.write_line(user_terminal);
	      format.start_message('modify \')
	    end
    end (* if modify_type[i] *);
  if cud_name.size > 0
  then
    begin
      format.string('user \');
      format.username(cud_name)
    end (* if cud_name.size > 0 *)
end (* display_modify *);
$endif changes_to_oper_log
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*) 



(***************************  filter_utility  ***************************) 
(*									*) 
(*		 	    do_display_filters				*)
(*									*) 
(*	This procedure is called by the DISPLAY FILTER and MESSAGE	*)
(*	commands to scan the filter_selection record for the filter	*)
(*	types which are selected.					*)
(*									*) 
(************************************************************************) 

procedure do_display_filters;

var
  sup_index : real_supervisor_index;
  message_index : message_kind_index;
$if changes_to_oper_log  index : modify_index;

begin
  with filter_selection do
    begin
      if all_select
      then format.start_message('ALL \ ')
      else format.start;
      format.string('Messages currently filtered\');
      format.write_line(user_terminal);
      if not all_select
      then
        begin
          display_supervisor;
	  for message_index := FIRST_MESSAGE_KIND to LAST_MESSAGE_KIND do
	    if message_type[message_index]
	    then
	      begin
    	        format.start;
	        format.put_message_kind(message_index);
	        format.skip(1);
	        if message_index = VALIDATOR_OPLOG_MSG
		then
		  begin
		    if validator_number_select
	            then
		      begin
		        format.string('number \');
		        format.number(validator_number_to_match, 10)
		      end
	            else
		      if validator_name_to_match.size > 0
	              then
		        begin
		          format.string('username \');
		          format.username(validator_name_to_match);
		        end
		  end (* VALIDATOR_OPLOG_MSG *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if NETVAL_IS_A_SLAVE 
	        if (message_index = MASTER_OPLOG_MSG) and master_number_select
	        then
		  begin
		    format.string('number \');
		    format.number(master_number_to_match, 10)
		  end (* MASTER_OPLOG_MSG and master_number_select *);
$endif NETVAL_IS_A_SLAVE
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if CHANGES_TO_OPER_LOG 
	        if message_index = MODIFY_CUD_OPLOG_MSG
		then
		  begin
		    if filter_selection.modify_all
		    then format.string('ALL\')
	            else display_modify(cud_name_to_match)
		  end (* MODIFY_CUD_OPLOG_MSG *);
$endif CHANGES_TO_OPER_LOG
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
                format.write_line(user_terminal)
	      end (* if message_type *)
        end (* not all_select *)
    end (* with filter_selection *)
end (* do_display_filters *);
!
"
		DISPLAY FILTER Command
"


(****************************  filter_utility  **************************) 
(*									*) 
(*		 	       display_filters				*)
(*									*) 
(*	Command to output current filter selectio.			*)
(*									*) 
(************************************************************************) 

procedure entry DISPLAY_FILTERS;

begin
  do_display_filters
end (* display_filters *);
"
		FILTER Command
"


(****************************  filter_utility  **************************) 
(*									*) 
(*		 	      get_sup_to_match				*) 
(*									*) 
(*	Return real_superviosr_index of sup  number in command string.	*)
(*									*) 
(************************************************************************) 

procedure get_sup_to_match(
  var scanned	: scanned_command);

var
  index : real_supervisor_index;
  freeword : command_freeword_index;
  temp : integer;

begin
  if scanned.freeword_count = 0
  then
    for index := FIRST_SUPERVISOR to MAXIMUM_REAL_SUPERVISOR do
      filter_selection.sup_to_match[index] := TRUE
  else
    for freeword := 0 to scanned.freeword_count - 1 do
      begin
        argument_scan.freeword_list(freeword,
          FIRST_SUPERVISOR + PRINT_SUPERVISOR_OFFSET,
	  MAXIMUM_REAL_SUPERVISOR + PRINT_SUPERVISOR_OFFSET, 10,
	  scanned, temp);
        if scanned.status = CMD_OK
        then filter_selection.sup_to_match[temp - PRINT_SUPERVISOR_OFFSET] := TRUE
      end (* for *)
end (* get_sup_to_match *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if CHANGES_TO_OPER_LOG


(*****************************  filter_utility  *************************) 
(*									*) 
(*		 	       scan_modify_type				*) 
(*									*) 
(*	 This procedure will check for a modify_type in the command.	*)
(*									*) 
(************************************************************************) 

procedure scan_modify_type(
  var scanned	: scanned_command);

var
  count : integer;
  change_keyword : command_keyword_index;
  temp_modify : modify_selection;

begin
  temp_modify := filter_selection.modify_type;
  count := 0;
  if argument_scan.check_keyword(PRIMARY_FILTER_VALIDATOR_USER_KEYWORD,
    scanned)
  then
    begin
      argument_scan.keyword_username(
        PRIMARY_FILTER_VALIDATOR_USER_KEYWORD, scanned,
	filter_selection.cud_name_to_match);
    end (* PRIMARY_FILTER_VALIDATOR_USER_KEYWORD *)
  else
    for change_keyword := PRIMARY_FILTER_MODIFY_ACCESS_KEYWORD to
      PRIMARY_FILTER_MODIFY_NEW_KEYWORD do
      if argument_scan.check_keyword(change_keyword, scanned)
      then
        begin
          case change_keyword of
            PRIMARY_FILTER_MODIFY_ACCESS_KEYWORD: temp_modify[ACCESS] := TRUE;
            PRIMARY_FILTER_MODIFY_CONTROL_KEYWORD: temp_modify[CONTROL] :=TRUE;
            PRIMARY_FILTER_MODIFY_DELETE_KEYWORD: temp_modify[DELETE] := TRUE;
            PRIMARY_FILTER_MODIFY_DISTRICT_KEYWORD:
	      temp_modify[DISTRICT] := TRUE;
$if password_expiration_date_in_cud
            PRIMARY_FILTER_MODIFY_EXPIRE_DATE_KEYWORD:
	      temp_modify[EXPIRE_DATE] := TRUE;
$endif password_expiration_date_in_cud
            PRIMARY_FILTER_MODIFY_GAN_KEYWORD: temp_modify[GAN] := TRUE;
$if NETVAL_IS_A_SLAVE
            PRIMARY_FILTER_MODIFY_GFD_KEYWORD: temp_modify[GFD] := TRUE;
$if INCLUDE_IRC
            PRIMARY_FILTER_MODIFY_IRC_KEYWORD: temp_modify[IRC] := TRUE;
$endif INCLUDE_IRC
$endif NETVAL_IS_A_SLAVE
            PRIMARY_FILTER_MODIFY_NAME_KEYWORD: temp_modify[CHANGENAME] :=TRUE;
            PRIMARY_FILTER_MODIFY_NEW_KEYWORD: temp_modify[NEW] := TRUE;
$ifnone BEFORE_SUP_V43
            PRIMARY_FILTER_MODIFY_NUD_KEYWORD:
	      temp_modify[NUD_CONTROL] := TRUE;
$endif BEFORE_SUP_V43
            PRIMARY_FILTER_MODIFY_PASSWORD_KEYWORD: temp_modify[PASSWORD] :=
	      TRUE;
$if OVERFLOW_CUD_ENTRIES
            PRIMARY_FILTER_MODIFY_OVERFLOW_KEYWORD: temp_modify[OVERFLOW] :=
	      TRUE;
$endif OVERFLOW_CUD_ENTRIES
$if restrict_users_by_time
            PRIMARY_FILTER_MODIFY_TIME_KEYWORD: temp_modify[TIMES] := TRUE;
$endif restrict_users_by_time
            PRIMARY_FILTER_MODIFY_UUN_KEYWORD: temp_modify[UUN] := TRUE
        end (* case *);
      count := count + 1
    end (* if argument_scan.check_keyword *);
  if count > 5
  then scanned.status := TOO_MANY_ARGS;
  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    begin
      filter_selection.modify_all := FALSE;
      filter_selection.modify_type := temp_modify
    end
end (* scan_modify_type *);
$endif CHANGES_TO_OPER_LOG
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*) 



(****************************  filter_utility  **************************) 
(*									*) 
(*		 	     scan_filter_command			*) 
(*									*) 
(*	This procedure is called by the FILTER command to scan the	*)
(*	command line and turn the selected filter on.			*)
(*									*) 
(************************************************************************) 

procedure entry SCAN_FILTER_COMMAND(
  var scanned	: scanned_command);

var
  filter_keyword : command_keyword_index;
  val_keyword : command_keyword_index;
  message_index : message_kind_index;
$if changes_to_oper_log  index : modify_index;
  username : username_string;
  temp : validator_index;

begin
  with filter_selection do
    begin
      argument_scan.find_keyword(PRIMARY_FILTER_ALL_KEYWORD,
$ifnone LOGICAL_VOLUMES PRIMARY_FILTER_VALIDATOR_KEYWORD,
$if LOGICAL_VOLUMES PRIMARY_FILTER_VOLUMES_KEYWORD,
 	  scanned, filter_keyword);
      if scanned.status = CMD_OK
      then
        case filter_keyword of
          PRIMARY_FILTER_ALL_KEYWORD: do_clear_filter;
	  PRIMARY_FILTER_ARCHIVE_KEYWORD: message_index := ARCHIVE_OPLOG_MSG;
	  PRIMARY_FILTER_CONSISTENCY_KEYWORD: message_index := CONSISTENCY_OPLOG_MSG;
	  PRIMARY_FILTER_CUDERROR_KEYWORD: message_index := CUD_OPLOG_MSG;
	  PRIMARY_FILTER_DEBUG_KEYWORD: message_index := DEBUGGING_OPLOG_MSG;
	  PRIMARY_FILTER_FILE_KEYWORD: message_index := FILE_OPLOG_MSG;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if NETVAL_IS_A_SLAVE
	  PRIMARY_FILTER_MASTER_KEYWORD:
	    begin
	      message_index := MASTER_OPLOG_MSG;
	      if argument_scan.check_keyword(
		PRIMARY_FILTER_VALIDATOR_NUMBER_KEYWORD, scanned)
	      then
		begin
		  keyword_util.get_numeric_keyword_value(
	            PRIMARY_FILTER_VALIDATOR_NUMBER_KEYWORD, 10,
		    FIRST_VALIDATOR, MAXIMUM_VALIDATOR,
	            scanned, temp);
	          if scanned.status = CMD_OK
  	          then
		    begin
		      master_number_select := TRUE;
		      master_number_to_match := temp
		    end
		end (* if check_keyword *)
	      else
		if scanned.keyword_count = 1
		then master_number_select := FALSE
	    end (* PRIMARY_FILTER_MASTER_KEYWORD *);
$endif NETVAL_IS_A_SLAVE
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if CHANGES_TO_OPER_LOG
	  PRIMARY_FILTER_MODIFY_KEYWORD:
	    begin
	      message_index := MODIFY_CUD_OPLOG_MSG;
	      if scanned.keyword_count > 1
	      then scan_modify_type(scanned)
	      else
		begin
		  for index := FIRST_MODIFY_TYPE to LAST_MODIFY_TYPE do
		    modify_type[index] := FALSE;
		  cud_name_to_match.size := 0;
		  modify_all := TRUE
		end
	    end (* PRIMARY_FILTER_MODIFY_KEYWORD *);
$endif CHANGES_TO_OPER_LOG
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	  PRIMARY_FILTER_MUDUPDATE_KEYWORD: message_index := MUDUPD_OPLOG_MSG;
	  PRIMARY_FILTER_OPERATOR_KEYWORD: message_index := OPERLOG_REPORT_MSG;
	  PRIMARY_FILTER_PARAMETER_KEYWORD: message_index := CUD_PARAM_OPLOG_MSG;
	  PRIMARY_FILTER_SUPERVISOR_KEYWORD:
	      if argument_scan.check_keyword(
		PRIMARY_FILTER_SUPERVISOR_OFF_KEYWORD, scanned)
	      then message_index := UPDATE_OFF_MSG
	      else get_sup_to_match(scanned);
	    
	  PRIMARY_FILTER_SYSMSG1_KEYWORD: message_index := SYSMSG1_OPLOG_MSG;
$ifany (force_password_change, global_password_only_login)
	  PRIMARY_FILTER_PASSCHANGER_KEYWORD: message_index := PASSCHANGER_MSG;
$endif any force_password_change global_password_only_login
	  PRIMARY_FILTER_UN2_KEYWORD: message_index := UN2_OPLOG_MSG;
$if REUSE_UUNS
 	  PRIMARY_FILTER_UUNMERGE_KEYWORD: message_index := MERGE_UUN_OPLOG_MSG;
$endif REUSE_UUNS
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if LOGICAL_VOLUMES
	  PRIMARY_FILTER_VOLUMES_KEYWORD: message_index := LV_OPLOG_MSG;
$endif LOGICAL_VOLUMES
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	  PRIMARY_FILTER_VALIDATOR_KEYWORD:
	    begin
	      message_index := VALIDATOR_OPLOG_MSG;
	      if scanned.keyword_count > 1
	      then
		begin
	          argument_scan.find_keyword(
		    PRIMARY_FILTER_VALIDATOR_NUMBER_KEYWORD,
		    PRIMARY_FILTER_VALIDATOR_USER_KEYWORD,
		    scanned, val_keyword);
		  if (val_keyword = PRIMARY_FILTER_VALIDATOR_NUMBER_KEYWORD)
		    and (scanned.status = CMD_OK)
	          then
		    begin
		      keyword_util.get_numeric_keyword_value(
	                PRIMARY_FILTER_VALIDATOR_NUMBER_KEYWORD, 10,
		        FIRST_VALIDATOR, MAXIMUM_VALIDATOR,
	                scanned, temp);
  	              if scanned.status = CMD_OK
                      then
			begin
			  validator_name_to_match.size := 0;
			  validator_number_select := TRUE;
			  validator_number_to_match := temp
			end
		    end
		  else
	            if (val_keyword = PRIMARY_FILTER_VALIDATOR_USER_KEYWORD)
		      and (scanned.status = CMD_OK)
		    then
		      begin
		        argument_scan.keyword_username(
		          PRIMARY_FILTER_VALIDATOR_USER_KEYWORD,
                          scanned, validator_name_to_match);
		        if scanned.status = CMD_OK
		        then validator_number_select := FALSE
    	              end
		end (* if keyword_count > 1 *)
	      else
		begin
		  validator_name_to_match.size := 0;
		  validator_number_select := FALSE
		end
	    end (* PRIMARY_FILTER_VALIDATOR_KEYWORD *)
        end (* case *);
      argument_scan.extra_argument_check(scanned);
      if scanned.status = CMD_OK
      then
	begin
	  if filter_keyword = PRIMARY_FILTER_ALL_KEYWORD
	  then all_select := TRUE
	  else all_select := FALSE;
          if ((filter_keyword <> PRIMARY_FILTER_SUPERVISOR_KEYWORD) and
	    (filter_keyword <> PRIMARY_FILTER_ALL_KEYWORD)) or
	    (message_index = UPDATE_OFF_MSG)
          then message_type[message_index] := TRUE;
	  user_terminal.write_quoted_text_line('message filter accepted\')
	end (* status = CMD_OK *)
    end (* with *)
end (* scan_filter_command *);
"
		MESSAGE command routines
"




(****************************  filter_utility ***************************) 
(*									*) 
(*		 	         sup_selected				*) 
(*									*) 
(*	 Return true if all sups are selected are sup_number is TRUE	*)
(*	 in sup_to_match.						*)
(*									*)
(************************************************************************)

function sup_selected : boolean;

var
  done : boolean;
  temp : boolean;
  sup_index : real_supervisor_index;

begin
  sup_index := FIRST_SUPERVISOR;
(* check if any sups were selected *)
  done := FALSE;
  repeat
    temp := filter_selection.sup_to_match[sup_index];
    if sup_index < MAXIMUM_REAL_SUPERVISOR
    then sup_index := sup_index + 1
    else done := TRUE
  until done or temp (* either found sup on or checked all sups *);
  sup_selected := temp
end (* sup_selected *);



(****************************  filter_utility  **************************) 
(*									*) 
(*		 	      check_validator				*) 
(*									*) 
(*	Return TRUE is validator name or number in message matches	*)
(*	validator name or number in filter selection.			*)
(*									*) 
(************************************************************************) 

function check_validator(
      sup_number: integer;
      number	: validator_index;
      name	: username_string) : boolean;

var
  temp : boolean;

begin
  with filter_selection do
    begin
      if validator_number_select
      then temp := number = validator_number_to_match
      else
        if validator_name_to_match.size > 0
        then temp := mutil.username_match(validator_name_to_match, name)
        else temp := TRUE;
      if sup_selected 
      then
        if ((sup_number >= FIRST_SUPERVISOR)
	  and (sup_number <= MAXIMUM_REAL_SUPERVISOR))
        then temp := sup_to_match[sup_number] and temp
        else temp := FALSE
    end (* with *);
  check_validator := temp
end (* check_validator *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if NETVAL_IS_A_SLAVE


(****************************  filter_utility ***************************) 
(*									*) 
(*		 	        check_master				*)
(*									*)
(*	 Return TRUE is master_number not selected or if number is	*)
(*	 equal to master_number_to_match.				*)
(*									*)
(************************************************************************) 

function check_master(
      number	: validator_index) : boolean;

var
  temp : boolean;

begin
  with filter_selection do
    begin
      if master_number_select
      then temp := number = master_number_to_match
      else temp := TRUE
    end (* with *);
  check_master := temp
end (* check_master *);
$endif NETVAL_IS_A_SLAVE
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if CHANGES_TO_OPER_LOG


(****************************  filter_utility  **************************) 
(*									*) 
(*		 	        check_modify				*)
(*									*) 
(*	Return TRUE if modify_all is TRUE or if modify_type[index]	*)
(*	is TRUE or is cud_name matches cud_name_to_match.		*)
(*									*) 
(************************************************************************) 

function check_modify(
      cud_name	: username_string;
      index	: modify_index) : boolean;

var
  temp : boolean;
  i : modify_index;

begin
  with filter_selection do
    if not modify_all
    then
      begin
	i := FIRST_MODIFY_TYPE;
	while not modify_type[i] and (i < LAST_MODIFY_TYPE) do
	    i := succ(i);
	if modify_type[i]
	then
	  begin
	    if (index >= FIRST_MODIFY_TYPE) and (index <= LAST_MODIFY_TYPE)
	    then 
	      begin
	        if cud_name_to_match.size > 0
	        then temp := mutil.username_match(cud_name_to_match, cud_name)
		  and modify_type[index]
	        else temp := modify_type[index]
	      end
	    else temp := FALSE
	  end (* if modify_type[i] *)
	else temp := cud_name_to_match = cud_name
      end (* if not modify_all *)
    else temp := TRUE;
  check_modify := temp
end (* check_modify *);
$endif CHANGES_TO_OPER_LOG
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(****************************  filter_utility  **************************) 
(*									*) 
(*		 	       check_entry			 	*) 
(*									*) 
(*	Function to check if a log_entry is of the type selected	*)
(*	by filter_criteria.						*)
(*									*) 
(************************************************************************) 

function check_entry(
      next_message	: oper_log_entry) : boolean;

var
  temp : boolean;

begin
  with filter_selection do
    begin
      temp := all_select;
      if not temp
      then
        with next_message do
	  begin
	    if (kind >= first_message_kind) and
              (kind <= last_message_kind)
            then temp := message_type[kind]
	    else temp := FALSE;
	    if temp
	    then
              begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if NETVAL_IS_A_SLAVE
  	        if kind = MASTER_OPLOG_MSG
      	        then temp := check_master(login_number)
                else
$endif NETVAL_IS_A_SLAVE
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if CHANGES_TO_OPER_LOG
      	        if kind = MODIFY_CUD_OPLOG_MSG
      	        then temp := check_modify(cud_name, modify)
	        else
$endif CHANGES_TO_OPER_LOG
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
                if kind = VALIDATOR_OPLOG_MSG
                then temp := check_validator(sup_number, login_number,
		  login_name)
		else
	          if (kind = CONSISTENCY_OPLOG_MSG) or (
		    (kind = SYSMSG1_OPLOG_MSG) or (kind = UN2_OPLOG_MSG))
	          then
                    if sup_selected
		    then
		      if ((sup_number >= FIRST_SUPERVISOR)
	                and (sup_number <= MAXIMUM_REAL_SUPERVISOR))
                      then temp := sup_to_match[sup_number]
		      else temp := FALSE
          end (* if temp *)
        else
          if sup_selected
	  then
            if ((sup_number >= FIRST_SUPERVISOR)
	      and (sup_number <= MAXIMUM_REAL_SUPERVISOR))
            then temp := sup_to_match[sup_number] and
	      ((not message_type[CONSISTENCY_OPLOG_MSG]) and
	      (not message_type[SYSMSG1_OPLOG_MSG])) and
	      ((not message_type[UN2_OPLOG_MSG]) and
	      (not message_type[VALIDATOR_OPLOG_MSG]))
	    else temp := FALSE
      end (* with next_message *)
    end (* with filter_selection *);
  check_entry := temp
end (* check_entry *);



(**************************  filter_utility  ****************************)
(*									*)
(*			   print_log_messages				*)
(*									*)
(*	Print operator_log message information in oper_log_entry to	*)
(*	user's terminal.						*)
(*									*) 
(************************************************************************)

procedure print_log_message(
  var next_message 	: oper_log_entry;
  var last_time		: integer);

begin
  if check_entry(next_message)
  then
    with next_message do
      begin
        if time <> last_time
        then
          begin
            format.start_and_newline;
            format.time(time);
            format.write_line(user_terminal);
            last_time := time
          end (* not last_time *);
        format.start;
        if (kind = SYSMSG1_OPLOG_MSG) or (kind = UN2_OPLOG_MSG)
        then
	  begin
	    format.put_message_kind(kind);
	    format.string(' error on \ ')
          end;
        if (sup_number > 0) and (kind <> VALIDATOR_OPLOG_MSG)
        then 
	  begin
	    format.string(SUPERVISOR_MESSAGE);
	    format.sup_number(sup_number);
	    format.write_line(user_terminal)
	  end;
          user_terminal.write_log_message(message);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if CHANGES_TO_OPER_LOG
        if kind = MODIFY_CUD_OPLOG_MSG
        then
          begin
	    format.start;
	    format.username(cud_name);
	    format.by_validator(login_name);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if NETVAL_IS_A_SLAVE
	    format.string(' (validator \ ');
	    format.number(login_number, 10);
	    format.character(ASCII_RIGHT_PARENS);
$endif NETVAL_IS_A_SLAVE
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	    format.write_line(user_terminal)
          end (* MODIFY_CUD_OPLOG_MSG *)
        else
$endif CHANGES_TO_OPER_LOG
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
          if (login_name.size > 0) and (kind <> MODIFY_CUD_OPLOG_MSG)
	  then
            begin
	      format.start;
	      if sup_number > 0
	      then
		begin
		  format.string(SUPERVISOR_MESSAGE);
		  format.sup_number(sup_number);
		  format.by_validator(login_name)
		end
	      else
		begin
	          format.number(login_number, 10);
	          format.skip(3);
                  format.username(login_name)
		end (* else *);
              format.write_line(user_terminal)
	    end (* if login_name.size *)
          else user_terminal.write_newline
      end (* with *)
end (* print_log_message *);



(***************************  filter_utility  ***************************)
(*									*)
(*			   scan_message_command				*)
(*									*)
(*	Output selected filters, output each message which is of the    *)
(*	type selected in filter_selection.				*)
(*									*) 
(************************************************************************)

procedure entry SCAN_MESSAGE_COMMAND(
  var scanned	: scanned_command);

var
  start_time : integer (* start time if specified *);
  last_time : integer;
  next_message : oper_log_entry;
  got_message : boolean;

begin
  last_time := -1 (* set previous message time to impossible time *);
  if argument_scan.check_keyword(PRIMARY_MESSAGE_FROM_KEYWORD, scanned)
  then argument_scan.freeword_date_and_time(0, REALTIME, scanned, start_time)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code else scanned.status := ARG_MISSING;
$ifnone disk_maintenance_code ;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  if scanned.status = CMD_OK
  then argument_scan.extra_argument_check(scanned);

  if scanned.status = CMD_OK
  then
    begin
      do_display_filters;
      if PRIMARY_MESSAGE_FROM_KEYWORD in scanned.keyword_present
      then
        begin
(* Find the first message of a time greater than or equal to the time	*)
(* requested and set up validator_sequence with that sequence.		*)
(* NOTE: between the time of finding the first record and reading it,	*)
(* another process may write over the record desired			*)
	  oplog.find_timed_message(
$ifnone disk_maintenance_code		validator,
            start_time, got_message);
	  while got_message and user_terminal.sendable do
	    begin
              oplog.read_timed_message(
$ifnone disk_maintenance_code		validator,
                next_message, got_message);
  	      if got_message
  	      then print_log_message(next_message, last_time)
            end (* while *)
        end
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      else
        repeat
          oplog.read(next_message, got_message);
	  if got_message
	  then
	    begin
	      print_log_message(next_message, last_time);
	      if not user_terminal.break_pending
	      then oplog.advance_address (* advances "last read record" *)
	    end
          else
            begin
              wait;
	      user_terminal.check_circuit
	    end
        until not user_terminal.sendable
    end (* if status = CMD_OK *)
end (* scan_message_command *);



(************************************************************************)
(************************************************************************)

begin (* initial statement *)
end (* filter_utility *);
!
(************************************************************************)
(*									*)
(*	ARCCMD.NTV							*)
(*									*)
(*			archive_commands				*)
(*									*)
(*	This class handles all the ARCHIVE sub-system commands.		*)
(*									*)
(*	The routines are organized as follows:				*)
(*		reporting routines					*)
(*		utility routines					*)
(*		label character manipulation routines			*)
(*		commands (RESTORE, STORE, others)			*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	06Dec89 - neh							*)
(*		- add two volume tape ability				*)
(*	01Nov89 - neh							*)
(*		- remove index variable from reformat_command, not used *)
(*	02Oct88 - jrn							*)
(*		- use ganpass_file_exists				*)
(*	18Nov87 - neh							*)
(*	      - add ARCHIVE_RESTORE_DNIC_FILE_KEYWORD to restore_command*)
(*	      - add store_dnic_file					*)
(*	12Aug87 - neh							*)
(*	      - replace tymshare_cud_format with check_time_status	*)
(*	18Sep87 - neh							*)
(*	      - merge GPO and FPC with 5.00				*)
(*	19Mar87 - rsb							*)
(*		- add code to enable STORE and RESTORE of Passtable	*)
(*		  if force_password_change or global_password_only_login*)
(*		  are enabled, 						*)
(*		- add PASMON to class definition if either		*)
(*		  global_password_only_login or				*)
(*		  force_password_change are enabled			*)
(*	23Feb87 - neh							*)
(*	      - add REFORMAT command to convert to MUD version 43	*)
(*		if CONVERT_TO_43 is enabled				*)
(*	09Sep86 - neh							*) 
(*	      - Change oper_log_message kind from FILE_OPLOG_MSG to	*)
(*		ARCHIVE_OPLOG_MSG in DUMP, STORE and RESTORE.		*)
(*	12Aug86 - jrn							*)
(*	      - add lots of "FAILED" comments to help catch the		*)
(*		operators attention when a STORE or RESTORE aborts	*)
(*	14May86 - neh							*)
(*	      - add DUMP command to dump CUD in ascii format to tape	*)
(*	      - add reporting routines					*)
(*		 (REPORT_FULL_ON_BLOCK, REPORT_CUD_ENTRY_ERROR)		*)
(*	      - add get_cud_locked					*)
(*	      - add output_storing to be used by initialize_file_store  *)
(*		and initilize_dump					*)
(*	      - add write_eof_label to be used by complete_store	*)
(*	10Mar86 - jrn							*)
(*	      - redo reuse_uuns to maintain a bit map for 18 bit UUNS	*)
(*		and change the add back scheme to be a dated list	*)
(*	27Jan86 - jrn							*)
(*	      - change NULL_PROMPT to NULL_STRING			*)
(*	10Jan85 - jrn - version 3.00					*)
(*	      - do not require "UNIT" keyword to be entered		*)
(*	      - store different format CUD_PARAMETER_FILE if reuse_uuns	*)
(*		is enabled						*)
(*	      - add logical_volume_directory				*)
(*	      - new format tape - ANSII format labels and records;	*)
(*		named_lists, classes and groups rather than pages	*)
(*	12Mar85 - jrn - Version 2.03					*)
(*	      - do not put out a newline between each CUD error message	*)
(*		during store and restore				*)
(*	21Jun84	- jrn							*)
(*	      - use disk_maintenace_code; move RESTORE to NVDM and	*)
(*		allow:							*)
(*			RESTORE CUD BLOCK range				*)
(*	03Apr84 Version 2.02 - jrn					*)
(*	      - consolidate OKAY message				*)
(*	14Mar84	Version 2.01 - jrn neb					*)
(*	      - more descriptive procedure names, shorter procedure	*)
(*		names where possible, single-use procedures combined,	*)
(*		various other efficiencies				*)
(*	      - get_unit remembers if the unit specified has been pre-	*)
(*		viously assigned, and if so, does not deassign it when	*)
(*		done							*)
(*		Original -- jrn						*)
(*									*)
(************************************************************************)

type ARCHIVE_COMMANDS = class(
	validator	: licensed_validator_index;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifall (disk_maintenance_code, logical_volumes)
	lv_dir		: logical_volume_directory;
$endif (disk_maintenance_code, logical_volumes)
$ifnone disk_maintenance_code 	login_pool	: login_distributer;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	tape_pool	: tape_allocater;
	mud_change	: mud_change_handler;
	sys_io		: system_handler;
	mutil		: misc_utility;
	statistics	: statistics_gatherer;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code
	file_system	: file_system_manager;
	param_manager	: cud_parameter_controller;
$if include_dump
        cmd_utility	: command_level_utility;
	cud_update_util	: cud_updater_utility;
$endif include_dump
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
        cud_access	: cud_access_controller;
	block_updater	: cud_block_updater;
	block_utility	: cud_block_utility;
	cud_utility	: cud_entry_utility;
$ifany (BEFORE_SUP_V43, CONVERT_TO_43)      cud_updater     : cud_entry_updater;
$ifnone BEFORE_SUP_V43       mud_updater	: mud_entry_updater;
$if ganpass_file_exists
        pasmon		: passtable_handler;
$endif ganpass_file_exists
$if INCLUDE_DNIC
	dnic		: dnic_file_handler;
$endif INCLUDE_DNIC
	dsksys          : disk_system;
	tape_io		: tape_handler;
	tape_util	: tape_utility;
	user_terminal	: circuit_handler;
	command_read	: command_loop;
	argument_scan	: argument_scanner;
	freeword_utility: freeword_response_utility;
	keyword_util	: keyword_utility;
	keyword_scan	: keyword_scanner;
	scan_error	: command_error_message;
	format		: internal_to_string;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code 	config_utility	: configuration_utility;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	oplog		: operator_log;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code
	oper_messages	: operator_messages;
	list_io		: node_host_list_io_utility;
	list_allocater	: node_host_list_allocater;
	list_access	: node_host_list_access;
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
 	calendar	: date_time_converter;
	list_utility	: node_host_list_utility);



const
  error_offset_message = ' error, offset: \ ';
  file_header_message = '(header)\ ';
  file_nodelists_message = '(nodelists)\';
  file_hostlists_message = '(hostlists)\';
  file_classes_message = '(classes)\';
  file_groups_message = '(groups)\ ';
(*-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code
  not_assigned = 'no tape unit assigned\';
  storing_message = 'storing \ ';
$if include_dump
  USER_COUNT_SIZE = 6	(* number of places in ascii string *);
  ACCESS_COUNT_SIZE = 4;
  ASCII_DUMP = ' ASCII dump\';
  ASCII_PROFILE_FLAG = 'P';
$endif include_dump
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



var
  param_file : cud_parameter_file_utility;
  vol_label  : quoted_text;
  label_date : array [0..5] of char;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code   config_utility : configuration_utility;
$if CONVERT_TO_43
  label_version : integer;

  read_entries : integer (* CUD entries read *);
  write_entries : integer (* CUD entries written *);
  errors : integer (* entries not written due to error *);
$endif CONVERT_TO_43
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
"
		reporting routines
"


(**************************  archive_commands  **************************)
(*									*)
(*			    report_tape_error				*)
(*									*)
(************************************************************************)

procedure report_tape_error(
      unit	: tape_unit_index);

begin
  if tape_io.param.status = COMPLETE
  then user_terminal.write_quoted_text_line(
    'size does not match tape record\')
  else tape_util.display_tape_error(unit, tape_io.param)
end (* report_tape_error *);



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                        report_tape_label_error	                *)
(*                                                                      *)
(************************************************************************)

procedure report_tape_label_error(
      unit	: tape_unit_index;
      label_id	: quoted_text);

begin
  format.start_message('Error on label: \ ');
  format.string(label_id);
  format.write_line(user_terminal);
  report_tape_error(unit)
end (* report_tape_label_error *);



(**************************  archive_commands  **************************)
(*									*)
(*			   report_attach_status				*)
(*									*)
(************************************************************************)

procedure report_attach_status(
      unit	: tape_unit_index;
      param	: tape_param);

begin
  if (param.status = COMPLETE) and (param.count = 20)
  then user_terminal.write_quoted_text_line(WRITE_PROTECTED_MESSAGE)
  else
    if param.status <> COMPLETE
    then
      begin
        if param.status <> INTERVENTION
        then user_terminal.write_quoted_text_line('tape unit attach failed\');
        tape_util.display_tape_error(unit, param)
      end
end (* report_attach_status *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code



(**************************  archive_commands  **************************)
(*									*)
(*			  report_already_assigned			*)
(*									*)
(************************************************************************)

procedure report_already_assigned(
      unit	: tape_unit_index);

var
  info : tape_descriptor;
  tape_user : username_string;

begin
  tape_pool.tape_information(unit, info);
  format.start_message('tape unit assigned to \ ');
  login_pool.validator_name(info.assigned_by, tape_user);
  format.username(tape_user);
  format.write_line(user_terminal)
end (* report_already_assigned *);



(**************************  archive_commands  **************************)
(*									*)
(*			  report_assign_failure				*)
(*									*)
(************************************************************************)

procedure report_assign_failure(
      unit	: tape_unit_index;
      status	: tape_assign_status;
      param	: tape_param);

begin
  if status = ALREADY_ASSIGNED
  then report_already_assigned(unit)
  else report_attach_status(unit, param)
end (* report_assign_failure *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if include_dump



(************************  archive_commands  ****************************)
(*									*)
(*			 report_full_on_block				*)
(*									*)
(*      Report tape full at CUD block number				*)
(*									*)
(************************************************************************)

procedure report_full_on_block(
      unit	: tape_unit_index;
      block_no	: cud_block_index;
  var ok	: boolean);

begin
  format.start_line_message('Tape full\');
  format.on_block(block_no);
  format.write_line(user_terminal);
  tape_io.back_tape(unit, ok)
end (* report_full_on_block *);



(**************************  archive_commands  **************************)
(*									*)
(*			  report_cud_entry_error			*)
(*									*)
(*									*)
(************************************************************************)

procedure report_cud_entry_error(
      status	: cud_entry_result;
      block	: cud_block_index);

begin
  if status <> CUD_ENTRY_OK
  then
    begin
      format.start_and_newline;
      format.cud_entry_status(status);
      format.on_block(block);
      format.write_line(user_terminal)
    end
end (* report_cud_entry_error *);
$endif include_dump
$endif disk_maintenance_code
$if CONVERT_TO_43



(**************************  archive_commands  **************************)
(*									*)
(*			  report_name_entry_error			*)
(*									*)
(*									*)
(************************************************************************)

procedure report_name_entry_error(
      status	: cud_entry_result;
      block	: cud_block_index;
      name	: username_string);

begin
  if status <> CUD_ENTRY_OK
  then
    begin
      format.start_message('CUD error for user \');
      format.username(name);
      format.colon_space;
      format.cud_entry_status(status);
      format.write_line(user_terminal);
      errors := succ(errors)
    end
end (* report_name_entry_error *);



(**************************  archive_commands  **************************)
(*									*)
(*			  report_illegal_name 				*)
(*									*)
(*									*)
(************************************************************************)

procedure report_illegal_name(
      cud_name	: username_string;
      name	: username_string;
      delete	: boolean);

begin
  format.start_message('Entry \ ');
  format.username(cud_name);
  format.string(' has illegal characters, \');
  if delete
  then format.string('name deleted\ ')
  else
    begin
      format.string('changed to \');
      format.username(name)
    end;
  format.write_line(user_terminal)
end (* report_illegal_name *);


(**************************  archive_commands  **************************)
(*                                                                      *)
(*                           report_format_progress                     *)
(*                                                                      *)
(************************************************************************)

procedure report_format_progress;

begin
  format.start;
  format.number(read_entries, 10);
  format.string(' entries read/ \');
  format.number(write_entries, 10);
  format.string(' written\ ');
  format.write_line(user_terminal)
end (* report_format_progress *);
$endif CONVERT_TO_43
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                        report_tape_file_error	                *)
(*                                                                      *)
(************************************************************************)

procedure report_tape_file_error(
      unit	: tape_unit_index;
      offset    : univ integer);

begin
  format.start_line_message('tape\ ');
  format.string(ERROR_OFFSET_MESSAGE);
  format.number(offset, 10);
  format.write_line(user_terminal);
  report_tape_error(unit)
end (* report_tape_file_error *);



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                           report_cud_error				*)
(*                                                                      *)
(************************************************************************)

procedure report_cud_error(
      result    : cud_operation_result;
      block     : cud_block_index);

begin
  format.start;
  format.cud_block_error(block, result);
  format.write_line(user_terminal)
end (* report_cud_error *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                       report_unexpected_offset			*)
(*                                                                      *)
(************************************************************************)

procedure report_unexpected_offset(
      offset_expected    : univ integer;
      offset_read        : integer);

begin
  format.start_line_message('Expected offset \ ');
  format.number(offset_expected, 10);
  format.string(' received offset \');
  format.number(offset_read, 10);
  format.write_line(user_terminal)
end (* report_unexpected_offset *);



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                         report_illegal_offset			*)
(*                                                                      *)
(************************************************************************)

procedure report_illegal_offset(
      offset     : univ integer);

begin
  format.start_message('RESTORE FAILED: aborting - illegal offset: \');
  format.number(offset, 10);
  format.write_line(user_terminal)
end (* report_illegal_offset *);



(**************************  archive_commands  **************************)
(*									*)
(*			      report_blocks				*)
(*									*)
(************************************************************************)

procedure report_blocks(
      blocks_written	: integer (* blocks written *);
      blocks_read	: integer (* blocks read from tape *));

begin
  format.start_message('records read: \ ');
  format.number(blocks_read, 10);
  format.string('    records written: \');
  format.number(blocks_written, 10);
  format.write_line(user_terminal)
end (* report_blocks *);
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                         report_checksum_error			*)
(*                                                                      *)
(************************************************************************)

procedure report_checksum_error(
      offset     : univ integer);

begin
  format.start_message(CHECKSUM_ERROR);
  format.string(' offset: \');
  format.number(offset, 10);
  format.write_line(user_terminal)
end (* report_checksum_error *);



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                           report_disk_error				*)
(*                                                                      *)
(************************************************************************)

procedure report_disk_error(
      offset	: univ integer);

begin
  format.start_line_message('Disk\ ');
  format.string(ERROR_OFFSET_MESSAGE);
  format.number(offset, 10);
  format.write_line(user_terminal)
end (* report_disk_error *);
!
"
		utility routines
"



(**************************  archive_commands  **************************)
(*									*)
(*			     get_command_unit				*)
(*									*)
(*      Return the legal tape unit requested in the command line;	*)
(*	the validator must not have another unit assigned.		*)
(*									*)
(************************************************************************)

procedure get_command_unit(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code
  var already_assigned	: boolean;
  var old_unit		: tape_unit_index;
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  var unit		: tape_unit_index;
  var scanned		: scanned_command);

begin
  freeword_utility.get_numeric_freeword_value(0, 10, 0, TAPE_UNIT_LIMIT,
    scanned, unit);
  if scanned.status = CMD_OK
  then
    if not tape_pool.legal_tape(unit)
    then
      begin (* not a legal tape unit *)
        scanned.status := RUN_ERROR;
	user_terminal.write_quoted_text_line('illegal tape unit\')
      end (* not a legal tape unit *)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code
    else
      begin (* this unit is legal, be sure no other unit is assigned *)
        tape_pool.validator_tape(validator, already_assigned, old_unit);
        if already_assigned and (old_unit <> unit)
        then
          begin
	    scanned.status := RUN_ERROR;
	    format.start_message('tape unit \ ');
	    format.number(old_unit, 10);
	    format.string(' already assigned\');
	    format.write_line(user_terminal)
	  end
      end
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$endif disk_maintenance_code
end (* get_command_unit *);



(**************************  archive_commands  **************************)
(*                                                                      *)
(*				increment_count				*)
(*                                                                      *)
(************************************************************************)

procedure increment_count(
  var count	: integer);

var
  line	: integer;

begin
  if count <= 1
  then line := 1;
  count := count + 1;
  if (count mod 20) = 0
  then
    begin
      format.start;
      format.number(count, 10);
      format.character(ASCII_SPACE);
      format.write_block(user_terminal)
    end;
  if ((line = 1) and ((count mod 300) = 0)) or
    ((line > 1) and (((count - 280) mod 400) = 0))
  then
    begin
      line := line + 1;
      user_terminal.write_newline
    end
end (* increment_count *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code



(**************************  archive_commands  **************************)
(*									*)
(*			         get_unit				*)
(*									*)
(*      If there is a tape unit included in the command line, pick up	*)
(*	the argument and assign it implicitly; otherwise, return the	*)
(*	unit already assigned to the validator.				*)
(*									*)
(************************************************************************)

procedure get_unit(
  var unit		: tape_unit_index;
  var scanned           : scanned_command;
  var unit_assigned     : boolean (* TRUE if assigned here *));

var
  status : tape_assign_status;
  already_assigned : boolean;
  old_unit : tape_unit_index;
  param : tape_param;

begin
  if scanned.freeword_count > 0
  then
    begin (* validator entered UNIT number *)
      get_command_unit(already_assigned, old_unit, unit, scanned);
      if scanned.status = CMD_OK
      then
        begin
          tape_pool.assign_unit(unit, validator, status, param);
          if status = ASSIGN_OK
          then unit_assigned := not already_assigned or
	    (already_assigned and (unit <> old_unit))
          else
            begin
              report_assign_failure(unit, status, param);
              scanned.status := RUN_ERROR
            end
        end
    end
  else
    begin (* no unit entered, get current unit assigned, if any *)
      tape_pool.validator_tape(validator, already_assigned, old_unit);
      if already_assigned
      then unit := old_unit
      else
        begin
          user_terminal.write_quoted_text_line(NOT_ASSIGNED);
	  scanned.status := RUN_ERROR
	end
    end (* get_current unit assinged, if any *)
end (* get_unit *);



(**************************  archive commands  **************************)
(*									*)
(*			      get_cud_locked				*)
(*									*)
(*      Return cud_locked TRUE is able to lock CUD			*)
(*									*)
(************************************************************************)

procedure get_cud_locked(
  var cud_locked	: boolean);

var
  status : cud_access_status;

begin
  cud_locked := FALSE;
  repeat
    cud_access.lock_cud_file(status) (* for read-only access *);
    if status = CUD_ACCESS_OK
    then cud_locked := TRUE
    else
      begin (* status <> CUD_ACCESS_OK *)
        user_terminal.write_quoted_text_line(CUD_FILE_BUSY);
	wait
      end (* status <> CUD_ACCESS_OK *)
  until not user_terminal.sendable or cud_locked
end (* get_cud_locked *);



(**************************  archive_commands  **************************)
(*									*)
(*			      output_storing				*)
(*									*)
(*	Output to user_terminal, file is being stored output filename   *)
(*	passed and file message passed.					*)
(*									*)
(************************************************************************)

procedure output_storing(
      file	: archive_file_index;
      file_msg	: quoted_text);

begin
  format.start_message(STORING_MESSAGE);
  format.file_name(file);
  format.string(file_msg);
  format.colon_space;
  user_terminal.write_format_buffer(format.buffer)  
end (* output_storing *);
$endif disk_maintenance_code



(**************************  archive_commands  **************************)
(*									*)
(*			     rewind_tape				*)
(*									*)
(************************************************************************)

procedure rewind_tape(
      display_message	: boolean;
      unit		: tape_unit_index;
  var ok		: boolean);

var
  disk_tape_info : disk_tape_information;

begin
  if display_message
  then user_terminal.write_quoted_text_line('tape rewinding\ ');
  tape_io.position_drive(unit, TAPE_REWIND);
  repeat (* wait for completion of rewind *)
    tape_io.drive_status(unit, disk_tape_info);
    wait;
    user_terminal.check_circuit
  until not user_terminal.sendable or (tape_io.param.status <> COMPLETE) or
    ((disk_tape_info.device_status div 2) mod 2 = 1) (* BOT *);
  ok := tape_io.param.status = COMPLETE;
  if not ok
  then tape_util.display_tape_error(unit, tape_io.param)
end (* rewind_tape *);

!
"
		general label character manipulation routines
"


(**************************  archive_commands  **************************)
(*                                                                      *)
(*                             init_label_value				*)
(*                                                                      *)
(************************************************************************)

procedure init_label_value;

var
  label_index : ansii_tape_label_index;

begin
  format.start_message(VOL_ID);
  format.string_from_buffer(vol_label)
end (* init_label_value *);



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                           label_chars_match				*)
(*                                                                      *)
(*	Return TRUE if the characters in the label match the		*)
(*	given quoted_text.						*)
(*                                                                      *)
(************************************************************************)

function label_chars_match(
      text_to_check	: quoted_text;
      label		: ansii_tape_label;
      first_label_char	: ansii_tape_label_index;
      chars_to_check	: ansii_tape_label_size) : boolean;

var
  label_index : ansii_tape_label_index;

begin
  label_chars_match := TRUE;
  for label_index := first_label_char to (first_label_char+chars_to_check-1) do
    if label[label_index] <> text_to_check[label_index - first_label_char]
    then label_chars_match := FALSE
end (* label_chars_match *);



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                              check_label				*)
(*                                                                      *)
(*                                                                      *)
(************************************************************************)

procedure check_label(
      print_label_error	: boolean;
      label_id		: quoted_text;
      label		: ansii_tape_label;
  var ok		: boolean);

begin
  ok := label_chars_match(label_id, label, LABEL_ID_OFFSET, LABEL_ID_SIZE);
  if not ok and print_label_error
  then
    begin
      format.start_message('label missing from tape: \');
      format.string(label_id);
      format.write_line(user_terminal)
    end (* not ok and print_label_error *)
end (* check_label *);


(**************************  archive_commands  **************************)
(*                                                                      *)
(*                              read_label				*)
(*                                                                      *)
(*	Read the label from the tape and be sure it is the		*)
(*	kind expected.							*)
(*                                                                      *)
(************************************************************************)

procedure read_label(
      unit		: tape_unit_index;
      print_label_error	: boolean;
      label_id		: quoted_text;
  var label		: ansii_tape_label;
  var ok        	: boolean);

begin
  tape_io.read_label(unit, label, ok);
  if ok
  then check_label(print_label_error, label_id, label, ok)
  else (* not ok *)
    if print_label_error and (tape_io.param.status <> END_MEDIUM)
    then report_tape_label_error(unit, label_id)
end (* read_label *);



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                           read_volume_label                          *)
(*                                                                      *)
(************************************************************************)

procedure read_volume_label(
      unit		: tape_unit_index;
      print_label_error	: boolean;
  var label		: ansii_tape_label;
  var ok        	: boolean);

var
  count : integer;

begin
  tape_io.read_label(unit, label, ok);
  count := ord(vol_label[LABEL_VOLUME_OFFSET]) - ord(ASCII_ZERO);
  if ok
  then
    repeat
      if count < MAX_VOLUMES
      then
        begin
	  check_label(FALSE, vol_label, label, ok);
          if not ok
	  then vol_label[LABEL_VOLUME_OFFSET] :=
	         chr(ord(vol_label[LABEL_VOLUME_OFFSET]) + 1)
        end
      else check_label(print_label_error, vol_label, label, ok);
      count := count + 1
    until ok or (count > MAX_VOLUMES)
  else (* not ok *)
    if print_label_error and (tape_io.param.status <> END_MEDIUM)
    then report_tape_label_error(unit, vol_label);
  if ok
  then
    if not label_chars_match(LABEL_OWNER_ID, label, VOLUME_HEADER_OWNER_OFFSET,
      VOLUME_HEADER_OWNER_SIZE)
    then
      begin
        ok := FALSE;
	if print_label_error
	then user_terminal.write_quoted_text_line('mta is not a NETVAL tape\ ')
      end
end (* read_volume_label *);



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                          display_label_date				*)
(*                                                                      *)
(************************************************************************)

procedure display_label_date(
      label	: ansii_tape_label);

begin
  format.ansii_tape_label_chars(label, VOLUME_HEADER_DATE_MONTH_OFFSET, 2);
  format.character(ASCII_SLASH);
  format.ansii_tape_label_chars(label, VOLUME_HEADER_DATE_DAY_OFFSET, 2);
  format.character(ASCII_SLASH);
  format.ansii_tape_label_chars(label, VOLUME_HEADER_DATE_YEAR_OFFSET, 2);
  format.write_line(user_terminal)
end (* display_label_date *);



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                         display_volume_label                         *)
(*                                                                      *)
(************************************************************************)

procedure display_volume_label(
      unit	: tape_unit_index;
  var label	: ansii_tape_label;
  var ok        : boolean);

begin
  init_label_value;
  read_volume_label(unit, TRUE, label, ok);
  if ok
  then
    begin
      format.start_message('NETVAL tape \ ');
      format.ansii_tape_label_chars(label, LABEL_ID_OFFSET, LABEL_ID_SIZE);
      format.string(' (Version \ ');
      format.ansii_tape_label_chars(label, VOLUME_HEADER_VERSION_OFFSET,
        VOLUME_HEADER_VERSION_SIZE);
      format.string(') created on: \ ');
      display_label_date(label)
    end
end (* display_volume_label *);



(**************************  archive_commands  **************************)
(*									*)
(*			    request_next_volume				*)
(*									*)
(************************************************************************)

procedure request_next_volume(
      unit		: tape_unit_index;
  var done		: boolean;
  var ok		: boolean);

begin
  rewind_tape(TRUE, unit, ok);
$if disk_maintenance_code
  ok := keyword_scan.input_answer('Do you want to continue with another VOLUME\');
$endif disk_maintenance_code
$ifnot disk_maintenance_code
  ok := keyword_scan.input_answer('Do you want to add another VOLUME\');
$endif disk_maintenance_code
  done := not ok;
  if ok
  then
    begin
      vol_label[LABEL_VOLUME_OFFSET] :=
	chr(ord(vol_label[LABEL_VOLUME_OFFSET]) + 1);
	  user_terminal.write_line_and_quoted_text_line(
	'Mount next tape to continue.\ ');
      ok := keyword_scan.input_answer(CONTINUE_MESSAGE);
      done := not ok
    end
end (* request_next_volume *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                             label_value				*)
(*                                                                      *)
(************************************************************************)

function label_value(
      label		: ansii_tape_label;
      label_offset	: ansii_tape_label_index;
      label_size	: ansii_tape_label_size) : integer;

var
  value : integer;
  label_index : ansii_tape_label_index;

begin
  value := 0;
  for label_index := label_offset to (label_offset + label_size - 1) do
    value := (value * 10) + ord(label[label_index]) - ord(ASCII_ZERO);
  label_value := value
end (* label_value *);
$if check_time_status



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                          store_label_date				*)
(*                                                                      *)
(************************************************************************)

procedure store_label_date(
      label		: ansii_tape_label);

var
  buffer_ptr : ansii_tape_label_index;

begin
  for buffer_ptr := 0 to (VOLUME_HEADER_DATE_SIZE - 1) do
    label_date[buffer_ptr] := label[buffer_ptr + VOLUME_HEADER_DATE_DAY_OFFSET]
end (* store_label_date *);
$endif check_time_status
$endif disk_maintenance_code
$ifnone disk_maintenance_code



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                          copy_label_chars				*)
(*                                                                      *)
(************************************************************************)

procedure copy_label_chars(
      first_buffer_char	: format_buffer_text_index;
      first_label_char	: ansii_tape_label_index;
      copy_count	: ansii_tape_label_size;
  var label		: ansii_tape_label);

var
  buffer_ptr : format_buffer_text_index;

begin
  for buffer_ptr := first_buffer_char to (first_buffer_char+copy_count-1) do
    label[first_label_char + buffer_ptr - first_buffer_char] :=
      format.buffer.text[buffer_ptr]
end (* copy_label_chars *);



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                          store_label_string				*)
(*                                                                      *)
(************************************************************************)

procedure store_label_string(
      label_id	: quoted_text;
      offset	: ansii_tape_label_index;
      size	: ansii_tape_label_size;
  var label	: ansii_tape_label);

begin
  format.start_message(label_id);
  copy_label_chars(0, offset, size, label)
end (* store_label_string *);



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                             init_label				*)
(*                                                                      *)
(************************************************************************)

procedure init_label(
      label_id	: quoted_text;
  var label	: ansii_tape_label);

var
  label_index : ansii_tape_label_index;

begin
  for label_index := 0 to ANSII_TAPE_LABEL_LIMIT do
    label[label_index] := ASCII_SPACE;

  store_label_string(label_id, LABEL_ID_OFFSET, LABEL_ID_SIZE, label)
end (* init_label *);



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                             write_label				*)
(*                                                                      *)
(************************************************************************)

procedure write_label(
      unit	: tape_unit_index;
      label_id	: quoted_text;
  var label	: ansii_tape_label;
  var ok	: boolean);

begin
  tape_io.write_label(unit, label, ok);
  if not ok and (tape_io.param.status <> END_MEDIUM)
  then report_tape_label_error(unit, label_id)
end (* write_label *);



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                          store_label_number				*)
(*                                                                      *)
(************************************************************************)

procedure store_label_number(
      number_to_store	: univ integer;
      label_offset	: ansii_tape_label_index;
      places_to_store	: ansii_tape_label_size;
  var label		: ansii_tape_label);

begin
  format.start;
  format.format_number(number_to_store, 10, -places_to_store);
  copy_label_chars(0, label_offset, places_to_store, label)
end (* store_label_number *);



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                          write_volume_label				*)
(*                                                                      *)
(************************************************************************)

procedure write_volume_label(
      label_id	: quoted_text;
      unit	: tape_unit_index;
  var ok	: boolean);

var
  label : ansii_tape_label;

begin
  init_label(label_id, label);

  format.start;
  format.date(REALTIME) (* make MM/DD/YY string *);
  copy_label_chars(0, VOLUME_HEADER_DATE_MONTH_OFFSET, 2, label);
  copy_label_chars(3, VOLUME_HEADER_DATE_DAY_OFFSET, 2, label);
  copy_label_chars(6, VOLUME_HEADER_DATE_YEAR_OFFSET, 2, label);

  store_label_string(LABEL_OWNER_ID, VOLUME_HEADER_OWNER_OFFSET, VOLUME_HEADER_OWNER_SIZE,
    label);

  format.start;
  if version < 10
  then format.number(0,10);
  format.scaled_number(version*100 + revision, 10, 2) (* make VV.RR string *);
  copy_label_chars(0, VOLUME_HEADER_VERSION_OFFSET, VOLUME_HEADER_VERSION_SIZE, label);

  label[VOLUME_HEADER_STANDARD_LEVEL_OFFSET] := VOLUME_HEADER_STANDARD_LEVEL;

  write_label(unit, label_id, label, ok)
end (* write_volume_label *);



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                           make_hdr1_label				*)
(*                                                                      *)
(*	Set up most of the HDR1 label - also used for the EOF1 label.	*)
(*                                                                      *)
(************************************************************************)

procedure make_hdr1_label(
      file_sequence	: integer;
  var label		: ansii_tape_label);

begin
  copy_label_chars(0, LABEL_FILE_NAME_OFFSET, format.buffer.size, label);

  store_label_string(LABEL_OWNER_ID, LABEL_SET_ID_OFFSET, LABEL_SET_ID_SIZE,
    label);

  store_label_number(LABEL_FILE_SECTION, LABEL_FILE_SECTION_OFFSET,
    LABEL_FILE_SECTION_SIZE, label);

  store_label_number(file_sequence, LABEL_FILE_SEQUENCE_OFFSET,
    LABEL_FILE_SEQUENCE_SIZE, label);

  store_label_number(1, LABEL_GENERATION_NUMBER_OFFSET,
    LABEL_GENERATION_NUMBER_SIZE, label);

  store_label_number(0, LABEL_GENERATION_VERSION_NUMBER_OFFSET,
    LABEL_GENERATION_VERSION_NUMBER_SIZE, label);

  format.start;
  format.ansii_tape_label_date(REALTIME);
  copy_label_chars(0, LABEL_CREATION_DATE_OFFSET, LABEL_DATE_SIZE, label);

  copy_label_chars(0, LABEL_EXPIRATION_DATE_OFFSET, LABEL_DATE_SIZE, label)
end (* make_hdr1_label *);



(**************************  archive_commands  **************************)
(*									*)
(*			    write_eof_label				*)
(*									*)
(*  	Write out EOF label to tape				        *)
(*									*)
(************************************************************************)

procedure write_eof_label(
      unit		: tape_unit_index;
      file_sequence	: integer;
      block_count	: integer;
  var ok		: boolean);

var
  label		: ansii_tape_label;

begin
  tape_io.position_drive(unit, TAPE_WRITE_EOF);
  init_label(EOF1_ID, label);
  make_hdr1_label(file_sequence, label) (* mostly same as HDR1 *);

  store_label_number(block_count, LABEL_BLOCK_COUNT_OFFSET,
    LABEL_BLOCK_COUNT_SIZE, label);

  write_label(unit, EOF1_ID, label, ok);
  if ok
  then
    begin
      tape_io.position_drive(unit, TAPE_WRITE_EOF);
      format.start;
      format.number(block_count, 10);
      format.string(' records written\ ');
      format.write_line(user_terminal)
    end
end (* write_eof_label *);



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                           get_next_volume				*)
(*                                                                      *)
(************************************************************************)

procedure get_next_volume(
      unit		: tape_unit_index;
      file_sequence	: integer;
      block_count	: integer;
  var done		: boolean;
  var ok		: boolean);

begin
  ok := TRUE; done := TRUE;
  user_terminal.write_quoted_text_line('END OF TAPE.\ ');
  if block_count > 1
  then
    begin
       tape_io.position_drive(unit, TAPE_BACK_SPACE);
       write_eof_label(unit, file_sequence, block_count, ok);
    end
  else tape_io.position_drive(unit, TAPE_BACK_FILE);
  tape_io.position_drive(unit, TAPE_WRITE_EOF) (* 2nd eof at end *);
  (* complete file *)
  if not ok
  then ok := (tape_io.param.status = END_MEDIUM) or
    (tape_io.param.status = COMPLETE);
  if ok
  then request_next_volume(unit, done, ok)
  else report_tape_error(unit);
  if ok
  then write_volume_label(vol_label, unit, ok) ;
end (* get_next_volume *);



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                           write_hdr1_label				*)
(*                                                                      *)
(************************************************************************)

procedure write_hdr1_label(
      unit		: tape_unit_index;
      file		: archive_file_index;
      file_sequence	: integer;
  var ok		: boolean);

var
  label : ansii_tape_label;
  done : boolean;

begin
  init_label(HDR1_ID, label);
  format.start;
  format.file_name(file) (* put file name in format buffer *);
  make_hdr1_label(file_sequence, label);
  store_label_number(0, LABEL_BLOCK_COUNT_OFFSET, LABEL_BLOCK_COUNT_SIZE,
    label);
  write_label(unit, HDR1_ID, label, ok);
  if (not ok) and (tape_io.param.status = END_MEDIUM)
  then get_next_volume(unit, file_sequence, 0, done, ok)
  else done := ok;
  if ok and not done
  then write_label(unit, HDR1_ID, label, ok)
end (* write_hdr1_label *);



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                          write_hdr2_label				*)
(*                                                                      *)
(************************************************************************)

procedure write_hdr2_label(
      unit		: tape_unit_index;
      block_length	: integer;
      record_length	: integer;
      file_sequence	: integer;
  var ok		: boolean);

var
  label : ansii_tape_label;

begin
  init_label(HDR2_ID, label);

  label[HDR2_FORMAT_OFFSET] := HDR2_FORMAT;

  store_label_number(block_length, HDR2_BLOCK_LENGTH_OFFSET,
    HDR2_BLOCK_LENGTH_SIZE, label);

  store_label_number(record_length, HDR2_RECORD_LENGTH_OFFSET,
    HDR2_RECORD_LENGTH_SIZE, label);

  store_label_number(0, HDR2_BUFFER_OFFSET, HDR2_BUFFER_OFFSET_SIZE, label);

  write_label(unit, HDR2_ID, label, ok)
end (* write_hdr2_label *);



(**************************  archive_commands  **************************)
(*                                                                      *)
(*				store_page				*)
(*                                                                      *)
(*	This routine is only used for single page files (config, list	*)
(*	header, if reuse_uuns is DISABLED, cud_parameter).		*)
(*                                                                      *)
(************************************************************************)

procedure store_page(
      unit		: tape_unit_index;
  var buffer		: univ page;
  var block_count	: integer;
  var ok		: boolean);

begin
  tape_io.write_tape_page(unit, buffer, ok);
  if ok
  then block_count := block_count + 1
  else report_tape_error(unit)
end (* store_page *);



(**************************  archive_commands  **************************)
(*									*)
(*			  initialize_file_store				*)
(*									*)
(*	Clear block_count, increment file_sequence, output "storing	*)
(*	file message", write HDR1, HDR2 and and end-of-file mark.	*)
(*									*)
(************************************************************************)

procedure initialize_file_store(
      unit		: tape_unit_index;
      file		: archive_file_index;
      file_msg		: quoted_text;
      block_length	: integer;
      record_length	: integer;
  var block_count	: integer (* number of records in file *);
  var file_sequence	: integer (* sequence of file on tape *);
  var ok		: boolean);

var
  done : boolean;

begin
  block_count := 0;
  file_sequence := file_sequence + 1 (* increment for file *);
  output_storing(file, file_msg);
  write_hdr1_label(unit, file, file_sequence, ok);
  if ok
  then write_hdr2_label(unit, block_length, record_length, file_sequence, ok);
  if not ok and (tape_io.param.status = END_MEDIUM)
  then
    begin
      tape_io.position_drive(unit, TAPE_BACK_SPACE);
      get_next_volume(unit, file_sequence, block_count, done, ok)
    end
  else done := ok;
  if ok and not done
  then
    begin
      output_storing(file, file_msg);
      write_hdr1_label(unit, file, file_sequence, ok);
      if ok
      then
        write_hdr2_label(unit, block_length, record_length, file_sequence, ok)
    end;
  if ok
  then tape_io.position_drive(unit, TAPE_WRITE_EOF)
end (* initialize_file_store *);



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                          complete_file_store				*)
(*                                                                      *)
(************************************************************************)

procedure complete_file_store(
      unit		: tape_unit_index;
      file		: archive_file_index;
      block_length	: integer;
      record_length	: integer;
  var file_sequence	: integer;
  var block_count	: integer;
  var done		: boolean;
  var ok		: boolean);

begin
  write_eof_label(unit, file_sequence, block_count, ok);
  if not ok and (tape_io.param.status = END_MEDIUM)
  then
    begin
      if block_count = 1 (* if file is only one record, remove header *)
      then tape_io.position_drive(unit, TAPE_BACK_SPACE);
      get_next_volume(unit, file_sequence, block_count, done, ok);
      if ok
      then initialize_file_store(unit, file, NULL_STRING, block_length,
             record_length, block_count, file_sequence, ok)
    end
  else done := ok
end (* complete_file_store *);



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                         store_configuration				*)
(*                                                                      *)
(************************************************************************)

procedure store_configuration(
      unit		: tape_unit_index;
  var file_sequence	: integer;
  var ok		: boolean);

var
  buffer : configuration_information;
  status : file_utility_status;
  block_count : integer;
  done : boolean;

begin
  initialize_file_store(unit, CONFIGURATION_FILE, NULL_STRING,
    PAGE_SIZE, PAGE_SIZE, block_count, file_sequence, ok);
  if ok
  then
    begin
      config_utility.read_file(buffer, status);
      if status = FU_SUCCESS
      then
        begin
          store_page(unit, buffer, block_count, ok);
          if ok
          then complete_file_store(unit, CONFIGURATION_FILE, PAGE_SIZE,
            PAGE_SIZE, file_sequence, block_count, done, ok)
	  else done := TRUE;
          if ok and not done
          then
            begin
              store_page(unit, buffer, block_count, ok);
              if ok
              then write_eof_label(unit, file_sequence, block_count, ok)
            end
	end
      else
        begin
	  ok := FALSE;
	  if status = FU_CHECKSUM_ERROR
	  then report_checksum_error(0)
	  else report_disk_error(0);
          config_utility.report_error_to_oplog(format, oper_messages)
        end
    end
end (* store_configuration *);



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                        store_next_volume		                *)
(*                                                                      *)
(************************************************************************)

procedure store_next_volume(
      unit		: tape_unit_index;
      count		: integer;
  var file_sequence	: integer;
  var ok		: boolean);

var
  done : boolean;

begin
  if (tape_io.param.status = END_MEDIUM) and user_terminal.sendable
  then
    begin
      if count = 1
      then format.start_message('no room for file\ ')
      else
        begin
          format.start_line_message('current record \');
	  format.number(count, 10)
        end;
      format.write_line(user_terminal);
      get_next_volume(unit, file_sequence, count, done, ok);
      if ok and not done
      then store_configuration(unit, file_sequence, ok)
    end
  else report_tape_error(unit)
end (* store_next_volume *);
$endif disk_maintenance_code
$if check_time_status



(**************************  archive_commands  **************************)
(*									*)
(*			    tape_is_todays_date				*)
(*									*)
(************************************************************************)

function tape_is_todays_date : boolean;

var
  label_print_date : print_time;
  this_date : print_time;

begin
  label_print_date.month :=
    ((ord(label_date[0]) - ord(ASCII_ZERO)) * 10) +
     ord(label_date[1]) - ord(ASCII_ZERO);
  label_print_date.day :=
    ((ord(label_date[2]) - ord(ASCII_ZERO)) * 10) +
     ord(label_date[3]) - ord(ASCII_ZERO);
  label_print_date.year :=
    ((ord(label_date[4]) - ord(ASCII_ZERO)) * 10) +
     ord(label_date[5]) - ord(ASCII_ZERO) + 1900;
  calendar.date_from_isis_time(REALTIME, this_date);
  tape_is_todays_date := (label_print_date.year = this_date.year) and
    (label_print_date.month = this_date.month) and
    ((this_date.day - label_print_date.day) <= 1)
end (* tape_is_todays_date *);
$endif check_time_status
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if disk_maintenance_code



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                            read_tape_page				*)
(*                                                                      *)
(*	Used by configuration, node/host header and, if reuse_uuns	*)
(*	disabled, the cud_parameter file.				*)
(*									*)
(************************************************************************)

procedure read_tape_page(
      unit		: tape_unit_index;
      page_number	: integer;
  var tape_buffer       : univ page_record;
  var blocks_read	: integer;
  var ok                : boolean);

var
  computed_checksum : integer;

begin
  tape_io.read_tape_page(unit, tape_buffer, ok);
  if ok
  then
    begin
      blocks_read := blocks_read + 1;
      sys_io.page_checksum(PAGE_SIZE - MAXIMUM_BYTES_IN_WORD, tape_buffer,
        computed_checksum);
      if computed_checksum <> tape_buffer.checksum
      then
        begin
          ok := FALSE;
          report_checksum_error(page_number)
        end (* computed_checksum <> tape_buffer.checksum *)
    end (* ok *)
  else report_tape_error(unit)
end (* read_tape_page *);



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                            check_tape_config				*)
(*                                                                      *)
(************************************************************************)

function check_tape_config(
      unit : tape_unit_index) : boolean;

var
  temp : integer;
  ok : boolean;
  page_buffer : page_record;

begin
  check_tape_config := FALSE;
  read_tape_page(unit, CONFIGURATION_FILE_START, page_buffer, temp, ok);
  tape_io.position_drive(unit, TAPE_FORWARD_FILE) (* skip the EOF *);
  tape_io.position_drive(unit, TAPE_FORWARD_FILE) (* skip EOF1 label *);
  if ok
$if CONVERT_TO_43      and (label_version = version) (* shouldnt match *)
  then config_utility.check_configuration(page_buffer,
$if CONVERT_TO_43     sup_43,
    ok);
$ifnot CONVERT_TO_43   if ok
$if CONVERT_TO_43
  if (ok and not (label_version = version)) or
    (sup_43 and (label_version = version))
$endif CONVERT_TO_43
  then
    begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if check_time_status
      if not tape_is_todays_date
      then user_terminal.write_line_and_quoted_text_line(WARNING_MESSAGE);
$endif check_time_status
$if CONVERT_TO_43
      if label_version = version
      then user_terminal.write_line_and_quoted_text_line(
	'CAUTION:  Tape written by current version of NETVAL\');
$endif CONVERT_TO_43
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      check_tape_config := keyword_scan.input_answer(OKAY_QUERY)
    end
  else user_terminal.write_quoted_text_line(
$ifnone CONVERT_TO_43
    'tape configuration does not match disk, restore cancelled\')
$endif CONVERT_TO_43
$if CONVERT_TO_43
    'tape configuration matches disk, reformat cancelled\')
$endif CONVERT_TO_43
end (* check_tape_config *);



(**************************  archive_commands  **************************)
(*									*)
(*				check_file				*)
(*                                                                      *)
(************************************************************************)

procedure check_file(
      unit	: tape_unit_index;
  var label	: ansii_tape_label;
  var ok	: boolean;
  var found	: boolean);

var
  index : format_buffer_text_index;

begin
  found := TRUE;
  for index := 0 to format.buffer.size - 1 do
    if label[index + LABEL_FILE_NAME_OFFSET] <> format.buffer.text[index]
    then found := FALSE (* file name does not match *);
  read_label(unit, TRUE, HDR2_ID, label, ok) (* skip over HDR2 label *);
  tape_io.position_drive(unit, TAPE_FORWARD_FILE) (* and EOF *);
  if not found
  then
    begin (* name does not match, not file we're looking for *)
      user_terminal.check_circuit;
      if user_terminal.sendable
      then
	begin
	  tape_io.position_drive(unit,TAPE_FORWARD_FILE) (* skip file *);
          tape_io.position_drive(unit,TAPE_FORWARD_FILE) (* skip EOF *)
	end
    end (* name does not match *)
end (* check_file *);



(**************************  archive_commands  **************************)
(*									*)
(*				locate_file				*)
(*                                                                      *)
(*	Scan the file from the place it is positioned now (should be	*)
(*	just before a HDR1 label) all the way to the end of tape if	*)
(*	necessary; if file is found, return TRUE, and skip over the	*)
(*	HDR2 label and the end-of-file mark.				*)
(*                                                                      *)
(*	If file is not found, the tape should be rewound and the VOL	*)
(*	label skipped.							*)
(*                                                                      *)
(************************************************************************)

procedure locate_file(
      unit	: tape_unit_index;
      file	: archive_file_index;
      next_vol	: boolean;
  var ok	: boolean;
  var found	: boolean);

var
  done : boolean;
  label	: ansii_tape_label;

begin
  found := FALSE;
  done := FALSE;
  format.start;
  format.file_name(file);
  repeat
    read_label(unit, TRUE, HDR1_ID, label, ok);
    if ok
    then check_file(unit, label, ok, found)
    else
      if (tape_io.param.status = END_FILE) or (tape_io.param.status = END_MEDIUM)
      then
        begin (* found eof, error return *)
	  format.start;
	  format.file_name(file);
	  format.string(' not found\ ');
	  format.write_line(user_terminal);
          format.start_message('END of TAPE and file not found.\');
          format.write_line(user_terminal);
	  if next_vol
          then
	    begin
	      request_next_volume(unit, done, ok);
  	      format.start;
  	      format.file_name(CONFIGURATION_FILE);
	      if ok and not done
    	      then read_label(unit, TRUE, HDR1_ID, label, ok);
    	      if ok and not done
	      then check_file(unit, label, ok, found);
$if check_time_status
  	      if ok and found
  	      then store_label_date(label);
$endif check_time_status
  	      if ok and found
              then found := not check_tape_config(unit)
	      else done := TRUE
	    end
	  else done := TRUE
	end
      else tape_util.display_tape_error(unit, tape_io.param)
  until found or done or not user_terminal.sendable
end (* locate_file *);



(**************************  archive_commands  **************************)
(*									*)
(*			check_tape_and_configuration			*)
(*									*)
(*	Rewind tape, read volume label, be sure it is a NETVAL tape,	*)
(*	check to be sure the configuration is the current one, then	*)
(*	ask the user to confirm the tape date.				*)
(*									*)
(************************************************************************)

function check_tape_and_configuration(
      unit	: tape_unit_index) : boolean;

var
  ok : boolean;
  found : boolean;
  page_buffer : page_record;
  label : ansii_tape_label;
$if CONVERT_TO_43  sup_43 : boolean;

begin
  check_tape_and_configuration := FALSE;
  rewind_tape(TRUE, unit, ok);
  if ok
  then display_volume_label(unit, label, ok);
$if CONVERT_TO_43
(* version 02, 03, 04 or 05? *)
  if ok
  then label_version := label_value(label, VOLUME_HEADER_VERSION_OFFSET, 2);
$endif CONVERT_TO_43
$if check_time_status
  if ok
  then store_label_date(label);
$endif check_time_status
  if ok
  then locate_file(unit, CONFIGURATION_FILE, FALSE, ok, found);
  if ok and found
  then check_tape_and_configuration := check_tape_config(unit)
end (* check_tape_and_configuration *);



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                        restore_next_volume		                *)
(*                                                                      *)
(************************************************************************)

procedure restore_next_volume(
      unit	: tape_unit_index;
  var done	: boolean;
  var ok	: boolean);

var
  label	: ansii_tape_label;

begin
  request_next_volume(unit, done, ok);
  if ok and not done
  then
    begin
      read_volume_label(unit, TRUE, label, ok);
      if ok
      then done := not check_tape_and_configuration(unit)
    end
end (* restore_next_volume *);
$endif disk_maintenance_code



(**************************  archive_commands  **************************)
(*									*)
(*				clear_page				*)
(*									*)
(************************************************************************)

procedure clear_page(
  var page_data	: page_record);

begin
  mutil.clear_page(page_data);
  sys_io.page_checksum(PAGE_SIZE, page_data, page_data.checksum)
end (* clear_page *);
$if disk_maintenance_code
!
"
		RESTORE Command
"



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                        restore_file_volume		                *)
(*                                                                      *)
(************************************************************************)

procedure restore_file_volume(
      unit	: tape_unit_index;
      file	: archive_file_index;
  var done	: boolean;
  var ok	: boolean);

var
  found : boolean;

begin
  restore_next_volume(unit, done, ok);
  if ok and not done
  then locate_file(unit, file, FALSE, ok, found)
  else found := ok;
  if ok and not found
  then
    begin
      ok := FALSE;
      format.start;
      format.file_name(file);
      format.string(' file not found on volume\');
      format.write_block(user_terminal)
    end
end (* restore_file_volume *);



(**************************  archive_commands  **************************)
(*									*)
(*			  initialize_file_restore			*)
(*                                                                      *)
(*	Find the file on tape and initialize the restore by setting	*)
(*	blocks_written and blocks_read to zero and report to user.	*)
(*                                                                      *)
(************************************************************************)

procedure initialize_file_restore(
      unit		: tape_unit_index;
      file		: archive_file_index;
      file_msg		: quoted_text;
  var blocks_written	: integer (* blocks written to disk *);
  var blocks_read	: integer (* blocks read from tape *);
  var ok		: boolean);

var
  found : boolean;

begin
  locate_file(unit, file, TRUE, ok, found);
  if ok
  then
    if found
    then
      begin
        blocks_read := 0; blocks_written := 0;
$if CONVERT_TO_43
	if file = CUD_FILE
	then format.start_line_message('reformatting \')
	else
$endif CONVERT_TO_43
	format.start_message('restoring \ ');
	format.file_name(file);
	format.string(file_msg);
	format.colon_space;
$if CONVERT_TO_43
	if file = CUD_FILE
	then format.newline;
$endif CONVERT_TO_43
	format.write_block(user_terminal)
      end
    else ok := FALSE
end (* initialize_file_restore *);



(**************************  archive_commands  **************************)
(*									*)
(*			   complete_file_restore			*)
(*									*)
(************************************************************************)

procedure complete_file_restore(
      unit		: tape_unit_index;
      blocks_written	: integer (* blocks written *);
      blocks_read	: integer (* blocks read from tape *);
      data_eof_not_read	: boolean (* eof at end of data not read *);
  var ok		: boolean);

var
  label	: ansii_tape_label;
  blocks_recorded : integer (* block count read from EOF1 label *);

begin
  report_blocks(blocks_written, blocks_read);
  if ok and user_terminal.sendable
  then
    begin
      if data_eof_not_read
      then tape_io.position_drive(unit, TAPE_FORWARD_FILE);
      read_label(unit, TRUE, EOF1_ID, label, ok) (* read EOF1 label *);
      tape_io.position_drive(unit, TAPE_FORWARD_FILE) (* skip eof mark *);
      if ok
      then
        begin (* read EOF1 successfully *)
	  blocks_recorded := label_value(label, LABEL_BLOCK_COUNT_OFFSET,
	    LABEL_BLOCK_COUNT_SIZE);
	  if blocks_read <> blocks_recorded
	  then
	    begin
	      format.start_message('WARNING! records reported on tape: \');
	      format.number(blocks_recorded, 10);
	      format.write_line(user_terminal)
	    end;
	end (* read EOF1 successfully *)
    end (* ok and user_terminal.sendable *)
end (* complete_file_restore *);



(**************************  archive_commands  **************************)
(*									*)
(*			   read_blocked_tape_page			*)
(*									*)
(*	Called by restore_operlog and restore_parameter.		*)
(*									*)
(************************************************************************)

procedure read_blocked_tape_page(
      unit		: tape_unit_index;
      expected_offset	: univ integer;
      last		: univ integer;
      file		: archive_file_index;
  var done		: boolean;
  var tape_buffer       : tape_page_block;
  var blocks_read	: integer;
  var checksum_flags	: blocked_page_checksums);

var
  tape_index : tape_page_block_index;
  computed_checksum : integer;
  ok : boolean;

begin
  tape_io.read_blocked_tape_page(unit, tape_buffer, ok);
  if (not ok) and ((tape_io.param.status = END_MEDIUM) or
    (tape_io.param.status = END_FILE))
  then restore_file_volume(unit, file, done, ok);
  if not ok and not done
  then report_tape_error(unit);
  if ok and not done
  then
    begin (* ok *)
      increment_count(blocks_read);
      for tape_index := 0 to TAPE_PAGE_BLOCK_LIMIT do
	begin
          sys_io.page_checksum(PAGE_SIZE - MAXIMUM_BYTES_IN_WORD,
	    tape_buffer[tape_index].page_data, computed_checksum);
	  if computed_checksum = tape_buffer[tape_index].page_data.checksum
	  then checksum_flags[tape_index] := TRUE
	  else report_checksum_error(tape_index + expected_offset)
	end (* for *)
    end (* ok *)
end (* read_blocked_tape_page *);



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                          clearing_message				*)
(*                                                                      *)
(************************************************************************)

procedure clearing_message(
      first_to_clear	: univ integer;
      last_to_clear	: univ integer);

begin
  format.start_message('Clearing offset \ ');
  if first_to_clear < last_to_clear
  then format.number_range(first_to_clear, last_to_clear, 10)
  else format.number(first_to_clear, 10);
  format.write_line(user_terminal)
end (*  clearing_message *);
(* +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if reuse_uuns
!
"
		restore parameter file
"


(**************************  archive_commands  **************************)
(*                                                                      *)
(*			     write_param_page				*)
(*                                                                      *)
(************************************************************************)

procedure write_param_page(
      page_no		: cud_parameter_page_index;
  var data		: univ page_record;
  var blocks_written	: integer;
  var ok		: boolean);

begin
  if user_terminal.sendable
  then
    begin
      if page_no = CUD_PARAMETER_HEADER_PAGE
      then param_file.write_header(data, ok)
      else
        if page_no > BIT18_PAGE_MAX
	then param_file.write_add_back_page(page_no, data, ok)
	else param_file.write_uun_page(page_no, data, ok);
      if ok
      then
        begin
	  blocks_written := blocks_written + 1;
	  user_terminal.check_circuit
	end
      else report_disk_error(page_no)
    end
end (* write_param_page *);



(**************************  archive_commands  **************************)
(*									*)
(*			 clear_missing_param_pages			*)
(*									*)
(************************************************************************)

procedure clear_missing_param_pages(
      first_to_clear	: cud_parameter_page_index;
      last_to_clear	: cud_parameter_page_index;
  var uun_default	: univ page;
  var add_back_default	: univ page;
  var blocks_written	: integer);

var
  clear_index : cud_parameter_page_index;
  ok : boolean;
  done : boolean;

begin
  clearing_message(first_to_clear, last_to_clear);
  clear_index := first_to_clear; done := FALSE;
  while not done and user_terminal.sendable do
    begin
      if clear_index > BIT18_PAGE_MAX
      then write_param_page(clear_index, add_back_default, blocks_written, ok)
      else write_param_page(clear_index, uun_default, blocks_written, ok);
      if clear_index = last_to_clear
      then done := TRUE
      else clear_index := clear_index + 1;
      user_terminal.check_circuit
    end
end (* clear_missing_param_pages *);



(**************************  archive_commands  **************************)
(*									*)
(*			   get_bit_map_checksum				*)
(*									*)
(************************************************************************)

procedure get_bit_map_checksum(
  var page_data	: univ page_record);

begin
  sys_io.page_checksum(PAGE_SIZE - MAXIMUM_BYTES_IN_WORD, page_data,
    page_data.checksum)
end (* get_bit_map_checksum *);
$endif reuse_uuns
(* +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                          restore_parameter				*)
(*                                                                      *)
(************************************************************************)

procedure restore_parameter(
      unit	: tape_unit_index;
  var ok	: boolean);

var
  blocks_read : integer;
  blocks_written : integer;
(* +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone reuse_uuns   tape_buffer : page_record;
$if reuse_uuns
  tape_buffer : tape_page_block;
  tape_index : tape_page_block_index;

  expected_offset : cud_parameter_page_index;
  bit_offset : basic_set_index;
  map_offset : map_index;
  checksum_flags : blocked_page_checksums;

  add_back_default : add_back_page;
  uun_default : bit_map_page;

  tape_blk_done : boolean;
  done : boolean;
$endif reuse_uun
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

begin
  initialize_file_restore(unit, CUD_PARAMETER_FILE, NULL_STRING,
    blocks_written, blocks_read, ok);
  if ok
  then
    begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone reuse_uuns
      read_tape_page(unit, 0, tape_buffer, blocks_read, ok);
      if ok
      then
        begin
          param_file.write_header(tape_buffer, ok);
          if ok
          then blocks_written := blocks_written + 1
          else report_disk_error(0)
        end (* ok *)
    end;
$endif reuse_uuns
$if reuse_uuns
(* in case there are pages missing from tape, set up default pages to write *)
    for map_offset := 0 to MAP_LIMIT do (* make uuns all used *)
      for bit_offset := 0 to BASIC_SET_LIMIT do
        uun_default[map_offset] := uun_default[map_offset] or [bit_offset];
    get_bit_map_checksum(uun_default);
    mutil.clear_page(add_back_default);

    expected_offset := 0; done := FALSE;
    while not done and user_terminal.sendable do
      begin
        for tape_index := 0 to TAPE_PAGE_BLOCK_LIMIT do
	  checksum_flags[tape_index] := FALSE (* clear out checksum flags *);
        read_blocked_tape_page(unit, expected_offset, ADD_BACK_PAGE_MAX,
          CUD_PARAMETER_FILE, done, tape_buffer, blocks_read, checksum_flags);
	if tape_io.param.status = END_FILE
        then
          begin
	    done := TRUE;
	    ok := TRUE
	  end (* found end of file *);

	tape_index := 0; tape_blk_done := FALSE;
        while not done and user_terminal.sendable and not tape_blk_done do
	  begin
	    if not checksum_flags[tape_index]
	    then
	      begin
		clear_missing_param_pages(expected_offset, expected_offset,
		  uun_default, add_back_default, blocks_written);
                tape_buffer[tape_index].page_offset := expected_offset
	      end (* checksum was not ok *)
	    else (* checksum is ok *)
              if (tape_buffer[tape_index].page_offset < 0) or
		 (tape_buffer[tape_index].page_offset > ADD_BACK_PAGE_MAX) or
		 (tape_buffer[tape_index].page_offset < expected_offset)
               then
		 begin
    	           done := TRUE; ok := FALSE;
		   report_illegal_offset(tape_buffer[tape_index].page_offset)
	         end
	       else
	         begin (* checksum is ok, and offset is not illegal *)
		   if (tape_buffer[tape_index].page_offset > expected_offset) and
			(blocks_written > 0)
		   then
		     begin (* missing pages, write out default(s) *)
		       report_unexpected_offset(expected_offset,
		         tape_buffer[tape_index].page_offset);
		       clear_missing_param_pages(expected_offset,
		         tape_buffer[tape_index].page_offset - 1,
			 uun_default, add_back_default, blocks_written)
		     end (* missing pages, write out default(s) *);
	           write_param_page(tape_buffer[tape_index].page_offset,
		     tape_buffer[tape_index].page_data, blocks_written, ok);
		 end (* checksum is ok, and offset is not illegal *);
	    if tape_buffer[tape_index].page_offset = ADD_BACK_PAGE_MAX
	    then done := TRUE
	    else expected_offset := tape_buffer[tape_index].page_offset + 1;
	    if tape_index < TAPE_PAGE_BLOCK_LIMIT
	    then tape_index := tape_index + 1
	    else tape_blk_done := TRUE
          end (* not done and user_terminal.sendable and not tape_blk_done *)
      end (* not done and user_terminal.sendable *)
    end (* ok *);
$endif reuse_uuns
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  complete_file_restore(unit, blocks_written, blocks_read, TRUE, ok)
end (* restore_parameter *);
!
"
		restore CUD
"
$if CONVERT_TO_43



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                           convert_cud_data				*)
(*                                                                      *)
(************************************************************************)

procedure convert_cud_data(
      cud_entry		: cud_user_entry;
  var mud_entry 	: mud_user_entry;
  var nud_entry 	: nud_user_entry);

var
  option : cud_control_options;
  index : access_entry_index;

begin
  with mud_entry, nud_entry, cud_entry do
    begin
(* copy NUD data *)
      entry_change_date := cud_entry_change_date;
$if include_gan    gan := cud_gan;
$if special
      (* non-usuable cubs window expands to Jan 2-4,1990 by 1/1/1995 *)
      if (cud_password_change_date > REALTIME div SECONDS_PER_DAY) or
	(cud_password_change_date < ENGINE_940_DAYS_BIAS + 365) "no isis < 1/1/75"
      then calendar.cubs_to_isis_days(cud_password_change_date, password_change_date)
      else
$endif special
      password_change_date := cud_password_change_date;
      password_change_date := SECONDS_PER_DAY * password_change_date;
      district := cud_district;
(* copy NUD and MUD options *)
      nud_options := [];
      mud_options := [];
      for option := FIRST_CUD_CONTROL_OPTION to LAST_CUD_CONTROL_OPTION do
	if option in cud_options
	then
	  case option of
	    OLD_NETWORK_ADMINISTRATOR: nud_options := nud_options or 
	      [NETWORK_ADMINISTRATOR];

	    OLD_ACCOUNT_SUPERVISOR: nud_options := nud_options or 
	      [ACCOUNT_SUPERVISOR];

	    OLD_OPERATOR: nud_options := nud_options or [OPERATOR];

	    OLD_AUDITOR: nud_options := nud_options or [AUDITOR];

(*      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-  *)
$if force_password_change
"$ifany (force_password_change, allow_global_password_expire)"
    	    OLD_FPC_EXEMPT: nud_options := nud_options or [FPC_EXEMPT];

$endif force_password_change
$if no_self_password_change
    	    OLD_NSP_CHANGE: nud_options := nud_options or [NSP_CHANGE];

$endif no_self_password_change
(*      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-  *)
	    OLD_IGNORE_DESTINATION: mud_options := mud_options or 
	      [IGNORE_DESTINATION];

	    OLD_NO_PASSWORD_REQUIRED: mud_options := mud_options or 
	      [NO_PASSWORD_REQUIRED];

	    OLD_TRANSPARENT_LOGIN: mud_options := mud_options or 
	      [TRANSPARENT_LOGIN]
	  end (* case *);
      mud_options := mud_options or [USERNAME_TYPE];
(* copy MUD data *)
$if INCLUDE_IRC
      irc := cud_irc;
      if irc > 0
      then entry_type := EXPIRE_DATE_IRC_ENTRY
      else
$endif INCLUDE_IRC
      entry_type := MINIMUM_ENTRY;
      uun := cud_uun;
      password.cipher := cud_password;
      password.expire_date := 0;
      mud_access_profile := cud_access_profile;
      for index := 0 to mud_access_profile.count - 1 do
	begin
          mud_access_profile.entries[index].access_control :=
	    DEFAULT_AP_CONTROL;
          if OLD_SHUT_OVERRIDE in cud_options
          then mud_access_profile.entries[index].access_control :=
	    mud_access_profile.entries[index].access_control + SHUT_OVERRIDE_BIT
	end (* for count *)
  end (* with cud_entry, mud_entry, nud_entry *)
end (* convert_cud_data *);
$endif CONVERT_TO_43



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                           restore_cud_block	                        *)
(*                                                                      *)
(************************************************************************)

procedure restore_cud_block(
$if CONVERT_TO_43      delete_illegal		: boolean;
  var block		: cud_block_index;
$if convert_to_43
  var disk_buffer	 : read_cud_disk_block;
  var blocks_read	: integer);
$endif CONVERT_TO_43
$ifnone convert_to_43
  var disk_buffer       : cud_disk_block;
  var blocks_written	: integer);
$endif CONVERT_TO_43

var
  result : cud_operation_result;
$ifnone BEFORE_SUP_V43
$if convert_to_43
  illegal_name : boolean;
  name_index : username_text_index;
  mud_entry : mud_user_entry;
  nud_entry : nud_user_entry;
  cud_entry : cud_user_entry;
  pointer : read_cud_data_index;
$endif CONVERT_TO_43
$endif BEFORE_SUP_V43

begin
$ifnone BEFORE_SUP_V43
$if convert_to_43
  pointer := 0;
  cud_updater.next_read_cud_list(disk_buffer, block, pointer, cud_entry);
  while (cud_updater.last_status = CUD_ENTRY_OK) and user_terminal.sendable do
    begin
      read_entries := read_entries + 1;
      with cud_entry, mud_entry do
	begin
	  illegal_name := FALSE;
          name.size := 0;
	  for name_index := 0 to (cud_name.size - 1) do
	    if mutil.legal_username_character(cud_name.text[name_index])
	    then
	      begin
	        name.size := succ(name.size);
	        name.text[name_index] := cud_name.text[name_index]
	      end (* if legal *)
	    else illegal_name := TRUE;
          if illegal_name
          then report_illegal_name(cud_name, name, delete_illegal)
	end (* with cud_entry, mud_entry *);
      if not illegal_name or not delete_illegal
      then
	begin
          convert_cud_data(cud_entry, mud_entry, nud_entry);
(* copy access profile *)
          mud_updater.new_cud_entry(mud_entry, nud_entry);
          if mud_updater.last_status = CUD_ENTRY_OK
          then write_entries := write_entries + 1
          else report_name_entry_error(mud_updater.last_status,
	    block, mud_entry.name);
	end (* not illegal *);
      if (read_entries mod 500) = 0
      then report_format_progress;
      cud_updater.next_read_cud_list(disk_buffer, block, pointer, cud_entry)
    end (* while CUD_ENTRY_OK *);
$endif convert_to_43
$endif BEFORE_SUP_V43
$ifnone CONVERT_TO_43
  block_updater.update_cud_block(block, disk_buffer, result);
  if result = CUD_OPERATION_FAILED
  then report_cud_error(result, block)
  else
    begin
      increment_count(blocks_written);
$endif CONVERT_TO_43
$if CONVERT_TO_43       blocks_read := blocks_read + 1;
      user_terminal.check_circuit
$ifnone CONVERT_TO_43    end
end (* restore_cud_block *);



(**************************  archive_commands  **************************)
(*									*)
(*			  clear_missing_blocks				*)
(*									*)
(************************************************************************)

procedure clear_missing_blocks(
      first_to_clear	: cud_block_index;
      last_to_clear	: cud_block_index;
  var blocks_written	: integer);

var
$ifnone CONVERT_TO_43  cleared_block		: cud_disk_block;
$if CONVERT_TO_43  cleared_block		: read_cud_disk_block;
  clear_index		: cud_block_index;
  done			: boolean;

begin
  clearing_message(first_to_clear, last_to_clear);
  mutil.clear_block(cleared_block.data);
$ifnone CONVERT_TO_43
  sys_io.cud_checksum(MAXIMUM_CUD_DATA, cleared_block.data,
    cleared_block.checksum);
$endif CONVERT_TO_43
$if CONVERT_TO_43
  sys_io.read_cud_checksum(MAXIMUM_READ_CUD_DATA, cleared_block.data,
    cleared_block.checksum);
$endif CONVERT_TO_43
  clear_index := first_to_clear; done := FALSE;
  while not done and user_terminal.sendable do
    begin
      restore_cud_block(
$if CONVERT_TO_43        FALSE,
      clear_index, cleared_block, blocks_written);
      if clear_index = last_to_clear
      then done := TRUE
      else clear_index := clear_index + 1;
      user_terminal.check_circuit
    end
end (* clear_missing_blocks *);
$if CONVERT_TO_43


(**************************  archive_commands  **************************)
(*                                                                      *)
(*                           report_format_errors                     	*)
(*                                                                      *)
(************************************************************************)

procedure report_format_errors;

begin
  format.start_message('CUD reformat complete\');
  if errors > 0
  then
    begin
      format.colon_space;
      format.number(errors, 10);
      if errors > 1
      then format.string(' CUD entries lost\')
      else format.string(' CUD entry lost\')
    end;
  format.write_line(user_terminal)
end (* report_format_errors *);
$endif CONVERT_TO_43



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                           restore_cud                                *)
(*                                                                      *)
(************************************************************************)

procedure restore_cud(
      unit		: tape_unit_index;
      restore_blocks	: range;
$if CONVERT_TO_43      delete_illegal		: boolean;
  var ok		: boolean);

var
  computed_checksum : integer;
  tape_buffer : tape_cud_block;
  tape_index : tape_cud_block_index;
  first_to_clear,
  last_to_clear,
  expected_block : cud_block_index;
  tape_blk_done,
  block_read_in_range,
  block_expected_in_range,
  done : boolean;
  blocks_read,
  blocks_written : integer;
  new_blocks_read,
  new_blocks_written : integer;
  ptr : cud_data_index;
$if CONVERT_TO_43
  label	: ansii_tape_label;
$endif CONVERT_TO_43

begin
  initialize_file_restore(unit, CUD_FILE,
$ifnot CONVERT_TO_43    NULL_STRING,
$if CONVERT_TO_43    ' to version 43\ ',
    blocks_written, blocks_read, ok);
  done := FALSE; expected_block := 0;
  if ok
  then
    repeat
      tape_blk_done := FALSE; tape_index := 0;
      tape_io.read_cud_block(unit, tape_buffer, ok);
      if ((not ok) and ((tape_io.param.status = END_MEDIUM) or
        (tape_io.param.status = END_FILE))) and
	(tape_buffer[tape_index].block <
$ifnone CONVERT_TO_43		CUD_BLOCK_LIMIT)
$if CONVERT_TO_43		CONVERT_BLOCK_LIMIT)
      then
	begin
	  restore_file_volume(unit, CUD_FILE, done, ok);
      	  tape_blk_done := FALSE; tape_index := 0;
	  if ok and not done
          then tape_io.read_cud_block(unit, tape_buffer, ok)
	end;
	if not ok and not done
	then report_tape_file_error(unit, expected_block)
$if CONVERT_TO_43 ;
$ifnot CONVERT_TO_43     else blocks_read := blocks_read + 1;
      repeat
        block_expected_in_range := (expected_block >= restore_blocks.first) and
	  (expected_block <= restore_blocks.last);
	if ok and not done
$ifnone CONVERT_TO_43           then sys_io.cud_checksum(MAXIMUM_CUD_DATA,
$if CONVERT_TO_43          then sys_io.read_cud_checksum(MAXIMUM_READ_CUD_DATA,
	    tape_buffer[tape_index].cud_data.data, computed_checksum);
	if computed_checksum <> tape_buffer[tape_index].cud_data.checksum
	then
	  begin
	    report_checksum_error(expected_block);
	    ok := FALSE
	  end (* checksum does not match *);
	if not ok
	then
	  begin
	    ok := TRUE;
	    if block_expected_in_range
	    then clear_missing_blocks(expected_block, expected_block,
	      blocks_written)
	  end (* not ok *)
	else
	  begin
	    block_read_in_range :=
	      (tape_buffer[tape_index].block >= restore_blocks.first) and
	      (tape_buffer[tape_index].block <= restore_blocks.last);
	    if block_read_in_range and
	      (tape_buffer[tape_index].block = expected_block)
	    then restore_cud_block(
$if CONVERT_TO_43	    delete_illegal,
	      expected_block, tape_buffer[tape_index].cud_data,
$ifnone CONVERT_TO_43        blocks_written)
$if CONVERT_TO_43         blocks_read)
	    else
	      if (tape_buffer[tape_index].block < expected_block) or
	        (tape_buffer[tape_index].block >
$ifnone CONVERT_TO_43		CUD_BLOCK_LIMIT)
$if CONVERT_TO_43		CONVERT_BLOCK_LIMIT)
	      then
	        begin
		  done := TRUE; ok := FALSE;
		  report_illegal_offset(tape_buffer[tape_index].block)
		end
	      else
	        if tape_buffer[tape_index].block > expected_block
		then
		  begin
		    if block_expected_in_range
		    then report_unexpected_offset(expected_block,
		      tape_buffer[tape_index].block);
		    if block_read_in_range
      		    then restore_cud_block(
$if CONVERT_TO_43        delete_illegal,
		      tape_buffer[tape_index].block,
		      tape_buffer[tape_index].cud_data,
$ifnone CONVERT_TO_43     			blocks_written);
$if CONVERT_TO_43     			blocks_read);
		    if (expected_block <= restore_blocks.last) and
		       (blocks_written > 0) and
		      (tape_buffer[tape_index].block >= restore_blocks.first)
		    then
		      begin (* clear the blocks *)
		        if expected_block <= restore_blocks.first
			then first_to_clear := restore_blocks.first
			else first_to_clear := expected_block;
			if tape_buffer[tape_index].block > restore_blocks.last
			then last_to_clear := restore_blocks.last
			else last_to_clear := tape_buffer[tape_index].block-1;
			clear_missing_blocks(first_to_clear, last_to_clear,
			  blocks_written)
		      end (* clear the blocks *)
		  end (* tape_buffer.block > expected_block *)
	  end (* else chksum ok *);

	if tape_buffer[tape_index].block >= restore_blocks.last
	then done := TRUE
	else expected_block := tape_buffer[tape_index].block + 1;
	if tape_index < TAPE_CUD_BLOCK_LIMIT
	then tape_index := tape_index + 1
	else tape_blk_done := TRUE;
	user_terminal.check_circuit
      until (not user_terminal.sendable) or done or tape_blk_done or
        (tape_io.param.status = END_FILE)
    until (not user_terminal.sendable) or done or
      (tape_io.param.status = END_FILE);

$if CONVERT_TO_43   report_format_progress;
  if tape_io.param.status = END_FILE
  then ok := TRUE;
  if ok and user_terminal.sendable
  then
$ifnot CONVERT_TO_43
    if (restore_blocks.first = 0) and
      (restore_blocks.last = CUD_BLOCK_LIMIT)
    then complete_file_restore(unit, blocks_written, blocks_read, TRUE, ok)
    else report_blocks(blocks_written, blocks_read)
$endif CONVERT_TO_43
$if CONVERT_TO_43
    begin
      format.start_message('blocks read: \');
      format.number(blocks_read, 10);
      if (restore_blocks.first = 0) and
	(restore_blocks.last = CONVERT_BLOCK_LIMIT)
      then
        begin
          tape_io.position_drive(unit, TAPE_FORWARD_FILE);
          read_label(unit, TRUE, EOF1_ID, label, ok) (* read EOF1 label *);
          tape_io.position_drive(unit, TAPE_FORWARD_FILE) (* skip eof mark *)
        end
    end (* ok and user_terminal.sendable *)
$endif CONVERT_TO_43
end (* restore_cud *);
!
"
		restore node host file
"


(**************************  archive_commands  **************************)
(*                                                                      *)
(*                          restore_list_header                         *)
(*                                                                      *)
(************************************************************************)

procedure restore_list_header(
      unit	: tape_unit_index;
  var ok	: boolean);

var
  buffer : page_record;
  blocks_read : integer;
  blocks_written : integer;

begin
  initialize_file_restore(unit, NODE_HOST_FILE, FILE_HEADER_MESSAGE,
    blocks_written, blocks_read, ok);
  if ok
  then read_tape_page(unit, 0, buffer, blocks_read, ok);
  if ok
  then list_utility.restore_header(buffer, ok);
  if ok
  then blocks_written := blocks_written + 1;
  complete_file_restore(unit, blocks_written, blocks_read, TRUE, ok)
end (* restore_list_header *);



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                            restore_lists				*)
(*                                                                      *)
(************************************************************************)

procedure restore_lists(
      unit		: tape_unit_index;
      host_flag		: boolean;
      file_message	: quoted_text;
  var ok		: boolean);

var
  done : boolean;
  computed_checksum : integer;
  tape_buffer : tape_named_list_definition;
  blocks_read : integer;
  blocks_written : integer;
  expected_list : list_index;

begin
  initialize_file_restore(unit, NODE_HOST_FILE, file_message,
    blocks_written, blocks_read, ok);
  if ok
  then
    begin
      tape_buffer.named_list.name.size := 0 (* first clear entire file *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if include_list_descriptions
      tape_buffer.named_list.description.size := 0;
$endif include_list_descriptions
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      tape_buffer.named_list.count := 0;
      for expected_list := 0 to LIST_LIMIT do
        list_utility.write_named_list(host_flag, expected_list,
	  tape_buffer.named_list, ok);
      done := FALSE; expected_list := 0;
      repeat
        tape_io.read_named_list(unit, tape_buffer, ok);
        if ok
        then
          begin
            blocks_read := blocks_read + 1;
	    sys_io.named_list_checksum(tape_buffer.named_list,
	      computed_checksum);
	    if computed_checksum <> tape_buffer.named_list.checksum
	    then report_checksum_error(tape_buffer.list_ptr)
	    else
	      if (tape_buffer.list_ptr < expected_list) or
	        (tape_buffer.list_ptr > LIST_LIMIT)
	      then
		begin
		  done := TRUE; ok := FALSE;
		  report_illegal_offset(tape_buffer.list_ptr)
		end (* illegal offset found on tape *)
	      else
		begin (* write list to disk *)
		  expected_list := tape_buffer.list_ptr;
		  list_utility.write_named_list(host_flag,
		    tape_buffer.list_ptr, tape_buffer.named_list, ok);
	          if not ok
		  then report_disk_error(tape_buffer.list_ptr)
		  else
		    begin
		      blocks_written := blocks_written + 1;
		      user_terminal.check_circuit
		    end (* if ok *)
                end (* write list to disk *)
          end (* if ok *)
        else (* read not ok *)
	  if tape_io.param.status = END_FILE
	  then
	    begin
	      done := TRUE;
	      ok := TRUE
	    end (* end of file found *)
	  else report_tape_error(unit)
      until done or not user_terminal.sendable;
      complete_file_restore(unit, blocks_written, blocks_read, FALSE, ok)
    end
end (* restore_lists *);



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                       restore_global_accesses			*)
(*                                                                      *)
(************************************************************************)

procedure restore_global_accesses(
      unit		: tape_unit_index;
      class_flag	: boolean;
      file_message	: quoted_text;
      first_value	: integer;
      maximum_value	: integer;
  var ok		: boolean);

var
  computed_checksum : integer;
  tape_buffer : tape_global_access_definition;
  global_access : global_access_description;
  done : boolean;
  last_value : integer;
  blocks_read : integer;
  blocks_written : integer;

begin
  initialize_file_restore(unit, NODE_HOST_FILE, file_message,
    blocks_written, blocks_read, ok);
  if ok
  then
    begin
      global_access.count := 0 (* first clear all global accesses *);
      for last_value := first_value to maximum_value do
        list_utility.write_global_access(class_flag, last_value, global_access,
	  ok);
      done := FALSE; last_value := 0;
      repeat
        tape_io.read_global_access(unit, tape_buffer, ok);
	if ok
	then
	  begin
	    blocks_read := blocks_read + 1;
	    sys_io.global_access_checksum(tape_buffer.global_access,
	      computed_checksum);
	    if computed_checksum <> tape_buffer.global_access.checksum
	    then report_checksum_error(tape_buffer.global_value)
	    else
	      if (tape_buffer.global_value > maximum_value) or
		(tape_buffer.global_value <= last_value)
	      then
	        begin (* illegal value found on tape *)
		  done := TRUE; ok := FALSE;
		  report_illegal_offset(tape_buffer.global_value)
		end (* illegal value found on tape *)
	      else
	        begin (* write the global access *)
		  last_value := tape_buffer.global_value;
		  list_utility.write_global_access(class_flag,
		    tape_buffer.global_value, tape_buffer.global_access, ok);
		  if not ok
		  then report_disk_error(tape_buffer.global_value)
		  else
		    begin
		      blocks_written := blocks_written + 1;
		      user_terminal.check_circuit
		    end (* if ok *)
		end (* write the global access *)
     	  end (* return from  read_global_access was ok *)
	else (* return from read_global_access not ok *)
	  if tape_io.param.status = END_FILE
	  then
	    begin
	      done := TRUE;
	      ok := TRUE
	    end
	  else report_tape_error(unit)
      until done or not user_terminal.sendable;
      complete_file_restore(unit, blocks_written, blocks_read, FALSE, ok)
    end (* if initialize_file_restore was ok *)
end (* restore_global_accesses *);
!
"
		restore mud change file
"


(**************************  archive_commands  **************************)
(*                                                                      *)
(*                           restore_mud_change                         *)
(*                                                                      *)
(************************************************************************)

procedure restore_mud_change(
	unit		: tape_unit_index;
  var ok		: boolean);

var
  buffer : tape_mudupd_header_definition;
  blocks_read : integer;
  blocks_written : integer;
  new_blocks_written : integer;
  computed_checksum : integer;
  done : boolean;

begin
  initialize_file_restore(unit, MUD_UPDATE_FILE, NULL_STRING, blocks_written,
    blocks_read, ok);
  if ok
  then
    begin
      tape_io.read_mudupd_header(unit, buffer, ok);
      if ok
      then
	begin
	  blocks_read := blocks_read + 1;
	  sys_io.page_checksum(PAGE_SIZE, buffer.mudupd_info,
	    computed_checksum);
	  if computed_checksum <> buffer.checksum
	  then
	    begin
	      report_checksum_error(0);
	      ok := FALSE
	    end (* computed_checksum <> buffer.checksum *)
        end (* ok *)
      else report_tape_file_error(unit, 0);
      if not ok
      then
        begin
	  ok := TRUE;
	  mud_change.make_new_mudupd(ok)
	end
      else mud_change.write_header(buffer.mudupd_info, ok);
      if ok
      then blocks_written := blocks_written + 1
      else report_disk_error(0)
    end;
  if ok
  then complete_file_restore(unit, blocks_written, blocks_read, TRUE, ok)
end (* restore_mud_change *);
!
"
		restore operlog file
"



(**************************  archive_commands  **************************)
(*									*)
(*			    write_operlog_page				*)
(*									*)
(************************************************************************)

procedure write_operlog_page(
      page_offset	: univ oper_log_archive_page_index;
  var page_data		: page_record;
  var blocks_written	: integer;
  var ok		: boolean);

begin
  oplog.write_operlog_page(page_offset, page_data, ok);
  if not ok
  then report_disk_error(page_offset)
  else blocks_written := blocks_written + 1
end (* write_operlog_page *);



(**************************  archive_commands  **************************)
(*									*)
(*			 clear_missing_oper_pages			*)
(*									*)
(************************************************************************)

procedure clear_missing_oper_pages(
      first_to_clear	: oper_log_archive_page_index;
      last_to_clear	: oper_log_archive_page_index;
  var blocks_written	: integer);

var
  ok,
  done			: boolean;
  clear_index		: oper_log_archive_page_index;
  cleared_data		: page_record;

begin
  clearing_message(first_to_clear, last_to_clear);
  clear_page(cleared_data);
  clear_index := first_to_clear; done := FALSE;
  while not done and user_terminal.sendable do
    begin
      write_operlog_page(clear_index, cleared_data, blocks_written, ok);
      if clear_index = last_to_clear
      then done := TRUE
      else clear_index := clear_index + 1;
      user_terminal.check_circuit
    end
end (* clear_missing_oper_pages *);
$if INCLUDE_DNIC


(**************************  archive_commands  **************************)
(*                                                                      *)
(*                         restore_dnic_file	                        *)
(*                                                                      *)
(************************************************************************)

procedure restore_dnic_file(
      unit	: tape_unit_index;
  var ok	: boolean);

var
  buffer : tape_dnic_file;
  computed_checksum : integer;
  blocks_written : integer;
  blocks_read : integer;
  new_blocks_written : integer;
  new_blocks_read : integer;
  done : boolean;

begin
  initialize_file_restore(unit, DNIC_FILE, NULL_STRING, blocks_written,
    blocks_read, ok);
  if ok and user_terminal.sendable
  then
    begin (* actually restore dnic *)
      tape_io.read_dnic_file(unit, buffer, ok);
      if not ok
      then report_tape_file_error(unit, 0)
      else
        begin (* compute checksum then write tape table to disc *)
	  blocks_read := blocks_read + 1;
	  sys_io.dnic_checksum(buffer.file, computed_checksum);
	 
          if computed_checksum <> buffer.checksum
          then report_checksum_error(0)
  	  else
	    begin
	      dnic.move_dnic_to_disc(buffer.file, ok);
              if ok then
                blocks_written := blocks_written + 1
              else report_disk_error(0)
	    end
        end  (* compute checksum then write tape table to disc *)
    end (* restore dnic *);

  if ok and user_terminal.sendable
  then complete_file_restore(unit, blocks_written, blocks_read, TRUE, ok)
end (* restore_dnic_file *);
$endif INCLUDE_DNIC


(**************************  archive_commands  **************************)
(*                                                                      *)
(*                         restore_operlog_file	                        *)
(*                                                                      *)
(************************************************************************)

procedure restore_operlog_file(
      unit	: tape_unit_index;
  var ok	: boolean);

var
  tape_buffer : tape_page_block;
  expected_offset : oper_log_archive_page_index;
  tape_blk_done : boolean;
  done : boolean;
  blocks_written : integer;
  blocks_read : integer;
  tape_index : tape_page_block_index;
  checksum_flags : blocked_page_checksums;

begin
  initialize_file_restore(unit, OPERLOG_FILE, NULL_STRING, blocks_written,
    blocks_read, ok);
  expected_offset := 0; done := not ok;
  while user_terminal.sendable and not done do
    begin
      for tape_index := 0 to TAPE_PAGE_BLOCK_LIMIT do
        checksum_flags[tape_index] := FALSE;
      tape_index := 0; tape_blk_done := FALSE;
      read_blocked_tape_page(unit, expected_offset, OPER_LOG_HEADER_PAGE,
        OPERLOG_FILE, done, tape_buffer, blocks_read, checksum_flags);
      if tape_io.param.status = END_FILE
      then
        begin
	  done := TRUE;
	  ok := TRUE
	end (* found end of file *);
      while not done and user_terminal.sendable and not tape_blk_done do
        begin
	  if not checksum_flags[tape_index]
	  then
	    begin
	      clear_missing_oper_pages(expected_offset, expected_offset,
	        blocks_written);
	      tape_buffer[tape_index].page_offset := expected_offset
	    end
	  else
	    if (tape_buffer[tape_index].page_offset < expected_offset) or
	      (tape_buffer[tape_index].page_offset > OPER_LOG_HEADER_PAGE)
	    then
	      begin
	        done := TRUE; ok := FALSE;
		report_illegal_offset(tape_buffer[tape_index].page_offset)
	      end
	    else
	      begin
	        if (tape_buffer[tape_index].page_offset > expected_offset) and
			(blocks_written > 0)
		then
		  begin
		    report_unexpected_offset(expected_offset,
		      tape_buffer[tape_index].page_offset);
		    clear_missing_oper_pages(expected_offset,
		      tape_buffer[tape_index].page_offset - 1, blocks_written)
		  end;
		if user_terminal.sendable and ok
		then write_operlog_page(tape_buffer[tape_index].page_offset,
		  tape_buffer[tape_index].page_data, blocks_written, ok)
	      end;
	  if tape_buffer[tape_index].page_offset = OPER_LOG_HEADER_PAGE
	  then done:= TRUE
	  else expected_offset := tape_buffer[tape_index].page_offset + 1;
	  if tape_index = TAPE_PAGE_BLOCK_LIMIT
	  then tape_blk_done := TRUE
	  else tape_index := tape_index + 1;
	  user_terminal.check_circuit
	end (* while *)
    end (* outer while loop *);
  if ok and user_terminal.sendable
  then complete_file_restore(unit, blocks_written, blocks_read, TRUE, ok)
end (* restore_operlog_file *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if ganpass_file_exists



(**************************  archive_commands  **************************)
(*									*)
(*  Name:	restore_passtable_file					*)   
(*									*)
(*  Purpose:	move passtable file from tape to disc			*)
(*									*)
(************************************************************************)
procedure restore_passtable_file(
      unit	: tape_unit_index;
  var ok	: boolean);

var
  blocks_written : integer;
  blocks_read : integer;
  new_blocks_written : integer;
  new_blocks_read : integer;
  buffer : tape_passtable;
  computed_checksum : integer;
  done : boolean;

begin (* restore_passtable_file *)
  initialize_file_restore(unit, PASSTABLE_FILE, NULL_STRING, blocks_written,
    							blocks_read, ok);
  if ok
  then
    begin (* actually restore passtable *)
      tape_io.read_passtable_file(unit, buffer, ok);
      if not ok
      then report_tape_file_error(unit, 0)
      else
        begin (* compute checksum then write tape table to disc *)
	  blocks_read := blocks_read + 1;
	  sys_io.passtable_checksum(PASSTABLE_FILE_LENGTH_IN_BYTES,
          		 		buffer.data, computed_checksum);
	 
          if computed_checksum <> buffer.checksum
          then report_checksum_error(0)
  	  else
	    begin
	      pasmon.move_passtable_to_disc(buffer.data, ok);
      	      if ok
      	      then blocks_written := blocks_written + 1
      	      else report_disk_error(0)
	    end
        end  (* compute checksum then write tape table to disc *)
    end (* actually restore passtable *);

  if ok 
  then complete_file_restore(unit, blocks_written, blocks_read, TRUE, ok)
end (* restore_passtable_file *);
$endif ganpass_file_exists
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(**************************  archive_commands  **************************)
(*									*)
(*  Name:	restore_schedtable_file					*)   
(*									*)
(*  Purpose:	move schedtable file from tape to disc			*)
(*									*)
(************************************************************************)
procedure restore_schedtable_file(
      unit	: tape_unit_index;
  var ok	: boolean);

var
  blocks_written : integer;
  blocks_read : integer;
  new_blocks_written : integer;
  new_blocks_read : integer;
  buffer : tape_schedtable;
  computed_checksum : integer;
  done : boolean;

begin (* restore_schedtable_file *)
  initialize_file_restore(unit, SCHEDTABLE_FILE, NULL_STRING, blocks_written,
    							blocks_read, ok);
  if ok
  then
    begin (* actually restore schedtable *)
      tape_io.read_schedtable_file(unit, buffer, ok);
      if not ok
      then report_tape_file_error(unit, 0)
      else
        begin (* compute checksum then write tape table to disc *)
	  blocks_read := blocks_read + 1;
          sys_io.page_checksum(PAGE_SIZE, buffer.data, computed_checksum);
	 
          if computed_checksum <> buffer.checksum
          then report_checksum_error(0)
  	  else
	    begin
	      mud_change.move_schedtable_to_disc(buffer.data, ok);
              if ok then
                blocks_written := blocks_written + 1
              else report_disk_error(0)
	    end
        end  (* compute checksum then write tape table to disc *)
      end (* restore schedtable  *);

  if ok 
  then complete_file_restore(unit, blocks_written, blocks_read, TRUE, ok)
end (* restore_schedtable_file *);
$ifnone convert_to_43


(**************************  archive_commands  **************************)
(*									*)
(*			     restore_command				*)
(*									*)
(************************************************************************)

procedure restore_command(
  var scanned	: scanned_command;
  var unit	: tape_unit_index);

var
  cud_restore_blocks : range;
  all_files (* TRUE if all files being restored *),
  ok : boolean;
  done : boolean;
  last_file_to_restore,
  file : archive_file_index;

begin
  all_files := TRUE;
  cud_restore_blocks.first := 0;
  cud_restore_blocks.last := CUD_BLOCK_LIMIT;
  get_command_unit(unit, scanned);
  if scanned.status = CMD_OK
  then
    if scanned.subcommand <> ARCHIVE_RESTORE_ALL_KEYWORD
    then
      begin
        all_files := FALSE;
	if scanned.subcommand = ARCHIVE_RESTORE_CUD_KEYWORD
	then
	  if argument_scan.check_keyword(ARCHIVE_RESTORE_BLOCK_KEYWORD,
	    scanned)
	  then argument_scan.freeword_range(1, 0, CUD_BLOCK_LIMIT, 10,
	    scanned, cud_restore_blocks)
      end;
  argument_scan.extra_argument_check(scanned);

  if scanned.status = CMD_OK
  then
    if check_tape_and_configuration(unit)
    then
      begin
        if all_files
	then
	  begin
	    config_utility.new_configuration_file;
	    file := succ(FIRST_ARCHIVE_FILE) (* skip config file here *);
	    last_file_to_restore := LAST_ARCHIVE_FILE
	  end
	else
	  begin (* not doing an all files, set up limits of files to store *)
	    case scanned.subcommand of
	      ARCHIVE_RESTORE_CUD_KEYWORD:
	        begin
		  file := CUD_FILE;
		  if (cud_restore_blocks.first = 0) and
		    (cud_restore_blocks.last = CUD_BLOCK_LIMIT)
		  then last_file_to_restore := CUD_PARAMETER_FILE
		  else last_file_to_restore := CUD_FILE
		end;
$if INCLUDE_DNIC	ARCHIVE_RESTORE_DNIC_FILE_KEYWORD: file := DNIC_FILE;
	      ARCHIVE_RESTORE_NODE_KEYWORD: file := NODE_HOST_FILE;
	      ARCHIVE_RESTORE_MUDUPDATE_KEYWORD: file := MUD_UPDATE_FILE;
$if ganpass_file_exists
	      ARCHIVE_RESTORE_PASSTABLE_KEYWORD: file := PASSTABLE_FILE;
$endif ganpass_file_exists
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

$if change_by_whom
" added archive_restore_schedtable by SHSUE at 30-Jun-87 11:06:17"
$endif change_by_whom
	      ARCHIVE_RESTORE_SCHEDTABLE_KEYWORD: file := SCHEDTABLE_FILE;
	      ARCHIVE_RESTORE_OPERLOG_KEYWORD: file := OPERLOG_FILE
	    end (* case *);
	    if file <> CUD_FILE
	    then last_file_to_restore := file
	  end (* not doing an all files, set up... *);

	done := FALSE; ok := TRUE;
	while ok and user_terminal.sendable and not done do
	  begin
	    case file of (* restore each file *)

	      NODE_HOST_FILE:
	        begin
		  restore_list_header(unit, ok);
		  if ok and user_terminal.sendable
		  then restore_lists(unit, TRUE, file_hostlists_message, ok);
		  if ok and user_terminal.sendable
		  then restore_lists(unit, FALSE, file_nodelists_message, ok);
		  if ok and user_terminal.sendable
		  then restore_global_accesses(unit, TRUE,
		    file_classes_message, FIRST_CLASS, MAXIMUM_CLASS, ok);
		  if ok and user_terminal.sendable
		  then restore_global_accesses(unit, FALSE,
		    file_groups_message, FIRST_GROUP, MAXIMUM_GROUP, ok)
		end (* NODE_HOST_FILE *);

$if INCLUDE_DNIC
	      DNIC_FILE: restore_dnic_file(unit, ok);

$endif INCLUDE_DNIC
	      CLASS_GROUP_FILE: (* null *);
	      OPERLOG_FILE:  restore_operlog_file(unit, ok);

	      MUD_UPDATE_FILE: restore_mud_change(unit, ok);

(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if ganpass_file_exists
	      PASSTABLE_FILE: restore_passtable_file(unit, ok);

$endif ganpass_file_exists
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	      SCHEDTABLE_FILE: restore_schedtable_file(unit, ok);

	      CUD_FILE: restore_cud(unit, cud_restore_blocks, ok);

	      CUD_PARAMETER_FILE: restore_parameter(unit, ok)

	    end (* case *);

	    if file = last_file_to_restore
	    then done := TRUE
	    else file := succ(file)
	  end (* while *);
	rewind_tape(TRUE, unit, ok)
      end (* if check_tape_and_configuration *)
end (* restore_command *);
$endif convert_to_43
$if convert_to_43


(**************************  archive_commands  **************************)
(*									*)
(*			     reformat_command				*)
(*									*)
(************************************************************************)

procedure reformat_command(
  var scanned	: scanned_command;
  var unit	: tape_unit_index);

var
  cud_restore_blocks : range;
  delete_illegal : boolean;
  ok : boolean;
  pass_found : boolean;
  mud_header : mud_block_header;
  buffer : cud_data_block;
  block : cud_block_index;
  done : boolean;
  result : cud_operation_result;

begin
  ok := FALSE; cud_restore_blocks.first := 0; errors := 0;
  cud_restore_blocks.last := CONVERT_BLOCK_LIMIT;
  write_entries := 0; read_entries := 0;
  get_command_unit(unit, scanned);
  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    begin
      format.start_message(
        'This command will read a version 42 or earlier CUD from a NETVAL tape\');
      format.write_line(user_terminal);
      format.start_message(
        'and write the data to the CUD disk in the version 43 format.\ ');
      format.newline;
      format.write_line(user_terminal);
      ok := keyword_scan.input_answer(
        'Are you sure you want to continue\');
    end;
  if ok and user_terminal.sendable
  then
    if check_tape_and_configuration(unit) and user_terminal.sendable
    then
      begin
        delete_illegal := keyword_scan.input_answer(
          'Should illegal names be deleted\');
	format.start;
        format.write_line(user_terminal);
	format.start_message('Initializing CUD file, please wait\ ');
	format.write_line(user_terminal);
	for index := 0 to MUD_DATA_LIMIT do
	  buffer.data.mud_block.data[index] := chr(0);
	if user_terminal.sendable
	then for index := NUD_DATA_ENTRY_OFFSET to NUD_DATA_LIMIT do
	  buffer.data.nud_block[index] := chr(0);
	block := 0; done := FALSE;
	if user_terminal.sendable
	then repeat
	  mud_header.time := REALTIME;
	  mud_header.overflow := [];
$if overflow_cud_entries
	  if block > NORMAL_CUD_BLOCK_LIMIT
	  then
	    begin
mud_header.overflow := mud_header.overflow or
	        [BLOCK_IS_OVERFLOW];
mud_header.block := block - MAXIMUM_NORMAL_CUD_BLOCK
	    end
	  else
$endif overflow_cud_entries
	  mud_header.block := block;
	  cud_utility.pack_mud_header(mud_header, buffer.data.mud_block.data);
	  block_updater.update_cud_block(block, buffer, result);
	  if user_terminal.sendable and (block < CUD_BLOCK_LIMIT)
	  then block := block + 1
	  else done := TRUE
	until done;
	if ok and user_terminal.sendable
	then restore_list_header(unit, ok);
	if ok and user_terminal.sendable
	then restore_lists(unit, TRUE, file_hostlists_message, ok);
	if ok and user_terminal.sendable
	then restore_lists(unit, FALSE, file_nodelists_message, ok);
	if ok and user_terminal.sendable
	then restore_global_accesses(unit, TRUE,
	  file_classes_message, FIRST_CLASS, MAXIMUM_CLASS, ok);
	if ok and user_terminal.sendable
	then restore_global_accesses(unit, FALSE,
	  file_groups_message, FIRST_GROUP, MAXIMUM_GROUP, ok);
	if ok and user_terminal.sendable
	then restore_operlog_file(unit, ok);
	if ok and user_terminal.sendable
	then restore_mud_change(unit, ok);
	if (ok and user_terminal.sendable) and (label_version >= 4)
	then
	  begin
$if ganpass_file_exists
	    restore_passtable_file(unit, ok);
	    if not ok
      	    then tape_io.position_drive(unit, TAPE_FORWARD_FILE);
$endif ganpass_file_exists
	    pass_found := ok;
            restore_schedtable_file(unit, ok)
	  end;
	if ok and user_terminal.sendable
	then restore_cud(unit, cud_restore_blocks, delete_illegal, ok);
	if ok and user_terminal.sendable
	then report_format_errors;
	if ok and user_terminal.sendable
	then restore_parameter(unit, ok);
$if INCLUDE_DNIC
	if ok and user_terminal.sendable
	then
	  begin
            format.start_message('clearing the DNIC files\');
            format.write_line(user_terminal);
	    if keyword_scan.input_answer(OKAY_QUERY)
	    then
	      begin
	        mud_change.new_dnic_header;
	        dnic.new_dnic_table
	      end
	  end;
$endif INCLUDE_DNIC
$if ganpass_file_exists
	if (ok and user_terminal.sendable) and not pass_found
	then
	  begin
            format.start_message('clearing the PASSTABLE file\');
            format.write_line(user_terminal);
	    if keyword_scan.input_answer(OKAY_QUERY)
            then pasmon.new_passtable_file
	  end;
$endif ganpass_file_exists
	if (ok and user_terminal.sendable) and (label_version < 4)
        then
	  begin
            format.start_message('clearing the SCHEDTABLE file\ ');
            format.write_line(user_terminal);
	    if keyword_scan.input_answer(OKAY_QUERY)
            then mud_change.new_schedtable_file;
	  end;
	rewind_tape(TRUE, unit, ok)
      end (* if check_tape_and_config *)
end (* reformat_command *);
$endif convert_to_43
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code
$if include_dump
!
"
		DUMP Command
"



(***************************  archive_commands  *************************)
(*									*)
(*			  store_ascii_dump_block  			*)
(*									*)
(*	Used by the DUMP command to output a block of formatted CUD     *)
(*	data.								*)
(*									*)
(************************************************************************)

procedure store_ascii_dump_block(
      unit		: tape_unit_index;
  var ascii_tape_index	: ascii_dump_tape_block_index;
  var count		: integer;
  var ok		: boolean;
  var end_tape		: boolean);

var
  ascii_tape_buffer : ascii_dump_tape_block;

begin
  if not end_tape
  then
    if format.buffer.size > ASCII_DUMP_DATA_SIZE
    then
      begin
        format.skip_to(FORMAT_BUFFER_TEXT_MAX);
        ascii_tape_buffer[ascii_tape_index] := format.buffer.text;
        format.start;
	if ascii_tape_index < ASCII_DUMP_BLOCK_STRING_LIMIT
        then ascii_tape_index := ascii_tape_index + 1
        else
          begin
	    ascii_tape_index := 0;
  	    tape_io.write_ascii_dump_tape_block(unit, ascii_tape_buffer,
       	      ok, end_tape);
  	    if ok
  	    then count := count + 1
	    else report_tape_error(unit)	
	  end
      end
    else format.skip_to(ASCII_DUMP_DATA_SIZE)
end (* store_ascii_dump_block *);



(*************************  archive_commands  ***************************)
(*									*)
(*			    write_dump_label				*)
(*									*)
(*	Output storing dump, write HDR1, HDR2 and end-of-file mark.	*)
(*									*)
(************************************************************************)

procedure write_dump_label(
      unit		: tape_unit_index;
      file		: archive_file_index;
      block_length	: integer;
      record_length	: integer;
      block_count	: integer;
      file_sequence	: integer;
  var ok		: boolean);

var
  label : ansii_tape_label;

begin
  output_storing(file, ASCII_DUMP);
  init_label(HDR1_ID, label);
  make_hdr1_label(file_sequence, label);
  store_label_number(0, LABEL_BLOCK_COUNT_OFFSET, LABEL_BLOCK_COUNT_SIZE,
    label);
  write_label(unit, HDR1_ID, label, ok);
  if ok
  then write_hdr2_label(unit, block_length, record_length, file_sequence, ok);
  if ok
  then tape_io.position_drive(unit, TAPE_WRITE_EOF)
end (* write_dump_label *);



(*************************  archive_commands  ***************************)
(*									*)
(*			    initialize_dump				*)
(*	Clear block_ccount, set file_sequence and write label.		*)
(*									*)
(************************************************************************)

procedure initialize_dump(
      unit		: tape_unit_index;
      file		: archive_file_index;
      block_length	: integer;
      record_length	: integer;
  var block_count	: integer;
  var file_sequence	: integer;
  var ok		: boolean);

var
  done : boolean;

begin
  block_count := 0;
  file_sequence := file_sequence + 1;
  write_dump_label(unit, file, block_length, record_length, block_count,
    file_sequence, ok);
  if (not ok) and (tape_io.param.status = END_MEDIUM)
  then
    begin
      get_next_volume(unit, file_sequence, 0, done, ok);
      if ok and not done
      then write_dump_label(unit, file, block_length, record_length, block_count,
        file_sequence, ok)
      else ok := FALSE
    end
end (* initialize_dump *);



(**************************  archive_commands  **************************)
(*									*)
(*			     write_ascii_data				*)
(*									*)
(*	Format CUD data to text string. Write full buffer to tape.      *)
(*									*)
(************************************************************************)

procedure write_ascii_data(
      unit		: tape_unit_index;
$if BEFORE_SUP_V43      cud_entry		: cud_user_entry;
$ifnone BEFORE_SUP_V43
      mud_entry		: mud_user_entry;
      nud_entry		: nud_user_entry;
$endif BEFORE_SUP_V43
      selected_fields	: designated_fields;
  var user_count	: integer;
  var ascii_tape_index	: ascii_dump_tape_block_index;
  var block_count	: integer;
  var ok		: boolean;
  var end_tape		: boolean);

var
  index : access_entry_index;

begin
  user_count := user_count + 1;
  format.skip(1);
  format.format_number(user_count, 10, USER_COUNT_SIZE);
  format.skip(1);
  cmd_utility.format_user_data(selected_fields,
$if BEFORE_SUP_V43  cud_entry);
$ifnone BEFORE_SUP_V43  mud_entry, nud_entry);
  store_ascii_dump_block(unit, ascii_tape_index, block_count, ok, end_tape);
  cmd_utility.format_change_dates(selected_fields,
$if BEFORE_SUP_V43  cud_entry);
$ifnone BEFORE_SUP_V43
    mud_entry, nud_entry);
  with mud_entry, mud_access_profile do
$endif BEFORE_SUP_V43
$if BEFORE_SUP_V43  with cud_entry, access_profile do
    begin
      format.format_number(count, 10, ACCESS_COUNT_SIZE);
      for index := 0 to count - 1 do
        begin
	  format.skip(1);
	  format.character(ASCII_PROFILE_FLAG);
 	  cmd_utility.write_access_entry_to_tape(index, entries[index]);
          store_ascii_dump_block(unit, ascii_tape_index, block_count, ok,
	    end_tape)
        end (* for *)
    end (* with cud_entry *)
end (* write_ascii_data *);



(**************************  archive_commands  **************************)
(*								        *)
(*			     format_cud_tape			        *)
(*								        *)
(*	Read CUD data and convert to ASCII string format	        *)
(*								        *)
(************************************************************************)

procedure format_cud_tape(
      unit	 	: tape_unit_index;
  var block_no  	: cud_block_index;
  var block_count 	: integer;
  var ok		: boolean);

var
  list_block_no : cud_block_index;
  user_count : integer;
$if BEFORE_SUP_V43  cud_entry : cud_user_entry;
$ifnone BEFORE_SUP_V43
  mud_entry : mud_user_entry;
  nud_entry : nud_user_entry;
$endif BEFORE_SUP_V43
  disk_block : cud_disk_block;
  ascii_tape_index : ascii_dump_tape_block_index;
  selected_fields : designated_fields;
  end_tape :  boolean;

begin
  end_tape := FALSE;
  ascii_tape_index := 0;
  user_count := 0;
  format.start;
  cmd_utility.clear_designated_fields(selected_fields);
  selected_fields[ALL_FIELDS] := TRUE;
$if BEFORE_SUP_V43
  cud_updater.start_cud_list(block_no, disk_block);
  report_cud_entry_error(cud_updater.last_status, block_no);
  repeat
    cud_updater.next_cud_list(disk_block, list_block_no, cud_entry);
    if cud_updater.last_status = CUD_ENTRY_OK
$endif BEFORE_SUP_V43
$ifnone BEFORE_SUP_V43
  mud_updater.start_cud_list(block_no, disk_block);
  report_cud_entry_error(mud_updater.last_status, block_no);
  repeat
    mud_updater.next_cud_list(disk_block, list_block_no, mud_entry, nud_entry);
    if mud_updater.last_status = CUD_ENTRY_OK
$endif BEFORE_SUP_V43
    then 
      begin
	write_ascii_data(unit,
$if BEFORE_SUP_V43            cud_entry,
$ifnone BEFORE_SUP_V43            mud_entry, nud_entry,
	  selected_fields, user_count, ascii_tape_index,
	  block_count, ok, end_tape);
        if not end_tape and (ascii_tape_index = 0)
	then block_no := list_block_no - 1
      end
    else
$ifnone BEFORE_SUP_V43
      if mud_updater.last_status <> CUD_ENTRY_NOT_FOUND
      then report_cud_entry_error(mud_updater.last_status, list_block_no);
$endif BEFORE_SUP_V43
$if BEFORE_SUP_V43
      if cud_updater.last_status <> CUD_ENTRY_NOT_FOUND
      then report_cud_entry_error(cud_updater.last_status, list_block_no);
$endif BEFORE_SUP_V43
    user_terminal.check_circuit;
    if end_tape
    then
      begin
	store_next_volume(unit, block_no - 1, ok);
	end_tape := not ok
      end
  until (not user_terminal.sendable or end_tape) or
$ifnone BEFORE_SUP_V43    (mud_updater.last_status = CUD_ENTRY_NOT_FOUND);
$if BEFORE_SUP_V43    (cud_updater.last_status = CUD_ENTRY_NOT_FOUND);
  if (list_block_no = CUD_BLOCK_LIMIT) and ((ascii_tape_index > 0) or
    (format.buffer.size > 0))
  then
    repeat
      format.skip_to(FORMAT_BUFFER_TEXT_MAX);
      store_ascii_dump_block(unit, ascii_tape_index, block_count,
	ok, end_tape)
    until ascii_tape_index = 0
end (* format_cud_tape *);



(**************************  archive_commands  **************************)
(*									*)
(*				dump_command				*)
(*									*)
(*	Copy CUD to tape in ascii format			        *)
(*									*)
(************************************************************************)

procedure dump_command(
      unit	: tape_unit_index;
  var block_no	: cud_block_index);

var
  file_sequence : integer;
  block_count : integer;
  new_count : integer;
  cud_locked : boolean;
  user : username_string;
  ok : boolean;
  end_tape : boolean;
  done : boolean;

begin
  init_label_value;
  file_sequence := 0;
  get_cud_locked(cud_locked);
  if cud_locked
  then
    begin
      rewind_tape(TRUE, unit, ok);
      if ok
      then write_volume_label(vol_label, unit, ok);
      if ok and user_terminal.sendable
      then
        begin
	  login_pool.validator_name(validator, user);
	  format.start_message('ASCII dump begun\ ');
	  format.by_validator(user);
	  oper_messages.report_message(ARCHIVE_OPLOG_MSG);
	  format.newline;
	  initialize_dump(unit, CUD_FILE, ASCII_DUMP_BLOCK_SIZE,
  	    ASCII_DUMP_DATA_SIZE, block_count, file_sequence, ok);
  	  if ok
  	  then format_cud_tape(unit, block_no, block_count, ok);
          if ok
	  then
	    begin
  	      write_eof_label(unit, file_sequence, block_count, ok);
	      if not ok and (tape_io.param.status = END_MEDIUM)
	      then get_next_volume(unit, file_sequence, block_count, done, ok)
	      else done := ok
	    end;
	  if ok and not done (* if done does not match ok and ok is true *)
	  then
	    begin (* write header, last record and eof to next tape *)
	      initialize_dump(unit, CUD_FILE, ASCII_DUMP_BLOCK_SIZE,
  	        ASCII_DUMP_DATA_SIZE, new_count, file_sequence, ok);
	      if ok
  	      then tape_io.write_ascii_dump_tape_block(unit, ascii_tape_buffer,
       	        ok, end_tape);
  	      if ok
  	      then write_eof_label(unit, file_sequence, block_count, ok);
	      if not ok
	      then report_tape_error(unit)	
	    end;
          if ok and user_terminal.sendable
	  then
	    begin
	      tape_io.position_drive(unit, TAPE_WRITE_EOF) (* second mark *);
	      format.start_message('ASCII dump completed\ ');
	      oper_messages.report_message(ARCHIVE_OPLOG_MSG);
    	      format.start_line_message('dump completed\ ');
	      format.write_line(user_terminal)
	    end (* ok and sendable *)
	  else
	    begin
              format.start_message('ASCII dump aborted\ ');
	      oper_messages.report_message(ARCHIVE_OPLOG_MSG)
	    end (* not ok or not sendable *);
          rewind_tape(TRUE, unit, ok)
        end (* ok and sendable *);
      cud_access.unlock_cud_file
    end (* cud_locked *)
end (* dump_command *);
$endif include_dump
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
"
		 STORE Command
"



(**************************  archive_commands  **************************)
(*                                                                      *)
(*			    store_blocked_page				*)
(*                                                                      *)
(*	This routine is used for blocked page files (oper file and,	*)
(*	if reuse_uuns ENABLED, cud_parameter).				*)
(*                                                                      *)
(************************************************************************)

procedure store_blocked_page(
      unit		: tape_unit_index;
      file		: archive_file_index;
  var file_sequence	: integer;
  var buffer		: tape_page_block;
  var block_count	: integer;
  var done		: boolean;
  var ok		: boolean);

begin
  tape_io.write_blocked_tape_page(unit, buffer, ok);
  if not ok
  then
    begin
      store_next_volume(unit, block_count, file_sequence, ok);
      if ok
      then initialize_file_store(unit, file, NULL_STRING, TAPE_PAGE_BLOCK_SIZE,
          TAPE_PAGE_BLOCKING_FACTOR, block_count, file_sequence, ok);
      if ok
      then tape_io.write_blocked_tape_page(unit, buffer, ok)
      else done := TRUE
    end;
  if ok
  then increment_count(block_count)
end (* store_blocked_page *);



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                            store_cud                                 *)
(*                                                                      *)
(************************************************************************)

procedure store_cud(
      unit		: tape_unit_index;
  var file_sequence	: integer;
  var ok		: boolean);

var
  result : cud_operation_result;
  block_no : cud_block_index;
  tape_buffer : tape_cud_block;
  block_count : integer;
  done : boolean;
  tape_index : tape_cud_block_index;
  tape_blk_done : boolean;

begin
  initialize_file_store(unit, CUD_FILE, NULL_STRING, TAPE_CUD_BLOCK_SIZE,
    TAPE_BLOCKING_FACTOR, block_count, file_sequence, ok);
  done := not ok; block_no := 0;
    while not done and user_terminal.sendable do
      begin
        tape_index := 0; tape_blk_done := FALSE;
	repeat
          with tape_buffer[tape_index] do
	    begin
              block_utility.read_cud_block(block_no, result, cud_data);
	      if result <> CUD_OPERATION_OK
	      then
	        begin
		  mutil.clear_block(cud_data.data);
		  sys_io.cud_checksum(MAXIMUM_CUD_DATA, cud_data.data,
		    cud_data.checksum);
		  report_cud_error(result, block_no)
	        end
   	      else
	        begin
	          block := block_no;
		  if tape_index < TAPE_CUD_BLOCK_LIMIT
		  then tape_index := tape_index + 1
		  else tape_blk_done := TRUE
		end;
	      if block_no = CUD_BLOCK_LIMIT
	      then done := TRUE
	      else block_no := block_no + 1;
              user_terminal.check_circuit
	    end (* with *)
	until not user_terminal.sendable or done or tape_blk_done;
(* write the block to tape *)
      if ok
      then
        begin
	  tape_io.write_cud_block(unit, tape_buffer, ok);
	  if not ok
	  then
	    begin
	      store_next_volume(unit, block_count, file_sequence, ok);
	      if ok
	      then
  		initialize_file_store(unit, CUD_FILE, NULL_STRING,
		  TAPE_CUD_BLOCK_SIZE, TAPE_BLOCKING_FACTOR, block_count,
		  file_sequence, ok);
	      if ok
	      then tape_io.write_cud_block(unit, tape_buffer, ok)
	      else done := TRUE
	    end;
	  if ok
	  then increment_count(block_count)
	end
    end (* while *);
  if ok
  then complete_file_store(unit, CUD_FILE, TAPE_CUD_BLOCK_SIZE,
    TAPE_BLOCKING_FACTOR, file_sequence, block_count, done, ok)
  else done := TRUE;
  if ok and not done
  then
    begin
      tape_io.write_cud_block(unit, tape_buffer, ok);
      if ok
      then write_eof_label(unit, file_sequence, block_count, ok)
    end
end (* store_cud *);



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                           store_parameter				*)
(*                                                                      *)
(************************************************************************)

procedure store_parameter(
      unit		: tape_unit_index;
  var file_sequence	: integer;
  var ok		: boolean);

var
  block_count : integer;
  done : boolean;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone reuse_uuns     tape_buffer : page_record;
$if reuse_uuns
  tape_buffer : tape_page_block;
  tape_index : tape_page_block_index;
  page_no : cud_parameter_page_index;
  tape_blk_done: boolean;
$endif reuse_uuns
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

begin
  initialize_file_store(unit, CUD_PARAMETER_FILE, NULL_STRING,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone reuse_uuns    PAGE_SIZE, PAGE_SIZE,
$if reuse_uuns
    TAPE_PAGE_BLOCK_SIZE, TAPE_PAGE_BLOCKING_FACTOR,
$endif reuse_uuns
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    block_count, file_sequence, ok);
  if ok
  then
    begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone reuse_uuns
      param_file.read_header(tape_buffer, ok);
      if ok
      then
        begin
	  store_page(unit, tape_buffer, block_count, ok);
	  if ok
	  then complete_file_store(unit, CUD_PARAMETER_FILE, PAGE_SIZE,
	    PAGE_SIZE, file_sequence, block_count, done, ok)
          else done := TRUE;
          if ok and not done
          then
            begin
              store_page(unit, tape_buffer, block_count, ok);
              if ok
              then write_eof_label(unit, file_sequence, block_count, ok)
            end
        end
      else format.write_block(user_terminal)
$endif reuse_uuns
$if reuse_uuns
      done := FALSE; page_no := CUD_PARAMETER_HEADER_PAGE;
      while user_terminal.sendable and not done do
        begin
	  tape_index := 0; tape_blk_done := FALSE;
	  repeat
	    if page_no = CUD_PARAMETER_HEADER_PAGE
	    then param_file.read_header(tape_buffer[tape_index].page_data, ok)
	    else
	      if page_no > BIT18_PAGE_MAX
	      then param_file.read_add_back_page(page_no,
	        tape_buffer[tape_index].page_data, ok)
	      else param_file.read_uun_page(page_no,
	        tape_buffer[tape_index].page_data, ok);
	    if not ok
	    then
	      begin
	        format.write_block(user_terminal);
		clear_page(tape_buffer[tape_index].page_data)
	      end;
	    tape_buffer[tape_index].page_offset := page_no;
	    if tape_index < TAPE_PAGE_BLOCK_LIMIT
	    then tape_index := tape_index + 1
	    else tape_blk_done:= TRUE;
	    if page_no = ADD_BACK_PAGE_MAX
	    then done := TRUE
	    else page_no := page_no + 1;
	    user_terminal.check_circuit
	  until not user_terminal.sendable or tape_blk_done or done;
	  if ok and user_terminal.sendable
	  then store_blocked_page(unit, CUD_PARAMETER_FILE, file_sequence,
	    tape_buffer, block_count, done, ok)
	end (* while *);
      if ok
      then complete_file_store(unit, CUD_PARAMETER_FILE, TAPE_PAGE_BLOCK_SIZE,
	TAPE_PAGE_BLOCKING_FACTOR, file_sequence, block_count, done, ok)
      else done := TRUE;
      if ok and not done
      then
        begin
	  store_blocked_page(unit, CUD_PARAMETER_FILE, file_sequence,
	    tape_buffer, block_count, done, ok);
          if ok
          then write_eof_label(unit, file_sequence, block_count, ok)
    end
$endif reuse_uuns
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    end (* if ok *)
end (* store_parameter *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if INCLUDE_DNIC



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                           store_dnic_file			*)
(*                                                                      *)
(************************************************************************)

procedure store_dnic_file(
      unit		: tape_unit_index;
  var file_sequence	: integer;
  var ok		: boolean);

var
 block_count 		: integer;
 buffer			: tape_dnic_file;
 io_status		: file_utility_status;
 done			: boolean;

begin (* store_dnic_file *)
  initialize_file_store(unit, DNIC_FILE, NULL_STRING, 
  	TAPE_DNIC_LENGTH, TAPE_DNIC_LENGTH, 
	block_count, file_sequence, ok);

  if ok
  then 
    begin (* move dnic file from memory to tape *)
      mud_change.get_dnic_header_info(buffer.file.header);
      dnic.read_dnic_data(buffer.file.data, ok);
      sys_io.dnic_checksum(buffer.file, buffer.checksum);
      tape_io.write_dnic_file(unit, buffer, ok)
    end;

  if ok
  then
    begin
      block_count := block_count + 1;
      complete_file_store(unit, DNIC_FILE, TAPE_DNIC_LENGTH, TAPE_DNIC_LENGTH,
	file_sequence, block_count, done, ok);
      if ok and not done
      then
        begin
          tape_io.write_dnic_file(unit, buffer, ok);
          if ok
          then write_eof_label(unit, file_sequence, block_count, ok)
        end
    end (* move dnic file from memory to tape *)
end (* store_dnic *);
$endif INCLUDE_DNIC
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if ganpass_file_exists



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                           store_passtable_file			*)
(*                                                                      *)
(************************************************************************)

procedure store_passtable_file(
      unit		: tape_unit_index;
  var file_sequence	: integer;
  var ok		: boolean);

var
 block_count 		: integer;
 done			: boolean;
 buffer			: tape_passtable;
 io_status		: file_utility_status;

begin (* store_passtable_file *)
  initialize_file_store(unit, PASSTABLE_FILE, NULL_STRING, 
  	TAPE_PASSTABLE_LENGTH, TAPE_PASSTABLE_LENGTH, 
	block_count, file_sequence, ok);

  if ok
  then 
    begin (* move passtable file from memory to tape *)
      pasmon.fetch_passtable(buffer.data);
      sys_io.passtable_checksum(PASSTABLE_FILE_LENGTH_IN_BYTES,
				 buffer.data, buffer.checksum);
      tape_io.write_passtable_file(unit, buffer, ok)
    end (* move passtable file from memory to tape *);

  if ok
  then
    begin
      block_count := block_count + 1;
      complete_file_store(unit, PASSTABLE_FILE, TAPE_PASSTABLE_LENGTH,
	TAPE_PASSTABLE_LENGTH, file_sequence, block_count, done, ok);
      if ok and not done
      then
        begin
          tape_io.write_passtable_file(unit, buffer, ok);
          if ok
          then write_eof_label(unit, file_sequence, block_count, ok)
        end
    end
end (* store_passtable *);
$endif ganpass_file_exists



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                           store_schedtable_file			*)
(*                                                                      *)
(************************************************************************)

procedure store_schedtable_file(
      unit		: tape_unit_index;
  var file_sequence	: integer;
  var ok		: boolean);

var
 block_count 		: integer;
 done			: boolean;
 buffer			: tape_schedtable;
 io_status		: file_utility_status;

begin (* store_schedtable_file *)
  initialize_file_store(unit, SCHEDTABLE_FILE, NULL_STRING, 
  	TAPE_SCHEDTABLE_LENGTH, TAPE_SCHEDTABLE_LENGTH, 
	block_count, file_sequence, ok);

  if ok
  then 
    begin (* move schedtable file from memory to tape *)
      mud_change.fetch_schedtable(buffer.data);
      sys_io.page_checksum(PAGE_SIZE, buffer.data, buffer.checksum);
      tape_io.write_schedtable_file(unit, buffer, ok);

      if ok
      then 
        begin
	  block_count := block_count + 1;
	  complete_file_store(unit, SCHEDTABLE_FILE, TAPE_SCHEDTABLE_LENGTH,
	    TAPE_SCHEDTABLE_LENGTH, file_sequence, block_count, done, ok);
          if ok and not done
          then
            begin
              tape_io.write_schedtable_file(unit, buffer, ok);
              if ok
              then write_eof_label(unit, file_sequence, block_count, ok)
	    end
        end
    end (* move schedtable file from memory to tape *)
end (* store_schedtable *);



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                           store_list_header				*)
(*                                                                      *)
(************************************************************************)

procedure store_list_header(
      unit		: tape_unit_index;
  var file_sequence	: integer;
  var ok		: boolean);

var
  buffer : page_record;
  status : node_host_utility_status;
  block_count : integer;
  done : boolean;

begin
  initialize_file_store(unit, NODE_HOST_FILE, FILE_HEADER_MESSAGE,
    PAGE_SIZE, PAGE_SIZE, block_count, file_sequence, ok);
  if ok
  then
    begin
      list_io.read_header(buffer, status);
      if status <> NODE_HOST_OK
      then
        begin
	  ok := FALSE;
	  format.write_block(user_terminal)
	end
      else
        begin
	  store_page(unit, buffer, block_count, ok);
	  if ok
	  then complete_file_store(unit, NODE_HOST_FILE, PAGE_SIZE, PAGE_SIZE,
	    file_sequence, block_count, done, ok)
	  else done := TRUE;
          if ok and not done
          then
            begin
              store_page(unit, buffer, block_count, ok);
              if ok
              then write_eof_label(unit, file_sequence, 1, ok)
            end
	end
    end
end (* store_list_header *);



(**************************  archive_commands  **************************)
(*									*)
(*			        store_lists				*)
(*									*)
(************************************************************************)

procedure store_lists(
      unit		: tape_unit_index;
      host_flag		: boolean;
      file_message	: quoted_text;
  var file_sequence	: integer;
  var ok		: boolean);

var
  tape_buffer : tape_named_list_definition;
  status : node_host_utility_status;
  block_count : integer;
  list_desc : list_descriptor;
  done : boolean;

begin
  initialize_file_store(unit, NODE_HOST_FILE, file_message,
    TAPE_NAMED_LIST_DEFINITION_SIZE, TAPE_NAMED_LIST_DEFINITION_SIZE,
    block_count, file_sequence, ok);
  done := not ok;
  list_allocater.start_list(validator, host_flag);
  while user_terminal.sendable and not done do
    begin
      list_allocater.next_list(validator, tape_buffer.list_ptr, done);
      if not done
      then
        begin
	  status := NODE_HOST_OK;
	  list_desc.list_ptr := tape_buffer.list_ptr;
	  list_desc.host_flag := host_flag;
	  list_io.read_list(list_desc, tape_buffer.named_list, status);
	  if status <> NODE_HOST_OK
	  then
	    begin
	      format.write_block(user_terminal);
	      user_terminal.write_quoted_text_line(
	        'list will not be stored to tape\')
	    end
	  else
	    begin (* status = NODE_HOST_OK *)
	      tape_io.write_named_list(unit, tape_buffer, ok);
	      if not ok
	      then
		begin
		  store_next_volume(unit, block_count, file_sequence, ok);
		  if ok
		  then
		    initialize_file_store(unit, NODE_HOST_FILE, file_message,
		      TAPE_NAMED_LIST_DEFINITION_SIZE,
		      TAPE_NAMED_LIST_DEFINITION_SIZE,
		      block_count, file_sequence, ok);
		  if ok
	          then tape_io.write_named_list(unit, tape_buffer, ok)
		  else done := TRUE
		end;
	      user_terminal.check_circuit;
	      if ok
	      then block_count := block_count + 1
	    end (* status = NODE_HOST_OK *)
        end (* if not done *)
    end (* while *);
  if ok
  then complete_file_store(unit, NODE_HOST_FILE, TAPE_NAMED_LIST_DEFINITION_SIZE,
         TAPE_NAMED_LIST_DEFINITION_SIZE, file_sequence, block_count, done, ok)
  else done := TRUE;
  if ok and not done
  then
    begin
      tape_io.write_named_list(unit, tape_buffer, ok);
      if ok
      then write_eof_label(unit, file_sequence, block_count, ok)
    end
end (* store_lists *);



(**************************  archive_commands  **************************)
(*									*)
(*			  store_global_accesses				*)
(*									*)
(************************************************************************)

procedure store_global_accesses(
      unit		: tape_unit_index;
      class_flag	: boolean;
      file_message	: quoted_text;
      first_value	: integer;
      last_value	: integer;
  var file_sequence	: integer;
  var ok		: boolean);

var
  block_count : integer;
  global_value : integer;
  status : node_host_utility_status;
  tape_buffer : tape_global_access_definition;
  done : boolean;

begin
  initialize_file_store(unit, NODE_HOST_FILE, file_message,
    MAXIMUM_TAPE_GLOBAL_ACCESS_DEFINITION_SIZE,
    MAXIMUM_TAPE_GLOBAL_ACCESS_DEFINITION_SIZE, block_count, file_sequence,
    ok);
  if ok
  then
    begin
      for global_value := first_value to last_value do
        if list_allocater.global_access_defined(class_flag, global_value)
	then
	  begin
	    status := NODE_HOST_OK;
	    list_io.read_global_access(class_flag, global_value,
	      tape_buffer.global_access, status);
	    if (status = NODE_HOST_BAD_CHECKSUM) or
	      (status = NODE_HOST_IO_ERROR)
	    then format.write_block(user_terminal)
	    else
	      if status = NODE_HOST_OK
	      then
	        begin (* store the global access to tape *)
		  tape_buffer.global_value := global_value;
		  tape_io.write_global_access(unit, tape_buffer, ok);
		  if not ok
		  then
		    begin
		      store_next_volume(unit, block_count, file_sequence, ok);
		      if ok
		      then
			initialize_file_store(unit, NODE_HOST_FILE, file_message,
			  MAXIMUM_TAPE_GLOBAL_ACCESS_DEFINITION_SIZE,
			  MAXIMUM_TAPE_GLOBAL_ACCESS_DEFINITION_SIZE,
			  block_count, file_sequence, ok);
		      if ok
		      then tape_io.write_global_access(unit, tape_buffer, ok)
		    end;
		  if ok
		  then block_count := block_count + 1
		end (* store the global access to tape *)
	  end (* if defined *)
    end (* if ok *);
  if ok
  then complete_file_store (unit, NODE_HOST_FILE,
         MAXIMUM_TAPE_GLOBAL_ACCESS_DEFINITION_SIZE,
         MAXIMUM_TAPE_GLOBAL_ACCESS_DEFINITION_SIZE,
         file_sequence, block_count, done, ok)
  else done := TRUE;
  if ok and not done
  then
    begin
      tape_io.write_global_access(unit, tape_buffer, ok);
      if ok
      then write_eof_label(unit, file_sequence, block_count, ok)
    end
end (* store_global_accesses *);



(**************************  archive_commands  **************************)
(*                                                                      *)
(*                         store_mud_change_file                        *)
(*                                                                      *)
(************************************************************************)

procedure store_mud_change_file(
      unit		: tape_unit_index;
  var file_sequence	: integer;
  var ok		: boolean);

var
  buffer : tape_mudupd_header_definition;
  block_count : integer;
  done : boolean;

begin
  initialize_file_store(unit, MUD_UPDATE_FILE, NULL_STRING,
    MAXIMUM_TAPE_MUDUPD_HEADER_SIZE, MAXIMUM_TAPE_MUDUPD_HEADER_SIZE,
    block_count, file_sequence, ok);
  if ok
  then
    begin (* no errors possible *)
      mud_change.read_mudupd_header(buffer.mudupd_info);
      sys_io.page_checksum(PAGE_SIZE, buffer.mudupd_info, buffer.checksum);
      tape_io.write_mud_change(unit, buffer, ok)
    end;
  if ok
  then
    begin
      block_count := block_count + 1;
      complete_file_store (unit, MUD_UPDATE_FILE,
	MAXIMUM_TAPE_MUDUPD_HEADER_SIZE, MAXIMUM_TAPE_MUDUPD_HEADER_SIZE,
	file_sequence, block_count, done, ok);
      if ok and not done
      then
        begin
          tape_io.write_mud_change(unit, buffer, ok);
          if ok
          then write_eof_label(unit, file_sequence, block_count, ok)
        end
    end
end (* store_mud_change_file *);



(**************************  archive_commands  **************************)
(*									*)
(*			    store_operlog_file				*)
(*									*)
(************************************************************************)

procedure store_operlog_file(
      unit		: tape_unit_index;
  var file_sequence	: integer;
  var ok		: boolean);

var
  page_no	: oper_log_archive_page_index;
  tape_buffer	: tape_page_block;
  tape_index	: tape_page_block_index;
  tape_blk_done,
  done		: boolean;
  block_count	: integer;

begin
  initialize_file_store(unit, OPERLOG_FILE, NULL_STRING, TAPE_PAGE_BLOCK_SIZE,
    TAPE_PAGE_BLOCKING_FACTOR, block_count, file_sequence, ok);
  done := not ok; page_no := 0;
  while user_terminal.sendable and not done do
    begin
      tape_blk_done := FALSE; tape_index:= 0;
      repeat
        oplog.read_operlog_page(page_no, tape_buffer[tape_index].page_data,
	  ok);
	if not ok
	then
	  begin
	    report_disk_error(page_no);
	    clear_page(tape_buffer[tape_index].page_data)
	  end;
	tape_buffer[tape_index].page_offset := page_no;
	if tape_index = TAPE_PAGE_BLOCK_LIMIT
	then tape_blk_done := TRUE
	else tape_index := tape_index + 1;
	if page_no = OPER_LOG_HEADER_PAGE
	then done := TRUE
	else page_no := page_no + 1;
	user_terminal.check_circuit
      until not user_terminal.sendable or tape_blk_done or done;
      if user_terminal.sendable and ok
      then store_blocked_page(unit, OPERLOG_FILE, file_sequence, tape_buffer,
	block_count, done, ok)
    end (* while *);
  if ok
  then complete_file_store (unit, OPERLOG_FILE, TAPE_PAGE_BLOCK_SIZE,
    TAPE_PAGE_BLOCKING_FACTOR, file_sequence, block_count, done, ok)
  else done := TRUE;
  if ok and not done
  then
    begin
      store_blocked_page(unit, OPERLOG_FILE, file_sequence, tape_buffer,
	block_count, done, ok);
      if ok
      then write_eof_label(unit, file_sequence, block_count, ok)
    end
end (* store_operlog_file *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if check_time_status



(**************************  archive_commands  **************************)
(*									*)
(*			    check_date_of_tape				*)
(*									*)
(*      If Tymnet, read the header of the tape on which the backup is	*)
(*	to be performed; if it is a Netval header, and the date is	*)
(*	within 24 hours, warn the operator and have him confirm that	*)
(*	he should continue.						*)
(*									*)
(************************************************************************)

procedure check_date_of_tape(
      unit		: tape_unit_index;
  var write_on_tape	: boolean);

var
  ok : boolean;
  label	: ansii_tape_label;

begin
  write_on_tape := TRUE;
  read_volume_label(unit, FALSE, label, ok);
  if ok
  then
    begin (* label was read successfully *)
      if tape_is_todays_date
      then
        begin (* tape is less than a day old *)
	  format.start_message('this Netval tape \');
          format.ansii_tape_label_chars(label, LABEL_ID_OFFSET, LABEL_ID_SIZE);
	  format.string(' was created on \ ');
	  display_label_date(label);
	  write_on_tape := keyword_scan.input_answer(CONTINUE_MESSAGE)
	end (* tape is less than a day old *)
    end (* label was read successfully *);
  rewind_tape(FALSE, unit, ok)
end (* check_date_of_tape *);
$endif check_time_status
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(**************************  archive_commands  **************************)
(*									*)
(*			      store_command				*)
(*									*)
(************************************************************************)

procedure store_command(
      unit	: tape_unit_index);

var
  cud_locked,
  store_begun,
  ok : boolean;
  file : archive_file_index;
  file_sequence : integer (* sequence of file on tape *);
  user : username_string;

begin
  init_label_value;
  store_begun := FALSE; file_sequence := 0;
  rewind_tape(TRUE, unit, ok);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if check_time_status   check_date_of_tape(unit, ok);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  if ok
  then write_volume_label(vol_label, unit, ok);
  for file := FIRST_ARCHIVE_FILE to LAST_ARCHIVE_FILE do
    if ok and user_terminal.sendable
    then
      case file of
        CONFIGURATION_FILE:
	  begin
	    login_pool.validator_name(validator, user);
	    format.start_message('store begun\');
	    format.by_validator(user);
	    oper_messages.report_message(ARCHIVE_OPLOG_MSG);
	    store_configuration(unit, file_sequence, ok);
	    store_begun := TRUE
	  end (* CONFIGURATION_FILE *);
	CUD_FILE:
	  begin
	    get_cud_locked(cud_locked);
	    if cud_locked
	    then store_cud(unit, file_sequence, ok)
	  end (* CUD_FILE *);
	CUD_PARAMETER_FILE:
	  begin
	    store_parameter(unit, file_sequence, ok);
	    cud_access.unlock_cud_file;
	    cud_locked := FALSE
	  end (* CUD_PARAMETER_FILE *);
	CLASS_GROUP_FILE: (* null - do not store *);
	OPERLOG_FILE: store_operlog_file(unit, file_sequence, ok);
	NODE_HOST_FILE:
	  begin
	    store_list_header(unit, file_sequence, ok);
	    if ok
	    then store_lists(unit, TRUE, file_hostlists_message,
	      file_sequence, ok);
	    if ok
	    then store_lists(unit, FALSE, file_nodelists_message,
	      file_sequence, ok);
	    if ok
	    then store_global_accesses(unit, TRUE, file_classes_message,
	      FIRST_CLASS, MAXIMUM_CLASS, file_sequence, ok);
	    if ok
	    then store_global_accesses(unit, FALSE, file_groups_message,
	      FIRST_GROUP, MAXIMUM_GROUP, file_sequence, ok)
	  end (* NODE_HOST_FILE *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if INCLUDE_DNIC
	DNIC_FILE: store_dnic_file(unit, file_sequence, ok);
$endif INCLUDE_DNIC
$if ganpass_file_exists
	PASSTABLE_FILE: store_passtable_file(unit, file_sequence, ok);
$endif ganpass_file_exists
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if change_by_whom
" added store_schedtable_file by SHSUE at 30-Jun-87 13:57:40"
$endif change_by_whom
	SCHEDTABLE_FILE: store_schedtable_file(unit, file_sequence, ok);
	MUD_UPDATE_FILE: store_mud_change_file(unit, file_sequence, ok)
      end (* case *);
  if cud_locked
  then cud_access.unlock_cud_file;
  if store_begun
  then
    if ok and user_terminal.sendable
    then
      begin
        tape_io.position_drive(unit, TAPE_WRITE_EOF) (* 2nd eof at end *);
	format.start_message('store completed\');
	oper_messages.report_message(ARCHIVE_OPLOG_MSG)
      end (* ok and user_terminal.sendable *)
    else
      begin (* not ok or not user_terminal.sendable *)
        format.start_message('STORE FAILED: aborted\');
	oper_messages.report_message(ARCHIVE_OPLOG_MSG)
      end (* not ok or not user_terminal.sendable *);
  rewind_tape(TRUE, unit, ok)
end (* store_command *);
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(**************************  archive_commands  **************************)
(*									*)
(*			     archive_command				*)
(*									*)
(*	The ARCHIVE command causes this routine to be called from	*)
(*	COMMAND_LEVEL; the validator's context has the ARCHIVE_CLASS	*)
(*	added to it, COMMAND_LOOP is called to retrieve archive		*)
(*	commands which are executed here.				*)
(*									*)
(************************************************************************)

procedure entry ARCHIVE_COMMAND(
  var scanned	: scanned_command);

var
  ok : boolean;
  param : tape_param;
  info : tape_descriptor;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code
  already_assigned : boolean;
  displayed : boolean;
  status : tape_assign_status;
  old_unit : tape_unit_index;
$if include_dump   block_no : cud_block_index;
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  unit : tape_unit_index;
  unit_implicitly_assigned : boolean;
  label : ansii_tape_label;

begin
  command_read.add_class(ARCHIVE_CLASS);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code  tape_util.display_status(displayed);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  repeat
    unit_implicitly_assigned := FALSE;
    command_read.get_command(scanned);
    if user_terminal.available
    then
      begin
        user_terminal.write_newline;
	case scanned.command of

(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code
          ARCHIVE_ASSIGN:
	    begin
	      get_command_unit(already_assigned, old_unit, unit, scanned);
	      argument_scan.extra_argument_check(scanned);
	      if scanned.status = CMD_OK
	      then
                begin
                  tape_pool.assign_unit(unit, validator, status, param);
                  if status = ASSIGN_OK
                  then
                    begin
                      user_terminal.write_quoted_text_line(
                        'tape unit assigned\ ');
                      report_attach_status(unit, param)
                    end
                  else report_assign_failure(unit, status, param)
                end
	    end (* ARCHIVE_ASSIGN *);

$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	  ARCHIVE_ATTACH:
	    begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code
	      get_command_unit(already_assigned, old_unit, unit, scanned);
$endif disk_maintenance_code
$if disk_maintenance_code 	      get_command_unit(unit, scanned);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	      argument_scan.extra_argument_check(scanned);
	      if scanned.status = CMD_OK
	      then
                begin
                  tape_pool.attach_unit(unit, ok, param);
                  if ok
                  then user_terminal.write_quoted_text_line(
                    'tape unit attached\ ');
                  report_attach_status(unit, param)
                end
	    end (* ARCHIVE_ATTACH *);

(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code
	  ARCHIVE_DEASSIGN:
	    begin
	      argument_scan.extra_argument_check(scanned);
	      if scanned.status = CMD_OK
	      then
                begin
                  tape_pool.validator_tape(validator, ok, unit);
                  if ok
                  then tape_util.deassign_tape(unit, TRUE)
                  else user_terminal.write_quoted_text_line(NOT_ASSIGNED)
                end
	    end (* ARCHIVE_DEASSIGN *);

$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	  ARCHIVE_DETACH:
	    begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code
	      get_command_unit(already_assigned, old_unit, unit, scanned);
$endif disk_maintenance_code
$if disk_maintenance_code 	      get_command_unit(unit, scanned);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	      argument_scan.extra_argument_check(scanned);
	      if scanned.status = CMD_OK
	      then
                begin
                  tape_pool.tape_information(unit, info);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code
                  if info.assigned and (info.assigned_by <> validator)
                  then report_already_assigned(unit)
                  else
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
                    if info.attach_state = UNCOMMITTED
                    then user_terminal.write_quoted_text_line(
                      'unit is not attached\ ')
                    else
                      begin
                        tape_pool.detach_unit(unit, validator, param);
                        if (param.status = COMPLETE) or
                          (param.status = INTERVENTION)
                        then user_terminal.write_quoted_text_line(
                          'tape unit detached\ ')
                        else tape_util.display_tape_error(unit, param)
                      end
                end
	    end (* ARCHIVE_DETACH *);

	  ARCHIVE_DISPLAY:
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code
	    case scanned.subcommand of

	      ARCHIVE_DISPLAY_ID_KEYWORD:
	        begin
		  get_unit(unit, scanned, unit_implicitly_assigned);
$endif disk_maintenance_code
$if disk_maintenance_code
		begin
		  get_command_unit(unit, scanned);
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
		  argument_scan.extra_argument_check(scanned);
		  if scanned.status = CMD_OK
		  then
		    begin
		      rewind_tape(TRUE, unit, ok);
		      if ok
		      then display_volume_label(unit, label, ok);
		      rewind_tape(TRUE, unit, ok)
		    end
		end (* DISPLAY_ID_COMMAND *);

(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code
	      ARCHIVE_DISPLAY_STATUS_KEYWORD:
	        begin
	          argument_scan.extra_argument_check(scanned);
	          if scanned.status = CMD_OK
	          then
		    begin
		       tape_util.display_status(displayed);
		       if not displayed
		       then user_terminal.write_quoted_text_line(
		         'no tape units are ATTACHED or ASSIGNED\ ')
		    end
		end (* ARCHIVE_DISPLAY_STATUS_KEYWORD *)

	    end (* case *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if include_dump

	  ARCHIVE_DUMP:
	    begin
	      if argument_scan.check_keyword(ARCHIVE_DUMP_FROM_KEYWORD,
	        scanned)
	      then keyword_util.get_numeric_keyword_value(
	        ARCHIVE_DUMP_FROM_KEYWORD, 10, 0, CUD_BLOCK_LIMIT,
		scanned, block_no)
	      else block_no := 0;
	      if scanned.status = CMD_OK
	      then
		begin
    	          get_unit(unit, scanned, unit_implicitly_assigned);
	          argument_scan.extra_argument_check(scanned);
		  if scanned.status = CMD_OK
		  then dump_command(unit, block_no)
		end
	    end (* ARCHIVE_COMMAND *);
$endif include_dump
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$endif disk_maintenance_code
$if disk_maintenance_code
$ifnone CONVERT_TO_43        ARCHIVE_RESTORE: restore_command(scanned, unit);
$if CONVERT_TO_43	ARCHIVE_REFORMAT: reformat_command(scanned, unit);

$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	  ARCHIVE_RETURN:
	    begin
	      argument_scan.extra_argument_check(scanned);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code
	      if scanned.status = CMD_OK
	      then tape_util.display_status(displayed)
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	    end (* ARCHIVE_RETURN *);

	  ARCHIVE_REWIND:
	    begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code
	      get_unit(unit, scanned, unit_implicitly_assigned);
$endif disk_maintenance_code
$if disk_maintenance_code
              get_command_unit(unit, scanned);
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	      argument_scan.extra_argument_check(scanned);
	      if scanned.status = CMD_OK
	      then
	        begin
		  rewind_tape(TRUE, unit, ok);
		  if ok
		  then user_terminal.write_quoted_text_line('tape rewound\ ')
		end
	    end (* ARCHIVE_REWIND *)

(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code
;

	  ARCHIVE_STORE:
	    begin
	      get_unit(unit, scanned, unit_implicitly_assigned);
	      argument_scan.extra_argument_check(scanned);
	      if scanned.status = CMD_OK
	      then store_command(unit)
	    end (* ARCHIVE_STORE *)

$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	end (* case *);
	scan_error.display_command_error(scanned);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code
	if unit_implicitly_assigned
	then tape_util.deassign_tape(unit, FALSE)
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      end
  until not user_terminal.available or (scanned.command = ARCHIVE_RETURN);
  command_read.remove_class(ARCHIVE_CLASS)
end (* archive_command *);



(************************************************************************)
(************************************************************************)

begin (* initial statement *)
  init param_file(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone disk_maintenance_code     statistics, file_system, oper_messages,
$if disk_maintenance_code
    user_terminal, dsksys,
$if logical_volumes    lv_dir,
$endif disk_maintenance_code
    sys_io, format)
$ifnone disk_maintenance_code
    , config_utility(dsksys, sys_io)
$endif disk_maintenance_code
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
end (* archive_commands *);
!
(************************************************************************)
(*									*)
(*	PSWCMD.NTV							*)
(*									*)
(*			    password_command_utility			*)
(*									*)
(*	This Class handles the change password command.			*)
(*									*)
(*	The following identifiers must be defined externally:		*)
(*	  password_read							*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	03Oct88 - jrn							*)
(*		- change allow_user_password_expire to			*)
(*		  password_expiration_by_user and check out code	*)
(*		- use password_expiration_date_in_cud for code that is	*)
(*		  required for global or user password expiration	*)
(*		- add code for PREVENT_DUPLICATE_PASSWORDS		*)
(*	09Sep87 - neh							*)
(*		- merge with version 5.00, change to mud_entry_updater	*)
(*	19Feb87 - rsb							*)
(*		- if force_password_change enabled add a parameter to	*)
(*		  calls to UPDATE_CUD_PASSWORD which specifies the 	*)
(*		  password change date is to be updated.		*)
(*		  This parameter is passed in to CHANGE_USER_PASSWORD	*)
(*		  as a boolean.  If true, exit_time is also		*)
(*		  passed to UPDATE_CUD_PASSWORD.			*)
(*	27Jan87 - rsb							*)
(*		- add EXIT_TIME and USE_EXIT_TIME to global variables.	*) 
(*		  CMDLVL will initialize them as 0 and FALSE.		*)
(*		  PSWLVL will pass a real exit time after initalizing	*)
(*		  USE_EXIT_TIME as TRUE.				*)
(*		- also pass SUCCESS to GET_NEW_CIPHER and only change 	*)
(*		  the user's password if success returns as TRUE.	*)
(*	17Jan85 - jrn							*)
(*	19Jun84 - jrn							*)
(*	      - add cud_entry_utility, and call print_cud_entry_message	*)
(*		after changing the password				*)
(*		Original -- jrn						*)
(*									*)
(************************************************************************)



type PASSWORD_COMMAND_UTILITY = class(
	mutil		: misc_utility;
	user_terminal	: circuit_handler;
	format		: internal_to_string;
	password_read	: password_reader;
$if BEFORE_SUP_V43 	cud_updater	: cud_entry_updater;
$ifnone BEFORE_SUP_V43 	cud_updater	: mud_entry_updater;
	cud_utility	: cud_updater_utility;
	mud_change	: mud_change_handler);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if prevent_duplicate_passwords



(*********************  password_command_utility  ***********************)
(*									*)
(*			    check_password_age				*)
(*									*)
(************************************************************************)

procedure entry CHECK_PASSWORD_AGE(
      changing_own_name	: boolean;
      cud_entry		: small_cud_entry;
  var password_aged_enuf: boolean);

var
  min_time_period : integer;

begin
  password_aged_enuf := TRUE;
  min_time_period := mud_change.minimum_password_change_time_in_seconds;
  if (REALTIME - cud_entry.password_date) < min_time_period
  then
    begin
      if changing_own_name
      then
        begin
	  format.start_line_message('password cannot \ ');
	  password_aged_enuf := FALSE
	end
      else format.start_line_message('WARNING: password should not \');
      format.string('be changed until \');
      format.time(cud_entry.password_date + min_time_period);
      format.write_line(user_terminal)
    end (* tell user about password period *)
end (* check_password_age *);
$endif prevent_duplicate_passwords
$if password_expiration_by_user



(*********************  password_command_utility  ***********************)
(*									*)
(*		do_display_password_expiration_date			*)
(*									*)
(************************************************************************)

procedure do_display_password_expiration_date(
      expiration_date	: integer);

begin
  if expiration_date <> 0
  then
    begin
      format.start_line_message(PASSWORD_EXPIRES_MESSAGE);
      format.time(expiration_date);
      format.write_line(user_terminal)
    end (* validity_period <> 0 *)
end (* do_display_password_expiration_date *);



(*********************  password_command_utility  ***********************)
(*									*)
(*		    display_password_expiration_date			*)
(*									*)
(************************************************************************)

procedure entry DISPLAY_PASSWORD_EXPIRATION_DATE(
      expiration_date	: integer);

begin
  do_display_password_expiration_date(expiration_date)
end (* display_password_expiration_date *);



(*********************  password_command_utility  ***********************)
(*									*)
(*		do_update_password_expiration_date			*)
(*									*)
(*	This procedure is not called unless the password expiraton	*)
(*	date needs to be updated (or cleared).				*)
(*									*)
(************************************************************************)

procedure do_update_password_expiration_date(
      validity_period	: integer;
  var cud_entry		: small_cud_entry);

begin
  if cud_updater.last_status <> CUD_ENTRY_OK
  then cud_utility.print_cud_entry_message
  else
    begin
      cud_updater.modify_cud_password(cud_entry) (* set up for change *);
      if cud_updater.last_status <> CUD_ENTRY_OK
      then cud_utility.print_cud_entry_error
      else
        begin
	  cud_updater.update_password_expiration_date(validity_period,
	    cud_entry);
	  cud_utility.print_cud_entry_message;
	  if cud_updater.last_status = CUD_ENTRY_OK
	  then do_display_password_expiration_date(cud_entry.expire_date)
	end (* cud_updater.last_status = CUD_ENTRY_OK *)
    end (* cud_updater.last_status = CUD_ENTRY_OK *)
end (* do_update_password_expiration_date *);



(*********************  password_command_utility  ***********************)
(*									*)
(*		    update_password_expiration_date			*)
(*									*)
(*	This procedure is not called unless the password expiraton	*)
(*	date needs to be udpated (or cleared).				*)
(*									*)
(************************************************************************)

procedure entry UPDATE_PASSWORD_EXPIRATION_DATE(
      validity_period	: integer;
  var cud_entry		: small_cud_entry);

begin
  do_update_password_expiration_date(validity_period, cud_entry)
end (* update_password_expiration_date *);
$endif password_expiration_by_user



(*********************  password_command_utility  ***********************)
(*									*)
(*			  change_user_password				*)
(*									*)
(*	Called from both PASSWORD_COMMAND_LEVEL and COMMAND_LEVEL.	*)
(*									*)
(************************************************************************)

procedure entry CHANGE_USER_PASSWORD(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if global_password_only_login
      use_exit_time	: boolean;
      exit_time		: integer;
$endif global_password_only_login
$if prevent_duplicate_passwords       changing_own_name	: boolean;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  var cud_entry		: small_cud_entry);

var
  new_cipher 	: integer;
  success    	: boolean;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if prevent_duplicate_passwords   previous_cipher_to_use : integer;
$if password_expiration_by_user   validity_period : integer;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if prevent_duplicate_passwords
  if changing_own_name
  then previous_cipher_to_use := cud_entry.previous_cipher
  else previous_cipher_to_use := NO_PREVIOUS_CIPHER;
$endif prevent_duplicate_passwords
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  password_read.get_new_cipher(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone name_legal_password     cud_entry.name,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    cud_entry.cipher, 
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if prevent_duplicate_passwords     previous_cipher_to_use,
$if global_password_only_login     exit_time, use_exit_time,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    new_cipher, success);
				
      if not success or not user_terminal.sendable
      then cud_updater.abort_cud_change
      else
        begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if prevent_duplicate_passwords
	if not changing_own_name and (new_cipher = cud_entry.previous_cipher)
	then
	  begin
	    user_terminal.write_line_and_quoted_text('Warning: \');
	    user_terminal.write_quoted_text_line(PREVIOUS_PASSWORD_MESSAGE)
	  end (* not changing own name and (new cipher = previous) *);
$endif prevent_duplicate_passwords
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	  cud_updater.update_cud_password(new_cipher
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if force_password_change 	    , TRUE
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	    );
$if password_expiration_by_user
	  if not (EXEMPT_FROM_PASSWORD_EXPIRATION in cud_entry.nud_options)
	  then
	    begin
	      if NON_STANDARD_PASSWORD_EXPIRATION in cud_entry.nud_options
	      then validity_period :=
		cud_entry.expire_date - cud_entry.password_date
	      else validity_period :=
	        mud_change.standard_password_validity_in_seconds;
	      do_update_password_expiration_date(validity_period, cud_entry)
	    end (* user is not exempt *)
	  else
$endif password_expiration_by_user
	  cud_utility.print_cud_entry_message
	end
end (* change_user_password *);



(************************************************************************)
(************************************************************************)

begin (* initial statement *)
end (* password_command_utility *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if allow_password_only
!
(************************************************************************)
(*									*)
(*	PSWLVL.NTV							*)
(*									*)
(*			    password_command_level			*)
(*									*)
(*	This process is the main process that accepts password-		*)
(*	only validator logins and proccesses a change password.		*)
(*	There is one for each possible password-only validator		*)
(*	in the system.							*)
(*									*)
(*	The following identifiers must be defined externally:		*)
(*	  validator_index, terminal_unit_index,	command_table,		*)
(*	  operator_log,							*)
(*	  argument_scanner, scanned_command,				*)
(*	  terminal_input_scanner, operator_messages, ioresult		*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	05Jan89 - neh                                                   *)
(*		- add limit check to prompt username to avoid CR loop   *)
(*	03Oct88 - jrn							*)
(*		- change allow_user_password_expire to			*)
(*		  password_expiration_by_user and check out code	*)
(*	02Oct88 - jrn							*)
(*		- use ganpass_file_exists				*)
(*	27Apr88 - neh							*)
(*	      - change global password to prompt "enter current		*)
(*		password"						*)
(*	16Aug87 - neh							*)
(*	      - remove calendar						*)
	(*		merge 4.00 and 5.00 neh			*)
(*	27Jan87 - rsb							*)
(*		- change timeout to be an absolute time period, that is	*)
(*		  the timer is no longer reset to zero on a bad try	*)
(*		- add code to fetch a GLOBAL_PASSWORD_ONLY_LOGIN user's *)
(*		  real username and password before entering		*)
(*		  password change code					*)
(*		- pass EXIT_TIME and USE_EXIT_TIME to			*)
(*		  password_command.CHANGE_USER_PASSWORD			*)
(*	09Jan87 - neh							*)
(*	      - add VALIDATOR_OPLOG_MSG to calls to report_login and	*)
(*		report_logout						*)
(*	08Jan86 - jrn							*)
(*	      - remove UPDATE_TYMCOM_LUDS				*)
(*	04Oct84 neg							*)
(*	      - change cud_entry_utility to cud_updater_utility		*)
(*	15Jun84 jrn							*)
(*	      - added cud_utility to init of password_command		*)
(*	      - removed oper_messages from initialization of		*)
(*		cud_block_updater					*)
(*	Version 2.02	April 14, 1984 - jrn				*)
(*	      - remove "? " from question prompts			*)
(*		Original -- jrn						*)
(*									*)
(************************************************************************)


type PASSWORD_COMMAND_LEVEL = process(
	validator	: validator_index;
	login_pool	: login_distributer;
	commands	: command_table;
	statistics	: statistics_gatherer;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if global_password_only_login
        file_system		: file_system_manager;
$endif global_password_only_login
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	oplog	 	: operator_log;
	mud_change	: mud_change_handler;
	cud_access	: cud_access_controller;
	param_manager	: cud_parameter_controller;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifall (overflow_cud_entries, BEFORE_SUP_V43)
	overflow_controller	: cud_overflow_controller;
$endif (overflow_cud_entries, BEFORE_SUP_V43)
$if ganpass_file_exists
	pasmon		: passtable_handler;
$endif ganpass_file_exists
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	name_access	: cud_name_controller);


(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if global_password_only_login
const
  GPO_ATTEMPT_LIMIT = GPO_ATTEMPT_MAX - 1;

type
  gpo_attempt_index = 0..GPO_ATTEMPT_LIMIT;
$endif global_password_only_login
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)


const
  NOT_AUTHORIZED_MESSAGE = 'you are not authorized for this procedure\';


var
$ifnot BEFORE_SUP_V43   list_utility		: node_host_list_utility;
  mutil			: misc_utility;
  profile		: validator_profile;
  format		: internal_to_string;
  user_terminal		: circuit_handler;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if global_password_only_login
  freeword_utility	: freeword_response_utility;
  scan_error		: command_error_message;
$endif global_password_only_login
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  cud			: disk_system;
  block_utility		: cud_block_utility;
  block_updater		: cud_block_updater;
  cud_entry_util	: cud_entry_utility;
$if BEFORE_SUP_V43   cud_updater		: cud_entry_updater;
$ifnone BEFORE_SUP_V43   cud_updater		: mud_entry_updater;
  cud_utility		: cud_updater_utility;
  password_read		: password_reader;
  password_command	: password_command_utility;
  argument_scan		: argument_scanner;
  keyword_util		: keyword_utility;
  input_scanner		: terminal_input_scanner;
  keyword_scan		: keyword_scanner;
  oper_messages		: operator_messages;

  exit_time		: integer;




(************************  password_command_level  **********************)
(*									*)
(*				 login					*)
(*									*)
(************************************************************************)

procedure login;

var
  terminal_unit : terminal_unit_index;

begin
  login_pool.wait_for_login(profile, terminal_unit);
  user_terminal.use_circuit(terminal_unit, TERMINAL,
    [COMPLETE, BREAK_KEY, ORANGE_BALL]);
  user_terminal.set_alternate_break(ESCAPE);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnot global_password_only_login
  exit_time := REALTIME + (TERMINAL_TIMEOUT * 60);
  user_terminal.set_timeout(TERMINAL_TIMEOUT * 60);
$endif not global_password_only_login
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if global_password_only_login
  user_terminal.set_timeout(GPO_TIMEOUT);
  exit_time := REALTIME + GPO_TIMEOUT;
  if profile.level <> GPO_VALIDATOR
  then
    begin
$endif global_password_only_login
  format.start;
  format.welcome_message(NETVAL_WELCOME_MESSAGE);
  format.write_line(user_terminal);
  oper_messages.report_login(VALIDATOR_OPLOG_MSG, profile)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if global_password_only_login
    end
  else
    begin
      user_terminal.write_newline;
      user_terminal.write_line_and_quoted_text_line(
        'NETVAL password change procedure\ ');
      user_terminal.write_newline
    end
$endif global_password_only_login
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
end (* login *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if global_password_only_login



(************************  password_command_level  **********************)
(*									*)
(*			   get_gpo_user_password			*)
(*									*)
(*	Validator is logging in under the GPO name; confirm that the	*)
(*	validator knows the username's current.				*)
(*									*)
(************************************************************************)

procedure get_gpo_user_password(
      cipher		: integer;
  var gpo_attempt_count	: integer;
  var got_password	: boolean);

begin
  got_password := FALSE;
  while not got_password and (gpo_attempt_count < GPO_ATTEMPT_MAX) and
    user_terminal.sendable do
    begin
      user_terminal.write_quoted_text('enter current \ ');
      if password_read.ciphered_password = cipher
      then got_password := TRUE
      else
        begin
	  gpo_attempt_count := gpo_attempt_count + 1;
	  if (gpo_attempt_count < GPO_ATTEMPT_MAX)
	  then user_terminal.write_quoted_text('re-\')
	end (* ciphered_password <> cipher *)
    end (* while *);
end (* get_gpo_user_password *);



(************************  password_command_level  **********************)
(*									*)
(*			      get_gpo_user				*)
(*									*)
(*	Validator is logging in under the GPO name; get his name and	*)
(*	check his password;  Set got_gpo_user to TRUE only if:		*)
(*		- validator enters a valid name in the CUD		*)
(*		- validator knows the password for the name		*)
(*		- user does not have no self password change set	*)
(*		- user has a password					*)
(*		- user has GPO access					*)
(*	Do not give away any validation information about the		*)
(*	username entered.						*)
(*									*)
(************************************************************************)

procedure get_gpo_user(
  var cud_entry		: small_cud_entry;
  var gpo_attempt_count	: integer;
  var got_gpo_user	: boolean;
  var found		: boolean);

begin
  found := FALSE;
  freeword_utility.prompt_username_count('username: \ ',
    GPO_ATTEMPT_LIMIT, gpo_attempt_count, cud_entry.name);
  if user_terminal.sendable and (cud_entry.name.size > 0)
  then
    begin (* fetch username entry from cud *)
      cud_updater.read_small_cud_entry(cud_entry);
      cud_utility.print_cud_entry_error;
      found := cud_updater.last_status = CUD_ENTRY_OK;
      if found
      then
	if NO_PASSWORD_REQUIRED in cud_entry.options
	then user_terminal.write_quoted_text_line(NOT_AUTHORIZED_MESSAGE)
	else
          begin (* username found in CUD...check user out *)
	    get_gpo_user_password(cud_entry.cipher, gpo_attempt_count,
	      got_gpo_user);
	    if got_gpo_user
	    then
$if no_self_password_change
$if BEFORE_SUP_V43 	      if NSP_CHANGE in cud_entry.options
$ifnone BEFORE_SUP_V43 	      if NSP_CHANGE in cud_entry.nud_options
	      then
	        begin
		  got_gpo_user := FALSE;
		  user_terminal.write_quoted_text_line(NOT_AUTHORIZED_MESSAGE)
		end (* NSP_CHANGE in ... *)
	      else
$endif no_self_password_change
	    begin (* user looks ok, is he valid for GPO ? *)
	      pasmon.fetch_gpogan(cud_entry.gan, got_gpo_user);
	      if not got_gpo_user
	      then user_terminal.write_quoted_text_line(NOT_AUTHORIZED_MESSAGE)
	    end (* user looks ok, is he valid for GPO ? *)
        end (* username found in CUD...check user out *)
    end (* fetch username entry from cud *)
end (* get_gpo_user *);



(************************  password_command_level  **********************)
(*									*)
(*			    do_gpo_check				*)
(*									*)
(*	Validator is logging in under the GPO name...check on him.	*)
(*									*)
(************************************************************************)

procedure do_gpo_check(
  var cud_entry		: small_cud_entry;
  var got_gpo_user	: boolean);

var
  new_timeout : integer;
  gpo_attempt_count : integer;
  found : boolean;

begin
  got_gpo_user := FALSE; gpo_attempt_count := 0;
  repeat
    get_gpo_user(cud_entry, gpo_attempt_count, got_gpo_user, found);
    if not got_gpo_user
    then
      begin (* user cannot GPO, give him another chance if he deserves it *)
        gpo_attempt_count := gpo_attempt_count + 1;
	new_timeout := exit_time - REALTIME; 
	user_terminal.set_timeout(new_timeout)
      end (* user cannot GPO, give him another chance if he deserves it *)
  until not user_terminal.sendable or found or
    (gpo_attempt_count >= GPO_ATTEMPT_MAX) or (new_timeout < 1);
  if got_gpo_user
  then oper_messages.report_gpo_login(VALIDATOR_OPLOG_MSG, cud_entry.name,
    profile)
  else
    begin (* report GPO entry failure *)
      format.start_message('password change failure\');
      format.write_line(user_terminal);
      format.start_message('unauthorized GPO login attempt by \ ');
      format.username(cud_entry.name);
      oper_messages.report_message(CUD_OPLOG_MSG)
    end (* report GPO entry failure *)
end (* do_gpo_check *);
$endif global_password_only_login
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(************************  password_command_level  **********************)
(*									*)
(*			  do_change_password_check			*)
(*									*)
(*	Validator is logging in; Set user_can_change_password		*)
(*	to TRUE only if:						*)
(*		- user does not have no self password change set	*)
(*		- user has a password					*)
(*									*)
(************************************************************************)

procedure do_change_password_check(
  var cud_entry		: small_cud_entry;
  var user_can_change_password	: boolean);

begin
  user_can_change_password := FALSE;
  cud_entry.name := profile.name;
  cud_updater.read_small_cud_entry(cud_entry);
  cud_utility.print_cud_entry_error;
  if cud_updater.last_status = CUD_ENTRY_OK
  then
    begin
      if (NO_PASSWORD_REQUIRED in cud_entry.options)
$if no_self_password_change
$if BEFORE_SUP_V43 	or (NSP_CHANGE in cud_entry.options)
$ifnone BEFORE_SUP_V43 	or (NSP_CHANGE in cud_entry.nud_options)
$endif no_self_password_change
      then user_terminal.write_quoted_text_line(NOT_AUTHORIZED_MESSAGE)
      else user_can_change_password := TRUE
    end
end (* do_change_password_check *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if force_password_change



(************************  password_command_level  **********************)
(*									*)
(*			   report_expiration_date			*)
(*									*)
(************************************************************************)

procedure report_expiration_date(
   var cud_entry : small_cud_entry);

var
  found : boolean;
  passlife : integer;
  expire_date : integer;

begin
  found := FALSE; passlife := 0;
  pasmon.fetch_expiredate(cud_entry.gan, cud_entry.password_date,
    expire_date, passlife, found);
$if before_sup_v43   if found and not (FPC_EXEMPT in cud_entry.options)
$ifnone before_sup_v43   if found and not (FPC_EXEMPT in cud_entry.nud_options)
  then
    begin (* display expire_date *)
      format.start_line_message(PASSWORD_EXPIRES_MESSAGE);
      format.date(expire_date);
      format.write_line(user_terminal);
    end (* display expire_date *);
end (* report_expiration_date *);
$endif force_password_change
$if password_expiration_by_user



(************************  password_command_level  **********************)
(*									*)
(*			   report_expiration_date			*)
(*									*)
(************************************************************************)

procedure report_expiration_date(
   var cud_entry : small_cud_entry);

begin
  if cud_entry.expire_date <> 0
  then
    begin (* display expire_date *)
      format.start_line_message(PASSWORD_EXPIRES_MESSAGE);
      format.time(cud_entry.expire_date);
      if cud_entry.expire_date < REALTIME
      then format.string(EXPIRED_MESSAGE);
      format.write_line(user_terminal);
    end (* display expire_date *);
end (* report_expiration_date *);
$endif password_expiration_by_user



(************************  password_command_level  **********************)
(*									*)
(*			 process_password_change			*)
(*									*)
(*	This is the main processing routine.  				*)
(*									*)
(************************************************************************)

procedure process_password_change;

var
  cud_entry : small_cud_entry;
  user_can_change_password : boolean;

begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if global_password_only_login
  if profile.level = GPO_VALIDATOR
  then do_gpo_check(cud_entry, user_can_change_password)
  else
$endif global_password_only_login
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  do_change_password_check(cud_entry, user_can_change_password);
  if user_can_change_password
  then
    begin (* user looks ok *)
      cud_updater.modify_cud_password(cud_entry);
      cud_utility.print_cud_entry_error;
      if cud_updater.last_status = CUD_ENTRY_OK
      then
        begin (* cud_updater.last_status = CUD_ENTRY_OK *)
          format.start_line_message('password last changed on \');
$if before_sup_v43         format.date(cud_entry.password_date*SECONDS_PER_DAY);
$ifnone before_sup_v43           format.time(cud_entry.password_date);
	  format.write_line(user_terminal);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifany (password_expiration_by_user, force_password_change)
	  report_expiration_date(cud_entry);
$endif (password_expiration_by_user, force_password_change)
$if prevent_duplicate_passwords
	  password_command.check_password_age(TRUE, cud_entry,
	    user_can_change_password);
	  if not user_can_change_password
	  then cud_updater.abort_cud_change
	  else
	    begin (* user_can_change_password *)
$endif prevent_duplicate_passwords
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	  user_terminal.write_newline;
          if not keyword_scan.input_answer(
	    'do you wish to change your password\')
          then cud_updater.abort_cud_change
          else
            begin (* user said no password change *)
	      user_terminal.write_newline;
	      password_command.change_user_password(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if global_password_only_login 		TRUE, exit_time,
$if prevent_duplicate_passwords 		TRUE,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	        cud_entry)
	    end (* user said no password change *)
$if prevent_duplicate_passwords
	    end (* user_can_change_password *)
$endif prevent_duplicate_passwords
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
        end (* cud_updater.last_status = CUD_ENTRY_OK *)
    end (* user looks ok *)
end (* process_password_change *);



(************************************************************************)
(************************************************************************)

begin (* initial statement *)
  init mutil, profile(validator), user_terminal(mutil), format,
    argument_scan(mutil),
    keyword_util(profile, format, user_terminal, commands, argument_scan),
    input_scanner(profile, mutil, format, user_terminal, commands,
      argument_scan, keyword_util),
    keyword_scan(user_terminal, input_scanner),
    oper_messages(oplog, format),
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if global_password_only_login
    freeword_utility(user_terminal, format, argument_scan, input_scanner,
      scan_error),
$endif global_password_only_login
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    cud(statistics),
    block_utility(mutil, oper_messages, format, cud),
    block_updater(mutil, statistics, cud, cud_access, block_utility, format),
    cud_entry_util(mutil, format, oper_messages),
    cud_updater(validator, mutil, format, login_pool, mud_change,
      oper_messages,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifall (overflow_cud_entries, BEFORE_SUP_V43)     overflow_controller,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      cud_entry_util, cud_access, block_updater,
$ifnone BEFORE_SUP_V43      list_utility,
      param_manager, name_access),
    cud_utility(format, cud_updater, user_terminal),
    password_read(mutil, format, user_terminal),
    password_command(mutil, user_terminal, format, password_read,
      cud_updater, cud_utility, mud_change);

  cycle
    login;
    process_password_change;
    user_terminal.wait_for_output;
    user_terminal.clear_circuit;
    login_pool.release_unit(user_terminal.unit);
    oper_messages.report_logout(VALIDATOR_OPLOG_MSG, profile,
      user_terminal.logout_reason)
  end (* cycle *)
end (* password_command_level *);
$endif allow_password_only
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if force_password_change
"$if allow_global_password_expire"
!
(************************************************************************)
(*									*)
(*	PASCHG.NTV							*)
(*									*)
(*			    passchanger					*)
(*									*)
(*	Passchanger changes overage passwords belonging to users in	*)
(*	FPC gans.  A GAN is designated eligible for FPC by a SET_GANPAS	*)
(*	command.  A user can be individually exempted from FPC by having*)
(*	the FPC Exempt control flag set.				*)
(*									*)
(*      The routines are organized as follows:				*)
(*		initialization routines					*)
(*									*)
(*      The following identifiers must be defined externally:		*)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	19Oct88 - jrn							*)
(*		- comment out allow_global_password_expire code; it may	*)
(*		  be tested and used someday				*)
(*	02-22-88	neh						*)
(*		- remove tymshare_cud_format flag			*)
(*	        - add BEFORE_SUP_V43					*)
(*	02-10-87	rsb						*)
(*		Original						*)
(*									*)
(************************************************************************)

type PASSCHANGER = process(
	login_pool	: login_distributer;
  	statistics	: statistics_gatherer;
  	oplog		: operator_log;
  	mud_change	: mud_change_handler;
  	cud_access	: cud_access_controller;
  	param_manager	: cud_parameter_controller;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifall (overflow_cud_entries, before_sup_v43)
	overflow_controller	: cud_overflow_controller;
$endif (overflow_cud_entries, before_sup_v43)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  	pasmon		: passtable_handler;
  	name_access	: cud_name_controller);


var
$ifnot BEFORE_SUP_V43  list_utility             : node_host_list_utility;
  validator		: validator_index;
  mutil	 		: misc_utility;
  format		: internal_to_string;
  user_terminal	 	: circuit_handler;
  oper_msgs		: operator_messages;
  cud			: disk_system;
  block_utility 	: cud_block_utility;
  block_updater		: cud_block_updater;
  cud_entry_util	: cud_entry_utility;
$if BEFORE_SUP_V43  cud_updater   	: cud_entry_updater;
$ifnot BEFORE_SUP_V43  cud_updater	: mud_entry_updater;
  zap_count		: integer; 
  cud_utility		: cud_updater_utility;


(************************** passchanger *********************************)
(*									*)
(*  Name:	zap_passwords						*)
(*									*)
(*  Purpose:	invalidate all overage passwords in the cud		*)
(*									*)
(************************************************************************)

procedure zap_passwords;

var
  now_time	: print_time;
  now_date	: print_time;
  buffer	: cud_disk_block;
  block		: cud_block_index;
$ifnot BEFORE_SUP_V43
  cud_entry	: mud_user_entry;
  nud_entry	: nud_user_entry;
$endif BEFORE_SUP_V43
$if BEFORE_SUP_V43  cud_entry	: cud_user_entry;
  expiredate	: integer;
  passlife	: integer;
  done		: boolean;
  found		: boolean;

begin (* zap_passwords *)
  cud_updater.start_cud_list(0, buffer);
  if cud_updater.last_status <> CUD_ENTRY_OK
  then
    begin (* report cud entry error *) 
      format.start;
      format.cud_entry_status(cud_updater.last_status);
      oper_msgs.report_message(CUD_OPLOG_MSG)
    end (* report cud entry error *);

  repeat
    done := FALSE;
    cud_updater.next_cud_list(buffer, block, cud_entry
$ifnot BEFORE_SUP_V43      , nud_entry
);
    if (cud_updater.last_status = CUD_ENTRY_OK) or
     			 (cud_updater.last_status = CUD_ENTRY_IN_WRONG_BLOCK)
    then
      begin (* got another user entry to work with *)
	if cud_updater.last_status = CUD_ENTRY_IN_WRONG_BLOCK
	then
	  begin (* report found an entry in the wrong block *)
	    format.start_message('passchanger found \ ');
	    format.username(cud_entry.name);
	    format.string(' to be in the wrong cud block\');
            oper_msgs.report_message(CUD_OPLOG_MSG)
	  end (* report found an entry in the wrong block *);

	cud_updater.modify_cud_entry(cud_entry
$ifnot BEFORE_SUP_V43            , nud_entry
);

	if cud_updater.last_status = CUD_ENTRY_LOCKED
	then
	  begin (* can't access this user entry because it's already locked *)
	    done := TRUE;
	    format.start_message('passchanger locked out of cud entry for:\ ');
	    format.username(cud_entry.name);
            oper_msgs.report_message(CUD_OPLOG_MSG)
	  end (* can't access this user entry because it's already locked *);

$if BEFORE_SUP_V43	if no_password_required in cud_entry.options
$ifnot BEFORE_SUP_V43      if NO_PASSWORD_REQUIRED in cud_entry.mud_options
	then done := TRUE;

$if BEFORE_SUP_V43	if FPC_EXEMPT in cud_entry.options
$ifnot BEFORE_SUP_V43      if FPC_EXEMPT in nud_entry.nud_options
	then done := TRUE;

	if MINIMUM_PASSWORD_SIZE = 0
	then
	  with cud_entry do
	    begin
$if BEFORE_SUP_V43    	  if password
$ifnot BEFORE_SUP_V43            if password.cipher
	        = 0
	      then done := TRUE;

$if BEFORE_SUP_V43	    if password
$ifnot BEFORE_SUP_V43          if password.cipher
	        = FPC_PASSWORD_CIPHER 
	      then done := TRUE;
          
$if BEFORE_SUP_V43	    if password
$ifnot BEFORE_SUP_V43          if password.cipher
	        = GFD_ONLY_PASSWORD
	      then done := TRUE
	    end (* with cud_entry *);

	if not done
	then
	  begin (* user got through first screening *)
	    pasmon.fetch_expiredate(
$if BEFORE_SUP_V43
	      cud_entry.gan, cud_entry.password_change_date,
$endif BEFORE_SUP_V43
$ifnot BEFORE_SUP_V43
	      nud_entry.gan, nud_entry.password_change_date,
$endif BEFORE_SUP_V43
	      expiredate, passlife, found);
	    if found then
	      begin
"$ifnot ALLOW_GLOBAL_PASSWORD_EXPIRE"
	        if REALTIME >= expiredate then
		  begin
	       	    cud_updater.update_cud_password(FPC_PASSWORD_CIPHER,FALSE);
"$endif ALLOW_GLOBAL_PASSWORD_EXPIRE"
$ifnot BEFORE_SUP_V43
"$if ALLOW_GLOBAL_PASSWORD_EXPIRE"
(* if allow global expire, check if user has right type *)
(* or is expire date is correct for passlife set for gan *)
	
"		if (cud_entry.entry_type <> EXPIRE_DATE_IRC_ENTRY) or
		  (cud_entry.password.expire_date <> expiredate)
		  begin
	       	    cud_updater.update_passexpire(expiredate);"
"$endif ALLOW_GLOBAL_PASSWORD_EXPIRE"
$endif BEFORE_SUP_V43
		    zap_count := zap_count + 1
		  end
	      end (* found *)

	  end (* user got through first screening *);
	cud_updater.abort_cud_change
      end (* got another user entry to work with *)
    else
      if cud_updater.last_status <> CUD_ENTRY_NOT_FOUND
      then
        begin
	  format.start_message('passchanger found \ ');
          format.string('block \ ');
          format.number(block, 10);
	  format.colon_space;
	  format.cud_entry_status(cud_updater.last_status);
          oper_msgs.report_message(CUD_OPLOG_MSG)
        end (* cud_updater.last_status <> CUD_ENTRY_NOT_FOUND *)
  until (cud_updater.last_status = CUD_ENTRY_NOT_FOUND)

end (* zap_passwords *);

(************************************************************************)
(************************************************************************)

begin (* initial statement *)
  init mutil, 
  format, 
  oper_msgs(oplog, format), 
    cud(statistics),
    block_utility(mutil, 
	oper_msgs, 
		format, 
			cud),
    block_updater(mutil, 
	statistics, 
		cud, 
			cud_access, 
				block_utility, 
					format),
    cud_entry_util(mutil, 
	format, 
		oper_msgs),
    cud_updater(validator, mutil, format, login_pool, mud_change,
      oper_msgs,
(*      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-  *)
$ifall (overflow_cud_entries, BEFORE_SUP_V43)     overflow_controller,
(*      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-  *)
      cud_entry_util, cud_access, block_updater,
$ifnone BEFORE_SUP_V43      list_utility,
      param_manager, name_access),

    cud_utility(format, cud_updater, user_terminal);

  cycle
    mud_change.delay_passchanger;
    format.start_message('starting Passchanger\ ');
    oper_msgs.report_message(PASSCHANGER_MSG);
    zap_count := 0;
    zap_passwords;
"$ifnot ALLOW_GLOBAL_PASSWORD_EXPIRE"
    format.start_message('Passchanger invalidated \ ');
"$endif ALLOW_GLOBAL_PASSWORD_EXPIRE"
"$if ALLOW_GLOBAL_PASSWORD_EXPIRE"
"    format.start_message('Passchanger set expiration for \');"
"$endif ALLOW_GLOBAL_PASSWORD_EXPIRE"
    format.number(zap_count, 10);
"$ifnot ALLOW_GLOBAL_PASSWORD_EXPIRE"
    format.string(' passwords\ ');
"$endif ALLOW_GLOBAL_PASSWORD_EXPIRE"
"$if ALLOW_GLOBAL_PASSWORD_EXPIRE"
"    format.string(' users\ ');"
"$endif ALLOW_GLOBAL_PASSWORD_EXPIRE"
    oper_msgs.report_message(PASSCHANGER_MSG);
    format.start_message('Passchanger completed\');
    oper_msgs.report_message(PASSCHANGER_MSG);
    mud_change.passchanger_complete
  end (* cycle *)
end (* initial_statement *);
$endif force_password_change
"$endif allow_global_password_expire"
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
(************************************************************************)
(*									*)
(*	CMDLVL.NTV							*)
(*									*)
(*				command_level				*)
(*									*)
(*	This process is the main process that accepts validator		*)
(*	logins and interprets commands for all validators EXCEPT	*)
(*	password_only validators.  There is one for each possible	*)
(*	licensed validator in the system.				*)
(*									*)
(*	The routines are organized as follows:				*)
(*	  login routine							*)
(*	  Error reporting routines					*)
(*		(report_list_status, report_named_list_value_error)	*)
(*	  Prompt routines						*)
(*		(output_prompt, output_new_prompt)			*)
(*	  Input routines						*)
(*		(get_numbers_list, get_supervisor, get_legal_supervisor,*)
(*		 get_cud_block, get_and_reserve_name, get_username,	*)
(*		 get_and_access_name, get_gan_number,			*)
(*		 get_origin_list, get_origin,				*)
(*		 get_destination, get_access_profile,			*)
(*		 get_options, get_list_description, entries_correct)	*)
(*	  Output Routines						*)
(*	 	(write_named_list, write_list_name_and_descr,		*)
(*		 write_global_access_header, write_global_access, 	*)
(*		 write_single_global_access,				*)
(*		 write_undefined, write_user_entry, write_cud_entry)	*)
(*	  sort_list Routine						*)
(*	  Miscellaneous Programmer routines (CUD/MUD buffer handling)	*)
(*	  CHANGE Commands						*)
(*		(ACCESS, CONTROL, CUD, DISTRICT, DNIC, GAN, INHIBIT,	*)
(*		IRC, GLOBAL (Class or Group),				*)
(*		LIST (Node or Host), NAME, PASSWORD, TIME, UUN,		*)
(*		VALIDITY)						*)
(*	  COMPARE Command						*)
(*	  CONSISTENCY Command						*)
(*	  DELETE Commands						*)
(*		(ACCESS, LIST (Node or Host), USER)			*)
(*	  DISPLAY Commands						*)
(*		(GLOBAL (Class or Group), SELECT, DIRECTORY, LIST (Node	*)
(*		 or Host), UPDATES, USER, CUD, MUD, GANPASS, GPOGAN,	*)
(*		 SCHEDULE)						*)
(*	  GET Command							*)
(*	  NEW Commands (ACCESS, HOSTLIST, NODELIST, USER)		*)
(*	  READ Commands (CUD, MUD, TABLE)				*)
(*	  SCHEDULE Command (CONSISTENCY, PASSCHANGER, UUN_MERGE)	*)
(*	  SEND Command							*)
(*	  SET Commands (SCHEDULE, SUPERVISOR)				*)
(*	  STOP Command							*)
(*	  WRITE Commands (CUD, MUD)					*)
(*	  QUIT Command							*)
(*	  UNLOCK Command						*)
(*									*)
(*	The following identifiers must be defined externally:		*)
(*	  validator_index, terminal_unit_index, command_table,		*)
(*	  operator_log, filter_utility, command_level_utility           *)
(*	  argument_scanner, scanned_command,				*)
(*	  terminal_input_scanner, operator_messages,			*)
(*	  needle_record, ioresult, pseudo_sup_index, real_sup_index	*)
(*									*)
(************************************************************************)
(*									*)
(*			     Revision Record				*)
(*									*)
(*	03Oct88 - jrn							*)
(*		- add new code for password_expiration_by_user		*)
(*		- change allow_user_password_expire to			*)
(*		  password_expiration_by_user and check out code	*)
(*		- use password_expiration_date_in_cud for code that is	*)
(*		  required for global or user password expiration	*)
(*		- add code for prevent_duplicate_passwords		*)
(*		- use ganpass_file_exists				*)
(*		- add code for restrict_users_by_time			*)
(*		- add code for allow_logon_inhibit			*)
(*	18May88 - neh version 5.02					*)
(*	      - add flag for REQUEST_GLOBAL_EXCEPTION to get class	*)
(*		and group exception in each APE or globally.		*)
(*	16May88 - neh version 5.02					*)
(*	      - add position output when inputing APE			*)
(*	      - add prompt for priority stop				*)
(*	24Nov87 - neh							*)
(*	      - add DELETE DNIC, DISPLAY DNIC, NEW DNIC, REPLACE DNIC	*)
(*		READ DNIC TABLE and SEND DNIC TABLE			*)
(*	10Sep87 - neh version 5.00					*)
(*	      - merge with version 4.00 command level			*)
(*	31Aug87 - neh							*)
(*	      - add get_access_options, destination name		*)
(*	      - change get_options to check username, destination name  *)
(*		types							*)
(*	26May87 - neh							*)
(*	      - sort all NODE and HOST lists.				*)
(*	      - add conditional for BEFORE_SUP_V43 and code for		*)
(*		version 43 format					*)
(*	27Jan87 - rsb							*)
(*		- add initializing and passing of USE_EXIT_TIME and	*)
(*		  EXIT_TIME to init of password_command			*)
(*		- add PASMON to list of monitors passed to cmdlvl	*)
(*		- add init of mud_change_handler to init of cmd_utility	*)
(*		- add init of pasmon to init of cmd_utility		*)
(*	09Jan87 - neh							*)
(*	      - add mutil to init filter_utility			*)
(*	01Dec86 - rsb							*)
(*		- add SET_GANPASS and SET_GPOGAN to PRIMARY_SET		*)
(*		- Move SCHEDULE_CONSISTENCY function from		*)
(*		  PRIMARY_SET to PRIMARY_SCHEDULE.  Also add		*)
(*		  conditionally compiled code to SCHEDULE_PASSCHANGER	*)
(*		  and SCHEDULE_UUN_MERGE				*)
(*		- Also change CONSISTENCY_START/STOP_TIME MESSAGE	*)
(*		  into START/STOP_TIME_MESSAGE for broader applicability*)
(*		- Change name of CLEAR to CLEAR_CONSISTENCY and		*)
(*		  add CLEAR_GANPASS and CLEAR_GPOGAN and CLEAR_UUNMERGE *)
(*		  and CLEAR_PASSCHANGER					*)
(*		- Add Expiredate to the list of DISPLAY_DIRECTORY	*)
(*		  parameter possibilities				*)
(*		- Add PRIMARY_DISPLAY_GANPASS_KEYWORD and 		*)
(*		  PRIMARY_DISPLAY_GPOGAN_KEYWORD and			*)
(*		  PRIMARY_DISPLAY_SCHEDULE_KEYWORD			*)	
(*	09Sep86 - neh							*) 
(*	      - Add DISPLAY_FILTER, FILTER and MESSAGE commands.	*)
(*            - Add filter_utility variable.                            *)
(*            - Remove operator_log from init command_loop parameters.  *)
(*	28Aug86 - jrn							*)
(*	      - mark all Tymshare "old" password code with:		*)
		(*******...  old password code  ...*******)
(*	14Aug86 - jrn							*)
(*	      - add DELETE CLASS, DELETE GROUP for clearing classes	*)
(*		and groups after a configuration change			*)
(*	04Aug86 - rsb							*)
(*		- in RUN_CONSISTENCY and STOP_COMMAND use 	        *)
(*		  un2_activity instead of checking for start_date = 0	*)
(*	08Jul86 - jrn							*)
(*	      - add REMARK command					*)
(*	      - add SPECIAL flag (CLEAN and OLDPASS commands)		*)
(*	13May86 - neh							*)
(*	      - Move all procedures used to display the CUD to		*)
(*		command_level_utility including the following		*)
(*		  clear_criteria in login				*)
(*		  Input Routines					*)
(*		    (get_radix_criteria_values)				*)
(*		  Output Routines					*)
(*    	 	    (check_line_length_and_write,			*)
(*		     format_origins,					*)
(* 		     write_access_profile)		 		*)
(*	  	  Miscellaneous Programmer routines (CUD/MUD handling)	*)
(*		  Command Routines					*)
(*		    (CHANGE CUD, DISPLAY_SELECT, DISPLAY_BLOCK,		*)
(*		     DISPLAY_DIRECTORY, READ CUD/MUD, SELECT,		*)
(*		     WRITE CUD/MUD)					*)
(*	15Apr86 - jrn							*)
(*	      - change DISPLAY NEXT to DISPLAY PARAMETERS		*)
(*	14Apr86 - rsb							*)
(*		- PRIMARY_READ_TABLE_KEYWORD,				*)
(*		  DISPLAY_TABLE,					*)
(*		  READ_NETVAL_TABLE,					*)
(*		  READ_SUPERVISOR_TABLE - modify to allow display of a  *)
(*		  single class or group.				*)
(*	10Mar86 - jrn							*)
(*	      - redo reuse_uuns to maintain a bit map for 18 bit UUNS	*)
(*		and change the add back scheme to be a dated list	*)
(*	      - add the displaying of available add back slots to	*)
(*		the DISPLAY NEXT command				*)
(*	03Mar86 - rsb							*)
(*		- declare user_terminal.set_crt_terminal		*)
(*	18Feb86 - rsb							*)
(*		- PRIMARY_READ_MUD_KEYWORD				*)
(*		  PRIMARY_READ_TABLE_KEYWORD				*)
(*		  PRIMARY_WRITE:  change call to get_supervisor		*)
(*		  into a call to get_LEGAL_supervisor			*)
(*	11feb86 - rsb							*)
(*		- Get_supervisor: change MAXIMUM_EXPECTED_SUPERVISORS	*)
(*		  to MAXIMUM_REAL_SUPERVISOR 				*)
(*	04Feb86	- rsb							*)
(*		- add crash_utility for Set_Supervisor command		*)
(*	03Feb86	- rsb							*)
(*		- set_schedule						*)
(*		  scan.primary_clear:					*)
(*		  - remove "sucess" variable because of 		*)
(*		  creation of mud_change.write_header_to_disc		*)
(*	27Jan86 - jrn							*)
(*	      - change NULL_PROMPT to NULL_STRING			*)
(*	23Jan86	- rsb							*)
(*		- Set_Supervisor: remove check for disc_write_error	*)
(*		  because write_muf_header will not return if error	*)
(*	      - change the UP and SHUT commands to HOST UP and HOST	*)
(*		SHUT, and add the HOST STATUS command			*)
(*	      - use internal_to_string BY_VALIDATOR procedure		*)
(*	14Jan85 -  jrn							*)
(*	      - add username to operator log report_logout message	*)
(*	      - change DISPLAY LVOL to DISPLAY VOLUME			*)
(*	08Jan86 - jrn							*)
(*	      - remove UPDATE_TYMCOM_LUDS				*)
(*	03Jan86 - rsb							*)
(*		- every "sup : supervisor_index" becomes		*)
(*		        "real_sup : real_supervisor_index;"		*)
(*		- every "sup" becomes "real_sup"			*)
(*	20Dec85 - jrn							*)
(*	      - add the FROM SUPERVISOR keywords to the WRITE CUD	*)
(*		command							*)
(*	13Nov84 - jrn							*)
(*	      - use cud_entry_udpater CHECK_FOR_NAME_IN_CUD procedure	*)
(*		instead of the old VALID_CUD_NAME function		*)
(*	01Nov85 - jrn							*)
(*	      - add the REPEAT keyword to the DISPLAY UPDATES command	*)
(*	      - add the SHUT and UP commands				*)
(*	      - send a message to the Supervisor err log whenever a	*)
(*		Supervisor is turned ON or OFF				*)
(*	29Oct85 - jrn							*)
(*	      - change SEND procedure to save status in current_status	*)
(*		so that multiple changes to the monitor do not have to	*)
(*		be made							*)
(*	      - change NEW USER AS command, so that it blocks account	*)
(*		supervisor users from validating new users with class 0	*)
(*		or group 0 if CLASS_0_GROUP_0_ASSIGNABLE is FALSE	*)
(*	07Oct85 - jrn							*)
(*	      - add the VALIDATE_X25_NAMES code				*)
(*	06Aug85 - jrn							*)
(*	      - make programmer enter password on the WRITE commands	*)
(*	12Dec84 - Version 3.00 - neb - pgl - jrn			*)
(*	      - use CUBS for Tymshare CUD format password dates		*)
(*	      - change call to new_cud_entry and add conditional	*)
(*		assembly parameter reuse_uuns				*)
(*	      - add conditional assembly parameter LOGICAL_VOLUMES	*)
(*	      - procedure write_cud_entry handles 			*)
(*		GFD_ONLY_PASSWORD_DATE, if TYMSHARE_CUD_FORMAT		*)
(*		is enabled						*)
(*	      - use engine checksum for disk				*)
(*	      - handle sorted flag better for list modification		*)
(*	      - allow username, class and listname to be entered on	*)
(*		command line whenever possible				*)
(*	      - add descriptions to lists				*)
(*	      - handle new format node-host file			*)
(*	25Mar85 - jrn - version 2.04					*)
(*	      - add allow_hosts_on_no_pasword flag			*)
(*	11Mar85 - jrn - version 2.03					*)
(*	      - fixed a bug that caused the wrong block number to be	*)
(*		displayed to the validator when an error is		*)
(*		detected in the CUD					*)
(*	      - change the format of error message in DISPLAY DIRECTORY	*)
(*		when a checksum or CUD format error occurs		*)
(*	      - fix leading comma in write_table_classes		*)
(*	      - allow READ CUD to retain the data in its buffer if it	*)
(*		encounters a checksum error on the disk			*)
(*	      - do not allow the CHANGE DISTRICT command if		*)
(*		INCLUDE_DISTRICT is FALSE (CMDLVL.NTV)			*)
(*	01Aug84 - pgl							*)
(*	      - fix leading comma in write_table_classes and 		*)
(*		write_table_groups					*)
(*	      - fix lack of comma before carriage return in		*)
(*		check_line_length_and_write				*)
(*	25Jul84 - jrn							*)
(*	      - fix bug in breaking out of change access command	*)
(*	28Jun84 Version 2.02	jrn					*)
(*	      - add PROGRAMMER_PASSWORD_CHANGEABLE			*)
(*	      - added restart capability to consistency			*)
(*	      - added cud_utility to password_command			*)
(*	      - removed oper_messages from initialization of		*)
(*		cud_block_updater					*)
(*	      - added option to assign UUNs if UUNSassignable is TRUE,	*)
(*		including adding CHANGE UUN command			*)
(*	      - added licenses, AUDITOR_LICENSE, OPERATOR_LICENSE	*)
(*		and DISPLAY_CUD_LICENSE					*)
(*	      - remove "? " from question prompts			*)
(*	      - change display_gan_or_all to continue on a CUD error	*)
(*	01May84	Version 2.01 - jrn					*)
(*	      - fix bug in NEW USER AS if old user has			*)
(*		  NO_PASSWORD_REQUIRED set				*)
(*	      - remove duplicate code in CHANGE NAME			*)
(*	      - fix NEW ACCESS to check for maximum number of entries	*)
(*	      - fix formatting of nodes and hosts in origin		*)
(*	      - fix bug in not allowing new user to have a null pass-	*)
(*		word							*)
(*	      - fix bug in displaying in-place origin nodes		*)
(*	      - when setting the home bit as a pre-determine value,	*)
(*		report that fact to the validator			*)
(*	      - change the format of DISPLAY UPDATES to type historical	*)
(*		consistency information before current information	*)
(*	      - fixed bug on calling SORT in the NEW NODELIST command	*)
(*	      - report if consistency already running on the CONSISTENCY*)
(*		command							*)
(*	      - on STOP command, if consistency is manual, report that	*)
(*		fact to the validator (manual consistencies cannot be	*)
(*		stopped)						*)
(*	      - added NO_CHANGE keyword to CONSISTENCY command		*)
(*	12Jun84 Version 2.02  pgl					*)
(*	      - deleted DISPLAY_ALL and DISPLAY_GAN commands		*)
(*		and display_gan_or_all and get_gan_number procedures	*)
(*	      - added DISPLAY_SELECT, DISPLAY_DIRECTORY and SELECT	*)
(*		commands						*)
(*	      - added permanent variable, criteria 			*)
(*	      - added FIELDS and DESIGNATED_FIELDS			*)
(*	      - added constants relating to output lengths		*)
(*	      - added NO_PAGINATION and NO_DISTRICT_MESSAGE		*)
(*	29Sep83	Original from cmdlvl.bas - jrn				*)
(*									*)
(************************************************************************)


type COMMAND_LEVEL = process(
      validator	 		: validator_index;
      login_pool		: login_distributer;
      tape_pool			: tape_allocater;
      commands			: command_table;
      statistics		: statistics_gatherer;
      file_system		: file_system_manager;
      oplog	 		: operator_log;
      mud_change		: mud_change_handler;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if ganpass_file_exists
      pasmon			: passtable_handler;
$endif ganpass_file_exists
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      cud_access		: cud_access_controller;
      param_manager		: cud_parameter_controller;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifall (overflow_cud_entries, before_sup_v43)
      overflow_controller	: cud_overflow_controller;
$endif (overflow_cud_entries, before_sup_v43)
$if INCLUDE_DNIC      dnic_access		: dnic_file_handler;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      name_access		: cud_name_controller;
      list_access		: node_host_list_access;
      list_allocater		: node_host_list_allocater;
      table_access		: class_group_handler;
      un2_access		: un2_access_manager;
(*	+-+-+-+-+--+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if logical_volumes       lv_status_manager	: lvol_status_manager;
(*	+-+-+-+-+--+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      sysmsg1_access		: sysmsg1_access_manager);


const
  A_HOME_MESSAGE = ' a home\';
  ADD_PROMPT = 'added\';
$ifnone before_sup_v43
  ALLOWING_REGULAR_CALL_AS_DESTINATION =
    'allowing regular call as destination\ ';
  ALLOWING_REGULAR_CALL_AS_USER = 'allowing regular call as user\';
  ASSIGNING_DESTINATION_NAME_OK_MESSAGE =
    'assigning DESTINATION NAME OK option\ ';
  ASSIGNING_NORMAL_CIRCUIT_MESSAGE = 'assigning normal circuit\ ';
  ASSIGNING_USERNAME_OK_MESSAGE = 'assigning USERNAME OK option\ ';
$endif before_sup_v43
  COMMAND_CANCELLED_MESSAGE = 'command cancelled\';
  CONSISTENCY_STOPPED_MESSAGE = 'automatic consistency stopped \ ';
  CONSISTENCY_UNSTOPPABLE_MSG = 'consistency is manual and cannot be stopped\';
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if logical_volumes   COPY_IN_PROGRESS = 'A copy is already in progress\';
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  DELETE_PROMPT = 'deleted\';
  ENTRIES_CORRECT_QUERY = 'all entries correct\';
  EXCEPTION_MESSAGE = '(not) \ ';
  LIST_NOT_FOUND_MESSAGE = 'list not found in \ ';
  LIST_USED_MESSAGE = 'list name is already entered\ ';
  NO_ACCESS_TO_USER = 'you cannot access that username\';
  NO_LEGAL_SUPS_MESSAGE = 'there are no legal supervisors \';
  NO_LISTS_MESSAGE = 'no lists to modify\ ';
$ifnone BEFORE_SUP_V43
  QUERY_APE_FOR_DESTINATION_NAME = 'is profile entry for destination name\';
  QUERY_APE_FOR_USERNAME = 'is profile entry for username\';
  QUERY_ALLOW_DESTINATION_COLLECT_CALL = 'allow collect call as destination\';
  QUERY_ALLOW_DESTINATION_REGULAR_CALL = 'allow regular call as destination\';
  QUERY_ALLOW_USER_COLLECT_CALL = 'allow collect call as user\ ';
  QUERY_ALLOW_USER_REGULAR_CALL = 'allow regular call as user\ ';
$endif BEFORE_SUP_V43
  QUERY_IS_DESTINATION = 'is destination \';
  REPLACE_PROMPT = 'replaced\ ';
$if BEFORE_SUP_V43
  SORT_ALL_QUERY = 'do you want the lists sorted\ ';
  SORT_QUERY = 'do you want the list sorted\';
$endif BEFORE_SUP_V43
  STARS_MESSAGE = ' *** \';
  START_TIME_MESSAGE ='start time: \ ';
  STOP_TIME_MESSAGE = 'stop time: \';

$if password_expiration_by_user
  NO_VALIDITY_PERIOD = -1 (* for NEW USER AS Command *);
$endif password_expiration_by_user


type
  PROMPT_TYPE = (node_prompt, host_prompt, dest_prompt, group_prompt);

  CLASS_GROUP_TABLE_DISPLAY_TYPE = (
	entire_table,
	only_one_class,
	only_one_group);
$ifnone before_sup_v43

  USERNAME_ENTRY_TYPE = (
    USERNAME_TYPE_ONLY, HOSTNAME_TYPE_ONLY, BOTH_USER_AND_HOST_NAME_TYPE);
$endif before_sup_v43
$if INCLUDE_DNIC

  DNIC_TABLE_DISPLAY_TYPE = (
	entire_dnic_table,
	only_one_dnic,
	default_dnic_entry);
$endif INCLUDE_DNIC

var		(* system type declarations *)
  sys_io		: system_handler;
  mutil			: misc_utility;
  calendar		: date_time_converter;
  profile		: validator_profile;
  format		: internal_to_string;
  user_terminal		: circuit_handler;
  oper_messages		: operator_messages;
  aux_io		: circuit_handler;
  crash_util		: crash_utility;

(* command handlers *)
  argument_scan		: argument_scanner;
  keyword_util		: keyword_utility;
  input_scanner		: terminal_input_scanner;
  freeword_utility	: freeword_response_utility;
  keyword_scan		: keyword_scanner;
  scan_error		: command_error_message;
  command_read		: command_loop;

  dsksys		: disk_system;

(* CUD handlers *)
  block_utility		: cud_block_utility;
  block_updater		: cud_block_updater;
  cud_entry_util	: cud_entry_utility;
$if BEFORE_SUP_V43   cud_updater		: cud_entry_updater;
$ifnone BEFORE_SUP_V43   cud_updater		: mud_entry_updater;
  cud_utility		: cud_updater_utility;
  password_read		: password_reader;
  password_command	: password_command_utility;
  un2_util		: un2_utility;
  consistency		: consistency_handler;

(* list handlers (class, group, node and host) *)
  list_io		: node_host_list_io_utility;
  list_utility		: node_host_list_utility;
  sysmsg1_util		: sysmsg1_utility;

(* tape and archive handlers *)
  tape_io		: tape_handler;
  tape_util		: tape_utility;
  archive		: archive_commands;

  filter_util           : filter_utility;
  cmd_utility		: command_level_utility;
(*	+-+-+-+-+--+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
(* logical volume handler *)
$if logical_volumes
  config_utility	: configuration_utility;
  lv_copy		: logical_volume_copy;
  lv_utility		: lvol_utility;
  lv_dialogue		: lvol_dialogue;
$endif logical_volumes
(*	+-+-+-+-+--+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

		(* permanent variables *)

  shut_block		: cud_block_index (* block that is locked *);

  block_is_locked	: boolean;

  scanned		: scanned_command;

!


(***************************  command_level  ****************************)
(*									*)
(*			    	login					*)
(*									*)
(************************************************************************)

procedure login;

var
  terminal_unit : terminal_unit_index;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if changes_to_oper_log   remark : oplog_remark_message;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

begin
  login_pool.wait_for_login(profile, terminal_unit);
  user_terminal.use_circuit(terminal_unit, TERMINAL,
    [COMPLETE, BREAK_KEY, ORANGE_BALL]);
  user_terminal.set_alternate_break(ESCAPE);
  user_terminal.set_crt_terminal;
  if profile.level <> PROGRAMMER_VALIDATOR
  then user_terminal.set_timeout(TERMINAL_TIMEOUT * 60);
  format.start;
  format.welcome_message(NETVAL_WELCOME_MESSAGE);
  format.write_line(user_terminal);
  oper_messages.report_login(VALIDATOR_OPLOG_MSG, profile);

  filter_util.clear_filter;
  cmd_utility.clear_criteria_and_buffer(ALL_CRITERIA);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if changes_to_oper_log
  remark.size := 0;
  cud_updater.set_remark(remark)
$endif changes_to_oper_log
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
end (* login *);
!
"
	Error Reporting Routines
"



(***************************  command_level  ****************************)
(*									*)
(*			   report_list_status      			*)
(*									*)
(************************************************************************)

procedure report_list_status;

begin
  format.start_and_newline;
  format.named_list_status(list_utility.last_status);
  format.write_line(user_terminal)
end (* report_list_status *);



(**************************  command_level  *****************************)
(*									*)
(*		      report_named_list_value_error			*)
(*									*)
(*	If IN_USE is TRUE, error is that list is already used, else it	*)
(*	is not found							*)
(*									*)
(************************************************************************)

procedure report_named_list_value_error(
      in_use	: boolean;
      host_flag	: boolean;
      number	: integer);

begin
  if host_flag
  then
    begin
      format.start_message(HOST_MESSAGE);
      format.character(ASCII_SPACE);
      format.number(number, 10);
    end (* host_flag *)
  else
    begin
      format.start_message(NODE_MESSAGE);
      format.character(ASCII_SPACE);
      format.number(number, 8)
    end (* not host_flag *);
  if in_use
  then format.string(' is already in list\')
  else format.string(' not found in list\ ');
  format.write_line(user_terminal)
end (* report_named_list_value_error *);
!
"
	Prompt Routines
"



(**************************  command_level  *****************************)
(*									*)
(*			output_node_or_host_prompt			*)
(*									*)
(************************************************************************)

procedure output_node_or_host_prompt(
      host_flag		: boolean (* TRUE if "host", else "node" *);
      list_prompt	: boolean (* TRUE if prompting for a list *));

begin
  if host_flag
  then format.string(HOST_MESSAGE)
  else format.string(NODE_MESSAGE);
  if list_prompt
  then format.string(LIST_MESSAGE)
end (* output_node_or_host_prompt *);



(**************************  command_level  *****************************)
(*									*)
(*			     output_prompt				*)
(*									*)
(************************************************************************)

procedure output_prompt(
      host_flag		: boolean (* TRUE if changing hostlists *);
      list_prompt	: boolean (* TRUE if prompting for a list *);
      op_msg		: quoted_text);

begin
  format.start_and_newline;
  output_node_or_host_prompt(host_flag, list_prompt);
  format.string(' to be \');
  format.string(op_msg);
  format.colon_space;
  format.write_block(user_terminal)
end (* output_prompt *);



(**************************  command_level  *****************************)
(*									*)
(*			   output_new_prompt				*)
(*									*)
(************************************************************************)

procedure output_new_prompt(
      host_flag		: boolean (* TRUE if changing hostlists *);
      list_prompt	: boolean (* TRUE if prompting for a list *));

begin
  format.start_message('new \ ');
  output_node_or_host_prompt(host_flag, list_prompt);
  format.colon_space;
  format.write_block(user_terminal)
end (* output_new_prompt *);
!
"
	Input Routines
"



(****************************  command_level  ***************************)
(*									*)
(*			     get_numbers_list				*)
(*									*)
(*	This routine inputs a list of numbers into an array to be used	*)
(*	for various purposes.						*)
(*									*)
(************************************************************************)

procedure get_numbers_list(
      exception		: boolean;
      prompt		: prompt_type;
      max_entries	: general_number_list_size;
      radix		: integer;
      min_value		: integer;
      max_value		: integer;
  var numbers		: general_number_list);

begin
  format.start_line_message('enter list of \ ');
  if exception
  then format.string('exception \ ');
  case prompt of
    DEST_PROMPT:	format.string(DEST_MESSAGE);
    HOST_PROMPT:	format.string(HOST_MESSAGE);
    NODE_PROMPT:	format.string(NODE_MESSAGE);
    GROUP_PROMPT:	format.string('group\')
  end (* case *);
  format.string('s: \');
  format.write_block(user_terminal);
  freeword_utility.prompt_number_list(max_entries, radix, min_value,
    max_value, numbers)
end (* get_numbers_list *);



(**************************  command_level  *****************************)
(*									*)
(*			    get_supervisor 				*)
(*									*)
(************************************************************************)

procedure get_supervisor(
      keyword	: command_keyword_index;
  var real_sup  : real_supervisor_index);

var
  temp : integer;

begin
  keyword_util.get_numeric_keyword_value(keyword, 10,
    FIRST_SUPERVISOR + PRINT_SUPERVISOR_OFFSET,
    MAXIMUM_REAL_SUPERVISOR + PRINT_SUPERVISOR_OFFSET, scanned, temp);
  if scanned.status = CMD_OK
  then real_sup := temp - PRINT_SUPERVISOR_OFFSET
end (* get_supervisor *);



(**************************  command_level  *****************************)
(*									*)
(*			 get_legal_supervisor 				*)
(*									*)
(************************************************************************)

procedure get_legal_supervisor(
      keyword  : command_keyword_index;
  var real_sup : real_supervisor_index);

begin
  get_supervisor(keyword, real_sup);
  if user_terminal.sendable and (scanned.status = CMD_OK)
  then
    if not mud_change.legal_supervisor(real_sup)
    then
      begin
	user_terminal.write_quoted_text_line('Supervisor is not legal\');
	scanned.status := RUN_ERROR
    end
end (* get_legal_supervisor *);



(**************************  command_level  *****************************)
(*									*)
(*			   get_cud_block 				*)
(*									*)
(************************************************************************)

procedure get_cud_block(
      keyword		: command_keyword_index;
  var block_number	: cud_block_index);

var
  temp : integer;

begin
  keyword_util.get_numeric_keyword_value(keyword, 10, 0, CUD_BLOCK_LIMIT,
    scanned, temp);
  if scanned.status = CMD_OK
  then block_number := temp
end (* get_cud_block *);



(****************************  command_level  ***************************)
(*									*)
(*			       reserve_name				*)
(*									*)
(************************************************************************)

function reserve_name(
      name	: username_string) : boolean;

begin
  reserve_name := cud_updater.reserve_name(name);
  if cud_updater.last_status <> CUD_ENTRY_NOT_FOUND
  then cud_utility.print_cud_entry_error
end (* reserve_name *);



(****************************  command_level  ***************************)
(*									*)
(*			    get_and_reserve_name			*)
(*									*)
(************************************************************************)

procedure get_and_reserve_name(
      name_prompt	: quoted_text;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if validate_x25_names
      this_is_x25_name	: boolean;
  var link_host		: integer;
$endif validate_x25_names
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  var name		: username_string;
  var success		: boolean);

(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if validate_x25_names
var
  prefix_ok : boolean;
  buffer_ptr : format_buffer_text_index;
$endif validate_x25_names
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

begin
  success := FALSE;
  repeat
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if validate_x25_names
    if this_is_x25_name
    then
      begin
        prefix_ok := FALSE;
        repeat
	  freeword_utility.prompt_username('prefix: \ ', name);
	  if user_terminal.sendable
	  then
	    if name.size <= MAX_X25_PREFIX_SIZE
	    then prefix_ok := TRUE
	    else
	      begin (* prefix too long, say so and ask again *)
	        format.start_message('prefix may be a maximum of \');
		format.number(MAX_X25_PREFIX_SIZE, 10);
		format.string(' characters, reenter\ ');
		format.write_line(user_terminal)
	      end (* prefix too long, say so and ask again *)
	until not user_terminal.sendable or prefix_ok;
	if user_terminal.sendable
	then freeword_utility.prompt_link_host(scanned, link_host);
	if user_terminal.sendable
	then
	  begin (* append link_host to name, zero filling host number *)
	    format.start (* get host in ASCII *);
	    format.format_number(link_host, 10, -MAX_X25_HOST_PLACES);
	    for buffer_ptr := 0 to MAX_X25_HOST_PLACES - 1 do
	      name.text[name.size + buffer_ptr] := (* save host in username *)
	        format.buffer.text[buffer_ptr];
	    name.size := name.size + MAX_X25_HOST_PLACES
	  end (* append link_host to name, zero filling host number *)
      end
    else
$endif validate_x25_names
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    freeword_utility.prompt_username(name_prompt, name);
    if user_terminal.sendable
    then success := reserve_name(name)
  until success or not user_terminal.sendable
end (* get_and_reserve_name *);



(****************************  command_level  ***************************)
(*									*)
(*			       get_username				*)
(*									*)
(*	If there is a freeword username, return it, otherwise, prompt	*)
(*	for a username.  Success is TRUE if no <break> has been entered	*)
(*	and there are no extraneous arguemnts left on the line.		*)
(*									*)
(************************************************************************)

procedure get_username(
  var username	: username_string;
  var success	: boolean);

begin
  freeword_utility.get_username(0, scanned, username);
  argument_scan.extra_argument_check(scanned);
  success := user_terminal.sendable and (scanned.status = CMD_OK)
end (* get_username *);



(****************************  command_level  ***************************)
(*									*)
(*			    modify_user_entry				*)
(*									*)
(************************************************************************)

procedure modify_user_entry(
$if BEFORE_SUP_V43   var cud_entry		: cud_user_entry);
$ifnone BEFORE_SUP_V43
  var mud_entry		: mud_user_entry;
  var nud_entry		: nud_user_entry);
$endif BEFORE_SUP_V43

begin
  cud_updater.modify_cud_entry(
$if BEFORE_SUP_V43   cud_entry);
$ifnone BEFORE_SUP_V43   mud_entry, nud_entry);
  cud_utility.print_cud_entry_error
end (* modify_user_entry *);



(**************************  command_level  *****************************)
(*									*)
(*			 read_user_entry	    			*)
(*									*)
(************************************************************************)

procedure read_user_entry(
$if BEFORE_SUP_V43    var cud_entry	: cud_user_entry);
$ifnone BEFORE_SUP_V43
   var mud_entry	: mud_user_entry;
   var nud_entry	: nud_user_entry);
$endif BEFORE_SUP_V43

begin
  cud_updater.read_cud_entry(
$if BEFORE_SUP_V43   cud_entry);
$ifnone BEFORE_SUP_V43   mud_entry, nud_entry);
  cud_utility.print_cud_entry_error
end (* read_user_entry *);


(****************************  command_level  ***************************)
(*									*)
(*			    get_and_access_name				*)
(*									*)
(************************************************************************)

procedure get_and_access_name(
      modify_access	: boolean (* TRUE if name is to be changed *);
$if BEFORE_SUP_V43   var cud_entry		: cud_user_entry;
$ifnone BEFORE_SUP_V43
  var mud_entry		: mud_user_entry;
  var nud_entry		: nud_user_entry;
$endif BEFORE_SUP_V43
  var success		: boolean);

var
  check_programmer_name : username_string;
  first_time,
  needs_newline,
  name_accessable : boolean;

begin
  check_programmer_name.size := PROGRAMMER_NAME_SIZE;
  check_programmer_name.text := PROGRAMMER_NAME;
  first_time := TRUE; needs_newline := scanned.freeword_count = 0;
  repeat
    name_accessable := TRUE;
$if BEFORE_SUP_V43   get_username(cud_entry.name, success);
$ifnone BEFORE_SUP_V43   get_username(mud_entry.name, success);
    if success
    then
      begin
        if not modify_access
$if BEFORE_SUP_V43   then read_user_entry(cud_entry)
$ifnone BEFORE_SUP_V43   then read_user_entry(mud_entry, nud_entry)
	else
	  if not PROGRAMMER_ENTRY_CHANGEABLE and mutil.username_match(
$if BEFORE_SUP_V43   cud_entry.name, check_programmer_name) and
$ifnone BEFORE_SUP_V43   mud_entry.name, check_programmer_name) and
	    (profile.level <> PROGRAMMER_VALIDATOR)
	  then name_accessable := FALSE
	  else modify_user_entry(
$if BEFORE_SUP_V43	    cud_entry);
$ifnone BEFORE_SUP_V43		mud_entry, nud_entry);
	if name_accessable
	then
	if cud_updater.last_status <> CUD_ENTRY_OK
	  then success := FALSE
	  else
	    if not profile.access_to_gan(
$if BEFORE_SUP_V43   cud_entry.gan, modify_access)
$ifnone BEFORE_SUP_V43   nud_entry.gan, modify_access)
	    then
	      begin
	        name_accessable := FALSE;
		cud_updater.abort_cud_change
	      end (* no access to gan *);
	if not name_accessable
	then
	  begin
	    success := FALSE;
	    user_terminal.write_quoted_text_line(NO_ACCESS_TO_USER)
	  end (* not name_accessable *)
      end (* success *);
    if not success
    then
      begin
        scanned.freeword_count := 0;
	first_time := FALSE
      end (* not success *)
  until not user_terminal.sendable or success;
  if first_time and needs_newline
  then user_terminal.write_newline
end (* get_and_access_name *);



(****************************  command_level  ***************************)
(*									*)
(*			      get_origin_list				*)
(*									*)
(************************************************************************)

procedure get_origin_list(
      host_flag		: boolean;
  var access_entry	: access_entry_description);

var
  add_value : boolean;
  numbers : general_number_list;
  numbers_index : general_number_list_index;
  copy_index,
  origin_index : in_place_origin_index;

begin
  if host_flag
  then get_numbers_list(access_entry.exception, HOST_PROMPT,
    mutil.minimum((MAXIMUM_IN_PLACE_ORIGIN - access_entry.origin.size),
     MAXIMUM_GENERAL_NUMBER_LIST_SIZE), 10, 1, MAXIMUM_ORIGIN_HOST, numbers)
  else get_numbers_list(access_entry.exception, NODE_PROMPT,
    mutil.minimum((MAXIMUM_IN_PLACE_ORIGIN - access_entry.origin.size),
     MAXIMUM_GENERAL_NUMBER_LIST_SIZE), 8, 1, MAXIMUM_NODE, numbers);
  if user_terminal.sendable
  then
    begin (* move numbers values to origin *)
      origin_index := access_entry.origin.size;
      for numbers_index := 0 to numbers.size - 1 do
	with access_entry.origin do
	  begin
	    add_value := TRUE;
	    for copy_index := 0 to size - 1 do
	      if (list[copy_index].value = numbers.list[numbers_index]) and
	        (list[copy_index].host_flag = host_flag)
	      then add_value := FALSE;
	  if add_value
	  then
            begin
	      list[origin_index].value := numbers.list[numbers_index];
	      list[origin_index].host_flag := host_flag;
	      origin_index := origin_index + 1
	    end
	  else numbers.size := numbers.size - 1
	end (* with *);
      access_entry.origin.size := access_entry.origin.size + numbers.size
    end (* move numbers values to origin *)
end (* get_origin_list *);



(****************************  command_level  ***************************)
(*									*)
(*				save_origin				*)
(*									*)
(************************************************************************)

procedure save_origin(
      temp_list	: in_place_origin_entry;
  var index	: in_place_origin_index;
  var origin	: in_place_origin_description);

begin
  origin.list[index] := temp_list;
  index := index + 1
end (* save_origin *);



(****************************  command_level  ***************************)
(*									*)
(*			    add_to_origin_list				*)
(*									*)
(************************************************************************)

procedure add_to_origin_list(
      keyword_choices	: keyword_choice_set;
  var keyword		: line_keyword_index;
  var access_entry	: access_entry_description);

begin
  input_scanner.prompt_and_scan_keyword(keyword_choices, keyword);
  if user_terminal.sendable
  then
    if keyword = LINE_HOST_KEYWORD
    then get_origin_list(TRUE, access_entry)
    else
      if keyword = LINE_NODE_KEYWORD
      then get_origin_list(FALSE, access_entry)
end (* add_to_origin_list *);



(****************************  command_level  ***************************)
(*									*)
(*			  minimum_assignable_value			*)
(*									*)
(*	This function returns the minimum value for either Class or	*)
(*	Group that a validator may enter; if CLASS_0_GROUP_0_ASSIGNABLE	*)
(*	is TRUE, minimum_assignable_value is zero; otherwise, if	*)
(*	validator is an account_supervisor, minimum_assignable_value	*)
(*	is 1.								*)
(*									*)
(************************************************************************)

function minimum_assignable_value : integer;

begin
  if not CLASS_0_GROUP_0_ASSIGNABLE and
    (profile.level = ACCOUNT_SUPERVISOR_VALIDATOR)
  then minimum_assignable_value := 1
  else minimum_assignable_value := 0
end (* minimum_assignable_value *);


(****************************  command_level  ***************************)
(*									*)
(*			       output_position				*)
(*									*)
(************************************************************************)

procedure output_position(
      position	: integer);

begin
  format.start_line_message('defining position \ ');
  format.number(position + 1, 10)
end (* output_position *);



(****************************  command_level  ***************************)
(*									*)
(*			       get_origin				*)
(*									*)
(************************************************************************)

procedure get_origin(
  var access_entry	: access_entry_description);

var
  keyword : line_keyword_index;
  done : boolean;
  temp_origin : in_place_origin_description;
  temp_index,
  index : in_place_origin_index;

begin
  format.string(' origin,\ ');
  format.write_line(user_terminal);
  access_entry.origin.size := 0;
  access_entry.in_place_origin := not keyword_scan.input_answer(
    'is the origin a system defined class\ ');
  if user_terminal.sendable
  then
    if access_entry.in_place_origin
    then
      begin
	access_entry.exception := keyword_scan.input_answer(
	  'is origin an exception list\');
	if user_terminal.sendable
	then
	  begin (* get in-place origins *)
	    add_to_origin_list([LINE_NODE_KEYWORD, LINE_HOST_KEYWORD],
	      keyword, access_entry);
	    done := FALSE;
	    while user_terminal.sendable and not done do
	      if access_entry.origin.size = MAXIMUM_IN_PLACE_ORIGIN
	      then done := TRUE
	      else
		begin
		  add_to_origin_list(
[LINE_NODE_KEYWORD, LINE_HOST_KEYWORD, LINE_COMPLETE_KEYWORD],
		    keyword, access_entry);
		  if keyword = LINE_COMPLETE_KEYWORD
		  then done := TRUE
	        end (* while *);

	    (* force origin hosts first *)
	    temp_origin := access_entry.origin;
(* run thru temp_origin, storing first hosts then nodes back in origin *)
	    index := 0;
	    for temp_index := 0 to access_entry.origin.size - 1 do
	      if temp_origin.list[temp_index].host_flag
	      then save_origin(temp_origin.list[temp_index], index,
	        access_entry.origin);
	    for temp_index := 0 to access_entry.origin.size - 1 do
	    if not temp_origin.list[temp_index].host_flag
	    then save_origin(temp_origin.list[temp_index], index,
	      access_entry.origin)
	  end
      end
    else
      begin
        done := FALSE;
	repeat 	(* set the CLASS origin *)
	 freeword_utility.prompt_class(minimum_assignable_value, scanned,
	   access_entry.class_no);
	  if user_terminal.sendable
	  then
	    if list_utility.defined_class(access_entry.class_no)
	    then done := TRUE
	    else user_terminal.write_line_and_quoted_text_line(
	      'class is not defined\ ')
	  else done := TRUE (* terminal not sendable *)
	until done;
$ifnot BEFORE_SUP_V43
$if REQUEST_GLOBAL_EXCEPTION
        if (access_entry.class_no > 0) and user_terminal.sendable
        then access_entry.exception := keyword_scan.input_answer(
          'is origin an exception\ ')
        else access_entry.exception := FALSE;
$endif REQUEST_GLOBAL_EXCEPTION
$ifnot REQUEST_GLOBAL_EXCEPTION
	if user_terminal.sendable
	then access_entry.exception :=
          list_utility.global_exception(TRUE, access_entry.class_no)
$endif REQUEST_GLOBAL_EXCEPTION
$endif BEFORE_SUP_V43
      end
end (* get_origin *);



(****************************  command_level  ***************************)
(*									*)
(*			      force_home_value				*)
(*									*)
(************************************************************************)

procedure force_home_value(
      home_value	: boolean;
  var dest_entry	: destination_entry);

begin
  dest_entry.home_flag := home_value;
  if dest_entry.group_flag
  then format.start_message(GROUP_MESSAGE)
  else
    begin
      format.start_message(DEST_MESSAGE);
      format.character(ASCII_SPACE);
    end;
  format.number(dest_entry.value, 10);
  format.string(' is\');
  if not home_value
  then format.string(' not\ ');
  format.string(A_HOME_MESSAGE);
  format.write_line(user_terminal)
end (* force_home_value *);



(****************************  command_level  ***************************)
(*									*)
(*			  store_destination_list			*)
(*									*)
(*	Scan the list of destinations for the user.  If user has the	*)
(*	IGNORE_DESTINATION, do not allow negative groups or group zero,	*)
(*	and force destination to be a HOME; otherwise, ask if each	*)
(*	destination should be a home or not.				*)
(*									*)
(************************************************************************)

procedure store_destination_list(
$if BEFORE_SUP_V43        options		: user_options;
$ifnone BEFORE_SUP_V43       options		: mud_user_options;
      group_flag	: boolean;
      numbers		: general_number_list;
  var access_entry	: access_entry_description);

var
  numbers_index : general_number_list_index;
  dest_index : destination_index;
  done : boolean;
  duplicate_found : boolean;
  defined : boolean;
  home_allowed : boolean;
  ok : boolean;

begin
  with access_entry.destination do
    for numbers_index := 0 to numbers.size - 1 do
      if user_terminal.sendable
      then
	begin
	  ok := TRUE; home_allowed := TRUE;
	  if group_flag
	  then
(*	Check to be sure the group is legal, and if user has the	*)
(*	IGNORE_DESTINATION option and the group cannot be a home, say 	*)
(*	the group is not acceptable.					*)
	    begin
	      format.start_message(GROUP_MESSAGE);
	      format.number(numbers.list[numbers_index], 10);
	      list_utility.defined_group(numbers.list[numbers_index],
		defined, home_allowed);
	      if not defined
	      then
		begin
		  ok := FALSE;
		  format.string(' is not defined\')
		end
	      else
		if ((IGNORE_DESTINATION in options)
$ifnot BEFORE_SUP_V43
		or (mutil.test_bit(HOSTNAME_OK_BIT, access_entry.access_control)
		and not (mutil.test_bit(USERNAME_OK_BIT,
		  access_entry.access_control)))
$endif BEFORE_SUP_V43
)
 		  and not home_allowed
		then
		  begin
		    ok := FALSE;
		    format.string(' cannot be used as a destination\ ')
		  end (*(IGNORE_DESTINATION in options) and not home_allowed*);
	      if not ok
	      then format.write_line(user_terminal)
	    end (* group_flag *);

	  if ok
	  then
	    begin
(* if value is already in list, store new one over old... *)
	      done := FALSE; duplicate_found := FALSE; dest_index := 0;
	      if size > 0
	      then
	        repeat
	          if (group_flag = list[dest_index].group_flag) and
		    (numbers.list[numbers_index] = list[dest_index].value)
		  then duplicate_found := TRUE
		  else
		    if dest_index = size - 1
		    then done := TRUE
		    else dest_index := dest_index + 1
	        until duplicate_found or done;
	      if not duplicate_found
	      then
	        begin (* no duplicate found, save list in new slot *)
		  dest_index := size;
		  list[dest_index].value := numbers.list[numbers_index];
		  list[dest_index].group_flag := group_flag
		end (* no duplicate found, save list in new slot *);
$ifnot BEFORE_SUP_V43
$if REQUEST_GLOBAL_EXCEPTION
	      if (list[dest_index].value <= 0) or not (mutil.test_bit(
		USERNAME_OK_BIT, access_entry.access_control)) or
                (IGNORE_DESTINATION in options)
	      then list[dest_index].exception := FALSE
	      else
		begin
	          format.start_message(QUERY_IS_DESTINATION);
	          format.number(list[dest_index].value, 10);
	          format.write_block(user_terminal);
	          list[dest_index].exception := keyword_scan.input_answer(
    		    ' to be an exception\')
	        end;
              if list[dest_index].value <= 0
              then home_allowed := FALSE
              else home_allowed := not list[dest_index].exception;
$endif REQUEST_GLOBAL_EXCEPTION
$ifnot REQUEST_GLOBAL_EXCEPTION
	      if list[dest_index].group_flag
	      then list[dest_index].exception :=
		list_utility.global_exception(FALSE, list[dest_index].value)
	      else list[dest_index].exception := FALSE;
$endif REQUEST_GLOBAL_EXCEPTION
$endif not BEFORE_SUP_V43
(* force all homes if IGNORE_DESTINATION *)
	      if (IGNORE_DESTINATION in options)
$ifnot BEFORE_SUP_V43
		or mutil.test_bit(HOSTNAME_OK_BIT, access_entry.access_control)
$endif BEFORE_SUP_V43
	      then force_home_value(TRUE, list[dest_index])
	      else
		if home_allowed
		then (* ask user if destination is a home *)
		  begin
		    format.start_message(QUERY_IS_DESTINATION);
		    format.number(list[dest_index].value, 10);
		    format.write_block(user_terminal);
		    list[dest_index].home_flag :=
		      keyword_scan.input_answer(A_HOME_MESSAGE)
		  end
		else force_home_value(FALSE, list[dest_index]);
	      if dest_index < DESTINATION_LIMIT
	      then dest_index := dest_index + 1;
	      if not duplicate_found
	      then size := size + 1
	    end
	end
end (* store_destination_list *);



(****************************  command_level  ***************************)
(*									*)
(*			   destination_entries_left			*)
(*									*)
(************************************************************************)

function destination_entries_left(
      access_entry	: access_entry_description) : integer;

begin
  destination_entries_left := MAXIMUM_ORIGIN_DESTINATION -
    access_entry.destination.size - access_entry.origin.size
end (* destination_entries_left *);



(****************************  command_level  ***************************)
(*									*)
(*			   add_to_destination_list			*)
(*									*)
(************************************************************************)

procedure add_to_destination_list(
$if BEFORE_SUP_V43       options		: user_options;
$ifnone BEFORE_SUP_V43       options		: mud_user_options;
      keyword_choices	: keyword_choice_set;
  var keyword		: line_keyword_index;
  var access_entry	: access_entry_description);

var
  numbers : general_number_list;

begin
  input_scanner.prompt_and_scan_keyword(keyword_choices, keyword);
  if user_terminal.sendable
  then
    if keyword = LINE_HOST_KEYWORD
    then
      begin
	get_numbers_list(FALSE, DEST_PROMPT,
	  mutil.minimum(destination_entries_left(access_entry),
	   MAXIMUM_GENERAL_NUMBER_LIST_SIZE), 10, 1, MAXIMUM_HOST, numbers);
	if user_terminal.sendable
	then store_destination_list(options, FALSE, numbers, access_entry)
      end
    else
      if keyword = LINE_GROUP_KEYWORD
      then
	begin
	   get_numbers_list(FALSE, GROUP_PROMPT,
	     mutil.minimum(destination_entries_left(access_entry),
	      MAXIMUM_GENERAL_NUMBER_LIST_SIZE), 10,
	     minimum_assignable_value, MAXIMUM_GROUP, numbers);
	   if user_terminal.sendable
	   then store_destination_list(options, TRUE, numbers, access_entry)
	end
end (* add_to_destination_list *);



(****************************  command_level  ***************************)
(*									*)
(*			      get_destination				*)
(*									*)
(************************************************************************)

procedure get_destination(
$if BEFORE_SUP_V43       options		: user_options;
$ifnone BEFORE_SUP_V43       options		: mud_user_options;
  var access_entry	: access_entry_description);

var
  done : boolean;
  keyword : line_keyword_index;

begin
  format.string(' destination,\');
  format.write_line(user_terminal);
  access_entry.destination.size := 0;
  repeat
    add_to_destination_list(options, [LINE_GROUP_KEYWORD, LINE_HOST_KEYWORD],
      keyword, access_entry)
  until not user_terminal.sendable or (access_entry.destination.size <> 0);
  done := FALSE;
  while user_terminal.sendable and not done do
    if destination_entries_left(access_entry) = 0
    then done := TRUE
    else
      begin
	add_to_destination_list(options,
	  [LINE_GROUP_KEYWORD, LINE_HOST_KEYWORD, LINE_COMPLETE_KEYWORD],
	  keyword, access_entry);
	if keyword = LINE_COMPLETE_KEYWORD
	then done := TRUE
      end (* while *)
end (* get_destination *);



(**************************  command_level  *****************************)
(*									*)
(*			set_single_ape_to_all_homes			*)
(*									*)
(************************************************************************)

procedure set_single_ape_to_all_homes(
  var command_aborted	: boolean;
  var destination	: destination_description);

var
  dest_index : destination_index;
  defined : boolean (* TRUE if group is defined *);
  allowed_to_be_home : boolean (* TRUE if group is allowed to be home *);

begin
  for dest_index := 0 to destination.size - 1 do
    with destination.list[dest_index] do
    begin
      home_flag := TRUE;
      if group_flag
      then
	begin (* if a group, check to be sure it can be a home *)
	  list_utility.defined_group(value, defined, allowed_to_be_home);
	  if not allowed_to_be_home
	  then
	    begin
	      command_aborted := TRUE;
	      format.start_message('group \ ');
	      format.number(value, 10);
	      format.string( ' cannot be assigned home status\');
	      format.write_line(user_terminal)
	    end (* not allowed_to_be_home *)
	end (* if a group, check to be sure it can be a home *)
    end (* with *)
end (* set_single_ape_to_all_homes *);
$ifnone BEFORE_SUP_V43



(**************************  command_level  *****************************)
(*									*)
(*			query_and_set_ape_to_all_homes			*)
(*									*)
(************************************************************************)

procedure query_and_set_ape_to_all_homes(
      use_query		: boolean (* if FALSE, skip query *);
  var command_aborted	: boolean;
  var destination	: destination_description);

var
  dest_index : destination_index;
  found_non_home : boolean;

begin
  found_non_home := FALSE;
  for dest_index := 0 to destination.size - 1 do
    with destination.list[dest_index] do
      if not home_flag
      then found_non_home := TRUE;
  if found_non_home
  then
    if use_query
    then
      begin
	user_terminal.write_quoted_text_line(
          'setting all destinations to homes in this APE,\ ');
	if not keyword_scan.input_answer(OKAY_QUERY)
	then command_aborted := TRUE
	else set_single_ape_to_all_homes(command_aborted, destination)
      end (* use_query *)
    else set_single_ape_to_all_homes(command_aborted, destination)
end (* query_and_set_ape_to_all_homes *);



(****************************  command_level  ***************************)
(*									*)
(*			   assign_and_report_ap_bit			*)
(*									*)
(************************************************************************)

procedure assign_and_report_ap_bit(
      message		: quoted_text;
      ap_bit_to_set	: integer;
  var control		: access_control_word);

begin
  user_terminal.write_quoted_text_line(message);
  mutil.set_bit(ap_bit_to_set, control)
end (* assign_and_report_ap_bit *);



(****************************  command_level  ***************************)
(*									*)
(*			   get_user_host_ap_options			*)
(*									*)
(************************************************************************)

procedure get_user_host_ap_options(
      defining_new_ap	: boolean;
      options		: mud_user_options;
  var control		: access_control_word;
  var destination	: destination_description;
  var command_aborted	: boolean);

begin
$if REQUEST_USER_HOST_OK
  if (USERNAME_TYPE in options) and (HOSTNAME_TYPE in options)
  then
    if keyword_scan.input_answer(QUERY_APE_FOR_DESTINATION_NAME)
    then
      begin
	mutil.set_bit(HOSTNAME_OK_BIT, control);
	if keyword_scan.input_answer(QUERY_APE_FOR_USERNAME)
	then mutil.set_bit(USERNAME_OK_BIT, control)
      end
    else assign_and_report_ap_bit(ASSIGNING_USERNAME_OK_MESSAGE,
      USERNAME_OK_BIT, control)
  else (* not both USER and HOST type in options *)
    if HOSTNAME_TYPE in options
    then assign_and_report_ap_bit(ASSIGNING_DESTINATION_NAME_OK_MESSAGE,
      HOSTNAME_OK_BIT, control)
    else assign_and_report_ap_bit(ASSIGNING_USERNAME_OK_MESSAGE,
      USERNAME_OK_BIT, control);
$endif REQUEST_USER_HOST_OK
$ifnone REQUEST_USER_HOST_OK
  if HOSTNAME_TYPE in options
  then assign_and_report_ap_bit(ASSIGNING_DESTINATION_NAME_OK_MESSAGE,
    HOSTNAME_OK_BIT, control);
  if USERNAME_TYPE in options
  then assign_and_report_ap_bit(ASSIGNING_USERNAME_OK_MESSAGE,
    USERNAME_OK_BIT, control);
$endif REQUEST_USER_HOST_OK
  if not defining_new_ap and mutil.test_bit(HOSTNAME_OK_BIT, control)
  then query_and_set_ape_to_all_homes(TRUE, command_aborted, destination);
  if not command_aborted
  then
    begin
      if mutil.test_bit(USERNAME_OK_BIT, control)
      then
$if REQUEST_COLLECT_CALL
	if keyword_scan.input_answer(QUERY_ALLOW_USER_COLLECT_CALL)
	then
	  begin
	    mutil.set_bit(USER_COLLECT_CALL_BIT, control);
	    if keyword_scan.input_answer(QUERY_ALLOW_USER_REGULAR_CALL)
	    then mutil.set_bit(USER_REGULAR_CALL_BIT, control)
	  end
	else (* do not allow user collect call *)
$endif REQUEST_COLLECT_CALL
	  assign_and_report_ap_bit(ALLOWING_REGULAR_CALL_AS_USER,
	    USER_REGULAR_CALL_BIT, control);
  if mutil.test_bit(HOSTNAME_OK_BIT, control)
  then
$if REQUEST_COLLECT_CALL
    if keyword_scan.input_answer(QUERY_ALLOW_DESTINATION_COLLECT_CALL)
    then
      begin
	mutil.set_bit(HOST_COLLECT_CALL_BIT, control);
        if keyword_scan.input_answer(QUERY_ALLOW_DESTINATION_REGULAR_CALL)
        then mutil.set_bit(HOST_REGULAR_CALL_BIT, control)
      end
    else
$endif REQUEST_COLLECT_CALL
      assign_and_report_ap_bit(ALLOWING_REGULAR_CALL_AS_DESTINATION,
	HOST_REGULAR_CALL_BIT, control)
    end (* not command aborted *)
end (* get_user_host_ap_options *);



(****************************  command_level  ***************************)
(*									*)
(*			       get_access_options			*)
(*									*)
(************************************************************************)

procedure get_access_options(
       options	: mud_user_options;
   var destination	: destination_description;
   var control		: access_control_word);

var
  dummy_command_aborted_flag : boolean;

begin
  format.string(' access control options,\ ');
  format.write_line(user_terminal);
  control := 0;
  if keyword_scan.input_answer(SHUT_OVERRIDE_MESSAGE)
  then mutil.set_bit(SHUT_OVERRIDE_BIT, control);
  dummy_command_aborted_flag := FALSE;
  get_user_host_ap_options(TRUE, options, control, destination,
    dummy_command_aborted_flag);
$if REQUEST_AUX_OR_NORMAL_CIRCUIT
  if keyword_scan.input_answer('allow auxiliary circuit\')
  then
    begin
      mutil.set_bit(ALLOW_AUX_CIRCUIT_BIT, control);
      if keyword_scan.input_answer('allow normal circuit\ ')
      then mutil.set_bit(ALLOW_NORMAL_CIRCUIT_BIT, control)
    end
  else
$endif REQUEST_AUX_OR_NORMAL_CIRCUIT
$ifnone REQUEST_AUX_OR_NORMAL_CIRCUIT
  user_terminal.write_quoted_text_line('assigning auxiliary circuit\');
  mutil.set_bit(ALLOW_AUX_CIRCUIT_BIT, control);
$endif REQUEST_AUX_OR_NORMAL_CIRCUIT
  assign_and_report_ap_bit(ASSIGNING_NORMAL_CIRCUIT_MESSAGE,
    ALLOW_NORMAL_CIRCUIT_BIT, control);
$if REQUEST_REQUIRE_HOSTNAME
  if mutil.test_bit(USERNAME_OK_BIT, control)
  then
    if keyword_scan.input_answer('destination name required\')
    then mutil.set_bit(REQUIRE_HOSTNAME_BIT, control);
$endif REQUEST_REQUIRE_HOSTNAME
$if REQUEST_TARGET_PROFILE
  if keyword_scan.input_answer('target profile destination\ ')
  then mutil.set_bit(TARGET_PROFILE_DESTINATION_BIT, control);
$endif REQUEST_TARGET_PROFILE
$if REQUEST_PRIORITY_STOP
(* priority continue bit on means to stop *)
  if keyword_scan.input_answer('priority stop\')
  then mutil.set_bit(PRIORITY_CONTINUE_BIT, control)
$endif REQUEST_PRIORITY_STOP
end (* get_access_options *);
$endif BEFORE_SUP_V43



(****************************  command_level  ***************************)
(*									*)
(*			    get_access_profile_entry			*)
(*									*)
(************************************************************************)

procedure get_access_profile_entry(
      index		: access_entry_index;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if validate_x25_names
      this_is_x25_name	: boolean;
      link_host		: integer;
$endif validate_x25_names
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if BEFORE_SUP_V43   options		: user_options;
$ifnone BEFORE_SUP_V43       options		: mud_user_options;
  var access_profile	: access_profile_description);

begin
$ifnot BEFORE_SUP_V43
  output_position(index);
  get_access_options(options, access_profile.entries[index].destination,
    access_profile.entries[index].access_control);
$endif not BEFORE_SUP_V43
  output_position(index);
$if validate_x25_names
  if this_is_x25_name
  then
    begin
      format.string(' assigning origin as host \ ');
      format.number(link_host, 10);
      format.write_line(user_terminal);
      access_profile.entries[index].in_place_origin := TRUE;
      access_profile.entries[index].exception := FALSE;
      access_profile.entries[index].origin.size := 1;
      access_profile.entries[index].origin.list[0].value := link_host;
      access_profile.entries[index].origin.list[0].host_flag := TRUE
    end
  else get_origin(access_profile.entries[index]);
$endif validate_x25_names
$ifnone validate_x25_names     get_origin(access_profile.entries[index]);
  output_position(index);
  if user_terminal.sendable
  then get_destination(options, access_profile.entries[index])
end (* get_access_profile_entry *);



(****************************  command_level  ***************************)
(*									*)
(*			     get_access_profile				*)
(*									*)
(************************************************************************)

procedure get_access_profile(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if validate_x25_names
      this_is_x25_name	: boolean;
      link_host		: integer;
$endif validate_x25_names
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if BEFORE_SUP_V43   options		: user_options;
$ifnone BEFORE_SUP_V43   options		: mud_user_options;
  var access_profile	: access_profile_description);

var
  done : boolean;
  index : access_entry_index;

begin
  done := FALSE; index := access_profile.count;
  repeat
    get_access_profile_entry(access_profile.count,
$if validate_x25_names     this_is_x25_name, link_host,
      options, access_profile);
    if user_terminal.sendable
    then
      begin
        access_profile.count := access_profile.count + 1;
	if access_profile.count = MAXIMUM_ACCESS_ENTRY
	then done := TRUE
	else
	  begin
	    if cud_updater.format_profile_size(access_profile) >
$if BEFORE_SUP_V43	        MAXIMUM_ACCESS_DESTINATION
$ifnot BEFORE_SUP_V43	           MAXIMUM_ACCESS_DESCRIPTION
	    then
	      begin
		done := TRUE;
		access_profile.count := access_profile.count - 1;
	        if cud_updater.last_status <> CUD_ENTRY_OK
		then user_terminal.write_quoted_text_line(
'Access entered cannot be implemented.\')
		else user_terminal.write_quoted_text_line(
'Access entry cannot be added, exceeds maximum user entry size.\ ')
	      end
	    else
	      if cud_updater.last_status = CUD_ENTRY_OK
	      then
		begin
	          index := index + 1;
	          user_terminal.write_newline;
	          done := not keyword_scan.input_answer(
'another access entry\ ')
	        end
	      else
		begin
		  done := TRUE;
		  access_profile.count := access_profile.count - 1;
		  user_terminal.write_quoted_text_line(
'Access entered cannot be implemented.\')
		end
	  end
      end (* user_terminal.sendable *)
  until done or not user_terminal.sendable
end (* get_access_profile *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if validate_x25_names



(****************************  command_level  ***************************)
(*									*)
(*			     check_for_x25_name				*)
(*									*)
(************************************************************************)

procedure check_for_x25_name(
$if BEFORE_SUP_V43   cud_entry		: cud_user_entry;
$ifnone BEFORE_SUP_V43   mud_entry		: mud_user_entry;
  var this_is_x25_name	: boolean;
  var link_host		: integer);

var
  ptr : username_text_index;

begin
  this_is_x25_name := TRUE; link_host := 0;
$if BEFORE_SUP_V43   if (cud_entry.password <> 0) or
$ifnone BEFORE_SUP_V43   if (mud_entry.password.cipher <> 0) or
(* if password is not null OR *)
    (MINIMUM_PASSWORD_SIZE = 0) or (* no mininum password size OR *)
$if BEFORE_SUP_V43   (cud_entry.name.size < (MAX_X25_HOST_PLACES+1)) or
$ifnone BEFORE_SUP_V43   (mud_entry.name.size < (MAX_X25_HOST_PLACES+1)) or
(* too small OR *)
$if BEFORE_SUP_V43   (cud_entry.name.size >
$ifnone BEFORE_SUP_V43   (mud_entry.name.size >
    (MAX_X25_HOST_PLACES+MAX_X25_PREFIX_SIZE))
							     (* name too big *)
  then this_is_x25_name := FALSE (* cannot be an X25 username *)
  else
(* scan username to see if it fits the format p..pnnnnn, where p..p is from *)
(* one to MAX_X25_PREFIX_SIZE characters, and nnnnn is a link host number.  *)
$if BEFORE_SUP_V43   with cud_entry do
$ifnone BEFORE_SUP_V43   with mud_entry do
      for ptr := (name.size - MAX_X25_HOST_PLACES) to (name.size - 1) do 
        if not mutil.decimal_digit(name.text[ptr])
        then this_is_x25_name := FALSE
        else link_host :=
          link_host * 10 + (ord(name.text[ptr]) - ord(ASCII_ZERO))
end (* check_for_x25_name *);
$endif validate_x25_names
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(****************************  command_level  ***************************)
(*									*)
(*			      entries_correct				*)
(*									*)
(************************************************************************)

function entries_correct(
      output_newline	: boolean) : boolean;

begin
  entries_correct := FALSE;
  if output_newline
  then user_terminal.write_newline;
  if user_terminal.sendable
  then entries_correct := keyword_scan.input_answer(ENTRIES_CORRECT_QUERY)
end (* entries_correct *);



(**************************  command_level  *****************************)
(*									*)
(*			  change_user_access 				*)
(*									*)
(************************************************************************)

procedure change_user_access(
$if BEFORE_SUP_V43   var cud_entry	: cud_user_entry);
$ifnone BEFORE_SUP_V43
  var mud_entry	: mud_user_entry;
  var nud_entry	: nud_user_entry);
$endif BEFORE_SUP_V43

begin
  cud_updater.update_profile(
$if BEFORE_SUP_V43   cud_entry);
$ifnone BEFORE_SUP_V43   mud_entry, nud_entry);
  cud_utility.print_cud_entry_message
end (* change_user_access *);



(****************************  command_level  ***************************)
(*									*)
(*				get_access_entry			*)
(*									*)
(************************************************************************)

procedure get_access_entry(
$if BEFORE_SUP_V43  var cud_entry : cud_user_entry);
$ifnone BEFORE_SUP_V43
  var mud_entry : mud_user_entry;
  var nud_entry : nud_user_entry);
$endif BEFORE_SUP_V43

(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if validate_x25_names
var
  this_is_x25_name : boolean;
  link_host : integer;
$endif validate_x25_names
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

begin
$if BEFORE_SUP_V43   if cud_entry.access_profile.count =
$ifnone BEFORE_SUP_V43   if mud_entry.mud_access_profile.count =
    MAXIMUM_ACCESS_ENTRY
    then
      begin
	user_terminal.write_quoted_text_line('access profile is full\ ');
	cud_updater.abort_cud_change
      end (* full access profile *)
    else
      begin (* room for new access profile *)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if validate_x25_names
      check_for_x25_name(
$if BEFORE_SUP_V43   cud_entry,
$ifnone BEFORE_SUP_V43   mud_entry,
	this_is_x25_name, link_host);
$endif validate_x25_names
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	get_access_profile(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if validate_x25_names 	this_is_x25_name, link_host,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if BEFORE_SUP_V43   cud_entry.options, cud_entry.access_profile);
$ifnone BEFORE_SUP_V43
	  mud_entry.mud_options, mud_entry.mud_access_profile);
$endif BEFORE_SUP_V43
	user_terminal.write_newline;
	cmd_utility.write_access_profile(
$if BEFORE_SUP_V43   cud_entry.access_profile, FALSE);
$ifnone BEFORE_SUP_V43   mud_entry.mud_access_profile, FALSE);
	if entries_correct(TRUE)
        then change_user_access
$if BEFORE_SUP_V43   (cud_entry)
$ifnone BEFORE_SUP_V43   (mud_entry, nud_entry)
	else cud_updater.abort_cud_change
      end (* room for new access profile *)
end (* get_access_entry *);
$ifnone before_sup_v43



(****************************  command_level  ***************************)
(*									*)
(*			      user_entry_type				*)
(*									*)
(************************************************************************)

function user_entry_type(
      options	: mud_user_options) : username_entry_type;

begin
  if (USERNAME_TYPE in options) and (HOSTNAME_TYPE in options)
  then user_entry_type := BOTH_USER_AND_HOST_NAME_TYPE
  else
    if USERNAME_TYPE in options
    then user_entry_type := USERNAME_TYPE_ONLY
    else user_entry_type := HOSTNAME_TYPE_ONLY
end (* user_entry_type *);
$endif before_sup_v43



(****************************  command_level  ***************************)
(*									*)
(*			       get_options				*)
(*									*)
(*	Set initial state of options before calling this routine, since	*)
(*	logon inhibit is not modified by this procedure; get_options	*)
(*	is only called by the new_user and change_control procedures.	*)
(*									*)
(************************************************************************)

procedure get_options(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if validate_x25_names       this_is_x25_name	: boolean;
$if BEFORE_SUP_V43   var options	: user_options);
$ifnone BEFORE_SUP_V43
  var options		: mud_user_options;
  var nud_options	: nud_user_options);
$endif BEFORE_SUP_V43
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if password_expiration_by_user
"$if ALLOW_GLOBAL_PASSWORD_EXPIRE"

var
  found : boolean;
  passlife,
  expiredate : integer;
$endif password_expiration_by_user
"$endif ALLOW_GLOBAL_PASSWORD_EXPIRE"
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

begin
$if BEFORE_SUP_V43
  if keyword_scan.input_answer(SHUT_OVERRIDE_MESSAGE)
  then options := options or [SHUT_OVERRIDE];
$endif BEFORE_SUP_V43
$ifnone BEFORE_SUP_V43
  user_terminal.write_line_and_quoted_text_line(
    'defining entry network options,\');
  if keyword_scan.input_answer('is entry a username\')
  then options := options or [USERNAME_TYPE];
  if user_terminal.sendable
  then
    if not (USERNAME_TYPE in options)
    then
      begin
        options := options or [HOSTNAME_TYPE];
        user_terminal.write_quoted_text_line(
	  'assigning destination name type\')
      end
    else
      if keyword_scan.input_answer('is entry a destination name\')
      then options := options or [HOSTNAME_TYPE];
$endif BEFORE_SUP_V43
  if user_terminal.sendable
  then
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if validate_x25_names
    if not this_is_x25_name
    then
$endif validate_x25_names
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnot BEFORE_SUP_V43
      if not (USERNAME_TYPE in options)
      then (* HOSTNAME_TYPE only, no password required *)
        options := options or [NO_PASSWORD_REQUIRED]
      else
	begin (* USERNAME_TYPE in options *)
$endif BEFORE_SUP_V43
      if not keyword_scan.input_answer('password required\')
      then options := options or [NO_PASSWORD_REQUIRED];
  if user_terminal.sendable
  then
    if keyword_scan.input_answer(TRANSPARENT_LOGIN_MESSAGE)
    then options := options or [TRANSPARENT_LOGIN];
$if force_password_change
  if user_terminal.sendable and not (NO_PASSWORD_REQUIRED in options)
  then
    if keyword_scan.input_answer(FPC_EXEMPT_MESSAGE) 
$if BEFORE_SUP_V43     then options := options or [FPC_EXEMPT];
$ifnot BEFORE_SUP_V43     then nud_options := nud_options or [FPC_EXEMPT];
$endif force_password_change

$if no_self_password_change
  if user_terminal.sendable and not (NO_PASSWORD_REQUIRED in options)
  then
   if keyword_scan.input_answer(NSP_CHANGE_MESSAGE)
$if BEFORE_SUP_V43     then options := options or [NSP_CHANGE];
$ifnot BEFORE_SUP_V43     then nud_options := nud_options or [NSP_CHANGE];
$endif no_self_password_change

$ifnone BEFORE_SUP_V43
"$if ALLOW_GLOBAL_PASSWORD_EXPIRE"
"  if not (FPC_EXEMPT in nud_options)
  then
    begin
      if nud_entry.password_change_date <> 0
      then pasmon.fetch_expiredate(nud_entry.gan,
        nud_entry.password_change_date, expiredate, passlife, found)
      else pasmon.fetch_expiredate(nud_entry.gan, REALTIME, expiredate,
        passlife, found);
      if found
      then
	begin
	  format.start_message('password life assigned: \ ');
	  format.number(passlife, 10);
	  format.write_line(user_terminal);
	end
      end (* not FPC_EXEMPT *);"
"$endif ALLOW_GLOBAL_PASSWORD_EXPIRE"
$endif BEFORE_SUP_V43
  if user_terminal.sendable
  then
    if (TRANSPARENT_LOGIN in options)
$ifnone allow_hosts_on_no_password        or (NO_PASSWORD_REQUIRED in options)
    then
      begin
	user_terminal.write_quoted_text_line(
          'assigning "IGNORE DESTINATION" option\');
	options := options or [IGNORE_DESTINATION]
      end
    else
      if keyword_scan.input_answer(IGNORE_DESTINATION_MESSAGE)
      then options := options or [IGNORE_DESTINATION];
$ifnot BEFORE_SUP_V43
$if REQUEST_AUX_OR_NORMAL_CIRCUIT
(* if flag is disabled all circuit options are set to MUD I functioning, *)
(* i.e. all users are allowed aux and normal circuits and aux circuits *)
(* do not require passwords to complete. *)
        if not (NO_PASSWORD_REQUIRED in options)
        then
	  if keyword_scan.input_answer(
	    'is password required for aux circuit\ ')
	  then options := options or [AUX_PASSWORD]
$endif REQUEST_AUX_OR_NORMAL_CIRCUIT
	end (* USERNAME_TYPE in options *);
$if REQUEST_TARGET_PROFILE
  if keyword_scan.input_answer('is entry a target profile\')
  then options := options or [TARGET_PROFILE_ENTRY];
$endif REQUEST_TARGET_PROFILE
$endif BEFORE_SUP_V43
  if user_terminal.sendable
  then
    if not (TRANSPARENT_LOGIN in options) and not
     (NO_PASSWORD_REQUIRED in options) and not (IGNORE_DESTINATION in options)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone BEFORE_SUP_V43     and (USERNAME_TYPE in options)
$if validate_x25_names      and not this_is_x25_name
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    then
      begin
        user_terminal.write_line_and_quoted_text_line(
	  'defining Netval license,\ ');
	if keyword_scan.input_answer(ACCOUNT_SUPERVISOR_MESSAGE)
$ifnone BEFORE_SUP_V43	      then nud_options := nud_options
$if BEFORE_SUP_V43	  then options := options
	  or [ACCOUNT_SUPERVISOR]
	else
	  if profile.level <> ACCOUNT_SUPERVISOR_VALIDATOR
	  then
	    if keyword_scan.input_answer(NETWORK_ADMINISTRATOR_MESSAGE)
$ifnone BEFORE_SUP_V43            then nud_options := nud_options or [NETWORK_ADMINISTRATOR];
$if BEFORE_SUP_V43	    then options := options or [NETWORK_ADMINISTRATOR];
$ifnone BEFORE_SUP_V43	 	 if not (NETWORK_ADMINISTRATOR in nud_options)
$if BEFORE_SUP_V43	   if not (NETWORK_ADMINISTRATOR in options)
	  and (profile.level <> ACCOUNT_SUPERVISOR_VALIDATOR)
	then
	  begin
	    if keyword_scan.input_answer(AUDITOR_MESSAGE)
$ifnone BEFORE_SUP_V43 	    then nud_options := nud_options or [AUDITOR];
$if BEFORE_SUP_V43 	    then options := options or [AUDITOR];
	    if keyword_scan.input_answer(OPERATOR_MESSAGE)
$ifnone BEFORE_SUP_V43          then nud_options := nud_options or [OPERATOR]
$if BEFORE_SUP_V43	    then options := options or [OPERATOR]
	  end
      end
end (* get_options *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if include_list_descriptions



(***************************  command_level  ****************************)
(*									*)
(*			   get_list_description				*)
(*									*)
(*      Routine to output the prompt and input a list description.	*)
(*									*)
(************************************************************************)

procedure get_list_description(
  var description	: named_list_description);

begin
  user_terminal.write_quoted_text_line('description:\ ');
  user_terminal.read_list_description(description)
end (* get_list_description *);
$endif include_list_descriptions
$if INCLUDE_DNIC



(***************************  command_level  ****************************)
(*									*)
(*			   get_default_dnic				*)
(*									*)
(*      Routine to prompt and input a default DNIC description.		*)
(*									*)
(************************************************************************)

procedure get_default_dnic(
  var default_entry	: dnic_data);

var
  first,
  second : integer;

begin
  default_entry.info := NATIVE_BIT (* default must be native *);
  freeword_utility.prompt_dnicname('Enter default DNIC: \ ',
    default_entry.name);
  freeword_utility.prompt_lookup('Number of NTN digits for first MUD lookup: \',
    scanned, first);
  if keyword_scan.input_answer(
'Is default DNIC shared between networks\')
  then
    begin
      default_entry.info := default_entry.info + SHARED_BIT;
      freeword_utility.prompt_lookup(
'Number of NTN digits for second MUD lookup: \ ',
	scanned, second);
      while (first = second) and user_terminal.sendable do
        freeword_utility.prompt_lookup(
'Second and first lookup cannot be equal, reenter: \ ', scanned, second);
      if second > first
      then
	if not keyword_scan.input_answer(
'Should the second lookup be greater than the first lookup\')
	then freeword_utility.prompt_second_lookup(first, scanned, second);
      default_entry.info := default_entry.info + mutil.left_shift(second, BIT23)
    end (* is default shared *);
  default_entry.info := default_entry.info + first
end (* get_default_dnic *);



(***************************  command_level  ****************************)
(*									*)
(*			   get_non_default_dnic				*)
(*									*)
(*      Routine to prompt and input a non_default DNIC description.	*)
(*									*)
(************************************************************************)

procedure get_non_default_dnic(
  var non_default_entry	: dnic_data);

var
  first,
  second : integer;

begin
  first := 0; non_default_entry.info := 0;
  if keyword_scan.input_answer('Is non-default DNIC native\ ')
    and user_terminal.sendable
  then
    begin
      non_default_entry.info := NATIVE_BIT;
      if keyword_scan.input_answer(
'Does non-default DNIC use the default numbering plan\ ') and
	user_terminal.sendable
      then non_default_entry.info := non_default_entry.info + TRANSLATED_BIT
      else
        if keyword_scan.input_answer(
'Is non-default DNIC shared between networks\') and
	  user_terminal.sendable
        then
          begin
            non_default_entry.info := non_default_entry.info + SHARED_BIT;
	    freeword_utility.prompt_lookup(
'Number of NTN digits for first MUD lookup: \', scanned, first);
            freeword_utility.prompt_lookup(
'Number of NTN digits for second MUD lookup: \ ', scanned, second);
	    while (first = second) and user_terminal.sendable do
              freeword_utility.prompt_lookup(
'Second and first lookup cannot be equal, reenter: \ ', scanned, second);
	    if second > first
	    then
	      if not keyword_scan.input_answer(
'Should the second lookup be greater than the first lookup\')
	      then freeword_utility.prompt_second_lookup(first,scanned, second);
            non_default_entry.info := non_default_entry.info +
		mutil.left_shift(second, BIT23)
          end (* is non_default shared *)
  	else freeword_utility.prompt_lookup(
'Number of NTN digits for first MUD lookup: \',
	  scanned, first)
    end (* native network *)
  else freeword_utility.prompt_lookup(
'Number of NTN digits for first MUD lookup: \',
    scanned, first);
  non_default_entry.info := non_default_entry.info + first
end (* get_non_default_dnic *);
$endif INCLUDE_DNIC
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
"
	Output Routines
"



(***************************  command_level  ****************************)
(*									*)
(*			 write_list_name_and_descr    			*)
(*									*)
(*	write out list name and description				*)
(*									*)
(************************************************************************)

procedure write_list_name_and_descr(
      named_list	: named_list_definition);

begin
  format.start;
  format.listname(named_list.name);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if include_list_descriptions
  format.colon_space;
  format.list_description(named_list.description);
$endif include_list_descriptions
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  format.write_line(user_terminal)
end (* write_list_name_and_descr *);



(***************************  command_level  ****************************)
(*									*)
(*			     write_named_list    			*)
(*									*)
(*	Called by nodelist and hostlist subcommand routines; writes out *)
(*	list name, description and host or node numbers.		*)
(*									*)
(************************************************************************)

procedure write_named_list(
      list_to_write	: validator_named_list_definition);

var
  radix : integer;
  finished : boolean;
  start_line : format_buffer_text_index;
  index : named_list_index;

begin
  user_terminal.write_newline;
  write_list_name_and_descr(list_to_write.named_list);
  if list_to_write.host_flag
  then radix := 10
  else radix := 8;
  format.start;
  finished := FALSE;
  start_line := format.buffer.size;
  for index := 0 to list_to_write.named_list.count - 1 do
    begin
      cmd_utility.check_line_length_and_write(MAX_HOST_OUTPUT+4,
	start_line, COMMA_SPACE);
      format.number(list_to_write.named_list.values[index], radix)
    end (* for *);
  format.write_line(user_terminal)
end (* write_named_list *);



(**************************  command_level  *****************************)
(*									*)
(*			write_global_access_header			*)
(*									*)
(************************************************************************)

procedure write_global_access_header(
      class_flag	: boolean	(* TRUE if a CLASS header *);
      first_value	: univ integer;
      last_value	: univ integer);

begin
  if class_flag
  then format.start_message(CLASS_MESSAGE)
  else format.start_message(GROUP_MESSAGE);
  format.number(first_value, 10);
  if first_value <> last_value
  then
    begin
      format.string(' - \');
      format.number(last_value, 10)
    end (* first_value <> last_value *);
  format.colon_space;
  format.write_block(user_terminal)
end (* write_global_access_header *);



(*************************  command_level  ******************************)
(*									*)
(*			  write_global_access				*)
(*									*)
(* Writes out global_access header, number and all its named lists.	*)
(*									*)
(************************************************************************)

procedure write_global_access(
      class_flag	: boolean;
      global_access 	: global_access_description;
      global_access_no	: univ integer);

var
  index : global_access_list_entry_index;
  list : validator_named_list_definition;

begin
  write_global_access_header(class_flag, global_access_no, global_access_no);
  user_terminal.write_newline;
  for index := 0 to global_access.count - 1 do
    begin
$ifnot REQUEST_GLOBAL_EXCEPTION
      if global_access.exception
      then user_terminal.write_quoted_text(EXCEPTION_MESSAGE);
$endif REQUEST_GLOBAL_EXCEPTION
      list_utility.read_next_list(global_access.lists[index], list);
      write_list_name_and_descr(list.named_list)
    end (* for *);
  user_terminal.write_newline;
end (* write_global_access *);



(*************************  command_level  ******************************)
(*									*)
(*			   write_undefined				*)
(*									*)
(* Writes out class header and number range or number and ': undefined' *)
(*									*)
(************************************************************************)

procedure write_undefined(
      class_flag	: boolean;
      last_undefined,
      first_undefined	: univ integer);

begin
  write_global_access_header(class_flag, first_undefined, last_undefined);
  user_terminal.write_quoted_text_line('undefined(:13:)(:10:)\')
end (* write_undefined *);



(*************************  command_level  ******************************)
(*									*)
(*		     write_undefined_or_global_access			*)
(*									*)
(* Writes out global_access or number and ': undefined'.		*)
(*									*)
(************************************************************************)

procedure write_undefined_or_global_access(
      class_flag	: boolean;
      global_access	: global_access_description;
      global_access_no	: univ integer);

begin
  if global_access.count = 0
  then write_undefined(class_flag, global_access_no, global_access_no)
  else write_global_access(class_flag, global_access, global_access_no)
end (* write_undefined_or_global_access *);



(***********************  command_level  ********************************)
(*									*)
(*			 write_cud_entry				*)
(*									*)
(************************************************************************)

procedure write_cud_entry(
$if BEFORE_SUP_V43   cud_entry : cud_user_entry);
$ifnone BEFORE_SUP_V43
      mud_entry : mud_user_entry;
      nud_entry : nud_user_entry);
$endif BEFORE_SUP_V43

var
$if BEFORE_SUP_V43   i : cud_control_options;
$ifnone BEFORE_SUP_V43
  i : mud_control_options_range;
  j : nud_control_options_range;
$endif BEFORE_SUP_V43
$if force_password_change
  expiredate	: integer;
  passlife	: integer;
  found		: boolean;
$endif force_password_change
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

begin
$if BEFORE_SUP_V43   if INCLUDE_GAN and (cud_entry.gan <> 0)
$ifnone BEFORE_SUP_V43   if INCLUDE_GAN and (nud_entry.gan <> 0)
  then
    begin
      format.start_message(GAN_PROMPT);
$if BEFORE_SUP_V43       format.number(cud_entry.gan, 8);
$ifnone BEFORE_SUP_V43       format.number(nud_entry.gan, 8);
      format.write_line(user_terminal)
    end (* INCLUDE_GAN and (cud_entry.gan <> 0) *);

$if BEFORE_SUP_V43   if cud_entry.uun <> 0
$ifnone BEFORE_SUP_V43   if mud_entry.uun <> 0
  then
    begin
      format.start_message(UUN_PROMPT);
$if BEFORE_SUP_V43       format.number(cud_entry.uun, UUN_RADIX);
$ifnone BEFORE_SUP_V43       format.number(mud_entry.uun, UUN_RADIX);
      format.write_line(user_terminal)
    end (* cud_entry.uun <> 0 *);

$if BEFORE_SUP_V43
  for i := FIRST_CUD_CONTROL_OPTION_TO_PRINT to
    LAST_CUD_CONTROL_OPTION_TO_PRINT do
    if i in cud_entry.options
    then
      begin
	format.start;
	format.control_option_name(i);
	format.write_line(user_terminal)
      end (* i in cud_entry.options *);
$endif BEFORE_SUP_V43
$ifnone BEFORE_SUP_V43
  for i := FIRST_MUD_CONTROL_OPTION to LAST_MUD_CONTROL_OPTION do
    if i in mud_entry.mud_options
    then
      begin
	format.start;
	format.control_option_name(i);
	format.write_line(user_terminal)
      end (* i in cud_entry.options *);
  for j := FIRST_NUD_CONTROL_OPTION_TO_PRINT to
    LAST_NUD_CONTROL_OPTION_TO_PRINT do
    if j in nud_entry.nud_options
    then
      begin
	format.start;
	format.nud_control_option_name(j);
	format.write_line(user_terminal)
      end (* j in nud_entry.nud_options *);
$endif BEFORE_SUP_V43

  if INCLUDE_DISTRICT
  then
    begin
      format.start_message('district: \ ');
      format.number(
$if BEFORE_SUP_V43   cud_entry.district, 10);
$ifnone BEFORE_SUP_V43   nud_entry.district, 10);
      format.write_line(user_terminal)
    end (* INCLUDE_DISTRICT *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if restrict_users_by_time
  cmd_utility.write_allowable_hours(mud_entry.allowable_times);
$endif restrict_users_by_time
$if BEFORE_SUP_V43   if (cud_entry.entry_change_date <> 0)
$ifnone BEFORE_SUP_V43   if (nud_entry.entry_change_date <> 0)
  then
    begin
      format.start_message('entry changed: \');
$if BEFORE_SUP_V43       format.time(cud_entry.entry_change_date);
$ifnone BEFORE_SUP_V43       format.time(nud_entry.entry_change_date);
      format.write_line(user_terminal)
    end (* output entry change date *);

(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+	*)
$if netval_is_a_slave
$if BEFORE_SUP_V43   if cud_entry.password_change_date =
$ifnone BEFORE_SUP_V43   if nud_entry.password_change_date =
    GFD_ONLY_PASSWORD_DATE
  then user_terminal.write_quoted_text_line(GFD_ONLY_MESSAGE)
  else
$endif netval_is_a_slave
$if BEFORE_SUP_V43
    if (cud_entry.password_change_date <> 0) and
      (not (NO_PASSWORD_REQUIRED in cud_entry.options))
$endif BEFORE_SUP_V43
$ifnone BEFORE_SUP_V43
    if (nud_entry.password_change_date <> 0) and
      (not (NO_PASSWORD_REQUIRED in mud_entry.mud_options))
$endif BEFORE_SUP_V43
    then
      begin
        format.start_message('password changed: \ ');
$if BEFORE_SUP_V43  format.date(cud_entry.password_change_date*SECONDS_PER_DAY);
$ifnone BEFORE_SUP_V43   format.time(nud_entry.password_change_date);
	format.write_line(user_terminal)
      end (* output password change date *);
$if password_expiration_by_user
  if mud_entry.password.expire_date <> 0
  then
    begin
      format.start_message(PASSWORD_EXPIRES_MESSAGE);
      format.time(mud_entry.password.expire_date);
      if mud_entry.password.expire_date < REALTIME
      then format.string(EXPIRED_MESSAGE);
      format.write_line(user_terminal)
    end (* expire_date <> 0 *);
$endif password_expiration_by_user
$if force_password_change
$if BEFORE_SUP_V43
    if (cud_entry.gan <> 0) and  (not (FPC_EXEMPT in cud_entry.options)) and
      (not (NO_PASSWORD_REQUIRED in cud_entry.options))
$endif BEFORE_SUP_V43
$ifnone BEFORE_SUP_V43
    if (nud_entry.gan <> 0) and  (not (FPC_EXEMPT in nud_entry.nud_options)) and
      (not (NO_PASSWORD_REQUIRED in mud_entry.mud_options))
$endif BEFORE_SUP_V43
    then
      begin (* display force_password_change information *)
	found := FALSE; expiredate := 0; passlife := 0;
$if BEFORE_SUP_V43        if cud_entry.password_change_date <> 0
$ifnot BEFORE_SUP_V43        if nud_entry.password_change_date <> 0
        then pasmon.fetch_expiredate(
$if BEFORE_SUP_V43         cud_entry.gan, cud_entry.password_change_date,
$ifnone BEFORE_SUP_V43        nud_entry.gan, nud_entry.password_change_date,
	  expiredate, passlife, found)
	else pasmon.fetch_expiredate(
$if BEFORE_SUP_V43        cud_entry.gan,
$ifnone BEFORE_SUP_V43        nud_entry.gan,
	  REALTIME, expiredate, passlife, found);
	if found
	then
	  if (expiredate < REALTIME) and
$if BEFORE_SUP_V43        (cud_entry.password_change_date <> 0)
$ifnone BEFORE_SUP_V43        (nud_entry.password_change_date <> 0)
	    then
	      begin (* password already expired *)
      	        format.start_message(PASSWORD_VALIDITY_PERIOD_MESSAGE);
		format.skip(-1);
		format.colon_space;
      	        format.number(passlife, 10);
	        format.string(' days\');
      	        format.write_line(user_terminal);
                format.start_message(
		  'NOTICE! password invalidated by Netval for exceeding \');
		format.string(PASSWORD_VALIDITY_PERIOD_MESSAGE);
      	        format.write_line(user_terminal)
	      end (* password already expired *)
	    else
	      begin (* password has yet to expire *)
      		format.start_message('password expires: \ ');
      		format.date(expiredate);
      	        format.write_line(user_terminal)
	      end (* password has yet to expire *)
      end (* display force_password_change information *);
$endif force_password_change
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  cmd_utility.write_access_profile(
$if BEFORE_SUP_V43   cud_entry.access_profile, FALSE)
$ifnone BEFORE_SUP_V43   mud_entry.mud_access_profile, FALSE)
end (* write_cud_entry *);
$if INCLUDE_DNIC



(**************************  command_level  *****************************)
(*									*)
(*			   dnic_flag_location				*)
(*									*)
(************************************************************************)

function dnic_flag_location(
      flag	: dnic_flags) : integer;

begin
  case flag of
    NATIVE: dnic_flag_location := NATIVE_BIT;
    SHARED: dnic_flag_location := SHARED_BIT;
    TRANSLATED: dnic_flag_location := TRANSLATED_BIT
  end (* case flag *)
end (* dnic_flag_location *);
 


(**************************  command_level  *****************************)
(*									*)
(*			   write_and_clear_flags			*)
(*									*)
(*	Write flag names to format buffer and clear the flag from info.	*)
(*									*)
(************************************************************************)

procedure write_and_clear_flags(
  var info	: integer);

var
  next_flag : dnic_flags;

begin
  for next_flag := FIRST_DNIC_FLAG to LAST_DNIC_FLAG do
    if mutil.test_bit(dnic_flag_location(next_flag), info)
    then
      begin
	format.dnic_flag_name(next_flag);
	mutil.clear_bit(dnic_flag_location(next_flag), info)
      end
end (* write_and_clear_flags *);
 

(**************************  command_level  *****************************)
(*									*)
(*			   write_dnic_file				*)
(*									*)
(************************************************************************)

procedure write_dnic_file(
  var dnic_table	: dnic_data_table);

var
  success : boolean;

begin
  dnic_access.write_dnic_data(dnic_table, success);
  user_terminal.write_newline;
  if success
  then
    begin
      mud_change.set_dnic_update;
      user_terminal.write_quoted_text_line(ENTRY_COMPLETED)
    end
  else user_terminal.write_quoted_text_line(DISK_WRITE_ERROR_MESSAGE)
end (* write_dnic_file *);



(**************************  command_level  *****************************)
(*									*)
(*			   write_dnic_info				*)
(*									*)
(************************************************************************)

procedure write_dnic_info(
      info	: integer);

var
  temp_info : integer;

begin
  temp_info := info;
  format.skip_to(15);
  if not mutil.test_bit(NATIVE_BIT, temp_info)
  then format.string('non-native \')
  else write_and_clear_flags(temp_info);
  format.skip_to(35);
  format.string('first lookup \');
  format.number(mutil.mask(temp_info, FIRST_LOOKUP_MASK), 10);
  format.string(', second lookup \ ');
  format.number(mutil.right_shift(BIT23, temp_info), 10);
  format.newline;
  format.write_line(user_terminal)
 end (* write_dnic_info *);
 


(**************************  command_level  *****************************)
(*									*)
(*			   write_dnic_entry				*)
(*									*)
(************************************************************************)

procedure write_dnic_entry(
      dnic_entry	: dnic_data);

begin (* write_dnic_entry *)
  format.start;
  format.skip(5);
  with dnic_entry do
    begin
      format.dnicname(name);
      write_dnic_info(info)
    end (* with dnic_entry *)
end (* write_dnic_entry *);
 


(**************************  command_level  *****************************)
(*									*)
(*			   write_dnic_prompt				*)
(*									*)
(************************************************************************)

procedure write_dnic_prompt(
      prompt		: quoted_text;
      dnic_entry	: dnic_data);

begin (* write_dnic_prompt *)
  user_terminal.write_quoted_text_line(prompt);
  if dnic_entry.name = NULL_DNICNAME
  then user_terminal.write_quoted_text_line(' not defined\ ')
  else write_dnic_entry(dnic_entry)
end (* write_dnic_prompt *);


(**************************  command_level  *****************************)
(*									*)
(*			   find_dnic_entry				*)
(*									*)
(************************************************************************)

procedure find_dnic_entry(
      dnic_name		: dnicname_string;
      dnic_table	: dnic_data_table;
  var dnic_index	: non_default_data_index;
  var is_default	: boolean;
  var found		: boolean);

var
  done : boolean;

begin
  dnic_index := 0; done := FALSE;
  with dnic_table do
    begin
      is_default := (dnic_name = default_dnic.name);
      if not is_default
      then
        repeat
	  found := mutil.dnic_match(dnic_name, non_default[dnic_index].name);
          if ((dnic_index < NON_DEFAULT_RECORD_LIMIT) and
            (non_default[dnic_index].name <> NULL_DNICNAME)) and
	    not found
          then dnic_index := dnic_index + 1
          else done := TRUE
        until done or not (user_terminal.sendable)
      else found := is_default
    end (* with *)
end (* find_dnic_entry *);
 


(**************************  command_level  *****************************)
(*									*)
(*			   get_dnic_entry				*)
(*									*)
(************************************************************************)

procedure get_dnic_entry(
      dnic_name		: dnicname_string;
  var dnic_table	: dnic_data_table;
  var dnic_index	: non_default_data_index;
  var is_default	: boolean;
  var found		: boolean;
  var success		: boolean);

begin
  dnic_access.read_dnic_data(dnic_table, success);
  if not success
  then user_terminal.write_quoted_text_line(DISK_READ_ERROR_MESSAGE)
  else find_dnic_entry(dnic_name, dnic_table, dnic_index, is_default,
    found);
end (* get_dnic_entry *);
$endif INCLUDE_DNIC
!
"
	Sorting Routines
"



(****************************  command_level  ***************************)
(*									*)
(*			      sort_named_list				*)
(*									*)
(************************************************************************)

procedure sort_named_list(
$if BEFORE_SUP_V43
      ask_about_sort	: boolean;
      sort_flag		: boolean (* if ask_about_sort is FALSE, use this *);
				(* value to determine sorting *)
$endif BEFORE_SUP_V43
  var list_to_sort	: validator_named_list_definition);

var
  temp : integer;
  switch_index,
  scan_index,
  index : named_list_index;
$if BEFORE_SUP_V43   do_sort : boolean;

begin
$if BEFORE_SUP_V43
  if ((list_to_sort.named_list.count > 1) and not list_to_sort.sorted) and
    ask_about_sort and user_terminal.sendable
  then do_sort := keyword_scan.input_answer(SORT_QUERY)
  else do_sort := sort_flag;
  if do_sort
$endif BEFORE_SUP_V43
$ifnone BEFORE_SUP_V43   if (list_to_sort.named_list.count > 1)
  then
    for scan_index := 0 to list_to_sort.named_list.count - 2 do
      begin
	switch_index := scan_index;
	for index := scan_index + 1 to list_to_sort.named_list.count - 1 do
	  if list_to_sort.named_list.values[index] <
	    list_to_sort.named_list.values[switch_index]
	  then switch_index := index;
	temp := list_to_sort.named_list.values[scan_index];
	list_to_sort.named_list.values[scan_index] :=
	  list_to_sort.named_list.values[switch_index];
	list_to_sort.named_list.values[switch_index] := temp
      end (* for *)
end (* sort_named_list *);
$if INCLUDE_DNIC


(****************************  command_level  ***************************)
(*									*)
(*			      insert_dnic				*)
(*									*)
(************************************************************************)

procedure insert_dnic(
      dnic		: dnic_data;
  var non_default_data	: non_default_data_table);

var
  new_dnic_value,
  temp_value : integer;
  temp_count	: non_default_data_size;
  dnic_index : non_default_data_index;
  done : boolean;
  next_dnic : dnic_data;
  temp_dnic : dnic_data;

begin
  mutil.save_characters_in_word(dnic.name[0], dnic.name[1],
    dnic.name[2], dnic.name[3], new_dnic_value);
  dnic_index := 0; temp_count := 0; done := FALSE;
  repeat
    with non_default_data[dnic_index] do
      mutil.save_characters_in_word(name[0], name[1], name[2],
	name[3], temp_value);
    if ((temp_value > new_dnic_value) or
      (dnic_index = NON_DEFAULT_RECORD_LIMIT)) or
      (temp_count >= mud_change.get_dnic_count - 1)
    then done := TRUE
    else dnic_index := dnic_index + 1;
    temp_count := temp_count + 1
  until done;
  temp_dnic := non_default_data[dnic_index];
  non_default_data[dnic_index] := dnic;
  while (temp_count < mud_change.get_dnic_count) and
    (temp_count < NON_DEFAULT_RECORD_COUNT) do
    begin
      if dnic_index < NON_DEFAULT_RECORD_LIMIT
      then dnic_index := dnic_index + 1;
      temp_count := temp_count + 1;
      next_dnic := non_default_data[dnic_index];
      non_default_data[dnic_index] := temp_dnic;
      temp_dnic := next_dnic
    end (* while temp_count < mud_change.get_dnic_count *)
end (* insert_dnic *);
$endif INCLUDE_DNIC
!
"
		CHANGE ACCESS Command
"



(**************************  command_level  *****************************)
(*									*)
(*			     change_access 				*)
(*									*)
(************************************************************************)

procedure change_access;

var
$if BEFORE_SUP_V43  cud_entry : cud_user_entry;
$ifnone BEFORE_SUP_V43
  mud_entry : mud_user_entry;
  nud_entry : nud_user_entry;
$endif BEFORE_SUP_V43
  success : boolean;
  index : access_entry_index;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if validate_x25_names
  this_is_x25_name : boolean;
  link_host : integer;
$endif validate_x25_names
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

begin
  get_and_access_name(TRUE,
$if BEFORE_SUP_V43   cud_entry, success);
$ifnone BEFORE_SUP_V43   mud_entry, nud_entry, success);
  if success
  then
    begin
      cmd_utility.write_access_profile(
$if BEFORE_SUP_V43        cud_entry.access_profile, FALSE);
$ifnone BEFORE_SUP_V43        mud_entry.mud_access_profile, FALSE);
      user_terminal.write_newline;
$if BEFORE_SUP_V43   if cud_entry.access_profile.count = 1
$ifnone BEFORE_SUP_V43   if mud_entry.mud_access_profile.count = 1
      then index := 0
      else freeword_utility.prompt_access_entry_position(
        'access position to change: \',
$if BEFORE_SUP_V43  	 cud_entry.access_profile.count,
$ifnone BEFORE_SUP_V43       mud_entry.mud_access_profile.count,
	scanned, index);
$if validate_x25_names
      check_for_x25_name(
$if BEFORE_SUP_V43 	cud_entry, this_is_x25_name, link_host);
$ifnone BEFORE_SUP_V43 	mud_entry, this_is_x25_name, link_host);
$endif validate_x25_names
      if user_terminal.sendable
      then get_access_profile_entry(index,
$if validate_x25_names 	this_is_x25_name, link_host,
$if BEFORE_SUP_V43 	cud_entry.options, cud_entry.access_profile);
$ifnone BEFORE_SUP_V43 	mud_entry.mud_options, mud_entry.mud_access_profile);
      if user_terminal.sendable
      then cmd_utility.write_access_profile(
$if BEFORE_SUP_V43 	cud_entry.access_profile, FALSE);
$ifnone BEFORE_SUP_V43 	mud_entry.mud_access_profile, FALSE);
      if entries_correct(TRUE)
      then change_user_access(
$if BEFORE_SUP_V43      cud_entry)
$ifnone BEFORE_SUP_V43      mud_entry, nud_entry)
      else cud_updater.abort_cud_change
    end
end (* change_access *);
!
"
		CHANGE CONTROL Command
"



(**************************  command_level  *****************************)
(*									*)
(*			    set_all_homes				*)
(*									*)
(************************************************************************)

procedure set_all_homes(
  var command_aborted	: boolean;
  var access_profile	: access_profile_description);

var
  profile_index : access_entry_index;

begin
  user_terminal.write_quoted_text_line('setting all destinations to homes,\ ');
  if not keyword_scan.input_answer(OKAY_QUERY)
  then command_aborted := TRUE
  else
    for profile_index := 0 to access_profile.count - 1 do
      if not command_aborted
      then set_single_ape_to_all_homes(command_aborted,
	access_profile.entries[profile_index].destination)
end (* set_all_homes *);



(**************************  command_level  *****************************)
(*									*)
(*			     non_homed_flag			 	*)
(*									*)
(************************************************************************)

function non_homed_flag(
      access_profile	: access_profile_description) : boolean;

var
  profile_index : access_entry_index;
  dest_index : destination_index;

begin
(* determine if the user has any destinations that are not homed *)
  non_homed_flag := FALSE;
  for profile_index := 0 to access_profile.count - 1 do
    with access_profile.entries[profile_index] do
      for dest_index := 0 to destination.size - 1 do
	if not destination.list[dest_index].home_flag
	then non_homed_flag := TRUE
end (* non_homed_flag *);
$ifnot BEFORE_SUP_V43



(**************************  command_level  *****************************)
(*									*)
(*			redefine_all_host_user_options			*)
(*									*)
(************************************************************************)

procedure redefine_all_host_user_options(
      non_homed_destinations	: boolean (* some non home dests exist *);
      type_being_added		: username_entry_type;
      options			: mud_user_options;
  var access_profile		: access_profile_description;
  var command_aborted		: boolean);

var
  index : access_entry_index;
  old_access_control : access_control_word;

begin
  format.start_line_message('you must change at least one APE to include \ ');
  if type_being_added = USERNAME_TYPE_ONLY
  then format.string('USERNAME OK\')
  else format.string('DESTINATION NAME OK\');
  format.write_line(user_terminal);
  for index := 0 to access_profile.count - 1 do
    with access_profile.entries[index] do
      begin
	output_position(index);
	format.string(' user and destination options\');
	format.write_line(user_terminal);
	old_access_control := access_control;
	mutil.clear_bit(USERNAME_OK_BIT, access_control);
	mutil.clear_bit(HOSTNAME_OK_BIT, access_control);
	mutil.clear_bit(USER_COLLECT_CALL_BIT, access_control);
	mutil.clear_bit(USER_REGULAR_CALL_BIT, access_control);
	mutil.clear_bit(HOST_COLLECT_CALL_BIT, access_control);
	mutil.clear_bit(HOST_REGULAR_CALL_BIT, access_control);
	get_user_host_ap_options(FALSE, options, access_control,
	  destination, command_aborted);
	if command_aborted and user_terminal.sendable
	then
	  begin (* user doesn't want all destinations 2B homes...continue *)
	    user_terminal.write_quoted_text_line(
	      'cancelling modification to this access profile entry\ ');
	    command_aborted := FALSE;
	    access_control := old_access_control
	  end (* user doesn't want all destinations 2B homes...continue *)
      end (* with and for *)
end (* redefine_all_host_user_options *);



(**************************  command_level  *****************************)
(*									*)
(*			  force_all_host_user_options			*)
(*									*)
(*	The entry type is being changed from either user name OR host	*)
(*	name type to both user name AND host name type;			*)
(*	set all access profile entries to both types.			*)
(*	If an APE is gaining DESTINATION NAME OK, set all destinations	*)
(*	to home.							*)
(*									*)
(************************************************************************)

procedure force_all_host_user_options(
      non_homed_destinations	: boolean (* some non home dests exist *);
      type_being_added		: username_entry_type;
      options			: mud_user_options;
  var access_profile		: access_profile_description;
  var command_aborted		: boolean);

var
  index : access_entry_index;
  set_user_collect_call_bit : boolean;
  set_user_regular_call_bit : boolean;
  set_host_collect_call_bit : boolean;
  set_host_regular_call_bit : boolean;

begin
  if non_homed_destinations and (type_being_added = HOSTNAME_TYPE_ONLY)
  then set_all_homes(command_aborted, access_profile);
  if not command_aborted
  then
    begin (* change all APE's to include new type *)
      user_terminal.write_line_and_quoted_text_line('for all APEs:\');
      set_user_collect_call_bit := FALSE;
      set_user_regular_call_bit := FALSE;
      set_host_collect_call_bit := FALSE;
      set_host_regular_call_bit := FALSE;
      if type_being_added = USERNAME_TYPE_ONLY
      then
$if REQUEST_COLLECT_CALL
	if keyword_scan.input_answer(QUERY_ALLOW_USER_COLLECT_CALL)
	then
	  begin
	    set_user_collect_call_bit := TRUE;
	    if keyword_scan.input_answer(QUERY_ALLOW_USER_REGULAR_CALL)
	    then set_user_regular_call_bit := TRUE
	  end
	else (* do not allow user collect call *)
$endif REQUEST_COLLECT_CALL
	  begin (* allow user regular call *)
	    user_terminal.write_quoted_text_line(
	      ALLOWING_REGULAR_CALL_AS_USER);
	    set_user_regular_call_bit := TRUE
	  end (* allow user regular call *)
      else (* type_being_added <> USERNAME_TYPE_ONLY *)
$if REQUEST_COLLECT_CALL
	if keyword_scan.input_answer(QUERY_ALLOW_DESTINATION_COLLECT_CALL)
	then
	  begin
	    set_host_collect_call_bit := TRUE;
	    if keyword_scan.input_answer(
	      QUERY_ALLOW_DESTINATION_REGULAR_CALL)
	    then set_host_regular_call_bit := TRUE
	  end
	else (* do not allow host collect call *)
$endif REQUEST_COLLECT_CALL
	  begin (* allow host regular call *)
	    user_terminal.write_quoted_text_line(
	      ALLOWING_REGULAR_CALL_AS_DESTINATION);
	    set_host_regular_call_bit := TRUE
	  end (* allow host regular call *);
      for index := 0 to access_profile.count - 1 do
	with access_profile.entries[index] do
	 if type_being_added = USERNAME_TYPE_ONLY
	 then
	   begin
	      mutil.set_bit(USERNAME_OK_BIT, access_control);
	      if set_user_collect_call_bit
	      then mutil.set_bit(USER_COLLECT_CALL_BIT, access_control);
	      if set_user_regular_call_bit
	      then mutil.set_bit(USER_REGULAR_CALL_BIT, access_control)
	    end (* username type being added *)
	  else
	    begin (* DESTINATION type being added *)
	      mutil.set_bit(HOSTNAME_OK_BIT, access_control);
	      if set_host_collect_call_bit
	      then mutil.set_bit(HOST_COLLECT_CALL_BIT, access_control);
	      if set_host_regular_call_bit
	      then mutil.set_bit(HOST_REGULAR_CALL_BIT, access_control)
	    end (* DESTINATION type being added *);
    end (* change all APE's to include new type *)
end (* force_all_host_user_options *);



(**************************  command_level  *****************************)
(*									*)
(*			    write_type_missing				*)
(*									*)
(************************************************************************)

procedure write_type_missing(
      type_missing	: username_entry_type);

begin
  format.newline;
  format.string('entry must have at least one APE with \ ');
  if type_missing = USERNAME_TYPE_ONLY
  then format.string('USERNAME OK\')
  else format.string('DESTINATION NAME OK\');
  format.write_line(user_terminal);
  user_terminal.write_newline;
end (* write_type_missing *);



(**************************  command_level  *****************************)
(*									*)
(*			    adjust_profile_type				*)
(*									*)
(*	The entry type is being changed from either user name OR host	*)
(*	name type to both user name AND host name type; give the	*)
(*	validator a chance to either:					*)
(*		- validate a new access profile entry			*)
(*		- automatically set all access profile entries		*)
(*		  to both types						*)
(*		- redefine the user and host options for each		*)
(*		  access profile entry					*)
(*	Before leaving this routine, insure that there is at least one	*)
(*	access profile entry of the type being added, or the user has	*)
(*	aborted the command.						*)
(*	If an APE is gaining DESTINATION NAME OK, set all destinations	*)
(*	to home.							*)
(*									*)
(************************************************************************)

procedure adjust_profile_type(
      non_homed_destinations	: boolean (* some non home dests exist *);
      type_being_added		: username_entry_type;
      options			: mud_user_options;
$if validate_x25_names
      x25_name			: boolean;
      link_host			: integer;
$endif validate_x25_names
  var access_profile		: access_profile_description;
  var command_aborted		: boolean);

var
  index : access_entry_index;
  host_ap_found	: boolean;
  user_ap_found	: boolean;
  set_user_collect_call_bit : boolean;
  set_user_regular_call_bit : boolean;
  set_host_collect_call_bit : boolean;
  set_host_regular_call_bit : boolean;

begin
  if type_being_added = USERNAME_TYPE_ONLY
  then format.start_line_message('USERNAME \')
  else format.start_line_message('DESTINATION NAME \');
  format.string('type control option is being added,\');
  write_type_missing(type_being_added);
  repeat
    if keyword_scan.input_answer(
      'do you want to define a new access profile entry\ ')
(* validator wants to validate a new access profile entry *)
    then get_access_profile(
$if validate_x25_names       x25_name, link_host,
      options, access_profile)
    else
      if keyword_scan.input_answer(
'do you want to have all APEs automatically changed to include new type\ ')
(* validator wants to automatically set all	*)
(* access profile entries to both types		*)
      then force_all_host_user_options(non_homed_destinations,
        type_being_added, options, access_profile, command_aborted)
$ifany (REQUEST_USER_HOST_OK, REQUEST_COLLECT_CALL)
(* validator wants to redefine the user and	*)
(* host options for each access profile entry	*)
      else redefine_all_host_user_options(non_homed_destinations,
        type_being_added, options, access_profile, command_aborted);
$endif (REQUEST_USER_HOST_OK, REQUEST_COLLECT_CALL)
$ifnone (REQUEST_USER_HOST_OK, REQUEST_COLLECT_CALL)  (* only 2 choices *);

(* check to see if there is an ap of each type as yet *)
    host_ap_found := FALSE; user_ap_found := FALSE;
    for index := 0 to access_profile.count - 1 do
      with access_profile.entries[index] do
        begin
          if mutil.test_bit(HOSTNAME_OK_BIT, access_control)
          then host_ap_found := TRUE;
          if mutil.test_bit(USERNAME_OK_BIT, access_control)
          then user_ap_found := TRUE
        end (* for *);
    if user_terminal.sendable
    then
      begin
	format.start;
	if not host_ap_found
	then write_type_missing(HOSTNAME_TYPE_ONLY)
	else
	  if not user_ap_found
	  then write_type_missing(USERNAME_TYPE_ONLY)
	  else user_terminal.write_newline
      end (* user_terminal.sendable *)
    else command_aborted := TRUE
  until (host_ap_found and user_ap_found) or command_aborted;
  if not command_aborted
  then cmd_utility.write_access_profile(access_profile, FALSE)
end (* adjust_profile_type *);



(**************************  command_level  *****************************)
(*									*)
(*		adjust_access_profile_information (not BEFORE_SUP_V43)	*)
(*									*)
(************************************************************************)

procedure adjust_access_profile_information(
$if validate_x25_names
      this_is_x25_name	: boolean;
      link_host		: integer;
$endif validate_x25_names
      old_options	: mud_user_options;
  var command_aborted	: boolean (* TRUE if cmd stopped *);
  var profile_changed	: boolean (* TRUE if profile changed *);
  var mud_entry		: mud_user_entry;
  var nud_entry		: nud_user_entry);

var
  non_homed_destinations : boolean;
  profile_index : access_entry_index;
  host_ap_found,
  user_ap_found : boolean;
  old_collect,
  new_collect,
  old_regular,
  new_regular,
  old_access_bit,
  new_access_bit : integer;
  type_being_added : username_entry_type;

begin
(* determine if the user has any destinations that are not homed *)
  non_homed_destinations := non_homed_flag(mud_entry.mud_access_profile);
  profile_changed := ((IGNORE_DESTINATION in mud_entry.mud_options) or
    (TRANSPARENT_LOGIN in mud_entry.mud_options))
$ifnot allow_hosts_on_no_password
    or (NO_PASSWORD_REQUIRED in mud_entry.mud_options)
$endif allow_hosts_on_no_password
    and non_homed_destinations;
  if profile_changed
  then set_all_homes(command_aborted, mud_entry.mud_access_profile);
  if not command_aborted
  then
    begin
      (* set flag again in case it changed *)
      non_homed_destinations := non_homed_flag(mud_entry.mud_access_profile);
      host_ap_found := FALSE; user_ap_found := FALSE;
      for profile_index := 0 to mud_entry.mud_access_profile.count - 1 do
	with mud_entry.mud_access_profile.entries[profile_index] do
	  begin
	    if mutil.test_bit(USERNAME_OK_BIT, access_control)
	    then user_ap_found := TRUE;
	    if mutil.test_bit(HOSTNAME_OK_BIT, access_control)
	    then host_ap_found := TRUE
          end (* with *);
(* if new options has both types and old only has one, get change from user *)
      if (user_entry_type(mud_entry.mud_options) =
          BOTH_USER_AND_HOST_NAME_TYPE) and
	 (user_entry_type(old_options) <> BOTH_USER_AND_HOST_NAME_TYPE)
      then
        begin
	  if user_entry_type(old_options) = USERNAME_TYPE_ONLY
	  then type_being_added := HOSTNAME_TYPE_ONLY
	  else type_being_added := USERNAME_TYPE_ONLY;
	  profile_changed := TRUE;
	  adjust_profile_type(non_homed_destinations,
	    type_being_added, mud_entry.mud_options,
$if validate_x25_names 	    this_is_x25_name, link_host,
	    mud_entry.mud_access_profile, command_aborted)
	end
      else
(* if old options has both types and new only has one type...OR *)
	if ((user_entry_type(old_options) = BOTH_USER_AND_HOST_NAME_TYPE) and
	  (user_entry_type(mud_entry.mud_options) <>
	   BOTH_USER_AND_HOST_NAME_TYPE)) or
(* ...if new options has only one and is different from old, auto change *)
	((user_entry_type(mud_entry.mud_options) <>
	  BOTH_USER_AND_HOST_NAME_TYPE) and
	 (user_entry_type(mud_entry.mud_options) <>
	   user_entry_type(old_options)))
	then
	  if ((HOSTNAME_TYPE in mud_entry.mud_options) and user_ap_found) or
	    ((USERNAME_TYPE in mud_entry.mud_options) and host_ap_found)
	  then
	    begin (* at least one AP found that is not correct type *)
	      profile_changed := TRUE;
	      if HOSTNAME_TYPE in mud_entry.mud_options
	      then
	        begin (* changing all APEs to DESTINATION NAME OK *)
	          if non_homed_destinations
	  	  then set_all_homes(command_aborted,
		    mud_entry.mud_access_profile);
		  if not command_aborted
		  then user_terminal.write_line_and_quoted_text_line(
'changing all access profile entries to DESTINATION NAME OK\ ');
		    old_collect := USER_COLLECT_CALL_BIT;
		    new_collect := HOST_COLLECT_CALL_BIT;
		    old_regular := USER_REGULAR_CALL_BIT;
		    new_regular := HOST_REGULAR_CALL_BIT;
		    old_access_bit := USERNAME_OK_BIT;
		    new_access_bit := HOSTNAME_OK_BIT
	        end (* changing all APEs to DESTINATION NAME OK *)
	      else
	        begin (* changing all APEs to USER NAME OK *)
      	          user_terminal.write_line_and_quoted_text_line(
'changing all access profile entries to USER NAME OK\');
		    old_collect := HOST_COLLECT_CALL_BIT;
		    new_collect := USER_COLLECT_CALL_BIT;
		    old_regular := HOST_REGULAR_CALL_BIT;
		    new_regular := USER_REGULAR_CALL_BIT;
		    old_access_bit := HOSTNAME_OK_BIT;
		    new_access_bit := USERNAME_OK_BIT
	        end (* changing all APEs to USER NAME OK *);
	      if not command_aborted
	      then
		for profile_index := 0 to
		  mud_entry.mud_access_profile.count - 1 do
	          with mud_entry.mud_access_profile.entries[profile_index] do
		    begin
  		      if mutil.test_bit(old_collect, access_control)
  		      then
		        begin
	  	          mutil.set_bit(new_collect, access_control);
	  	          mutil.clear_bit(old_collect, access_control)
		        end;
          	      if mutil.test_bit(old_regular, access_control)
  		      then
		        begin
	  	          mutil.set_bit(new_regular, access_control);
	  	          mutil.clear_bit(old_regular, access_control)
		        end;
	              mutil.clear_bit(old_access_bit, access_control);
		      mutil.set_bit(new_access_bit, access_control)
	            end (* for *)
	      end (* at least one AP found that is not correct type *)
    end (* not command_aborted *)
end (* adjust_access_profile_information *);



(**************************  command_level  *****************************)
(*									*)
(*		adjust_password_information (not BEFORE_SUP_V43)	*)
(*									*)
(*	If the NO_PASSWORD_REQUIRED bit is to be different than it was 	*)
(*	the CHANGE CONTROL command information was input, set the new	*)
(*	value for cud_entry.password, i.e., if bit was turned ON, set	*)
(*	password to -1, if bit was turned OFF, prompt for and set the	*)
(*	validator supplied password.  					*)
(*									*)
(************************************************************************)

procedure adjust_password_information(
      old_options	: mud_user_options;
  var password_changed	: boolean (* TRUE if password changed *);
$if password_expiration_by_user
  var validity_period	: integer (* new validity period for user *);
$endif password_expiration_by_user
  var mud_entry		: mud_user_entry;
  var nud_entry		: nud_user_entry);

var
  success : boolean;
  old_password : integer;

begin
  if (user_entry_type(old_options) = HOSTNAME_TYPE_ONLY) and
    (user_entry_type(mud_entry.mud_options) = USERNAME_TYPE_ONLY)
  then password_changed := TRUE (* new password must be entered *)
  else
    if (not (NO_PASSWORD_REQUIRED in old_options) or
      (user_entry_type(old_options) <> HOSTNAME_TYPE_ONLY)) and
      (user_entry_type(mud_entry.mud_options) = HOSTNAME_TYPE_ONLY)
    then password_changed := TRUE (* password must be cleared *)
    else
      if USERNAME_TYPE in mud_entry.mud_options
      then password_changed := (NO_PASSWORD_REQUIRED in old_options) <>
	(NO_PASSWORD_REQUIRED in mud_entry.mud_options)
      else password_changed := FALSE;
  if password_changed
  then
    if NO_PASSWORD_REQUIRED in mud_entry.mud_options
    then
      begin
$if prevent_duplicate_passwords
	nud_entry.nud_options :=
	  nud_entry.nud_options - [PREVIOUS_PASSWORD_STORED];
$endif prevent_duplicate_passwords
$if password_expiration_by_user
	nud_entry.nud_options := nud_entry.nud_options - 
	  [EXEMPT_FROM_PASSWORD_EXPIRATION, NON_STANDARD_PASSWORD_EXPIRATION];
	validity_period := 0 (* clear expiration date *);
$endif password_expiration_by_user
	mud_entry.password.cipher := -1 (* new password cipher *)
      end (* NO_PASSWORD_REQUIRED in mud_entry.mud_options *)
    else
      begin (* password is now required *)
	old_password := -1 (* there is no old password cipher *);
$if password_expiration_by_user
$if assign_password_expiration_as_default
	nud_entry.nud_options := nud_entry.nud_options -
	  [EXEMPT_FROM_PASSWORD_EXPIRATION, NON_STANDARD_PASSWORD_EXPIRATION];
	validity_period := mud_change.standard_password_validity_in_seconds;
$endif assign_password_expiration_as_default
$ifnone assign_password_expiration_as_default
	nud_entry.nud_options :=
	  nud_entry.nud_options or [EXEMPT_FROM_PASSWORD_EXPIRATION];
$endif assign_password_expiration_as_default
$endif password_expiration_by_user
(* input new password *)
	if user_terminal.sendable
	then password_read.get_new_cipher(
$ifnone name_legal_password 	  mud_entry.name,
	  old_password,
$if prevent_duplicate_passwords	       NO_PREVIOUS_CIPHER,
$if global_password_only_login	      0, FALSE,
	  mud_entry.password.cipher, success)
      end (* password is now required *)
end (* adjust_password_information *);
$endif BEFORE_SUP_V43
$if BEFORE_SUP_V43



(**************************  command_level  *****************************)
(*									*)
(*		adjust_access_profile_information (BEFORE_SUP_V43)	*)
(*									*)
(************************************************************************)

procedure adjust_access_profile_information(
  var command_aborted	: boolean (* TRUE if cmd stopped *);
  var profile_changed	: boolean (* TRUE if profile changed *);
  var cud_entry		: cud_user_entry);

var
  any_non_homed_destinations : boolean;
  profile_index : access_entry_index;
  dest_index : destination_index;

begin
(* determine if the user has any destinations that are not homed *)
  any_non_homed_destinations := non_homed_flag(cud_entry.access_profile);
  profile_changed := ((IGNORE_DESTINATION in cud_entry.options) or
    (TRANSPARENT_LOGIN in cud_entry.options))
$ifnot allow_hosts_on_no_password
    or (NO_PASSWORD_REQUIRED in cud_entry.options)
$endif allow_hosts_on_no_password
    and any_non_homed_destinations;
  if profile_changed
  then set_all_homes(command_aborted, cud_entry.access_profile)
end (* adjust_access_profile_information *);



(**************************  command_level  *****************************)
(*									*)
(*			adjust_password_information (BEFORE_SUP_V43)	*)
(*									*)
(*	If the NO_PASSWORD_REQUIRED bit is to be different than it was 	*)
(*	the CHANGE CONTROL command information was input, set the new	*)
(*	value for cud_entry.password, i.e., if bit was turned ON, set	*)
(*	password to -1, if bit was turned OFF, prompt for and set the	*)
(*	validator supplied password.  					*)
(*									*)
(************************************************************************)

procedure adjust_password_information(
      old_options	: user_options;
  var password_changed	: boolean (* TRUE if password changed *);
  var cud_entry		: cud_user_entry);

var
  success : boolean;
  old_password : integer;

begin
  password_changed := ((NO_PASSWORD_REQUIRED in old_options) <>
    (NO_PASSWORD_REQUIRED in cud_entry.options));
  if password_changed
  then
    if NO_PASSWORD_REQUIRED in cud_entry.options
    then cud_entry.password := -1 (* change from password to NO password *)
    else
      begin (* change from NO password to password *)
	old_password := -1;
	if user_terminal.sendable
	then password_read.get_new_cipher(
$ifnone name_legal_password 	  cud_entry.name,
	  old_password,
$if global_password_only_login 	  0, FALSE,
	  cud_entry.password, success)
      end (* change from NO password to password *);
end (* adjust_password_information *);
$endif BEFORE_SUP_V43



(**************************  command_level  *****************************)
(*									*)
(*			    change_control				*)
(*									*)
(************************************************************************)

procedure change_control;

var
  password_changed,	(* TRUE if password changed  *)
  profile_changed,	(* TRUE if profile changed *)
  command_aborted,	(* TRUE if cmd stopped due to non home destinations *)
  any_non_homed_destinations,
  success : boolean;
  profile_index : access_entry_index;
  dest_index : destination_index;
$if BEFORE_SUP_V43
  cud_entry : cud_user_entry;
  old_options : user_options;
$endif BEFORE_SUP_V43
$ifnone BEFORE_SUP_V43
  mud_entry : mud_user_entry;
  nud_entry : nud_user_entry;
  old_options : mud_user_options;
  old_nud_options : nud_user_options;
$if password_expiration_by_user
  small_entry : small_cud_entry;
  validity_period : integer;
$endif password_expiration_by_user
$endif BEFORE_SUP_V43
$if validate_x25_names
  this_is_x25_name : boolean;
  link_host : integer;
$endif validate_x25_names

begin
(* input name and save old options *)
  get_and_access_name(TRUE,
$if BEFORE_SUP_V43     cud_entry, success);
$ifnone BEFORE_SUP_V43     mud_entry, nud_entry, success);
  if success
  then
    begin
$if BEFORE_SUP_V43   old_options := cud_entry.options;
$ifnone BEFORE_SUP_V43
      old_options := mud_entry.mud_options;
      old_nud_options := nud_entry.nud_options;
$endif BEFORE_SUP_V43
$if validate_x25_names
$ifnot BEFORE_SUP_V43       check_for_x25_name(mud_entry,
$if BEFORE_SUP_V43       check_for_x25_name(cud_entry,
	this_is_x25_name, link_host);
$endif validate_x25_names
(* clear new options & store any old options that will not be prompted for *)
$if BEFORE_SUP_V43
      cud_entry.options := [];
      if NEW_PASSWORD_OPTION in old_options
      then cud_entry.options := cud_entry.options or [NEW_PASSWORD_OPTION];
$endif BEFORE_SUP_V43
$ifnone BEFORE_SUP_V43
      mud_entry.mud_options := [];
      nud_entry.nud_options := [];
$if allow_logon_inhibit
      if LOGON_INHIBIT in old_options
      then mud_entry.mud_options := mud_entry.mud_options or [LOGON_INHIBIT];
$endif allow_logon_inhibit
$if prevent_duplicate_passwords
      if PREVIOUS_PASSWORD_STORED in old_nud_options
      then nud_entry.nud_options :=
        nud_entry.nud_options or [PREVIOUS_PASSWORD_STORED];
$endif prevent_duplicate_passwords
$if password_expiration_by_user
      if EXEMPT_FROM_PASSWORD_EXPIRATION in old_nud_options
      then nud_entry.nud_options :=
        nud_entry.nud_options or [EXEMPT_FROM_PASSWORD_EXPIRATION];
      if NON_STANDARD_PASSWORD_EXPIRATION in old_nud_options
      then nud_entry.nud_options :=
        nud_entry.nud_options or [NON_STANDARD_PASSWORD_EXPIRATION];
$endif password_expiration_by_user
$endif BEFORE_SUP_V43
(* prompt for and input new options *)
      get_options(
$if validate_x25_names 	this_is_x25_name,
$if BEFORE_SUP_V43 	cud_entry.options);
$ifnone BEFORE_SUP_V43 	mud_entry.mud_options, nud_entry.nud_options);

      adjust_password_information(old_options, password_changed,
$if BEFORE_SUP_V43 	cud_entry);
$ifnone BEFORE_SUP_V43
$if password_expiration_by_user         validity_period,
 	mud_entry, nud_entry);
$endif BEFORE_SUP_V43

      command_aborted := FALSE;
      if user_terminal.sendable
      then adjust_access_profile_information(
$ifnone before_sup_v43
$if validate_x25_names 	this_is_x25_name, link_host,
	old_options, command_aborted, profile_changed, mud_entry, nud_entry);
$endif before_sup_v43
$if BEFORE_SUP_V43 	command_aborted, profile_changed, cud_entry);
      if command_aborted
      then
	begin
	  user_terminal.write_line_and_quoted_text_line(
	    COMMAND_CANCELLED_MESSAGE);
	  cud_updater.abort_cud_change
	end (* command aborted *)
      else
	if not entries_correct(TRUE)
	then cud_updater.abort_cud_change
	else
	  begin (* entries_correct *)
$if BEFORE_SUP_V43
	    cud_updater.update_options(password_changed, profile_changed,
	      cud_entry);
$endif BEFORE_SUP_V43
$ifnot BEFORE_SUP_V43
	    cud_updater.update_mud_options(password_changed, profile_changed,
	      mud_entry, nud_entry);
$if password_expiration_by_user
	    if cud_updater.last_status <> CUD_ENTRY_OK
	    then cud_utility.print_cud_entry_error
	    else
	      if password_changed and
	        not (EXEMPT_FROM_PASSWORD_EXPIRATION in nud_entry.nud_options)
	      then
(*	entry's password has changed; password expiration date should	*)
(*	be updated if it has changed from password required to no	*)
(*	password required (validity_period should be zero; expiration	*)
(*	date should be cleared) or from NO_PASSWORD_REQUIRED		*)
(*	to password required AND user should have an expiration date	*)
	      begin
	        small_entry.name := mud_entry.name;
		password_command.update_password_expiration_date(
		  validity_period, small_entry)
	      end (* user's NOT exempt from password expiration...update exp *)
	    else
$endif password_expiration_by_user
$endif BEFORE_SUP_V43
	    cud_utility.print_cud_entry_message
	  end (* entries_correct *)
    end (* success *)
end (* change_control *);
!
"
		CHANGE DISTRICT Command
"



(**************************  command_level  *****************************)
(*									*)
(*			    change_district 				*)
(*									*)
(************************************************************************)

procedure change_district;

var
  success : boolean;
$if BEFORE_SUP_V43   cud_entry : cud_user_entry;
$ifnone BEFORE_SUP_V43
  mud_entry : mud_user_entry;
  nud_entry : nud_user_entry;
$endif BEFORE_SUP_V43

begin
  if not INCLUDE_DISTRICT
  then user_terminal.write_quoted_text_line(NO_DISTRICTS_MESSAGE)
  else
    begin
      get_and_access_name(TRUE,
$if BEFORE_SUP_V43   cud_entry, success);
$ifnone BEFORE_SUP_V43   mud_entry, nud_entry, success);
      if success
      then
        begin
	  freeword_utility.prompt_district(scanned,
$if BEFORE_SUP_V43   		cud_entry.district);
$ifnone BEFORE_SUP_V43 		nud_entry.district);
	  if user_terminal.sendable
	  then
	    begin
	      cud_updater.update_district(
$if BEFORE_SUP_V43   cud_entry.district);
$ifnone BEFORE_SUP_V43       nud_entry.district);
	      cud_utility.print_cud_entry_message
	    end (* user_terminal.sendable *)
	  else cud_updater.abort_cud_change
	end (* success *)
    end (* INCLUDE_DISTRICT *)
end (* change_district *);
$if INCLUDE_DNIC
!
"
		CHANGE DNIC Command
"


(**************************  command_level  *****************************)
(*									*)
(*			  delete_dnic					*)
(*									*)
(************************************************************************)

procedure delete_dnic(
  var dnic_table : dnic_data_table;
  var dnic_index : non_default_data_index);

begin
  while (dnic_index < NON_DEFAULT_RECORD_LIMIT) and
    (dnic_index < mud_change.get_dnic_count) do
    begin
      dnic_table.non_default[dnic_index] :=
        dnic_table.non_default[dnic_index + 1];
      dnic_index := dnic_index + 1
    end;
  dnic_table.non_default[dnic_index].name := NULL_DNICNAME;
  dnic_table.non_default[dnic_index].info := NULL_INFO
end (* delete_dnic *);



(**************************  command_level  *****************************)
(*									*)
(*			      replace_dnic 				*)
(*									*)
(************************************************************************)

procedure replace_dnic(
      replace_default	: boolean;
      dnic_name		: dnicname_string);

var
  dnic_table : dnic_data_table;
  dnic : dnic_data;
  success : boolean;
  is_default : boolean;
  found : boolean;
  dnic_index : non_default_data_index;

begin
  get_dnic_entry(dnic_name, dnic_table, dnic_index, is_default,
    found, success);
  if success
  then with dnic_table do
    begin
      if replace_default or is_default
      then
        begin
	  write_dnic_prompt('Current default DNIC: \ ', default_dnic);
	  user_terminal.write_line_and_quoted_text_line(
'This command will change the default DNIC for the Network.\ ');
	  if keyword_scan.input_answer('Do you wish to continue\')
	  then get_default_dnic(default_dnic)
	  else success := FALSE
        end
      else
	if found
	then
	  begin
	    user_terminal.write_quoted_text_line('Currently defined: \');
	    format.start;
            write_dnic_info(non_default[dnic_index].info);
	    delete_dnic(dnic_table, dnic_index);
            freeword_utility.prompt_dnicname('Enter non-default DNIC: \ ',
              dnic.name);
	    get_non_default_dnic(dnic);
	    insert_dnic(dnic, dnic_table.non_default)
	  end
	else user_terminal.write_quoted_text_line('DNIC entry not found\ ')
    end (* with dnic_table *);
  if found and success
  then
    if entries_correct(TRUE)
    then write_dnic_file(dnic_table)
end (* replace_dnic *);



(**************************  command_level  *****************************)
(*									*)
(*			      change_dnic 				*)
(*									*)
(************************************************************************)

procedure change_dnic;

var
  dnic_name : dnicname_string;
  default : boolean;

begin
  default := (argument_scan.check_keyword(
    PRIMARY_CHANGE_DNIC_DEFAULT_KEYWORD, scanned));
  if not default
  then freeword_utility.get_dnicname(0, scanned, dnic_name)
  else dnic_name := NULL_DNICNAME;
  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then replace_dnic(default, dnic_name)
end (* change_dnic *);
$endif INCLUDE_DNIC
!
"
		CHANGE GAN Command
"


(**************************  command_level  *****************************)
(*									*)
(*			      change_gan 				*)
(*									*)
(************************************************************************)

procedure change_gan;

var
$if BEFORE_SUP_V43   cud_entry : cud_user_entry;
$ifnone BEFORE_SUP_V43
  mud_entry : mud_user_entry;
  nud_entry : nud_user_entry;
$endif BEFORE_SUP_V43
  success : boolean;
  gan_tba : integer;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone reuse_uuns   uun_tba : integer;
$if reuse_uuns
  bit17_usable_uuns : integer;
  bit18_usable_uuns : integer;
  usable_add_back_slots : integer;
$endif reuse_uuns
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

begin
  if not INCLUDE_GAN
  then user_terminal.write_quoted_text_line(NO_GANS_MESSAGE)
  else
    begin
      get_and_access_name(TRUE,
$if BEFORE_SUP_V43   cud_entry,
$ifnone BEFORE_SUP_V43   mud_entry, nud_entry,
	success);
      if success
      then
        begin
	  param_manager.next_gan_and_uun(gan_tba,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone reuse_uuns 	    uun_tba);
$if reuse_uuns 	  bit17_usable_uuns, bit18_usable_uuns, usable_add_back_slots);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	  freeword_utility.prompt_gan(gan_tba - 1, scanned,
$if BEFORE_SUP_V43   cud_entry.gan);
$ifnone BEFORE_SUP_V43   nud_entry.gan);
	  if not entries_correct(TRUE)
	  then cud_updater.abort_cud_change
	  else
	    begin (* entries_correct *)
	      cud_updater.update_gan(
$if BEFORE_SUP_V43   cud_entry.gan);
$ifnone BEFORE_SUP_V43             nud_entry.gan);
	      cud_utility.print_cud_entry_message
	    end (* entries_correct *)
	end (* success *)
    end (* INCLUDE_GAN *)
end (* change_gan *);
$ifnone before_sup_v43
$if allow_logon_inhibit
!



(**************************  command_level  *****************************)
(*									*)
(*				change_inhibit				*)
(*									*)
(************************************************************************)

procedure change_inhibit;

var
  mud_entry : mud_user_entry;
  nud_entry : nud_user_entry;
  success : boolean;

begin
  get_and_access_name(TRUE, mud_entry, nud_entry, success);
  if success
  then
    begin
      if keyword_scan.input_answer('set inhibit login\')
      then mud_entry.mud_options := mud_entry.mud_options or [LOGON_INHIBIT]
      else mud_entry.mud_options := mud_entry.mud_options - [LOGON_INHIBIT];
      if not entries_correct(TRUE)
      then cud_updater.abort_cud_change
      else
        begin (* entries_correct *)
	  cud_updater.update_mud_options(FALSE, FALSE, mud_entry, nud_entry);
	  cud_utility.print_cud_entry_message
	end (* entries_correct *)
    end (* success *)
end (* change_inhibit *);
$endif allow_logon_inhibit
$endif before_sup_v43
$if include_irc
!
"
		CHANGE IRC Command
"



(**************************  command_level  *****************************)
(*									*)
(*			    change_irc	 				*)
(*									*)
(************************************************************************)

procedure change_irc;

var
$if BEFORE_SUP_V43   cud_entry : cud_user_entry;
$ifnone BEFORE_SUP_V43
  mud_entry : mud_user_entry;
  nud_entry : nud_user_entry;
$endif BEFORE_SUP_V43
  success : boolean;

begin
  get_and_access_name(TRUE,
$if BEFORE_SUP_V43   cud_entry, success);
$ifnone BEFORE_SUP_V43   mud_entry, nud_entry, success);
  if success
  then
    begin
      freeword_utility.prompt_irc(
$if BEFORE_SUP_V43       scanned, cud_entry.irc);
$ifnone BEFORE_SUP_V43       scanned, mud_entry.irc);
      if user_terminal.sendable
      then
        begin
	  if entries_correct(TRUE)
	  then
	    begin
$if BEFORE_SUP_V43 	      cud_updater.update_irc(cud_entry.irc);
$ifnone BEFORE_SUP_V43 	      cud_updater.update_irc(mud_entry.irc);
	      cud_utility.print_cud_entry_message
	    end (* entries_correct *)
	  else cud_updater.abort_cud_change
	end (* not user_terminal.sendable *)
      else cud_updater.abort_cud_change
  end (* success *)
end (* change_irc *);
$endif include_irc
!
"
		CHANGE GLOBAL (Class or Group) Command
"



(**************************  command_level  *****************************)
(*									*)
(*			  get_and_locate_list				*)
(*									*)
(*	Input a listname and return success as TRUE if it exists.	*)
(*	This routine is used for updating Classes and Groups.		*)
(*									*)
(************************************************************************)

procedure get_and_locate_list(
      host_flag	: boolean;
  var success	: boolean;
  var list_desc	: list_descriptor);

var
  temp_list : named_list_name;

begin
  success := FALSE; list_desc.list_ptr := 0; list_desc.host_flag := host_flag;
  freeword_utility.prompt_listname(NULL_STRING, temp_list);
  if user_terminal.sendable
  then
    begin
      list_utility.find_list(temp_list, list_desc);
      if list_utility.last_status <> NODE_HOST_OK
      then list_utility.report_status(user_terminal, FALSE, list_desc,
        list_utility.last_status)
      else success := TRUE
    end (* sendable *)
end (* get_and_locate_list *);



(**************************  command_level  *****************************)
(*									*)
(*			find_list_in_global_access			*)
(*									*)
(************************************************************************)

procedure find_list_in_global_access(
      global_access	: global_access_description;
      list_to_find	: list_descriptor (* list to find *);
  var success		: boolean;
  var access_index	: global_access_list_entry_index);

var
  done : boolean;

begin
  success := FALSE; done := FALSE;
  access_index := 0;
  if global_access.count > 0
  then
    while not success and not done do
      if global_access.lists[access_index] = list_to_find
      then success := TRUE
      else
        if access_index = global_access.count - 1
	then done := TRUE
	else access_index := access_index + 1
end (* find_list_in_global_access *);



(**************************  command_level  *****************************)
(*									*)
(*			add_entry_to_global_access			*)
(*									*)
(************************************************************************)

procedure add_entry_to_global_access(
      class_flag	: boolean (* TRUE if changing CLASS *);
      host_flag		: boolean (* TRUE if changing hostlists *);
  var global_access	: global_access_description);

var
  list : list_descriptor;
  success : boolean;
  access_index : global_access_list_entry_index;

begin
  if global_access.count = MAXIMUM_LISTS_IN_GLOBAL_ACCESS
  then
    if class_flag
    then user_terminal.write_quoted_text_line('class is full\')
    else user_terminal.write_quoted_text_line('group is full\')
  else
    begin
      output_prompt(host_flag, TRUE, ADD_PROMPT);
      get_and_locate_list(host_flag, success, list);
      if success (* got a legal listname *)
      then
	begin (* check to see if list_ptr is already in class *)
	  find_list_in_global_access(global_access,list,success,access_index);
	  if success
	  then user_terminal.write_quoted_text_line(LIST_USED_MESSAGE)
	  else
	    begin (* list not already in class, add it *)
	      if not class_flag or not host_flag
	      then access_index := global_access.count (* put list at end *)
	      else
	        begin (* EXCEPT, store a HOSTLIST in a CLASS at beginning *)
		  for access_index := global_access.count - 1 downto 0 do
		    global_access.lists[access_index + 1] :=
		      global_access.lists[access_index];
		  access_index := 0 (* put new hostlist in front *)
		end (* store hostlist in class at beginning *);
	      global_access.lists[access_index] := list (* store list *);
	      global_access.count := global_access.count + 1 (* incr. count *)
	    end (* list not already in class *)
	end (* check to see if list_ptr is already in class *)
    end (* global access is not full *)
end (* add_entry_to_global_access *);



(**************************  command_level  *****************************)
(*									*)
(*		    delete_entry_from_global_access			*)
(*									*)
(************************************************************************)

procedure delete_entry_from_global_access(
      class_flag	: boolean (* TRUE if changing class *);
      host_flag		: boolean (* TRUE if changing hostlists *);
  var global_access	: global_access_description);

var
  success : boolean;
  list : list_descriptor;
  index,
  access_index : global_access_list_entry_index;

begin
  if global_access.count = 0
  then user_terminal.write_quoted_text_line(NO_LISTS_MESSAGE)
  else
    begin
      output_prompt(host_flag, TRUE, DELETE_PROMPT);
      get_and_locate_list(host_flag, success, list);
      if success
      then
	begin (* list exists *)
	  find_list_in_global_access(global_access,list,success,access_index);
	  if not success
	  then
	    begin
	      format.start_message(LIST_NOT_FOUND_MESSAGE);
	      if class_flag
	      then format.string(CLASS_MESSAGE)
	      else format.string(GROUP_MESSAGE);
	      format.write_line(user_terminal)
	    end (* not success *)
	  else
	    begin (* list is in the class, delete the list *)
	      global_access.count := global_access.count - 1;
	      for index := access_index to global_access.count - 1 do
		global_access.lists[index] := global_access.lists[index + 1]
	    end (* list is in the class, delete the list *)
	end (* list exists *)
    end (* global_access.count > 0 *)
end (* delete_entry_from_global_access *);



(**************************  command_level  *****************************)
(*									*)
(*			replace_global_access_entry			*)
(*									*)
(************************************************************************)

procedure replace_global_access_entry(
      host_flag		: boolean (* TRUE if changing hostlists *);
  var global_access	: global_access_description);

var
  list : list_descriptor;
  success : boolean;
  old_list_index,
  new_list_index : global_access_list_entry_index;

begin
  if global_access.count = 0
  then user_terminal.write_quoted_text_line(NO_LISTS_MESSAGE)
  else
    begin
      output_prompt(host_flag, TRUE, REPLACE_PROMPT);
      get_and_locate_list(host_flag, success, list);
      if success
      then
	begin (* list to be replaced exists *)
	  find_list_in_global_access(global_access, list, success,
	    old_list_index);
	  if success
	  then
	    begin (* list to be replaced exists in global access *)
	      output_new_prompt(host_flag, TRUE);
	      get_and_locate_list(host_flag, success, list);
	      if success
	      then
	        begin (* replacement list exists *)
		  find_list_in_global_access(global_access, list, success,
		    new_list_index);
		  if success
		  then user_terminal.write_quoted_text_line(LIST_USED_MESSAGE)
		  else global_access.lists[old_list_index] := list
		end (* replacement list exists *)
	    end (* list to be replaced exists in global access *)
	end (* list to be replaced exists *)
    end (* global_access.count > 0 *)
end (* replace_global_access_entry *);



(**************************  command_level  *****************************)
(*									*)
(*			  change_global_access				*)
(*									*)
(************************************************************************)

procedure change_global_access(
      class_flag	: boolean);

var
  global_value : integer;
  global_access : global_access_description;
  keyword : line_keyword_index;
  host_flag : boolean (* TRUE if changing hostlists *);
  done : boolean;

begin
  if class_flag
  then freeword_utility.get_class(0, scanned, global_value)
  else freeword_utility.get_group(0, scanned, global_value);
  if user_terminal.sendable
  then
    begin
      list_utility.modify_global_access(class_flag,global_value,global_access);
      if list_utility.last_status <> NODE_HOST_OK
      then report_list_status
      else
	begin
	  user_terminal.write_newline;
      	  write_undefined_or_global_access(class_flag, global_access,
	    global_value);
(* modify entries *)
	  global_access.exception :=
$ifnot REQUEST_GLOBAL_EXCEPTION
	    keyword_scan.input_answer(
	      'should this be an exception definition\ ');
$endif REQUEST_GLOBAL_EXCEPTION
$ifnot BEFORE_SUP_V43
$if REQUEST_GLOBAL_EXCEPTION          FALSE;
$endif BEFORE_SUP_V43
	  if class_flag
	  then
	    begin
	      user_terminal.write_quoted_text('change \');
	      if user_terminal.sendable
	      then input_scanner.prompt_and_scan_keyword(
		[LINE_HOSTLIST_KEYWORD, LINE_NODELIST_KEYWORD], keyword);
	      host_flag := keyword = LINE_HOSTLIST_KEYWORD
	    end
	  else host_flag := TRUE;

	  done := FALSE;
	  while user_terminal.sendable and not done do
	    begin
	      input_scanner.prompt_and_scan_keyword(
	        [LINE_ADD_KEYWORD, LINE_DELETE_KEYWORD, LINE_REPLACE_KEYWORD,
		LINE_END_KEYWORD], keyword);
	      if user_terminal.sendable
	      then
	        if keyword = LINE_ADD_KEYWORD
		then add_entry_to_global_access(class_flag, host_flag,
		  global_access)
		else
		  if keyword = LINE_DELETE_KEYWORD
		  then delete_entry_from_global_access(class_flag, host_flag,
		    global_access)
		  else
		    if keyword = LINE_REPLACE_KEYWORD
		    then replace_global_access_entry(host_flag, global_access)
		    else done := TRUE
	    end (* while *);

	  user_terminal.write_newline;
      	  write_undefined_or_global_access(class_flag, global_access,
	    global_value);
	  if not entries_correct(FALSE)
	  then list_utility.abort
	  else
	    begin (* entries correct *)
	      list_utility.update_global_access(class_flag, global_value,
		global_access);
	      report_list_status
	    end (* entries correct *)
	end
    end
end (* change_global_access *);
!
"
		CHANGE LIST (Host or Node) Routines
"



(**************************  command_level  *****************************)
(*									*)
(*			find_value_in_named_list			*)
(*									*)
(************************************************************************)

procedure find_value_in_named_list(
      value		: integer;
      list_to_search	: validator_named_list_definition;
  var found		: boolean;
  var index_found	: named_list_index);

var
  done : boolean;

begin
  found := FALSE; done := FALSE;
  index_found := 0;
  if list_to_search.named_list.count > 0
  then
    while not done and not found do
      if value = list_to_search.named_list.values[index_found]
      then found := TRUE
      else
	if index_found = list_to_search.named_list.count - 1
	then done := TRUE
	else index_found := index_found + 1
end (* find_value_in_named_list *);



(**************************  command_level  *****************************)
(*									*)
(*			   add_to_named_list				*)
(*									*)
(************************************************************************)

procedure add_to_named_list(
  var this_list	: validator_named_list_definition);

var
  numbers : general_number_list;
  count_to_input : general_number_list_size;
  numbers_index : general_number_list_index;
  temp_index,
  value_index : named_list_index;
  found : boolean;

begin
  if this_list.named_list.count = MAXIMUM_NAMED_LIST_ENTRY
  then user_terminal.write_quoted_text_line('list is full\ ')
  else
    begin
      if (MAXIMUM_NAMED_LIST_ENTRY - this_list.named_list.count) <
	MAXIMUM_GENERAL_NUMBER_LIST_SIZE
      then count_to_input := (MAXIMUM_NAMED_LIST_ENTRY -
	this_list.named_list.count)
      else count_to_input := MAXIMUM_GENERAL_NUMBER_LIST_SIZE;
      if this_list.host_flag
      then get_numbers_list(FALSE, HOST_PROMPT, count_to_input, 10,
	1, MAXIMUM_HOST, numbers)
      else get_numbers_list(FALSE, NODE_PROMPT, count_to_input, 8,
	1, MAXIMUM_NODE, numbers);

      if user_terminal.sendable
      then (* add the values to the list *)
	begin
	  value_index := this_list.named_list.count;
	  for numbers_index := 0 to numbers.size - 1 do
	    begin
	      find_value_in_named_list(numbers.list[numbers_index], this_list,
		found, temp_index);
	      if found
	      then report_named_list_value_error(TRUE, this_list.host_flag,
		numbers.list[numbers_index])
	      else
		with this_list, named_list do
		  begin (* add value to list *)
		    values[value_index] := numbers.list[numbers_index];
$if BEFORE_SUP_V43
		    if sorted and (value_index > 0)
		    then sorted :=
		      values[value_index] > values[value_index - 1];
$endif BEFORE_SUP_V43
		    if value_index < NAMED_LIST_ENTRY_LIMIT
		    then value_index := value_index + 1;
		    count := count + 1
		  end (* with *)		  
	    end (* for *)
	end (* user_terminal.sendable *)
    end (* list is not full *)
end (* add_to_named_list *);



(**************************  command_level  *****************************)
(*									*)
(*			 delete_from_named_list				*)
(*									*)
(************************************************************************)

procedure delete_from_named_list(
  var this_list	: validator_named_list_definition);

var
  numbers : general_number_list;
  count_to_input : general_number_list_size;
  numbers_index : general_number_list_index;
  temp_index,
  value_index : named_list_index;
  found : boolean;

begin
  if this_list.named_list.count = 0
  then user_terminal.write_quoted_text_line('no entries to delete\ ')
  else
    begin
      if this_list.named_list.count < MAXIMUM_GENERAL_NUMBER_LIST_SIZE
      then count_to_input := this_list.named_list.count
      else count_to_input := MAXIMUM_GENERAL_NUMBER_LIST_SIZE;
      if this_list.host_flag
      then get_numbers_list(FALSE, HOST_PROMPT, count_to_input, 10,
	1, MAXIMUM_HOST, numbers)
      else get_numbers_list(FALSE, NODE_PROMPT, count_to_input, 8,
	1, MAXIMUM_NODE, numbers);

(* delete values from the named list *)
      if user_terminal.sendable
      then
        for numbers_index := 0 to numbers.size - 1 do
	  begin
	    find_value_in_named_list(numbers.list[numbers_index], this_list,
	      found, value_index);
	    if not found
	    then report_named_list_value_error(FALSE, this_list.host_flag,
	      numbers.list[numbers_index])
	    else
    	      begin (* value found *)
	        this_list.named_list.count := this_list.named_list.count - 1;
		for temp_index:=value_index to this_list.named_list.count-1 do
		  this_list.named_list.values[temp_index] :=
		    this_list.named_list.values[temp_index + 1];
		  this_list.named_list.values[this_list.named_list.count] := 0
		end (* value found *)
	  end (* for *)
    end (* this_list.named_list.count <> 0 *)
end (* delete_from_named_list *);



(**************************  command_level  *****************************)
(*									*)
(*			   replace_named_list				*)
(*									*)
(************************************************************************)

procedure replace_named_list(
  var this_list	: validator_named_list_definition);

var
  value : integer;
  found : boolean;
  temp_index,
  replace_index : named_list_index;

begin
  if this_list.named_list.count = 0
  then user_terminal.write_quoted_text_line(NO_LISTS_MESSAGE)
  else
    begin
      output_prompt(this_list.host_flag, FALSE, REPLACE_PROMPT);
      if this_list.host_flag
      then freeword_utility.prompt_host(NULL_STRING, scanned, value)
      else freeword_utility.prompt_node(NULL_STRING, scanned, value);
      if user_terminal.sendable
      then
	begin
	  find_value_in_named_list(value, this_list, found, replace_index);
	  if not found
	  then report_named_list_value_error(FALSE, this_list.host_flag, value)
	  else
	    begin (* list to replace has been located in global access *)
	      output_new_prompt(this_list.host_flag, FALSE);
	      if this_list.host_flag
	      then freeword_utility.prompt_host(NULL_STRING, scanned, value)
	      else freeword_utility.prompt_node(NULL_STRING, scanned, value);
	      if user_terminal.sendable
	      then
		begin
		  find_value_in_named_list(value, this_list, found,
		    temp_index);
		  if found
		  then report_named_list_value_error(TRUE, this_list.host_flag,
		    value)
		  else
$ifnone BEFORE_SUP_V43	this_list.named_list.values[replace_index] := value
$if BEFORE_SUP_V43
		    with this_list, named_list do
		      begin
		        values[replace_index] := value;
			if sorted
			then
			  if (replace_index > 0) and
			    (replace_index < NAMED_LIST_ENTRY_LIMIT)
			  then
			    if replace_index < count - 1
			    then sorted :=
			      (values[replace_index] > 
			        values[replace_index-1]) and
			      (values[replace_index] < values[replace_index+1])
			    else sorted := 
			      (values[replace_index] > values[replace_index-1])
			  else
			    if replace_index = NAMED_LIST_ENTRY_LIMIT
			    then sorted :=
			      values[replace_index] > values[replace_index-1]
			    else
			      if (replace_index = 0) and (count > 1)
			      then sorted :=
			        values[replace_index] < values[replace_index+1]
		      end (* with *)
$endif BEFORE_SUP_V43
		end (* user_terminal.sendable *)
	    end (* list to replace has been located in global access *)
	end (* user_terminal.sendable *)
    end (* this_list.named_list.count <> 0 *)
end (* replace_named_list *);



(**************************  command_level  *****************************)
(*									*)
(*			      update_list				*)
(*									*)
(************************************************************************)

procedure update_list(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if include_list_descriptions      changing_description	: boolean;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  var this_list	: validator_named_list_definition);

var
  keyword : line_keyword_index;
  done : boolean;

begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if include_list_descriptions
  if changing_description
  then get_list_description(this_list.named_list.description)
  else
$endif include_list_descriptions
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    begin
      done := FALSE;
      while user_terminal.sendable and not done do
        begin
	  input_scanner.prompt_and_scan_keyword(
	    [LINE_ADD_KEYWORD, LINE_DELETE_KEYWORD, LINE_REPLACE_KEYWORD,
	     LINE_END_KEYWORD], keyword);
	  if user_terminal.sendable
	  then
	    if keyword = LINE_ADD_KEYWORD
	    then add_to_named_list(this_list)
	    else
	      if keyword = LINE_DELETE_KEYWORD
	      then delete_from_named_list(this_list)
	      else
	        if keyword = LINE_REPLACE_KEYWORD
		then replace_named_list(this_list)
		else done := TRUE
	end (* while *);
      sort_named_list(
$if before_sup_v43	  TRUE, FALSE,
        this_list)
    end;
  write_named_list(this_list);
  if not entries_correct(TRUE)
  then list_utility.abort
  else
    begin (* entries_correect *)
      list_utility.update_list(this_list);
      report_list_status
    end (* entries_correect *)
end (* update_list *);



(**************************  command_level  *****************************)
(*									*)
(*			      change_list				*)
(*									*)
(************************************************************************)

procedure change_list(
      host_flag	: boolean (* TRUE if changing a HOST list *));

var
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if include_list_descriptions  changing_description	: boolean;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  this_list : validator_named_list_definition;

begin
  this_list.host_flag := host_flag;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if include_list_descriptions
  changing_description := argument_scan.check_keyword(
    PRIMARY_CHANGE_LIST_DESCRIPTION_KEYWORD, scanned);
$endif include_list_descriptions
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  freeword_utility.get_listname(0, scanned, this_list.named_list.name);
  argument_scan.extra_argument_check(scanned);
  if user_terminal.sendable and (scanned.status = CMD_OK)
  then
    begin
      list_utility.modify_list(this_list);
      if list_utility.last_status <> NODE_HOST_OK
      then report_list_status
      else
        begin
	  write_named_list(this_list);
	  user_terminal.write_newline;
	  update_list(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if include_list_descriptions 		    changing_description,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	    this_list)
	end (* list_utility.last_status = NODE_HOST_OK *)
    end (* user_terminal.sendable and (scanned.status = CMD_OK) *)
end (* change_list *);
!
"
		CHANGE NAME Command
"



(**************************  command_level  *****************************)
(*									*)
(*			     change_name 				*)
(*									*)
(************************************************************************)

procedure change_name;

var
$if BEFORE_SUP_V43   cud_entry : cud_user_entry;
$ifnone BEFORE_SUP_V43
  mud_entry : mud_user_entry;
  nud_entry : nud_user_entry;
$endif BEFORE_SUP_V43
  old_name : username_string;
  success : boolean;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if validate_x25_names
  this_is_x25_name : boolean;
  link_host : integer;
  old_cipher : integer;
$endif validate_x25_names
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

begin
  get_and_access_name(TRUE,
$if BEFORE_SUP_V43   cud_entry,
$ifnone BEFORE_SUP_V43   mud_entry, nud_entry,
    success);
  old_name :=
$if BEFORE_SUP_V43   cud_entry.name;
$ifnone BEFORE_SUP_V43   mud_entry.name;
  if success
  then
    begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if validate_x25_names
      check_for_x25_name(
$if BEFORE_SUP_V43   cud_entry,
$ifnone BEFORE_SUP_V43   mud_entry,
	this_is_x25_name, link_host);
      if this_is_x25_name
      then
        begin
	  user_terminal.write_line_and_quoted_text_line(
	    'this username must be assigned a password,\ ');
	  old_cipher :=
$if BEFORE_SUP_V43   cud_entry.password;
$ifnone BEFORE_SUP_V43   mud_entry.password.cipher;
	  password_read.get_new_cipher(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone name_legal_password
$if BEFORE_SUP_V43 	    cud_entry.name,
$ifnone BEFORE_SUP_V43     	    mud_entry.name,
$endif name_legal_password
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	    old_cipher,
$if prevent_duplicate_passwords	       nud_entry.previous_cipher,
$if global_password_only_login	    0, FALSE,
$if BEFORE_SUP_V43	    cud_entry.password,
$ifnone BEFORE_SUP_V43	     mud_entry.password.cipher,
	    success)
	end (* this_is_x25_name *);
$endif validate_x25_names
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      success := FALSE;
      repeat
        freeword_utility.prompt_username('new name: \ ',
$if BEFORE_SUP_V43   cud_entry.name);
$ifnone BEFORE_SUP_V43   mud_entry.name);
	if user_terminal.sendable
	then
$if BEFORE_SUP_V43   if cud_entry.name = old_name
$ifnone BEFORE_SUP_V43   if mud_entry.name = old_name
	  then user_terminal.write_quoted_text_line(
	    'old and new name may not be the same\ ')
$if BEFORE_SUP_V43   else success := reserve_name(cud_entry.name)
$ifnone BEFORE_SUP_V43   else success := reserve_name(mud_entry.name)
      until success or not user_terminal.sendable;
      if not user_terminal.sendable
      then
      cud_updater.abort_cud_change
      else
        if not entries_correct(TRUE)
	then cud_updater.abort_cud_change
	else
	  begin (* entries_correct *)
	    cud_updater.rename_cud_entry(
$if BEFORE_SUP_V43   cud_entry);
$ifnone BEFORE_SUP_V43   mud_entry, nud_entry);
	    cud_utility.print_cud_entry_message
	  end (* entries_correct *)
    end
end (* change_name *);
!
"
		CHANGE PASSWORD
"



(**************************  command_level  *****************************)
(*									*)
(*			abort_password_change				*)
(*									*)
(************************************************************************)

procedure abort_password_change(
      message	: quoted_text;
  var success	: boolean);

begin
  success := FALSE;
  user_terminal.write_quoted_text_line(message);
  cud_updater.abort_cud_change
end (* abort_password_change *);



(**************************  command_level  *****************************)
(*									*)
(*			    change_password 				*)
(*									*)
(************************************************************************)

procedure change_password;

var
  success : boolean;
  user : small_cud_entry;
$if prevent_duplicate_passwords   password_aged_enuf : boolean;
$if BEFORE_SUP_V43   cud_entry : cud_user_entry;
$ifnone BEFORE_SUP_V43
  mud_entry : mud_user_entry;
  nud_entry : nud_user_entry;
$endif BEFORE_SUP_V43

begin
  if (profile.level = PASSWORD_ONLY_VALIDATOR)
(* removed by JRN 10/4/88...dont thinkg GPO users ever get here... *)
"$if global_password_only_login   or (profile.level = GPO_VALIDATOR)"
then
    begin
$if BEFORE_SUP_V43
      cud_entry.name := profile.name;
      modify_user_entry(cud_entry);
$endif BEFORE_SUP_V43
$ifnone BEFORE_SUP_V43
      mud_entry.name := profile.name;
      modify_user_entry(mud_entry, nud_entry);
$endif BEFORE_SUP_V43
      success := cud_updater.last_status = CUD_ENTRY_OK
    end (* password only validator *)
  else get_and_access_name(TRUE,
$if BEFORE_SUP_V43     cud_entry, success);
$ifnone BEFORE_SUP_V43     mud_entry, nud_entry, success);
  if success
  then
$ifnone before_sup_v43
    if user_entry_type(mud_entry.mud_options) = HOSTNAME_TYPE_ONLY
    then abort_password_change(
'user is DESTINATION NAME only and cannot have his password changed\ ',
      success)
    else
$endif before_sup_v43
$if no_self_password_change
      if (profile.level = PASSWORD_ONLY_VALIDATOR) and
$if BEFORE_SUP_V43        (NSP_CHANGE in cud_entry.options)
$ifnone BEFORE_SUP_V43       (NSP_CHANGE in nud_entry.nud_options)
      then abort_password_change(
	'you are not authorized to change your own password\ ', success)
      else
$endif no_self_password_change
$if before_sup_v43 	if NO_PASSWORD_REQUIRED in cud_entry.options
$ifnone before_sup_v43 	if NO_PASSWORD_REQUIRED in mud_entry.mud_options
	then abort_password_change(
'user has the NO PASSWORD option and cannot have his password changed\ ',
	  success);
  if success
  then
    begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if BEFORE_SUP_V43
      user.name := cud_entry.name;
      user.password_date := cud_entry.password_change_date;
      user.options := cud_entry.options;
      user.gan := cud_entry.gan;
      user.cipher := cud_entry.password;
$endif BEFORE_SUP_V43
$ifnone BEFORE_SUP_V43
      user.name := mud_entry.name;
      user.password_date := nud_entry.password_change_date;
      user.gan := nud_entry.gan;
      user.cipher := mud_entry.password.cipher;
      user.options := mud_entry.mud_options;
      user.nud_options := nud_entry.nud_options;
$endif BEFORE_SUP_V43
$if password_expiration_by_user
      user.expire_date := mud_entry.password.expire_date;
$endif password_expiration_by_user
$if prevent_duplicate_passwords
      user.previous_cipher := nud_entry.previous_cipher;
      password_command.check_password_age(profile.name = user.name,
	user, password_aged_enuf);
      if not password_aged_enuf and (profile.level = PASSWORD_ONLY_VALIDATOR)
      then cud_updater.abort_cud_change
      else
$endif prevent_duplicate_passwords
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      password_command.change_user_password(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if global_password_only_login 	FALSE, 0,
$if prevent_duplicate_passwords 	profile.name = user.name,
	user)
    end (* not password_aged_enuf... *)
end (* change_password *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+	*)
$if restrict_users_by_time
!
"
		CHANGE time
"


(**************************  command_level  *****************************)
(*									*)
(*			     change_time 				*)
(*									*)
(************************************************************************)

procedure change_time;

var
  mud_entry : mud_user_entry;
  nud_entry : nud_user_entry;
  success : boolean;

begin
  get_and_access_name(TRUE, mud_entry, nud_entry, success);
  if success
  then
    begin
      freeword_utility.prompt_allowable_times(scanned,
        mud_entry.allowable_times);
      if not entries_correct(TRUE)
      then cud_updater.abort_cud_change
      else
        begin (* entries_correct *)
	  cud_updater.update_allowable_times(mud_entry.allowable_times);
	  cud_utility.print_cud_entry_message
	end (* entries_correct *)
    end (* success *)
end (* change_time *);
$endif restrict_users_by_time
$if UUNSassignable
!
"
		CHANGE UUN
"


(**************************  command_level  *****************************)
(*									*)
(*			     change_uun 				*)
(*									*)
(************************************************************************)

procedure change_uun;

var
$if BEFORE_SUP_V43   cud_entry : cud_user_entry;
$ifnone BEFORE_SUP_V43
  mud_entry : mud_user_entry;
  nud_entry : nud_user_entry;
$endif BEFORE_SUP_V43
  success : boolean;

begin
  get_and_access_name(TRUE,
$if BEFORE_SUP_V43   cud_entry,
$ifnone BEFORE_SUP_V43   mud_entry, nud_entry,
    success);
  if success
  then
    begin
      freeword_utility.prompt_uun(scanned,
$if BEFORE_SUP_V43   cud_entry.uun);
$ifnone BEFORE_SUP_V43   mud_entry.uun);
      if not entries_correct(TRUE)
      then cud_updater.abort_cud_change
      else
        begin (* entries_correct *)
	  cud_updater.update_uun(
$if BEFORE_SUP_V43   cud_entry.uun);
$ifnone BEFORE_SUP_V43   mud_entry.uun);
	  cud_utility.print_cud_entry_message
	end (* entries_correct *)
    end (* success *)
end (* change_uun *);
$endif UUNSassignable
$if password_expiration_by_user
!
"
		CHANGE VALIDITY
"



(**************************  command_level  *****************************)
(*									*)
(*			    change_validity 				*)
(*									*)
(************************************************************************)

procedure change_validity;

var
  mud_entry : mud_user_entry;
  nud_entry : nud_user_entry;
  validity_period : integer;
  small_entry : small_cud_entry;
  success : boolean;

begin
  get_and_access_name(TRUE, mud_entry, nud_entry, success);
  if success
  then
    begin
      if NO_PASSWORD_REQUIRED in mud_entry.mud_options
      then
	begin
	  success := FALSE;
	  user_terminal.write_line_and_quoted_text_line(
	    'user has the NO PASSWORD control option,\ ')
	end (* NO_PASSWORD_REQUIRED in mud_entry.mud_options *)
      else
	if FPC_EXEMPT in nud_entry.nud_options
	then
	  begin
	    success := FALSE;
	    user_terminal.write_line_and_quoted_text_line(
	     'user has the FORCE PASSWORD CHANGE EXEMPT control option,\')
	  end (* FPC_EXEMPT in nud_entry.nud_options *);
      if not success
      then
        begin
	  cud_updater.abort_cud_change;
	  user_terminal.write_quoted_text_line(COMMAND_CANCELLED_MESSAGE)
	end
    end (* success *);
  if success
  then
    begin
      nud_entry.nud_options := nud_entry.nud_options -
        [EXEMPT_FROM_PASSWORD_EXPIRATION, NON_STANDARD_PASSWORD_EXPIRATION];
      if keyword_scan.input_answer(
        'should password be exempt from expiration\')
      then
        begin
	  nud_entry.nud_options :=
	    nud_entry.nud_options or [EXEMPT_FROM_PASSWORD_EXPIRATION];
	  validity_period := 0
	end
      else
        if keyword_scan.input_answer(
	  'should standard validity period be used\')
	then validity_period :=
	  mud_change.standard_password_validity_in_seconds
	else
	  begin (* non-standard validity period to be used *)
	    nud_entry.nud_options :=
	      nud_entry.nud_options or [NON_STANDARD_PASSWORD_EXPIRATION];
	    if user_terminal.sendable
	    then
	      begin
	        scanned.freeword_count := 0;
		freeword_utility.get_validity(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if prevent_duplicate_passwords
		  mud_change.minimum_password_change_time_in_seconds div
		    SECONDS_PER_DAY,
$endif prevent_duplicate_passwords
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
		  scanned, validity_period);
		if user_terminal.sendable
		then validity_period := validity_period * SECONDS_PER_DAY
		else
		  begin
		    success := FALSE;
		    cud_updater.abort_cud_change
		  end
	      end (* sendable *)
	  end (* non-standard validity period is to be used *)
    end (* success *);
  if success
  then
    if not entries_correct(TRUE)
    then cud_updater.abort_cud_change
    else
      begin
	cud_updater.update_nud_options(TRUE, nud_entry);
	if cud_updater.last_status <> CUD_ENTRY_OK
	then cud_utility.print_cud_entry_error
	else
	  begin
	    small_entry.name := mud_entry.name;
	    password_command.update_password_expiration_date(
	      validity_period, small_entry)
	  end (* user is not exempt *)
      end (* entries_correct *)
"following code has been commented out by JRN and may be debugged someday...
*$if expiration_by_global
        begin
	  pasmon.fetch_expiredate(nud_entry.gan,
	  nud_entry.change_password_date, expiredate, passlife, success);
	  if success
	  then
	    begin (* password already expired *)
      	      format.start_message('user is in GAN with expire life \ ');
	      format.number(passlife, 10);
	      format.write_line(user_terminal);
	    end
	  else
...end of commented out code"
end (* change_validity *);
$endif password_expiration_by_user
!



(*************************  command_level  ******************************)
(*									*)
(*  Name:	CLEAR_CONSISTENCY_COMMAND				*)
(*									*)
(*  Purpose:	prevent scheduled consistency execution			*)
(*									*)
(************************************************************************)

procedure clear_consistency_command;

var
  io_status : file_utility_status;

begin (* clear_consistency_command *)
  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    begin (* perform the CLEAR CONSISTENCY command *)
      mud_change.clear_consistency_schedule(io_status);
      if io_status = FU_SUCCESS
      then
	begin (* record clearing of consistency schedule *)
	  user_terminal.write_quoted_text_line(
	    CONSISTENCY_DEACTIVATED_MESSAGE);
          user_terminal.write_line_and_quoted_text_line(ENTRY_COMPLETED);
          format.start_message('CLEAR CONSISTENCY schedule by \ ');
          oper_messages.report_validator_message(profile);
	end (* record clearing of consistency schedule *)
      else 
        begin (* report disc write error *)
	  user_terminal.write_quoted_text_line(DISK_WRITE_ERROR_MESSAGE);
          format.start_message(DISK_WRITE_ERROR_MESSAGE);
          oper_messages.report_validator_message(profile)
        end (* report disc write error *)
    end (* perform the CLEAR CONSISTENCY command *)
end (* clear_consistency_command *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if force_password_change



(*************************  command_level  ******************************)
(*									*)
(*  Name:	CLEAR_PASSCHANGER_COMMAND				*)
(*									*)
(*  Purpose:	prevent scheduled passchanger execution			*)
(*									*)
(************************************************************************)

procedure clear_passchanger_command;

var
  io_status : file_utility_status;

begin (* clear_passchanger_command *)
  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    begin (* perform the CLEAR CONSISTENCY command *)
      mud_change.clear_passchanger_schedule(io_status);
      if io_status = FU_SUCCESS
      then
	begin (* record clearing of passchanger schedule *)
	  user_terminal.write_quoted_text_line(
				PASSCHANGER_DEACTIVATED_MESSAGE);
          user_terminal.write_line_and_quoted_text_line(ENTRY_COMPLETED);
          format.start_message(
			'CLEAR PASSCHANGER schedule by \ ');
          oper_messages.report_validator_message(profile);
	end (* record clearing of passchanger schedule *)
      else 
        begin (* report disc write error *)
	  user_terminal.write_quoted_text_line(DISK_WRITE_ERROR_MESSAGE);
          format.start_message(DISK_WRITE_ERROR_MESSAGE);
          oper_messages.report_validator_message(profile)
        end (* report disc write error *)
    end (* perform the CLEAR PASSCHANGER command *)
end (* clear_passchanger_schedule *);



(*************************  command_level  ******************************)
(*									*)
(*  Name:	CLEAR_GANPASS_COMMAND					*)
(*									*)
(*  Purpose:	save a GAN's members from the passchanger reaper	*)
(*									*)
(************************************************************************)

procedure clear_ganpass_command;

var
  gan			: integer;
  io_status		: file_utility_status;
  found			: boolean;
  gan_tba 		: integer;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone reuse_uuns uun_tba : integer;
$if reuse_uuns
  bit17_usable_uuns : integer;
  bit18_usable_uuns : integer;
  usable_add_back_slots : integer;
$endif reuse_uuns
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

begin (* clear_ganpass_command *)
  param_manager.next_gan_and_uun(gan_tba,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone reuse_uuns 	    uun_tba);
$if reuse_uuns 	  bit17_usable_uuns, bit18_usable_uuns, usable_add_back_slots);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  freeword_utility.get_gan(scanned, gan_tba - 1, gan);
  argument_scan.extra_argument_check(scanned);
  if (scanned.status = CMD_OK) and user_terminal.sendable
  then 
    begin (* process ok clear_ganpas command *)
      found := false;  io_status := FU_SUCCESS;
      pasmon.clear_ganpass(gan, io_status, found);
      if found 
      then 
      begin
        format.start_line_message('GAN \ ');
        format.number(gan, 8);
	format.character(ASCII_SPACE);
        format.string(PASSWORD_VALIDITY_PERIOD_MESSAGE);
        format.string('now infinite\ ');
        format.write_line(user_terminal);
        user_terminal.write_line_and_quoted_text_line(ENTRY_COMPLETED);
        if io_status = FU_SUCCESS
        then
	  begin (* report successfull ganpas clearing *)
            format.start_message('GAN \ ');
            format.number(gan, 8);
            format.string(' ganpass definition cleared by \');
            oper_messages.report_validator_message(profile)
          end (* report successfull ganpass clearing *)
        else 
          begin (* report disc write error *)
	    user_terminal.write_quoted_text_line(DISK_WRITE_ERROR_MESSAGE);
            format.start_message(DISK_WRITE_ERROR_MESSAGE);
            oper_messages.report_validator_message(profile)
          end (* report disc write error *)
	end (* found *)
	else (* not found *)
   	  begin
	    format.start_line_message('cannot find GAN \ ');
	    format.number(gan, 8);
	    format.write_line(user_terminal)
	  end
    end (* process ok clear_ganpas command *)
end (* clear_ganpass_command *);
$endif force_password_change
$if global_password_only_login



(*************************  command_level  ******************************)
(*									*)
(*  Name:	CLEAR_GPOGAN_COMMAND					*)
(*									*)
(*  Purpose:	remove a GAN's access rights to global_password_only	*)
(*									*)
(************************************************************************)

procedure clear_gpogan_command;

var
  gan		: integer;
  io_status	: file_utility_status;
  found		: boolean;
  gan_tba 	: integer;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone reuse_uuns   uun_tba : integer;
$if reuse_uuns
  bit17_usable_uuns : integer;
  bit18_usable_uuns : integer;
  usable_add_back_slots : integer;
$endif reuse_uuns
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

begin (* clear_gpogan_command *)
  param_manager.next_gan_and_uun(gan_tba,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone reuse_uuns 	    uun_tba);
$if reuse_uuns 	  bit17_usable_uuns, bit18_usable_uuns, usable_add_back_slots);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  freeword_utility.get_gan(scanned, gan_tba - 1, gan);
     argument_scan.extra_argument_check(scanned);
  if (scanned.status = CMD_OK) and user_terminal.sendable
  then 
    begin (* process ok clear_gpogan command *)
      found := false;  io_status := FU_SUCCESS;
      pasmon.clear_gpogan(gan, io_status, found);
      if found
      then
      begin
      format.start_line_message('GAN \ ');
      format.number(gan, 8);
      format.string(' users now excluded from global_password_only\');
      format.write_line(user_terminal);
      user_terminal.write_line_and_quoted_text_line(ENTRY_COMPLETED);
      user_terminal.write_newline;
      if io_status = FU_SUCCESS
        then
          begin (* report successfull gpogan clearing *)
            format.start_message('GAN \ ');
            format.number(gan, 8);
            format.string(' gpogan definition cleared by \ ');
            oper_messages.report_validator_message(profile)
          end (* report successfull gpogan clearing *)
        else 
          begin (* report disc write error *)
	    user_terminal.write_quoted_text_line(DISK_WRITE_ERROR_MESSAGE);
            format.start_message(DISK_WRITE_ERROR_MESSAGE);
            oper_messages.report_validator_message(profile)
          end (* report disc write error *)
	end (* found *)
	else (* not found *)
	  begin
	    format.start_line_message('cannot find GAN \ ');
	    format.number(gan, 8);
	    format.write_line(user_terminal)
	  end
    end (* process ok clear_gpogan command *)
end (* clear_gpogan_command *);
$endif global_password_only_login
$if reuse_uuns



(************************  command_level  *******************************)
(*									*)
(*  Name:	clear_uunmerge_command					*)
(*									*)
(*  Purpose:	call mudchange procedure to prevent uunmerge execution	*)
(*									*)
(************************************************************************)

procedure clear_uunmerge_command;

var
  io_status	: file_utility_status;

begin (* clear_uunmerge_command *)
  argument_scan.extra_argument_check(scanned);
  if (scanned.status = CMD_OK) and user_terminal.sendable
  then 
    begin (* process ok clear_ganpas command *)
      mud_change.clear_uunmerge_schedule(io_status);

      if (io_status = FU_SUCCESS)
      then
        begin (* report successfull uunmerge schedule clearing *)
          user_terminal.write_quoted_text_line('UUN merge deactivated\');
          user_terminal.write_line_and_quoted_text_line(ENTRY_COMPLETED);
          format.start_message('CLEAR UUN MERGE schedule by \ ');
          oper_messages.report_validator_message(profile)
        end (* report successfull uunmerge schedule clearing *)
      else 
        begin (* report disc write error *)
	  user_terminal.write_quoted_text_line(DISK_WRITE_ERROR_MESSAGE);
          format.start_message(DISK_WRITE_ERROR_MESSAGE);
          oper_messages.report_validator_message(profile)
        end (* report disc write error *)
    end (* process ok clear_uunmerge command *)
end (* clear_uunmerge_command *);
$endif reuse_uuns
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
"
		CONSISTENCY Command
"


(**************************  command_level  *****************************)
(*									*)
(*			    run_consistency				*)
(*									*)
(************************************************************************)

procedure run_consistency(
      real_sup	: real_supervisor_index;
      block	: cud_block_index;
      nochange	: boolean (* TRUE if no changes should be made *));

var
  in_core_info : supervisor_in_core_information;

begin
  mud_change.get_sup_update_info(real_sup, in_core_info);
  if (in_core_info.current_un2_activity = MANUAL_CONSISTENCY) 
     or (in_core_info.current_un2_activity = AUTO_CONSISTENCY)
  then user_terminal.write_quoted_text_line('consistency is already running\ ')
  else consistency.validator_consistency(real_sup, block, profile,
					   user_terminal, nochange)
end (* run_consistency *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if logical_volumes
!
"
			COPY Command
"


(***************************  command_level  ****************************)
(*									*)
(*			      copy_command				*)
(*									*)
(************************************************************************)

procedure copy_command;

var
  to_disk : incarnation_index;
  from_disk : incarnation_index;
  proceed_with_copy : boolean;
  lvol_age : logical_volume_age;

begin
  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    if lv_status_manager.copy_locked
    then user_terminal.write_quoted_text_line(COPY_IN_PROGRESS)
    else
      if not lv_status_manager.either_down_or_offline
      then user_terminal.write_quoted_text_line(
        'one disk must be down or offline\ ')
      else
        if not lv_status_manager.lock_for_copy
	then user_terminal.write_quoted_text_line(COPY_IN_PROGRESS)
	else
	  begin
	    lv_dialogue.get_confirmation(TRUE, to_disk, from_disk, lvol_age,
	      proceed_with_copy);
	    if proceed_with_copy
	    then lv_copy.copy(profile.name, lvol_age, to_disk, from_disk)
	    else lv_status_manager.copy_ended
	  end
end (* copy_command *);
$endif logical_volumes
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
"
		DELETE Command
"


(***************************  command_level  ****************************)
(*									*)
(*			      delete_access				*)
(*									*)
(*	prompts for username, deletes an access from that cud entry	*)
(*									*)
(************************************************************************)

procedure delete_access;

var
$if BEFORE_SUP_V43   cud_entry : cud_user_entry;
$ifnone BEFORE_SUP_V43
  mud_entry : mud_user_entry;
  nud_entry : nud_user_entry;
$endif BEFORE_SUP_V43
  success : boolean;
  position : access_entry_index;

begin
  get_and_access_name(TRUE,
$if BEFORE_SUP_V43   cud_entry,
$ifnone BEFORE_SUP_V43   mud_entry, nud_entry,
    success);
  if success
  then
$if BEFORE_SUP_V43   if cud_entry.access_profile.count = 1
$ifnone BEFORE_SUP_V43   if mud_entry.mud_access_profile.count = 1
    then
      begin
	cud_updater.abort_cud_change;
	user_terminal.write_quoted_text_line('cannot delete last entry\ ')
      end (* count = 1 *)
    else
      begin (* user has more than 1 entry *)
	cmd_utility.write_access_profile(
$if BEFORE_SUP_V43   cud_entry.access_profile,
$ifnone BEFORE_SUP_V43   mud_entry.mud_access_profile,
	  FALSE);
	user_terminal.write_newline;
	freeword_utility.prompt_access_entry_position(
	  'access position to delete: \',
$if BEFORE_SUP_V43   cud_entry.access_profile.count,
$ifnone BEFORE_SUP_V43   mud_entry.mud_access_profile.count,
	  scanned, position);
	if not entries_correct(TRUE)
	then cud_updater.abort_cud_change
	else
	  begin
	    cud_entry_util.remove_access_entry(position,
$if BEFORE_SUP_V43   cud_entry.access_profile);
$ifnone BEFORE_SUP_V43   mud_entry.mud_access_profile);
$if BEFORE_SUP_V43           change_user_access(cud_entry)
$ifnone BEFORE_SUP_V43           change_user_access(mud_entry, nud_entry)
	  end (* entries_correct *)
      end (* user has more than 1 entry *)
end (* delete_access *);
$if INCLUDE_DNIC
!


(**************************  command_level  *****************************)
(*									*)
(*			  delete_dnic_entry				*)
(*									*)
(************************************************************************)

procedure delete_dnic_entry;

var
  dnic_table : dnic_data_table;
  success : boolean;
  default_dnic : boolean;
  found : boolean;
  dnic_index : non_default_data_index;
  non_default_data : dnic_data;

begin
  freeword_utility.get_dnicname(0, scanned, non_default_data.name);
  argument_scan.extra_argument_check(scanned);
  if user_terminal.sendable and (scanned.status = CMD_OK)
  then
  if not mud_change.sub_dnic_count
  then user_terminal.write_quoted_text_line('DNIC table is empty\')
  else
    begin
      get_dnic_entry(non_default_data.name, dnic_table,
	dnic_index, default_dnic, found, success);
      if default_dnic and success
      then user_terminal.write_quoted_text_line(
'Default DNIC cannot be deleted\ ')
      else
        if found and success
        then
	  begin
            if entries_correct(TRUE)
            then
	      begin
		delete_dnic(dnic_table, dnic_index);
		write_dnic_file(dnic_table)
	      end
	    else success := mud_change.add_dnic_count
	  end
        else 
	  if success
	  then
	    begin
	      success := mud_change.add_dnic_count;
	      user_terminal.write_quoted_text_line('DNIC entry not found\ ')
	    end;
      if (not success) or default_dnic
      then success := mud_change.add_dnic_count
    end (* else *)
end (* delete_dnic_entry *);
$endif INCLUDE_DNIC
!



(**************************  command_level  *****************************)
(*									*)
(*			  delete_global_access				*)
(*									*)
(************************************************************************)

procedure delete_global_access(
      class_flag	: boolean);

var
  global_value : integer;
  global_access : global_access_description;
  abort_command : boolean;

begin
  if class_flag
  then freeword_utility.get_class(0, scanned, global_value)
  else freeword_utility.get_group(0, scanned, global_value);
  if user_terminal.sendable
  then
    begin
      list_utility.modify_global_access(class_flag,global_value,global_access);
      if list_utility.last_status <> NODE_HOST_OK
      then report_list_status
      else
	begin (* list_utility.last_status = NODE_HOST_OK *)
	  user_terminal.write_newline;
      	  write_undefined_or_global_access(class_flag, global_access,
	    global_value);
	  if class_flag
	  then abort_command := not keyword_scan.input_answer(
	    'clear entire class\ ')
	  else abort_command := not keyword_scan.input_answer(
	    'clear entire group\ ');
	  if abort_command
	  then list_utility.abort
	  else
	    begin (* clear entries *)
	      global_access.exception := FALSE;
	      global_access.count := 0;
	      user_terminal.write_newline;
	      write_undefined_or_global_access(class_flag, global_access,
	        global_value);
	      if not entries_correct(FALSE)
	      then list_utility.abort
	      else
	        begin (* entries correct *)
		  list_utility.update_global_access(class_flag, global_value,
		    global_access);
		  report_list_status
		end (* entries correct *)
	    end (* clear entries *)
	end (* list_utility.last_status = NODE_HOST_OK *)
    end (* user_terminal.sendable *)
end (* delete_global_access *);
!
(***************************  command_level  ****************************)
(*									*)
(*			       DELETE_LIST				*)
(*									*)
(*	prompt for name and delete list if not used by a class or group *)
(*									*)
(************************************************************************)

procedure delete_list(
      host_flag	: boolean);

var
  this_list	: validator_named_list_definition;
  class_no	: class_index;
  group_no	: group_index;
  found_grp	: boolean;

begin
  this_list.host_flag := host_flag;
  freeword_utility.get_listname(0, scanned, this_list.named_list.name);
  argument_scan.extra_argument_check(scanned);
  if user_terminal.sendable and (scanned.status = CMD_OK)
  then
    begin
      list_utility.modify_list(this_list);
      if list_utility.last_status <> NODE_HOST_OK
      then report_list_status
      else
	begin (* list_utility.last_status = NODE_HOST_OK *)
	  write_named_list(this_list);
	  if not entries_correct(TRUE)
	  then list_utility.abort
	  else
	    begin (* entries_correct *)
	      list_utility.delete_list(found_grp, group_no, class_no);
	      if list_utility.last_status <> NODE_HOST_LIST_IN_USE
	      then report_list_status
	      else
		begin (* list_utility.last_status = NODE_HOST_LIST_IN_USE *)
		  format.start_and_newline;
		  format.listname(this_list.named_list.name);
		  format.string(' is referred to in the definition of\ ');
		  format.string(STARS_MESSAGE);
		  if found_grp
		  then
		    begin
		      format.string(GROUP_MESSAGE);
		      format.number(group_no, 10)
		    end (* found_grp *)
		  else
		    begin (* found_grp false *)
		      format.string(CLASS_MESSAGE);
		      format.number(class_no, 10)
		    end (* found_grp false *);
		  format.string(STARS_MESSAGE);
		  format.newline;
		  format.string('and may not be deleted\ ');
		  format.write_line(user_terminal)
		end
	    end (* entries_correct *)
	end (* if NODE_HOST_OK *)
    end (* user_terminal.sendable and (scanned.status = CMD_OK) *)
end (* delete_list *);
!
(***************************  command_level  ****************************)
(*									*)
(*			     DELETE_USER				*)
(*									*)
(*	prompts for username and deletes that entry from cud		*)
(*									*)
(************************************************************************)

procedure delete_user;

var
$if BEFORE_SUP_V43   cud_entry : cud_user_entry;
$ifnone BEFORE_SUP_V43
  mud_entry : mud_user_entry;
  nud_entry : nud_user_entry;
$endif BEFORE_SUP_V43
  success : boolean;

begin
  get_and_access_name(TRUE,
$if BEFORE_SUP_V43   cud_entry,
$ifnone BEFORE_SUP_V43   mud_entry, nud_entry,
    success);
  if success
  then
    begin
      if not user_terminal.sendable
      then cud_updater.abort_cud_change
      else
	if not entries_correct(FALSE)
	then cud_updater.abort_cud_change
	else
	  begin (* delete the user *)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone reuse_uuns 	    cud_updater.delete_cud_entry;
$if reuse_uuns
	     cud_updater.delete_cud_entry(
$if BEFORE_SUP_V43                cud_entry.uun);
$ifnot BEFORE_SUP_V43                mud_entry.uun);
$endif reuse_uuns
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	    cud_utility.print_cud_entry_message
	  end (* delete the user *)
    end (* success *)
end (* delete_user *);
$if INCLUDE_DNIC
!
"
	DISPLAY DNIC
"



(**************************  command_level  *****************************)
(*									*)
(*			   display_dnic					*)
(*									*)
(************************************************************************)

procedure display_dnic(
      dnic_table	: dnic_data_table;
      dnic_display_type : dnic_table_display_type;
      sub_dnic_name     : dnicname_string);
      
var
  dnic_index : non_default_data_index;
  done : boolean;
  is_default : boolean;
  found : boolean;

begin (* display_dnic *)
  if mud_change.dnic_update = 0
  then format.start_message('DNIC file has not been created.\')
  else
    begin
      format.start_message('DNIC file last updated: \ ');
      format.short_time(mud_change.dnic_update)
    end;
  format.write_line(user_terminal);
  user_terminal.write_newline;
  if dnic_display_type = DEFAULT_DNIC_ENTRY
  then write_dnic_prompt('Default DNIC: \ ', dnic_table.default_dnic)
  else
    if dnic_display_type = ONLY_ONE_DNIC
    then
      begin
        find_dnic_entry(sub_dnic_name, dnic_table, dnic_index, is_default,
          found);
        if found
        then
	  begin
	    if is_default
	    then write_dnic_prompt('Default DNIC: \ ', dnic_table.default_dnic)
	    else write_dnic_prompt('DNIC entry: \ ',
	      dnic_table.non_default[dnic_index])
	  end
        else user_terminal.write_quoted_text_line('DNIC entry not found.\')
      end (* if ONLY_ONE_DNIC *)
    else (* display default for display default dnic and entire table *)
      begin (* display entire table *)
        write_dnic_prompt('Default DNIC: \ ', dnic_table.default_dnic);
        dnic_index := 0;
	write_dnic_prompt('Non-default DNIC: \ ',
	  dnic_table.non_default[dnic_index]);
        while ((dnic_index < NON_DEFAULT_RECORD_LIMIT) and
	  (dnic_index < mud_change.get_dnic_count - 1)) do
          begin
	    dnic_index := dnic_index + 1;
	    if dnic_table.non_default[dnic_index].name <> NULL_DNICNAME
	    then write_dnic_entry(dnic_table.non_default[dnic_index])
          end
      end (* entire_dnic_table *)
end (* display_dnic *);



(**************************  command_level  *****************************)
(*									*)
(*			   read_dnic_file				*)
(*									*)
(************************************************************************)

procedure read_dnic_file;

var
  sub_dnic_name		: dnicname_string;
  dnic_display_type	: dnic_table_display_type;
  dnic_table 		: dnic_data_table;
  success,
  netval_dnic_exists	: boolean;

begin  (* read_dnic_file *);
  dnic_display_type := ENTIRE_DNIC_TABLE;
  sub_dnic_name := NULL_DNICNAME;
  if argument_scan.check_keyword(
    PRIMARY_DISPLAY_DNIC_DEFAULT_KEYWORD, scanned)
  then dnic_display_type := DEFAULT_DNIC_ENTRY;
  if argument_scan.check_keyword(
    PRIMARY_DISPLAY_DNIC_ENTRY_KEYWORD, scanned)
  then
    begin (* set dnic table display parameters *)
      freeword_utility.get_dnicname(0, scanned, sub_dnic_name);
      dnic_display_type := ONLY_ONE_DNIC
    end (* set dnic table display parameters *);
  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    begin
      dnic_access.read_dnic_data(dnic_table, success);
      if not success
      then user_terminal.write_quoted_text_line(DISK_READ_ERROR_MESSAGE)
      else display_dnic(dnic_table, dnic_display_type, sub_dnic_name)
    end (* CMD_OK *)
end (* read_dnic_file *);
$endif INCLUDE_DNIC
!
"
		DISPLAY GLOBAL (CLASS or GROUP) command
"



(**************************  command_level  *****************************)
(*									*)
(*			display_single_global_access			*)
(*									*)
(************************************************************************)

procedure display_single_global_access(
      class_flag	: boolean;
      global_value	: univ integer);

var
  global_access : global_access_description;

begin
  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    begin
      list_utility.read_global_access(class_flag, global_value, global_access);
      if list_utility.last_status = NODE_HOST_OK
      then write_undefined_or_global_access(class_flag, global_access,
        global_value)
      else report_list_status
    end (* scanned.status = CMD_OK *)
end (* display_single_global_access *);



(**************************  command_level  *****************************)
(*									*)
(*			  display_global_access				*)
(*									*)
(************************************************************************)

procedure display_global_access(
      first_value	: integer;
      last_value	: integer;
      class_flag	: boolean (* TRUE if displaying CLASSES *));

var
  first_undefined,
  value : integer;
  global_access : global_access_description;
  undefined : boolean (* TRUE if undefined global accesses to be printed *);

begin
  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    begin
      undefined := FALSE;
      for value := first_value to last_value do
        begin
	  list_utility.read_global_access(class_flag, value, global_access);
	  if list_utility.last_status <> NODE_HOST_OK
	  then
	    begin
	      write_global_access_header(class_flag, value, value);
	      report_list_status
	    end (* list_utility.last_status <> NODE_HOST_OK *)
	  else (* list_utility.last_status = NODE_HOST_OK *)
	    if global_access.count <> 0
	    then
	      begin (* found a defined global_access *)
	        if undefined
		then write_undefined(class_flag, value - 1, first_undefined);
		write_global_access(class_flag, global_access, value);
		undefined := FALSE
	      end (* found a defined global_access *)
	    else (* count = 0, found an undefined global_access *)
	      if not undefined
	      then
	        begin (* first undefined global_access found *)
		  first_undefined := value;
		  undefined := TRUE
		end (* first undefined global_access found *)
	end (* for *);
      if undefined (* if last ones were undefined, output them *)
      then write_undefined(class_flag, last_value, first_undefined)
    end (* scanned.status = CMD_OK *)
end (* display_global_access *);
!

"
		DISPLAY HOSTLIST or NODELIST Command
"



(**************************  command_level  *****************************)
(*									*)
(*			     DISPLAY_LIST				*)
(*									*)
(************************************************************************)

procedure display_list;

var
  keyword : command_keyword_index;
  list_desc : list_descriptor;
  list : validator_named_list_definition;
$if BEFORE_SUP_V43   sort,
  list_values,	(* if TRUE display list names and their entries *)
  done,
  no_lists  : boolean;

begin
  list_desc.host_flag := PRIMARY_DISPLAY_HOSTLIST_KEYWORD = scanned.subcommand;
  list.host_flag := list_desc.host_flag;
  if scanned.freeword_count = 0
  then
    begin (* no list name entered, display ALL lists *)
      list_values := FALSE;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if include_list_descriptions
      if argument_scan.check_keyword(
        PRIMARY_DISPLAY_LIST_DESCRIPTIONS_KEYWORD, scanned)
      then keyword := PRIMARY_DISPLAY_LIST_DESCRIPTIONS_KEYWORD
      else
$endif include_list_descriptions
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      if not argument_scan.check_keyword(
        PRIMARY_DISPLAY_LIST_NAMES_KEYWORD, scanned)
      then list_values := TRUE (* listing entire named list information *)
      else keyword := PRIMARY_DISPLAY_LIST_NAMES_KEYWORD;

      argument_scan.extra_argument_check(scanned);
      if scanned.status = CMD_OK
      then
	begin
	  no_lists := TRUE (* no lists found so far *);
	  list_allocater.start_list(validator, list_desc.host_flag);
$if BEFORE_SUP_V43
	  if list_values
	  then sort := keyword_scan.input_answer(SORT_ALL_QUERY);
$endif BEFORE_SUP_V43
	  format.start;
	  repeat
	    list_allocater.next_list(validator, list_desc.list_ptr, done);
	    if not done
	    then
	      begin (* found a list *)
		list_utility.read_next_list(list_desc, list);
		if list_utility.last_status <> NODE_HOST_OK
		then
		  begin (* list_utility.last_status <> NODE_HOST_OK *)
		    if format.buffer.size <> 0
		    then format.write_line(user_terminal);
		    list_utility.report_status(user_terminal, TRUE,list_desc, 
		      list_utility.last_status);
		    format.start;
		  end (* list_utility.last_status <> NODE_HOST_OK *)
		else
		  if list.named_list.name.size > 0 
		  then (* ignore lists being created *)
		    begin (* list_utility.last_status = NODE_HOST_OK *)
		      no_lists := FALSE;
		      if list_values
		      then
		        begin (* display all information for the list *)
			  sort_named_list(
$if before_sup_v43				FALSE, sort,
			    list);
			  write_named_list(list)
			end (* display all information for the list *)
		      else
		        if keyword = PRIMARY_DISPLAY_LIST_NAMES_KEYWORD
			then
			  begin (* display list names only *)
			    cmd_utility.check_line_length_and_write(
			      list.named_list.name.size + 5, 0, COMMA_SPACE);
			    format.listname(list.named_list.name)
			  end (* display list names only *)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if include_list_descriptions
	                else write_list_name_and_descr(list.named_list)
$endif include_list_descriptions
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
		    end (* list_utility.last_status = NODE_HOST_OK *)
	      end (* found a list *)
	  until done or not user_terminal.sendable;
	  if no_lists
	  then user_terminal.write_quoted_text_line('no lists found\ ')
	  else
	    if not list_values and
	      (keyword = PRIMARY_DISPLAY_LIST_NAMES_KEYWORD)
	    then format.write_line(user_terminal)
	end (* if CMD_OK *)
    end (* scanned.freeword_count = 0 *)
  else
    begin (* display the specified list *)
      freeword_utility.get_listname(0, scanned, list.named_list.name);
      argument_scan.extra_argument_check(scanned);
      if scanned.status = CMD_OK
      then
	begin
	  list_utility.read_list(list_desc, list);
	  if list_utility.last_status <> NODE_HOST_OK
	  then report_list_status
	  else
	    begin
	      sort_named_list(
$if before_sup_v43		TRUE, FALSE,
		list);
	      write_named_list(list)
	    end (* list_utility.last_status = NODE_HOST_OK *)
	end (* scanned.status = CMD_OK *)
    end (* display the specified list *)
end (* display_list *);
!
"
		DISPLAY PARAMETERS Command
"



(**************************  command_level  *****************************)
(*									*)
(*			   display_parameters				*)
(*									*)
(************************************************************************)

procedure display_parameters;

var
  gan : integer;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone reuse_uuns   uun : integer;
$if reuse_uuns
  bit17_usable_uuns : integer;
  bit18_usable_uuns : integer;
  usable_add_back_slots : integer;
  header_info : mudupd_disk_header;
$endif reuse_uuns
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

begin
  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    begin
      param_manager.next_gan_and_uun(gan,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone reuse_uuns       uun);
$if reuse_uuns
	bit17_usable_uuns, bit18_usable_uuns, usable_add_back_slots);
$endif reuse_uuns
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      format.start;
      if INCLUDE_GAN
      then
        begin
	  format.string('Next \');
	  format.string(GAN_PROMPT);
	  format.number(gan, 8);
	  format.newline
	end (* INCLUDE_GAN *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+	*)
$if reuse_uuns
      format.string('17 bit UUNS available: \');
      format.number(bit17_usable_uuns, 10);
      format.newline;
      format.string('18 bit UUNS available: \');
      format.number(bit18_usable_uuns, 10);
      format.newline;
      format.string('Available add back slots: \ ');
      format.number(usable_add_back_slots, 10);
      format.write_line(user_terminal);

      mud_change.get_header_info(header_info);
      if header_info.last_merge = 0
      then user_terminal.write_quoted_text_line(
        'No UUN merge has been performed\')
      else
        begin (* output last merge time *)
	  format.start_message('Last UUN merge completed: \ ');
	  format.time(header_info.last_merge);
	  format.write_line(user_terminal)
	end (* output last merge time *);
$endif reuse_uuns
$if UUNSassignable       format.string('UUNs are assigned by validators\');
$ifnone (UUNSassignable, reuse_uuns)
      format.string('Next UUN: \ ');
      format.number(uun, UUN_RADIX);
$endif (UUNSassignable, reuse_uuns)
$ifnone reuse_uuns
      format.write_line(user_terminal)
$endif reuse_uuns
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+	*)
    end (* scanned.status = CMD_OK *)
end (* display_parameters *);
!
"
		DISPLAY UPDATES Subcommand
"
$if change_by_whom
"moved fromat_time to cmdutl at 11-Sep-87"
$endif
$if INCLUDE_DNIC


(******************  command_level  *************************************)
(*									*)
(*		DISPLAY_NETVAL_DNIC_AGE					*)
(*									*)
(************************************************************************)

procedure display_netval_dnic_age(
  var netval_dnic_exists : boolean);

begin (* display_netval_dnic_age *)
  if mud_change.dnic_date = 0
  then 
    begin (* netval dnic has not been created yet *)
      user_terminal.write_quoted_text_line(
            'Netval DNIC table has not been created\ ');
      netval_dnic_exists := FALSE
    end (* netval dnic has not been sent yet *)
  else
    begin (* output DNIC creation date *)
      netval_dnic_exists := TRUE;
      format.start_message('DNIC table last created: \');
      format.time(mud_change.dnic_date);
      format.write_line(user_terminal)
    end (* output DNIC created date *)
end (* display_netval_dnic_age *);
$endif INCLUDE_DNIC
!



(******************  command_level  *************************************)
(*									*)
(*		DISPLAY_NETVAL_TABLE_AGE				*)
(*									*)
(************************************************************************)

procedure display_netval_table_age(
  var netval_table_exists : boolean);

begin (* display_netval_table_age *)
  if mud_change.table_date = 0
  then 
    begin (* netval table has not been created yet *)
      user_terminal.write_quoted_text_line(
            'Netval Class/group table has not been created\');
      netval_table_exists := FALSE
    end (* netval table has not been created yet *)
  else
    begin (* output class/group table creation date *)
      netval_table_exists := TRUE;
      format.start_message('Class/group table last created: \ ');
      format.time(mud_change.table_date);
      format.write_line(user_terminal)
    end (* output class/group date *)
end (* display_netval_table_age *);



(**************************  command_level  *****************************)
(*									*)
(*			    display_updates				*)
(*									*)
(************************************************************************)

procedure display_updates;

var
  header_info    : mudupd_disk_header;
  sup_core_info  : supervisor_in_core_information;
  real_sup 	 : real_supervisor_index;
  mud_change_eof : integer;
  netval_table_exists,
  none 	 	 : boolean (* TRUE if there are no legal sup *);

begin
  format.start_message('Current time is \ ');
  format.time(REALTIME);
  format.string(UTC_MESSAGE);
  format.newline;
  format.string('Blocks in CUD: \');
  format.number(MAXIMUM_NORMAL_CUD_BLOCK, 10);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if OVERFLOW_CUD_ENTRIES
  format.character(ASCII_SLASH);
  format.number(NUMBER_OF_OVERFLOW_BLOCKS, 10);
$endif OVERFLOW_CUD_ENTRIES
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  format.string('     MUD update EOF: \');
  mud_change_eof := mud_change.mud_change_eof;
  format.number(mud_change_eof, 10);
  format.string(' (\ ');
  format.number(mud_change_eof div (MUDUPD_DATA_MAX div 100), 10);
  format.string('% full)\');
  format.write_line(user_terminal);
  display_netval_table_age(netval_table_exists);
$if INCLUDE_DNIC  display_netval_dnic_age(netval_table_exists);

  mud_change.get_header_info(header_info);

  none := TRUE;
  for real_sup := FIRST_SUPERVISOR to MAXIMUM_REAL_SUPERVISOR do
    if header_info.sup_disc_info[real_sup].state = real_sup (* if sup legal *)
    then
      begin
	if none
	then
	  begin (* write header for information *)
	    user_terminal.write_line_and_quoted_text_line(
	      'Sup                    MUD          CLASS/GROUP\');
	    user_terminal.write_quoted_text_line(
	      '          Ptr        Updated          Updated\');
	    none := FALSE
	  end (* write header for information *);

	with header_info.sup_disc_info[real_sup] do
	  begin (* write MUD and Class/group information *)
	    format.start;
	    format.sup_number(real_sup);
	    format.format_number(pointer, 10, 12);
	    format.skip_to(20);
	    if last_mud_update <> 0
	    then format.short_time(last_mud_update);
	    format.skip_to(37);
	    if last_cg_update <> 0
	    then format.short_time(last_cg_update);
	    format.write_line(user_terminal)
	  end (* write MUD and Class/group information *)
      end (* if sup is legal *);

  if none = TRUE
  then user_terminal.write_line_and_quoted_text_line(NO_LEGAL_SUPS_MESSAGE)
  else
    begin
      user_terminal.write_newline;
      (* write consistency information header *)
      user_terminal.write_quoted_text_line(
'Sup		       CONSISTENCY\');
      user_terminal.write_quoted_text_line(
'     Last Start     Last Stop   End Block	   Current Start   Block\');
(* write consistency info *)
      for real_sup := FIRST_SUPERVISOR to MAXIMUM_REAL_SUPERVISOR do
	if header_info.sup_disc_info[real_sup].state = real_sup
	then
	  begin (* sup legal *)
	    format.start;
	    format.sup_number(real_sup);
	    mud_change.get_sup_update_info(real_sup, sup_core_info);
	    with header_info.sup_disc_info[real_sup] do
	      if history.consistency.start_date <> 0
	      then
		begin (* write consistency history, if any *)
		  format.skip(2);
		  format.short_time(history.consistency.start_date);
		  format.skip(3);
		  format.short_time(history.stop_date);
		  format.skip(2);
		  if history.consistency.block = CUD_BLOCK_LIMIT
		  then format.string('complete\ ')
		  else format.format_number(history.consistency.block, 10, 6);
		  format.skip_to(42);
		  if history.consistency.manual
		  then format.string('M \ ')
		  else format.string('  \ ');
		  if history.consistency.stopped
		  then format.string('S\')
		end (* write consistency history, if any *);

	    format.skip_to(52);

	    with sup_core_info.consistency do
	      if start_date <> 0
	      then
		begin (* write current consistency info, if any *)
		  format.short_time(start_date);
		  format.format_number(block, 10, 8);
		  if manual
		  then format.string(' M\ ')
		  else
		    if sup_core_info.run_init_auto_consistency
		    then format.string(' I\ ')
		end (* write current consistency info, if any *);

	    format.write_line(user_terminal)
	  end (* sup legal *)
    end (* legal sups exist *)
end (* display_updates *);
!
"
		DISPLAY USER Subcommand
"



(**********************  command_level  *********************************)
(*									*)
(*			 DISPLAY_USER		    			*)
(*									*)
(*	Prompts for a username and displays their cud entry, if found   *)
(*									*)
(************************************************************************)

procedure display_user;

var
$if BEFORE_SUP_V43   cud_entry : cud_user_entry;
$ifnone BEFORE_SUP_V43
  mud_entry : mud_user_entry;
  nud_entry : nud_user_entry;
$endif BEFORE_SUP_V43
  success : boolean;

begin
  get_and_access_name(FALSE,
$if BEFORE_SUP_V43   cud_entry,
$ifnone BEFORE_SUP_V43   mud_entry, nud_entry,
    success);
  if success
$if BEFORE_SUP_V43   then write_cud_entry(cud_entry)
$ifnone BEFORE_SUP_V43   then write_cud_entry(mud_entry, nud_entry)
end (* display_user *);
!



(***************************  command_level  ****************************)
(*									*)
(*			      scan_display				*)
(*									*)
(*	Scans display command and calls appropriate subcommand		*)
(*									*)
(************************************************************************)

procedure scan_display;

var
  class_number : integer;
  group_number : integer;
  repeat_display : boolean;
  delay_value : integer;
  time_for_next_display : integer;

begin
  case scanned.subcommand of

    PRIMARY_DISPLAY_CLASS_KEYWORD:
      if scanned.freeword_count = 0
      then display_global_access(FIRST_CLASS, MAXIMUM_CLASS, TRUE)
      else
        begin
	  freeword_utility.get_class(0, scanned, class_number);
	  display_single_global_access(TRUE, class_number)
	end (* PRIMARY_DISPLAY_CLASS_KEYWORD *);

    PRIMARY_DISPLAY_CUD_KEYWORD: cmd_utility.display_block(TRUE, scanned);

    PRIMARY_DISPLAY_DIRECTORY_KEYWORD: cmd_utility.display_directory(scanned);

(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if INCLUDE_DNIC
    PRIMARY_DISPLAY_DNIC_KEYWORD: read_dnic_file;

$endif INCLUDE_DNIC
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    PRIMARY_DISPLAY_FILTER_KEYWORD: filter_util.display_filters;

(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if force_password_change
    PRIMARY_DISPLAY_GANPASS_KEYWORD: cmd_utility.display_ganpass(scanned);

$endif force_password_change
$if global_password_only_login
    PRIMARY_DISPLAY_GPOGAN_KEYWORD: cmd_utility.display_gpogan(scanned);

$endif global_password_only_login
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    PRIMARY_DISPLAY_GROUP_KEYWORD:
      if scanned.freeword_count = 0
      then display_global_access(FIRST_GROUP, MAXIMUM_GROUP, FALSE)
      else
        begin
	  freeword_utility.get_group(0, scanned, group_number);
	  display_single_global_access(FALSE, group_number)
	end (* PRIMARY_DISPLAY_GROUP_KEYWORD *);

    PRIMARY_DISPLAY_HOSTLIST_KEYWORD,
    PRIMARY_DISPLAY_NODELIST_KEYWORD: display_list;

    PRIMARY_DISPLAY_MUD_KEYWORD: cmd_utility.display_block(FALSE, scanned);

    PRIMARY_DISPLAY_PARAMETERS_KEYWORD: display_parameters;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if prevent_duplicate_passwords

    PRIMARY_DISPLAY_PASSPERIOD_KEYWORD:
      begin
	argument_scan.extra_argument_check(scanned);
	if scanned.status = CMD_OK
	then cmd_utility.display_passperiod
      end (* PRIMARY_DISPLAY_PASSPERIOD_KEYWORD *);
$endif prevent_duplicate_passwords
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

    PRIMARY_DISPLAY_SCHEDULE_KEYWORD: cmd_utility.display_schedule(scanned);

    PRIMARY_DISPLAY_SELECT_KEYWORD:
      begin
	argument_scan.extra_argument_check(scanned);
	if scanned.status = CMD_OK
	then cmd_utility.display_select
      end (* PRIMARY_DISPLAY_SELECT_KEYWORD *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if password_expiration_by_user

    PRIMARY_DISPLAY_VALIDITY_KEYWORD:
      begin
        argument_scan.extra_argument_check(scanned);
	if scanned.status = CMD_OK
	then cmd_utility.display_validity
      end (* PRIMARY_DISPLAY_VALIDITY_KEYWORD *);
$endif password_expiration_by_user
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

    PRIMARY_DISPLAY_UPDATES_KEYWORD:
      begin
        repeat_display := argument_scan.check_keyword(
	  PRIMARY_DISPLAY_UPDATES_REPEAT_KEYWORD, scanned);
	if repeat_display
	then
	  if scanned.freeword_count = 0 (* no value entered *)
	  then delay_value := 60 (* default is 1 minute (in seconds) *)
	  else freeword_utility.get_numeric_freeword_value(0, 10,
	    0, MAX_INTEGER, scanned, delay_value);
	argument_scan.extra_argument_check(scanned);
	if scanned.status = CMD_OK
	then
	  repeat
	    display_updates;
	    if repeat_display and user_terminal.sendable
	    then
	      begin (* wait until time to do another display *)
	        user_terminal.write_newline;
	        time_for_next_display := REALTIME + delay_value;
		repeat
		  user_terminal.check_circuit; wait
		until not user_terminal.sendable or
		  (REALTIME > time_for_next_display)
	      end (* wait until time to do another display *)
	  until not user_terminal.sendable or not repeat_display 
      end (* PRIMARY_DISPLAY_UPDATES_KEYWORD *);

    PRIMARY_DISPLAY_USER_KEYWORD: display_user
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if logical_volumes
;

    PRIMARY_DISPLAY_VOLUMES_KEYWORD:
      begin
	argument_scan.extra_argument_check(scanned);
	if scanned.status = CMD_OK
	then lv_dialogue.display_lvol
      end (* PRIMARY_DISPLAY_VOLUMES_KEYWORD *)
$endif logical_volumes
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    end (* case *)
end (* scan_display *);
!
"
		HOST Commands
"



(***************************  command_level  ****************************)
(*									*)
(*			   set_host_state				*)
(*									*)
(************************************************************************)

procedure set_host_state(
      new_state	: host_state);

begin
  if new_state = UP_STATE
  then
    begin (* confirm node and kernel host for this system *)
      cmd_utility.display_host_info;
      if not keyword_scan.input_answer(CONTINUE_MESSAGE)
      then scanned.status := RUN_ERROR;
      user_terminal.write_newline
    end (* confirm node and kernel host for this system *);
  if scanned.status = CMD_OK
  then
    begin
      sys_io.set_host_state(new_state);
      user_terminal.write_quoted_text_line(ENTRY_COMPLETED);
      format.start_message('Host state set to \ ');
      format.host_state_name(new_state);
      oper_messages.report_validator_message(profile)
    end (* scanned.status = CMD_OK *)
end (* set_host_state *);
!
"
		NEW ACCESS Command
"
(*		see procedure get_access_entry		*)
$if INCLUDE_DNIC
!
"
		NEW DNIC Command
"



(****************************  command_level  ***************************)
(*									*)
(*				  new_dnic				*)
(*									*)
(************************************************************************)

procedure new_dnic;

var
  non_default_data : dnic_data;
  dnic_table : dnic_data_table;
  success : boolean;
  default_dnic : boolean;
  found : boolean;
  dnic_index : non_default_data_index;

begin
  argument_scan.extra_argument_check(scanned);
  if user_terminal.sendable and (scanned.status = CMD_OK)
  then
    if not mud_change.add_dnic_count
    then user_terminal.write_quoted_text_line('DNIC table is full\ ')
    else
    begin
      freeword_utility.prompt_dnicname('Enter non-default DNIC: \ ',
        non_default_data.name);
      get_dnic_entry(non_default_data.name, dnic_table,
	dnic_index, default_dnic, found, success);
      if (not found) and success
      then
	begin
	  get_non_default_dnic(non_default_data);
	  if entries_correct(TRUE)
	  then
	    begin
	      insert_dnic(non_default_data, dnic_table.non_default);
	      write_dnic_file(dnic_table)
	    end
	  else success := mud_change.sub_dnic_count
	end
      else
	if found and success
	then
	  begin
	    success := mud_change.sub_dnic_count;
	    user_terminal.write_quoted_text_line('DNIC already exists\')
	  end
	else success := mud_change.sub_dnic_count
    end (* CMD_OK *)
end (* new_dnic *);
$endif INCLUDE_DNIC
!
"
		NEW HOSTLIST and NODELIST Command
"



(****************************  command_level  ***************************)
(*									*)
(*				  new_list				*)
(*									*)
(************************************************************************)

procedure new_list;

var
  this_list : validator_named_list_definition;

begin
  this_list.host_flag := scanned.subcommand = PRIMARY_NEW_HOSTLIST_KEYWORD;
  freeword_utility.get_listname(0, scanned, this_list.named_list.name);
  argument_scan.extra_argument_check(scanned);
  if user_terminal.sendable and (scanned.status = CMD_OK)
  then
    begin
      list_utility.create_list(this_list);
      if list_utility.last_status <> NODE_HOST_OK
      then report_list_status
      else
	begin (* list_utility.last_status = NODE_HOST_OK *)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if include_list_descriptions
	  get_list_description(this_list.named_list.description);
$endif include_list_descriptions
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	  this_list.named_list.count := 0;
$if BEFORE_SUP_V43	    this_list.sorted := TRUE;
	  if user_terminal.sendable
	  then add_to_named_list(this_list);
	  if user_terminal.sendable
	  then update_list(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if include_list_descriptions 	    FALSE,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	    this_list)
	  else list_utility.abort
	end (* list_utility.last_status = NODE_HOST_OK *)
    end (* user_terminal.sendable and (scanned.status = CMD_OK) *)
end (* new_list *);
!
"
		NEW USER Command
"



(****************************  command_level  ***************************)
(*									*)
(*			      validate_user				*)
(*									*)
(************************************************************************)

procedure validate_user(
$if UUNSassignable      new_user_as_old	: boolean (* TRUE = NEW USER AS cmd *);
$if BEFORE_SUP_V43   var cud_entry		: cud_user_entry);
$ifnone BEFORE_SUP_V43
$if password_expiration_by_user       validity_period	: integer;
  var mud_entry		: mud_user_entry;
  var nud_entry		: nud_user_entry);
$endif BEFORE_SUP_V43

var
  new_account : boolean;

begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+	*)
$if UUNSassignable
  if not new_user_as_old or ASSIGN_UUN_ON_NEW_USER_AS
$if BEFORE_SUP_V43   then freeword_utility.prompt_uun(scanned, cud_entry.uun);
$ifnone BEFORE_SUP_V43
  then freeword_utility.prompt_uun(scanned,  mud_entry.uun);
$endif BEFORE_SUP_V43
$endif UUNSassignable
$if BEFORE_SUP_V43
$ifnone UUNSassignable   cud_entry.uun := 0;
  cud_entry.entry_change_date := 0;
  cud_entry.password_change_date := 0;
$endif BEFORE_SUP_V43
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+	*)
$ifnone BEFORE_SUP_V43
$ifnone UUNSassignable   mud_entry.uun := 0;
  nud_entry.entry_change_date := 0;
  nud_entry.password_change_date := 0;
$if password_expiration_by_user   mud_entry.password.expire_date := 0;
$if prevent_duplicate_passwords
(* clear PREVIOUS_PASSWORD_STORED in case this is NEW_USER_AS_OLD command *)
  nud_entry.nud_options := nud_entry.nud_options - [PREVIOUS_PASSWORD_STORED];
  nud_entry.previous_cipher := NO_PREVIOUS_CIPHER;
$endif prevent_duplicate_passwords
$endif BEFORE_SUP_V43
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+	*)
  user_terminal.write_newline;
$if BEFORE_SUP_V43   write_cud_entry(cud_entry);
$ifnone BEFORE_SUP_V43   write_cud_entry(mud_entry, nud_entry);
  if not entries_correct(TRUE)
  then cud_updater.abort_cud_change
  else
    begin (* entries_correct *)
$if BEFORE_SUP_V43
      if INCLUDE_GAN
      then new_account := cud_entry.gan = 0
      else new_account := FALSE;
$endif BEFORE_SUP_V43
$ifnone BEFORE_SUP_V43
      if INCLUDE_GAN
      then new_account := nud_entry.gan = 0
      else new_account := FALSE;
      nud_entry.entry_change_date := REALTIME;
      nud_entry.password_change_date := nud_entry.entry_change_date;
$endif BEFORE_SUP_V43
$if password_expiration_by_user
      if (not (EXEMPT_FROM_PASSWORD_EXPIRATION in nud_entry.nud_options)) and
        (not (NO_PASSWORD_REQUIRED in mud_entry.mud_options))
      then
        if NON_STANDARD_PASSWORD_EXPIRATION in nud_entry.nud_options
	then mud_entry.password.expire_date := nud_entry.password_change_date +
	  validity_period
	else
	  if validity_period <> NO_VALIDITY_PERIOD (* from NEW USER AS Cmd *)
	  then mud_entry.password.expire_date :=
	    nud_entry.password_change_date +
	    mud_change.standard_password_validity_in_seconds;
$endif password_expiration_by_user
      cud_updater.new_cud_entry(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if reuse_uuns       FALSE,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if BEFORE_SUP_V43        cud_entry);
$ifnot BEFORE_SUP_V43        mud_entry, nud_entry);
      if cud_updater.last_status = CUD_ENTRY_OK
      then
	begin
	  user_terminal.write_newline;
	  if new_account
	  then
	    begin
	      format.start_message(GAN_PROMPT);
$if BEFORE_SUP_V43 	      format.number(cud_entry.gan, 8);
$ifnone BEFORE_SUP_V43 	      format.number(nud_entry.gan, 8);
	      format.write_line(user_terminal)
	    end (* new_account *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+	*)
$ifnone UUNSassignable
	  format.start_message(UUN_PROMPT);
$if BEFORE_SUP_V43   format.number(cud_entry.uun, UUN_RADIX);
$ifnone BEFORE_SUP_V43   format.number(mud_entry.uun, UUN_RADIX);
	  format.write_line(user_terminal);
$endif UUNSassignable
$if password_expiration_by_user
	  password_command.display_password_expiration_date(
	    mud_entry.password.expire_date)
$endif password_expiration_by_user
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+	*)
	end (* cud_updater.last_status = CUD_ENTRY_OK *);
      cud_utility.print_cud_entry_message
    end (* entries correct *)
end (* validate_user *);



(****************************  command_level  ***************************)
(*									*)
(*				 new_user				*)
(*									*)
(************************************************************************)

procedure new_user
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if validate_x25_names
(
      this_is_x25_name	: boolean)
$endif validate_x25_names
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
;

var
  success : boolean;
$if BEFORE_SUP_V43   cud_entry : cud_user_entry;
$ifnone BEFORE_SUP_V43
  mud_entry : mud_user_entry;
  nud_entry : nud_user_entry;
$endif BEFORE_SUP_V43
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if validate_x25_names  link_host : integer;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

begin
(* first get new account information *)
$if BEFORE_SUP_V43   cud_entry.gan := 0;
$ifnone BEFORE_SUP_V43   nud_entry.gan := 0;
  if INCLUDE_GAN
  then
    if profile.level = ACCOUNT_SUPERVISOR_VALIDATOR
$if BEFORE_SUP_V43   then cud_entry.gan := profile.gan
$ifnone BEFORE_SUP_V43   then nud_entry.gan := profile.gan
    else
      if not keyword_scan.input_answer(
	'does this user belong to a new account\ ')
      then
	if user_terminal.sendable
	then
	  repeat
	    freeword_utility.prompt_username('enter name in account: \',
$if BEFORE_SUP_V43   cud_entry.name);
$ifnone BEFORE_SUP_V43   mud_entry.name);
	    if user_terminal.sendable
$if BEFORE_SUP_V43   then read_user_entry(cud_entry)
$ifnone BEFORE_SUP_V43   then read_user_entry(mud_entry, nud_entry)
	  until (cud_updater.last_status <> CUD_ENTRY_NOT_FOUND)
	    or not user_terminal.sendable;
  if user_terminal.sendable
  then get_and_reserve_name(USERNAME_QUERY,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if validate_x25_names     this_is_x25_name, link_host,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if BEFORE_SUP_V43   cud_entry.name, success);
$ifnone BEFORE_SUP_V43   mud_entry.name, success);
  if user_terminal.sendable
  then
    if success
    then
      begin
$if BEFORE_SUP_V43 	cud_entry.options := [];
$ifnone BEFORE_SUP_V43
	mud_entry.mud_options := [];
	nud_entry.nud_options := [];
$endif BEFORE_SUP_V43
	get_options(
$if validate_x25_names 	  this_is_x25_name,
$if BEFORE_SUP_V43   cud_entry.options);
$ifnone BEFORE_SUP_V43         mud_entry.mud_options, nud_entry.nud_options);
$if password_expiration_by_user
$ifnot assign_password_expiration_as_default
	if not (NO_PASSWORD_REQUIRED in mud_entry.mud_options)
	then nud_entry.nud_options := [EXEMPT_FROM_PASSWORD_EXPIRATION];
$endif assign_password_expiration_as_default
$endif password_expiration_by_user
	if user_terminal.sendable and
$if BEFORE_SUP_V43 	not (NO_PASSWORD_REQUIRED in cud_entry.options)
$ifnot BEFORE_SUP_V43
	  (not (NO_PASSWORD_REQUIRED in mud_entry.mud_options) and
	  (USERNAME_TYPE in mud_entry.mud_options))
$endif BEFORE_SUP_V43
	then
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if validate_x25_names
	  if this_is_x25_name
	  then
	    begin
	      user_terminal.write_line_and_quoted_text_line(
		'assigning null password\');
$if BEFORE_SUP_V43 	      cud_entry.password := 0
$ifnone BEFORE_SUP_V43 	      mud_entry.password.cipher := 0
	    end
	  else
$endif validate_x25_names
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	  password_read.get_new_cipher(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone name_legal_password
$if BEFORE_SUP_V43 	    cud_entry.name,
$ifnone BEFORE_SUP_V43	        mud_entry.name,
$endif name_legal_password
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	    -1,
$if prevent_duplicate_passwords	       NO_PREVIOUS_CIPHER,
$if global_password_only_login	     0, FALSE,
$if BEFORE_SUP_V43	    cud_entry.password,
$ifnone BEFORE_SUP_V43	    mud_entry.password.cipher,
	    success);
	if user_terminal.sendable
$if BEFORE_SUP_V43
	then freeword_utility.prompt_district(scanned, cud_entry.district);
	cud_entry.access_profile.count := 0;
$endif BEFORE_SUP_V43
$ifnone BEFORE_SUP_V43	
	then freeword_utility.prompt_district(scanned, nud_entry.district);
	mud_entry.mud_access_profile.count := 0;
	mud_entry.allowable_times := [ALL_HOURS];
$endif BEFORE_SUP_V43
$if restrict_users_by_time
	if user_terminal.sendable
	then freeword_utility.prompt_allowable_times(scanned,
	  mud_entry.allowable_times);
$endif restrict_users_by_time
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

	if user_terminal.sendable
	then get_access_profile(
$if validate_x25_names     this_is_x25_name, link_host,
$if BEFORE_SUP_V43   cud_entry.options, cud_entry.access_profile);
$ifnone BEFORE_SUP_V43 	mud_entry.mud_options, mud_entry.mud_access_profile);
$ifnone BEFORE_SUP_V43
	mud_entry.entry_type := MINIMUM_ENTRY;
$if password_expiration_by_user
$if assign_password_expiration_as_default
	if not (NO_PASSWORD_REQUIRED in mud_entry.mud_options)
	then mud_entry.entry_type := EXPIRE_DATE_IRC_ENTRY;
$endif assign_password_expiration_as_default
$endif password_expiration_by_user
$endif BEFORE_SUP_V43
$if include_irc
$if BEFORE_SUP_V43 	cud_entry.irc := 0;
$ifnone BEFORE_SUP_V43 	mud_entry.irc := 0;
$endif include_irc
$if restrict_users_by_time
	if mud_entry.allowable_times <> [ALL_HOURS]
	then mud_entry.entry_type := TIME_RESTRICTED_ENTRY;
$endif restrict_users_by_time
	if user_terminal.sendable
	then validate_user(
$if UUNSassignable	  FALSE,
$if BEFORE_SUP_V43          cud_entry)
$ifnone BEFORE_SUP_V43
$if password_expiration_by_user 	  0, (* use standard valid. per. *)
	  mud_entry, nud_entry)
$endif BEFORE_SUP_V43
	else cud_updater.abort_cud_change
      end (* success *)
end (* new_user *);



(****************************  command_level  ***************************)
(*									*)
(*			check_for_0_class_or_group			*)
(*									*)
(************************************************************************)

procedure check_for_0_class_or_group(
      access_entry	: access_entry_description;
  var found		: boolean);

var
  dest_index : destination_index (* to scan thru destinations *);

begin
  if not access_entry.in_place_origin
  then
    if access_entry.class_no = 0
    then found := TRUE (* zero CLASS found *);
  for dest_index := 0 to access_entry.destination.size - 1 do
    if access_entry.destination.list[dest_index].group_flag and
      (access_entry.destination.list[dest_index].value = 0)
    then found := TRUE (* zero GROUP found *)
end (* check_for_0_class_or_group *);



(****************************  command_level  ***************************)
(*									*)
(*			      new_user_as_old				*)
(*									*)
(*	The validator wants to validate a new user with all the		*)
(*	characteristics of an old user name.  A password must be	*)
(*	assigned to the new username if the control options specify one.*)
(*	If the validator is an account supervisor:			*)
(*		- the old user must be in the same GAN			*)
(*		- if CLASS_0_GROUP_0_ASSIGNABLE is FALSE, the old user	*)
(*		  may not have class 0 or group 0 in his access profile	*)
(*									*)
(************************************************************************)

procedure new_user_as_old(
      old_name	: username_string);

var
  success : boolean;
  found : boolean (* TRUE if class 0 or group 0 was found *);
  index : access_entry_index (* to scan thru access entries *);
$if BEFORE_SUP_V43   cud_entry : cud_user_entry;
$ifnone BEFORE_SUP_V43
  mud_entry : mud_user_entry;
  nud_entry : nud_user_entry;
$if password_expiration_by_user   validity_period : integer;
$endif BEFORE_SUP_V43
$if validate_x25_names   dummy_link_host : integer;

begin
$if BEFORE_SUP_V43
  cud_entry.name := old_name;
  read_user_entry(cud_entry) (* get information about OLD user *);
$endif BEFORE_SUP_V43
$ifnone BEFORE_SUP_V43
  mud_entry.name := old_name;
  read_user_entry(mud_entry, nud_entry) (* get information about OLD user *);
$endif BEFORE_SUP_V43
  if cud_updater.last_status = CUD_ENTRY_OK
  then
$if INCLUDE_GAN
    if not profile.access_to_gan(
$if BEFORE_SUP_V43    cud_entry.gan,
$ifnone BEFORE_SUP_V43    nud_entry.gan,
      TRUE)
    then user_terminal.write_quoted_text_line(NO_ACCESS_TO_USER)
    else
$endif INCLUDE_GAN
      begin (* validator has access to old username *)
        success := TRUE;
        if not CLASS_0_GROUP_0_ASSIGNABLE and
	  (profile.level = ACCOUNT_SUPERVISOR_VALIDATOR)
	then
	  begin (* check for zero class or group *)
	    found := FALSE;
	    for index := 0 to
$if BEFORE_SUP_V43
	    cud_entry.access_profile.count - 1 do
	      check_for_0_class_or_group(
	        cud_entry.access_profile.entries[index], found);
$endif BEFORE_SUP_V43
$ifnone BEFORE_SUP_V43
	    mud_entry.mud_access_profile.count - 1 do
	      check_for_0_class_or_group(
	        mud_entry.mud_access_profile.entries[index], found);
$endif BEFORE_SUP_V43
	    if found
	    then
	      begin
	        success := FALSE;
		user_terminal.write_quoted_text_line(
'old user has a zero class or group value and cannot be used\')
	      end
	  end (* check for zero class or group *);
	if success
	then get_and_reserve_name(USERNAME_QUERY,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if validate_x25_names 	 	FALSE, dummy_link_host,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if BEFORE_SUP_V43   cud_entry.name, success);
$ifnone BEFORE_SUP_V43   mud_entry.name, success);
	if success
	then
	  begin
$if BEFORE_SUP_V43    if not (NO_PASSWORD_REQUIRED in cud_entry.options)
$ifnone BEFORE_SUP_V43   if not (NO_PASSWORD_REQUIRED in mud_entry.mud_options)
	    then password_read.get_new_cipher(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone name_legal_password
$if BEFORE_SUP_V43 	      cud_entry.name,
$ifnone BEFORE_SUP_V43     	      mud_entry.name,
$endif name_legal_password
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	      -1,
$if prevent_duplicate_passwords	       NO_PREVIOUS_CIPHER,
$if global_password_only_login	      0, FALSE,
$if BEFORE_SUP_V43	     cud_entry.password,
$ifnone BEFORE_SUP_V43   	     mud_entry.password.cipher,
	       success);
$if password_expiration_by_user
	      if not (EXEMPT_FROM_PASSWORD_EXPIRATION in nud_entry.nud_options)
	      then
	        if NON_STANDARD_PASSWORD_EXPIRATION in nud_entry.nud_options
(* use old users validity period... *)
		then validity_period := mud_entry.password.expire_date -
		  nud_entry.password_change_date
		else (* if old entry has no expiration date, same for new *)
		  if mud_entry.password.expire_date = 0
		  then validity_period := NO_VALIDITY_PERIOD;
$endif password_expiration_by_user
	    validate_user(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+	*)
$if UUNSassignable	      TRUE,
$if BEFORE_SUP_V43   cud_entry)
$ifnone BEFORE_SUP_V43
$if password_expiration_by_user 	      validity_period,
	      mud_entry, nud_entry)
$endif BEFORE_SUP_V43
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+	*)
	  end (* success *)
      end (* validator has access to gan *)
end (* new_user_as_old *);
!




(**************************  command_level  *****************************)
(*									*)
(*			make_table_value_header				*)
(*									*)
(************************************************************************)

procedure make_table_value_header(
      exception		: boolean;
      host_flag		: boolean;
  var start_line	: format_buffer_text_index);

begin
  if format.buffer.size <> 0
  then format.write_line(user_terminal);
  format.start_message('  \ ');
  if host_flag
  then format.string(HOST_MESSAGE)
  else format.string(NODE_MESSAGE);
  format.character(LOWER_CASE_S);
  if exception
  then format.string(' except\');
  format.colon_space;
  start_line := format.buffer.size
end (* make_table_value_header *);



(**************************  command_level  *****************************)
(*									*)
(*			extract_flag_and_value				*)
(*									*)
(************************************************************************)

procedure extract_flag_and_value(
      source_halfword	: halfword;
  var flag		: boolean;
  var value		: univ integer);

var
  temp : integer;

begin
  mutil.save_halfword_in_word(source_halfword, temp);
  if not mutil.test_bit(BIT16, temp)
$if BEFORE_SUP_V43  then flag := FALSE
(* if BEFORE_SUP_V43 is disabled, bit on indicates node *)
$ifnot BEFORE_SUP_V43  then flag := TRUE
  else
    begin (* bit is on *)
$ifnot BEFORE_SUP_V43      flag := FALSE;
$if BEFORE_SUP_V43      flag := TRUE;
      mutil.clear_bit(BIT16, temp)
    end (* bit is on *);
  value := temp
end (* extract_flag_and_value *);



(**************************  command_level  *****************************)
(*									*)
(*			  write_table_entries				*)
(*									*)
(************************************************************************)

procedure write_table_entries(
      class_flag	: boolean;
      global_value	: univ integer;
      table		: class_group_table;
  var undefined		: boolean;
  var first_undefined	: integer);

var
  start_line : format_buffer_text_index;
  first_value,
  last_value,
  value_index,
  value : integer;
  count : halfword;
  exception,
  host_flag,	(* this value is a host *)
  hosts : boolean (* TRUE if outputting hosts *);

begin
  if class_flag
  then count := table.class_defs[global_value].count
  else
    begin
      count := table.group_defs[global_value].count;
      host_flag := TRUE
    end (* class_flag is FALSE *);
  if count <> ZERO_HALFWORD
  then
    begin
      if undefined
      then write_undefined(class_flag, global_value - 1, first_undefined);
      undefined := FALSE;
      if class_flag
      then
	begin
	  mutil.save_halfword_in_word(table.class_defs[global_value].index,
	    first_value);
	  first_value := (first_value-FIRST_TABLE_CLASS_VALUE_POINTER) div 2;
$if BEFORE_SUP_V43
	  extract_flag_and_value(table.class_defs[global_value].count,
	    exception, value)
$endif BEFORE_SUP_V43
$ifnot BEFORE_SUP_V43
	  mutil.save_halfword_in_word(
	    table.class_defs[global_value].count, value);
	  exception :=
$if REQUEST_GLOBAL_EXCEPTION        FALSE
$ifnot REQUEST_GLOBAL_EXCEPTION  list_utility.global_exception(TRUE, global_value)
$endif BEFORE_SUP_V43
	end (* class_flag *)
      else
	begin (* not class_flag *)
	  mutil.save_halfword_in_word(table.group_defs[global_value].index,
	    first_value);
	  first_value := (first_value-FIRST_TABLE_GROUP_VALUE_POINTER) div 2;
$if BEFORE_SUP_V43
	  extract_flag_and_value(table.group_defs[global_value].count,
	    exception, value)
$endif BEFORE_SUP_V43
$ifnot BEFORE_SUP_V43
	  mutil.save_halfword_in_word(
	    table.group_defs[global_value].count, value);
	  exception :=
$if REQUEST_GLOBAL_EXCEPTION        FALSE
$ifnot REQUEST_GLOBAL_EXCEPTION  list_utility.global_exception(FALSE, global_value)
$endif BEFORE_SUP_V43
	end (* not class_flag *);
      last_value := (first_value + (value div 2)) - 1;
      write_global_access_header(class_flag, global_value, global_value);
      format.start_and_newline;
      for value_index := first_value to last_value do
	begin
	  if class_flag
  	  then extract_flag_and_value(table.class_values[value_index],
	    host_flag, value)
  	  else mutil.save_halfword_in_word(table.group_values[value_index],
	    value);
	  if value_index = first_value
	  then
	    begin
	      make_table_value_header(exception, host_flag, start_line);
	      hosts := host_flag
	    end (* value_index = first_value *)
	  else
  	    if not host_flag and hosts
	    then
	      begin
		hosts := FALSE;
		make_table_value_header(exception, host_flag, start_line)
	      end (* not host_flag and hosts *);
	  cmd_utility.check_line_length_and_write(MAX_HOST_OUTPUT + 4,
	    start_line, COMMA_SPACE);
	  if host_flag
	  then format.number(value, 10)
	  else format.number(value, 8)
	end (* for *);
      format.newline;
      format.write_line(user_terminal)
    end (* count <> ZERO_HALFWORD *)
  else (* zero count *)
    if not undefined
    then
      begin (* found an undef'd class, and the previous was not undef'd *)
	first_undefined := global_value;
	undefined := TRUE
      end (* found an undef'd class, and the previous was not undef'd *)
end (* write_table_entries *);



(**************************  command_level  *****************************)
(*									*)
(*			   display_table				*)
(*									*)
(************************************************************************)

procedure display_table(
      table		 : class_group_table;
      table_display_type : class_group_table_display_type;
      sub_table_number   : integer);
      
var
  class_no 	  : class_index;
  group_no 	  : group_index;
  first_undefined : integer;
  undefined 	  : boolean (* TRUE if any undef'd classes to be printed *);

begin (* display_table *)
  undefined := FALSE;
  if table_display_type = ENTIRE_TABLE
  then
    begin (* display entire Class_Group_Table *)
      for class_no := FIRST_CLASS to MAXIMUM_CLASS do
        if user_terminal.sendable
          then write_table_entries(TRUE, class_no, table, undefined,
                  			first_undefined);
      if undefined
      then write_undefined(TRUE, MAXIMUM_CLASS, first_undefined);

      user_terminal.write_newline; 
      undefined := FALSE;
      for group_no := FIRST_GROUP to MAXIMUM_GROUP do
        if user_terminal.sendable
        then write_table_entries(FALSE, group_no, table, undefined,
      					first_undefined);
      if undefined
      then write_undefined(FALSE, MAXIMUM_GROUP, first_undefined)
    end (* display entire Class_Group_Table *)
  else
    begin (* display a single class or group *)	  
      write_table_entries(table_display_type = ONLY_ONE_CLASS, 
				sub_table_number, table, undefined, 
				first_undefined);
      if undefined
      then write_undefined(table_display_type = ONLY_ONE_CLASS, 
				first_undefined, first_undefined)
    end (* display a single class or group *);	 
end (* display_table *);




(**************************  command_level  *****************************)
(*									*)
(*			display_available_table_space			*)
(*									*)
(************************************************************************)

procedure display_available_table_space(
      msg	: quoted_text;
      count	: integer);

begin
  format.start_message(msg);
  format.string(' available: \ ');
  format.number(count, 10);
  format.write_line(user_terminal)
end (* display_available_table_space *);



(**************************  command_level  *****************************)
(*									*)
(*			   read_netval_table				*)
(*									*)
(************************************************************************)

procedure read_netval_table(
      table_display_type 	: class_group_table_display_type;
      sub_table_number		: integer);

var
  table 		: class_group_table;
  class_list_index 	: table_class_list_index;
  available 		: integer;
  group_list_index 	: table_group_list_index;
  done,
  success,
  netval_table_exists	: boolean;

begin  (* read_netval_table *);
  display_netval_table_age(netval_table_exists);
  user_terminal.write_newline;
  if netval_table_exists
  then
    begin (* netval table exists *)
      table_access.read_table(table, success);
      if not success
      then user_terminal.write_quoted_text_line(DISK_READ_ERROR_MESSAGE)
      else
        if table_display_type = ENTIRE_TABLE
        then
          begin (* disc read OK, compute and display "available" *)
              done := FALSE; 
              class_list_index := 0;
              repeat (* compute "available" for class_table *)
                if table.class_values[class_list_index] = ZERO_HALFWORD
	        then
	          begin (* zero value found *)
	            done := TRUE;
	            available := MAXIMUM_TABLE_CLASS_LIST_HALFWORD_SIZE -
	                             class_list_index
	          end (* zero value found *)
	        else
	          if class_list_index = TABLE_CLASS_LIST_HALFWORD_LIMIT
	          then
	            begin (* list is full *)
	              done := TRUE;
	              available := 0
	            end (* list is full *)
	          else class_list_index := class_list_index + 1
              until done (* compute "available" for class_table *);
              display_available_table_space('Origins\', available);

              done := FALSE; 
              group_list_index := 0;
              repeat (* compute "available" for group_table *);
                if table.group_values[group_list_index] = ZERO_HALFWORD
	        then
	          begin (* zero value found *)
	            done := TRUE;
	            available := MAXIMUM_TABLE_GROUP_LIST_HALFWORD_SIZE -
	                 	     group_list_index
	          end (* zero value found *)
	        else
	          if group_list_index = TABLE_GROUP_LIST_HALFWORD_LIMIT
	          then
	            begin (* list is full *)
	              done :=TRUE;
	              available := 0
	            end (* list is full *)
	          else group_list_index := group_list_index + 1
              until done (* compute "available" for group_table *);
              display_available_table_space('Destinations\ ', available);
	      user_terminal.write_newline
          end (* disc read OK, compute and display "available" *);

          display_table(table, table_display_type, sub_table_number)
    end (* netval table exists *)
end (* read_netval_table *);



(**************************  command_level  *****************************)
(*									*)
(*			 read_supervisor_table				*)
(*									*)
(************************************************************************)

procedure read_supervisor_table(
      real_sup			: real_supervisor_index;
      table_display_type	: class_group_table_display_type;
      sub_table_number		: integer);

var
  table  	: class_group_table;
  status 	: sysmsg1_status;
  header_info 	: mudupd_disk_header;

begin (* read_supervisor_table *)
  mud_change.get_header_info(header_info);
  with header_info.sup_disc_info[real_sup] do
    if last_cg_update <> 0 (* use table age stored in MUF Header data *)
    then 
      begin (* format last updated msg *)	  
        format.start_message('Supervisor Class/group table last updated: \');
	format.short_time(last_cg_update)
      end (* format last updated msg *)	 
    else format.start_message(
'Supervisor Class/group table has not been updated.\ ');
  format.write_line(user_terminal);
  user_terminal.write_newline;

  sysmsg1_util.read_sup_table(real_sup, table, status);
  if status = SYSMSG1_SUCCESSFUL
  then display_table(table, table_display_type, sub_table_number)
  else
    begin (* report the SYSMSG1 error *)
      format.start;
      with aux_io do
	format.sysmsg1_error(status, aux_io.param.status,
	  aux_io.param.arg2);
      format.write_line(user_terminal)
    end (* report the SYSMSG1 error *)
end (* read_supervisor_table *);
$if INCLUDE_DNIC


(**************************  command_level  *****************************)
(*									*)
(*			   read_netval_dnic				*)
(*									*)
(************************************************************************)

procedure read_netval_dnic(
      dnic_display_type 	: dnic_table_display_type;
      sub_dnic_name		: dnicname_string);

var
  dnic_table 		: dnic_data_table;
  success,
  netval_dnic_exists	: boolean;

begin  (* read_netval_dnic *);
  display_netval_dnic_age(netval_dnic_exists);
  user_terminal.write_newline;
  if netval_dnic_exists
  then
    begin
      dnic_access.read_dnic_table(dnic_table, success);
      if not success
      then user_terminal.write_quoted_text_line(DISK_READ_ERROR_MESSAGE)
      else display_dnic(dnic_table, dnic_display_type, sub_dnic_name)
    end (* netval_dnic_exists *)
end (* read_netval_dnic *);



(**************************  command_level  *****************************)
(*									*)
(*			 read_supervisor_dnic				*)
(*									*)
(************************************************************************)

procedure read_supervisor_dnic(
      real_sup		: real_supervisor_index;
      dnic_display_type	: dnic_table_display_type;
      sub_dnic_name	: dnicname_string);

var
  dnic_table  		: dnic_data_table;
  status 		: sysmsg1_status;
  dnic_header_info 	: dnic_table_header;
  netval_dnic_exists	: boolean;

begin (* read_supervisor_dnic *)
(* use dnic age stored in MUD Change Header *)
  display_netval_dnic_age(netval_dnic_exists);
  user_terminal.write_newline;

  mud_change.get_dnic_header_info(dnic_header_info);
  with dnic_header_info do
    begin
      if sup_update[real_sup] <>  0
        then 
          begin (* format last updated msg *)	  
            format.start_message('Supervisor DNIC table last updated: \ ');
	    format.short_time(sup_update[real_sup])
          end (* format last updated msg *)	 
        else format.start_message(
'Supervisor DNIC table has not been updated.\')
    end (* with dnic_header_info *);
  format.write_line(user_terminal);
  user_terminal.write_newline;

  sysmsg1_util.read_sup_dnic(real_sup, dnic_table, status);
  if status = SYSMSG1_SUCCESSFUL
  then display_dnic(dnic_table, dnic_display_type, sub_dnic_name)
  else
    begin (* report the SYSMSG1 error *)
      format.start;
      with aux_io do
	format.sysmsg1_error(status, aux_io.param.status,
	  aux_io.param.arg2);
      format.write_line(user_terminal)
    end (* report the SYSMSG1 error *)
end (* read_supervisor_dnic *);
$endif INCLUDE_DNIC
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if changes_to_oper_log
!



(**************************  command_level  *****************************)
(*									*)
(*				remark_command				*)
(*									*)
(************************************************************************)

procedure remark_command;

var
  remark : oplog_remark_message;

begin
  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    begin
      user_terminal.write_quoted_text('Enter operator log remark: \');
      user_terminal.read_remark(remark);
      cud_updater.set_remark(remark)
    end (* scanned.status = CMD_OK *)
end (* remark_command *);
$endif changes_to_oper_log
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(*************************  command_level  ******************************)
(*									*)
(*  Name:	SCHED_CONSISTENCY_COMMAND				*)
(*									*)
(*  Purpose:	input consistency schedule and pass it on to 		*)
(*		mud_change_handler					*)
(*									*)
(************************************************************************)

procedure sched_consistency_command;

var
  start_time : integer;
  stop_time  : integer;
  io_status  : file_utility_status;

begin (* sched_consistency_command *)
   freeword_utility.prompt_time_in_minutes(START_TIME_MESSAGE, start_time);
  if user_terminal.sendable then
    freeword_utility.prompt_time_in_minutes(STOP_TIME_MESSAGE, stop_time);
  if user_terminal.sendable
  then 
    if (start_time = 0) and (stop_time = 0)
    then user_terminal.write_line_and_quoted_text_line(
		    'use CLEAR command to deactivate automatic consistency\')
  else
    begin (* legal times entered, set schedule *)
      mud_change.schedule_consistency(start_time, stop_time, io_status);
      if io_status = FU_SUCCESS
      then
        begin (* report passchanger schedule set *)
          user_terminal.write_line_and_quoted_text_line(ENTRY_COMPLETED);
          format.start_message('CONSISTENCY schedule set by \ ');
          oper_messages.report_validator_message(profile)
        end (* report passchanger schedule set *)
      else user_terminal.write_quoted_text_line(DISK_WRITE_ERROR_MESSAGE)
    end (* legal times entered, set schedule *)
end (* sched_consistency_command *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if force_password_change



(*************************  command_level  ******************************)
(*									*)
(*  Name:	SCHED_PASSCHANGER_COMMAND				*)
(*									*)
(*  Purpose:	input Passchanger run time from validator, then pass	*)
(*		it to mud change handler.				*)
(*									*)
(************************************************************************)

procedure sched_passchanger_command;

var
  start_time : integer;
  io_status  : file_utility_status;

begin (* sched_passchanger_command *)
  freeword_utility.prompt_time_in_minutes(START_TIME_MESSAGE, start_time);
  
  if user_terminal.sendable
  then 
    begin (* pass new passchanger to mud change handler *)
      mud_change.schedule_passchanger(start_time, io_status);
      if io_status = FU_SUCCESS
      then
        begin (* report passchanger schedule set *)
          user_terminal.write_line_and_quoted_text_line(ENTRY_COMPLETED);
          format.start_message('PASSCHANGER schedule set by \ ');
          oper_messages.report_validator_message(profile);
        end (* report passchanger schedule set *)
      else user_terminal.write_quoted_text_line(DISK_WRITE_ERROR_MESSAGE)
    end (* pass new passchanger to mud change handler *)
end (* sched_passchanger_command *);
$endif force_password_change
$if reuse_uuns



(*************************  command_level  ******************************)
(*									*)
(*  Name:	SCHED_UUN_MERGE_COMMAND					*)
(*									*)
(*  Purpose:	input UUN_Merge run time from validator, then pass	*)
(*		it to mud change handler 				*)
(*									*)
(************************************************************************)

procedure sched_uunmerge_command;

var
  start_time : integer;
  io_status  : file_utility_status;

begin (* sched_uunmerge_command *)
  freeword_utility.prompt_time_in_minutes(START_TIME_MESSAGE, start_time);
 
  if user_terminal.sendable
  then 
    begin (* pass new uunmerge run time to mud change handler *)
      mud_change.schedule_uunmerge(start_time, io_status);
      if io_status = FU_SUCCESS
      then
        begin (* report uunmerge schedule set *)
          user_terminal.write_line_and_quoted_text_line(ENTRY_COMPLETED);
          format.start_message('UUN MERGE schedule set by \ ');
          oper_messages.report_validator_message(profile);
        end (* report uunmerge schedule set *)
      else user_terminal.write_quoted_text_line(DISK_WRITE_ERROR_MESSAGE)
    end (* pass new uunmerge run time to mud change handler *)
end (* sched_uunmerge_command *);
$endif reuse_uuns
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
"
		SEND Command
"


(**************************  command_level  *****************************)
(*									*)
(*				send	 				*)
(*									*)
(************************************************************************)

procedure send;

var
  send_wait : boolean;
  table : class_group_table;
  success : boolean;
  real_sup : real_supervisor_index;
  done_waiting : boolean;
  wait_time : integer;
  current_status : class_group_status;

begin
  send_wait := argument_scan.check_keyword(PRIMARY_SEND_WAIT_KEYWORD,
    scanned);
  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    begin
      list_access.lock_file;
      list_utility.create_table(user_terminal, table);
      if list_utility.last_status <> NODE_HOST_OK
      then
	begin
	  list_access.unlock_file;
	  report_list_status
	end (* list_utility.last_status <> NODE_HOST_OK *)
      else
	begin (* list_utility.last_status = NODE_HOST_OK *)
	  user_terminal.write_quoted_text_line('Class/group table built\');
	  table_access.write_table(table, success);
	  if not success
	  then user_terminal.write_line_and_quoted_text_line(
	    'error in writing NETVAL table\')
	  else
	    begin (* table written successfully *)
	      user_terminal.write_line_and_quoted_text_line(
		'Class/group send initialized\ ');
	      list_access.unlock_file;
	      format.start_message('SEND command executed\');
	      oper_messages.report_validator_message(profile);
	      if send_wait (* if validater asked to, wait for completion *)
	      then
		for real_sup := FIRST_SUPERVISOR to MAXIMUM_REAL_SUPERVISOR do
		  if user_terminal.sendable and
		    mud_change.legal_supervisor(real_sup)
		  then
		    begin
		      done_waiting := FALSE;
		      repeat
		        current_status :=
			  mud_change.sup_table_status(real_sup);
			if current_status = CLASS_GROUP_NOT_TRIED
			then
			  begin (* this sup has not been tried as yet, wait *)
			    for wait_time := 1 to 10 do
			      wait;
			    user_terminal.check_circuit
			  end (* this sup has not been tried as yet *)
			else
			  begin (* update has been attempted *)
			    done_waiting := TRUE;
			    format.start_message('Supervisor \');
			    format.sup_number(real_sup);
			    format.colon_space;
			    if current_status = CLASS_GROUP_FAILED
			    then format.string('update failed\')
			    else format.string('table sent\ ');
			    format.write_line(user_terminal)
			  end (* update has been attempted *)
		      until done_waiting or not user_terminal.sendable
		    end (* legal_supervisor *)
	    end (* table written successfully *)
	end (* list_utility.last_status = NODE_HOST_OK *)
    end (* scanned.status = CMD_OK *)
end (* send *);
$if INCLUDE_DNIC
"
		SEND DNIC Command
"


(**************************  command_level  *****************************)
(*									*)
(*				send_dnic 				*)
(*									*)
(************************************************************************)

procedure send_dnic;

var
  send_wait : boolean;
  dnic_table : dnic_table_in_bytes;
  success : boolean;
  real_sup : real_supervisor_index;
  done_waiting : boolean;
  wait_time : integer;
  current_status : dnic_table_status;
  dnic_index : non_default_data_index;

begin
  send_wait := argument_scan.check_keyword(PRIMARY_SEND_WAIT_KEYWORD,
    scanned);
  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    begin
      dnic_access.read_dnic_data(dnic_table, success);
      if success
      then dnic_access.write_dnic_table(dnic_table, success);
      if success
      then
	begin
          user_terminal.write_line_and_quoted_text_line(
            'DNIC table send initialized\');
          format.start_message('SEND DNIC command executed\ ');
          oper_messages.report_validator_message(profile);
	  mud_change.set_dnic_sent;
          if send_wait (* if validater asked to, wait for completion *)
          then
            for real_sup := FIRST_SUPERVISOR to MAXIMUM_REAL_SUPERVISOR do
	      if user_terminal.sendable and
		mud_change.legal_supervisor(real_sup)
              then
	        begin
  	          done_waiting := FALSE;
	          repeat
	            current_status := mud_change.sup_dnic_status(real_sup);
	            if current_status = DNIC_UPDATE_NOT_TRIED
	            then
	              begin (* this sup has not been tried as yet, wait *)
	                for wait_time := 1 to 10 do
		          wait;
		        user_terminal.check_circuit
	              end (* this sup has not been tried as yet *)
	            else
	              begin (* update has been attempted *)
		        done_waiting := TRUE;
		        format.start_message('Supervisor \');
		        format.sup_number(real_sup);
		        format.colon_space;
		        if current_status = DNIC_UPDATE_FAILED
		        then format.string('update failed\')
		        else format.string('DNIC table sent\');
		        format.write_line(user_terminal)
	              end (* update has been attempted *)
	            until done_waiting or not user_terminal.sendable
                end (* legal_supervisor *)
	end (* success *)
    end (* scanned.status = CMD_OK *)
end (* send *);
$endif INCLUDE_DNIC
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if logical_volumes



(***************************  command_level  ****************************)
(*									*)
(*				set_drive				*)
(*									*)
(*      Sets designated drive offline					*)
(*									*)
(************************************************************************)

procedure set_drive;

var
  incarnation : incarnation_index;
  info_buffer : lvol_info_buffer;

begin
  keyword_util.get_numeric_keyword_value(PRIMARY_SET_DRIVE_KEYWORD,
    10, 0, INCARNATION_LIMIT, scanned, incarnation);
  if scanned.status = CMD_OK
  then
    if not argument_scan.check_keyword(PRIMARY_SET_DRIVE_OFFLINE_KEYWORD,
      scanned)
    then scanned.status := ARG_MISSING;
  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    if (lv_status_manager.last_state(lv_utility.lvol_partner(incarnation))
        <> INCARNATION_READ_WRITE) or
      (lv_status_manager.last_state(incarnation) <> INCARNATION_READ_WRITE)
    then user_terminal.write_quoted_text_line(
      'one drive is already down or offline\ ')
    else
      begin
        user_terminal.write_quoted_text_line(
'restoration to read/write state requires execution of the COPY command\ ');
	if keyword_scan.input_answer(CONTINUE_MESSAGE)
	then
	  begin
	    lv_utility.set_state(incarnation, SET_LVOL_UNAVAILABLE);
	    user_terminal.write_line_and_quoted_text_line(ENTRY_COMPLETED);
	    format.start_message(DRIVE_MESSAGE);
	    format.number(incarnation, 10);
	    format.string(' set OFFLINE\ ');
	    oper_messages.report_validator_message(profile);
	    lv_utility.lvol_information(info_buffer);
	    lv_status_manager.update_last_status(info_buffer)
	  end (* set drive offline *)
      end (* both drives are read/write *)
end (* set_drive *);
$endif logical_volumes
$if force_password_change
"$if allow_global_password_expire"



(********************** command_level    ********************************)
(*									*)
(*  Name:	set_gan_passlife					*)
(*									*)
(*  Purpose:	define pasword validity period for a GAN		*)
(*									*)
(*  Method:	Fetch ganpass parameters from user, pass them to 	*)
(*		pasmon.set_ganpas.  If set_ganpass return parameters	*)
(*		are checked to determine which message to display.	*)
(*									*)
(************************************************************************)

procedure set_gan_passlife;

var
  gan		: integer;
  passlife	: integer;
  io_status	: file_utility_status;
  passlife_set	: boolean;
  set_ok	: boolean;
  gan_tba 	: integer;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if request_fpc_start  start  : integer;
$ifnone reuse_uuns   uun_tba : integer;
$if reuse_uuns
  bit17_usable_uuns : integer;
  bit18_usable_uuns : integer;
  usable_add_back_slots : integer;
$endif reuse_uuns
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

begin (* set_gan_passlife *)
  passlife_set := false;  set_ok := false;  io_status := FU_SUCCESS;
  param_manager.next_gan_and_uun(gan_tba,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone reuse_uuns 	    uun_tba);
$if reuse_uuns 	  bit17_usable_uuns, bit18_usable_uuns, usable_add_back_slots);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  if gan_tba > 1 then
  begin		(* not empty table *)
  freeword_utility.get_ganpass(scanned, gan_tba - 1, gan, passlife
$if request_fpc_start     , start
);
  argument_scan.extra_argument_check(scanned);
  if scanned.status = CMD_OK
  then
    begin (* input is OK, try to save it *)
      if user_terminal.sendable
      then pasmon.set_ganpass(gan, passlife,
$if request_fpc_start        start,
	io_status, passlife_set, set_ok);

      if (not passlife_set) and set_ok
      then
        begin (* report successfull ganpass setting *)
          user_terminal.write_quoted_text_line(ENTRY_COMPLETED);
          format.start_message('GANPASS \ ');
          format.number(gan, 8);
          format.string(' set to \ ');
          format.number(passlife, 10);
	  format.string(' days by \');
$if request_fpc_start
	  format.string(' starting \ ');
	  format.date(start);
$endif request_fpc_start
          oper_messages.report_validator_message(profile);
        end (* report successfull ganpass setting *);
  
      if not set_ok
      then user_terminal.write_quoted_text_line('no entries available\ ');
      if passlife_set
      then user_terminal.write_quoted_text_line('GAN is already set\ ');

      if io_status <> FU_SUCCESS
      then 
        begin (* report disc write error *)
	  user_terminal.write_quoted_text_line(DISK_WRITE_ERROR_MESSAGE);
          format.start_message(DISK_WRITE_ERROR_MESSAGE);
          oper_messages.report_validator_message(profile)
        end (* report disc write error *)
    end (* input is OK, try to save it *)
  end 	(* not empty table *)
  else  (* empty cud parameter file *)
    user_terminal.write_quoted_text_line(
		   'empty cud parameter - ganpass cannot be set\')
end (* set_gan_passlife *);
$endif force_password_change
"$endif ALLOW_GLOBAL_PASSWORD_EXPIRE"
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if global_password_only_login



(**********************  command_level  *********************************)
(*									*)
(*  Name:	SET_GPO_ACCESS						*)
(*									*)
(*  Purpose:	process a Set Gpogan Command input by a validator	*)
(*									*)
(************************************************************************)

procedure set_gpo_access;

var
  gan			: integer;
  io_status		: file_utility_status;
  gpogan_set		: boolean;
  set_ok 		: boolean;
  gan_tba 		: integer;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone reuse_uuns   uun_tba : integer;
$if reuse_uuns
  bit17_usable_uuns 	: integer;
  bit18_usable_uuns 	: integer;
  usable_add_back_slots : integer;
$endif reuse_uuns
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

begin (* set_gpo_access *)
  gpogan_set := false;  set_ok := false;  io_status := FU_SUCCESS;
  param_manager.next_gan_and_uun(gan_tba,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone reuse_uuns 	    uun_tba);
$if reuse_uuns 	  bit17_usable_uuns, bit18_usable_uuns, usable_add_back_slots);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  if gan_tba > 1 then
  begin 	(* not empty table *)
  freeword_utility.get_gan(scanned, gan_tba - 1, gan);
  argument_scan.extra_argument_check(scanned);

  if user_terminal.sendable and (scanned.status = cmd_ok)
  then 
    begin (* got the gpogan, now set it *)
      pasmon.set_gpogan(gan, io_status, gpogan_set, set_ok);

      if (not gpogan_set) and set_ok
      then
        begin (* report successfull gpogan setting *)
          user_terminal.write_quoted_text_line(ENTRY_COMPLETED);
          format.start_message('GAN \ ');
          format.number(gan, 8);
          format.string(' designated eligible for GPO by \ ');
          oper_messages.report_validator_message(profile)
        end (* report successfull gpogan setting *);
   
      if not set_ok
      then user_terminal.write_quoted_text_line('no entries available\ ');

      if gpogan_set 
	then user_terminal.write_quoted_text_line('GPOGAN is already set\');

      if io_status <> FU_SUCCESS
      then 
        begin (* report disc write error *)
	  user_terminal.write_quoted_text_line(DISK_WRITE_ERROR_MESSAGE);
          format.start_message(DISK_WRITE_ERROR_MESSAGE);
          oper_messages.report_validator_message(profile)
        end (* report disc write error *)
    end (* got the gpogan, now set it *)
  end 	(* not empty table *)
  else  (* empty cud parameter file *)
    user_terminal.write_quoted_text_line(
	'empty cud parameter - gpogan cannot be set\ ')
end (* set_gpo_access *);
$endif global_password_only_login
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
"
		SET SUPERVISOR Command
"
(***************************  command_level  ****************************)
(*									*)
(*			  send_errlog_message				*)
(*									*)
(*      Send a message that a Supervisor has been turned ON or OFF	*)
(*	to the Supervisor err log ("12x" is Supervisor host number;	*)
(*	"f" is 0 if OFF, 1 if ON)					*)
(*									*)
(* Supervisor ERR log message:						*)
(*	NODE REPORT nnnn SLOT ss VAL TYPE 11 12x f			*)
(*									*)
(* TMCS message:							*)
(*	NODE REPORT nnnn FROM SLOT ss VAL, SUPERVISOR 12x TURNED ON/OFF	*)
(*									*)
(************************************************************************)

procedure send_errlog_message(
      real_sup	: real_supervisor_index;
      turned_on	: boolean);

var
  data1 : char;
  data2	: halfword;

begin (* send_errlog_message *)
  mutil.save_word_in_halfword(real_sup, data2);
  if turned_on
  then data1 := '(:1:)' (* sup has been turned on *)
  else data1 := ZERO (* sup has been turned off *);
  aux_io.send_errlog_message(ERRLOG_SET_SUPERVISOR_MESSAGE_TYPE, data1, data2)
end (* send_errlog_message *);



(***************************  command_level  ****************************)
(*									*)
(*			Display_all_legal_sups				*)
(*									*)
(************************************************************************)

procedure display_all_legal_sups;

var
  real_sup : real_supervisor_index;
  first_one : boolean;

begin (* display_all_legal_sups *)
  first_one := TRUE;
  for real_sup := FIRST_SUPERVISOR to MAXIMUM_REAL_SUPERVISOR do
    if mud_change.legal_supervisor(real_sup)
    then
      begin (* format legal_supervisor number *)
        if first_one
        then
    	  begin (* first one *)
	    format.start_message('Netval legal supervisors are: \ ');
  	    first_one := FALSE
	  end (* first_one *)
	else format.string(COMMA_SPACE);
	format.sup_number(real_sup)
      end (* format legal_supervisor number *);

  if first_one
  then user_terminal.write_quoted_text_line(NO_LEGAL_SUPS_MESSAGE)
  else format.write_line(user_terminal)
end (* display_all_legal_sups *);




(***********************  Command_Level  ********************************)
(*									*)
(*			record_change_of_sup_state	      		*)
(*									*)
(************************************************************************)

procedure record_change_of_sup_state(
      real_sup	: real_supervisor_index;
      on	: boolean);

begin (* record_change_of_sup_state *)
  format.start_message(SUPERVISOR_MESSAGE);
  format.sup_number(real_sup);
  format.string(' set \');
  if on
  then format.string('on\ ')
  else format.string('off\');
  oper_messages.report_validator_message(profile);

  send_errlog_message(real_sup, on) (* record changed sup status *);

  display_all_legal_sups  
end (* record_change_of_sup_state *);



(***************************  command_level  ****************************)
(*									*)
(*			     set_supervisor				*)
(*									*)
(*	turns designated sup on or off					*)
(*									*)
(************************************************************************)

procedure set_supervisor;

var
  real_sup    : real_supervisor_index;
  keyword     : command_keyword_index;
  success     : set_supervisor_status;
  on          : boolean (* TRUE if keyword = on *);

begin (* set_supervisor command processing *)
  argument_scan.find_keyword(PRIMARY_SET_SUPERVISOR_ON_KEYWORD,
    PRIMARY_SET_SUPERVISOR_OFF_KEYWORD, scanned, keyword);
  if scanned.status = CMD_OK (* if it's really a set_supervisor cmd *)
  then
    begin (* fetch rest of command *)
      on := keyword = PRIMARY_SET_SUPERVISOR_ON_KEYWORD;
      get_supervisor(PRIMARY_SET_SUPERVISOR_KEYWORD, real_sup);
      argument_scan.extra_argument_check(scanned)
    end (* fetch rest of command *);
  if scanned.status = CMD_OK (* if cmd params are OK *)
  then
    begin (* processing of OK set_supervisor command *)
      mud_change.set_supervisor(real_sup, on, success);
      case success of
        SET_SUP_SUCCESSFULL:
	  begin (* nothing unusual happened *)
            user_terminal.write_quoted_text_line(ENTRY_COMPLETED);
	    record_change_of_sup_state(real_sup, on)
	  end (* nothing unusual happened *);

        SET_SUP_AUTO_CONSISTENCY_HALTED:
	  begin (* auto consistency halted *)
	    user_terminal.write_quoted_text_line(CONSISTENCY_STOPPED_MESSAGE);
     	    user_terminal.write_quoted_text_line(ENTRY_COMPLETED);
	    record_change_of_sup_state(real_sup, on)
	  end (* auto consistency halted *);

        SET_SUP_NO_ROOM_IN_PSEUDO_SUP_TABLE:
          begin (* no room in pseudo_sup_table *)
	    user_terminal.write_quoted_text_line(
'Cannot SET_SUPERVISOR:ON because MAXIMUM_EXPECTED_SUPERVISORS already ON\ ');
	    display_all_legal_sups
	  end (* no room in pseudo_sup_table *);

        SET_SUP_ALREADY_IN_PSEUDO_SUP_TABLE:
	  begin (* sup already in pseudo_sup_table *)
	    user_terminal.write_quoted_text_line(
'ERROR!! Supervisor already in pseudo_sup_table\ ');
	    crash_util.halt_slot
	  end (* sup already in pseudo_sup_table *);

        SET_SUP_MANUAL_CONSISTENCY_IN_PROGRESS:
	  begin (* manual consistency in progress *)
	    user_terminal.write_quoted_text_line(
					'Cannot SET_SUPERVISOR:OFF because\');
            user_terminal.write_quoted_text_line(CONSISTENCY_UNSTOPPABLE_MSG)
	  end (* manual consistency in progress *);

	SET_SUP_ALREADY_ON:
	  begin (* supervisor is already on *)
	    user_terminal.write_quoted_text_line('Sup already on\ ');
	    display_all_legal_sups
	  end (* supervisor is already on *);

	SET_SUP_ALREADY_OFF:
	  begin (* supervisor is already off *)
	    user_terminal.write_quoted_text_line('Sup already off\');
	    display_all_legal_sups
	  end (* supervisor is already off *);

	SET_SUP_OFF_ALREADY_IN_PROGRESS:
	  begin (* another turn-off got here first *)
	    user_terminal.write_quoted_text_line('Sup already being SET:OFF\')
	  end (* another turn-off got here first *)
	end (* success case statement *)
    end (* processing of OK set_supervisor command *)
end (* set_supervisor *);
!
"
		STOP Command
"



(***************************  command_level  ****************************)
(*									*)
(*			       stop_command				*)
(*									*)
(************************************************************************)

procedure stop_command(
      real_sup : real_supervisor_index);

var
  in_core_info : supervisor_in_core_information;

begin
  mud_change.get_sup_update_info(real_sup, in_core_info);
  if (in_core_info.current_un2_activity = NOT_BUSY) 
     or (in_core_info.current_un2_activity = MUD_UPDATING)
  then user_terminal.write_quoted_text_line('consistency is not running\ ')
  else
    if in_core_info.consistency.manual
    then user_terminal.write_quoted_text_line(CONSISTENCY_UNSTOPPABLE_MSG)
    else
      begin
	mud_change.set_to_be_stopped_true(real_sup);
        user_terminal.write_quoted_text_line(CONSISTENCY_STOPPED_MESSAGE);
	format.start_message(CONSISTENCY_STOPPED_MESSAGE);
	format.string(SUPERVISOR_MESSAGE);
	format.sup_number(real_sup);
	oper_messages.report_validator_message(profile)
      end (* consistency running is not manual *)
end (* stop_command *);
!



(***************************  command_level  ****************************)
(*									*)
(*			   check_assigned_tape				*)
(*									*)
(************************************************************************)

procedure check_assigned_tape;

var
  unit : tape_unit_index;
  found : boolean;

begin
  tape_pool.validator_tape(validator, found, unit);
  if found
  then tape_util.deassign_tape(unit, TRUE)
end (* check_assigned_tape *);


!
"
	WRITE Command
"


(******************************  command_level  *************************)
(*									*)
(*			     knows_password				*)
(*									*)
(************************************************************************)

function knows_password : boolean;

var
$if BEFORE_SUP_V43   cud_entry : cud_user_entry;
$ifnone BEFORE_SUP_V43
  mud_entry : mud_user_entry;
  nud_entry : nud_user_entry;
$endif BEFORE_SUP_V43

begin
  knows_password := FALSE;
$if BEFORE_SUP_V43
  cud_entry.name.text := PROGRAMMER_NAME;
  cud_entry.name.size := PROGRAMMER_NAME_SIZE;
  read_user_entry(cud_entry);
  if cud_updater.last_status = CUD_ENTRY_OK
  then knows_password := cud_entry.password = password_read.ciphered_password  
$endif BEFORE_SUP_V43
$ifnone BEFORE_SUP_V43
  mud_entry.name.text := PROGRAMMER_NAME;
  mud_entry.name.size := PROGRAMMER_NAME_SIZE;
  read_user_entry(mud_entry, nud_entry);
  if cud_updater.last_status = CUD_ENTRY_OK
  then knows_password := mud_entry.password.cipher = password_read.ciphered_password  
$endif BEFORE_SUP_V43
end (* knows_password *);



(*******************************  command_level  ************************)
(*									*)
(*			     write_command 				*)
(*									*)
(************************************************************************)

procedure write_command(
      real_sup		: real_supervisor_index;
      writing_from_cud	: boolean);

var
  success        : boolean;

begin
  success := not cmd_utility.buffer_is_empty(writing_from_cud);
  if success
  then
    if not knows_password
    then
      begin
        success := FALSE;
        user_terminal.write_quoted_text_line(PASSWORD_ERROR)
      end (* not knows_password *);
  if success
  then
    if scanned.subcommand = PRIMARY_WRITE_CUD_KEYWORD
    then cmd_utility.write_cud_buffer(writing_from_cud)
    else cmd_utility.write_mud_buffer(writing_from_cud, real_sup)
end (* write_command *);



(***************************  command_level  ****************************)
(*									*)
(*			      scan_primary				*)
(*									*)
(************************************************************************)

procedure scan_primary;

var
  name 			: username_string;
  real_sup 		: real_supervisor_index;
  start_time		: integer;
  stop_time		: integer;
  block 		: cud_block_index;
  table_display_type	: class_group_table_display_type;
  sub_table_number	: integer;
$if INCLUDE_DNIC
  dnic_display_type	: dnic_table_display_type;
  sub_dnic_name		: dnicname_string;
$endif INCLUDE_DNIC
  new_as 		: boolean;
  success 		: boolean;  
  consistency_nochange  : boolean (* TRUE if consistency NOCHANGE *);
  tape_assigned 	: boolean;
  lock_block 		: boolean;
  writing_from_cud 	: boolean;
  display_sup_table	: boolean;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if validate_x25_names   this_is_x25_name 	: boolean;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if BEFORE_SUP_V43  cud_entry	: cud_user_entry;
$ifnone BEFORE_SUP_V43
  mud_entry	: mud_user_entry;
  nud_entry	: nud_user_entry;
$if overflow_cud_entries  over_block	: integer;
$endif BEFORE_SUP_V43

begin
  case scanned.command of

    PRIMARY_ARCHIVE: archive.archive_command(scanned);

    PRIMARY_CHANGE:
      case scanned.subcommand of
        PRIMARY_CHANGE_ACCESS_KEYWORD:	change_access;
	PRIMARY_CHANGE_CLASS_KEYWORD:	change_global_access(TRUE);
	PRIMARY_CHANGE_CONTROL_KEYWORD:	change_control;
	PRIMARY_CHANGE_CUD_KEYWORD:	cmd_utility.change_cud(scanned);
	PRIMARY_CHANGE_DISTRICT_KEYWORD:change_district;
$if INCLUDE_DNIC
	PRIMARY_CHANGE_DNIC_KEYWORD: change_dnic;
$endif INCLUDE_DNIC
	PRIMARY_CHANGE_GAN_KEYWORD:	change_gan;
	PRIMARY_CHANGE_GROUP_KEYWORD:	change_global_access(FALSE);
$ifnone BEFORE_SUP_V43
$if allow_logon_inhibit
	PRIMARY_CHANGE_INHIBIT_KEYWORD:	change_inhibit;
$endif allow_logon_inhibit
$endif BEFORE_SUP_V43
$if include_irc 	PRIMARY_CHANGE_IRC_KEYWORD:	change_irc;
	PRIMARY_CHANGE_HOSTLIST_KEYWORD:change_list(TRUE);
	PRIMARY_CHANGE_NAME_KEYWORD:	change_name;
	PRIMARY_CHANGE_NODELIST_KEYWORD:change_list(FALSE);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+	*)
$if UUNSassignable 	PRIMARY_CHANGE_UUN_KEYWORD:	change_uun;
$if password_expiration_by_user
	PRIMARY_CHANGE_VALIDITY_KEYWORD: change_validity;
$endif password_expiration_by_user
$if restrict_users_by_time 	PRIMARY_CHANGE_TIME_KEYWORD: change_time;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+	*)
	PRIMARY_CHANGE_PASSWORD_KEYWORD: change_password
      end (*  PRIMARY_CHANGE *);

    PRIMARY_CHECK:
      begin
        get_username(name, success);
	if success
	then
	  begin
	    cud_updater.check_for_name_in_cud(name);
	    cud_utility.print_cud_entry_error
	  end (* success *)
      end (* PRIMARY_CHECK *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if special

    PRIMARY_CLEAN: cmd_utility.clean_up(scanned);
$endif special
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

    PRIMARY_CLEAR:
      case scanned.subcommand of
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if force_password_change
	PRIMARY_CLEAR_GANPASS_KEYWORD: clear_ganpass_command;
	PRIMARY_CLEAR_PASSCHANGER_KEYWORD: clear_passchanger_command;
$endif force_password_change
$if global_password_only_login
	PRIMARY_CLEAR_GPOGAN_KEYWORD: clear_gpogan_command;
$endif global_password_only_login
$if reuse_uuns 	PRIMARY_CLEAR_UUNMERGE_KEYWORD: clear_uunmerge_command;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	PRIMARY_CLEAR_CONSISTENCY_KEYWORD: clear_consistency_command
      end (* PRIMARY_CLEAR *);

    PRIMARY_COMPARE: cmd_utility.compare(scanned);

    PRIMARY_CONSISTENCY:
      begin
        consistency_nochange := argument_scan.check_keyword(
	  PRIMARY_CONSISTENCY_NOCHANGE_KEYWORD, scanned);
	get_legal_supervisor(PRIMARY_CONSISTENCY_SUPERVISOR_KEYWORD, real_sup);
	if scanned.status = CMD_OK
	then
	  begin
	    block := 0;
	    if CONSISTENCY_RESTARTABLE
	    then
	      if argument_scan.check_keyword(PRIMARY_CONSISTENCY_FROM_KEYWORD,
	        scanned)
	      then keyword_util.get_numeric_keyword_value(
	        PRIMARY_CONSISTENCY_FROM_KEYWORD, 10, 0, CUD_BLOCK_LIMIT,
		  scanned, block)
	  end (* scanned.status = CMD_OK *);
        argument_scan.extra_argument_check(scanned);
	if scanned.status = CMD_OK
	then run_consistency(real_sup, block, consistency_nochange)
      end (* PRIMARY_CONSISTENCY *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if logical_volumes

  PRIMARY_COPY: copy_command;
$endif logical_volumes
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

    PRIMARY_DELETE:
      case scanned.subcommand of
	PRIMARY_DELETE_ACCESS_KEYWORD:	delete_access;
	PRIMARY_DELETE_CLASS_KEYWORD:	delete_global_access(TRUE);
$if include_dnic
	PRIMARY_DELETE_DNIC_KEYWORD: delete_dnic_entry;
$endif include_dnic
	PRIMARY_DELETE_GROUP_KEYWORD:	delete_global_access(FALSE);
	PRIMARY_DELETE_HOSTLIST_KEYWORD:delete_list(TRUE);
	PRIMARY_DELETE_NODELIST_KEYWORD:delete_list(FALSE);
	PRIMARY_DELETE_USER_KEYWORD:	delete_user
      end (* case *);

    PRIMARY_DISPLAY: scan_display;

    PRIMARY_FILTER: filter_util.scan_filter_command(scanned);

    PRIMARY_GET:
      begin
	get_username(name, success);
	if success
	then
	  begin
	    block :=
$if BEFORE_SUP_V43		cud_updater.hashed_cud_block(name);
$ifnot BEFORE_SUP_V43
	    cud_updater.hash_number(name);
$if overflow_cud_entries	over_block := cud_updater.overflow_number(name);
$endif not BEFORE_SUP_V43
	    cud_utility.print_cud_entry_error;
	    if cud_updater.last_status = CUD_ENTRY_OK
	    then
	      begin
		format.start_message('block number: \ ');
		format.number(block, 10);
$ifnot BEFORE_SUP_V43
$if overflow_cud_entries
		format.skip(2);
		format.string('overflow: \ ');
		format.number(over_block, 10);
$endif overflow_cud_entries
$endif not BEFORE_SUP_V43
		format.write_line(user_terminal)
	      end (* cud_updater.last_status = CUD_ENTRY_OK *)
	  end (* success *)
      end (* primary_get *);

    PRIMARY_HOST:
      begin
        argument_scan.extra_argument_check(scanned);
	if scanned.status = CMD_OK
	then
	  case scanned.subcommand of
	    PRIMARY_HOST_SHUT_KEYWORD:	set_host_state(SHUT_STATE);
	    PRIMARY_HOST_STATUS_KEYWORD:cmd_utility.host_status_command;
	    PRIMARY_HOST_UP_KEYWORD:	set_host_state(UP_STATE)
	  end (* case *);
      end (* PRIMARY_HOST *);

    PRIMARY_MESSAGE: filter_util.scan_message_command(scanned);

    PRIMARY_NEW:
      case scanned.subcommand of
	PRIMARY_NEW_ACCESS_KEYWORD:
	  begin
$ifnone BEFORE_SUP_V43
	    get_and_access_name(TRUE, mud_entry, nud_entry, success);
	    if success
	    then get_access_entry(mud_entry, nud_entry)
$endif BEFORE_SUP_V43
$if BEFORE_SUP_V43
	    get_and_access_name(TRUE, cud_entry, success);
	    if success
	    then get_access_entry(cud_entry)
$endif BEFORE_SUP_V43
	  end (* PRIMARY_NEW_ACCESS_KEYWORD *);
$if include_dnic
	PRIMARY_NEW_DNIC_KEYWORD: new_dnic;
$endif include_dnic

	PRIMARY_NEW_HOSTLIST_KEYWORD,
	PRIMARY_NEW_NODELIST_KEYWORD:
	  begin
	    argument_scan.extra_argument_check(scanned);
	    if scanned.status = CMD_OK
	    then new_list
	  end (* PRIMARY_NEW_HOSTLIST_KEYWORD *);

	PRIMARY_NEW_USER_KEYWORD:
	  begin
	    new_as := FALSE;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if validate_x25_names
	    this_is_x25_name := FALSE;
	    if argument_scan.check_keyword(PRIMARY_NEW_USER_X25_KEYWORD,
	      scanned)
	    then this_is_x25_name := TRUE
	    else
$endif validate_x25_names
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	    if argument_scan.check_keyword(PRIMARY_NEW_USER_AS_KEYWORD,
	      scanned)
	    then
	      begin
		argument_scan.freeword_username(0, scanned, name);
		new_as := TRUE
	      end (* PRIMARY_NEW_USER_AS_KEYWORD *);
	    argument_scan.extra_argument_check(scanned);
	    if scanned.status = CMD_OK
	    then
	      if new_as
	      then new_user_as_old(name)
	      else new_user
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if validate_x25_names 	      (this_is_x25_name)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	  end (* primary_new_user_keyword *)
      end (* case and PRIMARY_NEW *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if special

    PRIMARY_OLDPASS: cmd_utility.display_oldpass(scanned);
$endif special
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

    PRIMARY_QUIT:
      begin
	if profile.level >= NETWORK_ADMINISTRATOR_VALIDATOR
	then
	  begin
	    tape_util.display_status(tape_assigned);
	    if tape_assigned (* deassign any tape unit assigned *)
	    then check_assigned_tape
	  end (* profile.level >= NETWORK_ADMINISTRATOR_VALIDATOR *);
	format.start_message('Logging out at \');
	format.time(REALTIME);
	format.write_line(user_terminal);
	user_terminal.wait_for_output;
	user_terminal.clear_circuit
      end (* PRIMARY_QUIT *);

    PRIMARY_READ:
      case scanned.subcommand of

	PRIMARY_READ_CUD_KEYWORD:
	  begin
	    get_cud_block(PRIMARY_READ_BLOCK_KEYWORD, block);
	    if scanned.status = CMD_OK
	    then lock_block :=
	      argument_scan.check_keyword(PRIMARY_READ_LOCK_KEYWORD, scanned);
	    argument_scan.extra_argument_check(scanned);
	    if scanned.status = CMD_OK
	    then cmd_utility.read_cud(lock_block, block,
              block_is_locked, shut_block)
	  end (* PRIMARY_READ_CUD_KEYWORD *);

	PRIMARY_READ_MUD_KEYWORD:
	  begin
	    get_cud_block(PRIMARY_READ_BLOCK_KEYWORD, block);
	    if scanned.status = CMD_OK
	    then get_legal_supervisor(PRIMARY_READ_MUD_KEYWORD, real_sup);
	    argument_scan.extra_argument_check(scanned);
	    if scanned.status = CMD_OK
	    then cmd_utility.read_mud(real_sup, block)
	  end (* PRIMARY_READ_MUD_KEYWORD *);
$if include_dnic

	PRIMARY_READ_DNIC_KEYWORD:
          begin 
	    dnic_display_type := ENTIRE_DNIC_TABLE;
	    display_sup_table := FALSE;
	    sub_dnic_name := NULL_DNICNAME;

    	    if argument_scan.check_keyword(
			PRIMARY_READ_DNIC_DEFAULT_KEYWORD, scanned)
    	    then dnic_display_type := DEFAULT_DNIC_ENTRY;

    	    if argument_scan.check_keyword(
			PRIMARY_READ_DNIC_ENTRY_KEYWORD, scanned)
    	    then
      	      begin (* set dnic table display parameters *)
	        freeword_utility.get_dnicname(0, scanned, sub_dnic_name);
		dnic_display_type := ONLY_ONE_DNIC
	      end (* set dnic table display parameters *);

    	    if argument_scan.check_keyword(
			PRIMARY_READ_SUPERVISOR_KEYWORD, scanned)
    	    then
      	      begin (* set sup table display parameters *)
                display_sup_table := TRUE;
		get_legal_supervisor(PRIMARY_READ_SUPERVISOR_KEYWORD,
		  real_sup)
      	      end (* set sup table display parameters *);

      	    argument_scan.extra_argument_check(scanned);
    	    if scanned.status = CMD_OK
    	    then
      	      if display_sup_table
      	      then read_supervisor_dnic(real_sup, dnic_display_type,
		sub_dnic_name)
      	      else read_netval_dnic(dnic_display_type, sub_dnic_name)
	  end (* PRIMARY_READ_DNIC_KEYWORD *);
$endif include_dnic

	PRIMARY_READ_TABLE_KEYWORD:
  	  begin (* process READ command *)
    	    table_display_type := ENTIRE_TABLE;
    	    display_sup_table := FALSE;
	    sub_table_number := 0;

    	    if argument_scan.check_keyword(
			PRIMARY_READ_TABLE_CLASS_KEYWORD, scanned)
    	    then
      	      begin (* set class_table display parameters *)
	        table_display_type := ONLY_ONE_CLASS;	
		keyword_util.get_numeric_keyword_value(
	    		PRIMARY_READ_TABLE_CLASS_KEYWORD, 10, 
			FIRST_CLASS, MAXIMUM_CLASS, scanned, sub_table_number)
      	      end (* set class_table display parameters *)
    	    else 
              if argument_scan.check_keyword(PRIMARY_READ_TABLE_GROUP_KEYWORD, 
			scanned)
      	      then
                begin (* set group_table display parameters *)
	  	  table_display_type := ONLY_ONE_GROUP;	
  	  	  keyword_util.get_numeric_keyword_value(
	          	PRIMARY_READ_TABLE_GROUP_KEYWORD, 10, FIRST_GROUP,
			MAXIMUM_GROUP, scanned, sub_table_number)
        	end (* set group_table display parameters *);

    	    if argument_scan.check_keyword(
			PRIMARY_READ_SUPERVISOR_KEYWORD, scanned)
    	    then
      	      begin (* set sup table display parameters *)
                display_sup_table := TRUE;
		get_legal_supervisor(PRIMARY_READ_SUPERVISOR_KEYWORD, 
			real_sup)
      	      end (* set sup table display parameters *);

      	    argument_scan.extra_argument_check(scanned);
    	    if scanned.status = CMD_OK
    	    then
      	      if display_sup_table
      	      then read_supervisor_table(real_sup, table_display_type, 
			sub_table_number)
      	      else read_netval_table(table_display_type, sub_table_number)
  	  end (* process READ command *)
      end (* case and PRIMARY_READ *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if changes_to_oper_log

    PRIMARY_REMARK: remark_command;
$endif changes_to_oper_log
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

    PRIMARY_SCHEDULE:
      case scanned.subcommand of
	PRIMARY_SCHEDULE_CONSISTENCY_KEYWORD: sched_consistency_command
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if force_password_change
;
	PRIMARY_SCHEDULE_PASSCHANGER_KEYWORD: sched_passchanger_command
$endif force_password_change
$if reuse_uuns
;
	PRIMARY_SCHEDULE_UUNMERGE_KEYWORD: sched_uunmerge_command
$endif reuse_uuns
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      end (* case and PRIMARY_SCHEDULE *);

    PRIMARY_SELECT: cmd_utility.select(scanned);

$ifnone INCLUDE_DNIC    PRIMARY_SEND: send;
$if INCLUDE_DNIC
    PRIMARY_SEND:
      case scanned.subcommand of
        PRIMARY_SEND_DNIC_KEYWORD: send_dnic;
        PRIMARY_SEND_TABLE_KEYWORD: send
      end (* PRIMARY_SEND *);
$endif INCLUDE_DNIC

    PRIMARY_SET:
      case scanned.subcommand of
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if logical_volumes 	PRIMARY_SET_DRIVE_KEYWORD:	set_drive;
$if force_password_change
        PRIMARY_SET_GANPASS_KEYWORD: set_gan_passlife;
$endif force_password_change
$if global_password_only_login
        PRIMARY_SET_GPOGAN_KEYWORD: set_gpo_access;
$endif global_password_only_login
$if prevent_duplicate_passwords
	PRIMARY_SET_PASSPERIOD_KEYWORD: cmd_utility.set_passperiod(scanned);
$endif prevent_duplicate_passwords
$if password_expiration_by_user
	PRIMARY_SET_VALIDITY_KEYWORD: cmd_utility.set_validity(scanned);
$endif password_expiration_by_user
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	PRIMARY_SET_SUPERVISOR_KEYWORD:	set_supervisor

      end (* case and PRIMARY_SET *);

    PRIMARY_STOP:
      begin (* PRIMARY_STOP *)
	get_legal_supervisor(PRIMARY_STOP_SUPERVISOR_KEYWORD, real_sup);
	argument_scan.extra_argument_check(scanned);
	if scanned.status = CMD_OK
	then stop_command(real_sup)
      end (* PRIMARY_STOP *);

    PRIMARY_UNLOCK:
      begin (* PRIMARY_UNLOCK *)
	argument_scan.extra_argument_check(scanned);
	if scanned.status = CMD_OK
	then
	  if block_is_locked
	  then
	    begin
	      cud_access.unlock_cud_block(shut_block);
	      block_is_locked := FALSE;
	      format.start_message('block \ ');
	      format.number(shut_block, 10);
	      format.string(' unlocked\');
	      format.write_line(user_terminal)
	    end (* block_is_locked *)
	  else user_terminal.write_quoted_text_line('no block locked\')
      end (* PRIMARY_UNLOCK *);

    PRIMARY_WRITE:
      begin
        real_sup := FIRST_SUPERVISOR; 
	writing_from_cud := TRUE;
        if scanned.subcommand = PRIMARY_WRITE_MUD_KEYWORD
	then get_legal_supervisor(PRIMARY_WRITE_MUD_KEYWORD, real_sup)
	else
	  if argument_scan.check_keyword(PRIMARY_WRITE_CUD_FROM_KEYWORD,
	    scanned)
	  then
	    if argument_scan.check_keyword(
	      PRIMARY_WRITE_CUD_FROM_SUPERVISOR_KEYWORD, scanned)
	    then writing_from_cud := FALSE (* writing CUD from MUD buffer *)
	    else scanned.status := ARG_MISSING;
	argument_scan.extra_argument_check(scanned);
	if scanned.status = CMD_OK
	then write_command(real_sup, writing_from_cud)
      end (* PRIMARY_WRITE *)
  end (* case *)
end (* scan_primary *);



(***************************  command_level  ****************************)
(*									*)
(*			    process_validator				*)
(*									*)
(*	This is the main processing routine.  It sets context, reads	*)
(*	commands and calls the appropriate command class routine.	*)
(*									*)
(************************************************************************)

procedure process_validator;

begin
  command_read.add_class(PRIMARY_CLASS);
  repeat
    command_read.get_command(scanned);
    if user_terminal.available
    then
      begin
	command_read.remove_class(PRIMARY_CLASS);
	user_terminal.write_newline;
 	scan_primary;
	command_read.add_class(PRIMARY_CLASS);
	scan_error.display_command_error(scanned)
      end (* if user_terminal.available *)
  until not user_terminal.available;
  check_assigned_tape
end (* process_validator *);
!
(****************************  command_level  ***************************)
(************************************************************************)

begin (* inital statement *)
  init sys_io, mutil, format, profile(validator),
    user_terminal(mutil), oper_messages(oplog, format), aux_io(mutil),

    calendar,
    crash_util,

(* command handlers *)
    argument_scan(mutil),

    keyword_util(profile, format, user_terminal, commands, argument_scan),

    input_scanner(profile, mutil, format, user_terminal, commands,
      argument_scan, keyword_util),

    freeword_utility(user_terminal, format, argument_scan, input_scanner,
      scan_error),

    keyword_scan(user_terminal, input_scanner),

    scan_error(user_terminal, format),

    filter_util(validator, format, argument_scan, keyword_util,
      mutil, user_terminal, oplog),

    command_read(validator, profile, statistics, user_terminal, argument_scan,
      format, input_scanner, scan_error, commands),

    dsksys(statistics),


(* CUD handlers *)
    block_utility(mutil, oper_messages, format, dsksys),

    block_updater(mutil, statistics, dsksys, cud_access, block_utility,
      format),

    cud_entry_util(mutil, format, oper_messages),


(* list handlers (class, group, node and host) *)
    list_io(statistics, file_system, oper_messages, format, list_access),
    list_utility(validator, statistics, file_system,
      format, list_io, list_allocater, list_access),

    cud_updater(
      validator, mutil, format, login_pool, mud_change, oper_messages,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifall (overflow_cud_entries, BEFORE_SUP_V43)     overflow_controller,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      cud_entry_util, cud_access, block_updater,
$ifnone BEFORE_SUP_V43      list_utility,
      param_manager, name_access),

    cud_utility(format, cud_updater, user_terminal),

    password_read(mutil, format, user_terminal),

    password_command(mutil, user_terminal, format, password_read,
      cud_updater, cud_utility, mud_change),

    un2_util(aux_io, oper_messages, format, un2_access, mud_change),

    consistency(mutil, mud_change, un2_util, un2_access,
      block_updater, cud_entry_util, oper_messages, format, aux_io),

    sysmsg1_util(aux_io, format, oper_messages, sysmsg1_access),

(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if logical_volumes
  lv_utility, config_utility(dsksys, sys_io),
  lv_copy(user_terminal, format, lv_status_manager, lv_utility,
    oplog, statistics),
  lv_dialogue(user_terminal, keyword_scan, format, dsksys, sys_io,
    lv_status_manager, lv_utility, config_utility),
$endif logical_volumes
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

    cmd_utility(validator, sys_io, mutil,
$ifall (special, BEFORE_SUP_V43)       calendar,
      format, profile,
      oper_messages, aux_io, user_terminal, mud_change, cud_access,
      block_utility, block_updater, cud_entry_util, cud_updater,
      cud_utility, un2_util, login_pool, argument_scan, keyword_util,
      input_scanner, freeword_utility, keyword_scan, 
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if change_by_whom
"added gpo by SHSUE at 20-Jul-87 17:05:34"
$endif
$if ganpass_file_exists
      pasmon, param_manager,
$endif ganpass_file_exists
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      dsksys),

(* tape and archive handlers *)
    tape_io,

    tape_util(validator, login_pool, tape_pool, format, user_terminal),

    archive(validator, login_pool, tape_pool, mud_change, sys_io, mutil,
      statistics, file_system, param_manager, 
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if include_dump
      cmd_utility, cud_utility,
$endif include_dump
      cud_access, block_updater,
      block_utility, cud_entry_util, cud_updater,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if ganpass_file_exists
      pasmon,
$endif ganpass_file_exists
$if INCLUDE_DNIC      dnic_access,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      dsksys, tape_io, tape_util,
      user_terminal, command_read, argument_scan, freeword_utility,
      keyword_util,
      keyword_scan, scan_error, format, oplog, oper_messages, list_io,
      list_allocater, list_access, calendar, list_utility);

  block_is_locked := FALSE;

  cycle
    login;
    process_validator;
    login_pool.release_unit(user_terminal.unit);
    oper_messages.report_logout(VALIDATOR_OPLOG_MSG, profile, 
      user_terminal.logout_reason)
  end (* cycle *)
end (* command_level *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if NETVAL_IS_A_SLAVE
!
(************************************************************************)
(*									*)
(*	MSTLVL.NTV							*)
(*									*)
(*			   master_command_level				*)
(*									*)
(*	This process handles the slave CUD update function of NETVAL	*)
(*	which only exists if NETVAL_IS_A_SLAVE is enabled. The pro-	*)
(*	cess accepts logins from a master program.			*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	22Sep88 - jrn							*)
(*		- add code for password_expiration_by_user		*)
(*		- add nud_options to GET_MUD_DATA information		*)
(*		- add code for prevent_duplicate_passwords		*)
(*		- add code for restrict_users_by_time			*)
(*		- add code for allow_logon_inhibit			*)
(*	18May88 - neh							*)
(*	      - correct all_cud_data to send sync code after sending	*)
(*		mud data.						*)
(*	01Sep87 - neh							*)
(*	      - remove TYMSHARE_CUD_FORMAT				*)
(*	18Jun87 - neh							*)
(*	      - make changes for new mud format conditional on 		*)
	(*		merge 4.00 and 5.00 neh			*)
(*		BEFORE_SUP_V43 disabled					*)
(*	19Feb87 - rsb							*)
(*		- if force_password_change enabled add a parameter to	*)
(*		  calls to UPDATE_CUD_PASSWORD which specifies the 	*)
(*		  password change date is to be updated.		*)
(*		- put conditional compilation statements into 		*)
(*		  CHANGE_CPARW_COMMAND to account for 			*)
(*		  force_password_chg_exempt and no_self_passwd_change	*)
(*	10Nov86 - neh							*) 
(*	      - Make change uun and gan conditional on uun_assignable	*)
(*	06Nov86 - neh							*)
(*	      - Add all CUD errors to case statement in SET_CUD_ERROR	*)
(*		Added the following errors:				*)
(*			CUD_ENTRY_OK					*)
(*			CUD_ENTRY_ILLEGAL_NAME				*)
(*			CUD_ENTRY_OVERFLOW_FOUND			*)
(*			CUD_ENTRY_IN_WRONG_BLOCK			*)
(*	23Oct86 - neh							*) 
(*	      - Change report_message to report_master_message		*)
(* 	        to report master validator login handshake error.	*)
(*	03Spe86 - jrn							*)
(*	      - allow SET GFD ONLY and CHANGE UUN AND GAN CUD changes	*)
(*		available if not Tymshare CUD format (for BUBBNET)	*)
(*	08Aug86 - jrn							*)
(*	      - add SET_OPLOG_REMARK command				*)
(*	29Jul86 - jrn							*)
(*	      - modify NETVAL_INFO command for Bill Soley		*)
(*	14Jul86 - jrn							*)
(*	      - fix ALL_CUD_DATA command for Bill Soley			*)
(*	02Jun86 - jrn							*)
(*	      - fix bug in GET_NAME routine that caused a range error	*)
(*		if a name longer than 20 characters is sent		*)
(*	08May86 - jrn							*)
(*	      - remove separate handling of delete user and remove user	*)
(*	06May86 - jrn							*)
(*	      - fix bug when changing password to a NULL password	*)
(*	02May86 - jrn							*)
(*	      - clear UUN on new user command				*)
(*	26Feb86 - jrn							*)
(*	      - add DISK_LOAD_TEST flag					*)
(*	08Jan86 - jrn							*)
(*	      - add username to operator log report_logout message	*)
(*	      - remove UPDATE_TYMCOM_LUDS				*)
(*	09Dec85 - jrn							*)
(*	      - remove ASSIGN_CUSTOMER_NUMBERS_FROM_TYMCOM_IX		*)
(*	13Nov84 - jrn							*)
(*	      - use cud_entry_udpater CHECK_FOR_NAME_IN_CUD procedure	*)
(*		instead of the old VALID_CUD_NAME function		*)
(*	11Dec84 - Version 3.00 - neb					*)
(*									*)
(************************************************************************)


type master_command_level = process(
	validator	 	: validator_index;
	login_pool		: login_distributer;
	statistics		: statistics_gatherer;
	oplog	 		: operator_log;
	mud_change		: mud_change_handler;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifany (force_password_change, global_password_only_login)
	pasmon			: passtable_handler;
$endif any(force_password_change, global_password_only_login)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	cud_access		: cud_access_controller;
	param_manager		: cud_parameter_controller;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifall (overflow_cud_entries, BEFORE_SUP_V43)
	overflow_controller	: cud_overflow_controller;
$endif (overflow_cud_entries, BEFORE_SUP_V43)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnot BEFORE_SUP_V43
        file_system		: file_system_manager;
        list_access		: node_host_list_access;
        list_allocater		: node_host_list_allocater;
$endif BEFORE_SUP_V43
	name_access		: cud_name_controller);



const
  SYNC_CHARACTER = '(:32:)';

  NEW_USER = ONE;
  CHANGE_BILLABLE = '(:2:)';
  DELETE_USER = '(:3:)';
  CHANGE_CPARW = '(:4:)';
  CHANGE_GAN = '(:5:)';
  CHANGE_NAME = '(:6:)';
  CHECK_NAME = '(:7:)';
  ALL_CUD_DATA = '(:8:)';
  NETVAL_INFO = '(:9:)';
  GET_MUD_DATA = '(:10:)'		(* hex 0A *);
  GET_CHANGE_DATE = '(:11:)'		(* hex 0B *);
  SET_GFD_ONLY = '(:12:)'		(* hex 0C *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if changes_to_oper_log   SET_OPLOG_REMARK = '(:13:)'		(* hex 0D *);
$ifnone changes_to_oper_log   ILLEGAL_CODE_13 = '(:13:)'	(* hex 0D *);
$if before_sup_v43
  ILLEGAL_CODE_14 = '(:14:)'		(* hex 0E *);
  ILLEGAL_CODE_15 = '(:15:)'		(* hex 0F *);
  ILLEGAL_CODE_16 = '(:16:)'		(* hex 10 *);
$endif before_sup_v43
$ifnone before_sup_v43
$if allow_logon_inhibit   CHANGE_LOGON_INHIBIT = '(:14:)'	(* hex 0E *);
$ifnone allow_logon_inhibit   ILLEGAL_CODE_14 = '(:14:)'	(* hex 0E *);
$if restrict_users_by_time   CHANGE_ALLOWABLE_TIMES = '(:15:)'	(* hex 0F *);
$ifnone restrict_users_by_time   ILLEGAL_CODE_15 = '(:15:)'	(* hex 0F *);
$if password_expiration_by_user   CHANGE_VALIDITY = '(:16:)'	(* hex 10 *);
$ifnone password_expiration_by_user   ILLEGAL_CODE_16 = '(:16:)'(* hex 10 *);
$endif before_sup_v43
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  ILLEGAL_CODE_17 = '(:17:)'		(* hex 11 *);
  ILLEGAL_CODE_18 = '(:18:)'		(* hex 12 *);
  ILLEGAL_CODE_19 = '(:19:)'		(* hex 13 *);
  CHANGE_NO_PASSWORD_REQUIRED = '(:20:)'(* hex 14 *);
  CHANGE_ACCESS_ENTRY = '(:21:)'	(* hex 15 *);
  CHANGE_UUN = '(:22:)'			(* hex 16 *);
  CHANGE_UUN_AND_GAN = '(:23:)'		(* hex 17 *);
  CHANGE_IGNORE_DESTINATION = '(:24:)'	(* hex 18 *);
  CHANGE_IRC = '(:25:)'			(* hex 19 *);
  ADD_ACCESS_ENTRY = '(:26:)'		(* hex 1A *);
  DELETE_ACCESS_ENTRY = '(:27:)'	(* hex 1B *);
  CHANGE_DISTRICT = '(:28:)'		(* hex 1C *);
  GET_PASSWORD_CIPHER = '(:29:)'	(* hex 1D *);
  CHANGE_PASSWORD = '(:30:)'		(* hex 1E *);
  CHECK_OLD_PASSWORD = '(:31:)'		(* hex 1F *);
  NEW_USER_18_BIT = '(:32:)'		(* hex 20 *);

  MINIMUM_COMMAND = NEW_USER;
  MAXIMUM_COMMAND = NEW_USER_18_BIT;


(* the following defines the MASTER return codes: *)

  ENTRY_COMPLETE = ONE;
  NAME_NOT_FOUND = '(:2:)';
  NAME_IN_CUD = '(:3:)';
  CUD_FILE_BUSY = '(:4:)';
  OUT_OF_SYNC = '(:5:)';
  ILLEGAL_COMMAND = '(:6:)';
  CHANGE_FILE_ERROR = '(:7:)'	(* MUD change or LUD change file error *);
  LAST_ACCESS_ENTRY = '(:11:)'		(* hex 0B *);
  TOO_MANY_ACCESS_ENTRIES = '(:12:)'	(* hex 0C *);
  ACCESS_ENTRY_NOT_FOUND = '(:13:)'	(* hex 0D *);
  ILLEGAL_PASSWORD = '(:15:)'		(* hex 0F *);
  OPERATION_ERROR = '(:17:)'		(* hex 11...general error return *);
  PASSWORD_MISMATCH = '(:18:)'		(* hex 12 *);
  NO_UUN_AVAILABLE = '(:19:)'		(* hex 13 *);


(*	The following is for the NETVAL_INFO command, which	*)
(*	returns:						*)
(*		number of bytes following (one byte)		*)
(* 		MUD version level		     2 bytes	*)
(*		MUD revision level		     2 bytes	*)
(*		MAXIMUM_NORMAL_CUD_BLOCK	     4 bytes	*)
(*		MAXIMUM_CUD_BLOCK-MAXIMUM_NORMAL_CUD_BLOCK	*)
(*		 (NUMBER_OF_OVERFLOW_BLOCKS)	     4 bytes	*)
(*		MAXIMUM_CUD_BLOCK_SIZE_IN_SECTORS    4 bytes	*)

  NETVAL_INFO_BYTE_COUNT = 2 + (* MUD version level *)
			   2 + (* MUD revision level *)
			   4 + (* MAXIMUM_NORMAL_CUD_BLOCK *)
			   4 + (* MAXIMUM_CUD_BLOCK-MAXIMUM_NORMAL_CUD_BLOCK *)
			   4   (* MAXIMUM_CUD_BLOCK_SIZE_IN_SECTORS *);




(* the following are for internal use only *)

  LOST_CIRCUIT = '(:20:)';


(* minimum and maximum number of access	*)
(* entry values sent by the master.		*)

  MAXIMUM_ACCESS_ENTRY_VALUES = 6;
  MINIMUM_ACCESS_ENTRY_VALUES = 1;


(* flag to specify end of access profile	*)

  END_OF_ACCESS_PROFILE = '(:255:)'	(* hex 0FF *);


(* flag to specify the end of the password being transmitted. *)

  END_PASSWORD_CHARACTER = '(:109:)' 	(* hex 6D *);


(* on NEW USER command, this value for the password denotes a NULL password *)

  NULL_PASSWORD_FLAG = 3840 (* hex 00 00 0f 00 *);


(* semi colon character to check and ignore on password. *)

  SEMI_COLON = '(:59:)' (* hex 3B *);


(* Ignore password characters greater than or equal to the following. *)

  FIRST_IGNORE_PASSWORD_CHARACTER = '(:95:)';


(* The following describes the current input state.		*)
(* Since all information must be input from the MASTER		*)
(* circuit whether or not there is an error in a value,		*)
(* the return_code only keeps track of whether or not the	*)
(* circuit is in tact, and the INPUT_STATE keeps track of	*)
(* value errors.						*)

type
  CIRCUIT_INPUT_STATE = (INPUT_OK, INPUT_VALUE_ERROR);



var
  mutil			: misc_utility;
  calendar		: date_time_converter;
  format		: internal_to_string;
  profile		: validator_profile;
  oper_messages		: operator_messages;
  dsksys		: disk_system;
  block_utility		: cud_block_utility;
  block_updater		: cud_block_updater;
$ifnot BEFORE_SUP_V43
  list_io		: node_host_list_io_utility;
  list_utility		: node_host_list_utility;
  cud_updater		: mud_entry_updater;
$endif BEFORE_SUP_V43
$if BEFORE_SUP_V43   cud_updater		: cud_entry_updater;
  cud_utility		: cud_entry_utility;
  cipher_password	: password_cipher_utility;
  user_circuit		: circuit_handler;
  circuit_util		: circuit_utility;

  return_code		: char;
  input_state		: circuit_input_state;



(***********************  master_command_level  *************************)
(*									*)
(*				  login 				*)
(*									*)
(*    Wait for a login and perform a handshake; do not return		*)
(*    until there is a successful login.				*)
(*									*)
(************************************************************************)

procedure login;

var
  terminal_unit : terminal_unit_index;
  logged_in : boolean;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if changes_to_oper_log
  oplog_remark : oplog_remark_message;
$endif changes_to_oper_log
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

begin
  logged_in := FALSE;
  repeat
    login_pool.wait_for_login(profile, terminal_unit);
    user_circuit.use_circuit(terminal_unit, TERMINAL, [COMPLETE]);
    user_circuit.clear_edit_characters;
    user_circuit.set_timeout(30);
    circuit_util.exchange_handshake(STANDARD_HANDSHAKE);
    if user_circuit.available
    then
      begin
        logged_in := TRUE;
	oper_messages.report_login(MASTER_OPLOG_MSG, profile);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if changes_to_oper_log
	oplog_remark.size := 0;
	cud_updater.set_remark(oplog_remark)
$endif changes_to_oper_log
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      end
    else
      begin
        format.start;
	format.validator_type_name(MASTER_VALIDATOR);
	format.character(ASCII_SPACE);
	format.string(HANDSHAKE_ERROR);
        oper_messages.report_master_message(profile)
      end
  until logged_in
end (* login *);



(***********************  master_command_level  *************************)
(*									*)
(*				input_byte				*)
(*									*)
(*    Input a character from the circuit and set return_code if 	*)
(*    error.							        *)
(*									*)
(************************************************************************)

procedure input_byte(
  var c	: char);

begin
  user_circuit.read_one_character(c);
  if not user_circuit.available
  then return_code := LOST_CIRCUIT
end (* input_byte *);



(***********************  master_command_level  *************************)
(*									*)
(*				input_sync				*)
(*									*)
(*    Input a character from the circuit, and set return_code		*)
(*    appropriately if it is not the sync character or if there has     *)
(*    been any input error.						*)
(*									*)
(************************************************************************)

procedure input_sync;

var
  c : char;

begin
  input_byte(c);
  if return_code = ENTRY_COMPLETE
  then
    if c <> SYNC_CHARACTER
    then return_code := OUT_OF_SYNC
    else
      if input_state = INPUT_VALUE_ERROR
      then return_code := OPERATION_ERROR
end (* input_sync  *);



(***********************  master_command_level  *************************)
(*									*)
(*			    input_two_bytes				*)
(*									*)
(*   Call user_circuit.read_two_characters to input 2 characters	*)
(*     from the circuit, and if user_circuit is not available,		*)
(*     set return_code to LOST_CIRCUIT:				        *)
(*									*)
(************************************************************************)

procedure input_two_bytes(
  var word	: univ word_in_bytes);

begin
  user_circuit.read_two_characters(word);
  if not user_circuit.available
  then return_code := LOST_CIRCUIT
end (* input_two_bytes *);



(***********************  master_command_level  *************************)
(*									*)
(*			    input_three_bytes				*)
(*									*)
(*   Call user_circuit.read_three_characters to input 2 characters	*)
(*     from the circuit, and if user_circuit is not available,		*)
(*     set return_code to LOST_CIRCUIT:				        *)
(*									*)
(************************************************************************)

procedure input_three_bytes(
  var word	: univ word_in_bytes);

begin
  user_circuit.read_three_characters(word);
  if not user_circuit.available
  then return_code := LOST_CIRCUIT
end (* input_three_bytes *);



(***********************  master_command_level  *************************)
(*									*)
(*				input_word				*)
(*									*)
(*   Call user_circuit.read_word to input a word from the circuit,	*)
(*    and if user_circuit is not available, set return_code to 		*)
(*    LOST_CIRCUIT:						        *)
(*									*)
(************************************************************************)

procedure input_word(
  var word	: univ word_in_bytes);

begin
  user_circuit.read_word(word);
  if not user_circuit.available
  then return_code := LOST_CIRCUIT
end (* input_word *);



(***********************  master_command_level  *************************)
(*									*)
(*			  input_password_cipher				*)
(*									*)
(************************************************************************)

procedure input_password_cipher(
  var password_cipher	: integer);

begin
  input_word(password_cipher);
  if password_cipher = NULL_PASSWORD_FLAG
  then password_cipher := 0
end (* input_password_cipher *);



(***********************  master_command_level  *************************)
(*									*)
(*			 output_return_and_sync				*)
(*									*)
(*    Call user_circuit.write_one_character to output return_code	*)
(*    and a SYNC_CHARACTER (argument is passed here so that	 	*)
(*    this routine may be called with a supplied code, rather than 	*)
(*    setting return_code then calling this routine):		        *)
(*									*)
(************************************************************************)

procedure output_return_and_sync(
      return_code	: char);

begin
  user_circuit.write_one_character(return_code);
  user_circuit.write_one_character(SYNC_CHARACTER)
end (* output_return_and_sync *);



(***********************  master_command_level  *************************)
(*									*)
(*			output_cparw_and_options			*)
(*									*)
(*   Output CPARW and options; only used in get_mud_data_command.	*)
(*									*)
(************************************************************************)

procedure output_cparw_and_options(
$if BEFORE_SUP_V43   options	: user_options);
$ifnone BEFORE_SUP_V43   options	: mud_user_options);

var
  value : integer;

begin
  value := 0;
$if BEFORE_SUP_V43  cud_utility.pack_options(options, value);
$ifnone BEFORE_SUP_V43  cud_utility.pack_mud_options(options, value);
(* output CPARW *)
  value := mutil.right_shift(
$ifnot BEFORE_SUP_V43    BIT15, value);
$if BEFORE_SUP_V43    BIT23, value);
$ifnot BEFORE_SUP_V43  user_circuit.write_two_characters(value)
$if BEFORE_SUP_V43  user_circuit.write_three_characters(value)
end (* output_cparw_and_options *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone before_sup_v43


(***********************  master_command_level  *************************)
(*									*)
(*			   output_nud_options				*)
(*									*)
(*   Output nud_options; only used in get_mud_data_command.		*)
(*									*)
(************************************************************************)

procedure output_nud_options(
      options	: nud_user_options);

var
  value : integer;

begin
  cud_utility.pack_nud_options(options, value);
  value := mutil.right_shift(BIT15, value);
  user_circuit.write_two_characters(value)
end (* output_nud_options *);
$endif before_sup_v43
$if restrict_users_by_time



(***********************  master_command_level  *************************)
(*									*)
(*			output_allowable_times				*)
(*									*)
(*   Output allowable_times word; only used in get_mud_data_command.	*)
(*									*)
(************************************************************************)

procedure output_allowable_times(
      allowable_times : allowable_login_times);

var
  value : integer;

begin
  value := 0;
  cud_utility.pack_allowable_times(allowable_times, value);
  user_circuit.write_three_characters(value)
end (* output_allowable_times *);
$endif restrict_users_by_time
$if prevent_duplicate_passwords



(**************************  master_command_level  **********************)
(*									*)
(*			    output_previous_cipher			*)
(*									*)
(************************************************************************)

procedure output_previous_cipher(
      nud_entry : nud_user_entry);

begin
  if PREVIOUS_PASSWORD_STORED in nud_entry.nud_options
  then
    begin
      user_circuit.write_one_character(ONE);
      user_circuit.write_word(nud_entry.previous_cipher)
    end (* PREVIOUS_CIPHER_STORED in nud_entry.nud_options *)
  else user_circuit.write_one_character(ZERO)
end (* output_previous_cipher *);
$endif prevent_duplicate_passwords
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(***********************  master_command_level  *************************)
(*									*)
(*			 output_access_profile				*)
(*									*)
(*   Output the access profile.					        *)
(*									*)
(************************************************************************)

procedure output_access_profile(
      access_profile	: access_profile_description);

var
  index : access_entry_index;
  origin_index : in_place_origin_index;
  dest_index : destination_index;
  value : integer;

begin
  for index := 0 to access_profile.count - 1 do
    with access_profile.entries[index] do
      begin
	if in_place_origin
	then value := origin.size
	else value := 0;
	user_circuit.write_one_character(chr(value + destination.size));
$ifnot BEFORE_SUP_V43
	user_circuit.write_two_characters(access_control);
$endif BEFORE_SUP_V43
	value := 0;
	if in_place_origin
	then
	  begin
	    mutil.set_bit(IN_PLACE_BIT, value);
	    value := (origin.size * 2) + value;
	    if exception
	    then mutil.set_bit(EXCEPTION_BIT, value)
	  end
	else value := class_no;
	user_circuit.write_two_characters(value);
	if in_place_origin
	then
	  for origin_index := 0 to origin.size - 1 do
	    begin
	      value := origin.list[origin_index].value;
	      if origin.list[origin_index].host_flag
	      then mutil.set_bit(ORIGIN_HOST_BIT, value);
	      user_circuit.write_two_characters(value)
	    end;
	for dest_index := 0 to destination.size - 1 do
	  begin
	    value := destination.list[dest_index].value;
	    if destination.list[dest_index].group_flag
	    then mutil.set_bit(GROUP_BIT, value);
	    if destination.list[dest_index].home_flag
	    then mutil.set_bit(HOME_BIT, value);
	    user_circuit.write_two_characters(value)
	  end
      end;
  user_circuit.write_one_character(END_OF_ACCESS_PROFILE)
end (* output_access_profile *);



(***********************  master_command_level  *************************)
(*									*)
(*			     set_cud_error				*)
(*									*)
(*   Set return_code from cud_entry_result.			        *)
(*									*)
(************************************************************************)

procedure set_cud_error;

begin
  if cud_updater.last_status <> CUD_ENTRY_OK
  then
    case cud_updater.last_status of
      CUD_ENTRY_OK:		return_code := ENTRY_COMPLETE;
      CUD_ENTRY_LOCKED,
      CUD_ENTRY_FILE_LOCKED,
      CUD_ENTRY_BLOCK_LOCKED:	return_code := CUD_FILE_BUSY;
      CUD_ENTRY_NOT_FOUND:	return_code := NAME_NOT_FOUND;
      CUD_NAME_TAKEN:		return_code := NAME_IN_CUD;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if OVERFLOW_CUD_ENTRIES
      CUD_ENTRY_OVERFLOW_FOUND,
$endif OVERFLOW_CUD_ENTRIES
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      CUD_ENTRY_ILLEGAL_NAME,
      CUD_ENTRY_IN_WRONG_BLOCK,
      CUD_FORMAT_ERROR,
      CUD_ENTRY_BAD_CHECKSUM,
      CUD_ENTRY_DOES_NOT_FIT,
      CUD_ENTRY_OPERATION_FAILED:	return_code :=  OPERATION_ERROR;
      CUD_ENTRY_MUD_CHANGE_FILE_FULL,
      CUD_ENTRY_MUD_CHANGE_FILE_ERROR,
      CUD_ENTRY_LUD_CHANGE_FILE_ERROR:	return_code := CHANGE_FILE_ERROR
    end (* case *)
end (* set_cud_error *);



(***********************  master_command_level  *************************)
(*									*)
(*			output_cud_entry_result				*)
(*									*)
(*   Set and output return_code from a CUD update.		        *)
(*									*)
(************************************************************************)

procedure output_cud_entry_result;

begin
  set_cud_error;
  output_return_and_sync(return_code)
end (* output_cud_entry_result *);



(***********************  master_command_level  *************************)
(*									*)
(*			    check_input_value				*)
(*									*)
(*   Check for a legal value input and set input_state if error.	*)
(*									*)
(************************************************************************)

procedure check_input_value(
      min_value		: integer;
      max_value		: integer;
      value_input	: univ integer);

begin
  if (value_input < min_value) or (value_input > max_value)
  then input_state := INPUT_VALUE_ERROR
end (* check_input_value *);



(***********************  master_command_level  *************************)
(*									*)
(*				reserve_name				*)
(*									*)
(*     Reserve a name in the CUD.			  	        *)
(*									*)
(************************************************************************)

function reserve_name(
      name  : username_string) : boolean;

begin
  reserve_name := cud_updater.reserve_name(name);
  if cud_updater.last_status <> CUD_ENTRY_NOT_FOUND
  then set_cud_error
end (* reserve_name *);



(***********************  master_command_level  *************************)
(*									*)
(*				modify_name				*)
(*									*)
(*     Modify a name in the CUD.				        *)
(*									*)
(************************************************************************)

procedure modify_name(
$if BEFORE_SUP_V43   var cud_entry	: cud_user_entry);
$ifnone BEFORE_SUP_V43
  var mud_entry	: mud_user_entry;
  var nud_entry	: nud_user_entry);
$endif BEFORE_SUP_V43

begin
  cud_updater.modify_cud_entry(
$if BEFORE_SUP_V43   cud_entry);
$ifnone BEFORE_SUP_V43   mud_entry, nud_entry);
  set_cud_error
end (* modify_name *);



(***********************  master_command_level  *************************)
(*									*)
(*			   update_cud_options				*)
(*									*)
(*   Update the options for the name being modified.			*)
(*									*)
(************************************************************************)

procedure update_cud_options(
      password_changed	: boolean;
$if BEFORE_SUP_V43   var cud_entry		: cud_user_entry);
$ifnone BEFORE_SUP_V43
  var mud_entry		: mud_user_entry;
  var nud_entry		: nud_user_entry);
$endif BEFORE_SUP_V43

begin
$ifnot BEFORE_SUP_V43
  cud_updater.update_mud_options(password_changed, FALSE, mud_entry, nud_entry);
$endif BEFORE_SUP_V43
$if BEFORE_SUP_V43
  cud_updater.update_options(password_changed, FALSE, cud_entry);
$endif BEFORE_SUP_V43
  output_cud_entry_result
end (* update_cud_options *);



(***********************  master_command_level  *************************)
(*									*)
(*			  update_access_profile				*)
(*									*)
(*     Update the access profile for the name being modified.           *)
(*									*)
(************************************************************************)

procedure update_access_profile(
$if BEFORE_SUP_V43   var cud_entry	: cud_user_entry);
$ifnone BEFORE_SUP_V43
  var mud_entry	: mud_user_entry;
  var nud_entry : nud_user_entry);
$endif BEFORE_SUP_V43

begin
  cud_updater.update_profile(
$if BEFORE_SUP_V43   cud_entry);
$ifnone BEFORE_SUP_V43   mud_entry,nud_entry);
  output_cud_entry_result
end (* update_access_profile *);



(***********************  master_command_level  *************************)
(*									*)
(*			    get_access_entry				*)
(*									*)
(*   Input access entry information from the MASTER.	     		*)
(*									*)
(************************************************************************)

procedure get_access_entry(
  var access_entry	: access_entry_description);

var
  byte : char;
  total_values : integer;
  two_bytes : integer;
  done : boolean;
  origin_index : in_place_origin_index;
  dest_index : destination_index;

begin
  cud_utility.clear_access_entry(access_entry);
$ifnone BEFORE_SUP_V43   input_two_bytes(access_entry.access_control);
  input_byte(byte);
  total_values := ord(byte);
  check_input_value(MINIMUM_ACCESS_ENTRY_VALUES, MAXIMUM_ACCESS_ENTRY_VALUES,
    total_values);
  input_two_bytes(two_bytes);
  if not mutil.test_bit(IN_PLACE_BIT, two_bytes)
  then
    begin
      access_entry.class_no := mutil.mask(USER_CLASS_MASK, two_bytes);
      check_input_value(0, MAXIMUM_CLASS, access_entry.class_no)
    end
  else
    begin
      access_entry.in_place_origin := TRUE;
      if mutil.test_bit(EXCEPTION_BIT, two_bytes)
      then access_entry.exception := TRUE;
      access_entry.origin.size := mutil.mask(
	IN_PLACE_ORIGIN_SIZE_MASK, two_bytes) div 2;
      check_input_value(0, MAXIMUM_IN_PLACE_ORIGIN, access_entry.origin.size);
      origin_index := 0;
      done := FALSE;
      while (not done) and (return_code =  ENTRY_COMPLETE) do
	with access_entry.origin.list[origin_index] do
	  begin
	    input_two_bytes(value);
	    if mutil.test_bit(ORIGIN_HOST_BIT, value)
	    then
	      begin
		host_flag := TRUE;
	        mutil.clear_bit(ORIGIN_HOST_BIT, value);
	        check_input_value(1, MAXIMUM_HOST, value)
	      end
	    else check_input_value(1, MAXIMUM_NODE, value);
	    total_values := total_values - 1;
	    if origin_index = access_entry.origin.size - 1
	    then done := TRUE
	    else
	      if input_state = INPUT_OK
	      then origin_index := origin_index + 1
	  end
    end;
  dest_index := 0;
  while (total_values > 0) and (return_code = ENTRY_COMPLETE) do
    with access_entry.destination.list[dest_index] do
      begin
	input_two_bytes(value);
	if mutil.test_bit(HOME_BIT, value)
	then
	  begin
	    home_flag := TRUE;
	    mutil.clear_bit(HOME_BIT, value)
	  end;
	if mutil.test_bit(GROUP_BIT, value)
	then
	  begin
	    group_flag := TRUE;
	    mutil.clear_bit(GROUP_BIT, value);
	    check_input_value(0, MAXIMUM_GROUP, value)
	  end
	else check_input_value(1, MAXIMUM_HOST, value);
        total_values := total_values - 1;
        if input_state = INPUT_OK
        then
	  begin
	    access_entry.destination.size := access_entry.destination.size + 1;
	    dest_index := dest_index + 1
	  end
      end
end (* get_access_entry *);



(***********************  master_command_level  *************************)
(*									*)
(*			get_access_entry_position			*)
(*									*)
(*   Input the access entry position.				        *)
(*									*)
(************************************************************************)

procedure get_access_entry_position(
  var access_position	: access_entry_index);

var
  byte : char;

begin
  input_byte(byte);
  access_position := ord(byte) - 1;
  check_input_value(0, ACCESS_ENTRY_LIMIT, access_position)
end (* get_access_entry_position *);
$if BEFORE_SUP_V43



(***********************  master_command_level  *************************)
(*									*)
(*			      get_cparw					*)
(*									*)
(*   Input CPARW information from the MASTER.			        *)
(*									*)
(************************************************************************)

procedure get_cparw(
  var options	: user_options);

var
  value : integer;

begin
$ifnot BEFORE_SUP_V43  input_two_bytes(value);
$if BEFORE_SUP_V43  input_three_bytes(value);
  value := mutil.left_shift(
$ifnot BEFORE_SUP_V43    BIT15, value);
$if BEFORE_SUP_V43    BIT23, value);
  cud_utility.unpack_options(value, options)
end (* get_cparw *);
$endif BEFORE_SUP_V43



(***********************  master_command_level  *************************)
(*									*)
(*				get_name				*)
(*									*)
(*     Input a username from the MASTER.			        *)
(*									*)
(************************************************************************)

procedure get_name(
  var name	: username_string);

var
  word : word_in_bytes;
  name_pointer : username_text_index;
  word_pointer : word_in_bytes_index;
  done : boolean;

begin
  name.size := 0; name_pointer := 0; done := FALSE;
  repeat
    input_word(word) (* get a full word from the circuit *);
    if return_code <> ENTRY_COMPLETE
    then done := TRUE (* done if any error *)
    else
      begin (* word was input successfully, process it *)
        if mutil.negative_byte(word[0]) (* check for high order bit on *)
	then
	  begin (* high order bit on, this is last word in name *)
	    done :=  TRUE (* set done flag *);
	    mutil.clear_bit(BIT0, word) (* clear high order bit in word *)
	  end (* high order bit on, this is last word in name *);
	for word_pointer := 0 to WORD_IN_BYTES_LIMIT do
	  if word[word_pointer] <> ZERO
	  then
	    if name.size = USERNAME_TEXT_MAX
	    then input_state := INPUT_VALUE_ERROR
	    else
	      begin (* if next character is legal, save it in name *)
	        name.text[name.size] := word[word_pointer];
		name.size := name.size + 1
	      end (* if next character is legal, save it in name *)
      end (* word was input successfully, process it *)
  until done or (input_state <> INPUT_OK)
end (* get_name *);



(***********************  master_command_level  *************************)
(*									*)
(*			     get_district				*)
(*									*)
(*   Input district information from the MASTER.		        *)
(*									*)
(************************************************************************)

procedure get_district(
  var district	: univ district_number);

begin
  input_two_bytes(district);
  district := mutil.mask(district, DISTRICT_MASK)
end (* get_district *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ *)
$ifnone BEFORE_SUP_V43
$if restrict_users_by_time



(***********************  master_command_level  *************************)
(*									*)
(*			   get_allowable_times				*)
(*									*)
(*   Input allowable_times information from the MASTER.		        *)
(*									*)
(************************************************************************)

procedure get_allowable_times(
  var allowable_times	: allowable_login_times);

var
  value : integer;

begin
  input_three_bytes(value);
  cud_utility.unpack_allowable_times(value, allowable_times)
end (* get_allowable_times *);
$endif restrict_users_by_time



(***********************  master_command_level  *************************)
(*									*)
(*				get_options				*)
(*									*)
(*	Input options from the MASTER; only used on NEW USER and	*)
(*	CHANGE CPARW commands.						*)
(*									*)
(************************************************************************)

procedure get_options(
  var nud_options	: nud_user_options;
  var options		: mud_user_options);

var
  value : integer;

begin
  input_two_bytes(value);
  value := mutil.left_shift(BIT15, value);
  cud_utility.unpack_mud_options(value, options)
end (* get_options *);
$endif BEFORE_SUP_V43
$if INCLUDE_IRC



(***********************  master_command_level  *************************)
(*									*)
(*				get_irc					*)
(*									*)
(*   Input IRC information from the MASTER (if INCLUDE_IRC		*)
(*    is enabled).      						*)
(*									*)
(************************************************************************)

procedure get_irc(
  var irc	: integer);

var
  byte : char;

begin
  input_byte(byte);
  irc := ord(byte);
  check_input_value(0, MAXIMUM_IRC, irc)
end (* get_irc *);
$endif INCLUDE_IRC



(***********************  master_command_level  *************************)
(*									*)
(*			    get_date_command				*)
(*									*)
(*     Return the password change date in the appropriate format.	*)
(*									*)
(************************************************************************)

procedure get_date_command;

var
$if BEFORE_SUP_V43   cud_entry : cud_user_entry;
$ifnone BEFORE_SUP_V43
  mud_entry : mud_user_entry;
  nud_entry : nud_user_entry;
$endif BEFORE_SUP_V43
  date_to_send : integer;

begin
$if BEFORE_SUP_V43   get_name(cud_entry.name);
$ifnone BEFORE_SUP_V43   get_name(mud_entry.name);
  input_sync;
  if return_code = ENTRY_COMPLETE
  then
    begin
  cud_updater.read_cud_entry(
$if BEFORE_SUP_V43   cud_entry);
$ifnone BEFORE_SUP_V43   mud_entry, nud_entry);
      set_cud_error
    end;
  if return_code <> ENTRY_COMPLETE
  then output_return_and_sync(return_code)
  else
    begin (* return_code = ENTRY_COMPLETE *)
      date_to_send :=
$if BEFORE_SUP_V43   cud_entry.password_change_date;
$ifnone BEFORE_SUP_V43   nud_entry.password_change_date;
      if date_to_send = GFD_ONLY_PASSWORD_DATE
      then date_to_send := 0
      else date_to_send := calendar.word_time(date_to_send);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      user_circuit.write_one_character(ENTRY_COMPLETE);
      user_circuit.write_three_characters(date_to_send);
      user_circuit.write_one_character(SYNC_CHARACTER)
    end (* return_code = ENTRY_COMPLETE *)
end (* get_date_command *);



(***********************  master_command_level  *************************)
(*									*)
(*			    new_user_command				*)
(*									*)
(************************************************************************)

procedure new_user_command(
      command_code	: char);

var
$if BEFORE_SUP_V43   cud_entry : cud_user_entry;
$ifnone BEFORE_SUP_V43
  mud_entry : mud_user_entry;
  nud_entry : nud_user_entry;
$endif BEFORE_SUP_V43

begin
$if BEFORE_SUP_V43   with cud_entry do
$ifnone BEFORE_SUP_V43   with mud_entry, nud_entry do
    begin
      get_name(name);
$if BEFORE_SUP_V43       input_password_cipher(password);
$ifnone BEFORE_SUP_V43
      input_password_cipher(password.cipher);
$if prevent_duplicate_passwords       previous_cipher := NO_PREVIOUS_CIPHER;
$endif BEFORE_SUP_V43
      input_word(gan);
      gan := mutil.mask(gan, MASK_0FF_FFFF);
      input_word(uun);
(*  uun := mutil.mask(uun, MASK_0FF_FFFF); *)
      uun := 0 (* UUN SHOULD BE ASSIGNED BY NETVAL *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ *)
$if BEFORE_SUP_V43       get_cparw(options);
$ifnone BEFORE_SUP_V43
      nud_options := [];
      get_options(nud_options, mud_options);
$endif BEFORE_SUP_V43
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+ *)
      get_district(district);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if restrict_users_by_time       get_allowable_times(allowable_times);
$if INCLUDE_IRC       get_irc(irc);
$if BEFORE_SUP_V43      access_profile.count := 1;
$ifnot BEFORE_SUP_V43      mud_access_profile.count := 1;
      get_access_entry(
$if BEFORE_SUP_V43        access_profile.entries[0])
$ifnot BEFORE_SUP_V43      mud_access_profile.entries[0])
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    end (* with *);
  input_sync;
  if return_code <> ENTRY_COMPLETE
  then output_return_and_sync(return_code)
  else
    begin (* return_code = ENTRY_COMPLETE *)
$if BEFORE_SUP_V43
      cud_entry.entry_change_date := 0;
      cud_entry.password_change_date := 0;
      if not reserve_name(cud_entry.name)
$endif BEFORE_SUP_V43
$ifnone BEFORE_SUP_V43
      mud_entry.entry_type := MINIMUM_ENTRY;
      nud_entry.entry_change_date := REALTIME;
      nud_entry.password_change_date := nud_entry.entry_change_date;
      mud_entry.password.expire_date := 0;
$if password_expiration_by_user
      if not (NO_PASSWORD_REQUIRED in mud_entry.mud_options)
$ifnot assign_password_expiration_as_default
      then nud_entry.nud_options := [EXEMPT_FROM_PASSWORD_EXPIRATION];
$endif assign_password_expiration_as_default
$if assign_password_expiration_as_default
      then
        begin
	  mud_entry.entry_type := EXPIRE_DATE_IRC_ENTRY;
	  mud_entry.password.expire_date := nud_entry.password_change_date +
	    mud_change.standard_password_validity_in_seconds
	end (* user has a password *);
$endif assign_password_expiration_as_default
$endif password_expiration_by_user
      if not reserve_name(mud_entry.name)
$endif BEFORE_SUP_V43
      then output_return_and_sync(return_code)
      else
	begin (* reserve_name successful *)
	  if command_code = NEW_USER
	  then cud_updater.new_cud_entry(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if reuse_uuns 	    TRUE,
$if BEFORE_SUP_V43   cud_entry)
$ifnone BEFORE_SUP_V43   mud_entry, nud_entry)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
   	  else cud_updater.new_cud_entry(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if reuse_uuns 	    FALSE,
$if BEFORE_SUP_V43   cud_entry);
$ifnone BEFORE_SUP_V43   mud_entry, nud_entry);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  	  if cud_updater.last_status <> CUD_ENTRY_OK
	  then output_cud_entry_result
	  else
	    begin (* cud_updater.last_status = CUD_ENTRY_OK *)
	      user_circuit.write_one_character(return_code);
$if BEFORE_SUP_V43
	      user_circuit.write_word(cud_entry.gan);
	      user_circuit.write_word(cud_entry.uun);
$endif BEFORE_SUP_V43
$ifnone BEFORE_SUP_V43
	      user_circuit.write_word(nud_entry.gan);
	      user_circuit.write_word(mud_entry.uun);
$endif BEFORE_SUP_V43
	      user_circuit.write_one_character(SYNC_CHARACTER)
	    end (* cud_updater.last_status = CUD_ENTRY_OK *)
	end (* reserve_name successful *)
    end (* return_code = ENTRY_COMPLETE *)
end (* new_user_command *);



(***********************  master_command_level  *************************)
(*									*)
(*			    change_cparw_bit				*)
(*									*)
(************************************************************************)

procedure change_cparw_bit(
      bit_location	: integer;
$if BEFORE_SUP_V43
      option_to_change	: cud_control_options;
  var cud_entry		: cud_user_entry);
$endif BEFORE_SUP_V43
$ifnone BEFORE_SUP_V43
      option_to_change	: mud_control_options;
  var mud_entry		: mud_user_entry;
  var nud_entry	: nud_user_entry);
$endif BEFORE_SUP_V43

var
  value : integer;
  byte : char;

begin
$if BEFORE_SUP_V43   get_name(cud_entry.name);
$ifnone BEFORE_SUP_V43   get_name(mud_entry.name);
  input_byte(byte);
  value := mutil.left_shift(
$if BEFORE_SUP_V43    BIT19, ord(byte)) (* shift left 1.5 bytes *);
$ifnot BEFORE_SUP_V43    BIT7, ord(byte)) (* shift left 3 bytes *);
  input_sync;
  if return_code = ENTRY_COMPLETE
$if BEFORE_SUP_V43   then modify_name(cud_entry);
$ifnone BEFORE_SUP_V43   then modify_name(mud_entry, nud_entry);
  if return_code <> ENTRY_COMPLETE
  then output_return_and_sync(return_code)
  else
    begin
$if BEFORE_SUP_V43   cud_entry.options := cud_entry.options -
$ifnone BEFORE_SUP_V43   mud_entry.mud_options := mud_entry.mud_options -
	[option_to_change];
      if mutil.test_bit(bit_location, value)
$if BEFORE_SUP_V43   then cud_entry.options := cud_entry.options or
$ifnone BEFORE_SUP_V43   then mud_entry.mud_options := mud_entry.mud_options or
	[option_to_change]  
    end
end (* change_cparw_bit *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifall (BEFORE_SUP_V43, CHECK_TIME_STATUS)



(***********************  master_command_level  *************************)
(*									*)
(*			 change_billable_command			*)
(*									*)
(************************************************************************)

procedure change_billable_command;

var
$if BEFORE_SUP_V43 cud_entry : cud_user_entry;
$ifnot BEFORE_SUP_V43
  mud_entry : mud_user_entry;
  nud_entry : nud_user_entry;
$endif BEFORE_SUP_V43

begin
  change_cparw_bit(BILLABLE_BIT, BILLABLE_OPTION, cud_entry);
  if return_code = ENTRY_COMPLETE
  then update_cud_options(FALSE, cud_entry)
end (* change_billable_command *);
$endif (BEFORE_SUP_V43, CHECK_TIME_STATUS)



(***********************  master_command_level  *************************)
(*									*)
(*			 change_ignore_host_command			*)
(*									*)
(************************************************************************)

procedure change_ignore_host_command;

var
$if BEFORE_SUP_V43   cud_entry : cud_user_entry;
$ifnot BEFORE_SUP_V43
  mud_entry : mud_user_entry;
  nud_entry : nud_user_entry;
$endif BEFORE_SUP_V43

begin
  change_cparw_bit(
$if BEFORE_SUP_V43  IGNORE_HOST_BIT, IGNORE_DESTINATION, cud_entry);
$ifnone BEFORE_SUP_V43  IGNORE_DESTINATION_BIT, IGNORE_DESTINATION, mud_entry, nud_entry);
  if return_code = ENTRY_COMPLETE
  then update_cud_options(FALSE,
$if BEFORE_SUP_V43   cud_entry)
$ifnone BEFORE_SUP_V43   mud_entry, nud_entry)
end (* change_ignore_host_command *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(***********************  master_command_level  *************************)
(*									*)
(*			 change_no_password_command			*)
(*									*)
(************************************************************************)

procedure change_no_password_command;

var
$if BEFORE_SUP_V43   cud_entry : cud_user_entry;
$ifnot BEFORE_SUP_V43
  mud_entry : mud_user_entry;
  nud_entry : nud_user_entry;
$endif BEFORE_SUP_V43

begin
  change_cparw_bit(
$if BEFORE_SUP_V43  NO_PASSWORD_BIT, NO_PASSWORD_REQUIRED, cud_entry);
$ifnone BEFORE_SUP_V43  NO_PASSWORD_REQUIRED_BIT, NO_PASSWORD_REQUIRED, mud_entry, nud_entry);
  if return_code = ENTRY_COMPLETE
  then
    begin
$if BEFORE_SUP_V43
      cud_entry.options := cud_entry.options or [NEW_PASSWORD_OPTION];
      update_cud_options(TRUE, cud_entry) (* note that "password" changed *)
$endif BEFORE_SUP_V43
$ifnone BEFORE_SUP_V43
      update_cud_options(TRUE, mud_entry, nud_entry) (* note that "password" changed *)
$endif BEFORE_SUP_V43
    end
end (* change_no_password_command *);



(***********************  master_command_level  *************************)
(*									*)
(*			  delete_user_command				*)
(*									*)
(*	The DELETE USER and REMOVE USER commands used to be different;	*)
(*	the REMOVE USER command did not notify the LUD or MUD change	*)
(*	file of the deletion.						*)
(*	It was used in the case of notifying the CUD update slave of a	*)
(*	change, then finding a problem in the accounting data base, and	*)
(*	reversing the change in the CUD.  If the change is then made	*)
(*	again, and the deletion is still in the LUD change file, PJ	*)
(*	might have been wiping out the second validation on the host.	*)
(*	There seems to be absolutely no reason not to notify the MUD	*)
(*	change file of the change.					*)
(*									*)
(************************************************************************)

procedure delete_user_command;

var
$if BEFORE_SUP_V43   cud_entry : cud_user_entry;
$ifnone BEFORE_SUP_V43
  mud_entry : mud_user_entry;
  nud_entry : nud_user_entry;
$endif BEFORE_SUP_V43

begin
$if BEFORE_SUP_V43   get_name(cud_entry.name);
$ifnone BEFORE_SUP_V43   get_name(mud_entry.name);
  input_sync;
  if return_code = ENTRY_COMPLETE
$if BEFORE_SUP_V43   then modify_name(cud_entry);
$ifnone BEFORE_SUP_V43   then modify_name(mud_entry, nud_entry);
  if return_code = ENTRY_COMPLETE
  then
    begin
      cud_updater.delete_cud_entry
$if BEFORE_SUP_V43
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if reuse_uuns       (cud_entry.uun)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$endif BEFORE_SUP_V43
$ifnone BEFORE_SUP_V43
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if reuse_uuns       (mud_entry.uun)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$endif BEFORE_SUP_V43
;
      output_cud_entry_result
    end
  else output_return_and_sync(return_code)
end (* delete_user_command *);



(***********************  master_command_level  *************************)
(*									*)
(*			  change_cparw_command				*)
(*									*)
(************************************************************************)

procedure change_cparw_command;

var
$if BEFORE_SUP_V43
  cud_entry : cud_user_entry;
  temp_options : user_options;
$endif BEFORE_SUP_V43
$ifnone BEFORE_SUP_V43
  mud_entry : mud_user_entry;
  nud_entry : nud_user_entry;
  temp_options : mud_user_options;
$endif BEFORE_SUP_V43

begin
$if BEFORE_SUP_V43
  get_name(cud_entry.name);
  get_cparw(temp_options);
$endif BEFORE_SUP_V43
$ifnot BEFORE_SUP_V43
  get_name(mud_entry.name);
  get_options(nud_entry.nud_options, temp_options);
$endif BEFORE_SUP_V43
  input_sync;
  if return_code = ENTRY_COMPLETE
$if BEFORE_SUP_V43   then modify_name(cud_entry);
$ifnone BEFORE_SUP_V43   then modify_name(mud_entry, nud_entry);
  if return_code = ENTRY_COMPLETE
  then
    begin
$if BEFORE_SUP_V43
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      cud_entry.options := (cud_entry.options -
	[SHUT_OVERRIDE, ACCOUNT_SUPERVISOR,
$if force_password_change 	FPC_EXEMPT,
$if no_self_password_change 	NSP_CHANGE,
	 TRANSPARENT_LOGIN]) or temp_options; 
      update_cud_options(FALSE, cud_entry)
$endif BEFORE_SUP_V43
$ifnone BEFORE_SUP_V43
      mud_entry.mud_options := (mud_entry.mud_options -
        [USERNAME_TYPE, HOSTNAME_TYPE, TRANSPARENT_LOGIN, AUX_PASSWORD]) or
	temp_options; 
      update_cud_options(FALSE, mud_entry, nud_entry)
$endif BEFORE_SUP_V43
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    end
  else output_return_and_sync(return_code)
end (* change_cparw_command *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone before_sup_v43
$if allow_logon_inhibit


(***********************  master_command_level  *************************)
(*									*)
(*			 change_inhibit_command				*)
(*									*)
(************************************************************************)

procedure change_inhibit_command;

var
  mud_entry : mud_user_entry;
  nud_entry : nud_user_entry;
  inhibit_byte : char;
  inhibit_value : integer;

begin
  get_name(mud_entry.name);
  input_byte(inhibit_byte);
  input_sync;
  if return_code = ENTRY_COMPLETE
  then modify_name(mud_entry, nud_entry);
  if return_code = ENTRY_COMPLETE
  then 
    begin
      inhibit_value := ord(inhibit_byte);
      if inhibit_value = 0
      then mud_entry.mud_options := mud_entry.mud_options - [LOGON_INHIBIT]
      else
        if inhibit_value = 1
	then mud_entry.mud_options := mud_entry.mud_options or [LOGON_INHIBIT]
	else return_code := OPERATION_ERROR
    end;
  if return_code = ENTRY_COMPLETE
  then update_cud_options(FALSE, mud_entry, nud_entry)
  else output_return_and_sync(return_code)
end (* change_inhibit_command *);
$endif allow_logon_inhibit
$endif before_sup_v43
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(***********************  master_command_level  *************************)
(*									*)
(*			   change_gan_command				*)
(*									*)
(************************************************************************)

procedure change_gan_command;

var
$if BEFORE_SUP_V43   cud_entry : cud_user_entry;
$ifnone BEFORE_SUP_V43
  mud_entry : mud_user_entry;
  nud_entry : nud_user_entry;
$endif BEFORE_SUP_V43
  gan : integer;

begin
$if BEFORE_SUP_V43   get_name(cud_entry.name);
$ifnone BEFORE_SUP_V43   get_name(mud_entry.name);
  input_word(gan);
  input_sync;
  if return_code = ENTRY_COMPLETE
$if BEFORE_SUP_V43   then modify_name(cud_entry);
$ifnone BEFORE_SUP_V43   then modify_name(mud_entry, nud_entry);
  if return_code = ENTRY_COMPLETE
  then
    begin
      cud_updater.update_gan(gan);
      output_cud_entry_result
    end
  else output_return_and_sync(return_code)
end (* change_gan_command *);



(***********************  master_command_level  *************************)
(*									*)
(*			  change_name_command				*)
(*									*)
(************************************************************************)

procedure change_name_command;

var
$if BEFORE_SUP_V43   cud_entry : cud_user_entry;
$ifnone BEFORE_SUP_V43
  mud_entry : mud_user_entry;
  nud_entry : nud_user_entry;
$endif BEFORE_SUP_V43
  new_name : username_string;

begin
  get_name(new_name);
$if BEFORE_SUP_V43   get_name(cud_entry.name);
$ifnone BEFORE_SUP_V43   get_name(mud_entry.name);
  input_sync;
  if return_code = ENTRY_COMPLETE
$if BEFORE_SUP_V43
  then modify_name(cud_entry);
  cud_entry.name := new_name;
$endif BEFORE_SUP_V43
$ifnone BEFORE_SUP_V43
  then modify_name(mud_entry, nud_entry);
  mud_entry.name := new_name;
$endif BEFORE_SUP_V43
  if return_code = ENTRY_COMPLETE
  then
    begin
$if BEFORE_SUP_V43
      if reserve_name(cud_entry.name)
      then cud_updater.rename_cud_entry(cud_entry);
$endif BEFORE_SUP_V43
$ifnone BEFORE_SUP_V43
      if reserve_name(mud_entry.name)
      then cud_updater.rename_cud_entry(mud_entry, nud_entry);
$endif BEFORE_SUP_V43
      output_cud_entry_result
    end
  else output_return_and_sync(return_code)
end (* change_name_command *);



(***********************  master_command_level  *************************)
(*									*)
(*			   check_name_command				*)
(*									*)
(************************************************************************)

procedure check_name_command;

var
  name : username_string;

begin
  get_name(name);
  input_sync;
  if return_code <> ENTRY_COMPLETE
  then output_return_and_sync(return_code)
  else
    begin
      cud_updater.check_for_name_in_cud(name);
      output_cud_entry_result
    end (* return_code = ENTRY_COMPLETE *)
end (* check_name_command *);



(***********************  master_command_level  *************************)
(*									*)
(*			  all_cud_data_command				*)
(*									*)
(************************************************************************)

procedure all_cud_data_command;

var
  block	: cud_block_index;
  cud_status : cud_entry_result;
  result : cud_operation_result;
$if BEFORE_SUP_V43  cud_buffer : cud_disk_block; 
$ifnot BEFORE_SUP_V43  cud_buffer : cud_data_block;
  data_size : integer;

begin
  input_two_bytes(block);
  check_input_value(0, MAXIMUM_CUD_BLOCK, block);
  input_sync;
  if return_code = ENTRY_COMPLETE
  then
    begin
      block_utility.read_cud_block(block, result, cud_buffer);
      if result <> CUD_OPERATION_OK
      then
        if (result = CUD_FILE_LOCKED) or (result = CUD_BLOCK_MANUALLY_LOCKED)
	then return_code := CUD_FILE_BUSY
	else return_code := OPERATION_ERROR
    end (* return_code = ENTRY_COMPLETE *);
  if return_code = ENTRY_COMPLETE
  then
    begin
      user_circuit.write_one_character(ENTRY_COMPLETE);
      user_circuit.write_two_characters(block);
      cud_status := CUD_ENTRY_OK;
$if BEFORE_SUP_V43      cud_utility.cud_block_byte_count(cud_buffer.data,
$ifnot BEFORE_SUP_V43      cud_utility.mud_block_byte_count(cud_buffer.data,
	block, cud_status, data_size);
      user_circuit.write_two_characters(data_size);
      user_circuit.write_mud_data(data_size,
$if BEFORE_SUP_V43        cud_buffer.data);
$ifnot BEFORE_SUP_V43        cud_buffer.data.mud_block.data);
      user_circuit.write_one_character(SYNC_CHARACTER)
    end (* CUD_OPERATION_OK *)
  else output_return_and_sync(return_code)
end (* all_cud_data_command *);



(***********************  master_command_level  *************************)
(*									*)
(*			   netval_info_command				*)
(*									*)
(************************************************************************)

procedure netval_info_command;

var
  value : integer;

begin
  input_sync;
  if return_code <> ENTRY_COMPLETE
  then output_return_and_sync(return_code)
  else
    begin
      user_circuit.write_one_character(ENTRY_COMPLETE);
      user_circuit.write_one_character(chr(NETVAL_INFO_BYTE_COUNT));
      value := MUD_VERSION_NUMBER;
      user_circuit.write_two_characters(value);
      value := MUD_REVISION_NUMBER;
      user_circuit.write_two_characters(value);
      value := MAXIMUM_NORMAL_CUD_BLOCK;
      user_circuit.write_word(value);
      value := MAXIMUM_CUD_BLOCK-MAXIMUM_NORMAL_CUD_BLOCK (* overflow blcks *);
      user_circuit.write_word(value);
      value := MAXIMUM_CUD_BLOCK_SIZE_IN_SECTORS;
      user_circuit.write_word(value);
      user_circuit.write_one_character(SYNC_CHARACTER)
    end (* return_code <> ENTRY_COMPLETE *)
end (* netval_info_command *);



(***********************  master_command_level  *************************)
(*									*)
(*			  get_mud_data_command				*)
(*									*)
(************************************************************************)

procedure get_mud_data_command;

var
  byte : char;
  date_to_send : integer;
$if BEFORE_SUP_V43   cud_entry : cud_user_entry;
$ifnone BEFORE_SUP_V43
  mud_entry : mud_user_entry;
  nud_entry : nud_user_entry;
$if prevent_duplicate_passwords   min_password_date : integer;
$endif BEFORE_SUP_V43

begin
$if BEFORE_SUP_V43   get_name(cud_entry.name);
$ifnone BEFORE_SUP_V43   get_name(mud_entry.name);
  input_sync;
  if return_code = ENTRY_COMPLETE
  then
    begin
$if BEFORE_SUP_V43      cud_updater.read_cud_entry(cud_entry);
$ifnone BEFORE_SUP_V43      cud_updater.read_cud_entry(mud_entry, nud_entry);
      set_cud_error
    end;
  if return_code <> ENTRY_COMPLETE
  then output_return_and_sync(return_code)
  else
    begin
      user_circuit.write_one_character(ENTRY_COMPLETE);
$if BEFORE_SUP_V43       with cud_entry do
$ifnone BEFORE_SUP_V43       with mud_entry, nud_entry do
	begin
          user_circuit.write_word(gan);
	  user_circuit.write_word(uun);
$if BEFORE_SUP_V43 	  output_cparw_and_options(options);
$ifnone BEFORE_SUP_V43 	  output_cparw_and_options(mud_options);
          user_circuit.write_two_characters(district);
$if restrict_users_by_time 	  output_allowable_times(allowable_times);
$if INCLUDE_IRC
          byte := chr(irc);
	  user_circuit.write_one_character(byte);
$endif INCLUDE_IRC
$ifnot BEFORE_SUP_V43
	  output_access_profile(mud_access_profile);
$if prevent_duplicate_passwords
(* output legal password change date *)
	  min_password_date := nud_entry.password_change_date +
	    mud_change.minimum_password_change_time_in_seconds;
	  user_circuit.write_word(min_password_date);
	  output_previous_cipher(nud_entry);
$endif prevent_duplicate_passwords
	  output_nud_options(nud_entry.nud_options);
$if password_expiration_by_user
	  date_to_send := calendar.word_time(password.expire_date);
	  user_circuit.write_three_characters(date_to_send);
$endif password_expiration_by_user
	  date_to_send := nud_entry.password_change_date;
$endif BEFORE_SUP_V43
$if BEFORE_SUP_V43
	  output_access_profile(access_profile);
	  date_to_send := cud_entry.password_change_date;
$endif BEFORE_SUP_V43
          if date_to_send = GFD_ONLY_PASSWORD_DATE
          then date_to_send := 0
          else date_to_send := calendar.word_time(date_to_send);
          user_circuit.write_three_characters(date_to_send)
	end (* with *);
      user_circuit.write_one_character(SYNC_CHARACTER)
    end
end (* get_mud_data_command *);
$if BEFORE_SUP_V43



(***********************  master_command_level  *************************)
(*									*)
(*			  set_gfd_only_command				*)
(*									*)
(************************************************************************)

procedure set_gfd_only_command;

var
  cud_entry : cud_user_entry;

begin
  get_name(cud_entry.name);
  input_sync;
  if return_code = ENTRY_COMPLETE
  then modify_name(cud_entry);
  if return_code = ENTRY_COMPLETE
  then
    begin
      cud_updater.update_gfd_only;
      output_cud_entry_result
    end
  else output_return_and_sync(return_code)
end (* set_gfd_only_command *);
$endif BEFORE_SUP_V43



(***********************  master_command_level  *************************)
(*									*)
(*			change_access_entry_command			*)
(*									*)
(************************************************************************)

procedure change_access_entry_command;

var
$if BEFORE_SUP_V43   cud_entry : cud_user_entry;
$ifnone BEFORE_SUP_V43
  mud_entry : mud_user_entry;
  nud_entry : nud_user_entry;
$endif BEFORE_SUP_V43
  access_entry : access_entry_description;
  access_position : access_entry_index;

begin
$if BEFORE_SUP_V43   get_name(cud_entry.name);
$ifnone BEFORE_SUP_V43   get_name(mud_entry.name);
  get_access_entry_position(access_position);
  get_access_entry(access_entry);
  input_sync;
  if return_code = ENTRY_COMPLETE
$if BEFORE_SUP_V43   then modify_name(cud_entry);
$ifnone BEFORE_SUP_V43   then modify_name(mud_entry, nud_entry);
  if (return_code = ENTRY_COMPLETE) and
$if BEFORE_SUP_V43   (access_position >= cud_entry.access_profile.count)
$ifnone BEFORE_SUP_V43   (access_position >= mud_entry.mud_access_profile.count)
  then
    begin
      return_code := ACCESS_ENTRY_NOT_FOUND;
      cud_updater.abort_cud_change
    end;
  if return_code = ENTRY_COMPLETE
  then 
    begin
$if BEFORE_SUP_V43
      cud_entry.access_profile.entries[access_position] := access_entry;
      update_access_profile(cud_entry)
$endif BEFORE_SUP_V43
$ifnone BEFORE_SUP_V43
      mud_entry.mud_access_profile.entries[access_position] := access_entry;
      update_access_profile(mud_entry, nud_entry)
$endif BEFORE_SUP_V43
    end
  else output_return_and_sync(return_code)
end (* change_access_entry_command *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if UUNSassignable



(***********************  master_command_level  *************************)
(*									*)
(*			   change_uun_command				*)
(*									*)
(************************************************************************)

procedure change_uun_command;

var
$if BEFORE_SUP_V43   cud_entry : cud_user_entry;
$ifnot BEFORE_SUP_V43
  mud_entry : mud_user_entry;
  nud_entry : nud_user_entry;
$endif BEFORE_SUP_V43
  uun : integer;

begin
$if BEFORE_SUP_V43   get_name(cud_entry.name);
$ifnone BEFORE_SUP_V43   get_name(mud_entry.name);
  input_word(uun);
  input_sync;
  if return_code = ENTRY_COMPLETE
$if BEFORE_SUP_V43   then modify_name(cud_entry);
$ifnone BEFORE_SUP_V43   then modify_name(mud_entry, nud_entry);
  if return_code = ENTRY_COMPLETE
  then
    begin
      cud_updater.update_uun(uun);
      output_cud_entry_result 
    end
  else output_return_and_sync(return_code)
end (* change_uun_command *);



(***********************  master_command_level  *************************)
(*									*)
(*		       change_uun_and_gan_command			*)
(*									*)
(************************************************************************)

procedure change_uun_and_gan_command;

var
$if BEFORE_SUP_V43   cud_entry : cud_user_entry;
$ifnot BEFORE_SUP_V43
  mud_entry : mud_user_entry;
  nud_entry : nud_user_entry;
$endif BEFORE_SUP_V43
  gan : integer;
  uun : integer;

begin
$if BEFORE_SUP_V43   get_name(cud_entry.name);
$ifnone BEFORE_SUP_V43   get_name(mud_entry.name);
  input_word(gan);
  input_word(uun);
  input_sync;
  if return_code = ENTRY_COMPLETE
$if BEFORE_SUP_V43   then modify_name(cud_entry);
$ifnone BEFORE_SUP_V43   then modify_name(mud_entry, nud_entry);
  if return_code = ENTRY_COMPLETE
  then
    begin
      cud_updater.update_uun_and_gan(gan, uun);
      output_cud_entry_result 
    end
  else output_return_and_sync(return_code)
end (* change_uun_and_gan_command *);
$endif UUNSassignable
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if INCLUDE_IRC



(***********************  master_command_level  *************************)
(*									*)
(*			   change_irc_command				*)
(*									*)
(************************************************************************)

procedure change_irc_command;

var
$if BEFORE_SUP_V43   cud_entry : cud_user_entry;
$ifnone BEFORE_SUP_V43
  mud_entry : mud_user_entry;
  nud_entry : nud_user_entry;
$endif BEFORE_SUP_V43
  value : integer;

begin
$if BEFORE_SUP_V43   get_name(cud_entry.name);
$ifnone BEFORE_SUP_V43   get_name(mud_entry.name);
  get_irc(value);
  input_sync;
  if return_code = ENTRY_COMPLETE
$if BEFORE_SUP_V43   then modify_name(cud_entry);
$ifnone BEFORE_SUP_V43   then modify_name(mud_entry, nud_entry);
  if return_code = ENTRY_COMPLETE
  then
    begin
      cud_updater.update_irc(value);
      output_cud_entry_result
    end
  else output_return_and_sync(return_code)
end (* change_irc_command *);
$endif INCLUDE_IRC
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(***********************  master_command_level  *************************)
(*									*)
(*			add_access_entry_command			*)
(*									*)
(************************************************************************)

procedure add_access_entry_command;

var
$if BEFORE_SUP_V43   cud_entry : cud_user_entry;
$ifnot BEFORE_SUP_V43
  mud_entry : mud_user_entry;
  nud_entry : nud_user_entry;
$endif BEFORE_SUP_V43
  access_entry : access_entry_description;

begin
$if BEFORE_SUP_V43   get_name(cud_entry.name);
$ifnone BEFORE_SUP_V43   get_name(mud_entry.name);
  get_access_entry(access_entry);
  input_sync;
  if return_code = ENTRY_COMPLETE
$if BEFORE_SUP_V43   then modify_name(cud_entry);
$ifnone BEFORE_SUP_V43   then modify_name(mud_entry, nud_entry);
  if return_code = ENTRY_COMPLETE
  then
$if BEFORE_SUP_V43   if cud_entry.access_profile.count = MAXIMUM_ACCESS_ENTRY
$ifnone BEFORE_SUP_V43   if mud_entry.mud_access_profile.count = MAXIMUM_ACCESS_ENTRY
    then
      begin
        cud_updater.abort_cud_change;
	output_return_and_sync(TOO_MANY_ACCESS_ENTRIES)
      end
    else
      begin
$if BEFORE_SUP_V43
        cud_entry.access_profile.entries[cud_entry.access_profile.count] :=
	  access_entry;
	cud_entry.access_profile.count := cud_entry.access_profile.count + 1;
	update_access_profile(cud_entry)
$endif BEFORE_SUP_V43
$ifnone BEFORE_SUP_V43
        mud_entry.mud_access_profile.entries[mud_entry.mud_access_profile.count] :=
	  access_entry;
	mud_entry.mud_access_profile.count := mud_entry.mud_access_profile.count + 1;
	update_access_profile(mud_entry, nud_entry)
$endif BEFORE_SUP_V43
      end
    else output_return_and_sync(return_code)
end (* add_access_entry_command *);



(***********************  master_command_level  *************************)
(*									*)
(*			delete_access_entry_command			*)
(*									*)
(************************************************************************)

procedure delete_access_entry_command;

var
$if BEFORE_SUP_V43   cud_entry : cud_user_entry;
$ifnot BEFORE_SUP_V43
  mud_entry : mud_user_entry;
  nud_entry : nud_user_entry;
$endif BEFORE_SUP_V43
  access_position : access_entry_index;

begin
$if BEFORE_SUP_V43   get_name(cud_entry.name);
$ifnone BEFORE_SUP_V43   get_name(mud_entry.name);
  get_access_entry_position(access_position);
  input_sync;
  if return_code = ENTRY_COMPLETE
$if BEFORE_SUP_V43   then modify_name(cud_entry);
$ifnone BEFORE_SUP_V43   then modify_name(mud_entry, nud_entry);
  if return_code = ENTRY_COMPLETE
  then
    begin
$if BEFORE_SUP_V43   if access_position >= cud_entry.access_profile.count
$ifnone BEFORE_SUP_V43   if access_position >= mud_entry.mud_access_profile.count
      then return_code := ACCESS_ENTRY_NOT_FOUND
      else
$if BEFORE_SUP_V43   if cud_entry.access_profile.count = 1
$ifnone BEFORE_SUP_V43   if mud_entry.mud_access_profile.count = 1
	then return_code := LAST_ACCESS_ENTRY;
      if return_code <> ENTRY_COMPLETE
      then cud_updater.abort_cud_change
    end;
  if return_code = ENTRY_COMPLETE
  then
    begin
      cud_utility.remove_access_entry(access_position,
$if BEFORE_SUP_V43
        cud_entry.access_profile);
      update_access_profile(cud_entry)
$endif BEFORE_SUP_V43
$ifnone BEFORE_SUP_V43
        mud_entry.mud_access_profile);
      update_access_profile(mud_entry, nud_entry)
$endif BEFORE_SUP_V43
    end
  else output_return_and_sync(return_code)
end (* delete_access_entry_command *);



(***********************  master_command_level  *************************)
(*									*)
(*			change_district_command				*)
(*									*)
(************************************************************************)

procedure change_district_command;

var
$if BEFORE_SUP_V43   cud_entry : cud_user_entry;
$ifnot BEFORE_SUP_V43
  mud_entry : mud_user_entry;
  nud_entry : nud_user_entry;
$endif BEFORE_SUP_V43
  district : integer;

begin
$if BEFORE_SUP_V43   get_name(cud_entry.name);
$ifnone BEFORE_SUP_V43   get_name(mud_entry.name);
  get_district(district);
  input_sync;
  if return_code = ENTRY_COMPLETE
$if BEFORE_SUP_V43   then modify_name(cud_entry);
$ifnone BEFORE_SUP_V43   then modify_name(mud_entry, nud_entry);
  if return_code = ENTRY_COMPLETE
  then
    begin
      cud_updater.update_district(district);
      output_cud_entry_result
    end
  else output_return_and_sync(return_code)
end (* change_district_command *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if restrict_users_by_time



(***********************  master_command_level  *************************)
(*									*)
(*		     change_allowable_times_command			*)
(*									*)
(************************************************************************)

procedure change_allowable_times_command;

var
  mud_entry : mud_user_entry;
  nud_entry : nud_user_entry;
  allowable_times : allowable_login_times;

begin
  get_name(mud_entry.name);
  get_allowable_times(allowable_times);
  input_sync;
  if return_code = ENTRY_COMPLETE
  then modify_name(mud_entry, nud_entry);
  if return_code = ENTRY_COMPLETE
  then
    begin
      cud_updater.update_allowable_times(allowable_times);
      output_cud_entry_result
    end
  else output_return_and_sync(return_code)
end (* change_allowable_times_command *);
$endif restrict_users_by_time
$if password_expiration_by_user



(***********************  master_command_level  *************************)
(*									*)
(*		     	change_validity_command				*)
(*									*)
(************************************************************************)

procedure change_validity_command;

var
  mud_entry : mud_user_entry;
  nud_entry : nud_user_entry;
  cud_entry : small_cud_entry;
  byte : char;
  options_word : integer;
  validity_period : integer;

begin
  get_name(mud_entry.name);
  input_byte(byte);
  mutil.save_characters_in_word(byte, ZERO, ZERO, ZERO, options_word);
  nud_entry.nud_options := nud_entry.nud_options -
    [EXEMPT_FROM_PASSWORD_EXPIRATION, NON_STANDARD_PASSWORD_EXPIRATION];
  if mutil.test_bit(BIT0, options_word)
  then nud_entry.nud_options := nud_entry.nud_options or
    [EXEMPT_FROM_PASSWORD_EXPIRATION];
  validity_period := 0;
  if mutil.test_bit(BIT1, options_word)
  then
    begin (* user should have non standard password expiration *)
      nud_entry.nud_options := nud_entry.nud_options or
        [NON_STANDARD_PASSWORD_EXPIRATION];
      input_byte(byte);
      if EXEMPT_FROM_PASSWORD_EXPIRATION in nud_entry.nud_options
      then return_code := OPERATION_ERROR (* user is exempt? *)
      else validity_period := ord(byte) * SECONDS_PER_DAY
    end (* user should have non standard password expiration *)
  else validity_period := mud_change.standard_password_validity_in_seconds;
  input_sync;
  if return_code = ENTRY_COMPLETE
  then modify_name(mud_entry, nud_entry);
  if return_code <> ENTRY_COMPLETE
  then output_return_and_sync(return_code)
  else
    begin
      cud_updater.update_nud_options(TRUE, nud_entry);
      if cud_updater.last_status <> CUD_ENTRY_OK
      then output_cud_entry_result
      else
        begin
	  cud_entry.name := mud_entry.name;
	  cud_updater.modify_cud_password(cud_entry);
	  if cud_updater.last_status = CUD_ENTRY_OK
	  then cud_updater.update_password_expiration_date(validity_period,
	    cud_entry);
	  output_cud_entry_result
	end
    end
end (* change_validity_command *);
$endif password_expiration_by_user
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(***********************  master_command_level  *************************)
(*									*)
(*			get_password_cipher_command			*)
(*									*)
(************************************************************************)

procedure get_password_cipher_command;

var
  byte : char;
  done : boolean;
  password : password_string;
  password_index : password_text_index;
  password_cipher : integer;

begin
  done := FALSE;
  password_index := 0;
  repeat
    input_byte(byte);
    if return_code = ENTRY_COMPLETE
    then
      if byte = END_PASSWORD_CHARACTER
      then
        begin
	  done := TRUE;
	  password.size := password_index
	end (* byte = END_PASSWORD_CHARACTER *)
      else
	begin (* byte <> END_PASSWORD_CHARACTER *)
	  byte := chr(mutil.mask((ord(byte) + 32), MASK_7F));
	  if (byte <> SEMI_COLON) and (byte < FIRST_IGNORE_PASSWORD_CHARACTER)
	  then
	    begin (* save this password character *)
	      password.text[password_index] := byte;
	      if password_index < PASSWORD_TEXT_LIMIT
	      then password_index := password_index + 1
	      else
	        begin (* full password has been input *)
		  done := TRUE;
		  password.size := PASSWORD_TEXT_MAX;
		  input_byte(byte);
		  if byte <> END_PASSWORD_CHARACTER
		  then
		    begin (* more characters to input *)
		      input_state := INPUT_VALUE_ERROR;
		      repeat (* input any remaining characters *)
		        input_byte(byte)
		      until (byte = END_PASSWORD_CHARACTER) or
		        (return_code <> ENTRY_COMPLETE)
		    end (* more characters to input *)
		end (* full password has been input *)
	    end (* save this password character *)
	end (* byte <> END_PASSWORD_CHARACTER *)
  until (return_code <> ENTRY_COMPLETE) or done;
  input_sync;
  if return_code = ENTRY_COMPLETE
  then
    begin
      user_circuit.write_one_character(ENTRY_COMPLETE);
      password_cipher := cipher_password.convert(password);
      user_circuit.write_word(password_cipher);
      user_circuit.write_one_character(SYNC_CHARACTER)
    end
  else output_return_and_sync(return_code)
end (* get_password_cipher_command *);



(***********************  master_command_level  *************************)
(*									*)
(*			change_password_command				*)
(*									*)
(************************************************************************)

procedure change_password_command;

var
$if BEFORE_SUP_V43   cud_entry : cud_user_entry;
$ifnone BEFORE_SUP_V43 
  mud_entry : mud_user_entry;
  nud_entry : nud_user_entry;
$endif BEFORE_SUP_V43
  password_cipher : integer;

begin
$if BEFORE_SUP_V43   get_name(cud_entry.name);
$ifnone BEFORE_SUP_V43   get_name(mud_entry.name);
  input_password_cipher(password_cipher);
  input_sync;
  if return_code = ENTRY_COMPLETE
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if BEFORE_SUP_V43   then modify_name(cud_entry);
$ifnone BEFORE_SUP_V43   then modify_name(mud_entry, nud_entry);
$ifnone name_legal_password
$if BEFORE_SUP_V43   if cipher_password.ciphered_name(cud_entry.name) =
$ifnone BEFORE_SUP_V43   if cipher_password.ciphered_name(mud_entry.name) =
    password_cipher
  then
    begin
      return_code := ILLEGAL_PASSWORD;
      cud_updater.abort_cud_change
    end (* password = name *);
$endif name_legal_password
  if return_code = ENTRY_COMPLETE
  then
    begin
      cud_updater.update_cud_password(password_cipher
$if force_password_change          , TRUE
      );
      output_cud_entry_result
    end
  else output_return_and_sync(return_code)
end (* change_password_command *);



(***********************  master_command_level  *************************)
(*									*)
(*			check_old_password_command			*)
(*									*)
(************************************************************************)

procedure check_old_password_command;

var
$if BEFORE_SUP_V43   cud_entry : cud_user_entry;
$ifnone BEFORE_SUP_V43
  mud_entry : mud_user_entry;
  nud_entry : nud_user_entry;
$endif BEFORE_SUP_V43
  old_cipher : integer;

begin
$if BEFORE_SUP_V43   get_name(cud_entry.name);
$ifnone BEFORE_SUP_V43   get_name(mud_entry.name);
  input_password_cipher(old_cipher);
  input_sync;
  if return_code = ENTRY_COMPLETE
  then
    begin
      cud_updater.read_cud_entry(
$if BEFORE_SUP_V43   cud_entry);
$ifnone BEFORE_SUP_V43   mud_entry, nud_entry);
      set_cud_error;
      if return_code = ENTRY_COMPLETE
      then
$if BEFORE_SUP_V43   if cud_entry.password <> old_cipher
$ifnone BEFORE_SUP_V43   if mud_entry.password.cipher <> old_cipher
	then return_code := PASSWORD_MISMATCH
      end;
  output_return_and_sync(return_code)
end (* check_old_password_command *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if changes_to_oper_log



(***********************  master_command_level  *************************)
(*									*)
(*			set_oplog_remark_command			*)
(*									*)
(************************************************************************)

procedure set_oplog_remark_command;

var
  byte : char;
  remark_ptr : oplog_remark_index;
  oplog_remark : oplog_remark_message;

begin
  input_byte(byte);
  oplog_remark.size := ord(byte);
  check_input_value(0, OPLOG_REMARK_LENGTH, oplog_remark.size);
  if oplog_remark.size > OPLOG_REMARK_LENGTH
  then oplog_remark.size := OPLOG_REMARK_LENGTH;
  for remark_ptr := 0 to oplog_remark.size - 1 do
    input_byte(oplog_remark.chars[remark_ptr]);
  input_sync;
  if return_code = ENTRY_COMPLETE
  then cud_updater.set_remark(oplog_remark);
  output_return_and_sync(return_code)
end (* set_oplog_remark_command *);
$endif changes_to_oper_log
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)


(***********************  master_command_level  *************************)
(*									*)
(*				process_master				*)
(*									*)
(*   Process master commands.					        *)
(*									*)
(************************************************************************)

procedure process_master;

var
  command_code : char;
  value : integer;

begin
  repeat
    return_code := ENTRY_COMPLETE;
    input_state := INPUT_OK;
    user_circuit.set_timeout(MASTER_COMMAND_TIMEOUT);
    input_byte(command_code);
    format.start;
    format.validator_type_name(MASTER_VALIDATOR);
    format.character(ASCII_SPACE);
    format.string('command \ ');
    format.number(ord(command_code), 10);
    oper_messages.report_master_message(profile);
    if user_circuit.available
    then
      begin
        user_circuit.set_timeout(MASTER_TIMEOUT);
	if (return_code = ENTRY_COMPLETE) and
	  ((command_code < MINIMUM_COMMAND) or
	   (command_code > MAXIMUM_COMMAND))
	then output_return_and_sync(ILLEGAL_COMMAND)
	else
	  case command_code of
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone changes_to_oper_log 	    ILLEGAL_CODE_13,
$if before_sup_v43 	    ILLEGAL_CODE_14, ILLEGAL_CODE_15, ILLEGAL_CODE_16,
$ifnone before_sup_v43
$ifnone allow_logon_inhibit	    ILLEGAL_CODE_14,
$ifnone restrict_users_by_time 	    ILLEGAL_CODE_15,
$ifnone password_expiration_by_user 	    ILLEGAL_CODE_16,
$endif before_sup_v43
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
	    ILLEGAL_CODE_17,
	    ILLEGAL_CODE_18: output_return_and_sync(ILLEGAL_COMMAND);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if allow_logon_inhibit
	    CHANGE_LOGON_INHIBIT: change_inhibit_command;
$endif allow_logon_inhibit
$if restrict_users_by_time
	    CHANGE_ALLOWABLE_TIMES: change_allowable_times_command;
$endif restrict_users_by_time
$if password_expiration_by_user
	    CHANGE_VALIDITY: change_validity_command;
$endif password_expiration_by_user
$if changes_to_oper_log 	    SET_OPLOG_REMARK: set_oplog_remark_command;
$ifall (BEFORE_SUP_V43, CHECK_TIME_STATUS)
	    SET_GFD_ONLY: set_gfd_only_command;
	    CHANGE_BILLABLE: change_billable_command;
$endif (BEFORE_SUP_V43, CHECK_TIME_STATUS)
$ifnone (BEFORE_SUP_V43, CHECK_TIME_STATUS)
	    SET_GFD_ONLY,
	    CHANGE_BILLABLE,
$endif (BEFORE_SUP_V43, CHECK_TIME_STATUS)
	    ILLEGAL_CODE_19: output_return_and_sync(ILLEGAL_COMMAND);
$ifnone INCLUDE_IRC
	    CHANGE_IRC: output_return_and_sync(ILLEGAL_COMMAND);
$endif INCLUDE_IRC
$if INCLUDE_IRC 	    CHANGE_IRC: change_irc_command;
$ifnone UUNSassignable
    	    CHANGE_UUN,
 	    CHANGE_UUN_AND_GAN: return_code := OPERATION_ERROR;
$endif UUNSassignable
$if UUNSassignable
            CHANGE_UUN: change_uun_command;
 	    CHANGE_UUN_AND_GAN: change_uun_and_gan_command;
$endif UUNSassignable
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
 	    NEW_USER_18_BIT,
	    NEW_USER: new_user_command(command_code);
	    DELETE_USER: delete_user_command;
	    CHANGE_CPARW: change_cparw_command;
	    CHANGE_GAN: change_gan_command;
	    CHANGE_NAME: change_name_command;
	    CHECK_NAME: check_name_command;
	    ALL_CUD_DATA: all_cud_data_command;
	    NETVAL_INFO: netval_info_command;
	    GET_MUD_DATA: get_mud_data_command;
	    CHANGE_IGNORE_DESTINATION: change_ignore_host_command;
	    GET_CHANGE_DATE: get_date_command;
	    CHANGE_NO_PASSWORD_REQUIRED: change_no_password_command;
	    CHANGE_ACCESS_ENTRY: change_access_entry_command;
	    ADD_ACCESS_ENTRY: add_access_entry_command;
	    DELETE_ACCESS_ENTRY: delete_access_entry_command;
	    CHANGE_DISTRICT: change_district_command;
	    GET_PASSWORD_CIPHER: get_password_cipher_command;
	    CHANGE_PASSWORD: change_password_command;
	    CHECK_OLD_PASSWORD: check_old_password_command
        end (* case *)
      end (* user_circuit.available *)
  until not user_circuit.available
end (* process_master *);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if DISK_LOAD_TEST



(***********************  master_command_level  *************************)
(*									*)
(*			     dummy_update				*)
(*									*)
(************************************************************************)

procedure dummy_update(
      block_to_update	: cud_block_index);

var
  end_delay_period : integer;

begin
  cud_updater.dummy_update(block_to_update);
  end_delay_period := REALTIME + DISK_LOAD_CHANGE_DELAY;
  repeat
    wait; wait; wait; wait
  until REALTIME > end_delay_period
end (* dummy_update *);
$endif DISK_LOAD_TEST
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(************************  master_command_level  ************************)
(************************************************************************)

begin (* initial statement *)
  init mutil, calendar, format, profile(validator),
    oper_messages(oplog, format), dsksys(statistics),
    block_utility(mutil, oper_messages, format, dsksys),
    block_updater(mutil, statistics, dsksys, cud_access, block_utility,
      format),
    cud_utility(mutil, format, oper_messages),
$ifnot BEFORE_SUP_V43
    list_io(statistics, file_system, oper_messages, format, list_access),
    list_utility(validator, statistics, file_system,
      format, list_io, list_allocater, list_access),
$endif BEFORE_SUP_V43
    cud_updater(
      validator, mutil, format, login_pool, mud_change, oper_messages,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifall (overflow_cud_entries, BEFORE_SUP_V43)     overflow_controller,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      cud_utility, cud_access, block_updater,
$ifnot BEFORE_SUP_V43      list_utility,
      param_manager, name_access),

    user_circuit(mutil),
    circuit_util(user_circuit),
    cipher_password(mutil);


(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone DISK_LOAD_TEST
  cycle
    login;
    process_master;
    login_pool.release_unit(user_circuit.unit);
    oper_messages.report_logout(MASTER_OPLOG_MSG, profile,
      user_circuit.logout_reason)
  end (* cycle *)
$endif DISK_LOAD_TEST
$if DISK_LOAD_TEST
  cycle
    dummy_update(validator -  FIRST_MASTER_VALIDATOR)
  end (* cycle *)
$endif DISK_LOAD_TEST
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
end (* master_command_level *);
$endif NETVAL_IS_A_SLAVE
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
!
(************************************************************************)
(*									*)
(*	INIT.NTV							*)
(*									*)
(*			    initial process				*)
(*									*)
(************************************************************************)
(*									*)
(*                           Revision Record                            *)
(*									*)
(*	24Nov87 - neh							*)
(*	      - add DNIC_FILE_HANDLER					*)
(*	10Nov87 - neh							*)
(*	      - change class_group_updater to sysmsg1_updater to update	*)
(*		DNIC tables						*)
(*			merge 4.00 and 5.00 neh				*)
(*	19Jun86 - neh							*)
(*	      - add parameters to initialize OPLOG_REPORTER		*)
(*	16Mar87 - rsb							*)
(*		- add pasmon if either global_password_only_login or	*)
(*		  force_password_change is enabled			*)
(*		- add init of file system if global_password_only_login *)
(*		  and init of pasmon if force_password_change to	*)
(*		  INITIALIZE_VALIDATORS init of PASSWORD_ONLY_VALIDATORS*)
(*	12Feb86 - jrn							*)
(*	      - add lvol_time_stamp process				*)
(*	08Jan86 - jrn							*)
(*	      - remove UPDATE_TYMCOM_LUDS				*)
(*	06Jan86 - rsb							*)
(*		- Change declaration of "var Mud_Updaters" from		*)
(*		  "array[supervisor_index]" to				*)
(*		  "array[pseudo_sup_index]"				*)
(*		- every "sup" changed into "pseudo_sup"			*)
(*		- every "sup: supervisor_index" changed into		*)
(*		        "pseudo_sup ; pseudo_sup_index"			*)
(*	09Dec85 - jrn							*)
(*	      - remove ASSIGN_CUSTOMER_NUMBERS_FROM_TYMCOM_IX		*)
(*	16Jan85 - jrn							*)
(*	      - add all reuse_uun processes and monitors		*)
(*	12Dec84 - pgl/jrn						*)
(*	      - add logical volumes					*)
(*	20Jul84	- jrn							*)
(*	      - change call to disk_system				*)
(*	29SEP83	Original from (patrol)init.bas -- jrn			*)
(*									*)
(************************************************************************)


var
  sys_io		: system_handler;
  statistics		: statistics_gatherer;
  crash_util		: crash_utility;
  dsksys		: disk_system;
  config_utility	: configuration_utility;
  file_system		: file_system_manager;
  oplog			: operator_log;
  commands		: command_table;

  tape_pool		: tape_allocater;

  mud_change		: mud_change_handler;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifany (force_password_change, global_password_only_login)
  pasmon		: passtable_handler;
$endif any(force_password_change, global_password_only_login)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  tick			: mud_change_tick;

  cud_access		: cud_access_controller;
  param_manager		: cud_parameter_controller;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if reuse_uuns
  supply_17_bit_uuns	: bit17_supplier;
  supply_18_bit_uuns	: bit18_supplier;
  add_back		: return_uun;
  merge_uuns		: merge_uunfile;
$endif reuse_uuns

$if force_password_change    passchg		: passchanger;
$ifall (overflow_cud_entries, BEFORE_SUP_V43)   overflow_controller	: cud_overflow_controller;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  name_access		: cud_name_controller;

  table_access		: class_group_handler;
$if INCLUDE_DNIC  dnic_access		: dnic_file_handler;
  list_access		: node_host_list_access;
  list_allocater	: node_host_list_allocater;
  sysmsg1_access	: sysmsg1_access_manager;
  table_updater		: sysmsg1_updater;

  un2_access		: un2_access_manager;
  mud_updaters		: array [pseudo_supervisor_index] of mud_updater;

  login			: accept_login;
  login_pool		: login_distributer;


  (* Command level processes *)
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if allow_password_only
  password_only_validators : array [password_only_validator_index] of
    password_command_level;
$endif allow_password_only
$if netval_is_a_slave

  master_validators : array [master_validator_index] of master_command_level;
$endif netval_is_a_slave
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

  validators : array [licensed_validator_index] of command_level;

(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if logical_volumes
  mutil			: misc_utility;
  user_terminal		: circuit_handler;
  format		: internal_to_string;
  profile		: validator_profile;
  log_util		: login_utility;
  argument_scan		: argument_scanner;
  keyword_util		: keyword_utility;
  input_scanner		: terminal_input_scanner;
  keyword_scan		: keyword_scanner;
  
  lv_status_manager	: lvol_status_manager;
  lv_utility		: lvol_utility;
  lv_dialogue		: lvol_dialogue;
  lv_copy		: logical_volume_copy;
  lv_reporter		: lvol_state_reporter;
  lv_time_stamp		: lvol_time_stamp;
  lv_status_updater	: lvol_disk_maintenance;
  
  lv_username		: username_string;
  perform_auto_copy	: boolean;
  proceed_with_copy	: boolean;
  to_disk		: incarnation_index;
  from_disk		: incarnation_index;
  lvol_age		: logical_volume_age;
$endif logical_volumes
$if check_time_status   operlog_reporter	: oplog_reporter;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)



(******************************  initial  *******************************)
(*									*)
(*		initialize_disk_and_check_configuration			*)
(*									*)
(*	Initialize the monitors to access disk files and check		*)
(*	configuration parameters.			 		*)
(*									*)
(************************************************************************)

procedure initialize_disk_and_check_configuration;

var
  configuration : configuration_information;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if logical_volumes
(* current legal_disk flag and time_stamp for each unit *)
  lvol_state : lvol_disk_state;
  needle : needle_record;
  got_login : boolean;
  status : file_utility_status;
$endif logical_volumes
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

begin
  init statistics, dsksys(statistics), config_utility(dsksys, sys_io),
    file_system;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$ifnone logical_volumes
  config_utility.check_drive_configuration(FILE_SYSTEM_DISK, configuration);
  file_system.reset(configuration.files);
  init oplog(statistics, file_system)
$endif logical_volumes
$if logical_volumes
(* - initialize system types that do not require reding the disk	*)
(* - read the configuration file on each drive to determine their	*)
(*   current state							*)
(* - if an automatic copy can be performed, initialize the logical	*)
(*   volume system (set FROM disk to READ/WRITE, TO disk to WRITE ONLY)	*)
(* - if an automatic copy cannot be done, wait for the OPERATOR		*)
(*   or PROGRAMMER to login, have them confirm the direction of the	*)
(*   copy and initialize the logical volume system:			*)
(*	- if coming up with BOTH disks, set FROM disk to READ/WRITE,	*)
(*	  TO disk to WRITE ONLY						*)
(*	- if coming up with only one disk, set FROM disk to READ/WRITE,	*)
(*	  TO disk to UNAVAILABLE					*)
  init mutil, user_terminal(mutil), format, profile(VALIDATOR_LIMIT),
    log_util(mutil, user_terminal, format, login_pool),
    argument_scan(mutil),
    keyword_util(profile, format, user_terminal, commands, argument_scan),
    input_scanner(profile, mutil, format, user_terminal, commands,
      argument_scan, keyword_util),
    keyword_scan(user_terminal, input_scanner),
    lv_utility,
    lv_status_manager(statistics), (* sets COPY IN PROGRESS *)
    lv_dialogue(user_terminal, keyword_scan, format, dsksys,
      sys_io, lv_status_manager, lv_utility, config_utility);

  config_utility.check_lvol_configuration(configuration, lvol_state);
  perform_auto_copy := TRUE;
  if lvol_state[0].legal_disk and lvol_state[1].legal_disk and
    (lvol_state[0].time_stamp = lvol_state[1].time_stamp)
  then (* both disks in tact, same time stamp...perform automatic copy *)
	(* initialize incarnation 0 to READ/WRITE, 1 to WRITE ONLY *)
    lv_utility.initialize(1, SET_LVOL_WRITE_ONLY)
  else
    begin (* cannot do auto copy - wait for OPER/PROGRAMMER to login *)
      perform_auto_copy := FALSE; got_login := FALSE;
      repeat
        log_util.get_login(lv_username, needle);
	if not mutil.same_name(NVDM_OPERATOR_NAME, NVDM_OPERATOR_NAME_SIZE,
	  lv_username) and
	  not mutil.same_name(PROGRAMMER_NAME, PROGRAMMER_NAME_SIZE,
	    lv_username)
	then log_util.access_denied(
'NETVAL has not been initialized, no unprivileged logins allowed\')
        else
	  begin
	    got_login := TRUE;
	    user_terminal.use_circuit(log_util.unit, TERMINAL,
	      [COMPLETE, BREAK_KEY, ORANGE_BALL]);
	    user_terminal.set_alternate_break(ESCAPE);
	    user_terminal.write_newline;
	    user_terminal.write_line_and_quoted_text_line(
'logical volumes have not been initialized, current status is:\');
	    user_terminal.write_newline;
(* get_confirmation leaves logical volume system initialized *)
	    lv_dialogue.get_confirmation(FALSE, to_disk, from_disk, lvol_age,
	      proceed_with_copy)
	    end (* OPERATOR/PROGRAMMER logging in *);
        until got_login and user_terminal.available;
	config_utility.read_file(configuration, status);
	if status = FU_SUCCESS
	then user_terminal.write_quoted_text_line('NETVAL initializing\')
	else crash_util.halt_slot (* cannot read configuration now *)
    end (* cannot do auto copy - wait for OPER/PROGRAMMER to login *);
(* tell file system where files are *)
  file_system.reset(configuration.files);
  init oplog(statistics, file_system),
    lv_copy(user_terminal, format, lv_status_manager, lv_utility, oplog,
      statistics),
    lv_time_stamp(lv_status_manager),
    lv_status_updater(lv_status_manager),
    lv_reporter(lv_status_manager, oplog)
$endif logical_volumes
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
end (* initialize_disk_and_check_configuration *);



(*******************************  initial  ******************************)
(*									*)
(*			  initialize_mud_updates			*)
(*									*)
(************************************************************************)

procedure initialize_mud_updates;

var
  pseudo_sup : pseudo_supervisor_index;

begin
  init mud_change(statistics, file_system, oplog), tick(mud_change);

  for pseudo_sup := FIRST_SUPERVISOR to MAXIMUM_EXPECTED_SUPERVISORS do
    init un2_access[pseudo_sup];

  for pseudo_sup := FIRST_SUPERVISOR to MAXIMUM_EXPECTED_SUPERVISORS do
    init mud_updaters[pseudo_sup](pseudo_sup, statistics, file_system, oplog,
      cud_access, mud_change, un2_access)
end (* initialize_mud_updates *);



(*******************************  initial  ******************************)
(*									*)
(*			    initialize_validators			*)
(*									*)
(************************************************************************)

procedure initialize_validators;

var
  vi : validator_index;

begin
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if allow_password_only
(* initialize PASSWORD_ONLY validators *)
  for vi := FIRST_PASSWORD_ONLY_VALIDATOR to PASSWORD_ONLY_VALIDATOR_LIMIT do
    init password_only_validators[vi](vi, login_pool, commands, statistics,
$if global_password_only_login       file_system,
      oplog, mud_change, cud_access, param_manager,
$ifall (overflow_cud_entries, BEFORE_SUP_V43)       overflow_controller,
$ifany (force_password_change, global_password_only_login)       pasmon,
      name_access);
$endif allow_password_only
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if netval_is_a_slave

(* initialize master validators *)
  for vi := FIRST_MASTER_VALIDATOR to MASTER_VALIDATOR_LIMIT do
    init master_validators[vi](vi, login_pool, statistics,
      oplog, mud_change, 
$ifany (global_password_only_login, force_password_change)       pasmon,
      cud_access, param_manager,
$ifall (overflow_cud_entries, BEFORE_SUP_V43)       overflow_controller,
$ifnot BEFORE_SUP_V43     file_system, list_access, list_allocater,
      name_access);
$endif netval_is_a_slave
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

(* initialize licensed validators *)
  for vi := FIRST_LICENSED_VALIDATOR to VALIDATOR_LIMIT do
    init validators[vi](vi, login_pool, tape_pool, commands, statistics,
      file_system, oplog, mud_change,
$ifany (global_password_only_login, force_password_change)	pasmon,
      cud_access, param_manager,
$ifall (overflow_cud_entries, BEFORE_SUP_V43)       overflow_controller,
$if INCLUDE_DNIC      dnic_access,
      name_access, list_access, list_allocater,
      table_access, un2_access,
(*	+-+-+-+-+--+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if logical_volumes	lv_status_manager,
(*	+-+-+-+-+--+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
      sysmsg1_access);

(* Initialize login process *)

  init login(statistics, oplog, mud_change, cud_access, param_manager,
$ifall (overflow_cud_entries, BEFORE_SUP_V43)       overflow_controller,
    name_access, login_pool)
end (* initialize_validators *);
!
(************************************************************************)
(************************************************************************)

begin
  init sys_io, crash_util, login_pool, commands, tape_pool;

  initialize_disk_and_check_configuration;

  init cud_access, name_access,
    param_manager(statistics, file_system, oplog, cud_access);

  initialize_mud_updates;

(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if change_by_whom
"added init pasmon by SHSUE at 27-Aug-87 "
$endif
$ifany (force_password_change, global_password_only_login)
  init pasmon(statistics, file_system, oplog);
$endif any force_password_change or global_password_only_login
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

$if reuse_uuns
  init supply_17_bit_uuns(oplog, statistics, file_system, param_manager),

    supply_18_bit_uuns(oplog, statistics, file_system, param_manager),

    add_back(oplog, statistics, file_system, param_manager),

    merge_uuns(oplog, statistics, file_system, mud_change, param_manager);

$endif reuse_uuns
$ifall (overflow_cud_entries, BEFORE_SUP_V43)
   init overflow_controller(oplog, statistics);

$endif (overflow_cud_entries, BEFORE_SUP_V43)
$if force_password_change
  init passchg(login_pool, statistics, oplog, mud_change,
    cud_access, param_manager,
$ifall (overflow_cud_entries, BEFORE_SUP_V43)       overflow_controller,
    pasmon, name_access);

$endif force_password_change
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
  init sysmsg1_access, list_access,
    table_access(statistics, file_system, oplog, mud_change),
$if INCLUDE_DNIC    dnic_access(statistics, file_system, oplog),
    list_allocater(statistics, file_system, oplog, list_access),
    table_updater(oplog, mud_change, sysmsg1_access,
$if INCLUDE_DNIC    dnic_access,
    table_access);
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if check_time_status

  init operlog_reporter(
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if logical_volumes     lv_status_manager,
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
    login_pool, commands, statistics, oplog, mud_change,
$ifnot BEFORE_SUP_V43    file_system, list_access, list_allocater,
    cud_access, name_access, param_manager, un2_access);
$endif check_time_status
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)

  initialize_validators;
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
$if logical_volumes

  lv_status_manager.set_initial_status;
  if perform_auto_copy
  then lv_copy.auto_copy (* can perform auto copy - go do it *)
  else
    begin
      if not proceed_with_copy
      then lv_status_manager.copy_ended (* coming up w/one disk *)
      else
        begin
	  user_terminal.write_quoted_text_line('copy starting\');
	  lv_copy.copy(lv_username, lvol_age, to_disk, from_disk)
	end (* proceed_with_copy *);
      user_terminal.write_quoted_text_line('NETVAL initialized\ ');
      user_terminal.wait_for_output;
      user_terminal.clear_circuit;
      login_pool.release_unit(log_util.unit)
    end
$endif logical_volumes
(*	+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-	*)
end (* NETVAL *).
  R@o