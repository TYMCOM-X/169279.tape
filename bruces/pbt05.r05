: ******************************************************************
: **                  PROPRIETARY INFORMATION                     **
: **                                                              **
: **  This  source code listing constitutes the proprietary pro-  **
: **  perty of TYMNET, Incorporated. The recipient, by receiving  **
: **  this program listing, agrees that neither this listing nor  **
: **  the   information  disclosed herein nor any  part  thereof  **
: **  shall be  reproduced or transferred to other documents  or  **
: **  used  or  disclosed to others for manufacturing or for any  **
: **  other   purpose except as specifically authorized in  wri-  **
: **  ting by  TYMNET, Incorporated.                              **
: ******************************************************************
: **                   PROGRAM IDENTIFICATION                     **
: **                                                              **
: **  Version Number     : 5.05         Release Date : 10-23-85   **
: **                                                              **
: **  File Name          : PBT05.R05                              **
: **                                                              **
: **  File Description   : 3270 TERMINAL INTERFACE SOURCE FILE    **
: **                                                              **
: **  File Abstract      :                                        **
: **                                                              **
: ******************************************************************
: **                CONFIGURATION SPECIFICATION                   **
: **                                                              **
: **  Core Memory Requirement:                                    **
: **                                                              **
: **  Basic Code Size:                                            **
: **                                                              **
: **  Additional Code Size per Tymfile Parameter Unit:            **
: **                                                              **
: **  Estimated Code Growth for Next 12 Months:                   **
: **                                                              **
: **  Sample Configurations:                                      **
: **                                                              **
: **  Hardware/Firmware Requirements:                             **
: **                                                              **
: **  Other Software Requirements:                                **
: **                                                              **
: **  Slot Limitations:                                           **
: **                                                              **
: ******************************************************************
: **                   DOCUMENT SPECIFICATION                     **
: **                                                              **
: **  Software Requirements Specification       :                 **
: **                                                              **
: **  Functional Specification (GED)            :                 **
: **                                                              **
: ******************************************************************
: **                      MAINTENANCE HISTORY                     **
: **                                                              **
: **  Ver   Date    By   PIR/NSR         Reason for Change        **
: ** ----- -------- ---  -------- ------------------------------  **
: **                                                              **
: ******************************************************************
: **                 SUBROUTINE IDENTIFICATION                    **
: **                                                              **
: **  Routine Abstract   :                                        **
: **                                                              **
: **  Calling Sequence   :                                        **
: **                                                              **
: **  Parameters         :                                        **
: **                                                              **
: **  Returned Values    :                                        **
: **                                                              **
: **  Side Effects       :                                        **
: **                                                              **
: **  Optional Comments  :                                        **
: **                                                              **
: ******************************************************************
	SUBTTL	ISIS Assembly Switch Definitions	- START.LIB
:******************************************************************
:
:	This program is the sole property and confidential
:	information of Tymshare, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.
:
:*******************************************************************

	REMARK %Start.Lib Version 
SREV	EQ	0;	NUMBER SREV; REMARK .0
SLEV	EQ	05;	NUMBER SLEV

: Version 0.05 01/19/83 MDS
:	Delete Remark regarding incompatibility with ISIS 5.00
: Version 0.04 03/12/82  MDS
:	Add new fields to SYS SVC Sub-operand definitions,
:	per ISIS2 v.5.01
: Version 0.03 03/08/82  MDS
:	Add new fields to Seg F table per ISIS 5.01
:	(note - Start.lib ** NOT ** compatible with ISIS 5.00
:	because SLCNT and LCX were reversed in 5.00 )
: Version 0.02  12/08/81  MDS
:	Add QSTART remark, add I/O sub-ops for mother board.
:	Delete ISIS (one) code - force ISIS2
: Version 0.01  01/08/81  MDS
:	Correct relative addresses of local clock index and values.

	RA	0		:	START.LIB

:	this file should always be assembled IMMEDIATELY AFTER the *.TYM file


ISIS2	EQ	1	:Force ISIS2 for other library routines
			:Note - ISIS 1 is no longer supported

:			ISIS - II Version
:
:	The following parameters should be defined in the *.TYM file:
:	MAXHST	maximum number of hosts associated with this interface slot
:	MAXPRT	number of highest port associated with this interface slot
:			(number of ports - 1)
:	IRSIZE	 number of bytes to provide for input ring, from dispatcher
:	ORSIZE	 number of bytes to provide for output ring, to dispatcher
:	CNTRL	dispatcher control bits
:	ENGINE	set to 1 if executing on a Tymnet Engine

:	the following symbols MUST be defined SOMEWHERE in the assembly:
:	IRING	the start of the input ring, from dispatcher
:	ORING	the start of the output ring, to dispatcher
:	ENTRY	the location of the first instruction to be executed

:	the following symbols are defined for convenience:
:	RATE	the rate of the fast clock (ticks/second)
:	NRATE	word containing the value of RATE
:	FASTC	word containing  realtime fast clock
:	SLOWC	word containing  realtime slow clock (1-second)
:	GMT	word containing GMT clock
:	TEMPER	byte containing machine temperature
:	VOLTS	byte containing machine voltage
:	VERNO	halfword containing ISIS version number
:	WWVBT	word containing WWVB time
:	HOSTX	halfword containing kernel host number
:	NODEX	halfword containing kernel node number
:	LCX	halfword, offset of local clocks within seg F
:	SLCNT	halfword, number of slots known to ISIS dispatcher
:	LCT	halfword, pointer to crash table
:	MAXP0	halfword, highest port 0 msg. #
:	MAXMSG	halfword, highest msg # for all other ports
:	LP0LST	halfword, length table for port 0 msgs.
:	LENGTH	length table for msgs. all other ports
:	R0-R15	symbolic names for the registers
:	SEGn	the start address of segment n (0-0E)
:	HOSTS	halfword array of host numbers as known by the dispatcher (R/O)
:	PORTS	halfword array of ports/host as known by dispatcher (R/O)
:
:	the following symbols MAY be defined. defaults used otherwise
:	APROTn	protection byte for area n. default area 1 write protected,
:		other areas execution protected.
:	HOSTn	host number for host position n. default none.
:	HPRTn	number of ports for host position n. default none.
:	DSTART	user DDT execution start address. default none.
:	QSTART  user DDT query handler start address, default none.
:	FPANEL	halfword cell for front panel display. default cell allocated
:	FRISIS	bit array for input backpressure (1=no backpressure) default
:			array allocated.
:	TOISIS	bit array for output backpressure (1=no backpressure) default
:			array allocated.
:	VERSION	version number for slot code (default zero)
:	PCTTBL	bit array for indicating terminating character for project
:			code. (default none)
:	REVLEV	revision level for slot code (default zero)
:	A.DATA	segment number for data area. Default 0
:	A.CODE	segment number for code area. Default 1
:	A.BDAT	segment number for based data. Default 2.
:	A.RING	segment number for rings. Default 2.
:	A.BUFF	segment numberfor buffer(let)s. Default 2.
:
:	in addition most SVC calls have been assigned symbolic names.

	GL	FASTC,SLOWC,RATE,NRATE,GMT,TEMPER,VOLTS,VERNO,HOSTX,NODEX,SLOTNO
	GL	R0,R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11,R12,R13,R14,R15
	GL	IRSIZE,ORSIZE,CNTRL
	GL	ENTRY,IRING,ORING,ENGINE,LCX
	GL	VERREV,COREST,FPANEL,HOSTS,PORTS,FRISIS,TOISIS

:	DEFINE SEG 15d LOCATIONS
RATE	EQ	$A 600		:clock rate, ticks per second
NRATE	EQ	0F0000		:word, contains RATE
FASTC	EQ	0F0004		:word, contains fast clock (ticks)
SLOWC	EQ	0F0008		:word, contains slow clock (seconds)
GMT	EQ	0F000C		:word, contains GMT (seconds since 1/1/72)
TEMPER	EQ	0F0010		:byte, contains machine temperature
VOLTS	EQ	0F0011		:byte, contains machine voltage
VERNO	EQ	0F0012		:halfword, ISIS version number
WWVBT	EQ	0F0014		:word, WWVB time (format ??)
HOSTX	EQ	0F0018		:halfword, kernel host number
NODEX	EQ	0F001A		:halfword, kernel node number

: Local clocks displacements

LCX	EQ	0F001C	:1/2 word, contains offset of LOCLKS within seg F
: LOCLKX and LOCLKS must be referenced by the pointer in LCX
:LOCLKX	EQ	LOCLKS-2 :1/2 word, index to current clock from LOCLKX
:LOCLKS	EQ	Seg F + contents of LCX
			:clocks for slots, array of word entries per slot
			:1st halfword is user ticks, 2nd is sys ticks for slot

SLCNT	EQ	0F001E		:halfword, number of dispatcher slots
LCT	EQ	0F0020		:halfword, pointer to crash table
MAXP0	EQ	0F0022		:halfword, max. msg. # for port 0
MAXMSG	EQ	0F0024		:halfword, max. msg #, all non-0 ports
LP0LST	EQ	0F0026		:halfword, offset to port 0 msg length table
LENGTH	EQ	0F0028		:byte table, lengths of non-0 port msgs

:	Define Registers
R0	EQ	0
R1	EQ	1
R2	EQ	2
R3	EQ	3
R4	EQ	4
R5	EQ	5
R6	EQ	6
R7	EQ	7
R8	EQ	8
R9	EQ	9
R10	EQ	$A 10
R11	EQ	$A 11
R12	EQ	$A 12
R13	EQ	$A 13
R14	EQ	$A 14
R15	EQ	$A 15

:	AREA DEFINITIONS
	GL	A.DATA,A.CODE,A.BDAT,A.RING,A.BUFF
:
  IF	\A.DATA
  ELSE
A.DATA	EQ	0	:DEFAULT DATA AREA
  EI

  IF	\A.CODE
  ELSE
A.CODE	EQ	1	:DEFAULT CODE AREA
  EI

  IF	\A.BDAT
  ELSE
A.BDAT	EQ	2	:DEFAULT BASED DATA AREA
  EI

  IF	\A.RING
  ELSE
A.RING	EQ	2	:DEFAULT RING AREA
  EI

  IF	\A.BUFF
  ELSE
A.BUFF	EQ	2	:DEFAULT BUFFER AREA
  EI

:	SVC DEFINITIONS
:
	GL	DISMIS,FASTD,SYS,RSTRT.,CFGND.,DBGON.,DBGOF.,TSTDB.
	GL	FREEZ.,THAW.,TFREZ.,RDDTR.,RDDTP.,RBREG.,RBPSD.
	GL	RFREG.,RFPSD.,RDMAC.,RBMAC.,RFMAC.,SET1P.,SETP.,SETBE.
	GL	SETFE.,IO,IOQRY.,CSYNI.,CSYNO.,FSYNO.,TIISC.
	GL	CSUPF.,CSUPR.,FREZS.,THAWS.,ALARM.,RSCLK.,SSCLK.,SUDIA.
	GL	SFREZ.,HALT.,SHALT.
	GL	TIISI.,CASYN.,CPRT.,FPRT.,CSIO.,CMBRD.,FMBIN.,FMBOT.
	GL	SHARE,K.IN,K.OUT,KIO,BDISC,SDISC
:
DISMIS	EQ	0	:DISMISS SVC
FASTD	EQ	1	:FAST DISMISS SVC
:
SYS	EQ	2	:SYS SVC

:	SYS SVC SUBOPERANDS
RSTRT.	EQ	0	:Restart syscall
CFGND.	EQ	1	:Connect foreground syscall
DBGON.	EQ	2	:Debug mode ON syscall
DBGOF.	EQ	3	:Debug mode OFF syscall
TSTDB.	EQ	4	:Test debug mode syscall
FREEZ.	EQ	5	:Freeze slot syscall
THAW.	EQ	6	:Thaw slot syscall
TFREZ.	EQ	7	:Test freeze syscall
RDDTR.	EQ	8	:Read DDT register syscall
RDDTP.	EQ	9	:Read DDT PSD syscall
RBREG.	EQ	0A	:Read background register syscall
RBPSD.	EQ	0B	:Read background PSD syscall
RFREG.	EQ	0C	:Read foreground register syscall
RFPSD.	EQ	0D	:Read foreground PSD syscall
RDMAC.	EQ	0E	:Read DDT MAC register syscall
RBMAC.	EQ	0F	:Read background MAC register syscall
RFMAC.	EQ	10	:Read foreground MAC register syscall
SET1P.	EQ	11	:Set 1 protect syscall
SETP.	EQ	12	:Set protection syscall
SETBE.	EQ	13	:Set background execution addr syscall
SETFE.	EQ	14	:Set foreground execution addr syscall
LMAC.	EQ	15	:Set up MAC from CTA (DDT only)
CSUPF.	EQ	16	:Check SUP freeze state
CSUPR.	EQ	17	:Check SUP run Q state
FREZS.	EQ	18	:Freeze the SUP
THAWS.	EQ	19	:Thaw the SUP
ALARM.	EQ	1A	:Set/Clear alarm
RSCLK.	EQ	1B	:Read the super-clock
SSCLK.	EQ	1C	:Set the super-clock
SUDIA.	EQ	1D	:Set user diagnostic
UCORE.	EQ	1E	:Get slot physical addr & size (DDT only)
SFREZ.	EQ	1F	:Super-freeze slot
HALT.	EQ	20	:Halt the slot
SHALT.	EQ	21	:Super-halt the slot
SVSPY.	EQ	22	:Start/Stop SPY
DISCO.	EQ	23	:Disconnect Logical Unit

IO	EQ	3	:I/O SVC
:	I/O SUBOPERANDS
IOQRY.	EQ	8000	:Query I/O attributes
CSYNI.	EQ	0	:Connect SYNC input
CSYNO.	EQ	1	:Connect SYNC output
FSYNO.	EQ	2	:Force SYNC output
CASYN.	EQ	3	:Connect ASYNC
CPRT.	EQ	4	:Connect Printer
FPRT.	EQ	5	:Force Printer
TIISC.	EQ	6	:T-II SYNC Connect
TIISI.	EQ	7	:T-II SYNC Idle test
CSIO.	EQ	8	:Connect SIO
CMBRD.	EQ	9	:Connect SIO mother board
FMBIN.	EQ	0A	:Force mother board input
FMBOT.	EQ	0B	:Force mother board output
SHARE	EQ	04	:Shared device SVC
K.IN	EQ	0A	:Kernel Input SVC
K.OUT	EQ	0B	:Kernel Output SVC
KIO	EQ	0D	:Kernel-I/O (general) SVC
BDISC	EQ	0E	:Big disc SVC (obsolete)
SDISC	EQ	0F	:Small disc SVC (obsolete)

	IF	IRSIZE&3;	REMARK	%IRSIZE should be multiple of 4
IRSIZE	EQ	(IRSIZE!3)+1;	EI
	IF	ORSIZE&3;	REMARK	%ORSIZE should be multiple of 4
ORSIZE	EQ	(ORSIZE!3)+1;	EI

  IF	\MAXPRT
  ELSE
	REMARK	%PLEASE DEFINE MAXPRT. NPORTT ASSUMED.
MAXPRT	EQ	NPORTT-1
HPRT0	EQ	MAXPRT
  EI

  IF	\MAXHST
  ELSE
	REMARK	%PLEASE DEFINE MAXHST. 1 ASSUMED.
MAXHST	EQ	1
HOST0	EQ	HOSTNO
  EI


:	DEFINE START OF SEGMENTS
Q	EQ	0
	NOLIST
	RE	0F
  IF	\SEG|Q|
	GL	SEG|Q|
  ELSE
	SEG	Q
	GL	SEG|Q|
SEG|Q|
  EI
Q	EQ	Q+1
	ER
	LIST

:GENERATE DIAGNOSTICS
Q	EQ	0
	NOLIST
QQ	EQ	0;	RE	0F
	IF	((Q*10000)%SEG|Q|)&7FFFFFFF
QQ	EQ	1;	REMARK	%SYMBOL SEG
	NUMBER	Q
	REMARK	 IS NOT DEFINED PROPERLY. VALUE IS 
	NUMBER	SEG|Q|
	EI
Q	EQ	Q+1;	ER
	LIST

	IF	QQ;
	REMARK	%START.LIB **MUST** be assembled FIRST!!%;
	EI
	SUBTTL	Engine hardware trace trapping routine
:******************************************************************
:
:	This program is the sole property and confidential
:	information of Tymshare, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.
:
:*******************************************************************
	RA	0		:	TRACE.LIB

:	This file provides the necessary backbone for using the TYMNET-ENGINE
:	harware-trace feature.  It should be assembled IMMEDIATELY AFTER the
:	START.LIB file.  The file may be assembled directly from the library
:	version, in which case it is necessary to patch the appropriate test
:	into the assembled code, OR it may be copied and the test hard-coded.

	GL	ENTRY,CRASH	:TWO LIKELY CANDIDATES FOR SYMBOLS REQUIRED

	MO	.,TRACE
	SEG	0		:IN SEGMENT 0
	ORG	10		:AT LOCATION 10
TRPSD	WC	1000,ENTRY	:FORCE A TRANSFER TO "ENTRY"
	WC	TRACE		:ON TRAP, GO TO "TRACE"
TRSAVE	HS	22		:USEFUL AREA TO SAVE REGS, ETC
TRINDX  WC      TRING           :INDEX TO TRACE RING
TRING   WS      20              :TRACE RING
TRCHK   WS      1               :TRACE CHECK ON 300D6

	SEG	A.CODE		:IN CODE AREA
TRACE	HS	0		:ENTRY TO TRACE LOGIC
        STM     R10,TRSAVE+4    :SAVE REGISTERS
        L       R10,TRINDX      :GET TRACE RING INDEX
        CLI     R10,TRING+80    :CHECK IF OUTSIDE RING
        JLFS    TRACE2          :IF NOT ,JUMP
        LHI     R10,TRING       :GO TO BEGINNING OF RING
TRACE2  L       R11,TRPSD+4     :GET ADDRESS WE JUST JUMPED TO
        ST      R11,0,R10       :STORE IT IN RING
        AIS     R10,4           :ADVANCE RING INDEX
        ST      R10,TRINDX      :STORE NEW RING INDEX
:
TRACE3  J       TROUT           :EXIT TRACE
        HS      40              :ADDITIONAL AREA TO PATCH REQUIRED TEST
:
TROUT   LM      R10,TRSAVE+4    :RESTORE REGISTERS
	UPSW	TRPSD		:INSTRUCTION TO RE-ENABLE TRACE

:	TRANSFER TO HERE TO TURN ON TRACE INITIALLY
TRBGN	UPSW	IPSD		:THIS WILL TAKE US TO "ENTRY" WITH TRACE ON
IPSD	WC	1000,ENTRY	:TRACE BIT ON, GO TO "ENTRY"
	EM

	SUBTTL	Standard Timeout Routine Library	- TIMOUT.LIB
:******************************************************************
:
:	This program is the sole property and confidential
:	information of Tymshare, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.
:
:*******************************************************************
	RA	0		:	TIMOUT.LIB

:	This package contains the standard timeout routines
:	The following parameters MUST be defined on entry:
:	NTOUT	number of timeout entries which may be active at any one time

:	expects to JAL R10,CRASH if list overflows

:	six symbols are declared:
:	IZT	called at initilization, link on R0
:	TIMOUT	to be called periodicaly, link on on R0
:		will in turn jump to any routines which should be serviced:
:		R0 = routine address
:		R1 = current fast-clock time.
:	TORET	routines called by TIMOUT should exit to here
:	TOPUT	any code may call this to place an entry on timeout list:
:		link on R5...R6--R15 preserved
:		R0 = address to transfer to
:		R1 = next time to call routine
:	TOGET	called to delete an entry already on timout list
:		link on R5...R6--R15 preserved
:		R0 = routine address...entry with this address will be deleted
:	TONOW	called to flush an entry, and execute it NOW!
:		link on R5...NO registers preserved! NOW!
:		routine address in R0
:	NOwhen a routine is called from timeout list, it is removed from list,
:	and must call TOPUT to be called again.
:	ALSO...TOGET and TONOW both do normal returns, even if no entry is found.

	GL	IZT,TIMOUT,TORET,TOPUT,CRASH,TOGET,TONOW,NTOUT
	MO	.,TIMOUT

	SEG	A.DATA		:PLACE IN DATA AREA

  IF	6-.
	BS	6-.		:UNUSED 
  EI
TO9	HS	2		:link for timeout processor
LSIZ	EQ	$A 10		:number of bytes in list entry
TLIST	BS	(NTOUT+1)*LSIZ	:timeout list
:				active list entry = halfword chain pointer
:				word routine address
:				word time of next activiation

:		free list pointer is at TLIST
:		active list chain pointer is at TLIST+2
:	CODE SEGMENT
	SEG	A.CODE

TORET	L	R0,TO9		:TIMEOUT ROUTINES EXIT HERE
:	CALL NEXT TIME OUT ROUTINE (IF ANY) THAT HAS BECOME DUE
TIMOUT	LHL	R2,TLIST+2	:GET ACTIVE LIST POINTER
	JER	R0		:EXIT IF NO ACTIVE ENTRIES
	L	R1,FASTC,,	:GET CURRENT CLOCK TIME
	CL	R1,TLIST+6,R2	:IS 1ST ACTIVE LIST TIMEOUT DUE
	JLR	R0		:NO TIMEOUTS DUE TO PROCESS
	ST	R0,TO9		:ROUTINE MUST TERMINATE BY JUMPING TO TORET
	LHL	R3,TLIST,R2
	STH	R3,TLIST+2	:SHORTEN ACTIVE LIST
	LHL	R4,TLIST
	STH	R4,TLIST,R2	:SPLICE INTO HEAD OF FREE CHAIN
	STH	R2,TLIST
	L	R0,TLIST+2,R2
	JR	R0		:FETCH ADRS AND ENTER TIMED OUT ROUTINE

:	PUT ADRS R0 TO EXECUTE AT TIME R1 ON ACTIVE TIMEOUT LIST. LINK=R5.
TOPUT	LIS	R2,2		:FIND ACTIVE LIST ENTRY BETWEEN EARLIER, LATER TIMEOUT.
TPT1	LR	R3,R2
	LHL	R2,TLIST,R2	:CHECK NEXT TIMEOUT ENTRY
	JEFS	TPT2		:ACTIVE LIST IS EMPTY
	CL	R1,TLIST+6,R2	:IS IT EARLIER THAN ARGUMENT DUE TIME
	JGBS	TPT1		:YES, CONTINUE TIL R3 IS EARLIER AND R2 IS EQUAL OR LATER
TPT2	LHL	R4,TLIST
	JGFS	TPT3
	JAL	R10,CRASH	:FREE LIST EXHAUSTED
	BC	0,0,4*R5,0F	:FLAG--LINK R5, TYPE 15d CRASH
TPT3	STH	R4,TLIST,R3	:MAKE EARLIER ACTIVE LIST ENTRY POINT TO NEW ENTRY
	LHL	R3,TLIST,R4
	STH	R3,TLIST	:SHORTEN FREE LIST
	STH	R2,TLIST,R4	:HAVE NEW ENTRY POINT TO NEXT GREATER TIMEOUT ENTRY
	ST	R0,TLIST+2,R4
	ST	R1,TLIST+6,R4
	JR	R5		:STORE ARGUMENTS AND RETURN

TONOW	LIS	R1,2		:SEARCH ACTIVE LIST
TONOW1	LR	R2,R1		:COPY CURRENT ENTRY POINTER
	LHL	R1,TLIST,R2	:GET NEXT ENTRY
	JER	R5		:LIST EXHAUSTED...EXIT
	CL	R0,TLIST+2,R1	:CHECK THIS ENTRY
	JNBS	TONOW1		:LOOP IF NOT MATCH
	LHL	R3,TLIST,R1	:WE GOT A MATCH
	STH	R3,TLIST,R2	:UNLINK THIS ENTRY
	LHL	R3,TLIST	:GET START OF FREE LIST
	STH	R3,TLIST,R1	:LINK THIS ENTRY TO FREE LIST
	STH	R1,TLIST	:PLACE ON FREE LIST
	ST	R5,TO9		:SAVE RETURN ADDRESS
	JR	R0		:AND GO TO ROUTINE

TOGET	LIS	R1,2		:SEARCH ACTIVE LIST
TOGET1	LR	R2,R1		:COPY CURRENT ENTRY POINTER
	LHL	R1,TLIST,R2	:GET NEXT ENTRY
	JER	R5		:LIST EXHAUSTED...EXIT
	CL	R0,TLIST+2,R1	:CHECK THIS ENTRY
	JNBS	TOGET1		:LOOP IF NOT MATCH
	LHL	R3,TLIST,R1	:WE GOT A MATCH
	STH	R3,TLIST,R2	:UNLINK THIS ENTRY
	LHL	R3,TLIST	:GET START OF FREE LIST
	STH	R3,TLIST,R1	:LINK THIS ENTRY TO FREE LIST
	STH	R1,TLIST	:PLACE ON FREE LIST
	JR	R5		:AND EXIT

IZT	LHI	R1,NTOUT*LSIZ	:INITIALIZE TIMEOUT FREE LIST
	LIS	R2,0		:0 TERMINATES LIST
	STH	R2,TLIST+2	:ACTIVE LIST IS EMPTY
	STH	R2,TLIST,R1	:TERMINATE FREE LIST
	STH	R1,TLIST-LSIZ,R1
	SIS	R1,LSIZ
	JGBS	.-6
	JR	R0
	EM
	SUBTTL	ISIS Ring Handling Routines	- FRING.LIB
:******************************************************************
:
:	This program is the sole property and confidential
:	information of Tymshare, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.
:
:*******************************************************************
	RA	0		:	FRING.LIB

:	ISIS RING HANDLERS

:	This package is the fast, efficient ring handler set
:	The following CONSTRAINTS apply:
:	1.  Once started, register 14 or 15 is dedicated to that
:		operation, until it is "ended".
:	2.  If a new operation is started before the previous operation is
:		"ended", the previous operation is aborted, and the
:		appropriate ring is effectively left unchanged.
:
:	This package now permits simultaneous input and output!!!
:		R15 is used for output operations
:		R14 is used for input operations

:*: NOTE: ISIS II will soon use negative indexing, like this ring package.
:*:	To convert this package, remove all lines with ':*:' in them,
:*:	and change all occurrences of 'LHL R15/R14' to 'LH R15/R14'.

:	The package contains both utility and primitive routines:

:	utility routines are called with link R5,
:	they preserve registers R6--R14.
:	OCS	Output Canned String
:		R2 = port #, R3 = pointer to string (SC format)
:		OCS will output string as a data message to the specified
:		port. OCS goes to completion, and "ends the operation.
:	OCM	Output Canned Message
:		R2 = port #, R3 = pointer to string (SC format)
:		OCM will output the string as a message to the specified port
:		OCM goes to completion, and "ends the operation.
:	OBS	Output Byte String
:		R2 = number of characters, R3 = pointer to string
:		OBS will output specified string into the current message
:		message must have already been "started", and is NOT "ended".

:	primitive input routines.  All link on R4, & preserve R1-R3, R5-R13, R15:
:	LOOK	Determine if an input message exists...normal return if not
:		skip (4) return if so, and then:
:		R1 = port number
:		R2 = message type code (peek)
:		On skip return, condition codes are set such that JE will
:		succeed on port 0.  The port number will have been removed
:		from the message but the message code will not have been
:		removed (you get a peek at it).
:	GETCH	Get a character, returned in R0.
:	GETH	Get a halfword, returned in R0.  An even number of bytes 
:		should have been removed previously for expected results.
:	GETW	Get a word, returned in R0.  An even number of halfwords 
:		should have been removed previously for expected results.
:	FLUSH	Flush away ("end") remainder of input message.  R0 is number
:		of bytes remaining to flush.
:	ELIR	End-Logical-Input-Record.  "Ends" current message, sets
:		up pointers for next message.

:	Primative output routines.  All link on R4, preserve R1-R3, R5-R14,
:	unless used for arguments, or otherwise specified:
:	SPACE	Returns R0 = number of characters of space available in	
:		output ring. Sets up R15 for "start" of message.
:	ROOM	R0 = number of characters required for next message,
:		returns when that much room is available in output ring.
:		MAY DISMISS.
:		sets up R15 for "start" of message. SMASHES R1.
:	SLOR	Start Logical Output Record.
:		R0 = number of bytes required.
:		R1 = port #
:		R2 = message type code.
:		Provides function of ROOM, PUTH, and PUTCH for first 3 chars
:		of message. MAY DISMISS. SMASHES R3.
:	PUTCH	places character in R0 in next position of ring.
:	PUTH	places halfword in R0 in next position of ring.  Even number
:		of bytes have been output previously in this message.
:	PUTW	places word in R0 in next position of ring.  Even number of
:		halfwords should have been output previously in this message.
:	ELODR	End Logical Output Data Record
:		places byte count into message type to make data message,
:		then "ends" message.  Smashes R0, R1.
:	ELOR	End Logical Output Record
:		"ends" message.

:	CONVENTIONS:
:	ROUTINES USE DEDICATED REGISTERS:
:	R15	OUTPUT RING INDEX
:	R14	INPUT RING INDEX
:
:	NOTE....
:		IRSIZE AND ORSIZE MUST EACH BE LESS THAN 32K.

	GL	IRING,ORING,IRSIZE,ORSIZE
	GL	OCS,OCM,OBS
	GL	LOOK,GETCH,GETH,GETW,FLUSH,ELIR
	GL	SPACE,ROOM,SLOR,PUTCH,PUTH,PUTW,ELODR,ELOR

	MO	.,RING
NFMI	EQ	0		:RELATIVE INDEX OF NEXT-FILL-MESSAGE-INDEX
CEI	EQ	2		:RELATIVE INDEX OF CURRENT-EMPTY-INDEX
RING	EQ	4		:RELATIVE INDEX OF START OF RING DATA

:	DEFINE DATA AREA
	SEG	A.RING		:RINGS IN RING AREA

:	THE DISPATCHER OUTPUT RING
ORING	HS	0		:OUTPUT BLOCK START ADDRESS
	HC	0		:OUTPUT NEXT FILL MESSAGE INDEX
	HC	0		:OUTPUT CURRENT ENTRY INDEX
	BS	ORSIZE		:THE OUTPUT RING

:	THE DISPATCHER INPUT RING
IRING	HS	0		:INPUT BLOCK START ADDRESS
	HC	0		:INPUT NEXT FILL MESSAGE INDEX
	HC	0		:INPUT CURRENT EMPTY INDEX
	BS	IRSIZE		:THE INPUT RING

:	CODE AREA
	SEG	A.CODE
:	INPUT ROUTINES

:	LOOK AT A RING ENTRY
:	NORMAL RETURN IF RING EMPTY
:	ELSE SKIP RETURN, PORT RETURNED IN R1
:	MESSAGE TYPE RETURNED IN R2
:	ALL REGISTERS SET UP FOR TRANSFER
:	POSITION IS ADVANCED PAST PORT#
	IF	\LOOK;.LOOK.	 HS	0;	ELSE;LOOK	 HS	0;	EI
	LHL	R14,CEI+IRING,,	:GET CURRENT EMPTY INDEX
	CLH	R14,NFMI+IRING,,	:TEST IF CAUGHT UP
	JER	R4		:EMPTY...NORMAL RETURN
	SHI	R14,IRSIZE	:*: CONVERT TO NEGATIVE INDEX
	LHL	R1,IRING+RING+IRSIZE,R14,	:GET PORT #
	AIS	R14,2		:BUMP POINTER PAST PORT #
	LB	R2,IRING+RING+IRSIZE,R14,	:GET MESSAGE TYPE
	LR	R1,R1		:SET CONDITION CODES
	J	4,R4		:THEN SKIP RETURN

:	GET A CHARACTER FROM THE INPUT RING
:	CHARACTER RETURNED IN R0
GETCH	LB	R0,IRING+RING+IRSIZE,R14,	:GET THE CHAR
	AIS	R14,1		:BUMP INDEX
	JLR	R4		:RETURN IF NOT
	LHI	R14,-IRSIZE	:ELSE FOLD IT
	JR	R4		:AND EXIT

:	GET A HALF-WORD FROM THE INPUT RING
:	ASSUME HAVE REMOVED AN INTEGRAL NUMBER OF HALF-WORDS FROM RECORD
:	HALF-WORD RETURNED IN R0
GETH	LHL	R0,IRING+RING+IRSIZE,R14,	:GET THE DATA
	AIS	R14,2		:BUMP INDEX
	JLR	R4		:RETURN IF NOT
	LHI	R14,-IRSIZE	:ELSE FOLD IT
	JR	R4		:AND EXIT

:	GET A WORD FROM THE INPUT RING
:	ASSUME HAVE REMOVED AN INTEGRAL NUMBER OF WORDS FROM RECORD
:	WORD RETURNED IN R0
GETW	L	R0,IRING+RING+IRSIZE,R14,	:GET THE DATA
	AIS	R14,4		:BUMP INDEX
	JLR	R4		:RETURN IF NOT
	LHI	R14,-IRSIZE	:ELSE FOLD IT
	JR	R4		:AND EXIT

:	FLUSH AN INPUT RECORD
:	NUMBER OF CHARS TO FLUSH IN R0
FLUSH	AR	R14,R0		:ADVANCE RING AND FALL THROUGH

:	END LOGICAL INPUT RECORD
ELIR	AIS	R14,3		:FORCE TO NEXT WORD
	NHI	R14,-4
	JLFS	ELIR2		:NO
	SHI	R14,IRSIZE	:YES
ELIR2
	AHI	R14,IRSIZE	:*: CONVERT TO POSITIVE INDEX
	STH	R14,CEI+IRING,,
	JR	R4		:AND EXIT

:	OUTPUT ROUTINES

:	OUTPUT "CANNED" MESSAGE
:	LINK ON R5
:	R2 = PORT #
:	R3 = POINTER TO STRING (FORMAT: n\B1\...\Bn)
OCM	LB	R0,0,R3		:GET COUNT n
	AIS	R0,5		:COMPUTE SPACE REQUIREMENTS
	NHI	R0,-4
	JAL	R4,ROOM		:INSURE THERE IS ROOM
	LR	R0,R2		:COPY PORT #
	JAL	R4,PUTH		:PLACE PORT NUMBER
	LB	R2,0,R3		:GET COUNT AGAIN
	J	OCS1		:SKIP TO PLACE THE STRING

:	OUTPUT "CANNED" STRING
:	LINK ON R5
:	R2 = PORT #
:	R3 = POINTER TO TEXT STRING (FORMAT n\B1\...\Bn)
OCS	LB	R0,0,R3		GET COUNT n
	AIS	R0,6		:COMPUTE SPACE REQUIREMENTS
	NHI	R0,-4
	JAL	R4,ROOM		:INSURE THERE IS ROOM
	LR	R0,R2
	JAL	R4,PUTH		:PLACE PORT NUMBER
	LB	R2,0,R3
	LR	R0,R2		:GET THE COUNT n
	JAL	R4,PUTCH	:PLACE IT...MESSAGE TYPE 1-7D
OCS1	AIS	R3,1		:BUMP SOURCE CHARACTER POINTER
	LB	R0,0,R3		:GET THE NEXT CHARACTER
	JAL	R4,PUTCH	:PLACE IT INTO RING
	SIS	R2,1		:REDUCE COUNT
	JGBS	OCS1		:REPEAT UNTIL ALL CHARACTERS PLACED
	JAL	R4,ELOR		:END LOGICAL OUTPUT RECORD
	JR	R5		:THEN EXIT

:	OUTPUT A BYTE STRING
:	LINK ON R5
:	R3 = POINTER TO STRING
:	R2 = NUMBER OF CHARACTERS TO OUTPUT FROM STRING
OBS1	AIS	R3,1		:BUMP CHARACTER POINTER
OBS	LB	R0,0,R3		:GET THE NEXT CHARACTER
	JAL	R4,PUTCH	:PLACE IT INTO RING
	SIS	R2,1		:REDUCE COUNT
	JGBS	OBS1		:REPEAT UNTIL ALL CHARACTERS PLACED
	JR	R5		:THEN EXIT

:	FIND SPACE IN THE RING (HOW BIG A MESSAGE IT WILL TAKE)
:	RETURNS R0 = NUMBER OF CHARS OF SPACE
SPACE	LCS	R0,4		:SET MASK
	LHL	R15,NFMI+ORING,,
	NH	R0,CEI+ORING,,	:FORCE EMPTIER TO WORD BOUNDARY
	SR	R0,R15		:SPACE BETWEEN US AND EMPTIER
	JGFS	SPACE1		:SKIP IF NO WRAP-AROUND
	AHI	R0,ORSIZE	:ELSE CORRECT FOR WRAP
SPACE1	SIS	R0,4		:CORRECT FOR POSSIBLE OVERFLOW
	SHI	R15,ORSIZE	:*: CONVERT TO NEGATIVE INDEX
	JR	R4		:AND RETURN

:	INSURE THERE IS ROOM IN THE RING (DISMISS IF NECESSARY)
:	EXPECTS R0 = NUMBER OF CHARACTERS OF SPACE
ROOM	LHL	R15,NFMI+ORING,,
	SHI	R15,ORSIZE	:*: CONVERT TO NEG. INDEX
ROOM1	LCS	R1,4		:SET MASK
	NH	R1,CEI+ORING,,	:FORCE HIM TO WORD BOUNDARY
	SHI	R1,ORSIZE	:*:
	SR	R1,R15		:CHECK RELATIVE POSITIONS
	JGFS	ROOM2		:SKIP IF HE'S AHEAD OF US
	JER	R4		:EQUAL...HE'S EMPTY...GO DO IT
	AHI	R1,ORSIZE		:HE'S BEHIND US
ROOM2	SIS	R1,4		:ALLOW FOR POTENTIAL OVERFLOW
	CR	R0,R1
	JLER	R4		:ROOM EXISTS...GO DO IT
	SVC	DISMISS,0
	J	ROOM1		:AND GO TRY AGAIN

:	START LOGICAL OUTPUT RECORD
:	PROVIDES FUNCTION OF ROOM, PUTH, & PUTCH FOR FIRST 3 CHARS OF MESSAGE
:	R0 = NUMBER OF CHARACTERS OF SPACE REQUIRED
:	R1 = PORT #
:	R2 = MESSAGE CHARACTER CODE
SLOR	LHL	R15,NFMI+ORING,,
	SHI	R15,ORSIZE	:*: CONVERT TO NEG. INDEX
SLOR1	LCS	R3,4		:SET A MASK
	NH	R3,CEI+ORING,,	:FORCE RECEIVER TO WORD BOUNDARY
	SHI	R3,ORSIZE	:*:
	SR	R3,R15
	JGFS	SLOR2
	AHI	R3,ORSIZE	:ACCOUNT FOR POSSIBLE RING FOLDING
SLOR2	SIS	R3,4		:ALLOW FOR POTENTIAL OVERFLOW
	CR	R3,R0
	JGEFS	SLOR3		:SKIP IF WE CAN GO
	SVC	DISMISS,0
	JBS	SLOR1
SLOR3	STH	R1,ORING+RING+ORSIZE,R15,	:OK...PLACE MESSAGE
	STB	R2,2+ORING+RING+ORSIZE,R15,
	AIS	R15,3		:BUMP PAST THESE CHARACTERS
	JR	R4		:AND EXIT

:	PUT A CHARACTER INTO THE RING
:	R0 = CHARACTER
PUTCH	STB	R0,ORING+RING+ORSIZE,R15,	:PLACE THE CHARACTER
	AIS	R15,1		:BUMP INDEX
	JLR	R4		:SKIP IF NOT
	LHI	R15,-ORSIZE	:ELSE WRAP AROUND
	JR	R4		:AND EXIT

:	PUT A HALF-WORD INTO THE RING
:	R0 = HALF-WORD
PUTH	STH	R0,ORING+RING+ORSIZE,R15,	:PLACE THE HALF-WORD
	AIS	R15,2		:BUMP INDEX
	JLR	R4		:EXIT IF NOT
	LHI	R15,-ORSIZE	:ELSE WRAP AROUND
	JR	R4		:AND EXIT

:	PUT A WORD INTO THE RING
:	R0 = WORD
PUTW	ST	R0,ORING+RING+ORSIZE,R15,	:PLACE THE WORD
	AIS	R15,4		:BUMP INDEX
	JLR	R4		:SKIP IF NOT
	LHI	R15,-ORSIZE	:ELSE WRAP AROUND
	JR	R4		:AND EXIT

:	END LOGICAL OUTPUT DATA RECORD
ELODR	LHL	R1,NFMI+ORING,,	:GET START OF THIS MESSAGE
	SHI	R1,ORSIZE	:*: CONVERT TO NEG. INDEX
	LR	R0,R15		:COPY MESSAGE END
	SR	R0,R1		:COMPUTE SIZE OF THIS MESSAGE
	JGEFS	ELODR2		:SKIP IF NO WRAP-AROUND
	AHI	R0,ORSIZE		:ELSE CORRECT FOR WRAP
ELODR2	SIS	R0,3		:MAKE ALLOWANCE FOR HEADER
	JER	R4		:EXIT IF ZERO LENGTH MESSAGE
	STB	R0,2+ORING+RING+ORSIZE,R1,	:INSERT MESSAGE TYPE INTO MESSAGE
				:AND FALL THROUGH

:	END LOGICAL OUTPUT RECORD
ELOR	AIS	R15,3
	NHI	R15,-4
	JLFS	ELOR2
	LHI	R15,-ORSIZE	:FOLD IF NECESSARY
ELOR2
	AHI	R15,ORSIZE	:*: CONVERT BACK
	STH	R15,NFMI+ORING,,	:NOW ADVANCE POINTER TO NEXT MESSAGE
	JR	R4		:AND EXIT
	EM
	SUBTTL	Library Package for BID and BIDH	- BID.LIB
:******************************************************************
:
:	This program is the sole property and confidential
:	information of Tymshare, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.
:
:*******************************************************************
	RA	0		:	BID.LIB
:	Library package for BID, BIDH

:	either routine called with bit pattern in R1, link on R3
:	returns number of a non-zero bit in R2
	GL	BID,BIDH
	SEG	A.CODE		:PLACE IN CODE AREA
	MO	.,BID
:

:	HALFWORD Bit identifier
:	left half of R1 must be zero if bit 16 is zero
:	returns original word in R1
:	number of leftmost bit of right half or R1 in R2
  IF	ENGINE
BIDH	JFFOH	R1,BIDH1	:FIND FIRST NON-ZERO BIT
	LHI	R2,10	:RETURN 10 IF NO BIT IS FOUND
BIDH1	JR	R3	:AND RETURN
  ELSE
BIDH1	LB	R2,BIDTAB,R1	:LEFT HALF IS EMPTY
	JR	R3		:GET ID OF FIRST BIT IN RIGHT HALF
BIDH	THI	R1,0FF00	:TEST IF FIRST BIT IS IN LEFT OR RIGHT BYTE OF HALFWORD
	JEBS	BIDH1		:RIGHT HALF
	EXBR	R2,R1		:LEFT HALF
	LBR	R2,R2		:COPY LEFT BYTE
	LB	R2,BIDTAB,R2	:USE IT TO INDEX INTO ID TABLE
	SIS	R2,8		:ADJUST NUMBER TO CORRESPOND TO LEFT BYTE
	JR	R3		:AND RETURN
  EI	ENGINE

:	FULLWORD Bit identifier
:	returns original word in R1
:	number of leftmost non-zero bit in R2
  IF	ENGINE
BID	JFFO	R1,BID1		:TEST FULLWORD FOR FIRST NON-ZERO BIT
	LHI	R2,20		:RETURN 20 IF NO BIT FOUND
BID1	JR	R3		:AND RETURN
  ELSE
BID1	LB	R2,BIDTAB,R1	:IN BYTE 4
	AHI	R2,10		:GET BIT ID FOR BYTE AND ADJUST FOR BYTE 4
	JR	R3
BID2	THI	R1,0FF00	:BYTE 1 AND 2 = 0
	JEBS	BID1		:IF BYTE 3 IS 0, LOOK UP BYTE 4
	EXBR	R2,R1		:ELSE COPY OUT BYTE 3
	LBR	R2,R2
	LB	R2,BIDTAB,R2	:PICK UP INDEX FOR THAT BYTE
	AIS	R2,8		:ADJUST FOR BYTE 3
	JR	R3
BID	THI	R1,8000		:TEST IF IN LEFT 17 BITS
	JEBS	BID2		:IF NOT, MUST BE IN BYTE 3 OR 4
	EXHR	R2,R1		:BIT IS IN BYTE 1 OR 2 (OR BIT 16)
	TI	R2,0FF00	:TEST IF BYTE 1
	JEFS	BID3		:SKIP IF NOT
	EXBR	R2,R2		:BIT IS IN BYTE 1, SO COPY BYTE 1
	LBR	R2,R2		:TO USE AS INDEX
	LB	R2,BIDTAB,R2	:LOOK UP ID WITHIN THIS BYTE
	SIS	R2,8		:ADJUST FOR REALLY BEING IN BYTE 1
	JR	R3
BID3	LBR	R2,R2		:HERE WITH BIT IN BYTE 2 (OR BIT 16)
	LB	R2,BIDTAB,R2	:LOOK UP ID WITHIN THIS BYTE
	JR	R3		:IF FIRST BIT WAS BIT 16, USE ENTRY 0 IN TABLE
BIDTAB	HS	0		:TABLE OF BIT NUMBERS IN A BYTE, BIASED BY 8
	NOLIST
	XC	100F0E0E0D0D0D0D0C0C0C0C0C0C0C0C0B0B0B0B0B0B0B0B0B0B0B0B0B0B0B0B
	XC	0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A0A
	RE	2
	XC	0909090909090909090909090909090909090909090909090909090909090909
	ER
	RE	4
	XC	0808080808080808080808080808080808080808080808080808080808080808
	ER
	LIST
  EI	ENGINE
	EM
	SUBTTL	ISIS STARTUP AND CRASH LIBRARY	- CRASH.LIB
        REMARK  %CRASH.LIB    11-15-84 AWT
	REMARK	%THIS VERSION HAS AN OPTION FOR EXTENDED CRASH PROCESSING.

:******************************************************************
:
:	This program is the sole property and confidential
:	information of Tymshare, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.
:
:*******************************************************************
	RA	0		:	CRASH.LIB	MFR 07/14/81

:       Set UPSW to turn off tracing.
:       Added CTIME and CRTIME to save crash times in GMT.
:       Added a NCRSAV option to keep old copies of crash tables.
:         April 13, 1983 AWT
:
:	Changed the supervisor's log message to report the PRODID.
:	Sep. 20, 1982 SCY.
:	ENTRY2 (restart service) changed to clear input and output
:	rings PRIOR to issuing Restart SVC to prevent crash-loop if
:	Dispatcher has crashed. June 17, 1982 MDS.

:			ISIS - II Version
:
	GL	CRASH,CRASHC,CPOINT,CFROM,CRREG,ENTRY,START,CRAT,CRSHCT,CRSTOP
        GL      PRODID,NCRSAV,CTIME,CRTIME,EXCRSH
	MO	.,CRASH


:	Generalized crash package.
:	Handles both software and hardware crashes.  On any crash, the
:	registers are saved in CRXREG, and CRSHCT is incremented.
:	Software crashes occur via  JAL R10,CRASH .  CRASH saves (R10) in cell
:	CPOINT.  Software crashes may be "good" or "bad"...if "good", the
:	calling sequence is:

:		JAL	R10,CRASH
:						from a bad one
:		HC	0		:this key distinguishes a good crash
:		BC	4*L,Y		:first byte is 4*register linked to
:						routine, Y is the reason
:	then register (L) is saved in CFROM, and Y is saved in CRASHC

:	in the event of a hardware failure, CPOINT contains the instruction
:	address at the time of failure, CRASHC contains the failure reason,
:	and CFROM is set =-1.

:	On completion of crash, transfers to label START, defined
:	in the user code.
:
:	The symbol CRSTOP may be set to 0 or 1.  If 1 the crash routine will
:	be executed only once.  the second time through the crash area will
:	be set up as specified above and then registers will be restored to
:	their entry value and the slot will be frozen. If it is thawed it
:	will restart.
:
:       The symbol NCRSAV defines the number of crash tables to be saved.
:       It will be set to 1 by default. (In TYMFIL CRSHTB macro is used
:       to define NCRSAV)
:
:       Entering :R CRAT,CRTSIZ (or 4C) will dump the last 
:       crash table, CRAT+CRTLEN (or 50),CRTSIZ will dump the    
:       previous crash table and so on.
:
:       CTIME,4 gives the last crash time (in GMT), CTIME+CRTLEN,4
:       gives the previous crash time and so on.
:
:	The symbol EXCRSH, if set to 1, allows a JAL to label
:	CRSH.P out of the crash routine for extended crash processing.
:	The link is R5.  EXCRSH is defaulted to 0.
:
:

  IF	\CRSTOP
  ELSE
CRSTOP	EQ	0
  EI
  
  IF    \NCRSAV                 :# OF CRASH TABLES TO SAVE
  ELSE                          :IT MAY BE DEFINED IN TYMFIL
NCRSAV  EQ      1               :OTHERWISE IT IS 1 BY DEFAULT
  EI

  IF	\EXCRSH			:DEFAULT TO NO EXTENDED CRASH HANDLING
  ELSE
EXCRSH	EQ	0
  EI


CRTENT  EQ      .               :CRASH TABLE ENTRY
        ORG     0
CRSHCT	HS	1		:CRASH COUNT...HOW MANY TIMES CRASHED
CRASHC	HS	1		:CRASH CODE (INIT'ED TO MANUAL RESTART)
CPOINT	HS	2		:WHERE CRASH OCCURED
CFROM	HS	2    		:WHERE CRASH WAS CALLED FROM
CRXREG	HS	20		:CRASH REGISTER SAVE AREA
CRTSIZ  WS      0               :SIZE OF CRASH TABLE WITHOUT CRTIME
CRTIME  WS      1               :REAL TIME OF CRASH (GMT)
CRTLEN  WS      0               :LENGTH OF CRASH TABLE WITH CRTIME
        ORG     CRTENT  

        SEG     A.DATA
        HS      0
CTIME   WS      1               :STORAGE FOR CRASH TIME OF LAST CRASH
CRAT    BS      CRTLEN*NCRSAV   :STORAGE FOR CRASH TABLE(S)
CRREG   EQ      CRAT+CRXREG
RGSTOR  WS      10              :TEMPORARY STORAGE FOR REGISTERS
FGNDFL	HS	1		:FOREGROUND FLAG

TRBOFF  WC      0,FAIL0         :TRACE BIT OFF, GO TO FAIL0
TRCOFF  WC      0,CRASH0        :TRACE BIT OFF, GO TO CRASH0
PSWSAV  WC      0,START         :RESTORE PSW,  GO TO INITIALIZATION CODE
CHFLAG  WC      0               :USED FOR ANY CHANGES ON PSW


	SEG	A.CODE		:CODE AREA
CRSHCD	BC	1	:MANUAL RESTART
	BC	0	:POWER FAILURE
	BC	0E	:PARITY ERROR
	BC	10	:DISPATCHER CRASH
	BC	11	:ILLEGAL INSTRUCTION
	BC	12	:ILLEGAL SVC
	BC	13	:SYSTEM CRASH
	BC	14	:PROTECTION VIOLATION
	BC	15	:NON-RECOVERABLE DEVICE CHECK
	BC	16	:WATCH FROG TIMER - - TIME OUT

	RA	0
:	GENERAL MACHINE FAILURE
FAIL	HS	4		:PSD SAVED HERE
	HS	4		:R0,R1 SAVED HERE
        ST      R0,RGSTOR,,     :SAVE R0
        ST      R2,RGSTOR+4,,   :SAVE R2
        JAL     R2,SAVPSW       :SAVE CURRENT PSW
        L       R0,RGSTOR,,     :RESTORE R0
        L       R2,RGSTOR+4,,   :RESTORE R2
        UPSW    TRBOFF          :TRACE BIT OFF AND CONTINUE
FAIL0   LB      R0,CRSHCD,R1    :CONVERT CRASH REASON
	CLHI	R0,12		:TEST IF ILLEGAL SVC
	JNFS	FAIL1		:NO...SKIP
	LHL	R0,FGNDFL	:DID FOREGROUND CAUSE THE CRASH?
	JN	ENTRY2		:YES....JUMP OVER
FAIL1   STM     R0,RGSTOR,,     :SAVE REGISTERS
        JAL     R2,PSHTBS       :PUSH DOWN CRASH TABLES
        L       R1,GMT,,        :GET GMT CLOCK
        ST      R1,CTIME,,      :SAVE IT AS THE CRASH TIME
        LM      R0,RGSTOR,,     :RESTORE REGISTERS
        STM     R2,CRAT+CRXREG+8,, :SAVE THE REGISTERS
        STH     R0,CRAT+CRASHC,,  :SAVE CRASH CODE
        LM      R12,FAIL          :GET THE REST
        STM     R14,CRAT+CRXREG,,  :SAVE R0 & R1
        ST      R13,CRAT+CPOINT,, :SAVE FAILURE ADDRESS
	LCS	R1,1
        ST      R1,CRAT+CFROM,,   :FLUSH PLACE CALLED FROM
        J       ENTRY1            :AND SKIP TO START UP AGAIN



:	CRASH ROUTINE AND GENERAL INITIALIZER
:	IF "GOOD" CALL TO CRASH, HAS HALFWORD 0'S FOLLOWING,
:	THEN BYTE WITH 4*LINK REGISTER, THEN BYTE WITH CRASH REASON

CRASH   ST      R0,RGSTOR,,     :SAVE R0
        ST      R2,RGSTOR+4,,   :SAVE R2         
        JAL     R2,SAVPSW       :SAVE CURRENT PSW
        L       R0,RGSTOR,,     :RESTORE R0
        L       R2,RGSTOR+4,,   :RESTORE R2
        UPSW    TRCOFF          :TRACE BIT OFF AND CONTINUE
CRASH0  STM     R0,RGSTOR,,     :SAVE REGISTERS
        JAL     R2,PSHTBS       :PUSH DOWN THE CRASH TABLES
        L       R1,GMT,,        :GET GMT CLOCK
        ST      R1,CTIME,,      :SAVE IT AS THE CRASH TIME
        LM      R0,RGSTOR,,     :RESTORE REGISTERS
        STM     R0,CRAT+CRXREG,, :SAVE REGISTERS AND
        ST      R10,CRAT+CPOINT,,                    
	LIS	R0,$A10		:FAKE UNKNOWN CRASH
	LCS	R1,1		:FROM NOWHERE
	LHL	R2,0,R10	:CHECK WHERE CALLED FROM
	JNFS	CRASH1		:NOT KNOWN...USE DEFAULT
	LB	R0,3,R10	:GET CRASH CONDITION
	LB	R2,2,R10	:GET CALLING REGISTER
        L       R1,CRAT+CRXREG,R2 :GET CONTENTS OF REGISTER
        
CRASH1  STH     R0,CRAT+CRASHC,, :SAVE CRASH CODE
        ST      R1,CRAT+CFROM,,  :SAVE PLACE CRASHED FROM
	JFS	ENTRY1

:	ENTER HERE WITH RESTART
ENTRY	LIS	R0,1		:LOAD CRASH CODE REGISTER
        STH     R0,CRAT+CRASHC,, :STORE IT
ENTRY1	LIS	R1,1
        AHM     R1,CRAT+CRSHCT,, :SAVE INTERESTING DATA

  IF	CRSTOP		:IF STOPPING ON CONSECUTIVE CRASHES
	CLHI	R0,1
	JLE	ENTRY2		:IF POWER FAILURE OR MANUAL RESTART
	OHI	R0,0CC00	:CRASH INDICATOR FOR FRONT PANEL
	STH	R0,FPANEL,,	:SET PANEL TO BAD CRASH
   IF	EXCRSH
	JAL	R5,CRSH.P,,	:GO DO EXTENDED CRASH PROCESSING
   EI	EXCRSH
        LM      R0,CRAT+CRXREG,, :RESTORE REGISTERS
	SVC	SYS,HALT.	:HALT THE SLOT
  EI	CRSTOP

	LIS	R0,1		:WANT SECOND WORD OF PSD
	SVC	SYS,RFPSD.	:READ FOREGROUND PSD
	CLI	R0,.		:TEST IF FOREGROUND IS EXECUTING THIS INSTRUCTION
	JNFS	ENTRY2		:SKIP IF NOT
	STH	R0,FGNDFL	:SET THE FOREGROUND FLAG

ENTRY2		: NOW RESET OUTPUT RING, REPORT CRASH
  IF	CRSTOP
  ELSE
   IF	EXCRSH
	JAL	R5,CRSH.P,,	:GO DO EXTENDED CRASH PROCESSING
   EI	EXCRSH
  EI	CRSTOP
	LIS	R0,0
	ST	R0,ORING,,	:EMPTY OUTPUT RING
	ST	R0,IRING,,	:EMPTY INPUT RING

	LA	R0,FAIL		:LOAD TRAP AREA ADDRESS
	SVC	SYS,RSTRT.	:RESTART SVC
	JAL	R10,CRASH	:NON-SKIP RETURN...CRASH


	LIS	R0,0
	STH	R0,FGNDFL	:CLEAR THE FOREGROUND FLAG

	JAL	R4,SPACE,,	:SET UP FOR DIAGNOSTIC
	LHI	R0,0300
	JAL	R4,PUTW,,	:PORT 0 + DIAGNOSTIC MESSAGE + PAD
	LHL	R0,CRAT+CRSHCT,,
	JAL	R4,PUTCH,,	:HW4 LOW = CRASH COUNT
	LIS	R0,0
	JAL	R4,PUTCH,,	:RESERVED BYTE
	LIS	R0,1
	JAL	R4,PUTCH,,	:REPORT TYPE = 1
	LHL	R0,CRAT+CRASHC,,
	JAL	R4,PUTCH,,	:HW3 HIGH = CRASH CODE
	LHI	R0,PRODID
	JAL	R4,PUTCH,,	:HW2 LOW IS PRODUCT ID
	JAL	R4,ELOR,,	:END LOGICAL OUTPUT RECORD
        L       R1,CHFLAG,,     :SEE IF PSW HAS BEEN CHANGED
        CLHI    R1,1
        JNFS    CURPSW          :NO CHANGE, GO TO USE CURRENT PSW
        LIS     R1,0
        ST      R1,CHFLAG,,     :RESET CHFLAG FOR FUTURE PSW CHANGE
        UPSW    PSWSAV          :INITIALIZE WITH RESTORED PSW
CURPSW  J       START,,         :INITIALIZE WITH CURRENT PSW

SAVPSW  LIS     R0,1            :GET PC OF BACKGROUND PSD
        ST      R0,CHFLAG,,     :ALSO INDICATE PSW WILL BE MODIFIED
        SVC     SYS,RBPSD.      :READ BACKGROUND PSD
        CLI     R0,.            :IS IT RUNNING?
        JNFS    ISFGND          :NO, IT MUST BE FOREGROUND JOB
        LIS     R0,0            :GET PSW OF BACKGROUND JOB
        SVC     SYS,RBPSD.
        ST      R0,PSWSAV,,     :SAVE IT
        JR      R2              :RETURN
ISFGND  LIS     R0,0            :GET PSW OF FORGROUND JOB
        SVC     SYS,RFPSD.
        ST      R0,PSWSAV,,     :SAVE IT
        JR      R2              :RETURN


PSHTBS  LHI     R1,CRTLEN*NCRSAV-CRTLEN*2
        JLR     R2              :IF ONLY 1 CRASH TABLE, SKIP AND RETURN
PUSHIT  LM      R6,CRAT,R1      :PUSH DOWN THE CRASH TABLE
        STM     R6,CRAT+CRTLEN,R1
        LM      R6,CRAT+CRTLEN/2,R1
        STM     R6,CRAT+CRTLEN+CRTLEN/2,R1
        SHI     R1,CRTLEN
        JGEBS   PUSHIT
        L       R1,CTIME,,
        ST      R1,CRAT+CRTSIZ,,
        JR      R2              :RETURN
         
	EM

        SUBTTL	CHR-BISYNC CONTROL CHAR DEFINITION
        RA      0
        MO      .,BSCCHR

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::        B I S Y N C   C O N T R O L   C H A R   D E F I N I T I O N        ::
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:       MACRO TO DO 1-8,8-1 BIT REVERSAL OF AN EQ'D SYMBOL CREATING A
:       NEW SYMBOL R`SYMBOL.  THIS IS NEEDED BECAUSE CURRENT HARDWARE
:       RECEIVES SYNCHRONOUS DATA MSB INSTEAD LSB FIRST.

RVCHAR  MACRO(CHAR)[NOLIST
Q       EQ      0
        IF CHAR&80     ;Q EQ Q+01;      EI
        IF CHAR&40     ;Q EQ Q+02;      EI
        IF CHAR&20     ;Q EQ Q+04;      EI
        IF CHAR&10     ;Q EQ Q+08;      EI
        IF CHAR&08     ;Q EQ Q+10;      EI
        IF CHAR&04     ;Q EQ Q+20;      EI
        IF CHAR&02     ;Q EQ Q+40;      EI
        IF CHAR&01     ;Q EQ Q+80;      EI
        LIST
R`CHAR  EQ      Q]

:       BISYNC CONTROL CHARS
:       --------------------
:       '*' MEANS MUST BE PRECEEDED BY DLE

SOH	EQ	01		:START OF HEADER
STX	EQ	02		:START OF TEXT
ETX	EQ	03		:END OF TEXT
DLE	EQ	10		:DATA LINK ESCAPE
ITB	EQ	1F		:END OF INTERMEDIATE TRANSMISSION BLOCK
ETB	EQ	26		:END OF TRANSMISSION BLOCK
ENQ	EQ	2D		:ENQUIRY
SYN	EQ	32		:SYNCHRONOUS IDLE
EOT	EQ	37		:END OF TRANSMISSION
NAK	EQ	3D		:NEGATIVE ACKNOWLEDGEMENT
ACK1	EQ	61		:* AFFIRMATIVE ACKNOWLEDGEMENT 1
WACK	EQ	6B		:* WAIT BEFORE TRANSMIT POSITIVE ACKNOWLEDGEMENT
ACK0	EQ	70		:* AFFIRMATIVE ACKNOWLEDGEMENT 0
RVI	EQ	7C		:* REVERSE INTERRUPT


:       BISYNC CONTROL CHARACTERS WITH BIT REVERSAL
:       -------------------------------------------

        RVCHAR(SOH)
        RVCHAR(STX)
        RVCHAR(ETX)
        RVCHAR(DLE)
        RVCHAR(ITB)
        RVCHAR(ETB)
        RVCHAR(ENQ)
        RVCHAR(SYN)
        RVCHAR(EOT)
        RVCHAR(NAK)
        RVCHAR(ACK1)
        RVCHAR(WACK)
        RVCHAR(ACK0)
        RVCHAR(RVI)

        EM

        EM
        SUBTTL	CMDLST-COMMAND LIST PROCESSING
        GL      GCL,PCL,CLFULL,IZCFL,GCL01
        GL      RDEV,CLFULL,CLPTR
        GL      CLBUG
        GL      CMDLK
        GL      DISCMD,TIMCMD,YBCMD,OBCMD,EOTCMD,ERRCMD
        GL      STACMD,ACKCMD
        GL      CMDCNT
        GL      IZDEV,PTPON2




 
        SEG     1
        MO      .,CMDLST
        SEG     0
        
        :       COMMAND CODE VALUES
DISCMD  EQ      -1              : DISCONNECT
TIMCMD  EQ      -2              : RECORD TIME
                                : (LOCATION GIVEN IN SECOND HALFWORD)
YBCMD   EQ      -3              : YELLOW BALL
                                : (SECOND HALFWORD TO BE RETURNED IN O.B.)
OBCMD   EQ      -4              : ORANGE BALL - ANSWER TO Y.B.
                                : (SECOND HALFWORD COPIED FROM Y.B.)
EOTCMD  EQ      -5              : EOT
ERRCMD  EQ      -6              : ERROR
                                : (SECOND HALFWORD CONTAINS TYPE AND 
                                : CAUSE OF ERROR )
STACMD  EQ      -7              : STATUS CMD
                                : (SECOND HALFWORD CONTAINS VALUE )
ACKCMD  EQ      -8              : ACKNOWLEDGEMENT CMD
        :       THE ZERO CMD CODE IS RESERVED TO INDICATE AN EMPTY LIST
 
        :       A CMD CODE GTEATER THAN ZERO INDICATES A DATA MSG
        :       (FIRST HALFWORD IS THE BYTE COUNT)
        :       (SECOND HALFWORD IS THE POINTER TO THE DATA)
 
        :       STORAGE AND CONSTANTS
CMDSZ   EQ      4       : EACH LINK IS 3 HALFWORDS
CLPTR   EQ      (CMDSZ-1)*2     : OFFSET OF CMD LIST LINK PTR
CMDCNT  HS      1               : CNT OF FREE CMD LIST LINKS
        SEG     A.RING
CMDLK   HS      CMDSZ*NCMDLK            : COMMAND LINK SPACE
        SEG     0
 
        :       FREE LIST 1
CLLK1   HS      1       : LOCK FOR FREE LIST 1
CFLP1   HS      1       : PTR TO FIRST ENTRY
OFF1    EQ      0       : OFFSET OF LINKING PTR FOR LIST 1
 
        :       FREE LIST 2
CLLK2   HS      1       : LOCK
CFLP2   HS      1       : PTR TO FIRST ENTRY
OFF2    EQ      2       : OFFSET OF LINKING PTR
 
        SEG     1
        :       GCL - GET A COMMAND LINK FROM FREE POOL
        :
        :       REGISTERS       R4 - LINK
        :                       R6 - PTR TO ALLOCATED LINK
        :                            (RELATIVE TO CMDLK)
        :                       R7 - WORK





GCL     LR      R2,R2   : TRAP TO CHECK BBUFER POINTER
        JLE     GCL01
        LR      R3,R3           : CRAH IF BUFER POINTER MISSING
        JGFS    GCL01
        JAL     R10,CRASH,,
GCL01   LCS     R7,1    : DECREMENT FREE LINK CNT
        AHM     R7,CMDCNT
        JLE     GCL12           :   LIST EMPTY - EXIT
        LIS     R7,0
        SBT     R7,CLLK1        : LIST 1 LOCKED ?
        JE      GCL1            :  N -
        SBT     R7,CLLK2                : LIST 2 LOCKED ?
        JE      GCL2            :  N -
        SBT     R7,CLLK1                : TEST LOCK 1 AGAIN
        JEFS    GCL1
        JAL     R10,CRASH,,
        :       GET LINK FROM LIST 1
GCL1    LHL     R6,CFLP1                : GET FREE LIST PTR 1
        LHL     R7,CMDLK+OFF1,R6,       : R7 = PTR TO SECOND LIST ENTRY
        STH     R7,CFLP1                : UPDATE FREE LIST 1 PTR
        LIS     R7,0
        RBT     R7,CLLK1                : RESET LOCK
        J       6,R4                    : SKIP RETURN
        :       LIST WAS EMPTY . RELEASE LOCK AND DO STRAIGHT RETURN
GCL12   LIS     R7,1            : RESTORE FREE LIST CNT
        AHM     R7,CMDCNT               
        JR      R4
 
        :       GET LINK FROM FREE LIST 2
GCL2    LHL     R6,CFLP2                : R6 = PTR TO FIRST ENTRY
        LHL     R7,CMDLK+OFF2,R6,       : R7 = PTR TO SECOND LIST ENTRY
        STH     R7,CFLP2                : UPDATE FREE LIST PTR 2
        LIS     R7,0
        RBT     R7,CLLK2                : RELEASE LOCK
        J       6,R4                    : SKIP RETURN
        :       FREE LIST IS EMPTY - UNLOCK LIST AND RETURN
GCL22   LIS     R7,0
        RBT     R7,CLLK2
        LR      R7,R7                   : SET CONDITION CODE TO ZERO
        JR      R4

        :       PCL - RETURN A CMD LINK TO FREE POOL
        :       REGISTER USAGE LIKE GCL
PCL     LIS     R7,0
        SBT     R7,CLLK1                : TRY TO LOCK LIST 1
        JE      PCL1                    :   NOT LOCKED -
        SBT     R7,CLLK2                : LIST 2 LOCKED ?
        JE      PCL2                    :   NOT LOCKED -
        :       A RACE CONDITION COULD CAUSE US TO GET HERE
        :       TRY LIST 1 AGAIN
        :       IF STILL LOCKED - CRASH
        SBT     R7,CLLK1
        JEFS    PCL1
        JAL     R10,CRASH               : CRASH THE INTERFACE
        :       PUT LINK BACK AT LIST 1 END
PCL1    LHL     R7,CFLP1                : R7 = PTR TO FIRST ENTRY
        STH     R7,CMDLK+OFF1,R6,       : LINK FIRST ENTRY TO NEW ENTRY
        STH     R6,CMDLK+OFF2,R7,       : LINK NEW ENTRY TO FIRST ENTRY
        STH     R6,CFLP1                : MAKE NEW ENTRY THE FIRST ENTRY
        LIS     R7,1
        AHM     R7,CMDCNT               : ADD ONE TO FREE LINK CND
        LIS     R7,0
        RBT     R7,CLLK1                : RELEASE LOCK 1
        JR      R4                      : RETURN
        :       PUT LINK BACK ON LIST 2
PCL2    LHL     R7,CFLP2                : R7 = PTR TO FIRST ENTRY
        STH     R7,CMDLK+OFF2,R6,       : LINK FIRST ENTRY TO NEW ENTRY
        STH     R6,CMDLK+OFF1,R7,       : LINK NEW ENTRY TO FIRST ENTRY
        STH     R6,CFLP2                : MAKE NEW ENTRY THE FIRST ENTRY
        LIS     R7,1
        AHM     R7,CMDCNT               : ADD ONE TO FREE LINK CND
        LIS     R7,0
        RBT     R7,CLLK2                : RELEASE LOCK 2
        JR      R4                      : RETURN
 
        :       IZCFL - INITIALIZE COMMAND FREE LIST
IZCFL   LIS     R6,0
        LHI     R7,NCMDLK-2
        STH     R7,CMDCNT       : INIT. FREE LINK COUNT
        STH     R6,CLLK1                : LOCK 1 = 0
        STH     R6,CLLK2                : LOCK 2 = 0
        STH     R6,CFLP1                : FREE LIST 1 PTR = FIRST LINK
IZCFL1  LR      R7,R6
        AIS     R6,CMDSZ*2              : R6 = NEXT LINK
        STH     R6,CMDLK+OFF1,R7,       : LINK NEXT ENTRY TO CURRENT ONE
        STH     R7,CMDLK+OFF2,R6,       : LINK CURRENT TO NEXT
        CLI     R6,CMDSZ*2*(NCMDLK-1)   : LAST LINK REACHED ?
        JLBS    IZCFL1                  :   N - CONTINUE
        STH     R6,CFLP2                : FREE LIST PTR 2 = LAST LINK
        JR      R4                      : RETURN
 

        :       COMMAND LIST MACROS
        :
        :       IZCL - INITIALIZE A COMMAND LIST
        :
        :       PUTCMD - PUT A COMMAND INTO A LIST
        :
        :       RLCMD - RELEASE ALL COMMANDS IN A LIST
        :               (THIS MAKES THEM ACCESSIBLE TO PEEKS)
        :
        :       PKCMD - PEEK AT A COMMAND
        :
        :       ADVCMD - REMOVE THE FIRST COMMAND FROM THE LIST


        :       NXTCMD - GET NEXT CMD IN LIST W/O AFFECTING THE LIST
        :
        :       REGISTER USAGE
        :       
        :       R2 - COMMAND CODE
        :       R3 - SECOND HALFWORD OF THE COMMAND
        :       R4 - LINK TO GCL AND PCL
        :       R6 - PTR TO CMD LINK (PARM TO GCL / PCL )
        :       R7 - WORK REGISTER
        :       RDEV - INDEX TO CMD LIST WANTED
 
        :       PKCMD SETS CONDITION CODE TO ZERO IF CMD LIST IS EMPTY
        :       OTHERWISE THE VALUE OF R2 DETERMINES THE CONDITION CODE
        :
        :       NAMING CONVENTIONS
        :
        :       LNAME - COMMAND LIST NAME ( RCV , XMT , ERR , SAV)
        :       EACH LIST HAS A GET, NEXT, RELEASE AND PUT PTRS
        :       WHOSE NAME IS DERIVED FROM THE LIST NAME
 
IZCL    MACRO(LNAME,RLX1,RLX2)
        [
        JAL     R4,GCL01,,              : GET A FREE LINK
        JE      CLFULL,,                : CRASH IF NO LINK AVAILABLE
        STH     R6,GP`LNAME,RLX1,RLX2   : SET GET,RELEASE AND PUT PTRS
        STH     R6,NP`LNAME,RLX1,RLX2   : SET NEXT PTR
        STH     R6,RP`LNAME,RLX1,RLX2
        STH     R6,PP`LNAME,RLX1,RLX2
        LIS     R6,0
        STH     R6,CC`LNAME,RLX1,RLX1
        STH     R6,DC`LNAME,RLX1,RLX1
        RBT     RLX1,LNAME`DAT,,
        SBT     RLX1,LNAME`GAT,,
        ]
 
PUTCMD  MACRO(LNAME,RLX1,RLX2)
        [
        JAL     R4,GCL,,
        JE      CLFULL,,                : CRASH IF NO LINK AVAILABLE
        LHL     R7,PP`LNAME,RLX1,RLX2
        STH     R2,CMDLK,R7,
        STH     R3,CMDLK+2,R7,
        STH     R0,CMDLK+4,R7,
        STH     R6,CMDLK+CLPTR,R7,      : LINK NEW ENTRY
        STH     R6,PP`LNAME,RLX1,RLX2   
        LIS     R6,1                    : ADD ONE TO LINK USE CNT
        AHM     R6,CC`LNAME,RLX1,RLX1
        LR      R2,R2                   : DATA CMD ?
        JLEFS   .+8
        AHM     R2,DC`LNAME,RLX1,RLX1   :   Y - INC. DATA USE CNT
        ]
 
RLCMD   MACRO(LNAME,RLX1,RLX2)
        [
        LHL     R6,PP`LNAME,RLX1,RLX2  
        STH     R6,RP`LNAME,RLX1,RLX2   : SET RELEASE PTR = PUT PTR
        SBT     RLX1,LNAME`DAT,,
        ]
PKCMD   MACRO(LNAME,RLX1,RLX2)
        [
        LIS     R2,0
        LH      R6,GP`LNAME,RLX1,RLX2
        CLH     R6,RP`LNAME,RLX1,RLX2
        JE      .+22
        NI      R6,0FFFF
        STH     R6,NP`LNAME,RLX1,RLX2
        LHL     R3,CMDLK+2,R6,
        LHL     R0,CMDLK+4,R6,
        LH      R2,CMDLK,R6, ]
 
ADVCMD  MACRO(LNAME,RLX1,RLX2)
        [
        LH      R6,GP`LNAME,RLX1,RLX2
        CLH     R6,RP`LNAME,RLX1,RLX2   : IS LIST EMPTY ?
        JNFS    .+8
        JAL     R4,CLBUG,,              :    Y - PGM. BUG
        LCS     R7,1
        AHM     R7,CC`LNAME,RLX1,RLX1   : DEC. LINK USE CNT
        NI      R6,0FFFF
        LIS     R7,0
        SH      R7,CMDLK,R6,            : R7 = - CMD CODE
        JGEFS   .+8
        AHM     R7,DC`LNAME,RLX1,RLX1   :   DATA CMD - DEC. DATA USE CNT
        LH      R7,CMDLK+CLPTR,R6,
        STH     R7,GP`LNAME,RLX1,RLX2
        RBT     RLX1,LNAME`DAT,,
        CLH     R7,RP`LNAME,RLX1,RLX2   : COMPARE GET AND REL. PTRS.
        JEFS    .+8                     : SKIP IF EQUAL
        SBT     RLX1,LNAME`DAT,,
        JAL     R4,PCL,,        ]
 
NXTCMD  MACRO(LNAME,RLX1,RLX2)
[
        LIS     R2,0
        LH      R6,NP`LNAME,RLX1,RLX2
        CLH     R6,RP`LNAME,RLX1,RLX2
        JNFS    .+8
        JAL     R4,CLBUG,,
        NI      R6,0FFFF
        LH      R6,CMDLK+CLPTR,R6,
        CLH     R6,RP`LNAME,RLX1,RLX2
        JE      .+22
        STH     R6,NP`LNAME,RLX1,RLX2
        NI      R6,0FFFF
        LHL     R3,CMDLK+2,R6,
        LHL     R0,CMDLK+4,R6,
        LH      R2,CMDLK+0,R6,
]
        :       CLFULL - CALLED BY PUTCMD WHEN IT CANT GET A FREE CMD 
        :       LINK
CLFULL  JAL     R10,CRASH,,             : CRASH THE INTERFACE
        HC      0
        BC      4*R4,99
 
CLBUG   JAL     R10,CRASH,,             : BUG IN USE OF CMD LISTS
        HC      0
        BC      4*R4,98
        EM
        SUBTTL	RRC-BISYNC RECEIVE RETURN CODES
        RA      0
        MO      .,BSCRRC

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::               B I S Y N C   R C V   R E T U R N   C O D E S               ::
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

RCDATX  EQ      0               :GOOD DATA ETX
RCDATB  EQ      1               :GOOD DATA ETB
RCENQ   EQ      2               :ENQ
RCEOT   EQ      3               :EOT
RCNAK   EQ      4               :NAK
RCDISC  EQ      5               :DLE,EOT (DISCONNECT SIGNAL)
RCACK1  EQ      6               :ACK1
RCWACK  EQ      7               :WACK
RCACK0  EQ      8               :ACK0
RCRVI   EQ      9               :RVI
RCTTD   EQ      0A              :TTD (STX,ENQ)
RCMBID  EQ      0B              :MULTI-LEAVING BIG (SOH,ENQ)
RCDABT  EQ      0C              :DATA ABORT (ENQ,EOT,NAK IN TEXT)
RCLSYN  EQ      0D              :LOST SYNCHRONIZATION
RCOVRN  EQ      0E              :OVERRUN (MORE DATA THAN BUFFERLETS SPECIFIED)
RCNROM  EQ      0F              :NO INITIAL BUFFERLET AVAILABLE
RCTMOT  EQ      10              :TIMEOUT BEFORE MSG RECEIVED
RCBADD  EQ      11              :CRC ERROR IN DATA MESSAGE
RCLOST  EQ      12              :LOST DATA DUE TO INAVAILABILITY OF BUFFERLET
RCUNID  EQ      13              :UNIDENTIFIABLE MSG
RCFCOM  EQ      14              :FORCED COMPLETION BY BACKGROUND

        EM

        SUBTTL  EXC-BISYNC EXECUTIVE PROCESSING
        RA      0
        MO      .,BSCEXC
        GL      RDEV
        GL      BSCEXC,BSCEXI

:       DEDICATED REGISTERS
RL      EQ      R8              :CURRENT LINE BEING PROCESSED
RL2     EQ      R9 
 
:       SEMI-DEDICATED REGISTERS
RDEV    EQ      R11     : CURRENT DEVICE NO. REGISTER

RSEG    EQ      SEG1            :BASE ADDRESS FOR RELATIVE BRANCHING


:       RUN LISTS
        SEG     0
RRUNL   WS      0
        RE      NBILIN
        WC      RRUNOF
        ER

XRUNL   WS      0
        RE      NBILIN
        WC      XRUNOF
        ER

PRUNL   WS      0
        RE      NBILIN
        WC      PRUNOF
        ER

FBIRET  WS      1               :RETURN ADDR
        SEG     1

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:: B I S Y N C   F O R E G R O U N D   E X E C U T I O N   S C H E D U L E R ::
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:       INITIALIZATION
:       --------------

BSCEXI  LR      R2,R1           :MAKE WORD INDEX FOR LINE
        SLHLS   R2,2
        LA      R0,RRUNOF       :RESET RCV RUN LIST
        ST      R0,RRUNL,R2
        LA      R0,XRUNOF       :RESET XMT RUN LIST
        ST      R0,XRUNL,R2
        LA      R0,PRUNOF       :RESET PROTOCOL RUN LIST
        ST      R0,PRUNL,R2
        JR      R5              :RETURN


:       FOREGROUND EXEC LOOP CALL ENTRY
:       -------------------------------

BSCEXC  ST      R10,FBIRET      :SAVE RETURN ADDR

:       RECEIVE RUN LIST
:       ----------------

        IF      NBILIN-8
        LHI     RL2,(NBILIN-1)*2        :INIT 2 * LINE INDEX
        ELSE
        LIS     RL2,(NBILIN-1)*2        :INIT 2 * LINE INDEX
        EI

        IF      NBILIN-10
        LHI     RL,(NBILIN-1)           :INIT LINE INDEX
        ELSE
        LIS     RL,(NBILIN-1)           :INIT LINE INDEX
        EI

RRUN10  EQ      .
        L       R5,RRUNL,RL2,RL2        :GET ADDR TO RUN
        JR      R5                      :GO RUN

RHALT   LA      R5,RRUNOF               :TAKE LINE OFF RUN LIST
RDMISS  ST      R5,RRUNL,RL2,RL2        :DISMISS USER FOR THIS RUN CYCLE

RRUNOF  EQ      .
        IF      NBILIN-1
        SIS     RL,1                    :GO TO NEXT LINE
        SIS     RL2,2
        JGEBS   RRUN10
        EI


:       TRANSMIT RUN LIST
:       -----------------

        IF      NBILIN-8
        LHI     RL2,(NBILIN-1)*2        :INIT 2 * LINE INDEX
        ELSE
        LIS     RL2,(NBILIN-1)*2        :INIT 2 * LINE INDEX
        EI

        IF      NBILIN-10
        LHI     RL,(NBILIN-1)           :INIT LINE INDEX
        ELSE
        LIS     RL,(NBILIN-1)           :INIT LINE INDEX
        EI

XRUN10  EQ      .
        L       R5,XRUNL,RL2,RL2        :GET ADDR TO RUN
        JR      R5                      :GO RUN

XHALT   LA      R5,XRUNOF               :TAKE LINE OFF RUN LIST
XDMISS  ST      R5,XRUNL,RL2,RL2        :DISMISS USER FOR THIS RUN CYCLE

XRUNOF  EQ      .
        IF      NBILIN-1
        SIS     RL,1                    :GO TO NEXT LINE
        SIS     RL2,2
        JGEBS   XRUN10
        EI


:       PROTOCOL RUN LIST
:       -----------------

        IF      NBILIN-8
        LHI     RL2,(NBILIN-1)*2        :INIT 2 * LINE INDEX
        ELSE
        LIS     RL2,(NBILIN-1)*2        :INIT 2 * LINE INDEX
        EI

        IF      NBILIN-10
        LHI     RL,(NBILIN-1)           :INIT LINE INDEX
        ELSE
        LIS     RL,(NBILIN-1)           :INIT LINE INDEX
        EI

PRUN10  EQ      .
        L       R5,PRUNL,RL2,RL2        :GET ADDR TO RUN
        JR      R5                      :GO RUN

PHALT   LA      R5,PRUNOF               :TAKE LINE OFF RUN LIST
PDMISS  ST      R5,PRUNL,RL2,RL2        :DISMISS USER FOR THIS RUN CYCLE

PRUNOF  EQ      .
        IF      NBILIN-1
        SIS     RL,1                    :GO TO NEXT LINE
        SIS     RL2,2
        JGEBS   PRUN10
        EI

        L       R10,FBIRET      :RETURN TO FOREGROUND EXEC LOOP
        JR      R10

        EM

        SUBTTL	CRC-CRC COMPUTATION
        RA      0
        MO      .,BSCCRC
        GL      CRC16L

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::                     C R C 1 6   C O M P U T A T I O N                     ::
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:       COMPUTES CRC FOR EBCDIC TERMINALS.  GIVEN A PARTIAL CRC A/B
:AND A NEW CHARACTER C, THE NEW CRC IS GIVEN BY:

:       NC = CRCTBL(A) .XOR. B/C

:       AFTER ALL CHARACTERS IN BLOCK HAVE BEEN CHECKSUMMED, THE CRC IS
:COMPUTED *TWICE* MORE WITH A 00 CHARACTER CODE.


CRCACC  MACRO(RCRC,RC,RWK)
        [EXBR   RCRC,RCRC               :B/A
        LBR     RWK,RCRC
        STBR    RC,RCRC         :B/C
        XH      RCRC,CRC16L,RWK,RWK :XOR CRCTBL(A)]


CRCINT  MACRO(RCRC)
        [LIS    RCRC,0]


CRCEND  MACRO(RCRC,RWK1,RWK2)
        [LIS    RWK1,0          :PUT ZERO THROUGH COMPUTATION TWICE
        EXBR    RCRC,RCRC
        LBR     RWK2,RCRC
        STBR    RWK1,RCRC
        XH      RCRC,CRC16L,RWK2,RWK2
        EXBR    RCRC,RCRC
        LBR     RWK2,RCRC
        STBR    RWK1,RCRC
        XH      RCRC,CRC16L,RWK2,RWK2]


:       CRC16 TABLE FOR MSB RECEPTION
:       -----------------------------

        SEG     1
	HS	0	:ALIGN TO HALF-WORD
CRC16L	XC	00008005800F000A801B001E00148011
	XC	80330036003C80390028802D80270022
	XC	80630066006C80690078807D80770072
	XC	00508055805F005A804B004E00448041
	XC	80C300C600CC80C900D880DD80D700D2
	XC	00F080F580FF00FA80EB00EE00E480E1
	XC	00A080A580AF00AA80BB00BE00B480B1
	XC	80930096009C80990088808D80870082
	XC	81830186018C81890198819D81970192
	XC	01B081B581BF01BA81AB01AE01A481A1
	XC	01E081E581EF01EA81FB01FE01F481F1
	XC	81D301D601DC81D901C881CD81C701C2
	XC	01408145814F014A815B015E01548151
	XC	81730176017C81790168816D81670162
	XC	81230126012C81290138813D81370132
	XC	01108115811F011A810B010E01048101
	XC	83030306030C83090318831D83170312
	XC	03308335833F033A832B032E03248321
	XC	03608365836F036A837B037E03748371
	XC	83530356035C83590348834D83470342
	XC	03C083C583CF03CA83DB03DE03D483D1
	XC	83F303F603FC83F903E883ED83E703E2
	XC	83A303A603AC83A903B883BD83B703B2
	XC	03908395839F039A838B038E03848381
	XC	02808285828F028A829B029E02948291
	XC	82B302B602BC82B902A882AD82A702A2
	XC	82E302E602EC82E902F882FD82F702F2
	XC	02D082D582DF02DA82CB02CE02C482C1
	XC	82430246024C82490258825D82570252
	XC	02708275827F027A826B026E02648261
	XC	02208225822F022A823B023E02348231
	XC	82130216021C82190208820D82070202

        EM

        SUBTTL  RCV - RECEIVES DATA FROM BISYNC LINE
        RA      0
        MO      .,BSCRCV
        GL      RCVREV,REVTAB
        GL      BSCFRC          :FORCE RCV OP COMPLETE BIT ARRAY
        GL      PBBC,GBB,BBUFER
        GL      NGRMX,GTAB,RGRP
        GL      BSCEFR          :ENABLE FORCED OP COMPLETE
        GL      RRINGX,RRGETX
        LO      BSCCHR          :BISYNC CONTROL CHAR DEFINITIONS
        LO      BSCEXC          :ACCESS BISYNC FOREGROUND EXECUTION RUN LISTS
        LO      BSCRRC          :ACCESS BISYNC RCV OP RETURN CODES

:       DEDICATED REGISTERS
REX     EQ      R14             :LINE INPUT RING EMPTY INDEX
RAD     EQ      R15             :ADDR(LINE INPUT RING)
RLP     EQ      R13             :LEAD POINTER FOR SCAN
RBBX    EQ      R13             :BIG BUFFERLET INDEX(CHAR LAST STORED)
RBBA    EQ      R12             :ADDR(CURRENT BIG BUFFERLET)
RST     EQ      R11             :ADDR(CURRENT STATE TABLE)
RRET    EQ      R10             :STATE PROCESS LINK REG
RCRC    EQ      R2              :CRC ACCUMULATOR
RC      EQ      R1              :RCV CHARACTER REG
RCB     EQ      R0              :RCV CHAR REG BACKUP (LBR RC,RCB RESTORES RC)


:       CONFIGURATION PARAMETERS
MNSPED  EQ      $A 1200         :MINIMUM SPEED SYNC LINE SUPPORTED (BPS)
STOBCC  EQ      1               :STORE BCC IN BUFFERLET WITH DATA IF 1
MSIZE   EQ      08              :AMOUNT TO LIE TO SCAN ABOUT


        SEG     1

:       SINGLE CHARACTER CONTROL MSG RETURN CODE TABLE

RC1CTL  BC      RCUNID          :ELSE  - CANNOT OCCUR
        BC      RCUNID          :SOH   - CANNOT OCCUR
        BC      RCUNID          :STX   - CANNOT OCCUR
        BC      RCUNID          :ETX   - CANNOT OCCUR
        BC      RCUNID          :DLE   - CANNOT OCCUR
        BC      RCUNID          :ITB   - CANNOT OCCUR
        BC      RCUNID          :ETB   - CANNOT OCCUR
        BC      RCENQ           :ENQ
        BC      RCUNID          :SYN   - CANNOT OCCUR
        BC      RCEOT           :EOT
        BC      RCNAK           :NAK
        BC      RCUNID          :ACK1  - CANNOT OCCUR
        BC      RCUNID          :WACK  - CANNOT OCCUR
        BC      RCUNID          :ACK0  - CANNOT OCCUR
        BC      RCUNID          :RVI   - CANNOT OCCUR

:       CHARACTER PAIR CONTROL MESSAGE RETURN CODE TABLE

RC2CTL  BC      RCUNID          :ELSE  - CANNOT OCCUR
        BC      RCUNID          :SOH   - CANNOT OCCUR
        BC      RCUNID          :STX   - CANNOT OCCUR
        BC      RCUNID          :ETX   - CANNOT OCCUR
        BC      RCUNID          :DLE   - CANNOT OCCUR
        BC      RCUNID          :ITB   - CANNOT OCCUR
        BC      RCUNID          :ETB   - CANNOT OCCUR
        BC      RCUNID          :ENQ   - CANNOT OCCUR
        BC      RCUNID          :SYN   - CANNOT OCCUR
        BC      RCDISC          :DISC SIGNAL (DLE,EOT)
        BC      RCUNID          :NAK   - CANNOT OCCUR
        BC      RCACK1          :ACK1
        BC      RCWACK          :WACK
        BC      RCACK0          :ACK0
        BC      RCRVI           :RVI


:       VARIABLES FOR SYNCHRONIZATIONS AND STATE PROCESSOR
:       --------------------------------------------------

        SEG     0
RTIME   WS      NBILIN          :TIME TO FORCE RCV OP COMPLETE (FASTC)

RRETAD  HS      NBILIN          :OP COMPLETE RETURN ADDRESS REL TO RSEG
RSTATE  HS      NBILIN          :ADDR CURRENT STATE TABLE (REL TO RSEG)
RBBADR  HS      NBILIN          :ADDR CURRENT BIG BUFFERLET (REL TO BBUFER)
RBBINX  HS      NBILIN          :INDEX OF LAST CHAR STORED INTO BIG BUFFERLET
RSTPTM  HS      NBILIN          :TIME OF STATE PROCESSOR LAST DISMISS (FASTC+2)
RORUNC  HS      NBILIN          :MAX NUMBER OF BUFFERLETS BEFORE OVERRUN
ROBCNT  HS      NBILIN          : PARTIAL RCV BYTE CNT (ADD (RBBX)
                                : TO GIVE TOTAL BYTE CNT )
RLSYNC  HS      NBILIN          :ADDR LOST SYNC PROCESS (REL TO RSEG)
RBBCHN  HS      NBILIN          :ADDR 1ST BUFFERLET IN DATA MSG CHAIN
RRGETX  HS      NBILIN          :RCV RING EMPTY INDEX
RACCRC  HS      NBILIN          :CRC ACCUMULATOR

BSCFRC  HS      (NBILIN-1)/10+1 :FORCE RCV OP COMPLETE BIT ARRAY
BSCEFR  HS      (NBILIN-1)/10+1 :ENABLE FORCE RCV OP COMPLETE BIT ARRAY
RLOSTD  HS      (NBILIN-1)/10+1 :LOST DATA BIT ARRAY
RCRCER  HS      (NBILIN-1)/10+1 :CRC ERROR BIT ARRAY



RMTYPE  BS      NBILIN          :MESSAGE TYPE (TYPICALLY CONTROL CHAR VALUE)
RBYTEL  BS      NBILIN          :LAST BYTE OF RCV RING DATA
RSHIFT  BS      NBILIN          :SHIFT CNT TO FRAME CHARACTER
        SEG     1



:       CHARACTER IDENTIFICATION TABLE
:       _____________________________

DEFIDC  MACRO(CHAR)[NOLIST
Q       EQ      0
        IF CHAR&80     ;Q EQ Q+01;      EI
        IF CHAR&40     ;Q EQ Q+02;      EI
        IF CHAR&20     ;Q EQ Q+04;      EI
        IF CHAR&10     ;Q EQ Q+08;      EI
        IF CHAR&08     ;Q EQ Q+10;      EI
        IF CHAR&04     ;Q EQ Q+20;      EI
        IF CHAR&02     ;Q EQ Q+40;      EI
        IF CHAR&01     ;Q EQ Q+80;      EI
QQ      EQ      .
        ORG     BIDCHR+Q
BIDCHX  EQ      BIDCHX+2
        LIST
        BC      BIDCHX
        ORG     QQ]

BIDCHR  BS      0               :IDENTIFICATION TABLE INITIALIZATION
        RE      100;    NOLIST
        BC      0;      ER;     LIST
BIDCHX  EQ      0               :INIT ID INDEX


:       DEFINE CONTROL CHAR'S OF INTEREST IN 'BIDCHR' TABLE
:       ---------------------------------------------------

        DEFIDC(SOH)
        DEFIDC(STX)
        DEFIDC(ETX)
        DEFIDC(DLE)
        DEFIDC(ITB)
        DEFIDC(ETB)
        DEFIDC(ENQ)
        DEFIDC(SYN)
        DEFIDC(EOT)
        DEFIDC(NAK)
        DEFIDC(ACK1)
        DEFIDC(WACK)
        DEFIDC(ACK0)
        DEFIDC(RVI)




:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::                      R I N G   D E F I N I T I O N S                      ::
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

RRSIZE  EQ      100             :DATA BYTES IN ISIS SYNC INPUT RING

        SEG     A.RING          :DEFINE RING FOR EACH LINE
RRING   HS      (1+RRSIZE/2)*NBILIN
SECT    HS      (RRSIZE/2)*NBILIN

        SEG     1
RRINGX  WS      0               :ADDRESS TABLE OF START OF EACH RING
Q       EQ      0
        RE      NBILIN
        WC      RRING+Q*(2+RRSIZE)
Q       EQ      Q+1
        ER


Q       EQ      0
ISECT   WS      0               :ADDRESS OF INPUT BUFFER
        RE      NBILIN
        WC      SECT+Q*(RRSIZE)
Q       EQ      Q+1
        ER
:       RING INDEX ADVANCEMENT MACRO
RRADVC  MACRO(REG)[
        AIS     REG,2
        LBR     REG,REG]

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::                   R C V   S Y N C H R O N I Z A T I O N                   ::
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:       INITIALIZE
RSTART  LIS     R3,0            :INIT NO BUFFERLET CHAIN
        STH     R3,RBBCHN,RL2
        LHI     R3,RSYN15-RSEG  :INIT LOST SYNCHRONIZATION PROCESS
        STH     R3,RLSYNC,RL2

:       LOST SYNCHRONIZATION WHILE LOOKING FOR SYNC.  SET LAST BYTE
:       TO MARKS AND CONTINUE
RSYN05  JFS     RSYN15

:       RING EMPTY, BEFORE DISMISSING, CHECK IF BACKGROUND WANTS PROTOCOL
:       DRIVER ACTIVATED.  IF SO AND PROTOCOL DRIVER HAS NOT LOCKED OUT
:       SUCH ACTIVATION, GO TAKE OP COMPLETE.
RSYN10  TBT     RL,BSCFRC       :FORCE RCV OP COMPLETE ?
        JEFS    RSYN12          :JUMP IF NOT
        TBT     RL,BSCEFR       :FORCE ENABLED ?
        JN      RPFCOM          :JUMP IF SO, GO ACTIVATE
RSYN12  STH     REX,RRGETX,RL2  :SAVE EMPTY INDEX
        JAL     R5,RDMISS       :DISMISS

:       CHECK FOR RECEIVE TIME-OUT
RSYN15  L       R0,RTIME,RL2,RL2        :GET TIMEOUT FASTC VALUE
        JEFS    RSYN20          :JUMP NOT TIMING
        S       R0,FASTC,,      :TIME UP ?
        JLE     RPTMOT          :JUMP IF SO

:       INITIALIZE REG'S FOR RING FETCHS
RSYN20  L       RAD,RRINGX,RL2,RL2      :LOCATION OF RING
        LHL     REX,RRGETX,RL2          :EMPTY POINTER
        LHL     RLP,0,RAD               :LEAD POINTER
:
:ADD MSIZE TO THE LP SO THAT SCAN WILL ONLY TRAIL BY
:       16-MSIZE   BYTES
:
        AIS     RLP,MSIZE               :LIE TO SCAN
        LBR     RLP,RLP         :WRAP
:
        AIS     RAD,2           :POINT AT ACTUAL RING
:
:USE SCAN TO FIND A 0 BIT IN THE RING
:
RSYN25  SCAN    RLP,RAD
        JFS     RSYN30          :FOUND A 0
:
        J       RSYN10          :NOTHING FOUND
:
RSYN30  LHL     R3,0,RAD,REX    :GET FIRST HW
        JNFS    RSYN40          :IT IS NOT ALL ZEROES
:
RSYN35  RRADVC(REX)
        JBS     RSYN25          :JUST SKIP THIS HW
:
:COMPUTE THE ALIGNMENT FACTOR
:
RSYN40  STH     REX,RRGETX,RL2  :SAVE POSTION (IN CASE WE ARE WRONG)
        LCS     R6,1            :INVERT THE DATA
        XR      R6,R3
:
        JFFOH   R6,RSYN50       :FIND A 1 (0)
        JBS     RSYN35          :THIS SHOULD NOT HAPPEN
:
:NOW SET UP TO DO AN ALIGN TO GET THE DATA THAT FOLLOWS
:
RSYN50  LIS     R10,0F          :INVERT SHIFT COUNT
        XR      R10,R7
        LR      R6,RL           :SAVE RL
        L       R8,ISECT,RL2,RL2 :ADDRESS OF INPUT SECTOR
:
        LIS     R1,($A16-MSIZE)/2
        RRADVC(REX)
        ALIGN   RAD,REX         :MOVE THE DATA
        L       R8,ISECT,RL2,RL2
        LHL     R0,0,R8         :DID WE GET A SYN
        LR      RL,R6           :RESTORE RL
        CHI     R0,RSYN*100+RSYN
        JEFS    INSYN
:
        XHI     R10,0F          :RESTORE INDEX
        LHL     REX,RRGETX,RL2  :BACK UP RING
        SBT     R10,0,RAD,REX   :RESET THIS BIT
        J       RSYN25          :TRY AGAIN
:
:NOW IN SYNC.  GET READY TO PROCESS THE BALENCE OF THE RECORD
:
INSYN   STB     R10,RSHIFT,RL           :SAVE THE SHIFT
        LHL     R3,RGRP,RL2             :GET GRAPHIC OFFSET
        LIS     R4,0
        STH     R4,GTAB,R3              :SET COUNT TO ZERO
        LHI     RST,RSIDMS-RSEG         :INIT STATE TO IDENTIFY MSG

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::                   R C V   S T A T E   P R O C E S S O R                   ::
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

        STH     REX,RRGETX,RL2          :SAVE RING INDEX
        LIS     RAD,($A16-MSIZE)
        LCS     REX,($A16-MSIZE)
RSTP05  A       RAD,ISECT,RL2,RL2
:
RSTP10  LB      RC,0,RAD,REX            :GET A BYTE
        LB      R3,BIDCHR,RC            :GET AN INDEX
        LHL     R3,RSEG,R3,RST          :GET THE ROUTINE

        IF      RCVTSW&0F000
        JAL     R4,RCVTRC
        EI

        JAL     RRET,RSEG,R3            :DOIT
:
        AIS     REX,1                   :DO SOME MORE
        JLBS    RSTP10
:
:TIME TO DISMIS
:
        STH     RST,RSTATE,RL2          :SAVE THE STATE
        STH     RBBA,RBBADR,RL2         :BIG BUFFER ADDR
        STH     RBBX,RBBINX,RL2         :STATE
        STH     RCRC,RACCRC,RL2         :CRC
        LHL     R3,FASTC+2,,            :SAVE TIME OF DISMIS
        STH     R3,RSTPTM,RL2
RSTP20  JAL     R5,RDMISS
:
:WAKE UP AND GET MORE RING DATA
:
        LHL     REX,RRGETX,RL2          :EMPTY PNTR
        SIS     REX,2                   :BACK UP BY 1 HW
        LBR     REX,REX
        L       RAD,RRINGX,RL2,RL2      :RING
        LHL     R1,0,RAD                :FILL PNTR
:
:IF WE WAKE UP WITH NO DATA THEN THERE IS TROUBLE
:
        SR      R1,REX
        JNFS    RSTP30
:
        LHL     R3,RSTPTM,RL2           :GET DISMISS TIME
        AIS     R3,(($A16*RATE/MNSPED)+1) :MINIMUM TICKS TO GET 16 BITS
        SH      R3,FASTC+2,,
        CHVR    R3,R3
        JG      RSTP20                  :NOT ENOUGH TIME
        LHL     R3,RLSYNC,RL2           :GOTO LOST SYN ROUTINE
        J       RSEG,R3
:
:CRANK THROUGH THE DATA RECEIVED SO FAT.
:
RSTP30  LBR     R1,R1                   :ACCOUNT FOR WRAP
        STB     R1,RBYTEL,RL            :AND STORE BC
        SRLS    R1,1                    :MAKE HW CNT
:
        LHL     R3,2,REX,RAD            :GET FIRST HW
        RRADVC(REX)
        LR      R6,RL                   :SAVE RL
        LB      R10,RSHIFT,RL           :GET THE SHIFT
        L       R8,ISECT,RL2,RL2
        AIS     RAD,2                   :POINT TO THE RING
        ALIGN   RAD,REX                 :MOVE IT
:
:RESTORE REGS FOR PROCESSING

        LR      RL,R6
        STH     REX,RRGETX,RL2
        LB      RAD,RBYTEL,RL
        LIS     REX,0
        SR      REX,RAD
        LHL     RBBA,RBBADR,RL2         :BUFFER
        LH      RBBX,RBBINX,RL2         :BUFFER INDEX
        LHL     RST,RSTATE,RL2          :STATE
        LHL     RCRC,RACCRC,RL2         :CRC ACCUMULATOR
        J       RSTP05
                IF RCVTSW&0F000
                :-:-:-:-:-:-:-:-:-:-:-:-:-:  TRACE  :-:-:-:-:-:-:-:-:-:-:-:-::
RCVTRC          :TRACE OPTIONS RCVT01,RCVT02,RCVT03,RCVT04,RCVT05            :
                TBT     RL,RCVBIT       :DO WE WANT TO TRACE THIS LINE?
                JER     R4              :NO - RETURN
                LHL     R5,RCVTRX       ;Q EQ 0 :SET TRACE INDEX             :
                IF      RCVTSW&RCVT01   : RCV CHAR TRACE
                LB      R6,REVTAB,RC
                STH     R6,RCVTTB,R5,
Q                       EQ      Q+2
                EI
                                                                             :
                IF      RCVTSW&RCVT02   :RING EMPTY INDEX TRACE              :
                STH     REX,RCVTTB+Q,R5,        ;Q EQ Q+2                    :
                EI                                                           :
                                                                             :
                IF      RCVTSW&RCVT03   :PROCESS TRACE                       :
                STH     R3,RCVTTB+Q,R5, ;Q EQ Q+2                            :
                EI                                                           :
                                                                             :
                IF      RCVTSW&RCVT04   :STATE TRACE                         :
                STH     RST,RCVTTB+Q,R5,        ;Q EQ Q+2                    :
                EI                                                           :
                                                                             :
                IF      RCVTSW&RCVT05   :TIME TRACE                          :
                LHL     R6,FASTC+2,,                                         :
                STH     R6,RCVTTB+Q,R5, ;Q EQ Q+2                            :
                EI                                                           :
                                                                             :
                AIS     R5,Q            :ADVANCE INDEX                       :
                CLHI    R5,(RCVTSW&0F000)^(-2)                                 :
                JLFS    .+4                                                  :
                LIS     R5,0                                                 :
                STH     R5,RCVTRX       :SAVE INDEX                          :
                JR      R4                                                   :
                                                                             :
                SEG     0                                                    :
RCVBIT  WC      0                                                       :
RCVTRX  HC      0                                                       :
                SEG     A.RING  ;RCVTTB HS 0                                 :
                RE RCVTSW^(-0C);        BS 400;         ER;     BS 10        :
                SEG     1                                                    :
                :-:-:-:-:-:-:-:-:-:-:-:-:-:  TRACE  :-:-:-:-:-:-:-:-:-:-:-:-::
                EI

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::                       S U B R O U T I N E   R W C I                       ::
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

RWCI    MACRO(RC)
        [
        IF      RCVREV
        LBR     R3,RC
        LB      R3,REVTAB,R3
        NI      RC,0FFFFFF00
        OR      RC,R3
        EI
        AIS     RBBX,1          : ADVANCE POINTER
        STB     RC,BBUFER+BBFLSZ-2,RBBX,RBBA    :PUT DATA
        JNFS    .+6
        JAL     R5,RWCIB        :IF NEEDED, GET NEW BUFFERLET & STORE DATA
        ]


:       NEED NEW BIG BUFFERLET.  IF THIS BUFFERLET FETCH EXCEEDS
:       OVERRUN CNT, END RECEIVE AS OVERRUN.  IF BUFFERLET IS NOT
:       AVAILABLE, FLAG 'LOST DATA' AND REUSE CURRENT BUFFERLET.

RWCIB   LCS     RBBX,1          :COUNT BUFFERLET USAGE
        AHM     RBBX,RORUNC,RL2
        JGEFS   RWCIB1          :JUMP HAVN'T USED QUOTA, OK
        LIS     RBBX,0          :ZERO CHAIN OVERWRITTEN BY LAST BYTE PUT
        STH     RBBX,BBUFER+BBFLSZ-2,RBBA,
        J       RPOVRN          :ABORT WITH OVERRUN

RWCIB1  JAL     R4,GBB          :GET A BIG BUFFERLET
        J       RWCIB4          :JUMP NONE AVAILABLE
        STH     R3,BBUFER+BBFLSZ-2,RBBA,        :CHAIN THIS BUFFERLET TO LAST
        LHI     R4,BBFLSZ-2
        AHM     R4,ROBCNT,RL2   : UPDATE PARTIAL BYTE CNT
        LR      RBBA,R3         :SET BUFFERLET BASE ADDR REG
RWCIB2  LHI     RBBX,-BBFLSZ+2  :INIT BUFFERLET INDEX
        STB     RC,BBUFER+BBFLSZ-2,RBBX,RBBA    :PUT CHARACTER
        JR      R5              :RETURN

RWCIB4  SBT     RL,RLOSTD       :FLAG LOSS OF DATA
        LIS     R3,0            :ZERO CHAIN THAT WAS OVER-WRITTEN
        STH     R3,BBUFER+BBFLSZ-2,RBBA,
        JBS     RWCIB2

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::                            R C V   S T A T E S                            ::
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:       IDENTIFY MSG : RSIDMS
:       ---------------------
:       CHARACTER SYNCHRONIZATION HAS BEEN ESTABLISHED ON INCOMMING BIT
:       STREAM.  NEXT CHAR OR CHAR PAIR (EXCLUDING SYNC CHAR'S) WILL
:       IDENTIFY MSG TYPE.

RSIDMS  HC      RGRAPH-RSEG     :ELSE  -LEADING GRAPHICS
        HC      RPCNDT-RSEG     :SOH   -START OF NON-TRANSPARENT DATA
        HC      RPCNDT-RSEG     :STX   -START OF NON-TRANSPARENT DATA
        HC      RPUNID-RSEG     :ETX   -UNKNOWN START OF MSG
        HC      RPCDLE-RSEG     :DLE   -CHAR PAIR MSG, NEXT CHAR WILL ID'FY
        HC      RPUNID-RSEG     :ITB   -UNKNOWN START OF MSG
        HC      RPUNID-RSEG     :ETB   -UNKNOWN START OF MSG
        HC      RPCPCK-RSEG     :ENQ   -1 CHAR MSG, CHECK FOR PAD
        HC      RPCEAT-RSEG     :SYN   -EAT LEADING SYN'S
        HC      RPCPCK-RSEG     :EOT   -1 CHAR MSG, CHECK FOR PAD
        HC      RPCPCK-RSEG     :NAK   -1 CHAR MSG, CHECK FOR PAD
        HC      RGRAPH-RSEG     :ACK1  -NOT PRECEDED BY DLE LEADING GRAPHIC
        HC      RGRAPH-RSEG     :WACK  -NOT PREC. BY DLE..LEADING GRAPHIC
        HC      RGRAPH-RSEG     :ACK0  -NOT PREC. BY DLE..LEADING GRAPHIC
        HC      RGRAPH-RSEG     :RVI   -NOT PREC. BY DLE..LEADING GRAPHIC


:       CHAR PAIR BISYNC MSG : RS2CHR
:       -----------------------------
:       A DLE WAS RCV'D IN ID'FY STATE, NEXT CHAR ID'S MSG TYPE

RS2CHR  HC      RPUNID-RSEG     :ELSE  -UNKNOWN CHAR PAIR MSG
        HC      RPUNID-RSEG     :SOH   -UNKNOWN CHAR PAIR MSG
        HC      RPCTDT-RSEG     :STX   -START OF TRANSPARENT DATA
        HC      RPUNID-RSEG     :ETX   -UNKNOWN CHAR PAIR MSG
        HC      RPUNID-RSEG     :DLE   -UNKNOWN CHAR PAIR MSG
        HC      RPUNID-RSEG     :ITB   -UNKNOWN CHAR PAIR MSG
        HC      RPUNID-RSEG     :ETB   -UNKNOWN CHAR PAIR MSG
        HC      RPUNID-RSEG     :ENQ   -UNKNOWN CHAR PAIR MSG
        HC      RPUNID-RSEG     :SYN   -UNKNOWN CHAR PAIR MSG
        HC      RPC2CH-RSEG     :EOT   -CONTROL MSG, PROCESS (DEL,EOT)
        HC      RPUNID-RSEG     :NAK   -UNKNOWN CHAR PAIR MSG
        HC      RPC2CH-RSEG     :ACK1  -CONTROL MSG, PROCESS
        HC      RPC2CH-RSEG     :WACK  -CONTROL MSG, PROCESS
        HC      RPC2CH-RSEG     :ACK0  -CONTROL MSG, PROCESS
        HC      RPC2CH-RSEG     :RVI   -CONTROL MSG, PROCESS


:       CHECK NEXT CHAR FOR MARKS IN 4 LSB'S : RSPCK2
:       ---------------------------------------------
:       TO GUARANTEE THE INTEGRITY OF A SINGLE CHAR BISYNC CONTROL MSG,
:       IT MUST BE FOLLOWED BY 4 MARKS (NEXT CHAR MUST HAVE 1'S IN LEAST
:       SIGNIFICANT BITS).
:       BUT IS REQUIRED TO KEEP PROCESSING TIME PER CHAR AT A MINIMUM.

RSPCK2  HC      RPCPC2-RSEG     :ELSE  -CHECK FOR MARKS IN 4 LSB'S
        HC      RPUNID-RSEG     :SOH   -UNKNOWN MSG, 4 LSB'S NOT MARK
        HC      RPUNID-RSEG     :STX   -UNKNOWN MSG, 4 LSB'S NOT MARK
        HC      RPUNID-RSEG     :ETX   -UNKNOWN MSG, 4 LSB'S NOT MARK
        HC      RPUNID-RSEG     :DLE   -UNKNOWN MSG, 4 LSB'S NOT MARK
        HC      RPCPC3-RSEG     :ITB   -KNOWN MSG, 4 LSB'S MARKS
        HC      RPUNID-RSEG     :ETB   -UNKNOWN MSG, 4 LSB'S NOT MARK
        HC      RPUNID-RSEG     :ENQ   -UNKNOWN MSG, 4 LSB'S NOT MARK
        HC      RPUNID-RSEG     :SYN   -UNKNOWN MSG, 4 LSB'S NOT MARK
        HC      RPUNID-RSEG     :EOT   -UNKNOWN MSG, 4 LSB'S NOT MARK
        HC      RPUNID-RSEG     :NAK   -UNKNOWN MSG, 4 LSB'S NOT MARK
        HC      RPUNID-RSEG     :ACK1  -UNKNOWN MSG, 4 LSB'S NOT MARK
        HC      RPUNID-RSEG     :WACK  -UNKNOWN MSG, 4 LSB'S NOT MARK
        HC      RPUNID-RSEG     :ACK0  -UNKNOWN MSG, 4 LSB'S NOT MARK
        HC      RPUNID-RSEG     :RVI   -UNKNOWN MSG, 4 LSB'S NOT MARK


:       NON-TRANSPARENT DATA : RSNDAT
:       -----------------------------
:       DATA CHECKSUMMED AND STORED WATCHING FOR A CONTROL CHAR

RSNDAT  HC      RPDSTO-RSEG     :ELSE  -DATA CHARACTER
        HC      RPDSTO-RSEG     :SOH   -DATA CHARACTER
        HC      RPDSTO-RSEG     :STX   -DATA CHARACTER
        HC      RPEDAT-RSEG     :ETX   -DATA END
        HC      RPNDLE-RSEG     :DLE   -WATCH FOR STX
        HC      RPEDAT-RSEG     :ITB   -DATA END
        HC      RPEDAT-RSEG     :ETB   -DATA END
        HC      RPNENQ-RSEG     :ENQ   -DATA ABORT OR TTD
        HC      RPCEAT-RSEG     :SYN   -EAT SYN'S
        HC      RPDABT-RSEG     :EOT   -DATA ABORT
        HC      RPDABT-RSEG     :NAK   -DATA ABORT
        HC      RPDSTO-RSEG     :ACK1  -DATA CHARACTER
        HC      RPDSTO-RSEG     :WACK  -DATA CHARACTER
        HC      RPDSTO-RSEG     :ACK0  -DATA CHARACTER
        HC      RPDSTO-RSEG     :RVI   -DATA CHARACTER


:       DLE IN NON-TRANSPARENT DATA : RSNDLE
:       ------------------------------------
:       PREVIOUS CHAR WAS DLE IN NON-TRANSPARENT DATA.  IF NEXT CHAR
:       IS STX, RECORD ENTERING TRANSPARENCY.  ELSE DLE WAS DATA CHAR

RSNDLE  HC      RPNDDL-RSEG     :ELSE  -PREVIOUS DLE WAS DATA
        HC      RPNDDL-RSEG     :SOH   -PREVIOUS DLE WAS DATA
        HC      RPNETP-RSEG     :STX   -ENTER TRANSPARENT TEXT
        HC      RPNDDL-RSEG     :ETX   -PREVIOUS DLE WAS DATA
        HC      RPNDDL-RSEG     :DLE   -PREVIOUS DLE WAS DATA
        HC      RPNDDL-RSEG     :ITB   -PREVIOUS DLE WAS DATA
        HC      RPNDDL-RSEG     :ETB   -PREVIOUS DLE WAS DATA
        HC      RPNDDL-RSEG     :ENQ   -PREVIOUS DLE WAS DATA
        HC      RPNDDL-RSEG     :SYN   -PREVIOUS DLE WAS DATA
        HC      RPNDDL-RSEG     :EOT   -PREVIOUS DLE WAS DATA
        HC      RPNDDL-RSEG     :NAK   -PREVIOUS DLE WAS DATA
        HC      RPNDDL-RSEG     :ACK1  -PREVIOUS DLE WAS DATA
        HC      RPNDDL-RSEG     :WACK  -PREVIOUS DLE WAS DATA
        HC      RPNDDL-RSEG     :ACK0  -PREVIOUS DLE WAS DATA
        HC      RPNDDL-RSEG     :RVI   -PREVIOUS DLE WAS DATA


:       TRANSPARENT DATA : RSTDAT
:       -------------------------
:       ALL CHAR'S HANDLED AS DATA EXCEPT DLE.  ON DLE, NEXT CHAR
:       IS CONTROL CHAR OR DATA DLE.

RSTDAT  HC      RPDSTO-RSEG     :ELSE  -DATA CHAR
        HC      RPDSTO-RSEG     :SOH   -DATA CHAR
        HC      RPDSTO-RSEG     :STX   -DATA CHAR
        HC      RPDSTO-RSEG     :ETX   -DATA CHAR
        HC      RPTDLE-RSEG     :DLE   -CONTROL IS NEXT CHAR
        HC      RPDSTO-RSEG     :ITB   -DATA CHAR
        HC      RPDSTO-RSEG     :ETB   -DATA CHAR
        HC      RPDSTO-RSEG     :ENQ   -DATA CHAR
        HC      RPDSTO-RSEG     :SYN   -DATA CHAR
        HC      RPDSTO-RSEG     :EOT   -DATA CHAR
        HC      RPDSTO-RSEG     :NAK   -DATA CHAR
        HC      RPDSTO-RSEG     :ACK1  -DATA CHAR
        HC      RPDSTO-RSEG     :WACK  -DATA CHAR
        HC      RPDSTO-RSEG     :ACK0  -DATA CHAR
        HC      RPDSTO-RSEG     :RVI   -DATA CHAR


:       DLE IN TRANSPARENT DATA : RSTDLE
:       --------------------------------
:       PREVIOUS CHAR WAS DLE IN TRANSPARENT DATA.  NEXT CHAR IS
:       DLE FOR DATA DLE OR CONTROL OF CONTROL PAIR.

RSTDLE  HC      RPTUNK-RSEG     :ELSE  -UNKNOWN, HANDLE PAIR AS DATA
        HC      RPTUNK-RSEG     :SOH   -UNKNOWN, HANDLE PAIR AS DATA
        HC      RPTUNK-RSEG     :STX   -UNKNOWN, HANDLE PAIR AS DATA
        HC      RPTEND-RSEG     :ETX   -DATA END
        HC      RPTEDT-RSEG     :DLE   -DATA DLE, STORE AND CKSUM ONE DLE
        HC      RPTEND-RSEG     :ITB   -DATA END
        HC      RPTEND-RSEG     :ETB   -DATA END
        HC      RPTENQ-RSEG     :ENQ   -DATA ABORT OR TTD
        HC      RPTEAT-RSEG     :SYN   -SYNCHRONICATION, EAT
        HC      RPDABT-RSEG     :EOT   -DATA ABORT
        HC      RPDABT-RSEG     :NAK   -DATA ABORT
        HC      RPTUNK-RSEG     :ACK1  -UNKNOWN, HANDLE PAIR AS DATA
        HC      RPTUNK-RSEG     :WACK  -UNKNOWN, HANDLE PAIR AS DATA
        HC      RPTUNK-RSEG     :ACK0  -UNKNOWN, HANDLE PAIR AS DATA
        HC      RPTUNK-RSEG     :RVI   -UNKNOWN, HANDLE PAIR AS DATA


:       1ST BYTE OF CRC : RSCRC1
:       ------------------------
:       1ST BYTE OF CRC (8 LSB'S) CAN BE ANY CHARACTER.

RSCRC1  HC      RPCRC1-RSEG     :ELSE  -PROCESS 1ST CRC BYTE
        HC      RPCRC1-RSEG     :SOH   -PROCESS 1ST CRC BYTE
        HC      RPCRC1-RSEG     :STX   -PROCESS 1ST CRC BYTE
        HC      RPCRC1-RSEG     :ETX   -PROCESS 1ST CRC BYTE
        HC      RPCRC1-RSEG     :DLE   -PROCESS 1ST CRC BYTE
        HC      RPCRC1-RSEG     :ITB   -PROCESS 1ST CRC BYTE
        HC      RPCRC1-RSEG     :ETB   -PROCESS 1ST CRC BYTE
        HC      RPCRC1-RSEG     :ENQ   -PROCESS 1ST CRC BYTE
        HC      RPCRC1-RSEG     :SYN   -PROCESS 1ST CRC BYTE
        HC      RPCRC1-RSEG     :EOT   -PROCESS 1ST CRC BYTE
        HC      RPCRC1-RSEG     :NAK   -PROCESS 1ST CRC BYTE
        HC      RPCRC1-RSEG     :ACK1  -PROCESS 1ST CRC BYTE
        HC      RPCRC1-RSEG     :WACK  -PROCESS 1ST CRC BYTE
        HC      RPCRC1-RSEG     :ACK0  -PROCESS 1ST CRC BYTE
        HC      RPCRC1-RSEG     :RVI   -PROCESS 1ST CRC BYTE


:       2ND BYTE OF CRC : RSCRC2
:       ------------------------
:       2ND BYTE OF CRC (8 MSB'S) CAN BE ANY CHARACTER.

RSCRC2  HC      RPCRC2-RSEG     :ELSE  -PROCESS 2ND CRC BYTE
        HC      RPCRC2-RSEG     :SOH   -PROCESS 2ND CRC BYTE
        HC      RPCRC2-RSEG     :STX   -PROCESS 2ND CRC BYTE
        HC      RPCRC2-RSEG     :ETX   -PROCESS 2ND CRC BYTE
        HC      RPCRC2-RSEG     :DLE   -PROCESS 2ND CRC BYTE
        HC      RPCRC2-RSEG     :ITB   -PROCESS 2ND CRC BYTE
        HC      RPCRC2-RSEG     :ETB   -PROCESS 2ND CRC BYTE
        HC      RPCRC2-RSEG     :ENQ   -PROCESS 2ND CRC BYTE
        HC      RPCRC2-RSEG     :SYN   -PROCESS 2ND CRC BYTE
        HC      RPCRC2-RSEG     :EOT   -PROCESS 2ND CRC BYTE
        HC      RPCRC2-RSEG     :NAK   -PROCESS 2ND CRC BYTE
        HC      RPCRC2-RSEG     :ACK1  -PROCESS 2ND CRC BYTE
        HC      RPCRC2-RSEG     :WACK  -PROCESS 2ND CRC BYTE
        HC      RPCRC2-RSEG     :ACK0  -PROCESS 2ND CRC BYTE
        HC      RPCRC2-RSEG     :RVI   -PROCESS 2ND CRC BYTE


:       START OF INTERMEDIATE DATA RECORD : RSDITB
:       ------------------------------------------
:       THE PREVIOUS DATA RECORD ENDED WITH ITB (OR DLE,ITB)
:       AND THIS CHARACTER WILL START A NEW RECORD.  NOTE THAT IT IS
:       POSSIBLE FOR THE RECORD TO START WITH A DATA CHARACTER.
:       NOTE ALSO THAT THE RECORD COULD START WITH A NON-TRANSPARENT
:       TERMINATOR (RECORD WOULD BE NULL).

RSDITB  HC      RPNITB-RSEG     :ELSE  -RECORD STARTS WITHOUT CONTROL CHAR
        HC      RPNITB-RSEG     :SOH   -RECORD STARTS WITH CONTROL CHAR
        HC      RPNITB-RSEG     :STX   -RECORD STARTS WITH CONTROL CHAR
        HC      RPEDAT-RSEG     :ETX   -RECORD STARTS WITH TERMINATOR, NULL
        HC      RPNDLE-RSEG     :DLE   -START OF TRANSPARENCY PERHAPS
        HC      RPEDAT-RSEG     :ITB   -RECORD STARTS WITH TERMINATOR, NULL
        HC      RPEDAT-RSEG     :ETB   -RECORD STARTS WITH TERMINATOR, NULL
        HC      RPDABT-RSEG     :ENQ   -DATA BLOCK ABORTED
        HC      RPCEAT-RSEG     :SYN   -EAT SYNC'S
        HC      RPDABT-RSEG     :EOT   -DATA BLOCK ABORTED
        HC      RPDABT-RSEG     :NAK   -DATA BLOCK ABORTED
        HC      RPNITB-RSEG     :ACK1  -RECORD STARTS WITHOUT CONTROL CHAR
        HC      RPNITB-RSEG     :WACK  -RECORD STARTS WITHOUT CONTROL CHAR
        HC      RPNITB-RSEG     :ACK0  -RECORD STARTS WITHOUT CONTROL CHAR
        HC      RPNITB-RSEG     :RVI   -RECORD STARTS WITHOUT CONTROL CHAR

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::                         R C V   P R O C E S S E S                         ::
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


:       LEADING GRAPHICS CHAR : RGRAPH
:       ------------------------------
:       STORE IN LEADING GRAPHICS AREA FOR THIS LINE
 
RGRAPH  LBR     R3,RC           : ISOLATE CHAR
        LB      R3,REVTAB,R3    : REVERSE IT
        NI      RC,0FFFFFF00    : MASK OFF CHAR IN RC
        OR      RC,R3           : PUT REVERSE CHAR BACK IN RC
        LHL     R3,RGRP,RL2     : GET OFFSET OF RCV GRAPHICS AREA
        LB      R4,GTAB,R3      : LOAD COUNT
        CHI     R4,NGRMX        : ROOM FOR THIS CHAR ?
        JGE     RPUNID          :   N - TREAT IS UNKNOWN MSG START
        AIS     R4,1            : INCREMENT COUNT
        STB     R4,GTAB,R3      : STORE COUNT
        STB     RC,GTAB,R3,R4   : STORE CHAR
        JR      RRET
:       EAT DLE,SYN IN TRANSPARENT DATA : RPTEAT
:       ----------------------------------------
:       DLE,SYN ARE NOT PLACED INTO BUFFERLETS OR CHECKSUMMED.
:       PROCESSING CONSISTS OF RESETING STATE TO TRANSPARENT DATA.

RPTEAT  LHI     RST,RSTDAT-RSEG :SET STATE TO TRANSPARENT


:       EAT SYN : RPCEAT
:       ----------------
:       LEADING SYN'S OR SYN'S IN NON-TRANSPARENT DATA ARE IGNORED.
:       STATE DOES NOT CHANGE.

RPCEAT  JR      RRET            :EAT


:       CHECK FOR 4 BITS OF PAD : RPCPCK
:       --------------------------------
:       A SINGLE BYTE BISYNC CONTROL MSG WAS JUST RECEIVED.  TO INSURE
:       THIS BYTE WAS NOT NOISE, THE NEXT 4 BITS ON THE LINE MUST BE
:       MARK (NEXT 4 BITS ARE THE LEAST SIGNIFICANT BITS OF A CHAR).
:       IF THEY ARE NOT MARK, WE HAVE AN UNKNOWN SYNCHRONIZATION.

RPCPCK  LB      RC,BIDCHR,RC    :ID'FY CHAR
        SRHLS   RC,1            :MAKE BYTE INDEX
        LB      RC,RC1CTL,RC    :GET SINGLE CHAR RETURN CODE
        STB     RC,RMTYPE,RL    :SAVE MSG TYPE
        LHI     R3,RPLSYN-RSEG  :SET LOST SYNC PROCESS
        STH     R3,RLSYNC,RL2
        LHI     RST,RSPCK2-RSEG :SET STATE TO GET NEXT CHAR
        JR      RRET            :GET NEXT CHAR

:       NEXT CHAR SHOULD HAVE 4 MARKS IN LSB'S
RPCPC2  SRHLS   RC,4            :ISOLATE LSB'S
        SIS     RC,0F           :4 MARKS ?
        JN      RPUNID          :UNKNOWN SYNCHRONIZATION IF NOT
RPCPC3  LB      RC,RMTYPE,RL    :GET MSG TYPE
        J       RPDONE          :GO END RCV



:       ESCAPED CONTROL MSG : RPCDLE
:       -----------------------------
:       A DLE WAS RECEIVED.  THE NEXT CHAR IDENTIFIES MSG TYPE.

RPCDLE  LHI     RST,RS2CHR-RSEG :SET STATE FOR 2ND OF CHAR PAIR
        LHI     R3,RPLSYN-RSEG  :ENGAGE LOST SYNC PROCESSOR
        STH     R3,RLSYNC,RL2
        JR      RRET            :GO GET NEXT CHAR

:       TWO BYTE CONTROL MSG : RPC2CH
:       -----------------------------
:       DLE,XXX CONTROL MSG FOUND.  RCV IS OVER.

RPC2CH  LB      RC,BIDCHR,RC    :ID'FY CHAR
        SRHLS   RC,1            :MAKE BYTE INDEX
        LB      RC,RC2CTL,RC    :GET CHAR PAIR RETURN CODE
        J       RPDONE          :GO END RCV


:       START TRANSPARENT DATA : RPCTDT
:       -------------------------------
:       DLE,STX FOUND.  ENTER TRANSPARENCY.  INITIALIZE FOR RCV DATA.

RPCTDT  LHI     RST,RSTDAT-RSEG         :SET TO "TRANSPARENT DATA" STATE
        SBT     RL,XPRDAT,,             :INDICATES ENTERING TRANSPARENCY
        JFS     RPCIDT


:       START NON-TRANSPARENT DATA : RPCNDT
:       -----------------------------------
:       SOH OR STX FOUND.  ENTER NON-TRANSPARENCY.  INITIALIZE FOR RCV DATA.

RPCNDT  LHI     RST,RSNDAT-RSEG         :SET TO "NORMAL DATA" STATE
        RBT     RL,XPRDAT,,             :INDICATES NORMAL MODE


:       INITIALIZE FOR RCV DATA : RPCIDT
:       -----------------------
:       THIS IS NOT A PROCESS BRANCHED TO DIRECTLY BY THE STATE TABLE,
:       BUT PROCESSES 'RPCTDT' AND 'RPCNDT' FALL INTO IT.  INITIALIZATION
:       FOR RCV DATA IS PERFORMED: A BIG BUFFERLET IS INITIALIZED,
:       THE CRC PROCESS IS INITIALIZED, AND THE CONTROL CHAR (IE.,STX
:       OR SOH) STARTING THE DATA MSG IS STORED INTO THE BIG BUFFERLET
:       AND INTO RMTYPE, BUT IS NOT CHECKSUMMED.

RPCIDT  LCS     R3,1            :COUNT BUFFERLET USAGE
        AHM     R3,RORUNC,RL2
        JL      RPOVRN          :JUMP CAN'T USE ANY, OVERRUN
        JAL     R4,GBB          :GET 1ST BIG BUFFERLET
        J       RPNROM          :JUMP NO BUFFERLETS
        LHI     R4,BBFLSZ-1
        STH     R4,ROBCNT,RL2   : INIT. PARTIAL BYTE CNT
        LR      RBBA,R3         :INIT BUFFERLET ADDR REG
        LHI     RBBX,-BBFLSZ+1  :INIT BUFFERLET INDEX REG
        STH     RBBA,RBBCHN,RL2 :INIT BUFFERLET CHAIN ADDR

        CRCINT(RCRC)
        RBT     RL,RCRCER       :INIT CRC ERROR OFF
        RBT     RL,RLOSTD       :INIT LOST DATA INDICATOR
        LHI     R3,RPLSYN-RSEG  :ENGAGE LOST SYNC PROCESSOR
        STH     R3,RLSYNC,RL2


        STB     RC,RMTYPE,RL    :SAVE MSG TYPE
        RWCI(RC)                :STORE MSG TYPE
        JR      RRET            :GO GET NEXT CHAR


:       DLE NOT-STX IN NON-TRANSPARENT TEXT : RPNDDL
:       --------------------------------------------
:       PREVIOUS DLE WAS DATA.  RESET STATE TO NON-TRANSPARENT AND
:       PROCESS CURRENT CHARACTER THROUGH NON-TRANSPARENT STATE TABLE.

RPNDDL  LHI     RST,RSNDAT-RSEG :SET STATE TO NON-TRANSPARENT
        LB      R3,BIDCHR,RC    :ID'FY CHAR
        LHL     R3,RSNDAT,R3    :GET PROCESS FOR CURRENT CHAR
        J       RSEG,R3         :GO PROCESS CHAR


:       DATA DLE IN TRANSPARENT DATA : RPTEDT
:       -------------------------------------
:       DLE,DLE IN TRANSPARENT.  PUT INTO BUFFERLET AND CHECKSUM
:       ONLY ONE DLE.  STATE SET BACK TO TRANSPARENT DATA.

RPTEDT  LHI     RST,RSTDAT-RSEG :SET STATE BACK TO TRANSPARENT DATA
        JFS     RPDSTO          :GO STORE AND CKSUM 2ND DLE


:       DLE IN NON-TRANSPARENT DATA : RPNDLE
:       ------------------------------------
:       DLE IN NON-TRANSPARENT DATA.  IF NEXT CHAR IS STX, ENTER
:       TRANSPARENCY, ELSE DLE IS DATA.  SET STATE TO PROCESS CONDITION,
:       STORE DLE AND CHECKSUM.

RPNDLE  LHI     RST,RSNDLE-RSEG :SET NEXT STATE
        JFS     RPDSTO


:       DLE STX IN NON-TRANSPARENT TEXT : RPNETP
:       ----------------------------------------
:       DLE STX IN NON-TRANSPARENT TEXT SIGNALS TO ENTER TRANSPARENCY.
:       STX IS STORED INTO BUFFERLET AND CHECKSUMMED.

RPNETP  LHI     RST,RSTDAT-RSEG :SET STATE TO TRANSPARENT
        JFS     RPDSTO          :GO STORE AND CHECKSUM


:       START OF NON-TRANSPARENT INTERMEDIATE RECORD - RPNITB
:       -----------------------------------------------------
:       PREVIOUS RECORD TERMINATED BY ITB (OR DLE,ITB).  NEXT RECORD
:       BEGAN WITH NON-TRANSPARENT CHARACTER SEQUENCE.  PUT CHAR INTO
:       BUFFER AND CHECKSUM.  SET STATE FOR NON-TRANSPARENT DATA.

RPNITB  LHI     RST,RSNDAT-RSEG :SET STATE FOR NON-TRANSPARENT DATA


:       STORE DATA AND CHECKSUM : RPDSTO
:       --------------------------------
:       CHAR IS STORED INTO BIG BUFFERLET AND CRC-16 PERFORMED

RPDSTO  EQ      .
        CRCACC(RCRC,RC,R3)
RPDPUT  EQ      .
        RWCI(RC)
        JR      RRET


:       ENQ IN NON-TRANSPARENT DATA : RPNENQ
:       ------------------------------------
:       AN ENQ FOUND IN NON-TRANSPARENT TEXT.  IF IT IS THE 2ND CHAR
:       IN THE 1ST BUFFERLET, IT IS A CONTROL SEQUENCE.  ELSE IT IS
:       A DATA ABORT.  SOH,ENQ IS THE MULTI-LEAVING REMOTE BID
:       SEQUENCE.  STX,ENQ IS A TTD.

RPNENQ  LHI     R4,-BBFLSZ+2    :POINTER MUST BE AT 1ST BYTE
        LB      R3,BBUFER+BBFLSZ-2,RBBX,RBBA    :FETCH LAST CHAR
        IF      RCVREV
        CLHI    R3,STX          : STX ?
        ELSE
        CLHI    R3,RSTX         :STX ?
        EI
        JEFS    RPTEN2          :YEP, GO CHECK BUFFER POSITION
        LIS     RC,RCMBID       :SET RETURN CODE FOR MULTI-LEAVING BID
        JFS     RPTEN4


:       DLE ENQ IN TRANSPARENT DATA : RPTENQ
:       ------------------------------------
:       A DLE,ENQ FOUND IN TRANSPARENT DATA.  IF IT IS IMMEDIATELY AFTER
:       THE DLE,STX, HANDLE AS TTD.  ELSE IT IS A DATA ABORT.  ITS PLACE
:       IN THE BUFFERLET IS DETERMINED BY REQUIRING THAT IT IS IN THE 1ST
:       BUFFERLET OF THE CHAIN AND 3RD BYTE (DLE NOT IN BUFFERLET YET).

RPTENQ  LHI     R4,-BBFLSZ+3    :LAST BYTE WAS 4TH
RPTEN2  LIS     RC,RCTTD        :SET FOR TTD RETURN CODE
RPTEN4  CR      R4,RBBX         :CHECK BUFFERLET BYTE INDEX
        JN      RPDABT          :JUMP NOT BEG OF BUF, DATA ABORT
        CLH     RBBA,RBBCHN,RL2 :IN 1ST BUFFERLET ?
        JN      RPDABT          :JUMP IF NOT, DATA ABORT
        J       RPDONE          :RCV DONE


:       DLE IN TRANSPARENT DATA : RPTDLE
:       --------------------------------
:       A DLE WAS FOUND IN TRANSPARENT DATA.  SET STATE TO DECODE
:       NEXT CHARACTER AS DATA DLE OR CONTROL.  NOTE THAT DLE IS
:       NOT CHECKSUMMED OR PUT IN BUFFERLET.  WE DO NOT WANT TO
:       PUT DLE,SYN INTO BUFFER AND ITS HARD TO BACK UP BUFFERLETS.

RPTDLE  LHI     RST,RSTDLE-RSEG :SET STATE TO PROCESS NEXT CHAR
        JR      RRET


:       UNKNOWN DLE SEQUENCE IN TRANSPARENT DATA : RPTUNK
:       -------------------------------------------------
:       HANDLE PREVIOUS DLE AS DATA, CHECKSUMMING BOTH IT AND
:       CHARACTER WHICH FOLLOWS.  BOTH CHARACTERS ARE STORE INTO
:       BUFFERLET.

RPTUNK  LHI     RST,RSTDAT-RSEG :SET STATE BACK TO TRANSPARENT DATA
        LHI     RCB,RDLE         :PUT PREVIOUS DLE INTO BUFFERLET
        CRCACC(RCRC,RCB,R3)
        RWCI(RCB)
        J       RPDSTO          


:       END OF DATA IN TRANSPARENT : RPTEND
:       -----------------------------------
:       ETX,ETB, OR ITB PRECEDED BY A DLE.  THE DLE WAS NEITHER
:       STORED NOR CHECKSUMMED, BUT THE END CHAR IS, AS WE FALL THROUGH
:       THE STANDARD END OF DATA LOGIC.

RPTEND  


:       END DATA RECORD : RPEDAT
:       ------------------------
:       TERMINATOR CHAR IS SAVED AND RECORD CHECKSUM IS COMPLETED.
:       STATE SET TO READ AND CHECK CHECKSUM.

RPEDAT  STB     RC,RMTYPE,RL    :SAVE TERMINATOR TYPE
        CRCACC(RCRC,RC,R3)
        CRCEND(RCRC,RCB,R3)
        LHI     RST,RSCRC1-RSEG :SET TO CHECK 1ST BYTE OF CRC
        RWCI(RC)
        JR      RRET


:       CHECK 1ST CHAR OF CRC : RPCRC1
:       ------------------------------
:       CHECK THE 8 LSB'S OF THE 16 BIT CHECKSUM.  SINCE OUR HARDWARD
:       RECEIVES MSB 1ST, WE COMPARE IT TO THE 8 MSB'S OF THE ACCUMULATOR

RPCRC1  LHI     RST,RSCRC2-RSEG :PREPARE STATE FOR 2ND CRC BYTE
        EXBR    R3,RCRC         :POSITION MSB'S
        LBR     R3,R3           :ISOLATE MSB'S
        CR      R3,RC           :COMPARE TO RECEIVED VALUE
        IF      STOBCC          :BCC TO BE STORED WITH DATA ?
        JE      RPDPUT          :JUMP TO STORE BCC IF OK
        ELSE
        JER     RRET            :RETURN OK, GET NEXT
        EI
        SBT     RL,RCRCER       :SET CHECKSUM BAD
        IF      STOBCC          :BCC TO BE STORED WITH DATA ?
        J       RPDPUT          :JUMP TO STORE
        ELSE
        JR      RRET
        EI


:       COMPLETE CHECKSUM VERIFICATION : RPCRC2
:       ---------------------------------------
:       CHECK THE 8 MSB'S OF THE 16 BIT CHECKSUM AND RECORD OUTCOME.
:       IF RECORD TERMINATOR WAS ITB, SET STATE TO EXPECT THE BEGINNING
:       OF AN INTERMEDIATE RECORD.  ELSE, END RECEIVE AS GOOD
:       DATA IF ALL CHECKSUMS OK AND NO DATA WAS LOST, END RECEIVE AS BAD
:       OR LOST DATA OTHERWISE.

RPCRC2  LBR     RCRC,RCRC       :ISOLATE LSB'S
        CR      RCRC,RC         :COMPARE TO VALUE RECEIVED
        JEFS    .+6             :SKIP OK
        SBT     RL,RCRCER       :FLAG AS BAD

        IF      STOBCC          :BCC TO BE STORED WITH DATA ?
        RWCI(RC)
        JNFS    .+6             :SKIP NEW BUFFERLET NOT NEEDED
        JAL     R5,RWCIB        :GET NEW BUFFERLET AND STORE
        EI

        LB      RC,RMTYPE,RL    :GET TERMINATOR TYPE
        CLHI    RC,RITB         :ITB ?
        JNFS    RPCRC4          :SKIP IF NOT
        LHI     RST,RSDITB-RSEG :SET STATE FOR INTERMEDIATE RECORD
        CRCINT(RCRC)
        JR      RRET

:       END OF DATA
RPCRC4  LIS     RC,RCDATB       :RETURN CODE DATA-ETB
        AHM     RBBX,ROBCNT,RL2 : COMPLETE BYTE CNT IN ROBCNT
        LB      R3,RMTYPE,RL    :GET MSG TERMINATOR
        CLHI    R3,RETB         :ETB ?
        JEFS    .+4             :SKIP IF SO
        LIS     RC,RCDATX       :RETURN CODE DATA-ETX
        TBT     RL,RCRCER       :ANY CHECKSUM ERRORS ?
        JNFS    RPCRC6          :JUMP IF SO
        TBT     RL,RLOSTD       :ANY DATA LOST ?
        JE      RPDONE          :JUMP IF NOT, DONE

        LHI     RC,RCLOST       :FLAG DATA LOST
        J       RPDONE          :GO END OPERATION
RPCRC6  LHI     RC,RCBADD       :FLAG BAD RCV
        J       RPDONE          :GO END OPERATION


:       FORCED OPERATION COMPLETE : RPFCOM
:       ----------------------------------
:       THE BACKGROUND HAS SIGNALED TO ABORT THE CURRENT RCV OPERATION
:       AND FORCE AN OPERATION COMPLETE IMMEDIATELY.  THIS WILL ONLY BE
:       PERFORMED WHILE LOOKING FOR THE SYNCHRONIZATION PATTERN AND IF
:       THE PROTOCOL DRIVER ALLOWS IT (TYPICALLY, THE PROTOCOL DRIVER
:       ONLY ALLOWS IT WHEN IT IS MONITORING THE LINE FOR BIDS AND
:       THE BACKGROUND USES THIS MECHANISM TO SIGNAL THE PROTOCOL
:       DRIVER TO DO A TRANSMISSION).

RPFCOM  LHI     RC,RCFCOM       :FLAG OP COMPLETE FORCED
        LIS     REX,0           :INIT INDEX FOR RPDONE
        J       RPDONE          :GO END OPERATION


:       LOST RCV SYNCHRONIZATION : RPLSYN
:       ---------------------------------
:       LOST RCV SYNCHRONIZATION AFTER RECEPTION STARTED (CHAR AFTER
:       LEADING SYN'S RECEIVED, THEN SUBSEQUENTLY FAILED TO RCV DATA INTO
:       RING WITHING MAXIMUM TIME FOR SLOWEST LINE SPEED SUPPORTED).

RPLSYN  LHI     RC,RCLSYN       :FLAG LOST SYNCHRONIZATION
        JFS     RPDONE          :GO END OPERATION


:       RECEIVE DATA ABORT : RPDABT
:       ---------------------------
:       AFTER STARTING TRANSMISSION OF DATA, THE SENDER AS SIGNALED
:       AN ABORT (NAK,EOT,ENQ)

RPDABT  LIS     RC,RCDABT       :FLAG RCV DATA ABORT
        JFS     RPDONE          :GO END OPERATION


:       RECEIVE TIMEOUT : RPTMOT
:       ------------------------
:       THE TIME SPECIFIED BY THE USER AS ELAPSED WITHOUT FIND A SYNC PATTERN.

RPTMOT  LHI     RC,RCTMOT       :FLAG RCV TIMEOUT
        LIS     REX,0           :INIT INDEX FOR RPDONE
        JFS     RPDONE          :GO END OPERATION


:       -----------------------------
:       A MESSAGE WAS SEND WHOSE LENGTH EXCEEDED THAT SPECIFIED BY THE
:       USER (TO NEAREST BIG BUFFERLET).  RCV HALTED WITHOUT TRYING TO
:       COMPLETE SINCE THIS COULD BE DUE TO A LINE HIT AND WE'RE REALLY
:       LISTENING TO NOISE.

RPOVRN  LIS     RC,RCOVRN       :FLAG RCV OVERRUN
        JFS     RPDONE          :GO END OPERATION


:       UNIDENTIFIABLE RCV MESSAGE : RPUNID
:       -----------------------------------
:       CHAR(S) AFTER SYNC STREAM UNKNOWN

RPUNID  LHI     RC,RCUNID       :FLAG UNIDENTIFIED RCV
        JFS     RPDONE          :GO END OPERATION


:       RECEIVE STORAGE ERROR : RPNROM
:       ------------------------------
:       A DATA RCV OPERATION WAS STARTED (SOH,STX, ETC. RECEIVED)
:       AND A BIG BUFFERLET WAS NOT AVAILABLE.  RCV OPERATION IS
:       ABORTED IMMEDIATELY (UNLIKE LOST DATA WHERE BUFFERLET IS NOT
:       AVAILABLE, BUT RCV CONTINUES OVERLAYING DATA IN PREVIOUS
:       BUFFERLET).

RPNROM  LIS     RC,RCNROM       :FLAG STORAGE ERROR


:       RECEIVE OPERATION COMPLETE : RPDONE
:       -----------------------------------
:       RETURN TO ACTIVATOR USING RELATIVE ADDRESS STORED IN 'RRETAD'.
:       ON ALL BUT 'GOOD DATA' OP COMPLETE, RETURN ANY BIG BUFFERLETS
:       USED TO FREE POOL.
:
:       REGISTER CONVENTIONS ON RETURN:
:               R1     -OPERATION RETURN CODE
:               R3     -RELATIVE ADDRESS OF 1ST BUFFERLET IN DATA CHAIN

RPDONE  LHL     RAD,RRETAD,RL2  :GET RETURN ADDRESS TO ACTIVATOR
                :-:-:-:-:-:-:-:-:-:-:-:-:-:  TRACE  :-:-:-:-:-:-:-:-:-:-:-:-:-:
                IF      RCVTSW&0F000;   IF RCVTSW&RCVT12;                     :
                TBT     RL,RCVBIT       :TRACE THIS LINE?
                JE      RPDON2
                LHL     R5,RCVTRX       :GET INDEX                            :
                AIS     R5,1            :INSURE HALFWORD BOUNDRY              :
                NHI     R5,0FFFE                                              :
                LHI     R3,1234         :FLAG OP COMPLETE RETURN CODE         :
                STH     R3,RCVTTB,R5,                                         :
                STH     RC,RCVTTB+2,R5, :LOG RETURN CODE                      :
                AIS     R5,4            :ADVANCE TRACE INDEX                  :
                CLHI    R5,(RCVTSW&0F000)^(-2)                                :
                JLFS    .+4                                                   :
                LIS     R5,0                                                  :
                STH     R5,RCVTRX       :SAVE INDEX                           :
                EI
                :-:-:-:-:-:-:-:-:-:-:-:-:-:  TRACE  :-:-:-:-:-:-:-:-:-:-:-:-:-:
                EI      :RCVTSW
RPDON2
                IF      RCVHRC          :KEEP HISTORY OF RETURN CODES
                :-:-:-:-:-:-:-:-:-:-:-:-:-: HISTORY :-:-:-:-:-:-:-:-:-:-:-:-:-:
                LIS     R3,1            :COUNT RETURN CODE USED               :
                AHM     R3,RCVHRT,RC,RC                                       :
                SEG     0                                                     :
RCVHRT          HS      RCFCOM+2        :RETURN CODE HISTORY TABLE            :
                SEG     1                                                     :
                :-:-:-:-:-:-:-:-:-:-:-:-:-: HISTORY :-:-:-:-:-:-:-:-:-:-:-:-:-:
                EI      :RCVHRC
        AH      REX,RRGETX,RL2
        SIS     REX,1           :ADJUST INDEX TO POINT BEFORE SYN
        NHI     REX,0FE         :INSURE HW BOUNDRY
        STH     REX,RRGETX,RL2
        LHL     R3,RBBCHN,RL2   :GET DATA CHAIN ADDRESS
        JE      RSEG,RAD        :RETURN NO DATA RCV'D
        CLHI    RC,RCDATB       :GOOD DATA OP COMPLETE ?
        JLE     RSEG,RAD        :RETURN IF SO
        JAL     R5,PBBC         :RETURN BUFFERLETS TO FREE POOL
        J       RSEG,RAD        :RETURN TO ACTIVATOR


        EM

        SUBTTL	SRV-BISYNC SINGLE RECEIVE DRIVER
        RA      0
        MO      .,BSCSRV
        GL      BSCSRV,BSR100
        GL      BSRLUN
        LO      BSCRCV          :ACCESS BISYNC PRIMITIVE RCV DRIVER
        LO      BSCEXC          :ACCESS BISYNC FOREGROUND EXECUTION RUN LISTS

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::          B I S Y N C   S I N G L E   R E C E I V E   D R I V E R          ::
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:       REGISTER CONVENTIONS:
:       R0     -FASTC TIME TO FORCE END OF OPERATION.
:               0 = NEVER FORCE END BASED ON TIME.
:               - = INITIALIZE (CONNECTS INPUT, CALL ONLY ONCE)
:       R1     -MAXIMUM NUMBER OF BIG BUFFERLETS TO USE ON RECEIVE MESSAGE.
:               ON OUTPUT, THE NUMBER OF BIG BUFFERLETS USED.
:       R2     -OP COMPLETE CODE
:       R3     -DATA BUFFER CHAIN ADDRESS REL TO BBUFER IF GOOD DATA RCV'D
:       R5     -LINK REGISTER



:       ISIS SYNCHRONOUS SVC OP CODES
CONCTI  EQ      0               :FORCE OUTPUT


:       ISIS SVC'S
IOCTRL  EQ      3               :I/O CONTROL


:       VARIABLES

        SEG     0
BSRETA  WS      NBILIN          :CALLER'S RETURN ADDRESS

BSRBUF  HS      NBILIN          :DATA BUFFER CHAIN ADDRESS
BSRBCT  HS      NBILIN          :BUFFERLET LIMIT TO USE

BSROPC  BS      NBILIN          :OP COMPLETE CODE FROM RCV DRIVER


:       LOGICAL UNIT NUMBER TABLE
:       -------------------------
:       THE FOLLOWING TABLE CORRELATES THE BISYNC LINE NUMBER TO
:       THE ISIS LOGICAL UNIT NUMBER.  IT EXPECTS SYMBOLS BLUN0
:       BLUN1,...,BLUN|NBILIN| TO BE DEFINED CORRELATING BISYNC
:       LINE 0 TO ISIS LOGICAL UNIT X, ETC.

        SEG     1
BSRLUN  BS      0
Q       EQ      0
        RE      NBILIN
        BC      BLUN|Q|
Q       EQ      Q+1
        LIST;   ER


:       DETERMINE CALL TYPE
BSCSRV  LR      R0,R0           :INITIALIZE ?
        JGE     BSR100          :JUMP IF NOT, START INPUT

:       INITIALIZE - CONNECT SYNC INPUT
        LHI     R4,RRSIZE       :GET RING SIZE (IN BSCRCV)
        LB      R2,BSRLUN,R1    :GET LOGICAL UNIT NUMBER FOR BISYNC LINE
        SLHLS   R1,2            :MAKE WORD INDEX
        L       R3,RRINGX,R1    :GET RING ADDRESS FOR LINE (IN BSCRCV)
        SRHLS   R1,2            :RESTORE BYTE INDEX

        SVC     IOCTRL,CONCTI^4+R2      :CONNECT INPUT
        JAL     R10,CRASH               :CRASH ALREADY CONNECTED

        LCS     R3,1            :DE-SYNCHRONIZE RCV EMPTY POINTER
        STH     R3,RRGETX,R1,R1
        JR      R5              :RETURN TO CALLER

:       START INPUT AND HALT PROTOCOL DRIVER CALLER
BSR100  ST      R0,RTIME,RL2,RL2        :SAVE TIME TO FORCE RCV OP COMPLETE
        STH     R1,RORUNC,RL2           :INIT BUFFERLET USAGE LIMIT
        STH     R1,BSRBCT,RL2           :SAVE CNT TO COMPUTE USAGE
        ST      R5,BSRETA,RL2,RL2       :SAVE RETURN ADDRESS

        LH      R5,RRGETX,RL2           :HAS EMPTY INDEX BEEN SYNCHRONIZED ?
        JGEFS   BSR110                  :JUMP IF SO
        L       R5,RRINGX,RL2,RL2       :SYNCHRONIZE EMPTY INDEX TO
        LHL     R5,0,R5                 : CURRENT FILL RING INDEX
        STH     R5,RRGETX,RL2

BSR110  LHI     R5,BSREND-RSEG  :SUPPLY RCV ROUTINE WITH RETURN ADDRESS
        STH     R5,RRETAD,RL2
        LA      R5,RSTART       :PUT RECEIVE PROCESS ON RCV RUN LIST
        ST      R5,RRUNL,RL2,RL2

        J       PHALT           :REMOVE CALLER FROM PROTOCOL RUN LIST


:       RECEIVE OPERATION COMPLETE.  SAVE RESULTS AND PLACE ROUTINE
:       ON PROTOCOL RUN LIST.  WHEN PROTOCOL LIST IS RUN, RETURN TO
:       ORIGINAL CALLER.

BSREND  STB     RC,BSROPC,RL    :SAVE OP COMPLETE CODE
        STH     R3,BSRBUF,RL2   :SAVE DATA BUFFER CHAIN ADDRESS

        STH     REX,RRGETX,RL2  :KEEP LINE SYNCED FOR NOW

        LA      R3,BSRRET       :PUT US ON PROTOCOL RUN LIST
        ST      R3,PRUNL,RL2,RL2
        J       RHALT           :DISCONNECT LINE FROM RECEIVE RUN LIST


:       PROTOCOL LIST RUNNING, RESTART USER
BSRRET  LHL     R1,ROBCNT,RL2   : GET MSG BYTE CNT
        LB      R2,BSROPC,RL    :GET OP COMPLETE CODE
        LHL     R3,BSRBUF,RL2   :GET DATA BUFFER CHAIN ADDRESS
        L       R5,BSRETA,RL2,RL2
        JR      R5              :RETURN TO CALLER

        EM

        SUBTTL	SXM-BISYNC SINGLE TRANSMIT DRIVER
        RA      0
        MO      .,BSCSXM
        GL      BSCSXM
        GL      BSCCTS          :CLEAR TO SEND (CTS) BIT ARRAY
        GL      BSXWSZ
        GL      LNBUFLT,CDEV,STATE,SENQ
        GL      RPXMT,NPXMT
	GL	ST.ON,ST.DSP,ST.ST0,ST.ST1,ST.ST2,ST.ST3,ST.ST4,ST.ST5
	GL	ST.ST6,ST.ST7,ST.ST8,ST.ST9,STDSP,ST.FLG
	GL	RE.ON,RE.MST,RE.RSP,RE.FLG,RE.NMB
        LO      BSCCHR          :ACCESS BISYNC CONTROL CHAR DEFINITIONS
        LO      BSCRCV          :TEMP TO ACCESS RRINGX,RRGETX !!!!!!!!!!!!!!!!!!
        LO      BSCEXC          :ACCESS BISYNC FOREGROUND EXECUTION RUN LISTS


:       DEDICATED REGISTER DEFINITIONS
RLUN    EQ      R2              :REG HAVING LOGICAL UNIT NO. FOR SVC
RAD     EQ      RLUN+1          :REG HAVING LIST ADDRESS FOR SVC
RL8     EQ      R10             :CONTAINS LINE # INDEX BY DOUBLE WORDS (IE. 8*RL)
RCNT    EQ      R11             :REG HAVING HW DATA CNT
RTMP    EQ      R12             :TEMPORARY WORK REGISTER
RRET    EQ      R13             :REG HAVING RETURN ADDRESS FOR XMT PROCESS
RCMD    EQ      R14             :REG HAVING SYNC COMMAND
RDAT    EQ      RCMD+1          :REG HAVING DATA ADDRESS FOR COMMAND
PSEG    EQ      SEG1            :BASE ADDRESS FOR MODULE


:       CONFIGURATION PARAMETERS
LSYNCS  EQ      5               :NO. OF LEADING SYNC'S BEFORE MESSAGE
TPADS   EQ      6               :NO. OF TRAILING PADS AFTER MESSAGE

:       TRACE OPTIONS
BSXTSW  EQ      1               :KILO-BYTE SIZE OF TRACE BUFFER, O=TRACE OFF


:       RETURN CODES TO CALLER
XMTOK   EQ      0               :XMT SUCESSFUL
XMTTMO  EQ      1               :XMT NOT COMPLETED BEFORE TIMEOUT VALUE


:       ISIS SYNCHRONOUS OUTPUT COMMANDS
CHALT   EQ      0               :HALT OUTPUT
CWRITE  EQ      1               :WRITE
CJUMP   EQ      2               :JUMP TO ADDRESS
CRTSOF  EQ      3               :DISABLE REQUEST TO SEND
CRTSON  EQ      4               :ENABLE REQUEST TO SEND
CSBT    EQ      5               :SET BIT
CCTS    EQ      6               :CONNECT CLEAR TO SEND TO BIT ARRAY
CSPAD   EQ      $A10            :SET PADDING


:       ISIS SYNCHRONOUS SVC OP CODES
CONNECT EQ      1               :CONNECT OUTPUT
FORCEO  EQ      2               :FORCE OUTPUT


:       ISIS SVC'S
IOCTRL  EQ      3               :I/O CONTROL





:       LOGICAL UNIT NUMBER TABLE
:       -------------------------
:       THE FOLLOWING TABLE CORRELATES THE BISYNC LINE NUMBER TO
:       THE ISIS LOGICAL UNIT NUMBER.  IT EXPECTS SYMBOLS BLUN0
:       BLUN1,...,BLUN|NBILIN| TO BE DEFINED CORRELATING BISYNC
:       LINE 0 TO ISIS LOGICAL UNIT X, ETC.

        SEG     1
XLUN    BS      0
Q       EQ      0
        RE      NBILIN
        BC      BLUN|Q|
Q       EQ      Q+1
        LIST;   ER


:       CONFIGURE RTS/CTS HANDSHAKE LINES
:       ---------------------------------

:       THE FOLLOWING CODE CREATES A BIT ARRAY RTSCTS FROM USER INPUT
:       BRTS0,BRTS1,...,BRTS|NBILIN| WHICH THE CODE TESTS TO DETERMINE
:       IF RTS/CTS HANDSHAKE MUST BE PERFORMED BEFORE DATA IS TRANSMITTED
:       (HANDSHAKE IS RAISE RTS, WAIT FOR CTS, SEND DATA, LOWER RTS).
:       BIT ARRAY IS INDEXED BY RL, 1 = HANDSHAKE REQUIRED

RTSCTS  HS      0
QQ      EQ      0               :WORK SYMBOL
Q       EQ      0
        RE      NBILIN; NOLIST
QQ      EQ      QQ+(BRTS|Q|&1)^(0F-(Q&0F))
Q       EQ      Q+1
        IF Q&0F;        ELSE;
        HC QQ  ;QQ EQ 0;        EI
        ER
        IF Q&0F;        HC QQ;  EI;     LIST

:       THE FOLLOWING CODE CREATES A TABLE OF RELATIVE ADDRESSES OF THE
:       1ST PROCESSOR OF A LINE.  IF THE LINE REQUIRES RTS/CTS HANDSHAKING,
:       THE PROCESS WILL BE BSXRTS.  ELSE IT WILL BE BSXWRT.

BSX1ST  HS      0
Q       EQ      0               :LINE COUNTER
        RE      NBILIN; NOLIST
        IF      BRTS|Q|&1;      HC BSXRTS-RSEG
        ELSE;   HC BSXWRT-RSEG; EI
Q       EQ      Q+1;    LIST;   ER


:       DEFINE CONTROL MESSAGE TEXTS
:       ----------------------------

:       THE FOLLOWING MACRO DEFINES THE TEXT FOR BISYNC CONTROL MESSAGES.
:       EACH MSG WILL BE PRECEEDED BY LSYNCS LEADING SYNC'S AND AT LEAST
:       1 PAD AT INITIALIZATION (MSG IS EXPANDED WITH PADS TO NEAREST
:       HALF-WORD).  IT ALSO DEFINES A SYMBOL FOR THE OP CODE AS XC`OPCODE.

DFCMSG  MACRO(NAME,CTRL1,CTRL2)[NOLIST
QQ      EQ      0FF
        IF CTRL2        ;QQ EQ R`CTRL2; EI
        HC      R`CTRL1^8+QQ
Q       EQ      Q+1;    LIST
XC`NAME EQ      Q]

:       DEFINE TEXTS
Q       EQ      0               :INIT MSG CNTR

XCDATA  EQ      0               :OP CODE FOR SEND DATA
BSXCMS  HS      0               :TABLE OF 2 CHAR MSG TEXTS
        DFCMSG(ENQ,ENQ,0)
        DFCMSG(EOT,EOT,0)
        DFCMSG(NAK,NAK,0)
        DFCMSG(TTD,STX,ENQ)
        DFCMSG(ACK1,DLE,ACK1)
        DFCMSG(WACK,DLE,WACK)
        DFCMSG(ACK0,DLE,ACK0)
        DFCMSG(RVI,DLE,RVI)
        DFCMSG(DISC,DLE,EOT)
MAXOPC  EQ      Q               :MAX VALUE FOR OP CODE

:       LEADING SYN'S AND TRAILING PAD'S MESSAGES

SYNMSG HS 0;    IF LSYNCS&1;    BC 0FF; EI
        RE LSYNCS;      BC RSYN;        ER
PADMSG HS 0;    RE (TPADS+1)&0FFFE;     BC 0FF; ER

        IF      TSTPAD
        RE      TSTPAD/2
        HC      0FFFF
        ER      
        HC      0FF4C
        HC      4C4C
        HC      4C4C
        EI

MSGLGN  EQ      .-BSXCMS        :BYTES OF MSG TO MOVE AT INITIALIZATION

:       DEFINE CONTROL MESSAGE COMMAND TABLE.  EACH MSG COMMAND IS TWO
:       WORDS LONG:     1ST WD  (WRITE CMD CODE)(HALF-WORD CNT)
:                       2ND WD  (     ADDRESS OF MSG TEST     )

WCRTLM  WS      0
Q       EQ      0               :DEFINE LOOP CNTR
        RE      MAXOPC; NOLIST
        WC      CWRITE^10+2
        WC      BSXCMT+Q*2
Q       EQ      Q+1
        LIST;   ER

        IF      TSTPAD
SYNMOP  WC      CWRITE^10+(TSTPAD/2)*2+6
        WC      TSTSYN
        ELSE
SYNMOP  WC      CWRITE^10+((LSYNCS+1)&0FFFE)
        WC      BSXSYN
        EI

PAD2MOP WC      CWRITE^10+2             :2 PADS FOR FULL DUPLEX
        WC      BSXPAD

PAD6MOP WC      CWRITE^10+((TPADS+1)&0FFFE)     :6 PADS FOR HALF DUPLEX
        WC      BSXPAD



:       VARIABLES
:       ---------

        SEG     0
BSXRTA  WS      NBILIN          :CALLER'S RETURN ADDRESS
BSXTIM  WS      NBILIN          :FASTC TIME TO ABORT XMT OPERATION

BSXDAT  HS      NBILIN          :REL ADDR 1ST BUFFERLET IN DATA CHAIN
BSXCNT  HS      NBILIN          :HW CNT OF DATA TO SEND
BSXOPC  HS      NBILIN          :OPERATION CODE

BSXWCNT BS      NBILIN          :COUNT OF BUFFERS IN THE MSG
BSXWPTR WS      NBILIN          :POINTER TO CURRENT BUFFER IN THE MSG
BSXWR0  HS      NBILIN          :CONTROL BYTE OF THE 1ST BUFFER IN MSG

        IF      DYNBUF
        GL      NRSTRT,NDXMT
NRSTRT  HS      NDEVM           :# OF RESTARTS OF CMD ROTOR (# OF SYN INSERTS)
NDXMT   HS      NDEVM           :# OF BYTES TRANSMITTED FOR CURRENT MSG
        EI

BSXRTC  BS      NBILIN          :OPERATION RETURN CODE


:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::               O U T P U T   L I S T    D E F I N I T I O N S              ::
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

XLSIZE  EQ      8*8             :ALLOW FOR 8 I/O CMDS IN EACH ROTOR LIST
MAXBCT  EQ      0FE             :MAX BUFFER LIMIT FOR DATA RECEIVED

        SEG     A.BUFF          :DEFINE LIST FOR EACH LINE
        WS      0               :ALIGN ON FULLWORD FOR XLIST
XLIST   BS      XLSIZE*NBILIN   :ROTOR LISTS
BSXINT  HS      9               :CONNECT CTS WORK LIST, MUST BE WORD BOUNDRY
BSXOCP  HS      (NBILIN-1)/10+1 :OP COMPLETE BIT ARRAY
BSCCTS  HS      (NBILIN-1)/10+1 :CLEAR TO SEND (CTS) BIT ARRAY
BSXWBIT WS      2*NBILIN        :1=RCNT'TH MSG BUFFER SENT FOR THE LINE
:
:
BSXCMT  HS      MAXOPC          :CONTROL MSG TEXTS AFTER INITIALIZATION
BSXSYN  HS      (LSYNCS+1)/2    :LEADING SYN MSG AFTER INITIALIZATION
BSXPAD  HS      (TPADS+1)/2     :TRAILING PAD MSG AFTER INITIALIZATION
        IF      TSTPAD
TSTSYN  HS      TSTPAD/2+3
        EI

        SEG     1
XLISTX  WS      0               :ADDRESS TABLE OF START OF EACH LIST
Q       EQ      0
        RE      NBILIN
        WC      XLIST+Q*XLSIZE
Q       EQ      Q+1
        ER

:       DETERMINE CALL TYPE
BSCSXM  LR      R0,R0           :INITIALIZE ?
        JGE     BSX100          :JUMP IF NOT, START INPUT

:       INITIALIZE MSG TEXTS - NOTE THAT SINCE THESE TEXTS RESIDE IN
:       SEGMENT 2, THEY MUST BE INITIALIZED VIA EXECUTION AND NOT
:       BY ASSEMBLY.
        LHI     R2,-MSGLGN      :TEXT COUNTER

BSX010  LHL     R4,BSXCMS+MSGLGN,R2     :MOVE MSG'S
        STH     R4,BSXCMT+MSGLGN,R2,
        AIS     R2,2
        JLBS    BSX010

:       INITIALIZE - CONNECT CTS ARRAY FOR LINE IF NEEDED AND HALT CURRENT I/O
        LA      RAD,BSXINT,,    :INIT COMMAND LIST ADDR
        TBT     R1,RTSCTS       :RTS/CTS HANDSHAKE NEEDED ?
        JNFS    BSX020          :JUMP IF SO
        RBT     R1,BSCCTS-BSXINT,RAD    :INIT CTS ON
        LIS     R0,CHALT        :GET HALT COMMAND
        JFS     BSX030          :GO HALT CURRENT I/O

BSX020  LA      R0,BSCCTS-BSXINT,RAD    :SET 2ND WORD, BASE ADDR OF BIT ARRAY
        ST      R0,4,RAD
        LIS     R0,CRTSOF       :SET 3RD WORD, RTS OFF
        STH     R0,8,RAD
        LIS     R0,CHALT        :SET 5TH WORD, HALT COMMAND
        STH     R0,10,RAD
        LIS     R0,CCTS         :SET 1ST WORD, COMMAND\BISYNC LINE NO.
        EXHR    R0,R0           :POSITION
        OR      R0,R1           :(INCLUDE BISYNC LINE NUMBER)
BSX030  ST      R0,0,RAD        :WRITE 1ST COMMAND (PERHAPS ONLY)
        LB      RLUN,XLUN,R1    :GET LOGICAL UNIT NUMBER

        IF BSXTSW;      JAL R4,BSXTRC;  EI      :BSXTSW
        SVC     IOCTRL,FORCEO^4+RLUN    :CONNECT INPUT
        JAL     R10,CRASH               :CRASH IF CALLING ERROR

        JR      R5              :RETURN TO CALLER

:       START INPUT AND HALT PROTOCOL DRIVER CALLER
BSX100  ST      R0,BSXTIM,RL2,RL2       :SAVE TIME TO FORCE XMT OP COMPLETE
        ST      R5,BSXRTA,RL2,RL2       :SAVE RETURN ADDRESS
        STH     R1,BSXOPC,RL2   :SAVE OP CODE
        STH     R2,BSXCNT,RL2   :SAVE DATA HW CNT
        STH     R3,BSXDAT,RL2   :SAVE DATA CHAIN ADDRESS

        LHL     R5,BSX1ST,RL2   :GET ADDRESS OF 1ST XMT PROCESS
        JAL     RRET,RSEG,R5    :GO START XMT
        ST      R5,XRUNL,RL2,RL2        :PUT NEXT PROCESS ON XMT RUN LIST

        J       PHALT           :REMOVE PROTOCOL DRIVER (CALLER) FROM RUN LIST


:       TURN ON REQUEST TO SEND (RTS)
:       -----------------------------
:       FOR BISYNC LINES THAT ARE CONFIGURED SUCH, THIS IS THE 1ST
:       PROCESS EXECUTED WHEN XMT STARTS

BSXRTS  L       RAD,XLISTX,RL2,RL2      :GET ADDR OF LINES XMT LIST
        LIS     RCMD,CRTSON     :PUT 'TURN RTS ON' ON LIST
        STH     RCMD,0,RAD
        LIS     RCMD,CCTS       :PUT CONNECT CTS CMD ON LIST
        STH     RCMD,8,RAD      :
        STH     RL,0A,RAD       :PUT COUNT(RL) ON LIST
        LA      R0,BSCCTS,,     :BASE ADDRESS OF BIT ARRAY
        ST      R0,0C,RAD       :PUT IT ON LIST
        LIS     RCMD,CHALT      :PUT HALT CMD ON LIST
        STH     RCMD,10,RAD
        SBT     RL,BSCCTS,,     :TURN CTS OFF
        LB      RLUN,XLUN,RL    :GET LOGICAL UNIT NO. FOR LINE

        IF BSXTSW;      JAL R4,BSXTRC;  EI      :BSXTSW
        IF      HSTSWT
        SVC     IOCTRL,FORCEO^4+RLUN    :FORCE OUTPUT
        JAL     R10,CRASH               :CRASH IF CALLING ERROR
        ELSE
        SVC     IOCTRL,CONNECT^4+RLUN    :CONNECT OUTPUT
        NOP     
        EI

        JALR    R5,RRET         :RETURN TO CALLER


:       WATCH FOR CLEAR TO SEND (CTS)
:       -----------------------------
:       BEFORE DATA CAN BE SEND ON SOME LINES, CTS MUST BE SUPPLIED
:       FROM MODEM.  FOR THESE LINES, RTS HAS BEEN TURNED ON.
:       OP TIMER IS WATCHED CMD ABORTED IF IT TAKES TOO LONG

BSXCTS  TBT     RL,BSCCTS,,     :CTS YET ?
        JEFS    BSXW00          :YEP, GO QUEUE WRITE COMMANDS

        L       R2,BSXTIM,RL2,RL2       :GET FASTC TIME TO STOP OP
        JEFS    BSXCT2                  :JUMP NOT CHECKING
        S       R2,FASTC,,              :TIME UP ?
        JLE     BSXOTM                  :JUMP IF SO

BSXCT2  JAL     R5,XDMISS       :NOPE, DISMISS
        JBS     BSXCTS          :GO CHECK AGAIN


:       QUEUE WRITE COMMANDS
:       --------------------
:       DECODE XMT OP CODE, AND PUT WRITE COMMAND FOR CONTROL MSG OR
:       DATA ON XMT LIST.  FOR LINES THAT REQUIRE RTS/CTS HANDSHAKE,
:       'TURN OFF RTS' COMMAND IS PUT AT END OF WRITE LIST.
:       NOTE THAT FOR LINES NOT REQUIRING RTS/CTS HANDSHAKE, ENTRY
:       IS MADE AT 'BSXWRT'.

BSXW00  LA      RRET,XDMISS     :SET DISMISS PROCESS AS CALLER

BSXWRT  L       RAD,XLISTX,RL2,RL2      :GET ADDR OF LINES XMT LIST
        LM      RCMD,SYNMOP     :START COMMAND LIST WITH SYN'S
        STM     RCMD,0,RAD

        LHL     RCMD,BSXOPC,RL2 :GET OP CODE
        JE      BSXW05          :GO WRITE DATA
        CLHI    RCMD,MAXOPC     :CHECK OP CODE
        JLE     BSXW10          :BRANCH LEGAL
        JAL     R10,CRASH       :ILLEGAL CALL CRASH

:
: SEND SINGLE BUFFER TRANSMITS
:       HOST - STATUS MESSAGE
:       TERM - POLL OR SELECT MESSAGE
: THIS HANDLES A SINGLE MESSAGE IN A DEDICATED BUFFER WHOSE ADDRESS
: IS IN LNBUFLT.  OTHERWISE, THE DATA MESSAGE IS IN THE COMMAND LIST.
:
BSXW05  LHL     RDAT,BSXDAT,RL2         :GET BUFFER ADR OF DATA
        CH      RDAT,LNBUFLT,RL2        :IS IT DEDICATED BUFFER MSG?
        JN      BSXW30                  :N - GO SEND MSG IN CMDLST
        LHL     RCNT,BSXCNT,RL2         :GET MESSAGE COUNT OF BYTES
        LI      RCMD,CWRITE^10,RCNT     :FETCH WRITE MSG CODE
        LI      RDAT,BBUFER,RDAT        :GET ABSOLUTE ADR OF MSG BUFFER
        STM     RCMD,8,RAD              :STORE INTO ROTOR
        J       BSXW13                  :GO FINISH SENDING THE MSG
:
:       SEND CONTROL MSG.  LOOK UP MSG IN TABLE AND PUT WRITE COMMAND
:       ON LIST.
:
BSXW10  SLHLS   RCMD,3          :MAKE DOUBLE WORD INDEX
        LM      RCMD,WCRTLM-8,RCMD      :FETCH COMMAND TO WRITE CONTROL MSG
        STM     RCMD,8,RAD              :PUT ON LIST
: FINISH SENDING THE CONTROL MSG OR THE SINGLE BUFFER MESSAGE
:       PUT PADS AT END OF MSG TO INSURE COMPLETE MSG GETS OUT
BSXW13  TBT     RL,RTSCTS       :FULL OR HALF DUPLEX?
        JNFS    BSXW14
        LM      RCMD,PAD2MOP    :FULL DUPLEX...
        STM     RCMD,10,RAD     :2 PADS
        J       BSXW15
BSXW14  LM      RCMD,PAD6MOP     :HALF DUPLEX...
        STM     RCMD,10,RAD     :6 PADS

:       PUT 'TURN OFF RTS' ON LIST (RTS/CTS HANDSHAKE NEEDED FOR HALF DUPLEX)
        AIS     RAD,8           :ADVANCE LIST POINTER
        LIS     RCMD,CRTSOF     :PUT 'TURN RTS OFF' ON LIST
        STH     RCMD,10,RAD

:       END LIST AND START OPERATION
BSXW15  LIS     RCMD,CSBT       :GET SET BIT COMMAND
        EXHR    RCMD,RCMD       :POSITION
        OR      RCMD,RL         :INCLUDE BISYNC LINE NUMBER
        LA      RDAT,BSXOCP,,   :GET ADDR BIT ARRAY
        STM     RCMD,18,RAD     :PUT CMD / ADDR ON LIST

        LIS     RCMD,CHALT      :END LIST WITH HALT CMD
        STH     RCMD,20,RAD
        RBT     RL,BSXOCP,,     :RESET OP COMPLETE FLAG

        LB      RLUN,XLUN,RL            :GET LOGICAL UNIT NO. FOR LINE
        L       RAD,XLISTX,RL2,RL2      :GET LIST ADDR FOR LINE

        IF BSXTSW;      JAL R4,BSXTRC;  EI      :BSXTSW
        IF      HSTSWT
        SVC     IOCTRL,FORCEO^4+RLUN    :FORCE OUTPUT
        JAL     R10,CRASH               :CRASH IF CALLING ERROR
        ELSE
        SVC     IOCTRL,CONNECT^4+RLUN   :CONNECT OUTPUT
        NOP                             :JUST CONTINUE IF ERROR
        EI

        JALR    R5,RRET                 :RETURN TO PROCESS ACTIVATOR
        J       BSXCOM
BSXWCR  JAL     R10,CRASH               :CRASH
        WC      0

:
: SEND DATA MESSAGE - EACH BUFFERLET FROM BACKGROUND CORRESPONDS TO
: ONE COMAND LINK.  FERTHERMORE, THE BUFFERLET HAS ITS FIRST PART
: OF SIZE BSXWSZ EMPTY FOR ISIS XMT COMMANDS TO BE
: INSERTED IN THIS SECTION.  THE NUMBER OF DATA BYTES FOR EACH BUFFERLET
: IS ASSUMED TO BE EVEN EXCEPT THE LAST.
:
BSXW30
        IF      DYNBUF
        LB      RDEV,CDEV,RL            :GET DEVICE # (RDEV=RCNT=R11)
        LIS     R0,0
        STH     R0,NRSTRT,RDEV,RDEV     :ZERO # OF RESTARTS OF CMD ROTOR
        STH     R0,NDXMT,RDEV,RDEV      :ZERO # OF TRANSMITTED BYTES
        EI

:	TIMESTAMP XMT OF MESSAGE (STX)
	LH	R0,ST.ON,,		:ARE WE TIMESTAMPING
	JL	BSXW31			:IF NOT, SKIP AHEAD
	CLB	R0,CDEV,RL		:IS THIS THE RIGHT DEVICE
	JN	BSXW31			:IF NOT, SKIP AHEAD
	LH	R0,ST.FLG,,		:CHECK FLAG, WE ONLY SAVE 2ND STX XMITTED
	AIS	R0,1			:(FIRST IS STX OF SELECT MSG)
	STH	R0,ST.FLG,,
	JNFS	BSXW31
	LB	R5,ST.DSP+1,,		:GET DISPLACEMENT
	L	R0,FASTC,,		:GET CURRENT TIME IN FASTC
	ST	R0,ST.ST7,R5,		:AND SAVE TIME

:	RESPONSE TIME TRACING, CALCULATE AND SAVE RESPNSE TIME OF MSG
BSXW31	LH	R0,RE.ON,,		:ARE WE TRACING RESPONSE TIME
	JL	BSXW32			:IF NOT, SKIP AHEAD
	CLB	R0,CDEV,RL		:IS THIS THE RIGHT DEVICE
	JN	BSXW32			:IF NOT SKIP AHEAD
	LH	R0,RE.FLG,,		:IS THIS 2ND STX (1ST IS FOR SELECT)
	AIS	R0,1
	STH	R0,RE.FLG,,
	JG	BSXW32			:IF NOT SKIP AHEAD
	L	R0,FASTC,,		:GET CURRENT TIME IN FASTC
	S	R0,RE.MST,,		:CALCULATE NUMB OF TICKS OF RESPONSE
	AM	R0,RE.RSP,,		:INCREMENT TICK COUNT
	LIS	R0,1
	AHM	R0,RE.NMB,,		:BUMP MSG COUNT
	STH	R0,RE.FLG,,		:NEXT STX NOT NECESSARILY FIRST

BSXW32	LHL     R0,BSXWR0,RL2           :GET CONTROL BYTES OF 1ST MSG
        THI     R0,XPRBIT               :TRANSPARENT DATA?
        JN      BSXW33                  :Y - JUMP
        LI      RCMD,CSPAD^10+RSYN^8+RSYN       :N-SET PADDING TO SYN SYN
        JFS     BSXW34
BSXW33  LI      RCMD,CSPAD^10+RDLE^8+RSYN       :Y-SET PADDING TO DLE SYN
BSXW34  STM     RCMD,8,RAD              :STORE CMD INTO ROTOR
:
: AFTER SETTING THE PADDING FOR TIME FILLS (FOR THE CASE WE DO NOT GET THE
: DATA IN TIME, PUT INTO THE ROTOR THE COMMAND TO TRANSFER TO THE
: BEGINNING OF THE DATA BUFFER FOR MORE COMMANDS.
:
        LI      RCMD,CJUMP^10           :LOAD WITH THE TRASFER CMD
        LHL     RDAT,BSXDAT,RL2         :GET THE 1ST BUFFER ADR
        AI      RDAT,BBUFER             :COMPLETE THE ADR
        STM     RCMD,8*2,RAD            :STORE CMD INTO THE ROTOR
:
: PUT COMMANDS INTO THE BUFFERLET ITSELF
:
        LIS     RCNT,0                  :INIT THE COUNT OF BUFFERS
        LHL     RLUN,BSXCNT,RL2         :# OF DATA BYTES IN THE BUFFER
        LR      RAD,RDAT                :FULL ADR OF BUFFER

BSXW40  LR      RL8,RL                  :GET LINE # INDEX
        SLLS    RL8,3                   :CONVERT TO DOUBLE WORD INDEX
        RBT     RCNT,BSXWBIT,RL8,       :RESET BIT TO INDICATE DATA NOT SENT YET
        THI     R0,ETBBIT!ETXBIT        :AT LAST BUFER OF MSG?
        JN      BSXW50                  :Y - JUMP
        THI     R0,ENQBIT               :ABORT MSG?
        JE      BSXW42                  :N - JUMP
        LHI     R5,SENQ-PSEG            :SET STATE
        STH     R5,STATE,RL2            :TO HANDLE ABORT MSG
        J       BSXW50
: INSERT WRITE DATA COMMAND
BSXW42  IF      DYNBUF
        LB      R5,CDEV,RL              :GET DEVICE #
        AHM     RLUN,NDXMT,R5,R5        :ACCUMULATE # OF BYTES TRANSMITTED
        EI
        LI      RCMD,CWRITE^10,RLUN      :WRITE CMD WITH # OF DATA BYTES
        LI      RDAT,BSXWSZ,RAD         :DATA BUFFER ADR OFFSET TO WHERE DATA STARTS
        STM     RCMD,0,RAD              :STORE CMD INTO "ROTOR"
: INSERT SET BIT COMMAND TO INDICATE DATA HAS BEEN SENT
        LI      RCMD,CSBT^10,RCNT       :SET BIT CMD WITH BIT # TO SET
        LA      RDAT,BSXWBIT,RL8,       :ADR OF BIT ARRAY
        STM     RCMD,8,RAD              :STORE INTO "ROTOR"
:INSERT HALT COMMAND
        LI      RCMD,CHALT^10           :GET HALT COMMAND
        LIS     RDAT,0                  :ZERO ADR FIELD (FOR DEBUGGING)
        STM     RCMD,8*2,RAD            :STORE INTO "ROTOR"
:SEND THE COMMANDS IN THE ROTOR TO ISIS FOR OUTPUT
        JAL     R5,BSXSOUT              :SAVES PTR AND CNT
        JFS     BSXW46
:
: RETURN AND COME BACK TO PROCESS NEXT BUFFER
:
BSXW44  JALR    R5,RRET                 :RETURN TO ACTIVATOR
        LA      RRET,XDMISS             :RRET IS BAD IF CALLED FROM RUN LIST
BSXW46  LB      RDEV,CDEV,RL            :GET DEVICE # (RDEV=RCNT,R11)
        NXTCMD(XMT,RDEV,RDEV)
        LR      R2,R2                   :CHECK # OF DATA BYTES
        JE      BSXW44                  :NONE - SO RETURN
        IF      TSTSWT
        JLBS    .                       :CONTOL MSG - ERROR
        ELSE    
        JL      BSXW46                  :CONTROL MSG - SKIP IT
        EI
:
: RLUN = R2 = # OF DATA BYTES, RAD = R3 = BUFFER ADR, R0 = CONTROL BYTE
: INCREMENT CNT AND PROCESS THIS BUFFER
:
        AI      RAD,BBUFER              :MAKE FULL ADR
        LB      RCNT,BSXWCNT,RL         :RESTORE CNT
        AIS     RCNT,1                  :INCREMENT CNT
        CLHI    RCNT,MAXBCT             :INSURE CNT DOES NOT EXCCED MAX
        JLE     BSXW40                  :OK - PROCESS BUFFER
        IF      TSTSWT
        JBS     .                       :BAD - LOOP
        ELSE
        JAL     R10,CRASH               :BAD - CRASH
        WC      0
        EI

:****************************************************************************
:
: BSXSOUT - SEND THE COMMANDS IN THE ROTOR TO ISIS FOR OUTPUT.
:       RAD  - ADR OF CURRENT MESSAGE BUFFER
:       RLUN - # OF DATA BYTES IN CURRENT MESSAGE BUFFER
:       RCNT - COUNT OF MESSAGE BUFFERS ALREADY SENT
:
BSXSOUT LR      RDAT,RAD                :SAVE ADR TO CURRENT MSG BUFFER
        LR      RCNT,RCNT               :IS THIS THE 1ST BUFFER OF MSG?
        JN      BSXS10                  :N - JUMP
        LB      RLUN,XLUN,RL            :GET LOGICAL UNIT #
        L       RAD,XLISTX,RL2,RL2      :GET ADR TO ROTOR
        J       BSXS40                  :GO SEND THE COMMANDS
:
: CHECK IF PREVIOUS BUFFER HAS BEEN SENT.  IF YES, START ROTOR AT THIS
: CURRENT BUFFER.  IF NO, INSERT TRANSFER COMMAND INTO PREVIOUS BUFFER
: AND START ROTOR AT PREVIOUS BUFFER.
:
BSXS10  LR      RTMP,RCNT               :GET PREVIOUS CNT
        SIS     RTMP,1
        TBT     RTMP,BSXWBIT,RL8,       :HAS PREVIOUS BUFFER BEEN SENT?
        JN      BSXS20                  :Y - JUMP
        L       RLUN,BSXWPTR,RL2,RL2    :GET PTR TO PREVIOUS BUFFER
        LI      RCMD,CJUMP^10           :GET TRANSFER COMMAND CODE
        LR      RDAT,RAD                :ADR TO CURRENT BUFFER
        STM     RCMD,8*2,RLUN           :INSERT CMD TO PREVIOUS BUFFER
: CHECK FOR RACE CONDITION IF PREVIOUS BUFFER HAD NOT BEEN SENT
        TBT     RTMP,BSXWBIT,RL8,       :HAS PREVIOUS BUFFER BEEN SENT NOW?
        JE      BSXS50                  :N - NO NEED TO START THE ROTOR
        LHL     RTMP,8*2,RLUN
        JE      BSXS50
        JFS     BSXS30                  :Y - START ROTOR AT PREVIOUS BUFFER
: PREVIOUS BUFFER ALREADY SENT...
: MUST INCREMENT "X" (BECAUSE WE ARE TOO FAST, SO XMT BUFFER SIZE MUST INCREASE)
: AND START ROTOR AT CURRENT BUFFER
BSXS20
        IF      DYNBUF
        LB      RTMP,CDEV,RL            :GET DEVICE NUMBER
        LIS     R4,1                    :INCREMENT EACH TIME WE ARE TOO FAST
        AHM     R4,NRSTRT,RTMP,RTMP     :STORE FOR BACKGROUND TO CALCULATE
        EI
:
: START THE ROTOR
:
BSXS30  LB      RLUN,XLUN,RL            :GET LOGICAL UNIT #
BSXS40
        IF      BSXTSW  
        JAL     R4,BSXTRC
        EI

        L       R4,RRINGX,RL2,RL2       :UPDATE EMPTY PTR TO THE FILL PTR
        LHL     R4,0,R4
        STH     R4,RRGETX,RL2

        IF      HSTSWT
        SVC     IOCTRL,FORCEO^4+RLUN    :FORCE THE XMT
        JAL     R10,CRASH               :CRASH IF FAIL
        ELSE
        SVC     IOCTRL,CONNECT^4+RLUN   :START THE XMT
        NOP                             :IF FAILED, JUST SKIP IT
        EI
:
: SAVE CURRENT BUFFER ADR AND CURRENT BUFFER COUNT
:
BSXS50  ST      RDAT,BSXWPTR,RL2,RL2     :BUFFER ADR
        STB     RCNT,BSXWCNT,RL         :COUNT
        JR      R5
:****************************************************************************
:
: AN ETB OR ETX OR ENQ WAS RECEIVED..RESET THE PADDING,SEND THE LAST PARTIAL
: AND SEND A PAD TO INSURE PROPER SYNCHRONIZATION.
:
BSXW50  LI      RCMD,CSPAD^10+0FFFF     :CMD TO RESET PADDING TO FFFF
        LIS     RDAT,0
        STM     RCMD,0,RAD
:IF PARTIAL COUNT IS ODD, MAKE EVEN # OF BYTES BY INSERTING AN EXTRA FF
        IF      DYNBUF
        LB      R5,CDEV,RL
        AHM     RLUN,NDXMT,R5,R5        :ACCUMULATE # OF BYTES TRANSMITTED
        EI
        THI     RLUN,1                  :IS # OF BYTES ODD?
        JEFS    BSXW52                  :N - JUMP
        LCS     R5,1                    :GET AN FF
        STB     R5,BSXWSZ,RAD,RLUN      :STORE INTO LAST POSITION
        AIS     RLUN,1                  :INCREMENT # OF BYTES
: INSERT COMMAND TO SEND OUT LAST PARTIAL
BSXW52  LI      RCMD,CWRITE^10,RLUN     :GET WRITE CMD
        LI      RDAT,BSXWSZ,RAD         :GET ADR OF START OF DATA
        STM     RCMD,8,RAD              :STORE INTO "ROTOR"
: INSERT "JUMP TO MAIN ROTOR" COMMAND INTO THE BUFFER
        LI      RCMD,CJUMP^10           :GET TRASNFER CMD CODE
        L       RDAT,XLISTX,RL2,RL2     :GET ADR OF MAIN ROTOR FOR THIS LINE
        AHI     RDAT,8*3                :SKIP OVER CMDS ALREADY INSERTED
        STM     RCMD,8*2,RAD            :STORE CMD INTO "ROTOR"
: INSERT "SEND A PAD" COMMAND TO INSURE COMPLETE MSG GETS OUT
        LR      RTMP,RDAT               :GET ADR OF MAIN ROTOR, OFFSETTED
        TBT     RL,RTSCTS               :FULL OR HALF DUPLEX?
        JN      BSXW58
        LM      RCMD,PAD2MOP            :FULL DUPLEX...
        STM     RCMD,0,RTMP             :SEND 2 PADS
        J       BSXW60
BSXW58  LM      RCMD,PAD6MOP            :HALF DUPLEX...
        STM     RCMD,0,RTMP             :SEND 6 PADS
: INSERT "TURN OFF RTS" COMMAND (RTS/CTS HANDSHAKE NEEDED FOR HALF DUPLEX)
        AIS     RTMP,8                  :INCREMENT BASE ADR OF ROTOR
        LIS     RCMD,CRTSOF             :GET "TURN OFF RTS" CMD
        STH     RCMD,0,RTMP             :STORE INTO MAIN ROTOR
: INSERT "SET BIT" COMMAND TO INDICATE END OF THE OPERATION
BSXW60  LI      RCMD,CSBT^10,RL         :GET SET BIT CMD
        LA      RDAT,BSXOCP,,           :GET ADR OF OP COMPLETE BIT ARRAY
        STM     RCMD,8,RTMP             :STORE INTO MAIN ROTOR
        RBT     RL,BSXOCP,,             :RESET OPERATION COMPLETE FLAG
: INSERT THE HALT COMMAND AND SEND EVERYTHING
        LIS     RCMD,CHALT              :GET HALT COMMAND CODE
        STH     RCMD,8*2,RTMP           :STORE INTO MAIN ROTOR
        JAL     R5,BSXSOUT              :SEND CMDS TO ISIS FOR OUTPUT

:	TIMESTAMP XMT END OF MSG (ETX)
	LH	R0,ST.ON,,		:ARE WE TIMESTAMPING
	JLFS	BSXW65			:IF NOT, SKIP AHEAD
	CLB	R0,CDEV,RL		:IS THIS THE RIGHT DEVICE
	JNFS	BSXW65			:IF NOT, SKIP AHEAD
	LB	R5,ST.DSP+1,,		:GET DISPLACEMENT
	L	R0,FASTC,,		:GET CURRENT TIME IN FASTC
	ST	R0,ST.ST8,R5,		:AND SAVE TIME

BSXW65	JALR    R5,RRET                 :RETURN TO ACTIVATOR


:       WATCH FOR OPERATION COMPLETE
:       ----------------------------
:       SYNC I/O UNIT DRIVER WILL SET-BIT FOR LINE WHEN COMMAND LIST FOR XMT
:       IS COMPLETE (CMD TO SBT WAS PUT AT END OF LIST).  WATCH FOR SIGNAL
:       AND CHECK TIMER TO SEE IF OPERATION IS TAKING TOO LONG.

BSXCOM  L       R2,RRINGX,RL2,RL2       :SYNCHRONIZE EMPTY INDEX TO
        LHL     R2,0,R2                 : CURRENT FILL RING INDEX
        TBT     RL,BSXOCP,,             :XMT OP COMPLETE?
        JN      BSXOEN                  :JUMP IF SO
        STH     R2,RRGETX,RL2           : (AVOIDS WRAP AROUND)
        L       R2,BSXTIM,RL2,RL2       :GET FASTC TIME TO STOP OP
        JEFS    BSXC10                  :JUMP NOT CHECKING
        S       R2,FASTC,,              :TIME UP ?
        JLEFS   BSXOTM                  :JUMP IF SO

BSXC10  JAL     R5,XDMISS       :GO DISMISS
        J       BSXCOM          :CHECK AGAIN


:       XMT TIMEOUT
:       -----------
:       XMT OPERATION DID NOT COMPLETE WITHING TIME SPECIFIED BY USER.
:       HALT OPERATION AND TURN RTS OFF IF NECESSARY

BSXOTM  L       RAD,XLISTX,RL2,RL2      :GET ADDR LINE'S XMT LIST
        TBT     RL,RTSCTS       :RTS/CTS HANDSHAKE NEEDED ?
        JEFS    BSXOT2          :JUMP IF NOT
        LIS     RCMD,CRTSOF     :PUT 'TURN OFF RTS' ON LIST
        STH     RCMD,0,RAD
        AIS     RAD,8           :GO TO NEXT LIST ENTRY

BSXOT2  LIS     RCMD,CHALT      :PUT HALT ON LIST
        STH     RCMD,0,RAD

        LB      RLUN,XLUN,RL            :GET LOGICAL UNIT NO. FOR LINE
        L       RAD,XLISTX,RL2,RL2      :GET LIST ADDR FOR LINE

        IF BSXTSW;      JAL R4,BSXTRC;  EI      :BSXTSW
        IF      HSTSWT
        SVC     IOCTRL,FORCEO^4+RLUN    :FORCE OUTPUT
        JAL     R10,CRASH               :CRASH IF CALLING ERROR
        ELSE
        SVC     IOCTRL,CONNECT^4+RLUN   :CONNECT THE OUTPUT
        NOP
        EI

        LIS     RCMD,XMTTMO     :FLAG XMT TIMEOUT
        JFS     BSXOE1          :GO ACTIVATE PROTOCOL DRIVER


:       XMT OP COMPLETE
:       ---------------
:       TAKE US OFF THE XMT RUN LIST AND PUT US ON THE PROTOCOL RUN LIST.
:       WHEN ACTIVATED, RETURN TO ORIGNAL CALLER WITH OPERATION RESULTS.

BSXOEN  LIS     RCMD,XMTOK      :FLAG OP OK
BSXOE1  STB     RCMD,BSXRTC,RL  :SAVE

:	TIMESTAMP XMT OF MSG COMPLETE
	LH	R0,ST.ON,,		:ARE WE TIMESTAMPING
	JLFS	BSXOE5			:IF NOT, SKIP AHEAD
	CLB	R0,CDEV,RL		:IS THIS THE RIGHT DEVICE
	JNFS	BSXOE5			:IF NOT, SKIP AHEAD
	LB	R5,ST.DSP+1,,		:GET DISPLACEMENT
	L	R0,FASTC,,		:GET CURRENT TIME
	ST	R0,ST.ST9,R5,		:AND SAVE TIME

BSXOE5
        IF      DYNBUF
        LB      R5,CDEV,RL
        CHI     R5,0FF          :SENDING GENERAL POLL?
        JE      BSXOE8          :JUMP IF YES
        LIS     RAD,0
        STH     RAD,NDXMT,R5,R5 :END OF MSG...ZERO COUNT OF TRANSMITTED
BSXOE8
        EI

        LA      RAD,BSXEND      :PUT US ON PROTOCOL RUN LIST
        ST      RAD,PRUNL,RL2,RL2
        J       XHALT           :DISCONNECT LINE FROM TRANSMIT RUN LIST

:       PROTOCOL RUN LIST ACTIVE, RETURN TO CALLER
BSXEND  LB      R0,BSXRTC,RL    :GET RETURN CODE
        L       R5,BSXRTA,RL2,RL2       :GET RETURN ADDR
        JR      R5                      :RETURN

        IF      BSXTSW
:       XMT OUTPUT LIST TRACE
:       ---------------------
:       THIS ROUTINE TRACES TRANSMIT OPERATIONS BY COPYING THE XMT LIST
:       GIVEN TO THE SVC TO A CIRCULAR TRACE BUFFER.  FORMAT OF THE TRACE IS:
:
:       1234 1234 LUN(2) ADDR(2) LIST(8) ... LIST(8) 0(2) GARBABE(6)
:
:       1234    FLAGS START OF TRACE ENTRY, 4 BYTES
:       LUN     LOGICAL UNIT NUMBER OF LINE, 2 BYTES
:       ADDR    LAST HW OF ADDRESS OF SVC, 2 BYTES
:       LIST    XMT LIST ENTRY, 8 BYTES
:       0       END OF THIS XMT LIST, 2 BYTES
:       GAR     GARBAGE AT END OF LIST, 6 BYTES
:
:       BSXTBL  TRACE TABLE, BSXTSW K-BYTES LONG
:       BSXTRX  NEXT ENTRY IN TRACE TABLE TO BE FILLED (HALF-WORD)

BSXTRC  TBT     RL,BSXBIT       :DO WE WANT TO TRACE THIS LINE?
        JER     R4              :N - RETURN
        STM     R12,BSXTSV      :SAVE WORK REGISTERS
        LHL     R13,BSXTRX      :GET TRACE BUFFER INDEX
        LI      R14,12341234    :FLAG START OF TRACE
        ST      R14,BSXTBL,R13,
        STH     RLUN,BSXTBL+4,R13,      :SAVE LOGICAL UNIT NO.
        STH     R4,BSXTBL+6,R13,        :SAVE ADDR OF SVC
        AIS     R13,8           :ADVANCE TRACE INDEX
        CLHI    R13,BSXTSW*400
        JLFS    .+4
        LIS     R13,0

        LR      R12,RAD         :COPY ADDR OF LIST
BSXTR2  LM      R14,0,R12       :COPY LIST ENTRY
        STM     R14,BSXTBL,R13,
        AIS     R12,8           :UPDATE LIST INDEX
        AIS     R13,8           :UPDATE TRACE INDEX
        CLHI    R13,400*BSXTSW
        JLFS    .+4
        LIS     R13,0

        SRL     R14,10,0        :END OF LIST ?
        JNBS    BSXTR2          :JUMP IF NOT
        STH     R13,BSXTRX      :SAVE TRACE INDEX
        LM      R12,BSXTSV      :RESTORE REG'S
        JR      R4              :RETURN

        SEG     0
BSXTSV  WS      10-R12          :REG SAVE AREA
BSXTRX  HC      0               :TRACE TABLE INDEX
BSXBIT  HC      0               :BIT ARRAY FOR WHICH LINE TO TRACE
        SEG     A.RING
BSXTBL  WS      0
        RE BSXTSW;      BS 400; ER
        SEG     1
        EI      :BSXTSW

        EM

	SUBTTL	Big Bufferlet Package	- BBFLET.LIB
:******************************************************************
:
:	This program is the sole property and confidential
:	information of Tymshare, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.
:
:*******************************************************************
	RA	0

:	This package contains all code and storage allocation needed for
:	dynamic allocation of big bufferlets.  It contains no routines
:	which manage data in big bufferlets.  Such routines are left to
:	be written by the user.

:	This is the two level re-entrant version (all routines can be called
:	by both foreground and background).


:	the following parameters MUST be defined before assembly:
:	NBBFLT	the number of big bufferlets to create.  Two of them will
:		"never" be allocated, to avoid possible race conditions
:		and unraveling of the free list.  This can't be
:		counted on, however, since it is possible for one of the
:		unusable 2 to get allocated if things are timed in just the
:		right order.
:	BBFLSZ	the size (in bytes) of a big bufferlet, MUST be even

:	the following parameters are defined for the user:
:	BBUFER	base address of big bufferlet storage area

:	the following external routines are used:
:	CRASH	JAL R10,CRASH performed if catistrophic theoretically
:		impossible conditions occur

:	The big bufferlets are kept in a double linked free list
:	from which they are allocated when needed.  The pointers
:	used are relative to BBUFER.

:	The package contains both utility and primitive routines:

:	utility routines are called with link on RLINK1
:	PBBC   -Put Big Bufferlet Chain
:		RCH = pointer to 1st big bufferlet in chain
:		PBBC will return a chain of big bufferlets to the dynamic pool


:	primitive routines are called with link on RLINK
:	IZBB   -Initialize Big Bufferlets
:		initializes big bufferlet double linked list used to
:		dynamically allocate big bufferlets.
:	GBB    -Get Big Bufferlet
:		Return	       -No Big Bufferlet is available
:		Skip return    -RCH has pointer to big bufferlet, chain
:				half-word in big bufferlet set to zero
:	PBB    -Put Big Bufferlet
:		RCH has pointer to big bufferlet to return to dynamic pool

:       Debugging modes:  (active if symbol defined as a positive number)
:               BBF.D1  Count GBB and RBB calls in global cell 'BUFCNT'.
:                       When all bufferlets put back, BUFCNT=0.  Crash if
:                       BUFCNT<0.
:
:               BBF.D2  Software crash when no bufferlets available on
:                       GBB call.  This fixes lost bufferlet problem.
:
:               BBF.D3  On all returns of BB to chain, check BB addr. range.
:			CRASHES IF NOT VALID RANGE.

	GL	NBBFLT,BBFLSZ
	MO	.,BBUFER
	GL	IZBB,GBB,PBB,PBBC,BBUFER	:PROVIDED TO USER
	GL	CRASH				:EXTERNAL ROUTINES NEEDED

:	REGISTER USAGE DEFINITION
RCH	EQ	R3		:REG WITH BUFFERLET ADDR
RLINK	EQ	R4		:LINKAGE FOR IZBB,GBB,PBB
RLINK1	EQ	R5		:LINKAGE FOR PBBC
RW1	EQ	R6		:WORK REG FOR IZBB,GBB,PBB
RW2	EQ	R7		:WORK REG FOR IZBB,GBB,PBB
RW3	EQ	R2		:WORK REG FOR PBBC


:       DEBUGGING OPTIONS
  IF	\SNOBUF
  ELSE
SNOBUF	EQ	0		:DON'T SIMULATE NO BUFFERLETS EVER
  EI

  IF \BBF.D1
  ELSE
BBF.D1	EQ	0
  EI

  IF \BBF.D2
  ELSE
BBF.D2	EQ	0
  EI

  IF \BBF.D3
  ELSE
BBF.D3	EQ	0
  EI

:	DATA AREA
	SEG	A.DATA
FREE1	HC	0		:INDEX OF HEAD OF LIST 1
FREE2	HC	0		:INDEX OF HEAD OF LIST 2
LOCK1	HC	0		:8000 = LIST 1 LOCKED DUE TO RE-ENTRANTCY
LOCK2	HC	0		:8000 = LIST 2 LOCKED DUE TO RE-ENTRANTCY
        GL        BUFCNT
BUFCNT  HC      0       : CNT OF REMAINING FREE BUF.

:	BUFFERLET AREA
	SEG	A.BUFF		:ALLOCATE IN BUFFER AREA
	HS	0		:ALLIGN TO HALF-WORD

NBBMAX  EQ      ((A.BUFF+1)*10000-.-2)/BBFLSZ   :MAX # OF BUFFERLETS 
        IF      NBBMAX
        ELSE
        REMARK  %*** WARNING...NO SPACE AVAILABLE FOR BUFFERLETS
        EI
        IF      NBBFLT
        IF      NBBFLT-NBBMAX
NBBFLT  EQ      NBBMAX          :MAX EXCEEDED, SO REDEFINE NBBFLT TO MAX
        REMARK  %*** WARNING...NBBFLT TOO BIG, RESET TO MAXIMUM
        EI
        ELSE
NBBFLT  EQ      NBBMAX          :NEG NBBFLT REQUESTS MAXIMUM
        EI

BBUFER	EQ	.-2		:BASE ADDRESS OF BUFFERLET AREA
	BS	NBBFLT*BBFLSZ	:BUFFERLET AREA SIZE
CHAIN1	EQ	BBUFER+BBFLSZ-2 :ADDRESS OF FORWARD CHAIN HW IN BUFFERLET
CHAIN2	EQ	CHAIN1-2	:ADDRESS OF BACKWARD CHAIN
	SEG	A.CODE

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::			 S U B R O U T I N E   I Z B B			     ::
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

IZBB	LIS	RCH,2		:RCH = RELATIVE ADDR OF BUFFERLET
	STH	RCH,FREE1	:INIT FREE CHAIN
	LHI	RW1,NBBFLT	:RW1 = NO. BUFLETS IN FREE LIST

IBB10	SIS	RW1,1		:DEC BUFFERLET CNT
	JEFS	IBB20		:JUMP TO TERMINATE CHAIN
	STH	RCH,CHAIN2+BBFLSZ,RCH,	:BACKWARD LINK IN NEXT BB
	AHI	RCH,BBFLSZ	:FIND NEXT BUFFERLET START
	STH	RCH,BBUFER-2,RCH,	:SET CHAIN TO IT
	JBS	IBB10
IBB20	STH	RCH,FREE2	:HEAD OF LIST 2

        LHI     RW1,NBBFLT-1
            STH     RW1,BUFCNT      : INIT. FREE BUF. CNT 
          IF BBF.D3
        LIS     RW1,0
            STH     RW1,BBCKLK      :Init stack pointer
          EI
	LIS	RW1,0		:SET BIT POINTER
	RBT	RW1,LOCK1	:RESET LIST 1 LOCK
	RBT	RW1,LOCK2	:RESET LIST 2 LOCK
	JR	RLINK

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::			  S U B R O U T I N E	G B B			     ::
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

GBB     LCS     RW1,1           : DEC. FREE BUF. CNT
        AHM     RW1,BUFCNT
        JLE     NOBBF1          : EXIT IF NO FREE BUF.
	LIS	RW1,0		:INIT FOR BIT TESTS
                IF      SNOBUF          :SIMULATE NO BUFFER AVAILABLE
                :-:-:-:-:-:-:-:-:-:-:-:  ERROR SIMULATE :-:-:-:-:-:-:-:-:-:-:-:
                LCS     RW2,1           :COUNT ENTRY                          :
                AHM     RW2,SNOBCT                                            :
                JGFS    SNOBRT          :JUMP NOT TIME TO SIMULATE            :
                LHI     RW2,SNOBUF      :RESET ERROR SIMULATE CNTR            :
                STH     RW2,SNOBCT                                            :
                JR      RLINK           :TAKE NO BUFFERLET AVAILABLE RETURN   :
                SEG     A.DATA                                                 :
SNOBCT          HC      SNOBUF          :ERROR COUNTER                        :
                SEG     A.CODE                                                :
SNOBRT          EQ      .                                                     :
                :-:-:-:-:-:-:-:-:-:-:-:  ERROR SIMULATE :-:-:-:-:-:-:-:-:-:-:-:
                EI      :SNOBUF
	SBT	RW1,LOCK1	:LIST 1 LOCKED ?
	JN	GBB20		:JUMP IF SO, TRY LIST 2
	LHL	RCH,FREE1	:GET INDEX TO NEXT FREE BUFFERLET
        CLH     RCH,FREE2       :EQUAL TO INDEX OF LIST2?
        JE      NOBBF1          :Y - NO BUFFER
	LH	RW2,CHAIN1,RCH, :GET CHAIN TO NEXT FREE BUFFERLET
	STH	RW2,FREE1	:PUT IN FREE POINTER
	STH	RW1,CHAIN1,RCH, :ZERO CHAIN FOR BUFFERLET FETCHED
	STH	RW1,CHAIN2,RCH, :ZERO CHAIN FOR BUFFERLET FETCHED
	RBT	RW1,LOCK1	:UNLOCK LIST 1
	J	4,RLINK 	:SKIP RETURN (BUFFERLET FOUND)

:	LIST 1 WAS LOCKED OR EMPTY, TRY LIST 2.
:	IF LIST 2 EMPTY OR LOCKED, RETURN.  THEORETICALLY, BOTH
:	LISTS WILL NEVER BE LOCKED (IF THEY ARE, IT
:	IS A DESIGN ERROR THAT PBB WILL DETECT AND CRASH).

:       PROGRAM BUG - BOTH ENDS OF LIST LOCKED
BUFERR  JAL     R10,CRASH,,
        BC      0,0,4*RLINK,0D0 : CRASH WITH DIAG. CODE
NOBBUF	EQ	.
        LIS     RW1,1
        AHM     RW1,BUFCNT              : RESTORE BUF. CNT
          IF BBF.D2
            JAL       R10,CRASH       :No bufferlet crash
            BC        0,0,4*RLINK,0D2
          EI
	JR	RLINK		:RETURN (CAN'T PROVIDE BUFFERLET)

NOBBF1	RBT	RW1,LOCK1	:UNLOCK
	J	NOBBUF

GBB20   SBT     RW1,LOCK2       : TRY LIST 2
        JN      BUFERR          :   BOTH ENDS LOCKED - PGM. BUG
        LHL     RCH,FREE2       : GET LINK PTR
GBB30	LH	RW2,CHAIN2,RCH, :GET CHAIN TO NEXT BUFFERLET
	STH	RW2,FREE2	:PUT AT HEAD OF LIST 2
	STH	RW1,CHAIN1,RCH, :ZERO CHAIN FOR BUFFERLET FETCHED
	STH	RW1,CHAIN2,RCH, :ZERO CHAIN FOR BUFFERLET FETCHED
	RBT	RW1,LOCK2	:UNLOCK LIST 2
	J	4,RLINK 	:SKIP RETURN (BUFFERLET FOUND)


:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::			  S U B R O U T I N E	P B B			     ::
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::


PBB     EQ      .               :Start of routine PBB

	  IF BBF.D1
        LH      RW1,BUFCNT      : GET BUF. CNT
        CHI     RW1,NBBFLT-1    : COMPARE TO MAX POSSIBLE
        JLFS    PBB01           :   LESS - OK
            JAL       R10,CRASH       :Crash if too many put back
            BC        0,0,4*RLINK,0D1
          EI

PBB01	LIS	RW1,0		:INIT FOR BIT TESTS
	SBT	RW1,LOCK1	:LIST 1 LOCKED ?
	JN	PBB20		:JUMP IF SO, TRY LIST 2

PBB10	EQ	.
	  IF BBF.D3
	    JAL	RW2,BBCK	:Check BB range
	  EI
	LHL	RW2,FREE1	:GET INDEX TO 1ST FREE BUFFERLET
	STH	RW2,CHAIN1,RCH, :ONE WE'RE PUTTING BACK CHAINS TO IT
	STH	RCH,CHAIN2,RW2, :AND VICE VERSA
	STH	RCH,FREE1	:ONE PUTTING BACK NOW 1ST FREE
PBB15	RBT	RW1,LOCK1	:UNLOCK LIST 1
        LIS     RW1,1
        AHM     RW1,BUFCNT
	JR	RLINK		:RETURN

:	LIST 1 LOCKED, TRY LIST 2.  IF IT IS LOCKED ALSO,
:	IT IS CONCEIVABLE THAT IT IS DUE TO A RACE CONDITION, SO CHECK
:	LIST 1 AGAIN.  IF ITS LOCKED, THAT'S INCONCEIVABLE, CRASH.

PBB20	SBT	RW1,LOCK2	:LIST 2 LOCKED ?
	JEFS	PBB30		:JUMP IF NOT, PUT ON IT
	SBT	RW1,LOCK1	:LIST 1 STILL LOCKED ?
	JE	PBB10		:JUMP IF NOT, PUT ON LIST 1
	JAL	R10,CRASH	:LISTS LOCKED UP TIGHT, CRASH
	BC	0,0,4*RLINK,0D0	:CRASH CODE

PBB30	EQ	.
	  IF BBF.D3
	    JAL	RW2,BBCK	:Check BB range
	  EI
	LHL	RW2,FREE2	:GET INDEX TO 1ST BUFFERLET IN LIST 2
	STH	RW2,CHAIN2,RCH, :ONE WE'RE PUTTING BACK CHAINS TO IT
	STH	RCH,CHAIN1,RW2, :AND VICE VERSA
	STH	RCH,FREE2	:ONE PUTTING BACK NOW AT HEAD OF LIST 2
PBB40	RBT	RW1,LOCK2	:UNLOCK LIST 2
        LIS     RW1,1           : INC. FREE BUF. CNT
        AHM     RW1,BUFCNT
	JR	RLINK		:RETURN

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::			 S U B R O U T I N E   P B B C			     ::
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

PBBC	LHL	RW3,CHAIN1,RCH, :GET INDEX OF NEXT BUFFERLET IN CHAIN
	JAL	RLINK,PBB	:PUT THIS BUFFERLET BACK
	LR	RCH,RW3 	:GET NEXT IN CHAIN
	JNBS	PBBC		:PUT IT BACK TOO
	JR	RLINK1		:END OF CHAIN (0), RETURN


:Check range of BB address  (Only defined if BBF.D3 on)

  IF BBF.D3
BBCK	SBT	RW1,BBCKLK	:SET LOCK FOR REENTRANCY
	JEFS	BBCK1
	LIS	RW1,8		:CHOSE OTHER LOCK
	SBT	RW1,BBCKLK
	JNFS	BBCK2		:CRASH IF SET, CAN'T HAPPEN
BBCK1	STM	R14,BBCKSV,RW1
	LR	R14,RCH		:DON'T ALLOW NEGATIVE
	SIS	R14,2
	JLFS	BBCKCR
	CI	R14,(NBBFLT-1)*BBFLSZ	:CHECK MAX ADDR
	JGFS	BBCKCR
	DH	R14,BBCKD	:ADDR MUST BE MULTIPLE OF SIZE
	LR	R14,R14
BBCK2	JNFS	BBCKCR		:REM NOT 0, NOT EXACT MULTIPLE
	LM	R14,BBCKSV,RW1	:RESTORE REGS STACKED
	RBT	RW1,BBCKLK	:RELEASE LOCK
	LIS	RW1,0		:RESTORE RW1
	JR	RW2
BBCKCR	JAL	R10,CRASH	:RCH=BAD CHAIN ADDR
	BC	0,0,4*RLINK,0D3	:CRASH CODE
BBCKD	HC	BBFLSZ
	SEG	A.DATA
BBCKSV	HS	(2*2)*2
BBCKLK	HC	0		:STACK PNTR
	SEG	A.CODE
  EI

	EM

        SUBTTL  PRO-BISYNC PROTOCAL DRIVER
        RA      0
        MO      .,BSCPTP
        GL      SPCHRS,DEVADR,FDEVL,DEVCU,CUADR,FDEV,FCU
        GL      CMDCNT,BUFCNT,CMDLO,BUFLO
        GL      LCMMODE
        GL      XMTFSH
        GL      PTPTSW
        GL      FLXMT
        GL      REVTAB,CMDLK
        GL      CKSPAC
        GL      RCVERR
        GL      GTAB,RGRP,NGRMX
        GL      CUPOLL,POLLCU
        GL      BSCPTP
        GL      NBILM,NCUM,NDEVM,NGRMX,NBILIN,NCU,NDEV
        GL      RCVRST,XMTUCN,XMTSEQ,XMTZAP
        GL      NDEVB,NCUB
        GL      BSCXER,BSCETM,BSCFRO,BSCLCM,BSCLBL,BSCBAL
        GL      PTPHLT :!!!!!!!!!!!!!DEBUG!!!!!!!
        GL      NPRCV,RPRCV,GPRCV,PPRCV,CCRCV,DCRCV,RCVDAT,RCVGAT
        GL      PPXMT,GPXMT,CCXMT,XMTDAT,DCXMT,XMTGAT
	GL	XMTTOT,RCVTOT,PLLTO,RXMT,XERR,NAKS,RERR,ZCNT
	GL	E.PTO,E.RTN,E.XRR,E.NAK,E.RRR,E.LIN,E.TIM,E.SHRT
	GL	PR.ALR,PR.TCK,PR.ON,PR.NMB,PR.PLL,PR.SAV
	GL	ST.SIZ,ST.BEG
	GL	PTPTTB,PTPTRX,PTRBIT
        GL      fstpol,polcnt,lstpol
        LO      BSCRRC          :ACCESS BISYNC RCV OP RETURN CODES
        LO      BSCSXM          :ACCESS BISYNC XMT OP CODES
        LO      BSCEXC          : ACCESS BISYNC F.G. EXEC MODULE
        LO      BSCCHR          :BISYNC CONTROL CHAR DEFINITIONS
DERR    MACRO(ETYP)
        [
        LHI     R3,ETYP         : LOAD ERROR TYPE
        JAL     R5,SETERR       : COUNT ERROR AND COMPARE TO LIMIT
                                : (REPORT TO B.G. IF LIMIT REACHED)
        ]

        SEG     0


:       POINT-TO-POINT CONDITION TIMERS
:       -------------------------------

TSCALE  EQ      2               :SCALING TO KEEP HALFWORD'S POSITIVE
TPS     EQ      RATE^(-TSCALE)  :SCALED TICKS PER SECOND
        RA      0A              :EXPRESS TIMES IN DECIMAL

TXMTOP  EQ      03*TPS  :TIME ALLOWED XMT OPERATION BEFORE ERROR ASSUMED
TXMTER  EQ      5*TPS   :TIME GIVEN TO MODEM TO SETTLE AFTER XMT OP ERROR
TBID    EQ      3*TPS   :TIME BETWEEN BIDS WHEN WE ARE BIDDING FOR LINE
TRDAT   EQ      60*TPS  :WAIT TIME AFTER ETB BLOCK FOR NEXT BEFORE ERROR ABORT
TREOT   EQ      3*TPS   :WAIT TIME AFTER ETX BLOCK BEFORE ASSUMING EOT MISSED
TDRVI   EQ      60*TPS  :BID DELAY TIME AFTER RVI GIVING REMOTE NO-CONTENTION
TDNRDY  EQ      3*TPS   :BID DELAY TIME WHEN REMOTE IS NOT READY TO RCV
TDWACK  EQ      2*TPS   :WAIT TIME FOR RESOURCES BEFORE SENDING WACK
TWACK   EQ      5*TPS   :WAIT TIME FOR RESPONSE TO WACK BEFORE GOING ON
TLCM    EQ      6*TPS   :WAIT TIME FOR RESPONSE TO LIMITED CONVERSATIONAL DATA
TDRESP  EQ      3*TPS   :WAIT TIME FOR RESPONSE TO XMT DATA BEFORE GOING ON
TDTTD   EQ      2*TPS   :WAIT TIME FOR OUTPUT COMMAND BEFORE SENDING TTD
TTTD    EQ      3*TPS   :WAIT TIME FOR RESPONSE TO TTD BEFORE GOING ON
TRXENQ  EQ      4*TPS   :WAIT TIME FOR 2ND ENQ IN TRANSMIT DATA MODE
TDRRTY  EQ      3*TPS   :TIME TO DELAY RCV RETRY ON RCV ABORT DUE TO NO 1ST BUF
 
        :       SELECT INTERVAL TIMES
SELT1   EQ      15*RATE : DELAY INTERVAL AFTER UNSUCC. SELECT
SELT2   EQ      90*RATE : INTERVAL AFTER FIRST UNSUCC. SELECT
                        : BEFORE CIRCUIT IS KILLED
:       :       TTD INTERVAL FOR TIME OUT
TTDTOT  EQ      90*RATE : CIRCUIT WILL BE KILLED IF TIMEOUT
        RA      0

 
 
:       ERROR TYPE CODES  (MESSAGE ID, ERROR CODE)
:       ----------------
:
: COMMAND/RESPONSE UNDELIVERED (MESSAGE ID = 10)
XMTEOT  EQ      1001    : GOT EOT TO OUR XMT
XMTRVI  EQ      1002    : GOT RVI TO OUR SELECT (TI)
XMTFF   EQ      1003    : DETECTED FACILITIES FAILURE
XMTTO   EQ      1004    : REPEATED TIMEOUT IN RESPONSE TO OUR XMTS
XMTNAK  EQ      1005    : REPEATED NAKS TO OUR XMTS 
XMTWAK  EQ      1006    : REPEATED WACKS TO OUR XMTS (SELECTS FOR TI)
XMTACK	EQ	1007	: REPEATED WRONG ACK TO OUR XMTS
XMTINV  EQ      1008    : INVALID MESSAGE FORMAT
XMTUR   EQ      1009    : UNRECOGNIZABLE RESPONSE FROM REMOTE
XMTUCN  EQ      1010    : BAD UCN
XMTSEQ  EQ      1011    : MESSAGE OUT OF SEQUENCE
XMTCU   EQ      1012    : CU NOT RESPONSE TO POLL
XMTETO  EQ      1013    : TIME OUT WAIT FOR ETX OR ETB AFTER STX
XMTZAP  EQ      1020    : CIRCUIT ZAP
: COMMAND/RESPONSE ABORTED (MESSAGE ID = 11)
RCVFF   EQ      1103    : FACILITIES FAILURE
RCVTO   EQ      1104    : TIMEOUT
RCVNAK  EQ      1105    : N NAKS SENT
RCVSTE  EQ      110A    : GOT REPEATED DATA ABORT (STX...SUB...ENQ)
RCVACK  EQ      1110    : REPEAT REQUEST TO RESEND ACK'S
RCVTTD  EQ      1111    : NO ETX AFTER ETB ... SENT REPEAT TTD'S
RCVRST  EQ      1112    : RECEIVED CIRCUIT RESET FROM HOST PAD
:
RCVERR  EQ      0100    : TEST BIT INDICATING A "RCV" TYPE ERROR
:
:
 

:       BASE ADDRESS FOR MODULE
:       -----------------------

PSEG    EQ      SEG1


:       TRACE OPTIONS   - PTPTSW SHOULD BE SET INN COM FILE
:       -------------

RCURRC  BS      1               : SAVE AREA FOR CURRENT RCV RETURN CODE
 
 
GPDEV   EQ      07F
PADCHR  EQ      0FF
GPMSG   EQ      0
SPMSG   EQ      1
SELMSG  EQ      2

        : POLLING PROTOCOL DATA TABLES
        :       NBILM - NO  BISYNC LINES MAX
        :       NCUM  - NO  CONTROL UNITS MAX
        :       NDEVM - NO DEVICES MAX
NLNB    EQ      (NBILM-1)/10+1  : NO HWORDS IN LINE BIT TABLE
NCUB    EQ      (NCUM-1)/10+1   : NO HWORDS IN CU BIT TABLE
NDEVB   EQ      (NDEVM-1)/10+1  : NO HWORDS IN DEVICE BIT TABLE
 
        :       LINE TABLES
POLTYP  HS      NLNB            : TYPE OF POLL 0=SPECIFIC(OR NONE)
                                :              1=GENERAL
CCU     BS      NBILM           : CURRENT C.U. NO. 
CDEV    BS      NBILM           : CURRENT DEVICE NO. 
LSTXMT  BS      NBILM           : ETX/ETB CHAR FOR LAST MSG XMTED
RDPROC  HS      NBILM           : REL. ADDR OF ROUTINE FOR PROC.
POLCNT  HS      NBILM           : COUNT OF POLLS ISSUED
PTRBIT  WC      0               :PROTOCOL TRACE SWITCH (BY LINE)
                                : RCV. DATA MSG
 
 
        :       SAVE AREAS FOR SELECT LOGIC
DPSAV   HS      NBILM           : DATA PRESENT SAVE AREA
R2SAV   HS      NBILM           : REGISTER 2 SAVE AREA
ROFFSV  HS      NBILM           : REGISTER ROFF SAVE AREA
 
ROFF    EQ      0E              : REGISTER USED IN SELECT LOOP
 
        :       LMASK - ARRAY OF HALFWORD MASKS
        :       MASK I ZEROS BITS 0-(I-1)
LMASK   HC      0FFFF,07FFF,3FFF,1FFF
        HC      0FFF,7FF,3FF,1FF
        HC      0FF,7F,3F,1F
        HC      0F,7,3,1
        HC      0
 
LSENT   HS      NBILM           : LAST MSG TYPE SENT
LRCVD   HS      NBILM           : LAST MSG TYPE RCVD.
LNBUFLT HS      NBILM           : ADDRESS OF BUFFERLET USED FOR
REPOLL  HS      NBILM           : CNT OF TIMES CURRENT G.P. CAN BE RE-STARTED
 
        :       C.U. TABLES
POLLCU  RE      (NCUM-1)/10+1  : BIT ARRAY, 1 = CU IN POLLING LIST
        HC      0FFFF           : INITIALIZE POLLING LIST (ALL CU TO BE POLLED)
        ER
POLTYM  WS      NCUM            : TIME OF LAST POLL RESPONSE
LSTPOL  WS      NCUM            : TIME OF LAST POLL
FSTPOL  ws      nbilm           : time of first poll
 
        :       DEVICE TABLES
SELTYM  WS      NDEVM           : TIME OF LAST UNRESOLVED SELECT PROB.
NXTSEL  WS      NDEVM           : TIME FOR NEXT SELECT (USED FOR WACK DELAY)
 
 
 
        :       LEADING GRAPHICS VARIABLES
 
        :       GTAB HAS NGRMX CHARS OF SPACE FOR RCV
        :       LEADING GRAPHICS CHARS 
        :       A CHAR CNT PRECEDES EACH STRING AREA
GTAB    HS      0
        BS      NBILM*(NGRMX+1)
 
RGRP    HS      0               : PTRS TO RCV GRAPHICS AREA
                                : FOR EACH LINE
Q       EQ      0
        RE      NBILM
        HC      Q
Q       EQ      Q+NGRMX+1
        ER
 
RL      EQ      R8              : CURENT LINE NUMBER
RCU     EQ      R12             : CURRENT CU REGISTER
        :       EBCDIC CHARS IN 3270 MSG HEADING
RCHAR   EQ      0D9             : R
PERC    EQ      6C              : %
SLACHR  EQ      61              : /


OSTATE  WS      NBILIN          :OLD STATE (USED WHILE IN TTD MODE)


:       LOCAL VARIABLES
:       ---------------

        SEG     0
PTPRET  WS      1               :BSCPTP RETURN ADDR SAVE AREA

RCVTIM  WS      NBILIN          :RCV TIMEOUT SAVE FOR XMTRCV
XMTRET  WS      NBILIN          :RETURN ADDRESS FOR XMTRCV
WTIME   WS      NBILIN          :TIME IN FASTC TO ACTIVE AGAIN
TTDTIM  WS      NBILIN          :TIME IN FASTC TO STORE THE FIRST TIME SEND TTD
RCVBCT  HS      NBILIN          :RCV BUFFERLET LIMIT FOR XMTRCV
XMTCNT  HS      NBILIN          :HALFWORD DATA CNT FOR XMT
XDTRTE  HS      NBILIN          :HALFWORD DATA ADDR REL TO BBUFER FOR XMT
BDTIME  HS      NBILIN          :TIME TO DELAY BIDDING BY
STATE   HS      NBILIN          :STATE TABLE TO PROCESS CURRENT RCV BY
RSTIME   HS      NBILIN          :RESPONSE WAIT TIME FOR NEXT RCV OPERATION

LSTACK  HS      (NBILIN-1)/10+1 :LAST/NEXT ACK, 0=ACK0, 1=ACK1
LSTRVI  HS      (NBILIN-1)/10+1 : 1 = LAST ACK WAS RVI
RCVLCM  HS      (NBILIN-1)/10+1 :RCV/XMT DATA STARTED WITH LCM DATA MSG
PTPHLT  HS      (NBILIN-1)/10+1 :HALT PROTOCOL DRIVER BIT ARRAY

XMTOPC  BS      NBILIN          :XMT OP CODE FOR ROUTINE XMT
RETRY   BS      NBILIN          :RETRY COUNTER (COUNTS UP FROM 0)
RLRC    BS      NBILIN          :LAST RCV RETURN CODE IN RCV DATA MODE


:       GLOBAL VARIABLES
:       ----------------

BSCETM  WS      NBILIN          :FASTC TIME OF LAST UNRECOVERED ERROR, 0=NONE

BSCXER  HS      NBILIN          :COUNT OF XMT OP ERRORS FOR CURRENT OP
BSCLBL  HS      NBILIN          :BUFFERLET USAGE FOR LINE, -=OVERUSED

BSCFRO  HS      (NBILIN-1)/10+1 :FORCE OUTPUT BIT ARRAY
BSCLCM  HS      (NBILIN-1)/10+1 :LINE MAY SEND IN LIMITED CONVERSATIONAL MODE

BSCBAL  HS      1               :BUFFERLET USAGE FOR ALL LINES, -=OVERUSED

:	STORAGE FOR CURRENT LINE AND CURRENT TIME FOR DERR COMMAND
E.LIN	HC	E.DLIN		:DEFAULTED TO ALL LINES
E.TIM	HS	1		:CURRENT TIME (OR BIN NUMBER) FOR ERROR STORAGE
E.SHRT	HS	2		:ARRAY TO INDICATE THAT BIN NOT RESET AT BEGINNING
				:OF HOUR   1=NOT BEGINNING OF HOUR
        SEG     1

:       DECODE HALT/START COMMAND
BSCPTP  LR      R0,R0           :HALT/START ?
        JN      PTPON           :JUMP START, GO TURN ON

:       HALT PROTOCOL DRIVER
        SBT     R1,PTPHLT       :FLAG HALT IN CASE RUNNING

        LR      R2,R1           :MAKE LINE WORD INDEX
        SLHLS   R2,2

        LA      R3,RRUNOF       :RCV OFF ADDRESS
        LA      R4,XRUNOF       :XMT OFF ADDRESS
        LA      R6,PRUNOF       :PROTOCOL OFF ADDRESS

PTPOF2  ST      R3,RRUNL,R2     :TURN RCV OFF
        ST      R4,XRUNL,R2     :TURN XMT OFF
        ST      R6,PRUNL,R2     :TURN PROTOCOL

        C       R3,RRUNL,R2     :RCV OFF ?
        JNBS    PTPOF2          :RETRY IF NOT
        C       R4,XRUNL,R2     :XMT OFF ?
        JNBS    PTPOF2          :RETRY IF NOT
        C       R6,PRUNL,R2     :PROTOCOL OFF ?
        JNBS    PTPOF2          :RETRY IF NOT
        ST      R5,PTPRET       :SAVE RETURN ADDR
        LCS     R0,1
        JAL     R5,BSCSXM       :SHUT DOWN XMT 
        L       R5,PTPRET
        JR      R5              :RETURN


:       START PROTOCOL DRIVER
PTPON   LR      R2,R1           :MAKE LINE WORD INDEX
        JAL     R4,GBB          : GET A BIG BUFFERLET
        NOP
        STH     R3,LNBUFLT,R1,R1: STORE ADDRESS OF DEDICATED BUFFERLET
                                : FOR THIS LINE
        LIS     R4,0
        STH     R4,BSCXER,R1,R1 :RESET XMT ERROR CNTR
        SLHLS   R2,2
        ST      R4,BSCETM,R2    :RESET TIME LAST UNRECOVERED ERROR
        LA      R3,PLLP         : START PROTOCOL DRIVER
        ST      R3,PRUNL,R2
        RBT     R1,PTPHLT       : TURN DRIVER ON
:       INITIALIZE ALL CONTROL UNITS
        LB      RCU,FCU,R1,     : LOOP OVER CU S
PTPON1  LR      R4,RCU          : MAKE FULLWORD INDEX
        SBT     RCU,POLLCU      : BE SURE ALL CU ARE IN POLLING LIST
        SLHLS   R4,2
        L       R6,FASTC,,      : GET CURR. TIME
        ST      R6,POLTYM,R4    : LAST POLL RESP. = NOW
        ST      R6,LSTPOL,R4    : LAST POLL SENT. = NOW
        AIS     RCU,1           : NEXT CU
        CLB     RCU,FCU+1,R1,   : THRU FOR THIS LINE ?
        JL      PTPON1          :   N - REPEAT
                                : LOOP OVER DEV. ON THIS LINE
        LHL     RDEV,FDEVL,R1,R1
PTPON2  
        LR      R4,RDEV         : SET UP FULLWORD DEVICE INDEX
        SLHLS   R4,2
        LIS     R6,0            : INIT SELECT ERROR TIME AND NXTSEL
        ST      R6,SELTYM,R4    : TO ZERO
        ST      R6,NXTSEL,R4
        IZCL(XMT,RDEV,RDEV)               : INITIALIZE XMT CMD LIST
        IZCL(RCV,RDEV,RDEV)               : INITIALIZE RCV CMD LIST
        AIS     RDEV,1          : NEXT DEVICE
        CLH     RDEV,FDEVL+2,R1,R1      : ANY MORE DEVICES ?
        JL      PTPON2
        JR      R5              :RETURN

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::      S Y N C   I / O   P R O C E S S E S   -   X M T R C V ,   R C V      ::
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::      THESE PROCESSES INTERFACE TO THE BISYNC I/O LIBRARY ROUTINES.        ::
::      WHEN RCV OP COMPLETE, RETURN CODE USED TO BRANCH THROUGH             ::
::      CURRENT STATE TABLE.                                                 ::
::                                                                           ::
:: XMTRCV - DO A XMT THEN RCV OPERATION                                      ::
::                                                                           ::
::      INPUT:  R0     -RCV TIMEOUT VALUE (HALF WORD IN FASTC TICKS)         ::
::              R1     -OP CODE FOR XMT                                      ::
::              R2     -XMT HW DATA CNT (HALFWORD)                           ::
::              R3     -XMT DATA CHAIN ADDRESS (HALFWORD REL TO BBUFER)      ::
::              R4     -BUFFERLET LIMIT FOR RCV OPERATION (HALFWORD)         ::
::                                                                           ::
::      OUTPUT: R1     -NO. RCV BUFFERLETS USED (IF DATA RCV'D)              ::
::              R2     -RCV RETURN CODE * 2                                  ::
::              R3     -RCV DATA CHAIN ADDRESS (IF DATA RCV'D)               ::
::                                                                           ::
::      LINK:          -STATE HAS CURRENT STATE TABLE.  RETURN MADE BASED    ::
::                      ON RCV RETURN CODE.  NON-DEDICATED REGS NOT SAVED.   ::
::                                                                           ::
:: RCV - DO A RCV OPERATION                                                  ::
::                                                                           ::
::      INPUT:  R0     -RCV TIMEOUT VALUE (IN FASTC TICKS)                   ::
::              R1     -BUFFERLET LIMIT FOR RCV OPERATION (HALFWORD)         ::
::                                                                           ::
::      OUTPUT:         SAME AS FOR XMTRCV                                   ::
::                                                                           ::
::      LINK:           SAME AS FOR XMTRCV                                   ::
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

XMTRCV  STH     R0,RCVTIM,RL2,RL2       : SAVE TIMEOUT VALUE
        STH     R4,RCVBCT,RL2   :SAVE RCV BUFFERLET LIMIT

        JAL     R5,XMT          :DO XMT WITH ERROR RECOVERY

        LHL     R1,RCVBCT,RL2   :GET BUFFERLET CNT
        LHL     R0,RCVTIM,RL2,RL2       : GET RCV TIMEOUT VALUE
        JFS     RCV010

RCV     STH     R1,RCVBCT,RL2   :SAVE BUFFERLET CNT FOR RETRY
                IF      PTPTSW          :TRACE STATES
                :-:-:-:-:-:-:-:-:-:-:-:-:-:  TRACE  :-:-:-:-:-:-:-:-:-:-:-:-::
                TBT     RL,PTRBIT       :TRACE THIS LINE?
                JE      RCV005          :N - SKIP
                LCS     R5,1            :FLAG INITIAL RCV AS XMT OP IN TRACE :
                STB     R5,XMTOPC,RL                                         :
RCV005
                :-:-:-:-:-:-:-:-:-:-:-:-:-:  TRACE  :-:-:-:-:-:-:-:-:-:-:-:-::
                EI      :PTPTSW
RCV010  SLLS    R0,TSCALE       :SCALE TIME VALUE
        JEFS    RCV020          :JUMP IF NOT
        A       R0,FASTC,,      :COMPUTE OP END-TIME
RCV020  ST      R0,RCVTIM,RL2,RL2       :SAVE END-TIME

RCV100  TBT     RL,PTPHLT       :HALT PROTOCOL DRIVER ?
        JN      PHALT           :JUMP IF SO
        JAL     R5,BSR100       :DO SINGLE RCV
        TBT     RL,PTPHLT       :HALT PROTOCOL DRIVER ?
        JN      PHALT           :JUMP IF SO
	SLHLS   R2,1            :MAKE RCV RETURN CODE HW INDEX
RCV110  LHL     R4,STATE,RL2    :GET RCV STATE TABLE REL ADDR
        LHL     R5,PSEG,R2,R4   :GET PROCESS REL ADDRESS
                IF      PTPTSW          :TRACE STATES
                :-:-:-:-:-:-:-:-:-:-:-:-:-:  TRACE  :-:-:-:-:-:-:-:-:-:-:-:-::
                TBT     RL,PTRBIT       :TRACE THIS LINE?
                JE      RCV115          :N - SKIP
                LHL     R6,PTPTRX       :GET TRACE TABLE INDEX               :
                LB      R0,XMTOPC,RL    :GET LAST XMT OP CODE                :
                EXBR    R0,R0           :POSITION                            :
                SLLS    R0,1                                                 :
                OR      R0,R2           :INCLUDE RCV RETURN CODE             :
                SRLS    R0,1                                                 :
                STH     R0,PTPTTB,R6,   :TRACE                               :
                STH     R4,PTPTTB+2,R6, :TRACE STATE                         :
                AIS     R6,4            :ADVANCE TRACE INDEX                 :
                CLHI    R6,PTPSIZ                                            :
                JLFS    .+4                                                  :
                LIS     R6,0                                                 :
                STH     R6,PTPTRX       :SAVE INDEX                          :
                SEG     0                                                    :
PTPTRX          HC      0               :TRACE INDEX                         :
		SEG	A.BOM
PTPTTB          HS      0               :TRACE TABLE                         :
		BS	PTPSIZ						     :
		BS	10						     :
                SEG     1                                                    :
RCV115
                :-:-:-:-:-:-:-:-:-:-:-:-:-:  TRACE  :-:-:-:-:-:-:-:-:-:-:-:-::
                EI      :PTPTSW
        J       PSEG,R5         :GO TO APPROPRIATE RCV PROCESS


:       RECEIVE RETRY
:       -------------
:       THIS PROCESS IS USED BY STATE TABLES TO RETRY THE LAST RCV
:       OPERATION AND WATCH OP END-TIME.  IT IS TYPICALLY
:       INVOKED ON LOST SYNCHRONIZATION RETURN CODE AND WILL RETRY THE
:       LAST OPERATION UNLESS OP END-TIME IS UP.  IN THAT CASE, IT FAKES
:       A RCV TIMEOUT RETURN CODE.

RCVRTY	LB	R1,CCU,RL		:GET CURRENT CONTROL UNIT
	LIS	R0,1
	AHM	R0,RERR,R1,R1		:BUMP RECEIVE ERROR COUNT
	LH	R1,E.LIN		:GET LINE FOR ERROR REPORTING (BINS)
	JLFS	RCVR05			:JUMP IF ALL LINES
	CR	R1,RL			:IS THIS THE RIGHT LINE
	JNFS	RCVR06			:NO, SKIP AHEAD
RCVR05	LHL	R1,E.TIM		:GET TIME (BIN NUMBER)
	AHM	R0,E.RRR,R1,R1		:BUMP COUNTER

RCVR06	LHL     R1,RCVBCT,RL2		:GET BUFFERLET CNT
                IF      PTPTSW          :TRACE STATES
                :-:-:-:-:-:-:-:-:-:-:-:-:-:  TRACE  :-:-:-:-:-:-:-:-:-:-:-:-::
                TBT     RL,PTRBIT       :TRACE THIS LINE?
                JE      RCVR10          :N - SKIP
                LCS     R0,2            :FLAG RCV RETRY AS XMT OP IN TRACE   :
                STB     R0,XMTOPC,RL                                         :
RCVR10
                :-:-:-:-:-:-:-:-:-:-:-:-:-:  TRACE  :-:-:-:-:-:-:-:-:-:-:-:-::
                EI      :PTPTSW
        L       R0,RCVTIM,RL2,RL2       :GET OP END-TIME VALUE
        JE      RCV100          :JUMP NOT KEEPING TIME
        CL      R0,FASTC,,      :END-TIME YET ?
        JG      RCV100          :JUMP IF NOT, RETRY OP
        LHI     R2,RCTMOT*2     :GET TIME-OUT RCV RETURN CODE
        J       RCV110          :GO HANDLE AS TIMEOUT

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::                        S U B R O U T I N E   X M T                        ::
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::      THIS ROUTINE IS THE INTERFACE TO THE SINGLE XMT LIBRARY ROUTINE      ::
::      AND HANDLES ITS ERROR RETURNS.  CURRENT PHILOSOPHY ON XMT ERROR      ::
::      IS TO COUNT ERROR AND RETURN TO CALLER .                         ::
::      THE ERROR WILL SHOW UP AS A MESSEAGE NOT RCVD. BY THE OTHER END.
::                                                                           ::
::      INPUT:  R1     -OP CODE FOR BSCSXM                                   ::
::              R2     -HW DATA CNT (HALFWORD)                               ::
::              R3     -DATA CHAIN ADDRESS (HALFWORD REL TO BBUFER)          ::
::                                                                           ::
::      OUTPUT:        -BSCXER INCREMENTED FOR EACH ERROR, RESET ON COMPLETE ::
::                                                                           ::
::      LINK:   R5     -NOTE THAT NO NON-DEDICATED REGISTERS ARE SAVED       ::
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

XMT     STB     R1,XMTOPC,RL    :SAVE XMT OP CODE
        STH     R2,XMTCNT,RL2   :SAVE XMT BUFFERLET CNT
        STH     R3,XDTRTE,RL2   :SAVE XMT DATA ADDR
        ST      R5,XMTRET,RL2,RL2       :SAVE RETURN ADDRESS

:       START XMT OP, IF OK WHEN DONE, RETURN
XMT050  LHI     R0,TXMTOP       :GET XMT OP WAIT TIME
        SLLS    R0,TSCALE*2     :SCALE
        A       R0,FASTC,,      :MAKE REAL END TIME
        TBT     RL,PTPHLT       :HALT PROTOCOL DRIVER ?
        JN      PHALT           :JUMP IF SO
        JAL     R5,BSX100       :GO DO SINGLE XMT OP
        TBT     RL,PTPHLT       :HALT PROTOCOL DRIVER ?
        JN      PHALT           :JUMP IF SO
        LR      R0,R0           :OP OK ?
        JNFS    XMT110          :JUMP IF NOT, FLAG ERROR AND RETRY
        STH     R0,BSCXER,RL2   :RESET ERROR CNTR
        L       R5,XMTRET,RL2,RL2       :GET RETURN ADDR
        JR      R5              :RETURN

:       XMT ERROR, COUNT, AND RETURN
XMT110  LIS     R0,1            :COUNT ERROR
        AHM     R0,BSCXER,RL2
 
:       RECORD ERROR IN FG MONITOR RING
 
        L       R5,XMTRET,RL2,RL2       : RETURN
        JR      R5

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::                     S U B R O U T I N E   S E T E R R                     ::
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::      THIS ROUTINE FLAGS THE OCCURANCE OF AN ERROR AND UPDATES THE         ::
::      RETRY COUNTER.  IF RETRY COUNT EXCEEDED, THE CURRENT OPERATION       ::
::      IS ABORTED AND THE REMOTE IS RESET TO IDLE MODE (EOT SENT).          ::
::      THE BACKGROUND MAY WATCH THE TIME OF THE LAST UNRECOVERED ERROR      ::
::      AND MAY TAKE ACTION (HANG USER) AS IT DEEMS FIT.  AN ERROR IS        ::
::      CONSIDERED RECOVERED WHEN A GOOD DATA BLOCK IS MOVED IN EITHER       ::
::      DIRECTION (BSCETM, TIME OF LAST ERROR, SET TO ZERO).                 ::
::                                                                           ::
::      INPUT:         -BSCETM HAS ZERO IF ERROR NOT OUTSTANDING.            ::
::                     -RETRY HAS RETRY COUNT FOR LINE.                      ::
::                     -BSCRTY IS NUMBER OF RETRIES TO ALLOW.                ::
::                                                                           ::
::      OUTPUT:        -RETURN TO CALLER RETRY CNT NOT EXCEEDED.             ::
::                     -RETURN TO IRESET IF RETRY COUNT EXCEEDED.            ::
::                                                                           ::
::      LINK:   R5     -NOTE THAT R0 NOT SAVED.                              ::
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

SETERR	LIS	R0,1			:PREPARE TO BUMP COUNTER
	LB	R6,CCU,RL		:GET CU NUMBER
	THI	R3,RCVERR		:IS IT A RECEIVE ERROR
	JN	SETER0			:JUMP IF NOT
	AHM	R0,XERR,R6,R6		:BUMP COUNT OF XMT ERRORS
	LH	R6,E.LIN		:GET LINE FOR ERROR REPORTING (BINS)
	JLFS	SETERA			:JUMP IF ALL LINES
	CR	R6,RL			:IS THIS THE RIGHT LINE
	JN	SETER1			:IF NOT , SKIP AHEAD
SETERA	LHL	R6,E.TIM		:GET TIME (BIN NUMBER)
	AHM	R0,E.XRR,R6,R6		:BUMP COUNTER
	JFS	SETER1

SETER0	AHM	R0,RERR,R6,R6		:BUMP COUNT OF RECEIVE ERRORS
	LH	R6,E.LIN		:GET LINE FOR ERROR REPORTING (BINS)
	JLFS	SETERB			:JUMP IF ALL LINES
	CR	R6,RL			:IS IT RIGHT LINE
	JNFS	SETER1			:NO, SKIP AHEAD
SETERB	LHL	R6,E.TIM		:GET TIME (BIN NUMBER)
	AHM	R0,E.RRR,R6,R6		:BUMP COUNTER

SETER1	L       R0,BSCETM,RL2,RL2       :ERROR OUTSTANDING ?
        JNFS    SETER2                  :JUMP IF SO
        L       R0,FASTC,,		:SET TIME OF UNRECOVERED ERROR
        ST      R0,BSCETM,RL2,RL2

SETER2  LB      R0,RETRY,RL		:UPDATE LINE'S RETRY CNTR
        AIS     R0,1
        STB     R0,RETRY,RL
                IF      PTPTSW          :TRACE STATES
                :-:-:-:-:-:-:-:-:-:-:-:-:-:  TRACE  :-:-:-:-:-:-:-:-:-:-:-:-::
                TBT     RL,PTRBIT       :TRACE THIS LINE?
                JE      SETER3          :N - SKIP
                STM     R14,PTPRSV      :SAVE REGISTERS                      :
                LHL     R14,PTPTRX      :GET TRACE TABLE INDEX               :
                LCS     R15,3           :FLAG ERROR RETRY AS XMT OP CODE     :
                SLHLS   R15,8           :POSITION                            :
                OR      R15,R0          :INCLUDE RETRY CNT                   :
                STH     R15,PTPTTB,R14, :TRACE                               :
:	CHANGED TO SAVE ERROR CODE FOR BOM BY TEB			     :
:               STH     R5,PTPTTB+2,R14,        :TRACE CALLERS ADDR          :
		STH	R3,PTPTTB+2,R14,	:TRACE ERROR TYPE	     :
                AIS     R14,4           :ADVANCE TRACE INDEX                 :
                CLHI    R14,PTPTSW^0A                                        :
                JLFS    .+4                                                  :
                LIS     R14,0                                                :
                STH     R14,PTPTRX      :SAVE INDEX                          :
                LM      R14,PTPRSV      :RESTORE REGISTERS                   :
                SEG     0                                                    :
PTPRSV          WS      2               :REGISTER SAVE AREA                  :
                SEG     1                                                    :
SETER3
                :-:-:-:-:-:-:-:-:-:-:-:-:-:  TRACE  :-:-:-:-:-:-:-:-:-:-:-:-::
                EI      :PTPTSW
        CLHI    R0,BSCRTY       :EXCEED LIMIT ON RETRIES ?
        JLER    R5              :RETURN TO CALLER IF NOT
        JAL     R5,GOTERR       : REPORT ERROR , ETC.
        J       IRESET          : THEN SEND EOT

:       GOTERR - WE HAVE GOT A PERSISTANT ERROR
:       ---------------------------------------
:       REPORT IT TO B.G. AND RESET CNTRS
:       R3 CONTAINS THE ERROR TYPE (MESSAGE ID, ERROR CODE)
:       R5 - LINK
GOTERR  LIS     R0,0
        STB     R0,RETRY,RL
        ST      R5,GOTE50       : SAVE RETURN ADDR.
        LB      RDEV,CDEV,RL    : GET DEVICE NO.
        CLHI    RDEV,0FF        : ARE WE POLLING
        JNFS    GOTE02          : N - GO CHECK DEVICE NUMBER
        LB      R6,CCU,RL       : GET CU #
        LB      RDEV,FDEV,R6    : GET FIRST DEVICE # TO REPORT
        J       GOTE05
:       IS THE DEVICE NO. IN RANGE FOR THIS CU ?
GOTE02  LB      R6,CCU,RL       : GET CU NNUMBER
        CLB     RDEV,FDEV,R6,   : COMPARE DEV.NO. TO FIRST DEV. FOR CU
        JLR     R5              :   RETURN IF DEV. NO. IS LESS
        CLB     RDEV,FDEV+1,R6, : COMPARE TO FIRST DEV. FOR NEXT CU
        JGER    R5              :   RETURN IF DEV. NO. IS GGREATER OR EQUAL
:       DEVICE NUMBER IS VALID - REPORT ERROR
GOTE05  THI     R3,RCVERR       : IS THIS A XMT OR RCV ERROR ?
        JN      GOTE10          :    RCV ERR - SKIP
: C/R UNDELIVERED (XMT)...NO NEED LCM, BUT GET SEQ # FROM XMT Q.
        LR      R7,RDEV         : SET UP FWORD INDEX
        SLHLS   R7,2
        LIS     R6,0
        ST      R6,SELTYM,R7    : CLEAR SELECT ERROR TIMER
        STH     R3,GOTE70       : SAVE ERROR TYPE
        PKCMD(XMT,RDEV,RDEV)
        NHI     R0,0FF          :ISOLATE SEQ #
        LR      R2,R0           : SAVE SEQ #
        JAL     R5,FLXMT        : FLUSH XMT QUEUE
        LR      R0,R2           : RESTORE SEQ #
        LHL     R3,GOTE70       :RESTORE ERROR TYPE
        J       GOTE20
: C/R ABORTED (RCV)...(1) GET SEQ # FROM DOSEQ IN DCB
:                     (2) GET STATE OF LCMBIT AND INSERT INTO ERROR CODE
GOTE10  LIS     R0,0            :SEQ # TO BE GOTTEN IN BACKGROUND!!
        TBT     RL,RCVLCM       :LIMITED CONVERSATIONAL MODE?
        JEFS    GOTE20          :N - LEAVE LCM = 0
        OHI     R3,LCMBIT^4     :Y - TURN ON LCM IN ERROR CODE
: PUT ERROR INTO COMMANDLIST FOR BACKGROUND TO PROCESS
: R0 = SEQ #,   R3 = ERROR TYPE
GOTE20  LHI     R2,ERRCMD       : CMD TYPE = ERROR
        PUTCMD(RCV,RDEV,RDEV)
        RLCMD(RCV,RDEV,RDEV)
        L       R5,GOTE50       : RESTORE RETURN ADDRESS
        JR      R5
 
        SEG     0
GOTE50  WS      1               : SAVE RETURN ADDR. HERE
GOTE70  HS      1               : SAVE ERROR TYPE HERE
        SEG     1
 
 
 
:       CHECK FOR ADEQUATE RESOURCES BEFORE POLLING
:       CHECK COMMAND LIST AND BUFFERLET FREE POOLS
CKSPAC  LHL     R0,CMDCNT       : GET NO. FREE CMD LINKS
        CHI     R0,CMDLO        : BELOW SAFE LIMIT ?
        JLR     R5              :   Y - STRAIGHT RETURN
        LHL     R0,BUFCNT       : GET NO. FREE BUFFERLETS
        CHI     R0,BUFLO        : BELOW SAFE LIMIT ?
        JLR     R5              :   Y - STRAIGHT RETURN
        J       4,R5            : RESOURCES OK - SKIP RETURN
 
 

:       RESPONSE TO SELECT MSG : SXSEL
:       ---------------------------
:       WE HAVE SENT A SELECT MSG SO WE CAN SEND DATA.

SXSEL   HC      PCRASH-PSEG     :GOOD DATA ETX BLOCK
        HC      PCRASH-PSEG     :GOOD DATA ETB BLOCK
        HC      BADSR-PSEG      :ENQ
        HC      BADSR-PSEG      :EOT
        HC      BADSR-PSEG      :NAK
        HC      BADSR-PSEG      :DLE,EOT (DISCONNECT SIGNAL)
        HC      BADSR-PSEG      :ACK1
        HC      BADSR-PSEG      :WACK
        HC      XINIT-PSEG      :ACK0
        HC      IRRVI-PSEG      :RVI
        HC      PCRASH-PSEG     :TTD (STX,ENQ)
        HC      PCRASH-PSEG     :MULTI-LEAVING BIG (SOH,ENQ)
        HC      PCRASH-PSEG     :DATA ABORT (ENQ,EOT,NAK IN TEXT)
        HC      RCVRTY-PSEG     :LOST SYNCHRONIZATION
        HC      BADSR-PSEG      :OVERRUN (MORE DATA THAN BUFFERLETS SPECIFIED)
        HC      BADSR-PSEG      :NO INITIAL BUFFERLET AVAILABLE
        HC      BADSR-PSEG      :TIMEOUT BEFORE MSG RECEIVED
        HC      PCRASH-PSEG     :CRC ERROR IN DATA MESSAGE
        HC      PCRASH-PSEG     :LOST DATA DUE TO INAVAILABILITY OF BUFFERLET
        HC      RCVRTY-PSEG     :UNIDENTIFIABLE MSG
        HC      PCRASH-PSEG     :FORCED COMPLETION BY BACKGROUND


:       RECEIVE DATA INITIAL : SRINIT
:       -----------------------------
:       WE HAVE SENT A POLL MSG. THIS TABLE HANDLES THE RESPONSE.

SRINIT  HC      RDATAX-PSEG     :GOOD DATA ETX BLOCK
        HC      RDATAB-PSEG     :GOOD DATA ETB BLOCK
        HC      BADPR-PSEG      :ENQ
        HC      PREOT-PSEG      :EOT
        HC      BADPR-PSEG      :NAK
        HC      BADPR-PSEG      :DLE,EOT (DISCONNECT SIGNAL)
        HC      BADPR-PSEG      :ACK1
        HC      BADPR-PSEG      :WACK
        HC      BADPR-PSEG      :ACK0
        HC      BADPR-PSEG      :RVI
        HC      RBAD-PSEG       :TTD (STX,ENQ)
        HC      BADPR-PSEG      :MULTI-LEAVING BIG (SOH,ENQ)
        HC      RBAD-PSEG       :DATA ABORT (ENQ,EOT,NAK IN TEXT)
        HC      RCVRTY-PSEG     :LOST SYNCHRONIZATION
        HC      RBAD-PSEG       :OVERRUN (MORE DATA THAN BUFFERLETS SPECIFIED)
        HC      RWTRTY-PSEG     :NO INITIAL BUFFERLET AVAILABLE
        HC      BADPR-PSEG      :TIMEOUT BEFORE MSG RECEIVED
        HC      RBAD-PSEG       :CRC ERROR IN DATA MESSAGE
        HC      RBAD-PSEG       :LOST DATA DUE TO INAVAILABILITY OF BUFFERLET
        HC      RCVRTY-PSEG     :UNIDENTIFIABLE MSG
        HC      PCRASH-PSEG     :FORCED COMPLETION BY BACKGROUND


:       RESPONSE TO RCV'S OUTPUT OF WACK : SRWACK
:       -----------------------------------------
:       RCV IS WAITING ON RESOURCES AND HAS OUTPUT WACK TO REMOTE TELLING
:       IT TO WAIT FOR POSITIVE ACKNOWLEDGEMENT BEFORE CONTINUING TO RECEIVE
:       DATA.

SRWACK  HC      PCRASH-PSEG     :GOOD DATA ETX BLOCK
        HC      PCRASH-PSEG     :GOOD DATA ETB BLOCK
        HC      RSWACK-PSEG     :ENQ
        HC      RREOT-PSEG      :EOT
        HC      RCVRTY-PSEG     :NAK
        HC      RCVRTY-PSEG     :DLE,EOT (DISCONNECT SIGNAL)
        HC      RCVRTY-PSEG     :ACK1
        HC      RCVRTY-PSEG     :WACK
        HC      RCVRTY-PSEG     :ACK0
        HC      RCVRTY-PSEG     :RVI
        HC      PCRASH-PSEG     :TTD (STX,ENQ)
        HC      PCRASH-PSEG     :MULTI-LEAVING BIG (SOH,ENQ)
        HC      PCRASH-PSEG     :DATA ABORT (ENQ,EOT,NAK IN TEXT)
        HC      RCVRTY-PSEG     :LOST SYNCHRONIZATION
        HC      RCVRTY-PSEG     :OVERRUN (MORE DATA THAN BUFFERLETS SPECIFIED)
        HC      RCVRTY-PSEG     :NO INITIAL BUFFERLET AVAILABLE
        HC      RSWACK-PSEG     :TIMEOUT BEFORE MSG RECEIVED
        HC      PCRASH-PSEG     :CRC ERROR IN DATA MESSAGE
        HC      PCRASH-PSEG     :LOST DATA DUE TO INAVAILABILITY OF BUFFERLET
        HC      RCVRTY-PSEG     :UNIDENTIFIABLE MSG
        HC      PCRASH-PSEG     :FORCED COMPLETION BY BACKGROUND


:       RECEIVE DATA CONTINUE : SRCV
:       ----------------------------
:       THE REMOTE HAS SENT 1ST DATA BLOCK.  THIS HANDLES RECEPTION
:       OF SUBSEQUENT DATA BLOCKS.

SRCV    HC      RDATAX-PSEG     :GOOD DATA ETX BLOCK
        HC      RDATAB-PSEG     :GOOD DATA ETB BLOCK
        HC      RRSACK-PSEG     :ENQ
        HC      RREOT-PSEG      :EOT
        HC      RCVRTY-PSEG     :NAK
        HC      RCVRTY-PSEG     :DLE,EOT (DISCONNECT SIGNAL)
        HC      RCVRTY-PSEG     :ACK1
        HC      RCVRTY-PSEG     :WACK
        HC      RCVRTY-PSEG     :ACK0
        HC      RCVRTY-PSEG     :RVI
        HC      RBAD-PSEG       :TTD (STX,ENQ)
        HC      RBAD-PSEG       :MULTI-LEAVING BIG (SOH,ENQ)
        HC      RDABT-PSEG      :DATA ABORT (ENQ,EOT,NAK IN TEXT)
        HC      RCVRTY-PSEG     :LOST SYNCHRONIZATION
        HC      RBAD-PSEG       :OVERRUN (MORE DATA THAN BUFFERLETS SPECIFIED)
        HC      RWTRTY-PSEG     :NO INITIAL BUFFERLET AVAILABLE
        HC      RTMOT-PSEG      :TIMEOUT BEFORE MSG RECEIVED
        HC      RBAD-PSEG       :CRC ERROR IN DATA MESSAGE
        HC      RBAD-PSEG       :LOST DATA DUE TO INAVAILABILITY OF BUFFERLET
        HC      RCVRTY-PSEG     :UNIDENTIFIABLE MSG
        HC      PCRASH-PSEG     :FORCED COMPLETION BY BACKGROUND


:       RESPONSE TO TRANSMISSION OF DATA : SXMT
:       ---------------------------------------
:       WE HAVE CONTROL OF LINE AND HAVE SENT A DATA BLOCK TO THE REMOTE.

SXMT    HC      XRDATA-PSEG     :GOOD DATA ETX BLOCK
        HC      XRDATA-PSEG     :GOOD DATA ETB BLOCK
        HC      XRBAD-PSEG      :ENQ
        HC      IPSRVI-PSEG     :EOT
        HC      XRSDAT-PSEG     :NAK
        HC      XRBAD-PSEG      :DLE,EOT (DISCONNECT SIGNAL)
        HC      XRACK1-PSEG     :ACK1
        HC      XRAK20-PSEG     :WACK
        HC      XRACK0-PSEG     :ACK0
        HC      XRBAD-PSEG      :RVI
        HC      XRBAD-PSEG      :TTD (STX,ENQ)
        HC      XRBAD-PSEG      :MULTI-LEAVING BIG (SOH,ENQ)
        HC      XRBAD-PSEG      :DATA ABORT (ENQ,EOT,NAK IN TEXT)
        HC      RCVRTY-PSEG     :LOST SYNCHRONIZATION
        HC      XRBAD-PSEG      :OVERRUN (MORE DATA THAN BUFFERLETS SPECIFIED)
        HC      XRBAD-PSEG      :NO INITIAL BUFFERLET AVAILABLE
        HC      XTMOT-PSEG      :TIMEOUT BEFORE MSG RECEIVED
        HC      XRBAD-PSEG      :CRC ERROR IN DATA MESSAGE
        HC      XRBAD-PSEG      :LOST DATA DUE TO INAVAILABILITY OF BUFFERLET
        HC      RCVRTY-PSEG     :UNIDENTIFIABLE MSG
        HC      PCRASH-PSEG     :FORCED COMPLETION BY BACKGROUND






:       RESPONSE TO AN ABORT MESSAGE (ENQ) THAT WAS SENT TO REMOTE
:       ----------------------------------------------------------
:       WE HAVE JUST SENT AN ENQ TO REMOTE

SENQ    HC      PCRASH-PSEG     :GOOD DATA ETX BLOCK
        HC      PCRASH-PSEG     :GOOD DATA ETB BLOCK
        HC      PCRASH-PSEG     :ENQ
        HC      PCRASH-PSEG     :EOT
        HC      XSQNAK-PSEG     :NAK
        HC      PCRASH-PSEG     :DLE,EOT (DISCONNECT SIGNAL)
        HC      PCRASH-PSEG     :ACK1
        HC      PCRASH-PSEG     :WACK
        HC      PCRASH-PSEG     :ACK0
        HC      PCRASH-PSEG     :RVI
        HC      PCRASH-PSEG     :TTD (STX,ENQ)
        HC      PCRASH-PSEG     :MULTI-LEAVING BIG (SOH,ENQ)
        HC      PCRASH-PSEG     :DATA ABORT (ENQ,EOT,NAK IN TEXT)
        HC      RCVRTY-PSEG     :LOST SYNCHRONIZATION
        HC      PCRASH-PSEG     :OVERRUN (MORE DATA THAN BUFFLETS SPECIFIED)
        HC      PCRASH-PSEG     :NO INITIAL BUFFERLET AVAILABLE
        HC      XTSENQ-PSEG     :TIMEOUT BEFORE MSG RECEIVED
        HC      PCRASH-PSEG     :CRC ERROR IN DATA MESSAGE
        HC      PCRASH-PSEG     :LOST DATA DUE TO INAVAILABILITY OF BUFFERLET
        HC      PCRASH-PSEG     :UNIDENTIFIABLE MSG
        HC      PCRASH-PSEG     :FORCE COMPLETION BY BACK GROUND

:       RESPONSE TO A TTD (STX ENQ) THAT WAS SENT TO THE REMOTE
:       -------------------------------------------------------
:  

SXTTD   HC      XSTDAT-PSEG     :GOOD DATA ETX BLOCK
        HC      XSTDAT-PSEG     :GOOD DATA ETB BLOCK
        HC      XSTTD-PSEG      :ENQ
        HC      IPSRVI-PSEG     :EOT
        HC      XSTTD-PSEG      :NAK
        HC      RCVRTY-PSEG     :DLE,EOT (DISCONNECT SIGNAL)
        HC      RCVRTY-PSEG     :ACK1
        HC      RCVRTY-PSEG     :WACK
        HC      RCVRTY-PSEG     :ACK0
        HC      RCVRTY-PSEG     :RVI
        HC      RCVRTY-PSEG     :TTD (STX,ENQ)
        HC      RCVRTY-PSEG     :MULTI-LEAVING BIG (SOH,ENQ)
        HC      RCVRTY-PSEG     :DATA ABORT (ENQ,EOT,NAK IN TEXT)
        HC      RCVRTY-PSEG     :LOST SYNCHRONIZATION
        HC      RCVRTY-PSEG     :OVERRUN (MORE DATA THAN BUFFERLETS SPECIFIED)
        HC      RCVRTY-PSEG     :NO INITIAL BUFFERLET AVAILABLE
        HC      XTTDTM-PSEG     :TIMEOUT BEFORE MSG RECEIVED
        HC      RCVRTY-PSEG     :CRC ERROR IN DATA MESSAGE
        HC      RCVRTY-PSEG     :LOST DATA DUE TO INAVAILABILITY OF BUFFERLET
        HC      RCVRTY-PSEG     :UNIDENTIFIABLE MSG
        HC      PCRASH-PSEG     :FORCED COMPLETION BY BACKGROUND

        :       OVERALL POLLING PROTOCOL LOOP
:       -----------------------------------------
:       FIRST WE LOOP OVER CU S SENDING GENERAL POLLS
:       THEN WE LOOP OVER DEVICES LOOKING FOR DATA TO BE SENT
:       WHEN WE FIND DATA WAITING , WE SEND A SELECT MSG TO
:       THAT DEVICE .
PLLP    TBT     RL,DHNGBT,,     :ARE WE RUNNING THE HANG PROCESS?
        JEFS    PLLP01          :NOT ON THIS LINE!
:
        TBT     RL,BSCDSR,,     :DON'T POLL IF NO DSR
        JN      ENDSEL
:
PLLP01  SBT     RL,POLTYP       : SHOW G.P. IN PROGRESS
        LB      RCU,FCU,RL,     : LOAD FIRST CU INDEX
GPLOOP  STB     RCU,CCU,RL      : SAVE CURRENT CU INDEX
        JAL     R5,TSTPOL       : OK TO FAST OR SLOW POLL ?
        J       NXTGP3          :   N - SKIP IT
        J       SENDGP          : SEND G.P. MSG
NXTGP   LB      RCU,CCU,RL      : RETRIEVE CURRENT CU INDEX
NXTGP3  AIS     RCU,1
        CLB     RCU,FCU+1,RL,   : ANY MORE CU S FOR THIS LINE ?
        JL      GPLOOP
        :       END OF POLLING LOOP
 

        :       SELECT LOOP
        :       LOOP OVER DEVICES LOOKING FOR DATA TO SEND
SELLP   RBT     RL,POLTYP       : 
        LH      ROFF,FDEVL,RL2, : GET FIRST DEV ON THIS LINE
        LR      R2,ROFF
        NHI     R2,0F           : R2 = BIT NO OF FIRST DEV
        SRLS    ROFF,4          : ROFF = NUMBER OF BYTES FROM
        SLHLS   ROFF,1          : START FOR THE FIRST DEV.
SELLP1  LHL     R1,XMTDAT,ROFF, : LOAD DATA PRES FLAGS
        NH      R1,LMASK,R2,R2  : MASK OFF DEVICES FOR PREVIOUS LINE
        JN      SELLP3          : IF ANY ACTIVITY PRESENT ?
SELLP2  AIS     ROFF,2          : NEXT HALF-WORD
        LIS     R2,0            : SET BIT OFFSET TO ZERO
        LR      R1,ROFF
        SLLS    R1,3            : R1 = FIRST DEV. IN NEXT HALFWORD
        CLH     R1,FDEVL+2,RL2, : LAST DEVICE ?
        JLBS    SELLP1          :   N - PROCESS IT
        :       END OF SELECT LOOP
ENDSEL
 
 
:       CHECK FOR REQUESTS TO FLUSH XMT QUEUES
CKFSH   LH      RDEV,FDEVL,RL2, : LOOP OVER DEVICES ON THIS LINE
CKFSH2  RBT     RDEV,XMTFSH,,   : TEST AND RESET FLUSH XMT QUEUE FLAG
        JE      CKFSH4          :   NOT SET - SKIP
        JAL     R5,FLXMT        :   SET - FLUSH THE QUEUE
CKFSH4  AIS     RDEV,1          : NEXT DEVICE
        CLH     RDEV,FDEVL+2,RL2,
        JL      CKFSH2          : REPEAT FOR ALL DEVICES ON THIS LINE
 
        RBT     RL,PTPHLT       : 
        JAL     R5,PDMISS       : DISMISS FOR THIS LINE
        J       PLLP
NXTPOL  TBT     RL,POLTYP       : WERE WE IN POLL OR SELECT LOOP ?
        JE      SELLP5
        J       NXTGP
 
 
        :       THE CURRENT DATA PRESENT HALFWORD HAS A BIT ON
SELLP3  NH      R1,XMTGAT,ROFF, : COMBINE WITH OK TO SELECT FLAGS
        JE      SELLP2          : IF NO BIT ON EXIT
        STH     R1,DPSAV,RL2    : SAVE FLAG HALFWORD
        STH     ROFF,ROFFSV,RL2 : SAVE OFFSET
SELLP4  JAL     R3,BIDH         : FIND FIRST ON BIT
        LR      RDEV,ROFF       : SET UP DEVICE NO.
        SLLS    RDEV,3          : MULT. BY 8
        AR      RDEV,R2         : ADD IN BIT OFFSET
        CLH     RDEV,FDEVL+2,RL2,       :STILL IN THIS LINE'S DEVICES?
        JGE     ENDSEL
        STH     R2,R2SAV,RL2    : SAVE BIT NUMBER
        STB     RDEV,CDEV,RL    : SAVE CURRENT DEVICE
        LB      R3,DEVCU,RDEV,  : GET CU FOR THIS DEVICE
        STB     R3,CCU,RL       : SAVE CURRENT DEVICE
        JAL     R5,CSLEW        : LOOK FOR DATA CMD
        JLE     SELLP5          :   NONE - SKIP
:       CHECK TO SEE IF DELAY IS REQUIRED BEFORE SELECTING THE DEVICE
        LR      R7,RDEV         : SET UP FULLWORD INDEX
        SLHLS   R7,2
        L       R6,NXTSEL,R7    : GET TIME FOR NEXT SELECT
        JE      SELECT          : JUST SELECT IF NOT TIMING
        CL      R6,FASTC,,      : IS IT <= CURRENT TIME ?
        JLE     SELECT          :   Y - SEND SELECT
 
SELLP5  LH      R2,R2SAV,RL2
        LHL     ROFF,ROFFSV,RL2 :RESTORE ROFF
        LHL     R1,DPSAV,RL2    : RESTORE DATA PRESENT
        NH      R1,LMASK+2,R2,R2
        JE      SELLP2
        LHL     ROFF,ROFFSV,RL2
        J       SELLP4
 
 

:       PSEUDO-RVI FROM REMOTE : IPSRVI
:       -------------------------------
:       WHILE TRANSMITTING DATA, WE HAVE RECEIVED AN EOT .
:       THE DEVICE HAS STATUS WAITING . WE RECORD THE EVENT
:       AND THEN READ STATUS .

IPSRVI  
        LHI     R3,XMTEOT       : LOAD ERROR TYPE
        JAL     R5,GOTERR       : REPORT IT
        J       RINIT





:       RCV'D REVERSE INTERRUPT : IRRVI
:       -------------------------------
:       REMOTE HAS RESPONDED WITH RVI TO A SELECT MSG
:       INDICATING THAT IT HAS STATUS PENDING.
:       RECORD THE EVENT AND POLL IT FOR STATUS.

IRRVI   
        JAL     R5,CKSELT               : CHECK SELECT ERROR TIME
        J       IRRVI10                 :   ERROR INTERVAL EXPIRED
        J       IRESET                  :   INTERVAL NOT EXPIRED
IRRVI10
        LHI     R3,XMTRVI       : LOAD ERROR TYPE
        JAL     R5,GOTERR       : GO REPORT ERROR
        J       RINIT           : POLL FOR STATUS


:       RCVD EOT ON POLL : PREOT
:       ---------------------------------
:       RECORD IT , CLEAR POLL ERR AND
:       GO ON TO NEXT DEVICE .
PREOT
        L       R4,FASTC,,      : RECORD POLL RESPONSE TIME
        LB      R7,CCU,RL       : GET CU INDEX
        SBT     R7,CUPOLL,,     :INDICATE CU IS ANSWERING POLLS

:	POLL RESPONSE TIME TRACE
	LH	R0,PR.ON,,	:ARE WE TRACING POLL RESPONSE TIMES
	JL	PREOT5		:IF NOT, SKIP AHEAD
	LH	R0,PR.SAV,,	:SLOT OR CU
	JLFS	PREOT2		:IF SLOT, SKIP AHEAD
	CR	R0,R7		:IS THIS THE CU WE'RE TRACING
	JN	PREOT5		:IF NOT, SKIP AHEAD
PREOT2	TBT	RL,PR.ALR,,	:DID WE TIME THE POLL
	JNFS	PREOT5		:IF NOT SKIP AHEAD
	L	R0,FASTC,,	:GET CURRENT TIME
	S	R0,PR.PLL,RL2,RL2	:SUBTRACT POLL TIME FROM CURRENT TIME
	AM	R0,PR.TCK,,	:ADD NUMBER OF TICKS
	LIS	R0,1
	AM	R0,PR.NMB,,	:BUMP NUMBER OF POLLS

PREOT5	SLHLS   R7,2            : MAKE IT A FULLWORD INDEX
        RBT     RL,CHNGBT,,     :NOTE ACTIVITY ON LINE
        ST      R4,POLTYM,R7    : SET POLL RESP. TIME = CURR. TIME
        J       NXTPOL
 
 
:       BAD RESPONSE TO POLL
:       CHECK LAST POLL RESPONSE TIME
:       IF INACTIVE , CALL INACTIVE CU ROUTINE
BADPR   LB      R7,CCU,RL       : GET CU INDEX
	LIS	R0,1		:BUMP POLL TIMEOUT COUNTER
	AHM	R0,PLLTO,R7,R7
	LH	R6,E.LIN	:GET LINE FOR ERROR REPORTING (BINS)
	JLFS	BADPR0		:JUMP IF ALL LINES
	CR	R6,RL		:IS THIS THE RIGHT LINE
	JNFS	BADPR1		:NO, SKIP AHEAD
BADPR0	LHL	R6,E.TIM	:GET TIME (BIN NUMBER)
	AHM	R0,E.PTO,R6,R6	:BUMP COUNTER
BADPR1	SLHLS   R7,2            : MAKE FULLWORD INDEX
        L       R6,POLTYM,R7    : GET TIME OF LAST POLL RESP.
        AI      R6,POLT3        : ADD RECOVERY INTERVAL
        CL      R6,FASTC,,      : HAS INTERVAL EXPIRED ?
        JGFS    BADPR2
        JAL     R5,INACCU       :   Y - CALL INACTIVE C.U. ROUTINE
BADPR2  J       IRESET          : SEND EOT AND CONTINUE
 
 
:       RCVD BAD RESPONSE TO OUR SELECT MSG : BADSR
:       -------------------------------------------
:       RECORD IT AND SEND EOT .
 
BADSR	DERR(XMTUR)
	JAL     R5,CKSELT       : CHECK SELECT ERROR TIME
        J       BADSR2          :   INTERVAL EXPIRED
        J       IRESET          :   INTERVAL NOT EXPIRED
BADSR2  LHI     R3,XMTUR        : RECORD XMT ERROR
        JAL     R5,GOTERR
        J       IRESET
 
CKSELT  LB      R7,CDEV,RL      : GET DEVICE NUMBER
        SLHLS   R7,2            : MAKE FULLWORD INDEX
        L       R6,FASTC,,      : GET CURR. TIME
        AI      R6,SELT1        : ADD DELAY INTERVAL
        ST      R6,NXTSEL,R7    : DELAY NEXT SELECT
        L       R6,SELTYM,R7    : OUTSTANDING PROBLEM ?
        JNFS    CKSE10          :   Y - SKIP
        L       R6,FASTC,,      :   N - SELTYM = CURR. TIME + RECORERY INT.
        AI      R6,SELT2
        ST      R6,SELTYM,R7
CKSE10  CL      R6,FASTC,,      : HAS RECOVERY INTERVAL EXPIRED ?
        JG      4,R5            :   N - SKIP RETURN
        JR      R5              :   Y - STANDARD RETURN
 
:       RESET LINE STATE TO IDLE : IRESET
:       ---------------------------------
:       LINE RESET TO IDLE MODE BY SENDING EOT TO REMOTE.  IDLE STATE
:       IS ENTERED NEXT.  NOTE THAT THIS IS NOT AN ERROR.

IRESET  LIS     R1,XCEOT        :GET OP CODE FOR EOT

:       SEND A MSG WHICH REQUIRES NO RESPONSE AND GO INTO IDLE
IXMT    JAL     R5,XMT          :SEND MSG QUEUED
                IF      PTPTSW          :TRACE STATES
                :-:-:-:-:-:-:-:-:-:-:-:-:-:  TRACE  :-:-:-:-:-:-:-:-:-:-:-:-::
                TBT     RL,PTRBIT       :TRACE THIS LINE?
                JE      IXMT10          :N - SKIP
                LHL     R6,PTPTRX       :GET TRACE TABLE INDEX               :
                LB      R0,XMTOPC,RL    :GET LAST XMT OP CODE                :
                EXBR    R0,R0           :POSITION                            :
                OHI     R0,0FF          :FLAG NO RCV OP PERFORMED            :
                STH     R0,PTPTTB,R6,   :TRACE                               :
		LCS	R0,1						     :
		STH	R0,PTPTTB+2,R6,	:PAD OUT TRACE ENTRY WITH -1	     :
		AIS     R6,4            :ADVANCE TRACE INDEX                 :
                CLHI    R6,PTPSIZ                                            :
                JLFS    .+4                                                  :
                LIS     R6,0                                                 :
                STH     R6,PTPTRX       :SAVE INDEX                          :
IXMT10
                :-:-:-:-:-:-:-:-:-:-:-:-:-:  TRACE  :-:-:-:-:-:-:-:-:-:-:-:-::
                EI      :PTPTSW
        J       NXTPOL          : GO ON TO NEXT DEVICE


:       REMOTE ABORT : IRABRT
:       ---------------------
:       REMOTE SENT AN EOT ABORTING A RECEPTION OF DATA.
:       RECORD IT AND GO ON TO NEXT DEVICE .

IRABRT  DERR(XMTEOT)
        J       NXTPOL          : GO ON TO NEXT DEVICE


:       IMPOSSIBLE RESPONSE STATE : PCRASH
:       ----------------------------------
:       A RESPONSE FROM THE BISYNC RCV ROUTINE WHICH IS IMPOSSIBLE HAS
:       OCCURED.  CFROM WILL HAVE: SSSS00RR  RR=RCV RETURN CODE
:                                          SSSS=STATE TABLE REL ADDRESS

PCRASH  LHL     R0,STATE,RL2    :STATE TABLE REL ADDR
        EXHR    R0,R0           :POSITION
        OR      R0,R2           :INCLUDE RETUR CODE
        JAL     R10,CRASH        :CRASH
        BC      0,0,0
        BC      0,0,0

:       SEND A GENERAL POLL MSG
:       _______________________

SENDGP  JAL     R5,CKSPAC,,     : CHECK FOR BUF. AND CMD. LINK SPACE
        J       NXTPOL          : SKIP POLLING FOR NOW
        clb     rcu,fcu,rl      : is this the first cu?
        jn      sdgp20          : n - skip
        lhl     r0,polcnt,rl,rl : is it the first poll for this cu?
        jn      sdgp10          : n - skip
        l       r6,lstpol,r7    : store time of first poll
        st      r6,fstpol,rl2,rl2       
SDGP10  LIS     R0,1
        AHM     R0,POLCNT,RL,RL : COUNT POLLS ISSUED for this cu
SDGP20  LCS     R0,1            : SET CURR. DEVICE TO NULL VALUE
        STB     R0,CDEV,RL
        LHI     R0,RCDATX
        STB     R0,RLRC,RL      : LAST MSG = ETX
        RBT     RL,LSTACK       :LAST ACK = ACK0
        LHI     R0,RDFIR-PSEG   : GET ADDR OF FIRST MSG ROUTINE
        STH     R0,RDPROC,RL2   : INIT READ MSG RTE ADDR TO IT
        RBT     RL,RCVLCM       :RESET LIMITED CONVERSATIONAL MODE
        RBT     RL,BSCEFR       :DISABLE FORCE OP COMPLETE
        LHI     R0,TRDAT        :INIT RESPONSE TIME FOR DATA
        STH     R0,RSTIME,RL2
        LHI     R0,SRINIT-PSEG  :SET STATE TO RCV INITIAL
        STH     R0,STATE,RL2
        :       NOW SET UP POLL MSG AS A DATA MSG
        LHL     R3,LNBUFLT,RL2
        LIS     R4,GPMSG
        JAL     R5,SUMSG        : SET UP A G.P. MSG

:	POLL RESPONSE TIME TRACE
	LH	R4,PR.ON,,	:ARE WE TRACEING POLL RESPONSE TIMES
	JL	SNDGP5		:SKIP AHEAD IF NOT
	LH	R4,PR.SAV,,	:SLOT OR CU
	JLFS	SNDGP2		:IF SLOT, SKIP AHEAD
	CR	R4,RCU		:IS THIS THE CU WE'RE TRACING
	JNFS	SNDGP5		:IF NOT SKIP AHEAD
SNDGP2	L	R4,FASTC,,	:GET CURRENT TIME
	ST	R4,PR.PLL,RL2,RL2	:SAVE TO SHOW WHEN POLL STARTED
	RBT	RL,PR.ALR,,	:SET AS NOT ALREADY TIMED

SNDGP5	LHI     R0,TREOT        :WAIT FOR RCV RESPONSE AS IF EOT EXPECTED
        LHI     R4,BSCRBC       :SET RCV BUFFERLET USAGE LIMIT FOR DATA MSG
        J       XMTRCV          :GO ACK AND READ DATA

:       SEND A SPECIFIC POLL : RINIT
:       ----------------------------
:       RESET VARIOUS FLAGS , SET RCV. STATE AND SEND POLL.

RINIT   JAL     R5,CKSPAC       : CHECK FOR SPACE(BUF. AND CMD LINKS)
        J       NXTPOL          :   NOT ENOUGH - SKIP POLL FOR NOW
        LHI     R0,RCDATX
        STB     R0,RLRC,RL      : LAST MSG = ETX
        RBT     RL,LSTACK       :LAST ACK = ACK0
        RBT     RL,LSTRVI       :LAST ACK NOT RVI
        LHI     R0,RDFIR-PSEG   : GET ADDR OF FIRST MSG ROUTINE
        STH     R0,RDPROC,RL2   : INIT READ MSG RTE ADDR TO IT
        RBT     RL,RCVLCM       :RESET LIMITED CONVERSATIONAL MODE
        RBT     RL,BSCEFR       :DISABLE FORCE OP COMPLETE
        LHI     R0,TRDAT        :INIT RESPONSE TIME FOR DATA
        STH     R0,RSTIME,RL2
        LHI     R0,SRINIT-PSEG  :SET STATE TO RCV INITIAL
        STH     R0,STATE,RL2
        :       NOW SET UP POLL MSG AS A DATA MSG
        LHL     R3,LNBUFLT,RL2
        LIS     R4,SPMSG
        JAL     R5,SUMSG        : SET UP A SPECIFIC POLL MSG
        
:	POLL RESPONSE TIME TRACE
	LH	R4,PR.ON,,	:ARE WE TRACEING POLL RESPONSE TIMES
	JL	RINIT5		:SKIP AHEAD IF NOT
	LH	R4,PR.SAV,,	:SLOT OR CU
	JLFS	RINIT2		:IS SLOT, SKIP AHEAD
	CR	R4,RCU		:IS THIS THE CU WE'RE TRACING
	JNFS	RINIT5		:IF NOT SKIP AHEAD
RINIT2	L	R4,FASTC,,	:GET CURRENT TIME
	ST	R4,PR.PLL,RL2,RL2	:SAVE TO SHOW WHEN POLL STARTED
	RBT	R0,PR.ALR,,	:SET AS NOT ALREADY TIMED

RINIT5	LHI     R0,TREOT        :WAIT FOR RCV RESPONSE AS IF EOT EXPECTED
        LHI     R4,BSCRBC       :SET RCV BUFFERLET USAGE LIMIT FOR DATA MSG
        J       XMTRCV          :GO ACK AND READ DATA



:       GOOD DATA RECEIVED : RDATAX,RDATAB
:       ----------------------------------
:       A GOOD DATA BLOCK WAS RECEIVED.  DATA IS QUEUED FOR BACKGROUND
:       AND ACK IS SWITCHED (ACK INDICATES TO SENDER THE WHICH WAS THE
:       DATA BLOCK RECEIVED).  NOTE THAT USE OF INPUT COMMAND RING IS SUCH
:       THAT A NEW RCV OPERATION THAT MAY STORE INTO THE RING IS NOT
:       ALLOWED UNTIL THE RING HAS 2 FREE ENTRIES (WACK SENT UNTIL RING
:       SPACE AVAILABLE).  AN ATTEMPT TO WRITE INTO THE RING CAUSING FILL=EMPTY
:       POINTER IS A LOGIC ERROR AND WE CRASH.

:       DATA BLOCK ENDED IN ETX.  NEXT RCV OPERATION WILL USE SHORT
:       TIMEOUT SINCE AN EOT IS EXPECTED AND WE DON'T WANT TO WAIT
:       A LONG TIME IF IT IS LOST.
RDATAX  LHI     R0,TREOT        :SET TIME FOR ETX BLOCK
        LHI     R15,ETXBIT      :SET ETXBIT FOR CMD
        JFS     RDAT10          :GO QUEUE DATA

:       DATA BLOCK ENDED IN ETB.  NEXT RCV OPERATION WILL USE LONG
:       TIMEOUT TO ALLOW USE WITH STRANGE DEVICES THAT STOP SENDING
:       INSTEAD OF USING TTD'S.
RDATAB  LHI     R0,TRDAT        :SET TIME FOR ETB BLOCK
        LHI     R15,ETBBIT      :SET ETBBIT BIT FOR CMD
RDAT10  LHL     R4,CMDCNT       : CHECK TO SEE THAT A COMMAND LIST LINK
        CHI     R4,4            : IS AVAILABLE FOR THE DATA MSG
        JGFS    RDAT13          :   Y - CONTINUE
        JAL     R5,PBBC         :   N - FREE BUF AND 
        RBT     RL,XPRDAT,,     :RESET TRANSPARENT DATA BIT
        J       RBAD            :       SEND NAK
RDAT13
        STH     R0,RSTIME,RL2    :SET NEXT RCV TIMEOUT VALUE
        LB      R7,CCU,RL       : GET CU INDEX
       
:	POLL RESPONSE TIME TRACE
	LH	R4,PR.ON,,	:ARE WE TRACING POLL RESPONSE TIMES
	JL	RDAT16		:IF NOT, SKIP AHEAD
	LH	R4,PR.SAV,,	:SLOT OR LINE
	JLFS	RDAT15		:IF SLOT, SKIP AHEAD
	CR	R4,R7		:IS THIS THE CU WE'RE TRACING
	JN	RDAT16		:IF NOT, SKIP AHEAD
RDAT15	TBT	RL,PR.ALR,,	:HAVE WE ALREADY TIMED THE RESPONSE
	JNFS	RDAT16		:IF ALREADY DONE, SKIP AHEAD
	L	R4,FASTC,,	:GET CURRENT TIME
	S	R4,PR.PLL,RL2,RL2	:SUBTRACT POLL TIME FROM CURRENT TIME
	AM	R4,PR.TCK,,	:ADD NUMBER OF TICKS
	LIS	R4,1
	AM	R4,PR.NMB,,	:BUMP NUMBER OF POLLS

RDAT16	LIS	R4,1		:BUMP MSG BLOCK RECEIVED COUNTER
	AM	R4,RCVTOT,R7,R7
        SLHLS   R7,2            : MAKE IT A FULLWORD INDEX
        L       R4,FASTC,,      : GET TIME AND 
        ST      R4,POLTYM,R7    : RECORD AS LAST POLL RESP.
        RBT     RL,CHNGBT,,     :NOTE ACTIVITY ON LINE
        STB     R2,RCURRC       : SAVE CURRENT RCV RETURN CODE
        LR      R2,R1           : PUT BUF. CNT INTO R2
        RBT     RL,XPRDAT,,     :TRANSPARENCY?
        JEFS    RDAT18          :N - JUMP
        OHI     R15,XPRBIT      :SET BIT FOR XPR MODE
RDAT18  LHL     R4,RDPROC,RL2   : GET READ RTE. ADDR
        J       PSEG,R4         : JUMP THERE
 
:       RDFIR - CHECK FIRST MSG AFTER ETX FOR TYPE
:       IS THIS MSG DATA , STATUS OR TEST REQUEST ?
RDFIR   LB      R0,BBUFER,R3,   : GET FIRST CHAR OF MSG
        CLHI    R0,STX          :  STX ?
        JE      RDMSG           :   Y - DATA MSG
        :       SHOULD BE STATUS OR TEST REQUEST MSG
        CLHI    R0,SOH          : SOH ?
        JN      RTOSS           :   N - BAD MSG
        LB      R0,BBUFER+1,R3, : GET SECOND CHAR
        CLHI    R0,PERC         : % CHAR ?
        JN      RTOSS           :   N - BAD MSG
        LB      R0,BBUFER+2,R3, : GET THIRD CHAR
        CLHI    R0,RCHAR        : R CHAR ?
        JE      RSTAT           :   Y - STATUS MSG
:       RCVD A TEST REQUEST OR UNKNOWN MSG - TOSS IT UNTIL ETX
RTOSS   LI      R5,RTOSS-PSEG   : SET UP PROCESSING ADDR TO COME HERE
        STH     R5,RDPROC,RL2
        JAL     R5,PBBC         : FREE BUFFERLETS
        J       RDAT30          : SEND ACK BACK
 
 
:       RCVD DATA MSG
RDMSG   
        OHI     R15,FIRBIT      : SET FIRST BIT IN CMD R0 WORD
        LIS     R7,1
        JAL     R4,PRADR        : PROCESS ADDRESS CHARS
       
:	TIMESTAMP FIRST TIME PROCESS STX IN FOREGROUND
	LH	R0,ST.ON,,		:ARE WE TIMESTAMPING
	JL	RDMSG4			:IF NOT, SKIP AHEAD
	CLB	R0,CDEV,RL		:IS THIS THE RIGHT DEVICE
	JN	RDMSG4			:IF NOT, SKIP AHEAD
	LIS	R0,0			:ONLY RECORD 1ST STX OF MULT BLOCK MSG
	SBT	R0,ST.DSP,,
	JN	RDMSG4
	LB	R5,ST.DSP+1,,		:GET DISPLACEMENT
	JGFS	RDMSG0			:SWAP DISPLACEMENT
	LHI	R5,STDSP
	JFS	RDMSG1
RDMSG0	LIS	R5,0
RDMSG1	STB	R5,ST.DSP+1,,		:AND SAVE IT
	LHI	R4,(ST.SIZ/2)-4		:ZERO TIMESTAMP SAVE AREA
RDMSG2	ST	R0,ST.BEG,R4,R5
	SIS	R4,4
	JGEBS	RDMSG2			:TIL DONE
	L	R0,FASTC,,		:GET CURRENT TIME IN FASTC
	ST	R0,ST.ST0,R5,		:SAVE TIME
	LCS	R0,1			:SET FLAG TO SAVE TIME
	STH	R0,ST.FLG,,		:OF 2ND STX XMITTED

:	RESPONSE TIME TRACE, STAMP RECEIPT OF STX
RDMSG4	LH	R0,RE.ON,,		:ARE WE RESPONSE TRACING
	JL	RDMSG6			:IF NOT, SKIP AHEAD
	CLB	R0,CDEV,RL		:IS THIS THE RIGHT DEVICE
	JNFS	RDMSG6			:IF NOT, SKIP AHEAD
	TS	RE.FLG+2,,		:USE 1ST STX OF MULTI BLOCK MSG
	JNFS	RDMSG6
	L	R0,FASTC,,		:GET CURRENT TIME IN FASTC
	ST	R0,RE.MST,,		:AND SAVE IT
	LCS	R0,1			:SET FLAG TO USES SECOND XMIT STX
	STH	R0,RE.FLG,,		:FOR CALCULATING RESPONSE TIME

RDMSG6	LB      RDEV,CDEV,RL
        LHI     R5,RDMSG6-PSEG  : SET READ RTE. ADDR TO HERE
        STH     R5,RDPROC,RL2
        LR      R0,R15          : SET UP R0 WORD FOR CMD
        TBT     RL,RCVLCM       : CHECK FOR LCM RESP. MODE
        JEFS    RDMSG8          :   N - SKIP
        OHI     R0,LCMBIT       :   Y - TURN ON LCM BIT
RDMSG8
        PUTCMD(RCV,RDEV,RDEV)
        RLCMD(RCV,RDEV,RDEV)
 
        J       RDAT30
 
        :       WE RCVD A STATUS MSG
RSTAT   LIS     R7,4            : GET OFFSET OF CU ADR CHAR IN MSG
        JAL     R4,PRADR        : PROCESS ADDRESS CHARS
        LB      R0,BBUFER+6,R3, : GET FIRST STATUS CHAR
        SLLS    R0,8            : SHIFT LEFT 8 BITS
        LB      R5,BBUFER+7,R3, : GET SECOND STATUS CHAR
        OR      R0,R5           : INSERT IN LOW BYTE OF R0
 
        JAL     R5,PBBC         : FREE BUFFERLETS
        :       NOW BUILD STATUS CMD
        LHI     R2,STACMD       : CMD CODE = STATUS
        LR      R3,R0           : R3 = STATUS VALUE
        PUTCMD(RCV,RDEV,RDEV)
        RLCMD(RCV,RDEV,RDEV)
RDAT30  CBT     RL,LSTACK
        LIS     R0,0
        ST      R0,BSCETM,RL2,RL2       : RESET ERROR TIMER
        STB     R0,RETRY,RL     : RESET RETRY COUNTER
 
        LB      R0,RCURRC       : GET CURRENT RCV RETURN CODE
        STB     R0,RLRC,RL      : STORE AS LAST RCV RETURN CODE
        CHI     R0,RCDATX       : ETX ?
        JN	RDAT35          :   N - SKIP

:	TIMESTAMP FIRST TIME ETX PROCESSED BY FOREGROUND
	LH	R0,ST.ON,,	:ARE WE TIMESTAMPING
	JL	RDAT31		:IF NOT, SKIP AHEAD
	CR	R0,RDEV		:IS THIS THE RIGHT DEVICE
	JNFS	RDAT31		:IF NOT, SKIP AHEAD
	LB	R5,ST.DSP+1,,	:GET DISPLACEMENT
	L	R0,FASTC,,	:GET CURRENT TIME IN FASTC
	ST	R0,ST.ST1,R5,	:SAVE TIME
	LIS	R0,0		:NEXT STX WILL BE FIRST OF MULTI BLOCK MSG
	RBT	R0,ST.DSP,,

:	RESPONSE TIME TRACE - INDICATE MSG COMPLETED (FOR MULTIBOLCK MSGS)
RDAT31	LH	R0,RE.ON,,	:ARE WE TIMING RESPONSES
	JLFS	RDAT32		:IF NOT, SKIP AHEAD
	CR	R0,RDEV		:IS THIS THE RIGHT DEVICE
	JNFS	RDAT32		:IF NOT, SKIP AHEAD
	LIS	R0,0		:INDICATE NEXT STX IF FIRST OF MULTI BLOCK MSG
	STH	R0,RE.FLG+2,,

RDAT32	LHI     R5,RDFIR-PSEG   : RESET READ RTE ADDR TO FIRST MSG
        STH     R5,RDPROC,RL2
RDAT35
 

:       GET OP CODE FOR CURRENT ACK AND SEND.  THIS MAY BE ACK0,ACK1, 
RSACK   LIS     R1,XCACK0       :PREPARE TO SEND ACK0
        TBT     RL,LSTACK       :ACK0 OR ACK1 ?
        JEFS    RRCV            :GO SEND ACK0
        LIS     R1,XCACK1       :ACK1

:       SEND MSG AND READ NEXT DATA BLOCK.  MSG OP CODE IN R1 AND WILL
:       BE NAK,RVI,ACK0, OR ACK1
RRCV    LHI     R0,SRCV-PSEG    :SET STATE TO RCV
        STH     R0,STATE,RL2
        LHL     R0,RSTIME,RL2    :GET RCV TIMEOUT VALUE
        LHI     R4,BSCRBC       :SET RCV BUFFERLET LIMIT
        J       XMTRCV          :XMT AND READ RESPONSE

:       DUMMY WACK SENDER
RSWACK  NOP
 

:       WE RCVD A DATA ABORT : RDABT
:       --------------------------
:       RECORD IT THEN SEND NAK .
RDABT   DERR(RCVSTE)
        J       RSNAK
 

:       BAD DATA RECEPTION : RBAD
:       -------------------------
:       THE LAST DATA BLOCK WAS RECEIVED IN ERROR (BCC BAD, ETC.)
:       COUNT ERROR, ABORT IF TOO MANY, SEND NAK

RBAD    DERR(RCVNAK)

:       SEND NAK AND RCV AGAIN
RSNAK	LB	R6,CCU,RL	:GET CURRENT CU
	LIS	R0,1		:BUMP NAK COUNTER
	AHM	R0,NAKS,R6,R6
	LH	R6,E.LIN	:GET LINE FOR ERROR REPORTING (BINS)
	JLFS	RSNK05		:JUMP IF ALL LINES
	CR	R6,RL		:IS THIS THE RIGHT LINE
	JNFS	RSNK06		:NO, SKIP AHEAD
RSNK05	LHL	R6,E.TIM	:GET TIME (BIN NUMBER)
	AHM	R0,E.NAK,R6,R6	:BUMP COUNTER

RSNK06	LIS     R1,XCNAK        :GET NAK
        J       RRCV            :GO NAK AND RCV AGAIN


:       RECEIVED TTD : RRTTD
:       --------------------
:       REMOTE HAS SIGNALED THAT IT HAS MORE DATA TO SEND, BUT IS NOT READY
:       WITH IT CURRENTLY.  RESPONSE IS NAK, BUT IT IS NOT AN ERROR.

RRTTD   STB     R2,RLRC,RL      :SAVE TTD RCV RET CODE
        LIS     R0,0            :CLEAR ERROR TIMER
        ST      R0,BSCETM,RL2,RL2
        STB     R0,RETRY,RL     :RESET ERROR RETRY CNTR
        J	RSNAK           :GO SEND NAK


:       RESEND LAST ACK : RRSACK
:       ------------------------
:       SENDER HAS REQUEST RETRANSMISSION OF LAST POSITIVE ACKNOWLEDGEMENT.
:       COUNT ERROR, ABORT IF TOO MANY, SEND LAST ACK

RRSACK  DERR(RCVNAK)
        J       RSACK           :GO SEND LAST ACK


:       TIMEOUT AWAITING RCV DATA : RTMOT
:       ---------------------------------
:       IF LAST DATA BLOCK WAS ETX, WE MAY HAVE MISSED AN EOT.
: IF SO, RESET BY SENDING AN EOT, ELSE REPORT TIMEOUT ERROR AND
: SEND A NAK.
:
RTMOT   LB      R0,RLRC,RL      :GET LAST RETURN CODE
        CLHI    R0,RCDATX       :ETX BLOCK ?
        JE      IRESET          :Y - RESET BY SEND EOT
        DERR(RCVTO)
        J       RSNAK           : SEND NAK TO REQUEST RETRANSMISSION




:       EOT WHILE RCV'ING DATA : RREOT
:       ------------------------------
:       RCV'D EOT INSTEAD OF DATA BLOCK.  IF LAST RCV WAS ETX OR TTD, THIS
:       IS OK AND IS END-OF-FILE.  ELSE IT IS A RECEIVE ABORT.  NOTE
:       THAT SEQUENCE: DATA,ACK,TTD,EOT IS 'FORWARD ABORT' AND WE DO
:       NOT INTERPET IT AS AN ERROR ABORT.

RREOT   LB      R0,RLRC,RL      :GET LAST RCV RETURN CODE
        CLHI    R0,RCDATB       :DATA ETB ?
        JE      IRABRT          :JUMP IF SO, REMOTE IS ABORTING

:       PUT END-OF-FILE INDICATOR INTO INPUT COMMAND RING FOR BACKGROUND
REOF    LB      RDEV,CDEV,RL            : GET CURR.DEV.INDEX
:       RESET OUTSTANDING ERROR TIMER AND GO TO NEXT DEVICE.
        LB      R0,CCU,RL
        SBT     R0,CUPOLL,,     :INDICATE CU IS ANSWERING POLLS
        LIS     R0,0            :RESET ERROR TIMER
        ST      R0,BSCETM,RL2,RL2
        J       NXTPOL


:       RCV ABORTED DUE TO NO 1ST BUFFERLET : RWTRTY
:       --------------------------------------------
:       WE WERE ATTEMPTING TO RCV DATA AND A MSG STARTED TO COME IN, BUT
:       THERE WERE NO BUFFERLETS AVAILABLE TO PUT IT INTO.  DELAY RCV AND
:       RETRY.  THE DELAY IS TO GIVE THE DATA MSG CURRENTLY BEING SENT
:       TO US TIME TO FINISH BEFORE WE ATTEMPT TO RCV AGAIN.  THIS SHOULD
:       PREVENT US FROM MISINTERPETTING THE DATA MSG.
RWTRTY  LHL     R0,TDRRTY       :GET DELAY TIME
        SLLS    R0,TSCALE       :SCALE
        A       R0,FASTC,,      :CREATE TIME TO CONTINUE
        ST      R0,WTIME,RL2,RL2

RWRTY2  JAL     R5,PDMISS       :DISMISS
        L       R0,WTIME,RL2,RL2        :TIME TO CONTINUE ?
        S       R0,FASTC,,
        JLE     RCVRTY          :RETRY RCV IF SO
        JBS     RWRTY2



:       WE WANT TO SEND A SELECT MSG : SELECT
:       -------------------------------------
 
SELECT  HS	0

:	TIMESTAMP MSG SELECT
	LH	R0,ST.ON,,		:ARE WE TIMESTAMPING
	JLFS	SELCT5			:IF NOT, SKIP AHEAD
	CLB	R0,CDEV,RL		:IS THIS THE RIGHT DEVICE
	JNFS	SELCT5			:IF NOT, SKIP AHEAD
	LB	R1,ST.DSP+1,,		:GET DISPLACEMENT
	L	R0,FASTC,,		:GET CURRENT TIME IN FASTC
	ST	R0,ST.ST6,R1,		:AND SAVE TIME

SELCT5  LHI     R1,SXSEL-PSEG
        STH     R1,STATE,RL2
        :       NOW SET UP A SELECT MSG
        LHL     R3,LNBUFLT,RL2
        LIS     R4,SELMSG
        JAL     R5,SUMSG        : CALL SUMSG TO SET UP MSG
        LHI     R0,TBID
        LIS     R4,0            : BUFFERLET LIMIT = 0
        J       XMTRCV

:       ACK0 AFTER XMT RESPONSE TIMEOUT : XTACK0
:       ----------------------------------------
:       THE LAST REMOTE ACK WAS MISSED, AND WE ASKED THE REMOTE TO RESEND
:       IT VIA ENQ AND RCV'D ACK0.  IF THIS WAS NOT THE EXPECTED ACK,
:       THE REMOTE MISSED THE LAST DATA BLOCK, RESEND IT.

XTACK0  TBT     RL,LSTACK       :ACK0 EXPECTED ?
        JN      XRSDAT          :JUMP IF NOT, RESEND DATA


:       ACK0 XMT RESPONSE : XRACK0
:       --------------------------
:       IF ACK0 EXPECTED, DEQUEUE LAST COMMAND AND GO ON.  ELSE, ASK
:       FOR RETRANSMISSION OF ACK.

XRACK0  CBT     RL,LSTACK       :ALTERNATE ACK'S, TEST WHAT WAS EXPECTED
        JE      XRAK10          :JUMP ACK0 EXPECTED

:       WRONG ACK, UN-ALTERNATE AND ASK FOR ACK AGAIN
XRAKWG  CBT     RL,LSTACK       :UN-ALTERNATE ACK
	DERR(XMTACK)

	LB	R6,CCU,RL	:GET CU
	LIS	R0,1		:BUMP RETRANSMISSION COUNTER
	AHM	R0,RXMT,R6,R6
	LH	R6,E.LIN	:GET LINE FOR ERROR REPORTING (BINS)
	JLFS	XRKWG1		:JUMP IF ALL LINES
	CR	R6,RL		:IS THIS THE RIGHT LINE
	JNFS	XRKWG2		:NO, SKIP AHEAD
XRKWG1	LHL	R6,E.TIM	:GET TIME (BIN NUMBER)
	AHM	R0,E.RTN,R6,R6	:BUMP COUNTER
XRKWG2	J       XSDATA          :RE-SEND DATA


:       BAD XMT RESPONSE : XRBAD
:       ------------------------
:       ASK FOR RETRANSMISSION OF RESPONSE (ACK).  COUNT AS ERROR.

XRBAD   DERR(XMTNAK)
        J       XSENQ           :GO SEND ENQ


:       ACK1 AFTER XMT RESPONSE TIMEOUT : XTACK1
:       ----------------------------------------
:       THE LAST REMOTE ACK WAS MISSED, AND WE ASKED THE REMOTE TO RESEND
:       IT VIA ENQ AND RCV'D ACK1.  IF THIS WAS NOT THE EXPECTED ACK,
:       THE REMOTE MISSED THE LAST DATA BLOCK, RESEND IT.

XTACK1  TBT     RL,LSTACK       :ACK1 EXPECTED ?
        JE      XRSDAT          :JUMP IF NOT, RESEND DATA



:       ACK1 XMT RESPONSE : XRACK1
:       --------------------------
:       IF ACK1 EXPECTED, DEQUEUE LAST COMMAND AND GO ON.  ELSE, ASK
:       FOR RETRANSMISSION OF ACK.

XRACK1  CBT     RL,LSTACK       :ALTERNATE ACK'S, TEST WHAT WAS EXPECTED
        JE      XRAKWG          :JUMP WRONG ACK
XRAK10  

:       DEQUEUE LAST BACKGROUND COMMAND
XRAK20  STH     R2,XRAKSV       : SAVE RCV RETURN CODE
        SEG     0
XRAKSV  HS      1
        SEG     1
        RBT     RL,CHNGBT,,     : NOTE ACTIVITY ON LINE
        LB      RDEV,CDEV,RL
XRAK21
        PKCMD(XMT,RDEV,RDEV)    : GET LAST CMD
        ADVCMD(XMT,RDEV,RDEV)
        LR      R2,R2           : SKIP IF NOT DATA
        JLEFS   XRAK25
        JAL     R5,PBBC         : FREE BUF.
XRAK25  THI     R0,ETXBIT!ETBBIT        :END OF A BLOCK?
        JE      XRAK21                  :ADVANCE UNTIL END OF MESSAGE
        THI     R0,ACKBIT       : NEED TO SEND ACK CMD ?
        JE      XRAK22          :   N - SKIP
        LR      R5,R0           :SAVE CONTROL BITS
        NHI     R0,LCMBIT!0FF   :ISOLATE SEQ #
        LHI     R2,ACKCMD       : SEND ACK CMD
        PUTCMD(RCV,RDEV,RDEV)
        RLCMD(RCV,RDEV,RDEV)
        LR      R0,R5           :RESTORE CONTROL BITS
XRAK22
        LIS     R2,0            :CLEAR ERROR TIMER
        ST      R2,BSCETM,RL2,RL2
        STB     R2,RETRY,RL     :RESET RETRY CNTR
        LHL     R2,XRAKSV       : RETRIEVE RCV RETURN CODE
        CHI     R2,RCWACK*2     : WAS IT A WACK ?
        JE      IRESET          :   Y - SEND EOT
        THI     R0,ETXBIT       :LAST BLOCK?
        JN      IRESET          :Y - SEND EOT (NO CMD CHAINING)
        JAL     R5,CSLEW        :N - MUST BE ETB...CHECK NEXT CMD
        JG      XSDAT4          :DATA - SEND IT
        JL      XSDAT2          :OTHER - SEND EOT
        J       XSTTD0          :EMPTY - SEND TTD'S
:       J       XSDAT1          :GO SEND NEXT COMMAND


:       RESEND DATA : XRSDAT
:       --------------------
:       THE REMOTE HAS INDICATED THAT IT DID NOT RECEIVE OUR LAST
:       DATA BLOCK SUCCESSFULLY.  COUNT THE ERROR AND RESEND.  NOTE THAT
:       RESENDING IS MORE OR LESS AUTOMATIC SINCE WE DO NOT DEQUEUE BACKGROUND
:       COMMAND UNTIL IT IS ACK'D.

XRSDAT  DERR(XMTNAK)
	LB	R6,CCU,RL	:GET CU
	LIS	R0,1		:BUMP RETRANSMISSION COUNTER
	AHM	R0,RXMT,R6,R6
	LH	R6,E.LIN	:GET LINE FOR ERROR REPORTING
	JLFS	XRSDT1		:JUMP IF ALL LINES
	CR	R6,RL		:IS THIS THE RIGHT LINE
	JNFS	XRSDT2		:NO, SKIP AHEAD
XRSDT1	LHL	R6,E.TIM	:GET TIME (BIN NUMBER)
	AHM	R0,E.RTN,R6,R6	:BUMP COUNTER
XRSDT2	J       XSDATA          :GO SEND DATA



:       INITIALIZE TRANSMISSION : XINIT
:       -------------------------------
:       WE HAVE BID FOR LINE WITH ENQ AND REMOTE HAS GIVEN US CONTROL
:       WITH ACK0.  START SENDING MSG'S BACKGROUND HAS QUEUED.

XINIT   SBT     RL,LSTACK       :SET TO EXPECT ACK1
        RBT     RL,LSTRVI       :SET LAST ACK NOT RVI
        RBT     RL,RCVLCM       :RESET LIMITED CONVERSATIONAL MODE
        LHI     R0,RETX         : REVERSE ETX CHAR
        STB     R0,LSTXMT,RL    : RESET LAST MSG TYPE TO ETX
:       RESET OUTSTANDING SELECT ERROR TIME AND NEXT SELECT TIME
        LB      R7,CDEV,RL      : GET DEVICE INDEX
        SLHLS   R7,2            : MAKE FULLWORD INDEX
        LIS     R6,0
        ST      R6,SELTYM,R7    : SELECT ERROR TIME = 0
        ST      R6,NXTSEL,R7    : NEXT SEL. TIME = 0
        RBT     RL,CHNGBT,,     : NOTE ACTIVITY ON LINE


:       SEND DATA : XSDATA
:       ------------------
:       IF COMMAND IS NOT AVAILABLE FROM BACKGROUND, WAIT FOR ONE, KEEPING
:       REMOTE CONTENTED WITH TTD'S IF NECESSARY.  ELSE SEND COMMAND.
:       NOTE THAT DATA COMMANDS ARE NOT DEQUEUED UNTIL REMOTE ACK'S THEM,
:       OTHER COMMANDS ARE DEQUEUED IMMEDIATELY SINCE THEY REQUIRE NO REMOTE
:       RESPONSE.

XSDATA  LB      RDEV,CDEV,RL    : LOAD CURRENT DEVICE INDEX
XSDAT1  JAL     R5,CSLEW        : CHECK XMT QUEUE FOR NEXT CMD
        JG      XSDAT4          : IF DATA CMD - SEND IT

        JE      XSDAT3          : IF EMPTY - SEND EOT

:       MUST BE EOT CMD , DEQUEUE IT AND SEND EOT
XSDAT2
        ADVCMD(XMT,RDEV,RDEV)
XSDAT3  LIS     R0,0            :CLEAR ERROR TIMER
        ST      R0,BSCETM,RL2,RL2
        STB     R0,RETRY,RL     :RESET RETRY CNTR


        J       IRESET          :GO EXECUTE EOT COMMAND

:       DATA COMMAND
XSDAT4	LB	R6,CCU,RL	:GET CU
	LIS	R1,1		:BUMP XMIT MSG BLOCK COUNTER (ETX AND ETB)
	AM	R1,XMTTOT,R6,R6
	LIS     R1,XCDATA       :GET SEND DATA OP CODE
        STH     R0,BSXWR0,RL2   :SAVE CONTROL BYTE FOR SXM

:       SEND MSG AND READ RESPONSE
XSMSG   LHI     R0,SXMT-PSEG    :SET STATE FOR XMT DATA
        STH     R0,STATE,RL2
        LHI     R0,TDRESP       :SET TIMEOUT FOR DATA RESPONSE
        LHI     R4,BSCRBC       :SET RCV BUFFERLET LIMIT
        J       XMTRCV          :GO XMT AND DECODE READ RESPONSE



:       REMOTE NOT READY FOR DATA : XRNRDY
:       ----------------------------------
:       REMOTE IS NOT READY FOR NEXT DATA AND HAS SEND WACK.  WE SEND ENQ
:       IMMEDIATELY ASKING REMOTE IF ITS READY.  THIS IS NOT AN ERROR,
:       AND RESETS PENDING ERRORS.  NOTE THAT WE ASSUME REMOTE WILL DO
:       DELAYING IF IT IS NOT READY (UNLIKE TTD WHERE WE DELAY BEFORE SENDING).

XRNRDY  DERR(XMTWAK)

:       SEND ENQ
XSENQ   LIS     R1,XCENQ        :GET ENQ OP CODE
        J       XSMSG           :GO SEND AND DECODE READ RESPONSE


:       DATA XMT RESPONSE : XRDATA
:       --------------------------
:       RECEIVED A DATA BLOCK AS RESPONSE TO OUR DATA BLOCK.  IF OUR DATA
:       BLOCK ENDED IN ETX AND WE DID NOT INITIATE THIS XMT WITH A LCM
:       OF OUR OWN, IT IS A LIMITED CONVERSATIONAL RESPONSE AND
:       IS ALLOWED.  ELSE IT IS AN ERROR AND WE ASK FOR RETRANSMISSION
:       OF LAST ACKNOWLEDGEMENT.  IF THIS IS A LIMITED CONVERSATIONAL RESPONSE,
:       IT IS TAKEN AS AN ACK, THE DATA WE SENT IS DEQUEUED, AND IF THE NEXT
:       OUTPUT COMMAND IS SEND EOT, IT IS DEQUEUED ALSO.

XRDATA  LB      RDEV,CDEV,RL    : LOAD CURR. DEVICE INDEX
        LR      R14,R2          : SAVE RCV RETURN CODE
        LR      R15,R3          : SAVE RCV BUF. ADDR
XRDAT1
        PKCMD(XMT,RDEV,RDEV)
        ADVCMD(XMT,RDEV,RDEV)
        JAL     R5,PBBC
        THI     R0,ETXBIT!ETBBIT        :END OF A BLOCK?
        JE      XRDAT1                  :ADVANCE UNTIL END OF MESSAGE
        THI     R0,ACKBIT       : NEED TO SEND ACK CMD
        JE      XRDAT2          :   N - SKIP
        NHI     R0,LCMBIT!0FF   : MASK OFF UNWANTED BITS
        LHI     R2,ACKCMD       : GET ACK CMD CODE
        PUTCMD(RCV,RDEV,RDEV)
        RLCMD(RCV,RDEV,RDEV)
XRDAT2  JAL     R5,CSLEW        : ADVANCE EMPTY & SLEW THRU EOT COMMANDS
        LR      R2,R14          : RESTORE R2
        LR      R3,R15          : AND R3

:       INITIALIZE RCV PARAMETERS TO CONTINUE OPERATION FOR US
:       BRANCH THROUGH RECEIVE STATE TABLE TO HANDLE DATA RCV'D
        LB      R0,CDEV,RL      :GET DEVICE #
        SBT     R0,LCMMODE,,    :SET LCM FOR NETWORK SERVICES
        SBT     RL,RCVLCM       : SET LCM RESP. MODE FLAG
        RBT     RL,LSTACK       :IN LCM, LAST ACK WOULD HAVE BEEN ACK0
        RBT     RL,LSTRVI       :INIT LAST ACK NOT RVI
        LHI     R0,RDFIR-PSEG   : GET ADDR OF FIRST MSG ROUTINE
        STH     R0,RDPROC,RL2   : SAVE IT

        LHL     R4,SRCV,R2      :GET PROCESSOR FOR RCV DATA STATE
        J       PSEG,R4         :GO PROCESS DATA JUST RCV'D
 

:       LCM ANSWER FROM REMOTE HAS BAD FORMAT : XRBADX
:       ----------------------------------------------
:       RELEASE BUFFERLETS , THEN SEND ENQ
XRBADX  JAL     R5,PBBC         : RELEASE BIG BUFFERLETE
        J       XRBAD           : TREAT AS BAD RESPONSE


:       NO RESPONSE TO XMT : XTMOT
:       --------------------------
:       WE HAVE TIMED OUT WAITING FOR A RESPONSE TO OUR LAST TRANSMISSION.
:       ASK REMOTE TO RESENT ITS LAST ACK VIA ENQ.  NOTE THAT THIS IS COUNTED
:       AS AN ERROR.

XTMOT   DERR(XMTTO)
        LHI     R0,TDRESP       :SET TIMEOUT FOR DATA RESPONSE
        LIS     R1,XCENQ        :GET OP CODE FOR ENQ
        LHI     R4,BSCRBC       :SET RCV BUFFERLET LIMIT
        J       XMTRCV          :GO XMT AND DECODE READ RESPONSE




:       NAK RESPONSE TO ABORT MSG (ENQ)
:       -----------------------------------
:       WE HAVE JUST SENT AN ENQ TO REMOTE

XSQNAK  LB      RDEV,CDEV,RL    :GET DEVICE NUMBER
XSQNA1  PKCMD(XMT,RDEV,RDEV)
        ADVCMD(XMT,RDEV,RDEV)
        JAL     R5,PBBC         :FREE THE BUFFERS
        THI     R0,ENQBIT       :DID WE REACH THE ENQ?
        JE      XSQNA1          :N - CONTINUE FINISHING
        JAL     R5,CSLEW        :CHECK QUEUE FOR ANY DATA
        JG      XSDAT4          :DATA, SEND IT
        JL      XSDAT2          :NONE, RESET LINE WITH EOT
        J       XSDAT3          :OTHER, SEND EOT

:	TIMEOUT RESPONSE TO ABORT MSG (ENQ)
:	-------------------------------------
:	WE HAVE JUST WENT AN ENQ TO REMOTE

XTSENQ	LHI	R0,BSCRTY
	STB	R0,RETRY,RL	:FORCE TO GOTERR
	DERR(XMTTO)		:REPORT XMIT ERROR
	J	IRESET		:SHOULDN'T COME BACK, BUT IF IT DOES
				:GO AHEAD AND RESET LINE


:       TIMEOUT AWAITING TTD RESPONSE : XTTDTM
:       TIMEOUT WAITING FOR TTD RESPONSE : XTTDTM
:       --------------------------------------
:       WE MAKE ASSUMPTION THAT A NAK WAS SENT AND MISSED.  CHECK OUTPUT
:       AND IF COMMAND QUEUE STILL EMPTY, SEND TTD IMMEDIATELY.

XTTDTM	DERR(XMTTO)
	L       R0,FASTC,,      :PREPARE FOR IMMEDIATE TTD
        J       XSTTD1          :GO CHECK COMMAND QUEUE


:       WAIT FOR XMT RESOURCES : XSTTD
:       ------------------------------
:       THE OUTPUT COMMAND RING HAS GONE EMPTY WITHOUT THE BACKGROUND
:       SIGNALING END OF FILE WITH 'SEND EOT'.  WATCH RING FOR COMMAND
:       TO APPEAR AND EXECUTE COMMAND WHEN IT DOES.  TO KEEP REMOTE
:       CONTENTED UNTIL THEN, A TTD IS SENT NOW AND THEN TELLING THE
:       REMOTE TO WAIT FOR MORE DATA.
XSTTD0  LHL     R6,STATE,RL2    : GET CURRENT STATE AND SAVE
        STH     R6,OSTATE,RL2   : IT IN OLD STATE
        LHI     R0,TTDTOT       : TTD TIMEOUT INTERVAL
        A       R0,FASTC,,
        ST      R0,TTDTIM,RL2,RL2       :STORE FIRST TIME TO SEND TTD

XSTTD   LHI     R0,TDTTD        :COMPUTE TIME TO SEND TTD
        SLLS    R0,TSCALE       :SCALE
        A       R0,FASTC,,
XSTTD1  ST      R0,WTIME,RL2,RL2

:       IF COMMAND APPEARS, GO SEND IT
XSTTD2  LB      RDEV,CDEV,RL    : LOAD CURR. DEV. INDEX
        JAL     R5,CSLEW        : LOOK FOR A CMD
        JN      XSTTD8          :   DATA OR EOT - SEND IT
:       TIMEOUT TO KILL CIRCUIT IF TTD LOOP OCCURS
XSTTD4  L       R0,TTDTIM,RL2,RL2       : GET FIRST TIME TO SEND TTD
        S       R0,FASTC,,
        JGFS    XSTTD5          : SKIP IF NOT TIMEOUT
        LHI     R3,XMTTO        : REPORT XMT ERROR
        JAL     R5,SETERR,,
        J       IRESET

:       IF NOT TIME TO SEND TTD, DISMISS AND CHECK AGAIN LATER
XSTTD5  L       R0,WTIME,RL2,RL2
        S       R0,FASTC,,      :TIME TO SEND TTD ?
        JLEFS   XSTTD6          :JUMP IF SO

        TBT     RL,PTPHLT       :HALT PROTOCOL DRIVER ?
        JN      PHALT           :JUMP IF SO
        JAL     R5,PDMISS       :DISMISS PROTOCOL DRIVER
        TBT     RL,PTPHLT       :HALT PROTOCOL DRIVER ?
        JN      PHALT           :JUMP IF SO
        J       XSTTD2          :GO TEST IF COMMAND AVAILABLE

:       SEND TTD AND SET STATE TO RECEIVE RESPONSE.  NOTE THAT ALTHOUGH
:       WE DO NOT EXPECT DATA, WE ALLOW IT ANYWAY.  THIS IS FOR COMPATIBILITY
:       USING PROCESS XRENQ.
XSTTD6  LHI     R0,SXTTD-PSEG   :SET STATE FOR TTD RESPONSE
        STH     R0,STATE,RL2
        LHI     R0,TTTD         :GET TIME TO WAIT FOR RESPONSE
        LIS     R1,XCTTD        :GET OP CODE FOR TTD
        LHI     R4,BSCRBC       :SET BUFFERLET LIMIT
        J       XMTRCV          :SEND TTD AND READ RESPONSE
 
XSTTD8  LHL     R6,OSTATE,RL2   : GET OLD STATE
        STH     R6,STATE,RL2    : AND RESTORE
        J       XSDAT1          : GO TRANSMIT CMD


:
:       RECEIVED A DATA BLOCK IN RESPONSE TO A TTD:  XSTDAT
:       ---------------------------------------------------
:       RELEASE THE DATA BLOCKS AND RETRY LAST RECEIVE OPERATION.
:
XSTDAT  JAL     R5,PBBC                 :RELEASE THE DATA BLOCKS
        J       RCVRTY                  :RETRY LAST RECEIVE OPERATION

:       EXAMINE XMT CMD LIST - CSLEW
:       ----------------------------
:       REMOVE CMDS FROM XMT CMD LIST AND EXECUTE UNTIL
:       LIST IS EMPTY OR DATA OR EOT COMMAND FOUND
:       R5 - LINK
:       RDEV - INDEX TO XMT LIST WANTED
:       R0 - WORK
:       ( R4,R6,R7 USED BY CMD LIST MACROS)
:       OUTPUT
:               R2 - COMMAND CODE RETURNED
:               R3 - SECOND HALFWORD OF CMD
:               CONDITION CODE -  + DATA CMD
:                                0 LIST EMPTY
:                                - EOT CMD
CSLEW   LB      RDEV,CDEV,RL    : LOAD CURRENT DEVICE INDEX
CSLW10  PKCMD(XMT,RDEV,RDEV)              : PEEK AT NEXT CMD
        JGER    R5              : RETURN IF LIST EMPTY OR DATA CMD FOUND
        CHI     R2,TIMCMD       : RECORD TIME CMD ?
        JN      CSLW20          :   N - SKIP TO NEXT CASE
        LHL     R0,SLOWC+2,,    : GET SLOW CLOCK TIME
        JNFS    .+4
        AIS     R0,1            : PREVENT A ZERO VALUE FROM OCCURRING
        STH     R0,BBUFER,R3,   : STORE TIME
        J       CSLEWA
CSLW20  CHI     R2,YBCMD        : YELLOW BALL ?
        JN      CSLW30
        LHI     R2,OBCMD        : PUT ORANGE BALL CMD IN RCV LIST
        PUTCMD(RCV,RDEV,RDEV)
        RLCMD(RCV,RDEV,RDEV)
                                : SECOND HALFWORD OF O.B. CMD FROM Y.B.
        J       CSLEWA
CSLW30  CHI     R2,EOTCMD       : EOT COMMAND ?
        JN      CSLW40
        LR      R2,R2           : SET CONDITION CODE
        JR      R5              : RETURN
CSLW40
CSLEWA  ADVCMD(XMT,RDEV,RDEV)
        J       CSLW10          : PROCESS NEXT CMD


        :       PRADR - PROCESS CU AND DEV ADDRESS CHAR IN DATA MSG
        :       R0 - WORK
        :       R3 - ADDRESS OF FIRST BUFFERLET
        :       R4 - LINK
        :       R7 - OFFSET OF CU CHR
        :       R5 - WORK
        :       R6 - WORK
        :       RDEV - DEVICE NUMBER
PRADR   LB      R0,BBUFER,R3,R7         : GET CU ADDR CHR
        NHI     R0,03F                  : CONVERT TO NUMERIC
        LB      R5,CCU,RL               : LOAD CURR. CU NO.
        CLB     R0,CUADR,R5,            : CORRECT CU ADR ?
        JN      RTOSS                   :   N - DISCARD IT
        LB      R0,BBUFER+1,R3,R7       : GET DEV ADDR CHR
        NHI     R0,3F                   : CONVERT TO NUMERIC
        TBT     RL,POLTYP               : IS THIS A GENERAL POLL ?
        JNFS    PRADR1                  :   Y - SKIP
        :       COMPARE TO CURR. DEV. ADDR
        LB      RDEV,CDEV,RL            : GET CURR. DEV NO.
        CLB     R0,DEVADR,RDEV,         : CORRECT DEV ADDR ?
        JN      RTOSS                   :   N - DISCARD IT
        JR      R4                      : RETURN
PRADR1  JAL     R5,LKDEV                : LOOK UP DEVICE ADR
        J       RTOSS                   : UNKNOWN DEV ADDR
        STB     RDEV,CDEV,RL            : STORE CURR. DEV. NO.
        JR      R4

        :       LKDEV - LOOK UP DEVICE NUMBER FOR CURR. CU
        :       R0 - DEVICE ADR TO BE LOOKED UP
        :       R5 - LINK
        :       R6 - WORK
        :       RDEV - RETURNED DEVICE NO.
        :       SKIP RETURN IF DEVICE ADDR IS FOUND
LKDEV   LB      R6,CCU,RL               : GET CURR. CU NO
        LB      RDEV,FDEV,R6,           : GET FIRST DEVICE NO.
LKDEV1  CLB     R0,DEVADR,RDEV,         : COMPARE DEV ADDR CHR
        JE      4,R5                    : RETURN IF FOUND
        AIS     RDEV,1                  : NEXT DEVICE
        CLB     RDEV,FDEV+1,R6,         : ANY MORE DEVICES ?
        JLBS    LKDEV1
        JR      R5
 

:       SEND A POLL OR SELECT MESSAGE : SUMSG
:       -------------------------------------
:       INPUT - R4 = TYPE MSG DESIRED  
:               R3 - ADDRESS OF A BIG BUFFERLET
:       WORK  - R1 , 
:       LINK  - R5
SUMSG   LHI     R1,REOT                 : FIRST SEND EOT
        STB     R1,BBUFER,R3,
        LHI     R1,PADCHR               : NOW SEND PADS
        STB     R1,BBUFER+1,R3,
        STB     R1,BBUFER+2,R3,
        STB     R1,BBUFER+3,R3,
        LHI     R1,RSYN                 : NOW SEND SYNCS
        STB     R1,BBUFER+4,R3,
        STB     R1,BBUFER+5,R3,
        STB     R1,BBUFER+6,R3,
        STB     R1,BBUFER+7,R3,
:       NOW SEND THE POLL OR SELECT
        LB      R1,CCU,RL               : GET CURRENT CU NUMBER
        LB      R1,CUADR,R1,    : GET C.U. POLL ADDRESS
        CHI     R4,SELMSG
        JNFS    SUMSG1
        AHI     R1,20
SUMSG1  LB      R1,SPCHRS,R1    : USE TABLE TO SET BITS 0,1
        LB      R1,REVTAB,R1
        STB     R1,BBUFER+8,R3,
        STB     R1,BBUFER+9,R3, : STORE CU ADR TWICE
        CHI     R4,GPMSG
        JNFS    SUMSG2
        LHI     R1,GPDEV        : FOR G.P. MSG SET DEV ADDR TO THIS VALUE
        J       SUMSG3
SUMSG2  LB      R1,CDEV,RL
        LB      R1,DEVADR,R1,   : GET DEVICE ADDRESS
        LB      R1,SPCHRS,R1    : USE TAABLE TO SET BITS 0,1
SUMSG3  LB      R1,REVTAB,R1
        STB     R1,BBUFER+0A,R3,
        STB     R1,BBUFER+0B,R3,: STORE DEV ADR TWICE
        LHI     R1,RENQ
        STB     R1,BBUFER+0C,R3,: STORE ENQ CHAR
        LHI     R1,PADCHR       : PAD OUT MSG TO HALFWORD
        STB     R1,BBUFER+0D,R3,
        LIS     R1,0            : MSG TYPE - DATA
        LIS     R2,0E           : MSG LENGTH
        JR      R5


:       CHECK TIMES TO SEE IF OK TO POLL THIS CU
:       INPUT - RCU (CU INDEX)
:       WORK  - R6 R7
:       LINK  - R5 (SKIP RETURN IF OK TO POLL)
:       FAST POLL TEST - ANY RESPONSE IN LAST POLT1 INTERVAL
:       SLOW POLL TEST - HAS AN INTERVAL OF POLT2 PASSED SINCE LAST SLOW POLL
TSTPOL  TBT     RCU,POLLCU      : IS THIS CU IN POLLING LIST
        JER     R5              : N - RETURN TO NOT POLL
        LR      R7,RCU          : SET UP FULLWORD CU INDEX
        SLHLS   R7,2
:       TEST FAST POLL CRITERION
        L       R6,POLTYM,R7    : GET LAST POLL RESP. TIME
: CONTINUE TO FAST POLL IF THE LAST POLL RESPONSE WAS AFTER THE LAST POLL.
: THIS IS TO INSURE FAST POLLING OF ACTIVE CONTROLLERS WHEN THERE ARE INACTIVE
: CONTROLLERS ON THE SAME LINE.  DLC - 23 MAY84
        CL      R6,LSTPOL,R7
        JC      TSTP10
        AI      R6,POLT1        : ADD INTERVAL
        CL      R6,FASTC,,      : IS IT LATER THAN CURR. TIME
        JGE     TSTP10          :   Y - SET UP FOR POLL
:       FAST POLL TEST FAILS , TRY SLOW POLL TEST
        L       R6,RRINGX,RL2,RL2       :UPDATE SYNCH INPUT RING POINTER
        LHL     R6,0,R6         :
        STH     R6,RRGETX,RL2
        L       R6,LSTPOL,R7    : GET TIME OF LAST POLL
        AI      R6,POLT2        : ADD SLOW POLL INTERVAL
        CL      R6,FASTC,,      : HAS SLOW POLL INTERVAL EXPIRED ?
        JGR     R5              :   N - STRAIGHT RETURN
:       OK TO POLL
TSTP10  L       R6,FASTC,,      : UPDATE TIME OF LAST POLL
        ST      R6,LSTPOL,R7    : 
        J       4,R5            : SKIP RETURN
 
 
:       INACTIVE CU - REPORT FATAL ERROR FOR ALL DEVICES ON THE CU
:       INPUT - RCU (CU INDEX)   WORK RDEV,R3   LINK R5
INACCU  ST      R5,INAC50       : SAVE RETURN ADDR.
        LB      RCU,CCU,RL      : GET CU NUMBER
        RBT     RCU,CUPOLL,,    :INDICATE CU IS NOT ANSWERING POLLS
        LB      RDEV,FDEV,RCU,  : LOOP OVER DEVICES ON THIS CU
INAC10  STB     RDEV,CDEV,RL    : SAVE DEVICE NO.
        LHI     R3,XMTFF        : REPORT FATAL ERROR
        JAL     R5,GOTERR       : TO B.G.
        AIS     RDEV,1          : NEXT DEVICE
        CLB     RDEV,FDEV+1,RCU,: THRU FOR THIS CU ?
        JL      INAC10          :   N - REPEAT
        L       R5,INAC50
        JR      R5              : RETURN
 
        SEG     0
INAC50  WS      1
        SEG     1
 

        EM
        SUBTTL	DTR-BISYNC DTR SIGNAL PROCESSING
        RA      0
        MO      .,BSCDTR
        GL      BSCDTR,BSCDSR,ATTLST,DTRDSR


:       ISIS SYNCHRONOUS OUTPUT COMMANDS
CHALT   EQ      0               :HALT OUTPUT
CDSR    EQ      7               :CONNECT DATA SET READY BIT ARRAY
CDTROF  EQ      8               :DISABLE DATA TERMINAL READY
CDTRON  EQ      9               :ENABLE DATA TERMINAL READY


:       ISIS SYNCHRONOUS SVC OP CODES
FORCEO  EQ      2               :FORCE OUTPUT


:       ISIS SVC'S
IOCTRL  EQ      3               :I/O CONTROL


:       VARIABLES
:       ---------

        SEG     0
        WS      0               :ALIGN TO FULL WORD
DSRINT  HS      5               :CONNECT DSR WORK LIST, MUST BE WORD BOUNDRY

BSCDSR  HS      (NBILIN-1)/10+1 :DATA SET READY BIT ARRAY, 1=OFF


:       LOGICAL UNIT NUMBER TABLE
:       -------------------------
:       THE FOLLOWING TABLE CORRELATES THE BISYNC LINE NUMBER TO
:       THE ISIS LOGICAL UNIT NUMBER.  IT EXPECTS SYMBOLS BLUN0
:       BLUN1,...,BLUN|NBILIN| TO BE DEFINED CORRELATING BISYNC
:       LINE 0 TO ISIS LOGICAL UNIT X, ETC.

        SEG     1
LUN     BS      0
Q       EQ      0
        RE      NBILIN
        BC      BLUN|Q|
Q       EQ      Q+1
        LIST;   ER


:	CONFIGURE DTR/DSR HANDSHAKE LINES
:	---------------------------------

:	THE FOLLOWING CODE CREATES A BIT ARRAY DTRDSR FROM USER INPUT
:	BDTR0,BDTR1,...,BDTR|NBILIN| WHICH THE CODE TESTS TO DETERMINE
:	IF DTR/DSR HANDSHAKE MUST BE PERFORMED BEFORE DATA IS TRANSMITTED
:	OR RECEIVED (HANDSHAKE IS PERFORMED BY BACKGROUND AND IS
:       TYPICALLY RAISE DTR, WAIT FOR DSR, USE LINE, LOWER DTR, WAIT
:       FOR DSR TO DROP, RAISE DTR, ...).  BIT ARRAY IS INDEXED BY RL,
:	1 = HANDSHAKE REQUIRED.

DTRDSR	HS	0
QQ	EQ	0		:WORK SYMBOL
Q	EQ	0
	RE	NBILIN; NOLIST
QQ	EQ	QQ+(BDTR|Q|&1)^(0F-(Q&0F))
Q	EQ	Q+1
	IF Q&0F;	ELSE;
	HC QQ  ;QQ EQ 0;	EI
	ER
	IF Q&0F;	HC QQ;	EI;	LIST


:       DTR COMMAND LISTS
:       -----------------

        SEG     0
DTRBUF  WS      0               :CMD ROTOR FOR DTR ON/OFF
        RE      NBILIN*4        :EACH CMD IS TWO WORDS...DTR CMD AND HALT CMD
        WC      0               :ZERO ALL WORDS
        ER

:       ATTRIBUTE LIST HAS MAXIMUM LENGTH OF 3 BYTES -----
:          00:S1:SA
:       00 IS THE DEVICE TYPE, S1 IS THE SYNC LINE, AND SA IS THE SYNC ATTRIBUTE.

ATTLST  BS      4               :ATTRIBUTE LIST

        SEG     1
:       DETERMINE CALL TYPE

:       IF DTRDSR BIT IS SET OR DHNGBT IS SET
:          AND THE LINE SUPPORTS RS/CS THEN
:              SET DTRSDR AND CONNECT DSCDSR
:       ELSE RESET DTRDSR AND NOT CONNECT BSCDSR

BSCDTR  LR      R0,R0           :INITIALIZE ?
        JGE     DTR100          :JUMP IF NOT, ENABLE/DISABLE DTR

        TBT     R1,DTRDSR       : DTR/DSR HANDSHAKE REQUIRED  ON THIS LINE?
        JNFS    DSR020          : Y - SKIP
        IF      -HSTSWT
        TBT     R1,DHNGBT,,     : TEST IF LOGIC USES DSR
        JNFS    DSR020          :YES - SKIP
        EI
        SBT     R1,BSCDSR       :  INIT DSR OFF
        JR      R5
DSR020  LB      R2,LUN,R1       :GET LOGIC UNIT #
        LA      R3,ATTLST       :PUT ATTRIBUTE LIST ADR. IN SVC OUTPUT STRING
        LIS     R4,3            :3 BUFFER INPUT BYTES
        SVC     IOCTRL,IOQRY.+R2,,      :QUERY SYC ATTRIBUTE
        JAL     R10,CRASH       :CRASH IF CALLING ERROR
        LB      R3,ATTLST+2     :CHECK SUPPORT RS/CS OR NOT
        CHI     R3,80
        JN      DSR030          :SKIP IF NOT.
        LA      R3,DSRINT       :BUILD INITIALIZE DSR COMMAND LIST
        LI      R0,CDSR^10      :PREPARE 1ST WORD, COMMAND\BISYNC LINE NO.
        ST      R0,0,R3
        LA      R0,BSCDSR       :SET 2ND WORD, BASE ADDRESS OF BIT ARRAY
        ST      R0,4,R3
        LIS     R0,CHALT        :SET 3RD WORD, HALT COMMAND
        STH     R0,8,R3
        STH     R1,2,R3         :PUT BISYNC LINE NO. INTO 1ST WORD

        SVC     IOCTRL,FORCEO^4+R2      :CONNECT INPUT
        JAL     R10,CRASH               :CRASH IF CALLING ERROR

        JR      R5              :RETURN TO CALLER

DSR030  RBT     R1,DTRDSR       :DTRDSR NOT AVAILABLE
        JR      R5

:       ENABLE/DISABLE DTR
DTR100  TBT     R1,DTRDSR       :LINE USE DTR/DSR HANDSHAKE
        JNFS    DTR200          :JUMP IF SO, PASS ON TO HARDWARD

:       LINE DOES NOT USE DTR/DSR HANDSHAKE, COPY DTR TO DSR FOR COMPATIBILITY
        LR      R0,R0           :ENABLE/DISABLE ?
        JEFS    DTR110          :JUMP ENABLE
        SBT     R1,BSCDSR       :DISABLE DSR
        JR      R5              :RETURN

DTR110  RBT     R1,BSCDSR       :ENABLE DSR
        JR      R5              :RETURN

:       PASS DTR COMMAND TO HARDWARD
DTR200  LR      R0,R0           :ENABLE/DISABLE ?
        JEFS    DTR210          :JUMP ENABLE
        LHI     R3,CDTROFF       :GET DISABLE COMMAND
        JFS     DTR220          :GO EXECUTE

DTR210  LHI     R3,CDTRON         :GET ENABLE COMMAND
DTR220  SLLS    R1,4            :SHIFT OF 4-WORD INDEX
        STH     R3,DTRBUF,R1    :STORE DTR CMD
        LA      R3,DTRBUF,R1    :GET CMD ROTOR ADR
        SRLS    R1,4            :RESTORE LOGICAL UNIT #
        LB      R2,LUN,R1       :GET LOGICAL UNIT NO. FOR BISYNC LINE

        SVC     IOCTRL,FORCEO^4+R2      :CONNECT INPUT
        JAL     R10,CRASH               :CRASH IF CALLING ERROR
        JR      R5              :RETURN

        EM

        SUBTTL  DCB - LAYOUT OF THE DCB TABLE
:       DCB LAYOUT
        GL      PORTAB,DEVTAB,PORTUP,ZPCRCT,KLTPVC,DPORT
        GL      DMODE,DSPAPL,DSPCUA,DSPDVA
 
        SEG     A.DCB
        HS      0
DCBLKS  EQ      .-2             :START OF THE DCB'S
ORDORG  EQ      .
        ORG     DCBLKS
:       PROCESSING ROUTINE ADDRESSES
DIDRA   HS      1               : ISIS INPUT DATA ROUTINE
DICRA   HS      1               : ISIS INPUT CONTROL ROUTINE TABLE
DRDRA   HS      1               : RCV DATA ROUTINE
DRCRA   HS      1               : RCV CONTROL ROUTINE TABLE
DODRA   HS      1               : OUTPUT DATA ROUTINE
DOCRA   HS      1               : OUTPUT CONTROL ROUTINE TABLE
 
DDEV    HS      1               : DEVICE NUMBER FOR THIS DCB
DPORT   HS      1               : ASSOCIATED PORT (ZERO IF NOT LOGGED IN)
DPDEV   HS      1               : PHYSICAL DEVICE
DLDEV   HS      1               : LOGICAL DEVICE
 
DZAP    BS      1               :REASON CODE FOR DISCONNECT (FOR ACCT)
DLFLD   BS      1               : NEXT LOGON FIELD
:*************************************************************************
L.IDLE  EQ      0               :IDLE
L.MENU  EQ      10              :WAIT FOR MENU SELECTION
L.STR   EQ      11              :WAIT FOR LOGON STRING
L.PN    EQ      12              :WAIT FOR PSEUDO-NEEDLE
L.USER  EQ      13              :WAIT FOR USERNAME
L.USENT EQ      14              :USERNAME ALREADY SENT
L.PASS  EQ      15              :USERNAME OK...WAIT FOR PASSWORD
L.PSENT EQ      16              :PASSWORD ALREADY SENT
L.OK    EQ      17              :PASSWORD OK...LOGON STRING SENT
L.DIA   EQ      18              :WAIT FOR DIALECTS
L.TIIX  EQ      19              :RECEIVED TIIX
L.DSP   EQ      1A              :WAIT FOR DSP
L.ASC   EQ      1B              :WAIT FOR DSP AND ASCII
L.TURL  EQ      1C              :WAIT FOR TURKEY LEVEL
L.ACP   EQ      1D              :WAIT FOR CALL ACCEPT
L.ENA   EQ      1E              :WAIT FOR CIRCUIT ENABLE
L.GATE  EQ      20              :WAIT FOR GATEWAY INTERLINK MSG
L.NAT   EQ      30              :NATIVE MODE
:*****************************************************************************
DMODE   BS      1               : OPERATING MODE
                                :  0 = INACTIVE   1 = LOGON
                                :  2 = ASCII      3 = NATIVE
DLSEQ   BS      1               : LOGON KEY SEQUENCE NO.
DLRBA   WS      1               :ADR TO ELEMENT BEING PROCESSED
DLRBX   HS      1               :COUNT OF CHAR IN ELEMENT BEING PROCESSED
DLSTRA  HS      1               :INDEX TO FIRST ELEMENT OF LOGON STRING
DLSTRC  BS      1               :COUNT OF ELEMENTS ALREADY ACCESSED (DOUBLED)
DLSTRN  BS      1               :NUMBER OF ELEMENTS IN CHOSEN LOGON STRING (DOUBLED)
DLGET   HS      1               :HALFWORD ADR OF ROUTINE TO GET CHAR
DLSTR   HS      1               :INDEX TO MSTRS OF 1ST LOGON STRING IN MENU (BEFORE SELECTION)
                                :INDEX TO MSTRS OF SELECTED LOGON STRING (AFTER SELECTION)
DLCNT   BS      1               :NUMBER OF LOGON STRING IN THE MENU
DLROW   BS      1               :ROW # OF NEXT LOGON MSG (DOUBLED)
 
:       FIELDS FOR ISIS INPUT
DIFBA   HS      1               : FIRST BUFFERLET ADDR
DIRBA   HS      1               : CURRENT BUF. ADDR
DIRBX   HS      1               : OFFSET
DIRCNT  HS      1               : PARTIAL BYTE CNT
DTCNT   HS      1               :COUNTS # OF BYTES IN ONE MSG
:       DSP FIELDS
DISEQ   BS      1               : MSG SEQUENCE NUMBER
DIX25   BS      1               :X.25 FLAGS
: X.25 BIT DEFINITIONS (USE MASK METHOD)
X.Q     EQ      80              :DATA QUALIFIER
X.M     EQ      01              :MORE DATA COMING
:
DIPCNT  HS      1               : REMAINING BYTE CNT IN PACKET
DISRA   HS      1               : SUBROUTINE ADDRESS
DOSRA   HS      1               : OUTPUT SUBROUTINE ADDR.
DOR0    HS      1               : SAVE OUTPUT R0 VALUE
DIR0    HS      1               : SAVE R0 VALUE (CTL BYTE , SEQ.NO.)
DIIIX   WS      1               : ADR TO DISPATCH IIX MESSAGES
:
DIABIT  WS      1               :BITS INDICATING DIALECT CHOICES
:BUFFER FOR DATA FROM DSP SCREEN
DNDIG   BS      1              :# OF DIGITS IN DESTINATION ADR
DDEST  BS      7               :DESTINATION ADDRESS
DAPPL  BS      1               :APPLICATION ID
DCUA   BS      1               :CUA
DDVA   BS      1               :DVA
:
DSPCNT  BS      1               :COUNT OF ADD'L DEST DESIGNATOR INFO
DSPSAV  BS      4               :BUFFER FOR ADDL DEST DESIGANTOR INFO
DCRM    BS      1               :CRM #
DLA     BS      1               :HOLDS XPRBIT AND DEVICE TYPE

 
:       ASCII FIELDS
DADEV   HS      1               : DEVICE NO. OF ASSOCIATED PTR. DEVICE
DROW    BS      1               : ROW NUMBER
DCOL    BS      1               : COLUMN NUMBER
DLROW   BS      1               : LAST ROW FOR WRAPAROUND
DMNROW  BS      1               : MINIMUM ROW NUMBER
DMXROW  BS      1               : MAX ROW NUMBER
DRSIZE  BS      1               : ROW SIZE
DCSIZE  BS      1               : COLUMN SIZE (NO. ROWS)
DLC     BS      1               : LAST CHAR
 
CNTXMT  HS      1               :COUNT OF DATA IN LAST BLOCK ON XMT QUEUE
CNTIN   HS      1               :COUNT OF DATA IN LAST BLOCK ON IN QUEUE
        IF      DYNBUF
N0XMT   HS      1               :MIN # OF BYTES TO START XMT (IE. RELEASE XMT)
N0IN    HS      1               :MIN # OF BYTES TO START XMT (IE. RELEASE IN)
        EI

:       FIELDS FOR OUTPUT TO ISIS
DORBA   HS      1               : CURRENT BUFFERLET ADDR
DORBX   HS      1               : OFFSET
DORCNT  HS      1               : REMAINING BYTE COUNT IN BISYNC MSG
 
:       DSP FIELDS
DOPCNT  HS      1               : REMAINING BYTE COUNT IN PACKET
DOSEQ   BS      1               : MSG SEQUENCE NUMBER
DSPAPL	BS	1		: APPLICATION ID FROM CIRCUIT ENABLE PACKET
DSPCUA	BS	1		: CONTROL UNIT ADDRESS FROM CIRCUIT ENABLE PACKET
DSPDVA	BS	1		: DEVICE ADDRESS FROM CIRCUIT ENABLE PACKET
 
:       ASCII FIELDS
DOAID   BS      1               : AID CHAR
DOMSK   BS      1               : MASK FOR BITS 1,2
 
:
:       DCB FLAGS
DFLAGS  HS      1       
: DCB FLAGS DEFINITIONS (USE BIT ARRAY METHOD)
D.REQ   EQ      0               :LOGON REQUEST OUTSTANDING
D.NSRV  EQ      1               :FIRST PF-4 KEY HAS BEEN RECEIVED
D.STOR  EQ      2               :STORED LOGON STRING
D.WILD  EQ      3               :ADR NOT SPECIFIED..."WILD"
D.UND   EQ      4               :"C/R UNDELIVERED" WAS SENT...FLUSH OUT-OF-SEQ
D.GATE  EQ      5               :GATEWAY LOGON MODE
D.ERR   EQ      6               :JUST GOTTEN HOST ERROR STATUS
D.XPR   EQ      7               :REQUEST TRANSPARENT MODE
:
:
:
: END OF DCB DEFINITION
:
DCBSZ   EQ      (.-DCBLKS+0F)&0FFFF0    :SIZE OF DCB
NDCB    EQ      NDEVM+1                 :NUMBER OF DCB'S
        ORG     ORDORG
        BS      NDCB*DCBSZ              :DCB'S

        SEG     0
PORTAB  HS      NPORT           : INDEX TO DCBS BY PORT NO.
DEVTAB  HS      NDEVM           : INDEX TO DCBS BY DEVICE NO.
DCBX    HS      1               : INDEX TO LAST ALLOCATED DCB
FSHBRK  HS      NGRP
XONENA	HS	NGRP		:1 IF USING XON FEATURE
YONENA	HS	NGRP		:1 IF USING REVERSE BACKPRESSURE FEATURE
HAFDUX	HS	NGRP		:1 IF HALF DUPLEX PORT
DOECHO  HS      NGRP            : 1 IF ECHOING
KATKAN  HS      NGRP            : 1 IF KATAKANA CHAR SET USED
BRKFSH  HS      NGRP            : 1 IF FLUSH OUTPUT ON RCVING BREAK
DUMTAB  HS      NGRP            : DUMMY TABLE USED FOR OUT OF RANGE PARMS.
ECTLI	HS	NGRP		:ECHO CONTROL-I TO CONTROL-I IF ECTLI IS 1
ECTLH	HS	NGRP		:ECHO CONTROL-H TO CONTROL-H IF ECTLH IS 1
ECRLF	HS	NGRP		:1 IF ECHOING CAR.RET. , RUBOUT TO LINE FEED
ELFCR	HS	NGRP		:1 IF ECHOING LINE FEED TO CAR. RET.
PARITY	HS	NGRP		:PARITY ENABLED. 1 IF EVEN PARITY FORCED BY TRANSMITTER.
UNAME	HS	NGRP		:1 IF IN USER NAME PART OF LOGIN
CRDE	HS	NGRP		:1 IF CARRIAGE RETURN DELAY ENABLED
BRATE	BS	NPORT 		:4 BIT INPUT BAUD RATE LEFT, 4 BIT OUTPUT BAUD RATE RIGHT
PAB	BS	NPORT 		:1 UNUSED BIT,3 BIT PARAMTER A,AND 4 BIT PARAMETER B ON THE RIGHT
PCD	BS	NPORT 		:PARAM C LEFT (4 BITS), PARAM D RIGHT (4 BITS)

ZPCRCT	HS	NDEVB		:BIT ARRAY OF CIRCUITS TO BE ZAPPED
				: 1 IF CIRCUIT TO BE ZAPPED
KLTPVC	RE	NDEVB		:BIT ARRAY OF KILLED PVC CIRCUITS NOT TO BE REBUILT
	HC	0FFFF		: 1 IF OK TO LOGON
	ER

PORTUP  HS      NGRP            : 1 IF PORT IS UP
        SEG     1
        EM
        SUBTTL	DEFSYM-BACKGROUND SYMBOL DEFINITIONS
:       REGISTER DEFINITIONS FOR BACKGROUND
RBX     EQ      R2
RBA     EQ      R3              : PTR TO MSG. BUF.
RSUM    EQ      R9              : ACCUMULATING CHECK SUM (XMT DIRECTION)
RCNT    EQ      R9              : PARTIAL DATA COUNT (RCV DIRECTION)
RMASK   EQ      R9              : BIT 1,2 MASK FOR ASCII MODE OUTPUT
RCOL    EQ      R11             : COLUMN NUMBER FOR ASCII INPUT
RLC     EQ      R1              : LAST CHAR FOR ASCII INPUT
RDCB    EQ      R12             : POINTER TO DCB
RDEV    EQ      R11             : DEVICE NUMBER
 
 
:       DEFINE SYMBOLS FOR INPHND MODULE (ISIS INPUT HANDLER)
        GL      ACTIVD,ACTIVC,DCBLKS,DCBICC
        GL      ECHO,AUTOBP,PTIMEO,PSEGNO
        GL      PSEG
        GL      CRIPOM,CRNAR,CRINVM,CRINVN
 
DCBICC  EQ      0
CRNAR   EQ      60
CRIPOM  EQ      61
CRINVM  EQ      62
CRINVN  EQ      63
ACTIVD  EQ      DIDRA-DCBLKS    : DATA ACTIVATION RTE
ACTIVC  EQ      DICRA-DCBLKS    : CTL RTE ACTIVATION TABLE
 
PSEG    EQ      SEG1
PSEGNO  EQ      1               : SEGMENT NUMBER FOR TABLES AND RTES
ECHO    EQ      0
AUTOBP  EQ      0               : DONT WANT AUTO BPACK PRESSURE
PTIMEO  EQ      0               : DONT WANT TIMEOUT CODE
       SUBTTL  MSGS - CHARACTER SET AND MSG DEFINITIONS
        GL      AFF,AMODE,LMODE
:       3270 CHAR DEFINITIONS AND CANNED MSGS
        LO      BSCCHR
        SEG     0
 
:       3270 COMMAND CHAR CODES

WCMD    EQ      0F1             : WRITE CMD
EWCMD   EQ      0F5             : ERASE / WRITE CMD
RBCMD   EQ      0F2             : READ BUFFER CMD
RMCMD   EQ      0F6             : READ MODIFIED CMD
CPCMD   EQ      0F7             : COPY CMD
EAUCMD  EQ      06F             : ERASE ALL UNPROTECTED CMD
 
:       WRITE CONTROL CHAR (WCC) VALUES
 
:       CRT WCCS
WCCAKM  EQ      0C7             : ALARM , RESTORE KEYBOARD , REST. MDT BITS
WCCKM   EQ      0C3             : KEYBOARD , MDT BITS
WCCK    EQ      0C2             : KEYBOARD
WCCA    EQ      0C4             : SET ALARM
WCCAK   EQ      0C6             : SET ALARM , UNLOCK KBD.
WCCN    EQ      40              : NO ACTION
 
WCCALM  EQ      4
:       PRINTER WCC S
WCCPNS  EQ      0C8             : NL FORMAT , START PRINT
WCCP4S  EQ      0D8             : 40 CHAR LINE , START PRINT
WCCP6S  EQ      0E8             : 64 CHAR LINE , START PRINT
WCCP8S  EQ      0F8             : 80 CHAR LINE , START PRINT
WCCPN   EQ      40              : NL FORMAT
WCCP4   EQ      50              : 40 CHAR LINE
WCCP6   EQ      60              : 64 CHAR LINE
WCCP8   EQ      0F0             : 80 CHAR LINE
 
:       COPY CONTROL CHAR ( CCC ) VALUES
  
:       FIELD ATTRIBUTE CHAR CODES
:       NAMING CONVENTION - 
:       U/P = UNPROTECTED / PROTECTED
:       A/N = ALPHA / NUMERIC
:       N/D/I = NON-DISPLAY / DISPLAY / INTENSE DISPLAY
ATUAD   EQ      40
ATUAI   EQ      0C8
ATUAN   EQ      04C
ATUADM  EQ      0C1                     : UNPROT.,DISPLAY,MOD.DATA
ATUANM  EQ      4D                      : UNPROT.,DISPLAY,MOD.DATA
ATPNN   EQ      7C
ATPND   EQ      0F0
ATPNI   EQ      0F8
ATPAD   EQ      60
 
:       AID CHAR CODES
AIDCRT  EQ      60              : NO AID GENERATED - CRT
AIDPTR  EQ      0E8             : NO AID GENERATED - PRINTER
AIDENT  EQ      07D             : ENTER
AIDPF1  EQ      0F1             : PF KEY AIDS
AIDPF2  EQ      0F2
AIDPF3  EQ      0F3
AIDPF4  EQ      0F4
AIDPF5  EQ      0F5
AIDPA1  EQ      6C              : PA KEY AIDS
AIDPA2  EQ      6E
AIDPA3  EQ      6B
AIDCLR  EQ      6D              : CLEAR KEY AID
AIDTST  EQ      0F0             : AID FOR TEST REQUEST KEY
AIDSP   EQ      7E              : AID FOR SELECTOR PEN
 
:       STATUS AND SENSE CODES
DEVEND  EQ      0C240           : DEVICE END STATUS

:       3270 ORDER CODES
SF.     EQ      1D              : START FIELD
SBA.    EQ      11              : SET BUFFER ADDRESS
IC.     EQ      13              : INSERT CURSOR
PT.     EQ      05              : PROGRAM TAB
RA.     EQ      3C              : REPEAT TO ADDRESS
EAU.    EQ      12              : ERASE UNPROTECTED TO ADDRESS
 
:       3270 EBCDIC CHARS
ESC.    EQ      27
STX     EQ      02
ETX     EQ      03
ENQ.    EQ      2D
 
A.      EQ      0C1
B.      EQ      0C2
C.      EQ      0C3
D.      EQ      0C4
E.      EQ      0C5
F.      EQ      0C6
G.      EQ      0C7
H.      EQ      0C8
I.      EQ      0C9
J.      EQ      0D1
K.      EQ      0D2
L.      EQ      0D3
M.      EQ      0D4
N.      EQ      0D5
O.      EQ      0D6
P.      EQ      0D7
Q.      EQ      0D8
R.      EQ      0D9
S.      EQ      0E2
T.      EQ      0E3
U.      EQ      0E4
V.      EQ      0E5
W.      EQ      0E6
X.      EQ      0E7
Y.      EQ      0E8
Z.      EQ      0E9
 
N0.     EQ      0F0
N1.     EQ      0F1
N2.     EQ      0F2
N3.     EQ      0F3
N4.     EQ      0F4
N5.     EQ      0F5
N6.     EQ      0F6
N7.     EQ      0F7
N8.     EQ      0F8
N9.     EQ      0F9
 
NULL.   EQ      0               : NULL CHAR
SP.     EQ      40              : SPACE
COLON.  EQ      7A              :COLON
DASH.   EQ      60              : DASH CHAR
SEMI.   EQ      4E              : SEMICOLON
CENT.   EQ      4A              : CENT CHAR
DQTE.   EQ      7F              : DOUBLE QUOTE
FM.     EQ      1E              : FIELD MARK CHAR
QUES.   EQ      6F              :QUESTION MARK
DOT.    EQ      4B              :PERIOD

:       ASCII CONTROL CODES
AFF     EQ      0C
 
 
PKTMAX  EQ      $080                    : PACKET MAX = 128 DEC.
:       DATA PACKET TYPES
DPKT    EQ      80              : DATA PACKET - M BIT NOT SET
DMPKT   EQ      81              : DATA PACKET - M BIT SET
QPKT    EQ      82              : Q BIT PACKET ( CONTROL MESSAGES )
QMPKT   EQ      83              : Q BIT PACKET - M BIT ALSO SET
UDPKT   EQ      8C              : USER DATA PACKET (PART OF CALL REQUEST)
                                : STARTS WITH PROTOCOL ID BYTE - 16 BYTES MAX
INTPKT  EQ      8D              :  INTERRUPT PACKET - HAS 1 BYTE USER DATA
RSTPKT  EQ      8E              : RESET PACKET
 
:       3303 MSG ID CODES
CMDMSG  EQ      00              : COMMAND MESSAGE ( HOST TO TERMINAL DATA)
DATMSG  EQ      01              : DATA MESSAGE ( TERMINAL TO HOST DATA )
STAMSG  EQ      02              : STATUS MESSAGE
ACKMSG  EQ      04              : ACKNOWLEDGEMENT MESSAGE
REQCLR  EQ      08              : INVITATION TO CLEAR
CUDMSG  EQ      10              : COMMAND UNDELIVERED MESSAGE
MABMSG  EQ      11              : DATA MESSAGE UNDELIVERED
CIRENA  EQ      12              : CIRCUIT ENABLED MESSAGE
ENACON  EQ      14              : ENABLE CONFIRMATION MESSAGE
 
:       CIRCUIT MODE DEFINITIONS
IDMODE  EQ      0               : IDLE MODE
LMODE   EQ      1               : LOGON MODE
AMODE   EQ      2               : ASCII MODE
NMODE   EQ      3               : MATIVE MODE
 
 
:       ASCII CHAR CODES
ACR     EQ      0D              : CARRIAGE RETURN
ALF     EQ      0A              : LINE FEED
ABS     EQ      08              : BACK SPACE
ABEL    EQ      07              : BELL CHAR
ASEMI   EQ      03B             : SEMICOLON
A0.     EQ      30              : 0
A9.     EQ      39              : 9
 
:       TABLE OF 3270 GRAPHIC CHRS USED FOR POLLING ADDRS.
:       ATTRIBUTES
:       INDEX BY A 6-BIT VALUE TO GET THE CORRESPONDING
:       GRAPHIC CHAR
SPCHRS  XC      40C1C2C3C4C5C6C7C8C94A4B4C4D4E4F
        XC      50D1D2D3D4D5D6D7D8D95A5B5C5D5E5F
        XC      6061E2E3E4E5E6E7E8E96A6B6C6D6E6F
        XC      F0F1F2F3F4F5F6F7F8F97A7B7C7D7E7F
 
:       REVCHR - MACRO TO REVERSE A CHAR
REVCHR  MACRO(CHAR,QZZ) [NOLIST
QZZ     EQ          0
        IF CHAR&80     ;QZZ EQ QZZ+01;      EI
        IF CHAR&40     ;QZZ EQ QZZ+02;      EI
        IF CHAR&20     ;QZZ EQ QZZ+04;      EI
        IF CHAR&10     ;QZZ EQ QZZ+08;      EI
        IF CHAR&08     ;QZZ EQ QZZ+10;      EI
        IF CHAR&04     ;QZZ EQ QZZ+20;      EI
        IF CHAR&02     ;QZZ EQ QZZ+40;      EI
        IF CHAR&01     ;QZZ EQ QZZ+80;      EI
        LIST
        ]

 
:       REVTAB - TABLE FOR REVERSING CHARS
Q       EQ      0
REVTAB  BS      0
        RE      100
        REVCHR(Q,QQ)
        BC      QQ
Q       EQ      Q+1
        ER
 
 

:       EBCASC - EBCDIC TO ASCII TRANSLATION TABLE
:       ANY EBCDIC CHARS REQUIRING SPECIAL HANDLING HAVE 0 TABLE ENTRY
EBCASC  RE      40
        BC      0               : 0-3F
        ER
        BC      20,0,0,0,0,0,0,0                : 40-47
        BC      0,0,5B,2E,3C,28,2B,7C           : 48-4F
        BC      26,0,0,0,0,0,0,0                : 50-57
        BC      0,0,21,24,2A,29,3B,5E           : 58-5F
        BC      2D,2F,0,0,0,0,0,0               : 60-67
        BC      0,0,7C,2C,25,5F,3E,3F           : 68-6F
        BC      0,0,0,0,0,0,0,0                 : 70-77
        BC      0,60,3A,23,40,27,3D,22           : 78-7F
        BC      0,61,62,63,64,65,66,67          : 80-87
        BC      68,69,0,0,0,0,0,0               : 88-8F
        BC      0,6A,6B,6C,6D,6E,6F,70          : 90-97
        BC      71,72,0,0,0,0,0,0               : 98-9F
        BC      0,7E,73,74,75,76,77,78          : A0-A7
        BC      79,7A,0,0,0,0,0,0               : A8-AF
        BC      0,0,0,0,0,0,0,0                 : B0-B7
        BC      0,0,0,0,0,0,0,0                 : B8-BF
        BC      7B,41,42,43,44,45,46,47         : C0-C7
        BC      48,49,0,0,0,0,0,0               : C8-CF
        BC      7D,4A,4B,4C,4D,4E,4F,50         : D0-D7
        BC      51,52,0,0,0,0,0,0               : D8-DF
        BC      5C,0,53,54,55,56,57,58          : E0-EF
        BC      59,5A,0,0,0,0,0,0               : E8-EF
        BC      30,31,32,33,34,35,36,37         : F0-F7
        BC      38,39,0,0,0,0,0,0               : F8-FF
 

:       ASCEBC - ASCII TO EBCDIC TRANSLATION TABLE
:       ANY ASCII CHARS REQUIRING SPECIAL HANDLING HAVE A 0 TABLE ENTRY
ASCEBC  RE      20
        BC      0                               : 0-1F
        ER
        BC      40,5A,7F,7B,5B,6C,50,7D         : 20-27
        BC      4D,5D,5C,4E,6B,60,4B,61         : 28-27
        BC      0F0,0F1,0F2,0F3,0F4,0F5,0F6,0F7 : 30-37
        BC      0F8,0F9,7A,5E,4C,7E,6E,6F       : 38-3F
        BC      7C,0C1,0C2,0C3,0C4,0C5,0C6,0C7  : 40-47
        BC      0C8,0C9,0D1,0D2,0D3,0D4,0D5,0D6 : 48-4F
        BC      0D7,0D8,0D9,0E2,0E3,0E4,0E5,0E6 : 50-57
        BC      0E7,0E8,0E9,4A,05F,5F,5F,6D      : 58-5F
        BC      79,81,82,83,84,85,86,87         : 60-67
        BC      88,89,91,92,93,94,95,96         : 68-6F
        BC      97,98,99,0A2,0A3,0A4,0A5,0A6    : 70-77
        BC      0A7,0A8,0A9,6A,4F,0D0,0A1,00    : 78-7F
 
 

:       CANNED MSGS
 
:       MACROS FOR CONVERTING NUMBERIC BUFFER ADDRESSES TO CHARS
SPC     MACRO(C)                : GIVEN A NUMBER C - PRODUCE BC WITH CHAR
        [
QQX     EQ      C&0F
        IF      QQX-9
QQY     EQ      0
        ELSE
        IF      QQX-1
QQY     EQ      80
        ELSE
QQZ     EQ      (C^-3)+QQX
QQY     EQ      QQT|QQZ|
        EI
        EI
        BC      C+40+QQY
        ]
 
:       DEFINE SYMBOLS NEEDED BY SPC
QQT0    EQ      0
QQT1    EQ      80
QQT2    EQ      0
QQT3    EQ      80
QQT4    EQ      0
QQT5    EQ      0
QQT6    EQ      80
QQT7    EQ      80
 
:       SBAC - USES ROW NO , COL. NO AND ROW SIZE TO CALC.
:       BUFFER ADDR. , IT THEN CREATES TWO BC S FOR THE BUF. ADDR CHARS
SBAC    MACRO(R,C,CMAX)
        [
QQ1     EQ      R*CMAX+C
QQ2     EQ      QQ1^-6
        SPC(QQ2)
QQ2     EQ      QQ1&3F
        SPC(QQ2)
        ]
 
 
MSGXNO  WS      0
        RE      NDEVM
        WC      0
        ER
 
MSGRNO  WS      0
        RE      NDEVM
        WC      0
        ER
MSGXR0  HS      NDEVM
MSGRR0  HS      NDEVM
 
 
MSG1    HC      $A11
        BC      ESC.,EWCMD,WCCAKM
        BC      SBA.,40,40,IC.
        BC      RA.,0C2,60,A.
 
MSG2    HC      2
        BC      ESC.,RBCMD
 
MSG3    HC      2
        BC      ESC.,RMCMD
 
MSG4    HS      1
        BS      40
 
:
: CLEAR SCREEN AND UNLOCK KEYBOARD MESSAGE
:
MSG5    HC      4
        BC      ESC.,EWCMD,WCCAKM,IC.

: CLEAR SCREEN and unlock keyboard message without IC.
MSG6    HC      3
        BC      ESC.,EWCMD,WCCAKM

:       NET MODE MESSAGES
 
:
: UNLKB - UNLOCK KEYBOARD ONLY
:
UNLKB   HC      3
        BC      ESC.,WCMD,WCCK
:
: DISCONNECT REASON CODE FOR ACCT.
:
DZ.2    EQ      2               :DROP BY HOST
DZ.3    EQ      3               :DROP BY USER
DZ.20   EQ      $A20            :PROTOCOL VIOLATION
DZ.21   EQ      $A21            :RESOURCE LIMIT EXCEEDED
	SUBTTL	ISIS Front End Handler Package	- FRNTND.LIB
:******************************************************************
:
:	This program is the sole property and confidential
:	information of Tymshare, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.
:
:*******************************************************************
	RA	0		:	FRNTND.LIB	MFR 08/12/81
:
:	This package is an ISIS Front End interface to Tymnet. It
:	is used to service the ISIS input ring, and to activate user
:	defined routines whenever a message is found for a port and
:	optionally for output service when output requests are pending.

:	The package is designed to permit the activation routines to be
:	defined on an individual port basis if desired. It is also
:	designed so that context within a process can be indicated by 
:	dynamically changing to a different set of activation routines.
:
:			Conventions
:
:	The following symbols are to be provided by the user:
:
:	ECHO	if TRUE causes Tymsat echoing for terminals
:	AUTOBP	if TRUE causes automatic backpressure application and release
:		for a port based upon comparing number of characters
:		in input buffer and MAXCHAR.
:	PTIMEO	if TRUE port timeouts are available
:	MAXCHAR	maximum number of characters in a port's input buffer
:		before backpressure should be applied. (Only needed if AUTOBP is TRUE)
:	OUTPROC	if TRUE then output activation code will be included.
:	WAITZA if TRUE then ZAPPER acknowledgements will be requested from
:		ISIS and code will be included to clean up the port upon
:		receipt of the ZAP ACK message. (User will not have to reset
:		ACP.)
:
:	The following symbol is to be initialized by the user:
:
:	PECHO	a bit for each port. If set then echoing will be honored
:		for the port, otherwise defered echo mode will not be
:		honored.
:
:	The following symbols may be provided by the user:
:	(If not provided, default values will be used)
:
:	CRIPOM	crash code for invalid port zero message (default 20x)
:	CRNAR	crash code for no activation routine found (default 21x)
:	CRINVN	crash code for invalid needle received (default 22x)
:	CRINVM	crash code for invalid message received (default 23x)
:
:	The following data structures are to be provided and initialized
:	 by the user: (They may be located in any segment)
:
:	DCB	Device Control Block, a data structure which contains all
:		the context information for a port. There should be NPORT
:		DCB's defined starting at address DCBLKS. Within each DCB
:		the following offsets must be defined:
:			DCBICC	input character count (halfword)
:			ACTIVD	relative address in A.CODE of data
:				activation routine.
:			ACTIVC	relative address in A.CODE of a table of
:				halfword offsets in A.CODE of routines
:				for each possible control message.
:			ACTIVT	relative address in A.CODE of timeout
:				activation routine.
:			ACTIVO	relative address in A.CODE of output
:				activation routine. (Only needed if OUTPROC
:				is TRUE.)

:
:	PORTAB	Port Table, a halfword array containing entries for each
:		port which are the relative offset from DCBLKS of the
:		DCB for the port.
:
:	In addition, activation routines must be defined for port zero
:	messages (ACTIV0) to for needles (ACTIVN). These labels should
:	be the location of the actual routine not offsets in A.CODE.
:
:	Whenever a data or control message activation routine is called,
:	the following registers are set up:
:		R1	port number
:		R2	message type
:		R5	link register
:		R12	DCB pointer
:		R14	input ring pointers
:
:	The activation routines are responsible for extracting all the
:	message data for the current logical record from the input ring.
:	Upon return, this package willend the logical input record (ELIR).
:	Therefore R14 must be pointing to the end of the message
:	when this package regains control. All other registers may be
:	smashed.
:
:	Needles are handled differently. The are parsed and the following
:	registers loaded.
:		R1	port number
:		R2	number of characters in username
:		R5	link register
:		R6	invoice number
:		R7	destination host number
:		R8	originating node number
:		R9	originating host number
:		R10	originating port number
:		R11	dialect code
:		R13	TID
:		R14	input ring pointer
:
:	Upon a needle activation, everything up to and including the
:	username length will have been extracted from the input ring.
:	The ACTIVN routine is responsible for extracting the username.
:
:	If PTIMEO is true then a normal return from any activate'ed
:	process indicates that the timeout state of the port should not
:	be modified. If a skip return is taken, then R0 will be
:	examined. If R0 is non-zero, a timeout for that
:	many seconds will be set for the port. If R0 is zero then any 
:	timeout for the port will be cleared. When a timeout expires for a port
:	the timeout activation routine for the port will be called with
:	the following registers set up:
:		R1	port number
:		R5	link register
:		R12	DCB pointer
:
:	Upon return from the timeout activation routine, the same
:	skip/normal return convention is followed.
:
:	The user may also set or clear a timeout for a port directly.
:	The routines SETTO and CLRTO are used to set or clear a
:	timeout for a port respectively. They are used when a timeout
:	is to be set (or cleared) at a time other than a the return from
:	an activation. The routines should be called with R1 = port number.
:	For SETTO R0 should contain the interval, in seconds, until
:	the timeout activation routine for the DCB in activated.
:
:	The output routine searches for any ports requiring output service
:	which are not backpressured. For each such port, the output
:	activation routine found in the port's DCB will be activated
:	with the following registers set up:
:		R1	port number
:		R5	link register
:		R12	DCB pointer
:
:	Upon return from the output activation routine, the same
:	skip/normal return convention for timeouts is followed.
:
:	The following routines are to be called by the user (link R0).
:
:	IZFRNT	at initialization time, after calling IZT.
:	INPUT	from EXEC loop, to process input from ISIS.
:	OUTPUT	from EXEC loop, to process output requests.
:
:	In order to facilitate setting up the control message
:	activation routine table some symbols, routines, and macros
:	have been defined.
:
:	The following symbols have the values of the offsets from A.CODE of
:	a number of control message processing routines:
:		Symbol	Routine	Description
:		XTOSS	TOSS	tosses the message
:		XZAP	ZAP	handles zapper
:		XZACK	ZACK	handles zapper acknowledgement
:		XNOSEND	NOSEND	handles backpressure
:		XRESEND	RESEND	handles release backpressure
:		XGOBBLE	GOBBLE	handles gobbler
:		XFLBACK	FLBACK	handles flush backward
:		XEDEM	EDEM	handles enter deffered echo mode
:		XLDEM	LDEM	handles leave defered echo mode
:		XGB	GB	handles green ball
:		XRB	RB	handles red ball
:		XOB	OB	handles orange or black ball
:		XPNEED	PNEED	handles psuedo needle
:		XXLIM	XLIM	handle xmit limit
:		XINVAL	INVAL	crashes with invalid message code

:	The following macros are used to set up the tables:
:
:		HTABVT with argument table name is used to set up the 
:			process table for a typical virtual terminal port.
:
:		HTABIA with argument table name is used to set set up the
:			process table for an inactive port.
:
:		CHGTAB	with arguments table name, msg number, and routine
:			label is used to substitute for a default process
:			routine in the table.
::	Example:
:		To set up the control message activation routine table for
:		a virtual terminal handler which must call a routine to
:		release resources (RELRSC) upon losing the circuit on a port
:		the following code might be used.
:
:			SEG	A.CODE
:			MO	.,FRNTND
:
:			HTABVT(VTAB)	:GENERATE DEFAULT TABLE
:			CHGTAB(VTAB,9E,RELRSR)	:CHANGE ZAPPER HANDLER
:		RELRSC	------		:CODE TO CLEAN UP AND RELEASE
:			------		:RESOURCES USED BY PORT
:			J	ZAP	:JUMP TO ZAP PROCESSOR TO CLEAN
:					:UP ITS TABLES
:			EM
:			END
:
:	It should be noted that the above code is in the module FRNTND.
:	This is the Input Handler module. The preceeding symbols, routines
:	and macros are not global'ed so the code must be in the same
:	module or the symbols LOCAL'ed.
:	It should also be noted that the user defined processing
:	routines should jump to the default process routine or perform
:	similar processing on the input ring and status indicators.
:
:
	GL	NPORT,ECHO,DEM,PECHO,XLIMIT,ACP,TOISIS,FRISIS
	GL	IZFRNT,INPUT,RPORT,RDCB,AUTOBP,OUTPROC,PTIMEO
	GL	ACTIV0,ACTIVD,ACTIVC,ACTIVN,ACTIVT,EMPTYI,EMPTYO
	GL	CRIPOM,CRNAR,CRINVN,CRINVM
 IF	OUTPROC
	GL	ACTIVO,OUTPUT,OUTDAT,FLAGS
 EI
 IF	AUTOBP
	GL	AUTOBP
 EI

	MO	.,FRNTND

RPORT	EQ	R1		:PORT CURRENTLY BEING WORKED WITH
RDCB	EQ	R12		:POINTER TO DCB

	SEG	A.DATA

XLIMIT	BS	NPORT		:MAX NUMBER OF DATA CHARACTERS THAT CAN BE SENT
				:IN ONE MESSAGE
NGRP	EQ	(NPORT+0F)/10	:NUMBER OF PORT GROUPS TO PROCESS
ACP	HS	NGRP		:ACTIVE PORTS BIT ARRAY
TOISIS	HS	NGRP		:PORTS WE CAN SEND DATA ON
FRISIS	HS	NGRP		:PORTS WE HAVE NOT BACKPRESSURED
DEM	HS	NGRP		:PORTS IN DEFERED ECHO MODE
 IF	OUTPROC
FLAGS	HS	1		:BASE ADDRESS OF BIT ARRARYS. FIRST
				:HALFWORD WASTED TO AVOID BIT DISPLACE-
				:MENTS OF ZERO.
OUTDAT	HS	NGRP		:PORTS WITH OUTPUT REQUESTS WAITING
 EI
PECHO	HS	NGRP		:PORTS FOR WHICH ECHO SHOULD BE PERFORMED
 IF	\WAITZA
 ELSE
	REMARK %PLEASE DEFINE WAITZA SWITCH. DEFAULT OFF ASSUMED%%
WAITZA	EQ	0
 EI

 IF	WAITZA
	GL	CNTRL
  IF	\CNTRL
CNTRL	EQ	CNTRL!80	:SET ZAP ACK BIT
  ELSE
CNTRL	EQ	80
  EI
 EI

REGSAV	HS	20		:REGISTER SAVE AREA
RETPTR	HS	2		:RETURN POINTER
RETRN	HS	2		:RETURN ADDRESS FOR ACTIV ROUTINE
SPORT	HS	1		:SAVE AREA FOR PORT NUMBER
SDCB	HS	1		:SAVE AREA FOR DCB POINTER
SLOOP	HS	1		:SAVE AREA FOR OUTPUT LOOP COUNTER
 IF	OUTPROC
PRTSVC	HS	1		:PORTS ELIGIBLE FOR SERVICE INDICATOR
 EI

  IF	PTIMEO			:PORT TIMEOUT
TSAVE	HS	4		:SAVE AREA FOR TIMEOUT ACTIVATOR
PTIME	HS	NGRP		:PORTS ON ACTIVE TIMEOUT
ATIME	HS	2*NPORT		:ACTIVATION TIME
  EI

:
:	DEFINE CRASH CODES IF USER HAS NOT
:

  IF	\CRIPOM
  ELSE
CRIPOM	EQ	20	:INVALID PORT ZERO MESSAGE
  EI

  IF	\CRNAR
  ELSE
CRNAR	EQ	21	:NO ACTIVATION ROUTINE IN DCB
  EI

  IF	\CRINVN
  ELSE
CRINVN	EQ	22	:INVALID NEEDLE RECEIVED
  EI

  IF	\CRINVM
  ELSE
CRINVM	EQ	23	:INVALID MESSAGE RECEIVED
  EI


	SEG	A.CODE

:	HANDY INDEXABLE HALFWORD BIT MASKS
HMASK	HC	8000,4000,2000,1000,800,400,200,100,80,40,20,10,8,4,2,1

:	BIT ARRAY TO IDENTIFY DATA MESSAGES
DATAM	HC	07FFF,-1,-1	:00
	HC	-1,-1,-1	:30
	HC	-1,-1,-1	:60
	HC	0FFFC,0,0	:90
	HC	0,0,0		:C0
	HC	0		:F0

LENGTH	BC	0		:MESSAGE LENGTH TABLE
	RE	9D;	BC	.-LENGTH+1;	NOLIST;	ER;	LIST	:DATA TEXT STRINGS
	BC	1		: 9E	DETACH
	BC	1		: 9F	DISCONNECT
	BC	1		: A0	APPLY BACKPRESSURE
	BC	1		: A1	RELEASE BACKPRESSURE
	BC	1		: A2	FLUSH FORWARD
	BC	1		: A3	FLUSH BACKWARD
	BC	1		: A4	BLACK BALL
	BC	1		: A5	GREY BALL
	BC	1		: A6	ENTER "DEM"
	BC	1		: A7	LEAVE "DEM"
	BC	1		: A8	ENTER "TRANSPARENCY"
	BC	1		: A9	LEAVE "TRANSPARENCY"
	BC	1		: AA	GREEN BALL
	BC	1		: AB	RED BALL
	BC	1		: AC	YELLOW BALL
	BC	1		: AD	ORANGE BALL
	BC	1		: AE	"BREAK" DETECTED
	BC	1		: AF	"HANG UP"
	BC	2		: B0	QUERY TERMINAL PARAMETER
	BC	3		: B1	SET TERMINAL PARAMETER
	BC	4		: B2	PSEUDO-NEEDLE
	BC	2		: B3	LOGON CHARACTER
	BC	2		: B4	NORMAL LOGON STATUS
	BC	2		: B5	LOGON FAILURE
	BC	8		: B6	SUCCESSFUL LOGON FROM THIS PORT
	BC	6		: B7	ADDENDUM TO ACCOUNTING
	BC	1		: B8	SUPER-"HANG UP"
	BC	2		: B9	TRANSMIT LIMIT
	BC	1		: BA	BREAK END
	BC	1		: BB	ZAPPER ACKNOWLEGEMENT
	BC	1		: BC	ENTER ALTERNATE OUTPUT DEVICE MODE
	BC	1		: BD	LEAVE ALTERNATE OUTPUT DEVICE MODE
	BC	2		: BE	ZAP WITH REASON
	BC	1		: BF	START IIX
	BC	1		: CO	TERMINATE IIX

:		**INTERFACE DATA TYPES**


NEDMSG	EQ	0		:NEEDLE
FIRST	EQ	9E		:FIRST MESSAGE IN LIST
DETMSG	EQ	9E		:DETACH MESSAGE
ZAPMSG	EQ	9F		:DISCONNECT MESSAGE
NOSMSG	EQ	0A0		:APPLY BACK-PRESSURE
SNDMSG	EQ	0A1		:RELEASE BACK-PRESSURE
GOBMSG	EQ	0A2		:FLUSH OUTPUT
BKGMSG	EQ	0A3		:FLUSH INPUT
BLKMSG	EQ	0A4		:DATA LOST IN THIS DIRECTION
GRYMSG	EQ	0A5		:DATA LOST IN OPPOSITE DIRECTION
EDMMSG	EQ	0A6		:ENTER DEFERED ECHO MESSAGE
LDMMSG	EQ	0A7		:LEAVE DEFERED ECHO MESSAGE
ETMMSG	EQ	0A8		:ENTER TRANSPARENCY MODE
LTMMSG	EQ	0A9		:LEAVE TRANSPARENCY MODE
GBMSG	EQ	0AA		:GREEN BALL
RBMSG	EQ	0AB		:RED BALL
YBMSG	EQ	0AC		:YELLOW BALL
OBMSG	EQ	0AD		:ORANGE BALL
BRKMSG	EQ	0AE		:BREAK DETECTED
HNGMSG	EQ	0AF		:HANG UP
QTPMSG	EQ	0B0		:QUERY TERMINAL PARAMETER
STPMSG	EQ	0B1		:SET TERMINAL PARAMETER
PNDMSG	EQ	0B2		:PSEUDO NEEDLE
NLOGCH	EQ	0B3		:NORMAL LOGON CHAR
NLOGST	EQ	0B4		:NORMAL LOGON STATUS
LOGFAL	EQ	0B5		:LOGON FAILURE
LOGOK	EQ	0B6		:SUCCESSFUL LOGON
ADACTG	EQ	0B7		:ADDENDUM TO ACCOUNTING
SHGMSG	EQ	0B8		:SUPER-HANG UP
SETLIM	EQ	0B9		:SET XMIT LIMIT
BRKEND	EQ	0BA		:BREAK END
ZAPACK	EQ	0BB		:ZAPPER ACKNOWLEGEMENT
EAODM	EQ	0BC		:ENTER ALTERNATE OUTPUT DEVICE MODE
LAODM	EQ	0BD		:LEAVE ALTERNATE OUTPUT DEVICE MODE
ZAPREA	EQ	0BE		:ZAP WITH REASON
SIIX	EQ	0BF		:START IIX
TIIX	EQ	0C0		:TERMINATE IIX
MAXTYP	EQ	0C0		:MAXIMUM TYPE DEFINED

:
:	HANDLES INPUT MESSAGES FROM ISIS INPUT RING
:
INPUT	ST	R0,RETPTR	:SAVE RETURN ADDRESS
INPUT1	JAL	R4,LOOK		:IS THERE ANYTHING TO DO?
	J	RET		:NO... RETURN ALLL DONE FOR NOW
	JN	INPUT2		:TEST IF PORT 0.. SKIP IF NOT
:
:	CHECK PORT ZERO MESSAGES
:
	JAL	R4,GETCH	:GET MSG TYPE BYTE
	LR	R2,R0		:TEST MSG TYPE
	JEFS	SPEC2		:SKIP IF MSG 0
	TBT	R2,SPECL	:TEST IF VALID MESSAGE TYPE
	JEFS	SPEC1		:SKIP IF OK
	JAL	R10,CRASH	:OTHERWISE CRASH
	BC	0,0,4*R2,CRIPOM

SPECL	BC	1D,0A9,0FF	:INVALID PORT 0 MSG TYPES

SPEC1	LA	R5,ACTIV0	:SET UP CALLING ADDRESS
	JAL	R4,ACTIV	:ACTIVATE USER PORT 0 MSG ROUTINE
SPEC2	JAL	R4,ELIR		:END LOGICAL INPUT RECORD
	J	INPUT1		:AND GO BACK FOR MORE....
:
:	NOT A PORT ZERO MESSAGE
:
:	R1=PORT#	R2=MSG TYPE
:
INPUT2	JAL	R4,GETCH	:GET MSG TYPE
	TBT	R0,DATAM	:TEST IF DATA MESSAGE
	JE	INPUT3		:SKIP IF NOT
:
	TBT	RPORT,DEM	:TEST IF PORT IS IN DEFERED ECHO MODE
	JE	INDATA		:SKIP IF NOT
	TBT	RPORT,PECHO	:SHOULD DEM BE HONORED?
	JE	INDATA		:SKIP IF NOT
	LR	R2,R0		:COPY MSG LENGTH
	LR	R5,R0		:COPY IT AGAIN
	ST	R14,REGSAV	:SAVE INPUT RING POINTER REGISTER
:
ECHO1	JAL	R4,GETCH	:GET A CHARACTER
	STB	R0,ECHOBF,R5	:PUT IT INTO ECHO BUFFER
	SIS	R5,1		:DECREMENT COUNTER
	JGBS	ECHO1		:GO BACK IF MORE CHARS IN RECORD
	LR	R5,R2		:COPY CHAR COUNT
	LHI	R0,3,R2		:CALCULATE MSG LENGTH
	JAL	R4,SLOR		:START LOGICAL OUTPUT RECORD
ECHO2	LB	R0,ECHOBF,R5	:GET A CHARACTER FROM ECHO BUFFER
	JAL	R4,PUTCH	:PUT IT INTO OUTPUT RING
	SIS	R5,1		:DECREMENT COUNTER
	JGBS	ECHO2		:REPEAT IF MORE
	JAL	R4,ELOR		:ALL DONE.. END LOGICAL RECORD
:
:	NOTE THAT BACKPRESSURE AND TRANSMIT LIMIT ARE NOT CHECKED
:	IN SERVICING THE DEFERED ECHO.
:
	L	R14,REGSAV	:RESTORE INPUT RING POINTER

:
INDATA	LHL	RDCB,PORTAB,RPORT,RPORT	:GET DCB POINTER
	JEFS	INDCR		:CRASH IF NO DCB
	LHL	R4,DCBLKS+ACTIVD,RDCB,	:GET DATA ACTIVATION ROUTINE FOR PORT
	JNFS	INDAT1		:TEST IF THERE IS A ROUTINE
INDCR	JAL	R10,CRASH	:CRASH IF NO ROUTINE
	BC	0,0,4*RDCB,CRNAR
:
  IF	AUTOBP
:
:	CHECK IF INPUT PORT SHOULD BE BACKPRESSURED
:
INDAT1	STH	RPORT,SPORT	:PRESERVE R1
	STH	RDCB,SDCB	:PRESERVE RDCB
	LA	R5,SEG|A.CODE|,R4	:SET UP ACTIVATION ADDRESS
	JAL	R4,ACTIV	:ACTIVATE
	JAL	R4,ELIR		:END THE INPUT RECORD
	LHL	RDCB,SDCB	:RESTORE DCB POINTER
	LH	R0,DCBLKS+DCBICC,RDCB,	:GET INPUT CHAR COUNT
	SHI	R0,MAXCHAR	:TEST IF TOO MANY CHARACTERS
	JL	INPUT1		:NO... GO BACK FOR MORE 
	LHL	RPORT,SPORT	:RESTORE PORT NUMBER
	LIS	R0,3		:GENERATE BACKPRESSURE MESSAGE
	LHI	R2,NOSMSG	:
	JAL	R4,SLOR		:START THE RECORD
	JAL	R4,ELOR		:END IT
	RBT	RPORT,FRISIS	:SET BP INDICATOR FOR PORT
	J	INPUT1		:AND GO BACK FOR MORE
  ELSE
:
INDAT1	LA	R5,SEG|A.CODE|,R4	:SET UP ACTIVATION ADDRESS
	JAL	R4,ACTIV	:ACTIVATE
	JAL	R4,ELIR		:END THE INPUT RECORD
	J	INPUT1		:AND GO BACK FOR MORE
  EI

	SEG	A.DATA
ECHOBF	BS	FIRST	:ECHO BUFFER

	SEG	A.CODE

:
:	PROCESS CONTROL MESSAGES
:
INPUT3	LR	R3,R0		:COPY MSG TYPE
	JN	INCNTL		:NOT A NEEDLE....SKIP
	SBT	RPORT,ACP		:TEST AND SET ACTIVE PORT BIT
	JEFS	NEEDLE		:SKIP IF PORT WAS NOT ACTIVE
	JAL	R10,CRASH	:OTHERWISE CRASH
	BC	0,0,4*RPORT,CRINVN
:
:	PROCESS NEEDLES
:
NEEDLE	LHI	R0,FIRST-1	:SET UP TRANSMIT LIMIT
	STB	R0,XLIMIT,RPORT	:STORE IT
	SBT	RPORT,TOISIS	:CLEAR BACKPRESSURE
	SBT	RPORT,FRISIS	:
 IF	OUTPROC
	RBT	RPORT,OUTDAT	:CLEAR OUTPUT DATA WAITING
 EI
  IF PTIMEO
	RBT	RPORT,PTIME	:CLEAR PORT TIMEOUT
  EI
	JAL	R4,GETCH	:SKIP LENGTH
	JAL	R4,GETW		:GET INVOICE NUMBER
	LR	R6,R0		:COPY IT
	JAL	R4,GETH		:GET DESTINATION HOST
	LR	R7,R0		:COPY IT
	JAL	R4,GETH		:GET SOURCE NODE
	LR	R8,R0		:COPY IT
	JAL	R4,GETH		:GET SOURCE HOST
	LR	R9,R0		:COPY IT
	JAL	R4,GETH		:GET SOURCE PORT
	LR	R10,R0		:COPY IT
	JAL	R4,GETW		:FUTURE EXPANSION
	JAL	R4,GETH		:GET DIALECT CODE
	LR	R11,R0		:COPY IT
	JAL	R4,GETCH	:GET TID
	LR	R13,R0		:COPY IT
:
  IF	ECHO
:		SOURCE NODE SHOULD ECHO
	THI	R13,1F		:CHECK IF TERMINAL
	JE	NEED2		:SKIP... NOT A TERM
	ST	R14,REGSAV	:SAVE INPUT RING POINTER
	THI	R13,20		:CHECK IF HALF DUPLEX
	JNFS	NEED1		:SKIP IF HDX.. DON'T SET DEM
	SBT	RPORT,DEM	:SET DEM
NEED1	LIS	R0,5		:SEND SET TERM PARM MSG
	LHI	R2,STPMSG	:
	JAL	R4,SLOR		:START THE OUTPUT RECORD
	LIS	R0,0
	JAL	R4,PUTCH	:
	LIS	R0,1		:SET ECHO ON
	JAL	R4,PUTCH	:
	JAL	R4,ELOR		:
	L	R14,REGSAV	:RESTORE INPUT RING POINTER
  EI
:
NEED2	JAL	R4,GETCH	:GET USERNAME LENGTH
	LR	R2,R0		:COPY USERNAME LENGTH
	LA	R5,ACTIVN	:SET UP NEEDLE ACTIVATION ROUTINE ADDR
	JAL	R4,ACTIV	:ACTIVATE IT
	JAL	R4,ELIR		:END THE INPUT RECORD
	J	INPUT1		:AND GO BACK FOR MORE

:
:
:	PROCESS NON-NEEDLE CONTROL MESSAGES FOR PORTS
:
INCNTL	SHI	R3,FIRST		:SUBTRACT TO GET RELATIVE MSG NUMBER
	SLLS	R3,1			:FORM HALFWORD INDEX
	LHL	RDCB,PORTAB,RPORT,RPORT	:GET DCB POINTER
	JE	INCN1			:CRASH IF NO DCB
	LHL	R4,DCBLKS+ACTIVC,RDCB,	:GET TABLE POINTER
	JEFS	INCN1			:SKIP IF NO TABLE ADDRESS
	LHL	R4,SEG|A.CODE|,R4,R3	:GET ROUTINE ADDRESS
	JEFS	INCN1			:SKIP IF NO ROUTINE ADDRESS
	LA	R5,SEG|A.CODE|,R4	:SET UP ACTIVATION ADDRESS
	JAL	R4,ACTIV		:ACTIVATE
	JAL	R4,ELIR			:END THE LOGICAL RECORD
	J	INPUT1			:AND GO BACK FOR MORE
:
INCN1	JAL	R10,CRASH		:CRASH IF NO ROUTINE
	BC	0,0,4*RDCB,CRNAR

:	INITIALIZATION FOR THIS PACKAGE
:
IZFRNT	ST	R0,RETPTR	:SAVE RETURN ADDRESS
	LHI	RPORT,NPORT-1	:SET UP LOOP
IZIN1	RBT	RPORT,ACP	:SET PORT NOT ACTIVE
	SBT	RPORT,TOISIS	:SET BACKPRESSURE OFF
	SBT	RPORT,FRISIS	:
 IF	OUTPROC
	RBT	RPORT,OUTDAT	:RESET OUTPUT DATA WAITING
 EI
	RBT	RPORT,DEM	:NOT DEFERED ECHO MODE
	SIS	RPORT,1		:DECREMENT LOOP COUNTER
	JGEBS	IZIN1		:REPEAT IF MORE
:
  IF	AUTOBP			:AUTOMATIC BACKPRESSURE RELEASE CODE
	L	R7,FASTC,,	:GET CURRENT TIME
	LA	R0,RELBP	:PUT RELBP ON TIMEOUT LIST
	LHI	R1,RATE/2,R7	:SET HALF SECOND TIMEOUT
	JAL	R5,TOPUT	:
  EI
:
  IF	PTIMEO			:PORT TIMEOUT CODE
	L	R7,FASTC,,	:GET CURRENT TIME
	LA	R0,ONESEC	:PUT ONESEC ON TIMEOUT LIST
	LHI	R1,RATE,R7	:SET ONE SECOND TIMEOUT
	JAL	R5,TOPUT	:
  EI
	JFS	RET		:RETURN
:
:	GENERAL RETURN ROUTINE
RET	L	R0,RETPTR	:GET RETURN ADDRESS
	JR	R0		:AND RETURN
:
:	ACTIVATION ROUTINE
:
ACTIV	ST	R4,RETRN	:SAVE RETURN ADDRESS
  IF	PTIMEO
:		PORT TIMEOUT CODE
	STH	RPORT,SPORT	:PRESERVE PORT NUMBER
	JALR	R5,R5		:ACTIVATE
	J	ACTIV2		:NORMAL RETURN DON'T MODIFY TIMEOUT
	LHL	RPORT,SPORT	:RESTORE PORT NUMBER
	LR	R0,R0		:TEST RETURN PARAMETER
	JGFS	ACTIV1		:NONZERO... SKIP
	RBT	RPORT,PTIME	:TURN OFF PORT TIMEOUT INDICATOR
	JFS	ACTIV2		:
ACTIV1	SBT	RPORT,PTIME	:SET PORT TIMEOUT INDICATOR ON
	A	R0,SLOWC,,	:ADD TIMEOUT TO SLOW CLOCK
	SLHLS	RPORT,2		:MAKE WORD INDEX POINTER
	ST	R0,ATIME,RPORT	:STORE ACTIVATION TIME
  ELSE
	JALR	R5,R5		:ACTIVATE
  EI
ACTIV2	L	R4,RETRN	:RESTORE RETURN ADDRESS
	JR	R4		:AND RETURN
:
  IF	AUTOBP
:
:		CODE TO PERIODICALLY CHECK IF BACKPRESSURE CAN
:		BE RELEASED ON ANY PORTS
RELBP	AHI	R1,RATE/2		:
	JAL	R5,TOPUT	:PUT BACK ON TIMEOUT LIST FOR ONE SECOND
:
:	CHECK ALL PORTS FOR THOSE WITH BACKPRESSURE APPLIED
:
	LHI	R5,(NGRP-1)*2	:
	LHI	R6,(NGRP-1)*10	:SET UP POINTERS
RBP1	LCS	R7,1		:
	XH	R7,FRISIS,R5	:CHECK IF BACKPRESSURE APPLIED
	NH	R7,ACP,R5	:AND PORT ACTIVE
RBP2	LR	R1,R7		:TEST
	JNFS	RBP3		:SKIP.. SOMETHING TO DO
	SIS	R5,2		:DECREMENT POINTERS
	SHI	R6,10		:
	JGEBS	RBP1		:CHECK NEXT RING GROUP
	J	TORET		:OTHERWISE RETURN
:
RBP3	JAL	R3,BIDH		:DETERMINE WHICH PORT ON GROUP NEEDS SERVICE
	XH	R7,HMASK,R2,R2	:MARK PORT AS SERVICED
	AR	R2,R6		:FORM PORT NUMBER
	LR	RPORT,R2		:COPY IT
	SLHLS	R2,2		:FORM BUFFER NUMBER
	LHL	RDCB,PORTAB,RPORT,RPORT	:GET DCB POINTER FROM PORT TABLE
	LH	R0,DCBLKS+DCBICC,RDCB,	:GET INPUT CHAR COUNT
	SHI	R0,MAXCHAR	:TEST IF LESS THAN MAXCHAR
	JG	RBP2		:NOT EMPTY ENOUGH YET
	SBT	RPORT,FRISIS	:RELEASE BACKPRESSURE
	LIS	R0,3		:FORM 3 BYTE MESSAGE
	LHI	R2,SNDMSG	:GET MESSAGE
	JAL	R4,SLOR		:START LOGICAL OUTPUT RECORD
	JAL	R4,ELOR		:END IT
	J	RBP2		:AND CONTINUE
  EI
  IF	PTIMEO
:
:		CODE TO CHECK PERIODICALLY FOR PORT TIMEOUTS
:
ONESEC	AHI	R1,RATE		:SET UP TO RUN AGAIN IN ONE SECOND
	JAL	R5,TOPUT	:
	LHI	R15,(NGRP*2)-2	:SEARCH BY GROUPS
OS1	LH	R14,ACP,R15	:GET ACTIVE PORT INDICATORS
	NH	R14,PTIME,R15	:AND IN PORTS ON TIMEOUT
	JNFS	OS3		:JUMP IF ANY TO CHECK
OS2	SIS	R15,2		:DECREMENT GROUP INDEX
	JGEBS	OS1		:REPEAT IF MORE
	J	TORET		:OTHERWISE EXIT
:
OS3	LR	R1,R14		:COPY MASK OF PORTS TO PROCESS
	JEBS	OS2		:NONE... GO ON TO NEXT GROUP
	JAL	R3,BIDH		:FIND FIRST
	XH	R14,HMASK,R2,R2	:SET IT EXAMINED
	LR	R1,R15		:COPY GROUP INDEX
	SLHLS	R1,3		:MAKE GROUP INDEX INTO PORT OFFSET
	AR	RPORT,R2	:MAKE PORT NUMBER
	LR	R2,RPORT	:COPY PORT NUMBER
	SLHLS	R2,2		:MAKE INTO FULLWORD INDEX
	L	R0,ATIME,R2	:GET ACTIVATION TIME
	S	R0,SLOWC,,	:SUBTRACT CURRENT TIME
	JG	OS3		:NOT READY.. IGNORE FOR NOW
	LHL	RDCB,PORTAB,RPORT,RPORT	:GET DCB POINTER
	JNFS	OS4		:SKIP IF GOT A DCB
OSCR	JAL	R10,CRASH	:CRASH
	BC	0,0,4*RDCB,CRNAR	:NO ACTIVATION ROUTINE
:
OS4	LHL	R4,DCBLKS+ACTIVT,RDCB,	:GET ACTIVATION ROUTINE
	JEBS	OSCR		:CRASH IF NO ROUTINE
	LA	R5,SEG|A.CODE|,R4	:SET UP ACTIVATION ADDRESS
	STM	R14,TSAVE	:PRESERVE WORK REGISTERS
	JAL	R4,ACTIV	:ACTIVATE
	LM	R14,TSAVE	:RESTORE WORK REGISTERS
	J	OS3		:GO BACK FOR MORE
:
:	SET AND CLEAR TIMEOUT ROUTINES
:		LINK ON R4
:		EXPECT R1 = PORT NUMBER
:		       R0 = TIMEOUT INTERVAL IN SECONDS (SETTO)
:		SMASHES R0
:
	GL	SETTO,CLRTO
:
SETTO	SBT	RPORT,PTIME	:SET PORT TIMEOUT INDICATOR
	A	R0,SLOWC,,	:ADD TO CURRENT TIME
	SLHLS	RPORT,2		:MAKE INTO FULLWORD POINTER
	ST	R0,ATIME,RPORT	:STORE TIME
	SRHLS	RPORT,2		:MAKE BACK INTO PORT NUMBER
	JR	R4		:AND RETURN
:
CLRTO	RBT	RPORT,PTIME	:RESET PORT TIMEOUT INDICATIOR
	JR	R4		:AND RETURN
  EI
:

:	CONTROL MESSAGE ACTIVATION ROUTINES
:
:	TOSS A MESSAGE
TOSS	LB	R0,LENGTH,R2	:PICK UP MESSAGE LENGTH
	SIS	R0,1		:WE'VE ALREADY GOTTEN MESSAGE TYPE
	AR	R14,R0		:ADVANCE POINTER TO END OF MSG
	JR	R5		:RETURN
:
:	ZAPPER ACKNOWEDGEMENT
:
ZACK	EQ	.
:
:	DISCONNECT
ZAP	JAL	R4,EMPTYI	:EMPTY INPUT BUFFER
	JAL	R4,EMPTYO	:EMPTY OUTPUT BUFFER
	RBT	RPORT,ACP	:SET PORT NOT ACTIVE
	RBT	RPORT,DEM	:SET PORT NOT IN DEM
	JR	R5		:RETURN
:
:	APPLY BACKPRESSURE
NOSEND	RBT	RPORT,TOISIS	:TURN IT OFF FOR PORT
	JR	R5		:RETURN
:
:	RELEASE BACKPRESSURE
RESEND	SBT	RPORT,TOISIS	:TURN IT ON FOR PORT
	JR	R5		:RETURN
:
:	GOBBLER
GOBBLE	JAL	R4,EMPTYI	:EMPTY INPUT BUFFER
	SBT	RPORT,FRISIS	:RELEASE BACKPRESSURE
	JR	R5		:AND RETURN
:
:	FLUSH BACKWARD
FLBACK	JAL	R4,EMPTYO	:EMPTY OUTPUT BUFFER
	LIS	R0,3		:SEND GOBBLER IN OTHER DIRECTION
	LHI	R2,GOBMSG	:CREATE MESSAGE
	JAL	R4,SLOR		:START LOGICAL OUTPUT RECORD
	JAL	R4,ELOR		:END IT
	JR	R5		:AND RETURN
:
:	ENTER DEM
EDEM	SBT	RPORT,DEM	:SET INDICATOR
	JR	R5		:RETURN

:
:	LEAVE DEM
LDEM	RBT	RPORT,DEM	:CLEAR INDICATOR
	JR	R5		:RETURN
:

:	GREEN BALL
GB	LIS	R0,3		: RETURN GREEN BALL
	LHI	R2,GBMSG	:CREATE MESSAGE
	JAL	R4,SLOR		:START LOGICAL OUTPUT RECORD
	JAL	R4,ELOR		:END IT
	JR	R5		:AND RETURN
:
:	RED BALL
RB	LIS	R0,3		:RETURN THE RED BALL
	JAL	R4,SLOR		:START LOGICAL OUTPUT RECORD
	JAL	R4,ELOR		:END IT
	JR	R5		:AND RETURN
:
:	ORANGE (OR BLACK) BALL
OB	LIS	R0,3		:CREATE MESSAGE
	LHI	R2,1,R2		:CREATE OTHER BALL OF PAIR
	JAL	R4,SLOR		:START LOGICAL OUTPUT RECORD
	JAL	R4,ELOR		:END IT
	JR	R5		:AND RETURN
:
:	PSUEDO-NEEDLE
PNEED	LB	R0,LENGTH,R2	:JUST TOSS IT
	SIS	R0,1		:WE ALREADY GOT MSG TYPE
	AR	R14,R0		:ADVANCE POINTER TO END OF MSG
	LHI	R0,FIRST-1	:SET UP DEFAULT TRANSMIT LIMIT
	STB	R0,XLIMIT,RPORT	:
	SBT	RPORT,ACP	:SET PORT ACTIVE
	SBT	RPORT,TOISIS	:CLEAR BACKPRESSURE
	SBT	RPORT,FRISIS	:
	JR	R5		:AND RETURN
:
:	TRANSMIT LIMIT
XLIM	JAL	R4,GETCH	:GET RESTRICTION
	CLHI	R0,FIRST-1	:RANGE CHECK
	JLFS	XLIM1		:OK...SKIP
	LHI	R0,FIRST-1	:OTHERWISE SET LIMIT
XLIM1	STB	R0,XLIMIT,RPORT	:SET UP RESTRICTION
	JR	R5		:AND RETURN
:
:	INVALID MESSAGE
INVAL	JAL	R10,CRASH
	BC	0,0,4*R5,CRINVM
 IF	OUTPROC

:	OUTPUT PROCESS ROUTINE
:
OUTPUT	ST	R0,RETPTR	:SAVE RETURN ADDRESS
	LHI	R11,(NGRP-1)*2	:LOOP COUNTER
OUTP1	LCS	R1,1		:SET UP MASK
	STH	R1,PRTSVC	:SAVE PORT SERVICED MASK
OUTP2	LHL	R1,ACP,R11	:GET ACTIVE PORTS INDICATOR
	NH	R1,OUTDAT,R11	:AND WITH DATA WAITING INDICATOR
	NH	R1,TOISIS,R11	:AND NOT BACKPRESSURED
	NH	R1,PRTSVC	:AND NOT ALREADY SERVICED
	JNFS	OUTP3		:SKIP IF ANYTHING TO DO
	SIS	R11,2		:DECREMENT LOOP COUNTER
	JGEBS	OUTP1		:LOOP
	J	RET		:DONE... RETURN
:
OUTP3	JAL	R3,BIDH		:FIND PORT TO SERVICE
	LR	R1,R11		:COPY PORT OFFSET
	SLHLS	R1,3		:TIMES EIGHT
	AR	RPORT,R2	:PORT NUMBER!
	RBT	R2,PRTSVC	:CLEAR PORT TO BE SERVICED BIT
	LHL	RDCB,PORTAB,RPORT,RPORT	:GET DCB POINTER FOR PORT
	JEFS	OUTCR			:CRASH NO DCB POINTER
	LHL	R4,DCBLKS+ACTIVO,RDCB,	:GET OUTPUT ACTIVATION ROUTINE
	JNFS	OUTP4			:GOT A ROUTINE...SKIP
:
OUTCR	JAL	R10,CRASH
	BC	0,0,4*RDCB,CRNAR	:NO ACTIVATION ROUTINE
:
OUTP4	STH	R11,SLOOP	:SAVE LOOP COUNTER
	LA	R5,SEG|A.CODE|,R4	:SET UP ACTIVATION ADDRESS
	JAL	R4,ACTIV	:ACTIVATE
	LHL	R11,SLOOP	:RESTORE LOOP POINTER
	J	OUTP2		:LOOP
:
 EI
:	DEFAULT CONTROL MESSAGE ACTIVATION TABLES
:
:	CALCULATE ROUTINE OFFSETS
:
XTOSS	EQ	TOSS-SEG|A.CODE|
XZAP	EQ	ZAP-SEG|A.CODE|
XZACK	EQ	ZACK-SEG|A.CODE|
XNOSEND	EQ	NOSEND-SEG|A.CODE|
XRESEND	EQ	RESEND-SEG|A.CODE|
XGOBBLE	EQ	GOBBLE-SEG|A.CODE|
XFLBACK	EQ	FLBACK-SEG|A.CODE|
XEDEM	EQ	EDEM-SEG|A.CODE|
XLDEM	EQ	LDEM-SEG|A.CODE|
XGB	EQ	GB-SEG|A.CODE|
XRB	EQ	RB-SEG|A.CODE|
XOB	EQ	OB-SEG|A.CODE|
XPNEED	EQ	PNEED-SEG|A.CODE|
XXLIM	EQ	XLIM-SEG|A.CODE|
XINVAL	EQ	INVAL-SEG|A.CODE|
:
:	TABLE CREATION MACROS
:
HTABVT	MACRO(TABNAM)
[	SEG	A.CODE
	GL	TABNAM
TABNAM	HC	XZAP,XZAP,XNOSEND,XRESEND,XGOBBLE,XFLBACK	:9E - A3
	HC	XOB,XTOSS,XEDEM,XLDEM,XTOSS,XTOSS		:A4 - A9
	HC	XGB,XRB,XOB,XTOSS,XTOSS,XTOSS			:AA - AF
	HC	XTOSS,XTOSS,XINVAL,XINVAL,XTOSS,XTOSS		:B0 - B5
	HC	XTOSS,XINVAL,XTOSS,XXLIM,XTOSS,XZACK		:B6 - BB 
	HC	XTOSS,XTOSS,XINVAL,XTOSS,XTOSS			:BC - C0
]
:
HTABIA	MACRO(TABNAM)
[	SEG	A.CODE
	GL	TABNAM
TABNAM	HC	XZAP,XZAP	:9E - 9F
	RE	0B1-9F
	HC	XTOSS
	NOLIST
	ER
	LIST
	HC	XPNEED,XINVAL	:B2 - B3
	HC	XTOSS,XTOSS,XTOSS,XINVAL,XTOSS,XTOSS		:B4 - B9
	HC	XTOSS,XZACK,XTOSS,XTOSS,XINVAL,XTOSS,XTOSS	:BA - C0
]
:
CHGTAB	MACRO(TABNAM,MSGNUM,ROUTIN)
[
OLDORG	EQ	.
	ORG	TABNAM+(MSGNUM-FIRST)*2
	HC	ROUTIN-SEG|A.CODE|
	ORG	OLDORG
]
	EM
:
	SUBTTL	STOR - 3270 Configuration Tables
:
	RA	0	:RADIX IS HEX
:
	GL	NDEV,FCU,FDEVL,FDEV,CUADR,DEVADR,DTYPE,DEVCU,DEVLN
	GL	DEVPVC,DEVCOL,SS0SS1
        GL      DEVLA,PFNET,DEVBUS
:
        SEG     0
:
RDNSR2	HS	1		:FOR R2 STORAGE
RDNSR3	HS	1		:FOR R3 STORAGE
SAVHED	HS	1		:SAVE HEAD OF SAVE FOR PBBC
SAVBUF	HS	1		:FOR SAVEQ BUFFER POINTER STORED
CUSRST	HS	1		:LOCATION TO STORE ORIGNAL CURSOR POSITION
	BC	SBA.,0,0,IC.
:
NDEV	HC	NDEVM-1		:NUMBER OF DEVICES LESS ONE

FCU	BS	NBILM		:FIRST CONTROL UNIT FOR EACH LINE
	BC	NCUM		:

FDEVL	HS	NBILM		:FIRST DEVICE FOR EACH LINE
	HC	NDEVM		:


PFNET   BS      NBILM           : PF KEY FOR NET SERVICES SCREEN
 
FDEV	BS	NCUM		:FIRST DEVICE FOR EACH CONTROL UNIT
	BC	NDEVM		:
CUADR	BS	NCUM		:NUMERIC POLLING ADDRESS FOR EACH CONTROL UNIT

DEVADR	BS	NDEVM		:NUMERIC POLLING ADDRESS FOR EACH DEVICE
DTYPE	BS	NDEVM		:DEVICE TYPES
DEVCU	BS	NDEVM		:CONTROL UNIT NUMBER FOR EACH DEVICE
DEVLN	BS	NDEVM		:LINE NUMBER FOR EACH DEVICE
DEVLA	WS	NDEVM		:LOGICAL ADDRESS FOR DEVICE


XPRDAT  HS      NDEVB           :BIT ARRAY...1=TRANSPARENCY IN F.G.

DEVCOL  HS      0               :BIT ARRAY...1=DEVICE CAN HANDLE COLOR
Q       EQ      0
        RE      NDEVB
        HC      0
COLQ|Q| EQ      0
Q       EQ      Q+1
        ER

DEVXPR  HS      0               :BIT ARRAY...1=DEVICE CAN HANDLE TRANSPARENCY
Q       EQ      0
        RE      NDEVB
        HC      0
XPRQ|Q| EQ      0
Q       EQ      Q+1
        ER

:
: PARAMETERS FOR HOST INTERFACE ONLY
:
        IF HSTSWT
HSBIT   HC      0               :BITS TO DEFINE HOSTS (MAX OF 16)
PLOCK   HS      (NPORT+1)/10+1  :PORT LOCK
DEVCHR  BC      0       :DEVICE IDENTIFIER FOR NATIVE MODE
        BC      0F1     :1250
        BC      0F2     :470
        BC      0F3     :IBM 3101
HDEV    HS      0               :1=DEVICE BELONGS TO THIS HOST
        RE      MAXHST
        HS      NDEVB
        ER
        GL      RLA,RDA,RPA
RLA	WS	NDEVM		:REMOTE LOGICAL ADDRESS FOR DEVICE
RDA	BS	NDEVM		:REMOTE DEVICE ADDRESS FOR DEVICE
RPA     BS      NDEVM           : RELATED PRINTER ADDRESS
ACT     HS      NDEVB           :BIT ARRAY...1=DEVICE TO BE CHECKED FOR INACTIVITY
ACT1    HS      NDEVB           :BIT ARRAY...1=DEVICE IS INACTIVE
ACT2    HS      NDEVB           :BIT ARRAY...1=DEVICE HAS INACTIVITY TIMER COUNTING
        IF      DMSSWT
DCSBIT  HS      NDEVB           :BIT ARRAY...1=DSC MSG WAS SENT FROM H.I. AND
                                :A DSC MSG SENT FROM HOST IS EXPECTED.
DMSADR  WS      NDCMSG          :TABLE OF DSC MSG SEQUENCE ADDRESS
        
DMSBIT  HS      0               :BIT ARRAY, 1=DEVICE CAN HANDLE DSC MSG SEQUENCE
Q       EQ      0
        RE      NDEVB
        HC      0
DMGQ|Q| EQ      0
Q       EQ      Q+1
        ER
        EI
:
: PARAMETERS FOR TERMINAL INTERFACE ONLY
:
        ELSE
ELEADR  WS      ELENUM          :TABLE OF ELEMENT ADDRESSES
STRLST  HS      NSLST           :TABLE OF ORDERED ELEMENTS IN LOGON STRINGS
LSTRS   HS      NLSTR*3         :TABLE OF LOGON STRINGS
MSTRS   HS      NMSTR           :TABLE OF ORDERED LOGON STRINGS IN MENUS
MENUS   WS      NMENU           :TABLE OF MENUS
DEVMAP  HS      NDEVM           :TABLE OF DEVICE TO MENU MAPPINGS
DATTR   BS      NDEVM           :STORAGE OF OTHER DEVICE ATTRIBUTES
PTRMAP  HS      0               :TABLE OF PRINTER DEVICE LABEL MAPPINGS
        RE      NDEVM
        HC      -1              :INDICATES DEVICE WITH NO PRINTER LABEL
        ER
DEVBUSY HS      NDEVB           :BIT ARRAY...1=DEVICE IS BUSY (DPORT DEFINED)
CUPOLL  HS      NCUB            :BIT ARRAY...1=CU ANSWERED POLLS
CUPTR   HS      NCUM            :TABLE OF PRINTERS FOR THE CONTROL UNITS
PTRDEV  BS      NPRTR           :TABLE OF PRINTER DEVICE #'S FOR CU'S
:
        IF      \PVCOP|PVCOPT|
PVCOP|PVCOPT|  EQ  1
        ELSE
        REMARK  %PVCOPT IS OUT OF RANGE%
        EI

DEVPVC  HS      0               :BIT ARRAY...1=PERMANENT VIRTUAL CIRCUIT DEVICE
Q       EQ      0
        RE      NDEVB
        HC      0
PVCQ|Q| EQ      0
Q       EQ      Q+1
        ER
        EI
LOGPVC  HS      NDEVB           :BIT ARRAY...1=OK TO LOGIN A PVC DEVICE NOW
                                :               ATTEMPTED RECENTLY
:
NPVCL   HS      1               :# OF PVC LOGONS THAT CAN BE DONE NOW
NPVCD   HS      1               :# OF PVC DEVICES
:
        IF      PVCOP3          :OPTION 3...INSURE PVCTIM ELAPSED BEFORE RETRY
L1PVC   HS      NDEVB           :BIT ARRAY...1=ELAPSED TIME PASSED , OK TO LOGON
L2PVC   HS      NDEVB           :BIT ARRAY...1=LOGON PVC DEVICE AFTER PVCTIM
        EI      :PVCOP3

        IF      \SID            :SLOT ID
        ELSE
SID     EQ      ORGHST&0FF
:        REMARK  %WARNING...SID NOT DEFINED, USING ORGHST AS SID%
        EI
        IF      SID-0FF
        REMARK  %ERROR...SID IS LARGER THAN 1 BYTE%
        EI

SS0SS1	HS	NDEVM		:ARRAY TO SAVE LAST DEVICE STATUS HALFWORD


:	CONFIGURATION MACROS
:
MARK	MACRO(lm,rx,mx,P0,P1,P2,P3,P4,P5,P6,P7,P8,P9)[
Q0	EQ	$`RX -(0/P0+0)	:FOR Pi = n-m, Qi = -(0/n-m) = m
QQ0	EQ	$`RX Q0+(P0+0)	:FOR Pi = n-m, Qi=m, QQi = m+(n-m) = n
QQQ0	EQ	$`RX P0 $0100000000	:FOR Pi = null, QQQi = $0100000000
Q1	EQ	$`RX -(0/P1+0)
QQ1	EQ	$`RX Q1+(P1+0)
QQQ1	EQ	$`RX P1 $0100000000
Q2	EQ	$`RX -(0/P2+0)
QQ2	EQ	$`RX Q2+(P2+0)
QQQ2	EQ	$`RX P2 $0100000000
Q3	EQ	$`RX -(0/P3+0)
QQ3	EQ	$`RX Q3+(P3+0)
QQQ3	EQ	$`RX P3 $0100000000
Q4	EQ	$`RX -(0/P4+0)
QQ4	EQ	$`RX Q4+(P4+0)
QQQ4	EQ	$`RX P4 $0100000000
Q5	EQ	$`RX -(0/P5+0)
QQ5	EQ	$`RX Q5+(P5+0)
QQQ5	EQ	$`RX P5 $0100000000
Q6	EQ	$`RX -(0/P6+0)
QQ6	EQ	$`RX Q6+(P6+0)
QQQ6	EQ	$`RX P6 $0100000000
Q7	EQ	$`RX -(0/P7+0)
QQ7	EQ	$`RX Q7+(P7+0)
QQQ7	EQ	$`RX P7 $0100000000
Q8	EQ	$`RX -(0/P8+0)
QQ8	EQ	$`RX Q8+(P8+0)
QQQ8	EQ	$`RX P8 $0100000000
Q9	EQ	$`RX -(0/P9+0)
QQ9	EQ	$`RX Q9+(P9+0)
QQQ9	EQ	$`RX P9 $0100000000
Q	EQ	0
	RE	$0 0A
  IF	-QQ|Q|
	REMARK %>>>> ERROR **** PARAMETER ; NUMBER $`RX QQ|Q|
	REMARK  NOT POSITIVE ****%
  EI
  IF	$0 QQQ|Q|&1FFFFFFFF%100000000	:IF PI NOT NULL
	MRK(rx,mx)
QQ	EQ	QQ|Q|
	RE	QR
	lm
QQ	EQ	QQ+1
	ER
  EI
	KILL	Q|Q|,QQ|Q|,QQQ|Q|
Q	EQ	Q+1
	ER
	KILL	Q,QQ,QQQ,QR
]
:	INTERNAL MARK MACRO TO TEST FOR ERRORS AND RETURN QR= COUNT OF
:	NUMBERS IN RANGE.
MRK	MACRO(rx,mx)[
   IF	QQ|Q|-($`RX`MX)
	REMARK %>>>> ERROR **** PARAMETER ; NUMBER $`RX QQ|Q|
	REMARK  GREATER THAN ; NUMBER $`RX`MX; REMARK  ****%
   EI
   IF	Q|Q|	:IF M NOT NULL
    IF	Q|Q|-($`RX`MX)
	REMARK %>>>> ERROR **** PARAMETER ; NUMBER $`RX Q|Q|
	REMARK  GREATER THAN ; NUMBER $`RX`MX; REMARK  ****%
    EI
    IF	QQ|Q|-Q|Q|
	REMARK %>>>> ERROR **** RANGE ; NUMBER $`RX QQ|Q|
	REMARK -; NUMBER $`RX Q|Q|; REMARK  BACKWARD ****%
    EI
QR	EQ	Q|Q|-QQ|Q|+1
   ELSE
QR	EQ	1
   EI
]


:
:	SET ORIGIN MACRO : SETO
:		ARGUMENTS: BASE ADDRESS AND OFFSET
:
SETO	MACRO(BASE,OFFSET)
[
	ORG	BASE+OFFSET
]


:	START CONFIGURATION MACRO : SCONF
:		NO ARGUMENTS
SCONF	MACRO
[
LNO	EQ	-1
CUNO	EQ	-1
DEVNO	EQ	-1
SAVORG	EQ	.
]

:	END CONFIGURATION MACRO : ECONF
:		NO ARGUMENTS
:
ECONF	MACRO
[
LNO	EQ	LNO+1
CUNO	EQ	CUNO+1
DEVNO	EQ	DEVNO+1
        IF      1-HSTSWT
        IF      CUNO
        SETO(CUPTR,(CUNO-1)*2)
        BC      NCUPTR
        IF      NCUPTR-16
        REMARK  %WARNING...A CONTROL UNIT HAS MORE THAN 16 PRINTERS
        EI
        EI
        EI
	ORG	SAVORG
  IF	LNO-NBILM
	REMARK	%%TOO MANY LINES DEFINED%%
  ELSE
    IF	NBILM-LNO
	REMARK	%%NOT ENOUGH LINES DEFINED%%
    EI
  EI
  IF	CUNO-NCUM
	REMARK	%%TOO MANY CONTROL UNITS DEFINED%%
  ELSE
    IF	NCUM-CUNO
	REMARK	%%NOT ENOUGH CONTROL UNIT DEFINED%%
    EI
  EI
  IF	DEVNO-NDEVM
	REMARK	%%TOO MANY DEVICES DEFINED%%
  ELSE
    IF	NDEVM-DEVNO
	REMARK	%%NOT ENOUGH DEVICES DEFINED%%
    EI
  EI	]

:	DEFINE LINE MACRO : DEFLN
:		ARGUMENTS: CHARACTER ONE AND TWO OF THE LINE ADDRESS
:
:       DEFINE LINE MACRO - 
:       PARAMETERS - C1 = LOGICAL ADDRESS
:                    C2 = PF KEY FOR NET SCREEN
:                    C3 = CLEAR TO END/REQUEST TO SEND HANDSHAKE FLAG
:		     C4 = USER DEFINED LINE ID NUMBER
DEFLN	MACRO(C1,C2,C3,C4)
[
LNO	EQ	LNO+1
	SETO(FCU,LNO)
	BC	CUNO+1
	SETO(FDEVL,LNO*2)
	HC	DEVNO+1
        SETO(PFNET,LNO)
        IF      C2
        BC      C2
        ELSE
        BC      NETKEY
        EI

LC1	EQ	C1
CUX	EQ	0
]

:	DEFINE CONTROL UNIT MACRO : DEFCU
:		ARGUMENT 
:			C1 = CONTROL UNIT ADDRESS
:			C2 = USER DEFINED CU ID NUMBER
:
DEFCU	MACRO(C1,C2)
[

CUNO	EQ	CUNO+1
	SETO(FDEV,CUNO)
	BC	DEVNO+1
	SETO(CUADR,CUNO)
	BC	C1&ADRMSK

CUC	EQ	C1

CUX	EQ	CUX+1
        IF      1-HSTSWT
        IF      CUNO
        SETO(CUPTR,(CUNO-1)*2)
        BC      NCUPTR
        IF      NCUPTR-16
        REMARK  %WARNING...A CONTROL UNIT HAS MORE THAN 16 PRINTERS
        EI
        ELSE
        SEG     A.ELE
PTRLAB  EQ      .
        SEG     0
        EI
NCUPTR  EQ      0
        SETO(CUPTR,CUNO*2+1)
        BC      PTRNO
        EI
DUX	EQ	0
]

:	DEFINE DEVICE MACRO : DEFDEV
:
:       PARAMETERS - C = POLLING ADDRESS
:                    T = CRT/PRT, SCREEN SIZE
:                    RPTRA = RELATED PRINTER ADDRESS
:		     TNUM = 4 DIGIT USER DEFINED DEVICE ID
:
DEFDEV	MACRO(C,T,RPTRA,TNUM)
[
DEVNO	EQ	DEVNO+1
	SETO(DEVLN,DEVNO)
	BC	LNO
	SETO(DEVCU,DEVNO)
	BC	CUNO
	SETO(DTYPE,DEVNO)
	BC	T
	SETO(DEVLA,DEVNO*4)
	BC	LC1,CUC,C
	SETO(DEVADR,DEVNO)
	BC	C&ADRMSK

DUX	EQ	DUX+1

        IF      HSTSWT
        SETO(RPA,DEVNO)
        IF      RPTRA
        BC      RPTRA
        ELSE
        BC      0FF     :INDICATES NO ASSOCIATED DEVICE
        EI
Q       EQ      DEVNO^-4
QQ      EQ      DEVNO&0F
H|LH|D|Q| EQ    H|LH|D|Q|!(8000^-QQ)
        SETO(HDEV,LH*NDEVB*2+Q*2)
        HC      H|LH|D|Q|

        ELSE
        SETO(DEVMAP,DEVNO*2)
        HC      DFLMEN
        IF      T&PRTR
        SETO(PTRDEV,PTRNO)
        BC      DEVNO
NCUPTR  EQ      NCUPTR+1
PTRNO   EQ      PTRNO+1
        EI
        EI
]

:
: MACRO TO SET BITS IN BIT ARRAY DEVCOL IN ORDER TO INDICATE
:       WHICH DEVICE CAN HANDLE COLOR.
:
: PARAMETERS - DEVICES ABLE TO HANDLE COLOR
:
DEFCOL  MACRO(P0,P1,P2,P3,P4,P5,P6,P7,P8,P9) [
        MARK(COLU,A,NDEVM-1,P0,P1,P2,P3,P4,P5,P6,P7,P8,P9)
]

COLU    MACRO
[
QM      EQ      QQ/$A16
        SETO(DEVCOL,QM*2)
COLQ|QM|        EQ      COLQ|QM|!(8000^(QM*$A16-QQ))
        HC      COLQ|QM|
]

:
: MACRO TO SET BITS IN BIT ARRAY DEVXPR IN ORDER TO INDICATE
:       WHICH DEVICE CAN HANDLE TRANSPARENCY FOR EXTENDED ATTRIBUTES.
:
: PARAMETERS - DEVICES ABLE TO HANDLE TRANSPARENCY
:
DEFXPR  MACRO(P0,P1,P2,P3,P4,P5,P6,P7,P8,P9) [
        MARK(XPRU,A,NDEVM-1,P0,P1,P2,P3,P4,P5,P6,P7,P8,P9)
]

XPRU    MACRO
[
QM      EQ      QQ/$A16
        SETO(DEVXPR,QM*2)
XPRQ|QM|        EQ      XPRQ|QM|!(8000^(QM*$A16-QQ))
        HC      XPRQ|QM|
]

:
: MACROS OF HOST INTERFACE ONLY
:
        IF      HSTSWT
:
: CREATE BIT ARRAYS TO DETERMINE ASSOCIATIVITY OF DEVICES
: TO A RELATIVE HOST #
:
LH      EQ      0               :RELATIVE HOST NUMBER
        RE      MAXHST
Q       EQ      0
        RE      NDEVB
H|LH|D|Q| EQ    0
Q       EQ      Q+1
        ER
LH      EQ      LH+1
        ER
:
:       LUD AND LINE HOST NUMBER ASSIGNMENT
:
 
LINHST  HS      0
        RE      NBILM
        HC      HOST0
        ER
 
LNHOST  MACRO(IHOST)
        [
        SETO(LINHST,LNO*2)
        HC      HOST|IHOST|
LH      EQ      IHOST
        ]
 
 
:       LUD DEFINITIONS

        IF      \NLUD
        ELSE
NLUD    EQ      0
        EI

LUDNAM  HS      NLUD
LUDDEV  HS      NDEVB*(NLUD)    :SPACE FOR 1 BIT ARRAY FOR EACH ENTRY
        RE      NDEVB           :SPACE FOR NLUD=O CASE
        HC      0FFFF
        ER
LUDNO   EQ      -1
DEFLUD  MACRO(NAME)
[
LUDNO   EQ      LUDNO+1
        SETO(LUDNAM,LUDNO*2)
        HC      NAME
Q       EQ      0
        RE      NDEVB
QDEVB|Q| EQ     0
Q       EQ      Q+1
        ER
]

DEVOK   MACRO(P0,P1,P2,P3,P4,P5,P6,P7,P8,P9) [
        MARK(DEVO,A,NDEVM,P0,P1,P2,P3,P4,P5,P6,P7,P8,P9)
]
DEVO    MACRO
[
QM      EQ      QQ/$A16
        SETO(LUDDEV+NDEVB*LUDNO*2,QM*2)
QDEVB|QM| EQ    QDEVB|QM|!(8000^(QM*$A16-QQ))
        HC      QDEVB|QM|
]
:
:MACROS FOR MESSAGE TEXT DEFINITION
:
        IF      GRTSWT
GRTBIT  HS      0
Q       EQ      0
        RE      NDEVB
        HC      0
GRTQ|Q| EQ      0
Q       EQ      Q+1
        ER
GRTTBL  HS      NDEVM           :GREETING MESSAGE TABLE
        EI
:
: MACROS AND VARIABLES FOR DYNAMIC GREET MESSAGE
:
        IF      NDLSWT
: BUILD NEEDLE BIT ARRAY FOR DYNAMIC GREET MESSAGE
NDLBIT  HS      0
Q       EQ      0
        RE      NDEVB
        HC      0
NDLQ|Q| EQ      0
Q       EQ      Q+1
        ER
       
: MESSAGES AND STORAGE FOR DYNAMIC GREET MESSAGE
NDLHDR  HC      5               # OF BYTES IN NEEDLE MSG HEADER
        BS      2               CU,DEV ADR
        BC      AIDENT          AID "ENTER"
        BC      40,40           CURSOR ADR
NDLMSG  SC      /DEVICE ADDRESS DISALLOWED/
NDLDEC  BS      $A 10           # OF BYTES FOR CONVERING INTO DECIMAL
        EI
:
:DISCONNECT MESSAGES
:
        IF      DSCSWT
DSCBIT  HS      0
Q       EQ      0
        RE      NDEVB
        HC      0
DSCQ|Q| EQ      0
Q       EQ      Q+1
        ER
DSCTBL  HS      NDEVM           :DISCONNECT MESSAGE TABLE
        EI
:
:ZAP FROM HOST MESSAGES
:
        IF      ZAPSWT
ZAPBIT  HS      0
Q       EQ      0
        RE      NDEVB
        HC      0
ZAPQ|Q| EQ      0
Q       EQ      Q+1
        ER
ZAPTBL  HS      NDEVM
        EI
:
:NOW THE MACROS
:
STMSG   MACRO   [
        ORG     SAVORG
MTEXT   HS      1
        BS      2                       :TWO BYTES OF ADDRESS
]
MSGTEX  MACRO(C0,C1,C2,C3,C4,C5,C6,C7,C8,C9,C10,C11,C12,C13,C14,C15)
[
Q       EQ      C0 $0100000000
        IF      $A256-Q
        BC      Q
        EI
Q       EQ      C1 $0100000000
        IF      $A256-Q
        BC      Q
        EI
Q       EQ      C2 $0100000000
        IF      $A256-Q
        BC      Q
        EI
Q       EQ      C3 $0100000000
        IF      $A256-Q
        BC      Q
        EI
Q       EQ      C4 $0100000000
        IF      $A256-Q
        BC      Q
        EI
Q       EQ      C5 $0100000000
        IF      $A256-Q
        BC      Q
        EI
Q       EQ      C6 $0100000000
        IF      $A256-Q
        BC      Q
        EI
Q       EQ      C7 $0100000000
        IF      $A256-Q
        BC      Q
        EI
Q       EQ      C8 $0100000000
        IF      $A256-Q
        BC      Q
        EI
Q       EQ      C9 $0100000000
        IF      $A256-Q
        BC      Q
        EI
Q       EQ      C10 $0100000000
        IF      $A256-Q
        BC      Q
        EI
Q       EQ      C11 $0100000000
        IF      $A256-Q
        BC      Q
        EI
Q       EQ      C12 $0100000000
        IF      $A256-Q
        BC      Q
        EI
Q       EQ      C13 $0100000000
        IF      $A256-Q
        BC      Q
        EI
Q       EQ      C14 $0100000000
        IF      $A256-Q
        BC      Q
        EI
Q       EQ      C15 $0100000000
        IF      $A256-Q
        BC      Q
        EI
SAVORG  EQ      .
]
:
:MACRO TO END MESSAGE TEXT DEFINITION
:
ENDMSG  MACRO   
[
        ORG     SAVORG
Q       EQ      .-MTEXT-2
        ORG     MTEXT
        HC      Q
]

MSGUSE  MACRO(FCN,P0,P1,P2,P3,P4,P5,P6,P7,P8,P9) [
        MARK(MSGU(`FCN`),A,NDEVM-1,P0,P1,P2,P3,P4,P5,P6,P7,P8,P9)
]
:
:LOOP MACRO FOR ASSIGNING DEVICES TO MESSAGES
:
MSGU    MACRO(FCN) [
        SETO(FCN`TBL,QQ*2)
        HC      MTEXT
QM      EQ      QQ/$A16
        SETO(FCN`BIT,QM*2)
FCN`Q|QM| EQ    FCN`Q|QM|!(8000^(QM*$A16-QQ))
        HC      FCN`Q|QM|
]
:
: MACRO TO CONFIGURE BIT ARRAY FCN
:
NDLUSE  MACRO(FCN,P0,P1,P2,P3,P4,P5,P6,P7,P8,P9) [
        MARK(NDLU(`FCN`),A,NDEVM-1,P0,P1,P2,P3,P4,P5,P6,P7,P8,P9)
]
:
: LOOP MACRO TO ACTUALLY SET THE BIT QQ IN THE BIT ARRAY FCN
:
NDLU    MACRO(FCN)[
QM      EQ      QQ/$A16
        SETO(FCN`BIT,QM*2)
FCN`Q|QM| EQ    FCN`Q|QM|!(8000^(QM*$A16-QQ))
        HC      FCN`Q|QM|
]
:
: MACRO FOR DISCONNECT MESSAGE TO BE SENT IN DSC MSG SEQUENCE
:
        IF      DMSSWT
DMSSND  MACRO(STR) [
        SEG     1
D|DMSNO| SC     /STR/
        SEG     0
        SETO(DMSADR,DMSNO*4)
        WC      D|DMSNO|
DMSNO   EQ      DMSNO+1  ]
:
: MACRO FOR DSC MSG TO BE SENT FROM HOST IN DISCONNECT MSG SEQUENCE
:
DMSRCV  MACRO(STR) [
        SEG     1
D|DMSNO| SC     /STR/
        SEG     0
        SETO(DMSADR,DMSNO*4)
        WC      D|DMSNO|
DMSNO   EQ      DMSNO+1 ]
:  MACRO FOR ASSIGNING DEVICES TO SUPPORT DSC MSG SEQUENCE FUNCTION
:
DMSDEV  MACRO(FCN,P0,P1,P2,P3,P4,P5,P6,P7,P8,P9) [
        MARK(DMGU(`FCN`),A,NDEVM-1,P0,P1,P2,P3,P4,P5,P6,P7,P8,P9) ]

:
: LOOP MACRO TO SET BIT QQ IN THE BIT ARRAY
:
DMGU    MACRO(FCN) [
QM      EQ      QQ/$A16
        SETO(FCN`BIT,QM*2)
DMGQ|QM|        EQ      DMGQ|QM|!(8000^(QM*$A16-QQ))
        HC      DMGQ|QM| ]
        EI

:
: MACROS OF TERMINAL INTERFACE ONLY
:
        ELSE
:
: MACRO TO DEFINE LABELS FOR PRINTER DEVICES
:
DEFPTR  MACRO(C,T,LAB)
[
        IF      T&PRTR
        DEFDEV(C,T)
        SEG     A.ELE
P|PLABNO| SC    /LAB/
        SEG     0
        SETO(PTRMAP,DEVNO*2)
        HC      P|PLABNO|-PTRLAB
PLABNO  EQ      PLABNO+1
        EI
]
:
: MACRO TO DEFINE A LOGON ELEMENT
:
DEFELE  MACRO(STR)
[
        SEG     A.ELE
E|ELENO| SC     /STR/
        SEG     0
        SETO(ELEADR,ELENO*4)
        WC      E|ELENO|
ELENO   EQ      ELENO+1
]
:
: MACRO TO START LOGON STRING SECTION
:
LSTRST  MACRO
[
        SEG     A.ELE
STRLAB  HS      0               :ADR TO START OF LOGON STRING LABELS
        SEG     0
]
:
: MACRO TO DEFINE LOGON STRINGS (A LABEL & CORRESPONDING ELEMENTS)
:
DEFSTR  MACRO(LABEL,ELE0,ELE1,ELE2,ELE3,ELE4)
[
Q0      EQ      ELE0 $A -1
Q1      EQ      ELE1 $A -1
Q2      EQ      ELE2 $A -1
Q3      EQ      ELE3 $A -1
Q4      EQ      ELE4 $A -1
:
        SEG     A.ELE
L|LSTRNO| SC    /LABEL/
        SEG     0
        SETO(LSTRS,LSTRNO*6+4)
        HC      L|LSTRNO|-STRLAB
        SETO(LSTRS,LSTRNO*6+2)
        HC      SLSTNO*2
Q       EQ      0
QQ      EQ      0
        RE      MAXELE
        IF      1+Q|Q|
        SETO(STRLST,SLSTNO*2)
        HC      Q|Q|
QQ      EQ      QQ+1
SLSTNO  EQ      SLSTNO+1
        EI
Q       EQ      Q+1
        ER
        SETO(LSTRS,LSTRNO*6)
        BC      QQ
LSTRNO  EQ      LSTRNO+1
]
:
: MACRO TO DEFINE MANUAL LOGON OPTION
:
MANUAL  MACRO
[
        DEFSTR(MANUAL LOGON)
]
:
: MACRO TO DEFINE A MENU
:

DEFMEN  MACRO(S0,S1,S2,S3,S4,S5,S6,S7,S8,S9,S10,CONT)
[
Q0      EQ      S0 $A -1
Q1      EQ      S1 $A -1
Q2      EQ      S2 $A -1
Q3      EQ      S3 $A -1
Q4      EQ      S4 $A -1
Q5      EQ      S5 $A -1
Q6      EQ      S6 $A -1
Q7      EQ      S7 $A -1
Q8      EQ      S8 $A -1
Q9      EQ      S9 $A -1
QA      EQ      S10 $A -1
QCONT   EQ      CONT $A -1
:
        IF      -QCONT
: NEW MENU (NOT A CONTINUATION)
MENUQ   EQ      0
        SETO(MENUS,MENUNO*4+2)
        HC      MSTRNO*2
        EI
        SETO(MSTRS,MSTRNO*2)
Q       EQ      0
QQ      EQ      0
        RE      MAXMEN/2
        IF      1+Q|Q|
        HC      Q|Q|*6
QQ      EQ      QQ+1
        EI
Q       EQ      Q+1
        ER
MSTRNO  EQ      MSTRNO+QQ
MENUQ   EQ      MENUQ+QQ
        SETO(MENUS,MENUNO*4)
        BC      MENUQ
]
:
: MACRO TO DEFINE THE DEVICE TO MENU MAPPINGS
:
MENDEV  MACRO(P0,P1,P2,P3,P4,P5,P6,P7,P8,P9)
[
        MARK(MENUSE,A,NDEVM-1,P0,P1,P2,P3,P4,P5,P6,P7,P8,P9)
MENUNO  EQ      MENUNO+1
]
:
MENUSE  MACRO
[
        SETO(DEVMAP,QQ*2)
        HC      MENUNO
]
:
: MACRO TO SET BITYS IN BIT ARRAY DEVPVC IN ORDER TO INDICATE WHICH
: DEVICE IS TO HAVE A PERMANENT VIRTUAL CIRCUIT.
:
: PARAMETERS - DEVICES TO BE PVC-CONFIGURED
:
DEFPVC  MACRO(P0,P1,P2,P3,P4,P5,P6,P7,P8,P9) [
        MARK(PVCU,A,NDEVM-1,P0,P1,P2,P3,P4,P5,P6,P7,P8,P9)
]
PVCU    MACRO
[
QM      EQ      QQ/$A16
        SETO(DEVPVC,QM*2)
PVCQ|QM|        EQ      PVCQ|QM|!(8000^(QM*$A16-QQ))
        HC      PVCQ|QM|
]
:
: MACRO TO DEFINE THE MENU SCREEN HEADER
:
DEFHDR  MACRO(HDR)
[
        SEG     1
MENUHD  SC      /HDR/
        SEG     0
]
:
: MACRO TO DEFINE THE CALLING ADDRESS
:
DEFCAL  MACRO(ADR)
[
        SEG     1
CALADR  AC      /ADR/                   :CALLING ADDRESS
        SEG     0
]
        EI

:
:       CALL THE CONFIGURATION MACRO
:
        CONFIG


:
:
        IF      -HSTSWT
        SEG     A.ELE
A|A.ELE|SIZE    EQ      .-A.ELE*10000   :TOTAL SIZE OF ELEMENTS SEGMENT
        FIXSEG(A.ELE)
        SEG     1
        EI
        SUBTTL	3270 STACK HANDLING MACROS
:       STACK MODULE - MACROS ,STORAGE AND INITIALIZATION FOR
:       A BACKGROUND STACK
 
        GL      RSTACK,INSTK,STCKSZ,STACK
 
:       STACK MACROS
:
:       PUSH(REG) - SAVE REG ON THE STACK
:       POP(REG)  - RESTORE REG FROM STACK
:       RETJ(REG) - RESTORE REG AND RETURN USING IT
:       POPPSH(REG) - LOAD REG FROM STACK (LEAVE STACK UNCHANGED)
:       PUSHM(REG)- SAVE REG - R15 ON THE STACK
:       POPM(REG) - RESTORE REG - R15 FROM THE STACK
 
:       THE STACK PTR POINTS TO THE FIRST EMPTY LOCATION
:       THE STACK GROWS UPWARD IN MEMORY
 
PUSH    MACRO(REG)
 [      ST      REG,0,RSTACK  ;   AIS   RSTACK,4  ]
 
POP     MACRO(REG)
 [      SIS     RSTACK,4;       L       REG,0,RSTACK ]
 
RETJ    MACRO(REG)
 [      SIS     RSTACK,4 ;      L    REG,0,RSTACK ;  JR   REG  ]
 
POPPSH  MACRO(REG)
 [      L       REG,-4,RSTACK,  ]
 
PUSHM   MACRO(REG)
 [      STM     REG,0,RSTACK    ;   AHI RSTACK,($010-REG)*4 ]
 
POPM    MACRO(REG)
 [      SHI     RSTACK,($010-REG)*4     ;  LM   REG,0,RSTACK ]
 
:       STORAGE
RSTACK  EQ      R8              : DEDICATED STACK PTR
STCKSZ	EQ	$A60		: SIZE OF STACK IN WORDS

        SEG     0
STACK   WS      STCKSZ            : STORAGE AREA
 
:       INITIALIZATION FOR STACK PTR
        SEG     1
INSTK   LA      RSTACK,STACK,,
        JR      R4
 
        SUBTTL  INACT-INACTIVE MODE ROUTINES
:       INACTIVE MODE ROUTINES
        SEG     1
 
:       OID - DATA MSG IN OUTPUT QUEUE
OID     PUSH(R5)
        JAL     R5,FLOUT
        JAL     R5,FLIN                 : FLUSH INPUT QUEUE
        JAL     R5,STLOG                : START LOGON PROCESS
        RETJ(R5)
 
 
:       OIC - OUTPUT QUEUE CTL RTE TABLE - INACTIVE MODE
OIC     HC      OCTOSS-PSEG             : NULL CMD
        HC      OCTOSS-PSEG             : DISC CMD
        HC      OCTOSS-PSEG             : TIME CMD
        HC      OCTOSS-PSEG             : YELLOW BALL CMD
        HC      OIORG-PSEG              : ORANGE BALL CMD
        HC      OCTOSS-PSEG             : EOT CMD
        HC      OIERR-PSEG              : ERROR CMD
        HC      OISTA-PSEG              : STATUS CMD
        HC      OCTOSS-PSEG             : ACK  CMD
 

OIBUFZ  EQ      40                      :SIZE OF BUFFER TO STORE ERROR/STATUS

:       OIERR - ERROR CONDITION DETECTED IN IDLE STATE
:
:       THIS SHOULD ONLY OCCUR IF A MESSAGE WAS SENT TO A PVC
:       DEVICE TO CHECK WHRTHER OR NOT IT IS OFFLINE.  IF IT IS OFFLINE,
:       THEN AN ERROR CONDITION EXISTS BECAUSE THE MESSAGE FAILED TO BE
:       DELIVERED.
:               R3 = MESSAGE ID, ERROR CODE
:               R0 = SEQ #
:
OIERR   TBT     RDEV,DEVPVC,,           :IS THIS DEVICE DEFINE FOR PVC?
        JE      OCTOSS                  :N - TOSS IT
        ADVCMD(OUT,RDEV,RDEV)
        LHL     R4,OINDX,,              :STORE ERROR CODE
        STB     RDEV,OIBUF,R4,
        STB     R0,OIBUF+1,R4,
        STH     R3,OIBUF+2,R4,
        AIS     R4,4                    :INCREMENT ERROR BUFFER INDEX
        CLHI    R4,OIBUFZ
        JL      OIERR2
        LIS     R4,0
OIERR2  STH     R4,OINDX,,
        J       4,R5                    :RETURN TO PROCESS NEXT COMMAND
:
:       OISTA - STATUS MESSAGE FROM TERMINAL IN IDLE STATE
:       TREAT AS AN ERROR CONDITION
:
OISTA   J       OIERR

:
:       OIORG - ORANGE BALL RECEIVE IN IDLE STATE
:       
:       THIS SHOULD BE RECEIVED IN RESPONSE TO A YELLOW BALL SENT AFTER
:       A 'TEST' MESSAGE TO A PVC DEVICE.  HENCE, BEGIN THE PVC 
:       AUTOMATIC LOGIN
:

OIORG   TBT     RDEV,DEVPVC,,           :IS THE DEVICE DEFINE FOR PVC?
        JE      OCTOSS                  :TOSS IT
        ADVCMD(OUT,RDEV,RDEV)
        LHL     R4,NPVCL,,              :GET NEXT # OF  PVC WE CAN DO
        SIS     R4,1                    :CAN WE STILL DO A PVC LOGIN
        JGE     OIORG2                  :Y - START LOGON
        LHI     R2,YBCMD                :SEND YELLOW BALL TO TRY AGAIN
        PUTCMD(IN,RDEV,RDEV)
        RLCMD(IN,RDEV,RDEV)
        J       OIORG8

:       START AUTOMATIC LOGON FOR PVC DEVICE

OIORG2  STH     R4,NPVCL,,              :STORE UPDATE VALUE
        PUSH(R5)
        LHL     RDCB,DEVTAB,RDEV,RDEV   :GET DCB FOR THIS DEVICE
        JAL     R5,FLIN                 :FLUSH INPUT QUEUE
        JAL     R5,STDCB                :INIT DCB FOR LOGON
        LHL     R1,DLSTR,RDCB,          :GET INDEX TO STORED LOGON STRING
        LHL     R6,MSTRS,R1,            :GET STORED LOGON STRING
        LB      R0,LSTRS,R6,            :GET # OF ELEMENT IN LOGON STRING
        JAL     R5,SLOGON               :INITIATE STORED LOGON SEQUENCE
        POP(R5)
OIORG8  J       4,R5                    :RETURN

:
:       OIBUF - BUFFER TO STORE ERRORCONDITION AND STATUS FOR DEBUGGING
:       EACH ENTRY IS A FULLWORD WHOSE FORMAT:
:               DEVICE#(B),R0(B),ERROR CONDITION/STATUS (H)
:
        SEG     0
        WS      0
OIBUF   BS      OIBUFZ                  :BUFFER TO STORE ERROR OR STSTUS
OINDX   HC      0                       :INDEX TO OIBUF

        
:
:SWITCHED LINE SUPPORT
:
:SYMBOL DEFINITION
:
:       CHNGBT  1 -> NO MESSAGE RECEIVED
:       PHNGBT  1 -> THERE WAS A MESSAGE LAST TIME
:       DHNGBT  1 -> USE HANG PROCESS ON THIS LINE
:       RHNGBT  1 -> RAISE DTR ON THIS PORT
:       IHNTMP  1 -> LOWER DTR ON THIS LINE
:
CHNGBT  HS      1
PHNGBT  HS      1
DHNGBT  HC      UHNGBT
RHNGBT  HS      1
IHNTMP  HS      1
:
:IZIHNG - INITIALISE TIMOUT PROCESS
:       SET     CHNGBT = -1
:               PHNGBT = 0
:               RHNGBT = -1
:
:PUT THE FOLLOWING ON THE TIMOUT LIST
:
:IHNG   WITH IHNGTM PERIOD
:HHNG   WITH HHNGTM PERIOD
:
        LO      BSCDTR
        SEG     1
IZIHNG  PUSH(R5)
        LCS     R0,1
        NH      R0,DHNGBT,,
        STH     R0,CHNGBT,,     :SET CHNGBT
        STH     R0,RHNGBT,,     :SET RHNGBT
        LIS     R0,0
        STH     R0,PHNGBT,,     :RESET PHNGBT
:
        L       R1,FASTC,,      :SCHEDULE TIMOUTS
        AI      R1,RATE*IHNGTM
        LA      R0,IHNG
        JAL     R5,TOPUT,,
:
        L       R1,FASTC,,
        AI      R1,RATE*HHNGTM
        LA      R0,HHNG
        JAL     R5,TOPUT,,
:
        RETJ(R5)
:
:IHNG   FOR EVERY LINE IN WHICH
:       CHNGBT&PHNGBT&DHNGBT=1
:       1)LOWER DTR
:       2)SET TIMER TO RAISE DTR
:       THEN PHNGBT=^CHNGBT,CHNGBT=-1
:
IHNG    L       R1,FASTC,,      :PUT THIS BACK ON LIST
        AI      R1,RATE*IHNGTM
        LA      R0,IHNG
        JAL     R5,TOPUT
        LHL     R1,CHNGBT,,     :SEE WHO NEEDS ATTENTION
        NH      R1,PHNGBT,,
        NH      R1,DHNGBT,,
        NI      R1,0FFFF
        JE      IHNG20          :NOBODY TO WORK ON
:
        STH     R1,RHNGBT,,     :SET TO RAISE DTR
        STH     R1,IHNTMP,,     :SAVE FOR UPDATE
:
IHNG10  JAL     R3,BIDH,,       :FIND FIRST ONE NEEDING SERVICE
        RBT     R2,IHNTMP,,     :DO NOT PROCESS AGAIN
        SBT     R2,BSCDSR,,     :PRETEND IMMEDIATE LOWERING OF DSR
        SBT     R2,RHNGBT,,     :RAISE DTR LATER
        SLLS    R2,4            :MAKE 4-WORD INDEX
        LHI     R1,CDTROFF      :GET DTR DISABLE CMD
        STH     R1,DTRBUF,R2    :STORE INTO ROTOR
        LA      R3,DTRBUF,R2    :GET ROTOR ADR FOR SVC
        SRLS    R2,4            :RESTORE LOGICAL UNIT #
        LB      R2,LUN,R2       :CONVERT TO LUN
        SVC     IOCTRL,FORCEO^4+R2
        JAL     R10,CRASH
:
        LHL     R1,IHNTMP,,     :ANY MORE?
        JN      IHNG10          :YES
:
        L       R1,FASTC,,      :SCHEDULE HHNG
        AI      R1,RATE*HHNGTM
        LA      R0,HHNG
        JAL     R5,TOPUT
:
IHNG20  LHL     R0,CHNGBT,,     :UPDATE PHNGBT
        NH      R0,BSCDSR  
        XHI     R0,0FFFF
        STH     R0,PHNGBT,,
:
        LCS     R0,1
        STH     R0,CHNGBT,,     :UPDATE CHNGBT
:
        J       TORET
:
:HHNG-FOR EVERY LINE IN WHICH RHNGBT=1 RAISE DTR
:
HHNG    LHL     R1,RHNGBT,,
:
HHNG10  JFFOH   R1,HHNG20
        J       TORET           :RETURN IF NOTHING TO DO
HHNG20  RBT     R2,RHNGBT,,
        SLLS    R2,4            :MAKE 4-WORD INDEX
        LHI     R1,CDTRON       :DTR ENABLE CMD
        STH     R1,DTRBUF,R2    :STORE INTO ROTOR
        LA      R3,DTRBUF,R2    :GET ROTOR ADR FOR SVC CALL
        SRLS    R2,4            :RESTORE LOGICAL INIT #
        LB      R2,LUN,R2       :CONVERT LUN
        SVC     IOCTRL,FORCEO^4+R2
        JAL     R10,CRASH
:
        J       HHNG            :GO PROCESS NEXT LINE
        SUBTTL  IDTO-VIRTUAL MODE TIMOUT ROUTINES
:       TIMEOUT  ROUTINES
        SEG     1
 
:       IZIDTO  - INITIALIZE TIMEOUT PROCESS (RESET BITS,PUT RTE ON
:       TIMEOUT LIST
IZIDTO   PUSH(R5)
        LHI     R6,(NDEVB-1)*2          : INDEX TO HALFWORDS
        LIS     R0,0
IZIDT1   STH     R0,IDTIM1,R6,            : RESET BIT ARRAY1
        STH     R0,IDTIM2,R6,            : RESET BIT ARRAY2
        SIS     R6,2
        JGE     IZIDT1                   : REPEAT UNTIL ALL HWORDS DONE
:       NOW SCHEDULE TIMEOUT ROUTINE
        L       R1,FASTC,,
        AI      R1,$ARATE*IDTOP          : GET TIME FIRST EXECUTION
        LA      R0,IDTO                  : GET ADDRESS OF TIMEOUT RTE
        JAL     R5,TOPUT                : PUT ON TIMEOUT RUN LIST
        RETJ(R5)
 
:       SIDTIM  - SET  INPUT DATA  TIMEOUT
:       INPUT - RDEV
SIDTIM   SBT     RDEV,IDTIM1,,
        JR      R4
 
:       RIDTIM - RESET INPUT DATA TIMEOUT
:       INPUT - RDEV
RIDTIM   RBT     RDEV,IDTIM1,,
        RBT     RDEV,IDTIM2,,
        JR      R4
 

:       IDTO  -  INPUT DATA  TIMEOUT ROUTINE
:       RUN PERIODICLY FROM TIMEOUT LIBRARY PACKAGE
IDTO     LHI     R6,(NDEVB-1)*2
IDTO1    LHL     R1,IDTIM2,R6,            : CHECK FOR BITS ON IN IDTIM2
        JE      IDTO2                    : SKIP IF NONE
        JAL     R3,BIDH                 : FIND FIRST BIT ON
        RBT     R2,IDTIM2,R6,            : RESET FIRST BIT
        LR      RDEV,R6                 : BUILD DEVICE NUMBER
        SLHLS   RDEV,3                  : MULTIPLY HWORD INDEX BY 8
        AR      RDEV,R2                 : ADD IN BIT NUMBER IN HWORD
        JAL     R5,IDTOR                 : DO TIMEOUT ACTION FOR THIS DEV.
        J       IDTO1
IDTO2    LHL     R2,IDTIM1,R6,            : GET BIT ARRAY 1
        STH     R2,IDTIM2,R6,            : AND MOVE TO ARRAY 2
        LIS     R2,0
        STH     R2,IDTIM1,R6,            : RESET ARRAY1
        SIS     R6,2
        JGE     IDTO1                    : REPEAT UNTIL ALL HWORDS DONE
:       NOW SCHEDULE TIMEOUT ROUTINE AGAIN
        L       R1,FASTC,,
        AI      R1,$ARATE*IDTOP          : RUN AGAIN IN IDTOP SEC.
        LA      R0,IDTO                  : GET ADDR OF RTE
        JAL     R5,TOPUT                : PUT ON TIMEOUT LIST
        J       TORET
 

:       IDTOR - INPUT DATA ROUTINE FOR DEVICE TIMEOUT
:       INPUT - RDEV
IDTOR   PUSH(R5)
        PUSH(R6)
        LHL     RDCB,DEVTAB,RDEV,RDEV           : GET DCB ADDR
        LHL     RBA,DIRBA,RDCB,         : GET FIRST BUFFER ADDDR
        JE      IDTOR1                  : IF NO MSG STARTED - EXIT
        LH      RBX,DIRBX,RDCB,         : GET OFFSET
        LHL     RSUM,DIRCNT,RDCB,       : GET ACCUMULATED CHECK SUM
        LB      RCOL,DCOL,RDCB,         :GET COLUMN #
        JAL     R5,XAME,,               : END MSG AND QUEUE IT
        LHL     RDEV,DDEV,RDCB,         :RESTORE RDEV (= RCOL)
        LIS     RBA,0
        STH     RBA,DIFBA,RDCB,         :1ST BUFFER ADR = 0
        STH     RBA,DIRBA,RDCB,         : SET CURR. BUF. ADDR.=NULL
IDTOR1  POP(R6)
        RETJ(R5)
 
        SEG     0
IDTIM1  HS      NDEVB                   : TIMER BIT ARRAY 1
IDTIM2  HS      NDEVB                   : TIMER BIT ARRAY 2
        SEG     1
 
        SUBTTL  LTO-LOGIN TIMOUT ROUTINES
:       TIMEOUT  ROUTINES
        SEG     1
 
:       IZLTO  - INITIALIZE TIMEOUT PROCESS (RESET BITS,PUT RTE ON
:       TIMEOUT LIST
IZLTO   PUSH(R5)
        LHI     R6,(NDEVB-1)*2          : INDEX TO HALFWORDS
        LIS     R0,0
IZLT1   STH     R0,LTIM1,R6,            : RESET BIT ARRAY1
        STH     R0,LTIM2,R6,            : RESET BIT ARRAY2
        SIS     R6,2
        JGE     IZLT1                   : REPEAT UNTIL ALL HWORDS DONE
:       NOW SCHEDULE TIMEOUT ROUTINE
        L       R1,FASTC,,
        AI      R1,$ARATE*LTOP          : GET TIME FIRST EXECUTION
        LA      R0,LTO                  : GET ADDRESS OF TIMEOUT RTE
        JAL     R5,TOPUT                : PUT ON TIMEOUT RUN LIST
        RETJ(R5)
 
:       SLTIM  - SET  LOGON  TIMEOUT
:       INPUT - RDEV
SLTIM   SBT     RDEV,LTIM1,,
        JR      R4
 
:       RLTIM - RESET LOGON TIMEOUT
:       INPUT - RDEV
RLTIM   RBT     RDEV,LTIM1,,
        RBT     RDEV,LTIM2,,
        JR      R4
 

:       LTO  -  LOGON  TIMEOUT ROUTINE
:       RUN PERIODICLY FROM TIMEOUT LIBRARY PACKAGE
LTO     LHI     R6,(NDEVB-1)*2
LTO1    LHL     R1,LTIM2,R6,            : CHECK FOR BITS ON IN LTIM2
        JE      LTO2                    : SKIP IF NONE
        JAL     R3,BIDH                 : FIND FIRST BIT ON
        RBT     R2,LTIM2,R6,            : RESET FIRST BIT
        LR      RDEV,R6                 : BUILD DEVICE NUMBER
        SLHLS   RDEV,3                  : MULTIPLY HWORD INDEX BY 8
        AR      RDEV,R2                 : ADD IN BIT NUMBER IN HWORD
        JAL     R5,LTOR                 : DO TIMEOUT ACTION FOR THIS DEV.
        J       LTO1
LTO2    LHL     R2,LTIM1,R6,            : GET BIT ARRAY 1
        STH     R2,LTIM2,R6,            : AND MOVE TO ARRAY 2
        LIS     R2,0
        STH     R2,LTIM1,R6,            : RESET ARRAY1
        SIS     R6,2
        JGE     LTO1                    : REPEAT UNTIL ALL HWORDS DONE
:       NOW SCHEDULE TIMEOUT ROUTINE AGAIN
        L       R1,FASTC,,
        AI      R1,$ARATE*LTOP          : RUN AGAIN IN LTOP SEC.
        LA      R0,LTO                  : GET ADDR OF RTE
        JAL     R5,TOPUT                : PUT ON TIMEOUT LIST
        J       TORET

:       LTOR - ROUTINE CALLED WHEN A DEVICE IS FOUND WITH
:       A LOGON TIMOUT
:       INPUT - RDEV
:       R6 IS SAVED FOR THE TIMEOUT RTE
LTOR    PUSH(R5)
        PUSH(R6)
        LHL     RDCB,DEVTAB,RDEV,RDEV           : GET DCB ADDR
        JAL     R5,LZAP                         : ZAP THE DEVICE
        POP(R6)
        RETJ(R5)
 
        SEG     0
LTIM1   HS      NDEVB                   : TIMER BIT ARRAY 1
LTIM2   HS      NDEVB                   : TIMER BIT ARRAY 2
        SEG     1
 
        SUBTTL  GENERAL TIME OUT ROUTINE

: 
RL      EQ      R8              : CURRENT LINE NUMBER
RL2     eq      r9              :
RCU     eq      r12

	SEG	A.CODE

: IZPCTO - initialize average polling time timeout rountine for
:          reporting to SUP about the polling timefor each line
:          every ten minutes
:
izpcto  push(r5)
        lis     r5,0                    : first line
IZPC10  lis     r6,0
        sth     R6,POLCNT,R5,r5
        ais     r5,1                    : next line
        chi     r5,nbilm                
        jlbs    izpc10
        l       r1,fastc,,
        AI      R1,$ASPLTYM*60*600     : report to SUP every 10 minutes
        la      r0,pcto                 : get addr. of timeout routine
        jal     r5,toput,,              : put it on time out list
        retj(r5)

: pcto - report the average polling time to SUP every ten MINUTES
:
pcto    lis     rl,0                    : first line
        
PCTO10  lb      rcu,fcu,rl              : first control unit
        lr      rl2,rl
        slhls   rl2,2                   : make it full word
        lr      r7,rcu
        slhls   r7,2                    : make it full word
        l       r5,lstpol,r7            : get last polling time
        je      PCTO20                  : polling not start yet
        l       r0,fstpol,rl2           : get first polling time
        jefs    pcto20                  : skip if no poll
        sr      r5,r0                   : count time duration
        LHL     R0,POLCNT,RL,RL         : get poll count
        JEFS    PCTO20                  : SKIP IF NO POLL
        dhr     r5,r0                   : calculate average poll time
        JFS     PCTO30
PCTO20  LCS     R6,1                    : REPORT NO POLL
PCTO30  LR      R0,R6                   : PUT POLL TYM INTO DATA STRING
        SRLS    R0,2
        STB     R0,M.SUP+3,,
        STB     R6,M.SUP+4,,
        LHI     R0,3F                   : TYP = 3F, RECORD POLL TYM
        STB     R0,M.SUP+5,,
        STB     RL,M.SUP+6,,            : LINE #
        LIS     R2,0                    : PORT # = 0
        LA      R3,M.SUP,,              : OUTPUT TO ORING
        JAL     R5,OCM,,
        LIS     R6,0                    : initial. polcnt
        STH     R6,POLCNT,RL,RL
        ST      R6,FSTPOL,RL2           : reset first poll to zero
        AIS     RL,1                    : next line
        CHI     RL,NBILM                : last line?
        JL      PCTO10                  : n - continue
        L       R1,FASTC,,
        AI      R1,$ASPLTYM*60*600   : report again 10 minutes latter
        LA      R0,PCTO                 : GET ADDR.
        jal     r5,toput,,
        j       toret,,
        SUBTTL  XTO-TIMOUT ROUTINES
:       TIMEOUT  ROUTINES
        SEG     1
 
:       IZXTO  - INITIALIZE TIMEOUT PROCESS (RESET BITS,PUT RTE ON
:       TIMEOUT LIST
IZXTO   PUSH(R5)
        LHI     R6,(NDEVB-1)*2          : INDEX TO HALFWORDS
        LIS     R0,0
IZXT1   STH     R0,XTIM1,R6,            : RESET BIT ARRAY1
        STH     R0,XTIM2,R6,            : RESET BIT ARRAY2
        SIS     R6,2
        JGE     IZXT1                   : REPEAT UNTIL ALL HWORDS DONE
:       NOW SCHEDULE TIMEOUT ROUTINE
        L       R1,FASTC,,
        AI      R1,$ARATE*XTOP          : GET TIME FIRST EXECUTION
        LA      R0,XTO                  : GET ADDRESS OF TIMEOUT RTE
        JAL     R5,TOPUT                : PUT ON TIMEOUT RUN LIST
        RETJ(R5)
 
:       SXTIM  - SET  XMT  TIMEOUT
:       INPUT - RDEV
SXTIM   SBT     RDEV,XTIM1,,
        JR      R4
 
:       RXTIM - RESET XMT TIMEOUT
:       INPUT - RDEV
RXTIM   RBT     RDEV,XTIM1,,
        RBT     RDEV,XTIM2,,
        JR      R4
 

:       XTO  -  XMT  TIMEOUT ROUTINE
:       RUN PERIODICLY FROM TIMEOUT LIBRARY PACKAGE
XTO     LHI     R6,(NDEVB-1)*2
XTO1    LHL     R1,XTIM2,R6,            : CHECK FOR BITS ON IN XTIM2
        JE      XTO2                    : SKIP IF NONE
        JAL     R3,BIDH                 : FIND FIRST BIT ON
        RBT     R2,XTIM2,R6,            : RESET FIRST BIT
        LR      RDEV,R6                 : BUILD DEVICE NUMBER
        SLHLS   RDEV,3                  : MULTIPLY HWORD INDEX BY 8
        AR      RDEV,R2                 : ADD IN BIT NUMBER IN HWORD
        JAL     R5,XTOR                 : DO TIMEOUT ACTION FOR THIS DEV.
        J       XTO1
XTO2    LHL     R2,XTIM1,R6,,           : GET BIT ARRAY 1
        STH     R2,XTIM2,R6,            : AND MOVE TO ARRAY 2
        LIS     R2,0
        STH     R2,XTIM1,R6,,           : RESET ARRAY1
        SIS     R6,2
        JGE     XTO1                    : REPEAT UNTIL ALL HWORDS DONE
:       NOW SCHEDULE TIMEOUT ROUTINE AGAIN
        L       R1,FASTC,,
        AI      R1,$ARATE*XTOP          : RUN AGAIN IN XTOP SEC.
        LA      R0,XTO                  : GET ADDR OF RTE
        JAL     R5,TOPUT                : PUT ON TIMEOUT LIST
        J       TORET
 
 
:       XTOR - XMT ROUTINE FOR DEVICE TIMEOUT
:       INPUT - RDEV
XTOR    SBT     RDEV,INGAT,,                    : OPEN INPUT QUEUE GATE
        JR      R5
 
:       XMT TIMER BIT ARRAYS
        SEG     0
XTIM1   HS      NDEVB
XTIM2   HS      NDEVB
 
:       ISIS INPUT CTL RTE TABLES
        SUBTTL  INTAB - ISIS INPUT CTL ROUTINE TABLES
 
        GL      DOZAP
        LO      FRNTND          : GET SYMBOLS FROM ISIS INPUT HANDLER
        GL      IID,IAD
:
:       INACTIVE PORT TABLE
        HTABIA(IIC)
        CHGTAB(IIC,PNDMSG,RLPN)
 
:       LOGON MODE TABLE
        HTABIA(ILC)
        CHGTAB(ILC,DETMSG,RZAPL)
        CHGTAB(ILC,ZAPMSG,RZAPL)
        CHGTAB(ILC,NLOGST,RLNL)
        CHGTAB(ILC,HNGMSG,LZAP)
        CHGTAB(ILC,SHGMSG,LZAP)
        CHGTAB(ILC,LOGOK,RLSL)
        CHGTAB(ILC,LOGFAL,LZAP)
        CHGTAB(ILC,SIIX,SIIX00)
        CHGTAB(ILC,TIIX,TIIX00)

:
:       ASCII MODE TABLE
        HTABVT(IAC)
        CHGTAB(IAC,DETMSG,RZAPA)
        CHGTAB(IAC,NOSMSG,RSETBP)
        CHGTAB(IAC,SNDMSG,RRELBP)
        CHGTAB(IAC,GOBMSG,GOBBLE)
        CHGTAB(IAC,ZAPMSG,RZAPA)
        CHGTAB(IAC,SHGMSG,ZAP0)
        CHGTAB(IAC,0B0,RAB0)
        CHGTAB(IAC,HNGMSG,ZAP0)
        CHGTAB(IAC,0B1,RAB1)
        CHGTAB(IAC,EDMMSG,XTOSS)

:       INC - CONTROL ROUTINE TABLE FOR ISIS INPUT IN NATIVE MODE
 
        HTABVT(INC)
        CHGTAB(INC,DETMSG,RZAPN)
        CHGTAB(INC,ZAPMSG,RZAPN)
        CHGTAB(INC,SHGMSG,NZAP)
        CHGTAB(INC,HNGMSG,NZAP)
        CHGTAB(INC,BLKMSG,RZAPN)
        CHGTAB(INC,GRYMSG,RZAPN)
        CHGTAB(INC,SIIX,SIIX00)
        CHGTAB(INC,TIIX,TIIX00)
 
 

:       IID - DATA MSG FOR INACTIVE PORT
IID     AR      R14,R0          : FLUSH DATA CHARS
        JR      R5
 
EMPTYI  JR      R4              : DUMMY EMPTY INPUT ROUTINE FOR LIB
 
EMPTYO  JR      R4              : DUMMY EMPTY OUTPUT RTE.

:
: ZAP0 - RESETS REASON CODE FOR DISCONNECT AND CALLS APPROPRIATE ZAP ROUTINE.
:       PRESERVES R5 AS LINK REG, DESTROYS R1 AS WORK REG
:
ZAP0    LIS     R1,0
        STB     R1,DZAP,RDCB,           :RESETS REASON CODE
        LB      R1,DMODE,RDCB,          :GET OPERATING MODE
        LHL     R1,ZAPRTE,R1,R1         :GET ZAP ROUTINE
        J       PSEG,R1                 :JUMP TO ZAP ROUTINE
        SUBTTL  FLUSH-BUFFER FLUSH ROUTINES
:       UTILITY ROUTINES TO FLUSH CMD QUEUES
:
:
:       FLXMT - FLUSH XMT QUEUE FOR ONE DEVICE
:       INPUT - RDEV DEVICE NUMBER
:       WORK - R2,R3,R4,R6,R7   LINK - R5
:       SAVE - R2,R3
:
        SEG     0
FLXMR2  WS      1               :STORAGE FOR REG 2
FLXMR3  WS      1               :STORAGE FOR REG 3
FLXMR5  WS      1               :STORAGE FOR REG 5

        SEG     1
FLXMT   ST      R5,FLXMR5,,     :SAVE REG 5
        ST      R2,FLXMR2,,     :SAVE REG 2
        ST      R3,FLXMR3,,     :SAVE REG 3
FLXMT1  PKCMD(XMT,RDEV,RDEV)
        JE      FLXMT3
        JLFS    FLXMT2
        JAL     R5,PBBC         : DATA CMD - FREE BUF.
FLXMT2  ADVCMD(XMT,RDEV,RDEV)   : FLUSH CMD
        J       FLXMT1
FLXMT3  L       R5,FLXMR5,,     :RESTORE REG 5
        L       R2,FLXMR2,,     :RESTORE REG 2
        L       R3,FLXMR3,,     :RESTORE REG 3
        JR      R5              :RETURN
 

        IF      HSTSWT
:
:       FLRCV - FLUSH RCV QUEUE
FLRCV   PUSH(R5)
FLRCV1  PKCMD(RCV,RDEV,RDEV)    : GET NEXT CMD
        JE      FLRCV3          : EXIT IF EMPTY
        JLFS    FLRCV2
        JAL     R5,PBBC         : DATA CMD - FREE BUF.
FLRCV2  ADVCMD(RCV,RDEV,RDEV)   : FLUSH CMD
        J       FLRCV1
FLRCV3  RETJ(R5)
 
        ELSE
:
:       FLOUT - FLUSH OUTPUT QUEUE
FLOUT   PUSH(R5)
FLOUT1  PKCMD(OUT,RDEV,RDEV)
        JE      FLOUT3          : EXIT IF EMPTY
        JLFS    FLOUT2
        JAL     R5,PBBC         : DATA CMD - FREE BUF.
FLOUT2  ADVCMD(OUT,RDEV,RDEV)
        J       FLOUT1
FLOUT3  RETJ(R5)
 
:       FLIN  - FLUSH INPUT QUEUE
FLIN    PUSH(R5)
FLIN1   PKCMD(IN,RDEV,RDEV)     : GET CMD
        JE      FLIN3           : EXIT IF EMPTY
        JLFS    FLIN2
        JAL     R5,PBBC         : DATA CMD - FREE BUF.
FLIN2   ADVCMD(IN,RDEV,RDEV)    : FLUSH CMD
        J       FLIN1
FLIN3   RETJ(R5)
        EI
 
 
        SUBTTL  IIX - ROUTINES TO DISPATCH IIX MESSAGES
        RA      0               :IIX.LIB DWL 09/14/81
        IF      \IIXTRC
        ELSE
IIXTRC  EQ      0
        EI
:
:GLOBOLS
:
        GL      TURBAS,DSPBAS
        GL      SIIX00,DATIIX,FSHIIX,SNDIIX
:
B6.IIX  EQ      01                      :(B6)SUCCESS LOGON IIX BIT
PN.IIX  EQ      8000                    :PSEUDO-NEEDLE IIX BIT
PN.EXT  EQ      4000                    :REQUESTS EXTENDED LOGON STATUS
D.BASE  EQ      8081                    :BASE DIALECT CODE
D.MAX   EQ      4                       :NUMBER OF CURRENT DIALECTS IN IIX
:
:THIS PACKAGE IS INTENDED TO DISPATCH TO THE CORRECT ROUTINE
:TO PROCESS EACH IIX MESSAGE.  IN ADDITION IT WILL DISPATCH
:IIX MESSAGE TYPE 94 FOR DSP MESSAGE TYPES.
:
:THIS PACKAGE WILL REFERENCE IN THE DCB
:
:DISRA          SUBROUTINE FOR IDN DISPATCH
:DIIIX          TABLE FOR IIX MESSAGE DISPATCH
:
:CONFIGURATION OF IIX MESSAGE DISPATCH TABLES
:
:TO GENERATE A TABLE, UTILIZE THE MACRO GENIIX,
:       TABNAM  GENIIX
:WHERE TABNAM IS THE LABEL TO THE GENERATED TABLE,
:WITH ALL REFERENCES SET TO FLUSH THE MESSAGE.  THE
:EXCEPTION IS IIX 94 WHICH WILL GO TO THE DSP DISPATCH 
:PROCESS.  ALL ENTRIES FOR THE DSP DISPATCH WILL BE FLUSH
:ROUTINES AS WELL.
:
:TO CHANGE A BRANCH FOR A GLOBAL IIX ENTRY USE
:
:       GLOIIX(TABNAM,MSGNUM,BRLABL)
:
:WHERE
:TABNAM IS THE FIRST LOCATION IN THE TABLE,
:MSGNUM IS THE LOW ORDER 7 BITS OF THE IIX MSG TYPE,
:BRLABL IS THE PLACE TO BRANCH TO FOR THAT MESSAGE.
:
:TO CHANGE A PROTOCOL ENTRY USE
:
:       TURIIX(TABNAM,MSGNUM,BRLABL)
:
:WHERE
:THE SYMBOLS ARE AS BEFORE.
:
:TO CHANGE A 3270 DSP ENTRY USE
:
:       DSPIIX(TABNAM,MSGNUM,BRLABL)
:
:WHERE
:THE SYMBOLS ARE AS BEFORE EXCEPT MSGNUM IS A DSP MESSAGE NUMBER.
:
:EACH ROUTINE WILL BE BRANCHED TO WITH THE FOLLOWING REGISTER
:CONVENTION:
:
:R0     0       DATA BYTE
:RSL    1       SUBROUTINE ADDRESS FOR FETCHING THE NEXT DATA BYTE
:RBX    2       CURRENT BUFFER INDEX
:RBA    3       CURRENT BUFFER ADDRESS
:RCNT   9       COUNT OF CHARACTERS IN BUFFER
:RRC    A       ISIS MSG COUNT
:RPKT   B       COUNT OF BYTES REMAINING IN PACKET.  USER MUST
:               DECREMENT WITH EACH WITHDRAWAL.
:RDCB   C       DCB LOCATION
:R14    E       ISIS INPUT POINTER
:
RSL     EQ      1
RRC     EQ      0A
RPKT    EQ      0B
:
:TO FLUSH THE BALANCE OF AN IIX MESSAGE JUMP TO FSHIIX.  ALL
:SUBSEQUENT ISIS MESSAGES FOR THIS PORT WILL BE FLUSHED UNTIL
:A SIIX IS DETECTED.  IT IS RECOMMENDED AS A FINAL PROCESS AFTER
:RECEIVING ALL OF A MESSAGE THAT IS TO BE INTERPRETED.
:
:
:CONFIGURATION MACROES
:
:GENERATE A TABLE
:
GENIIX  MACRO   [
        HC      FSHIIX-PSEG     :8080   SELECT DIALECT
        HC      FSHIIX-PSEG     :8081   SELECTED DIALECT
        HC      FSHIIX-PSEG     :8082   GATEWAY REACHED SMART HOST
        HC      FSHIIX-PSEG     :8083   GATEWAY REACHED DUMB HOST
        HC      FSHIIX-PSEG     :8084   LOGON STATUS
        HC      FSHIIX-PSEG     :8085   RESYNCHRONIZE
        HC      FSHIIX-PSEG     :8086   INTERFACE ID/VERSION
        HC      FSHIIX-PSEG     :8087   REQ INTERFACE ID/VERSION
:
:TURKEY MESSAGES
:
        HC      FSHIIX-PSEG     :C087   CALLED ADDRESS
        HC      FSHIIX-PSEG     :C088   CALLING ADDRESS
        HC      FSHIIX-PSEG     :C089   CALL USER DATA
        HC      FSHIIX-PSEG     :C08A   INTERRUPT PKT
        HC      FSHIIX-PSEG     :C08B   INTERRUPT CONFIRMATION
        HC      FSHIIX-PSEG     :C08C   NETWORK UTILITY
        HC      FSHIIX-PSEG     :C08D   FACILITY
        HC      FSHIIX-PSEG     :C08E   UNUSED
        HC      FSHIIX-PSEG     :C08F   UNUSED
        HC      FSHIIX-PSEG     :C090   UNUSED
        HC      FSHIIX-PSEG     :C091   RESET CONFIRMATION
        HC      FSHIIX-PSEG     :C092   CALL ACCEPT
        HC      FSHIIX-PSEG     :C093   TURKEY LEVEL
        HC      DATIIX-PSEG     :C094   DATA
        HC      FSHIIX-PSEG     :C095   CLEAR INDICATION
        HC      FSHIIX-PSEG     :C096   RESET INDICATION
        HC      FSHIIX-PSEG     :C097   CLEAR INFO
        HC      FSHIIX-PSEG     :C098   ABNORMALITY REPORT
:
:       DSP Q=1 MESSAGES
:
        HC      FSHIIX-PSEG     :01     INVITATION TO CLEAR
        HC      FSHIIX-PSEG     :10     CMD/RES UNDILIVERED
        HC      FSHIIX-PSEG     :11     CMD/RES ABORTED
        HC      FSHIIX-PSEG     :12     STATUS MSG
        HC      FSHIIX-PSEG     :14     ACK MESSAGE
        HC      FSHIIX-PSEG     :20     CIR ENABLED
        HC      FSHIIX-PSEG     :21     CIRC. RESET
        HC      FSHIIX-PSEG     :22     CIRC. REQUEST
        HC      FSHIIX-PSEG     :24     CIRC. DISCONNECT
:
:       DSP Q=0
:
        HC      FSHIIX-PSEG     :25     DATA MESSAGE
]
:
:MACRO DEFINITIONS
:
:       MODIFY GLOBOL IIX ENTRIES
:
GLOIIX  MACRO(TABNAM,MSGNUM,BRLABL) [
OLDORG  EQ      .
        ORG     TABNAM+(MSGNUM)*2
        HC      BRLABL-PSEG
        ORG     OLDORG
]
:
:MODIFY TURKEY ENTRY
:
TURIIX  MACRO(TABNAM,MSGNUM,BRLABL) [
        GLOIIX(TABNAM,MSGNUM+TURBAS-7,BRLABL)
]
:
:MODIFY DSP ENTRY
:
DSPIIX  MACRO(TABNAM,MSGNUM,BRLABL) [
        IF      \DSPI|MSGNUM|
        GLOIIX(TABNAM,DSPI|MSGNUM|,BRLABL)
        ELSE
        REMARK  %INVALID DSP MESSAGE
        EI
]
:
:SPECIAL SYMBOLS USED BY THESE MACROES
:
TURBAS  EQ      8               :START OF TURKEY MESSAGES
DSPBAS  EQ      $A 24           :START OF DSP MESSAGES
:
:
DSPI1   EQ      0+DSPBAS        :INV TO CLR
DSPI10  EQ      1+DSPBAS        :CMD/RES UNDELIVERED
DSPI11  EQ      2+DSPBAS        :CMD/RES ABORTED
DSPI12  EQ      3+DSPBAS        :STATUS MESSAGE
DSPI14  EQ      4+DSPBAS        :ACK MESSAGE
DSPI20  EQ      5+DSPBAS        :CIR ENABLED
DSPI21  EQ      6+DSPBAS        :CIR RESET
DSPI22  EQ      7+DSPBAS        :CIR REQUEST
DSPI24  EQ      8+DSPBAS        :CIR DISCONNECT
DSPI25  EQ      9+DSPBAS        :DATA MESSAGE
        SEG     1
:
:RECEIVE A SIIX MESSAGE
:
SIIX00  LHI     R0,SIIX10-PSEG  :CHANGE ACTIVATION ROUTINE
        STH     R0,DISRA,RDCB,
:
        JR      R5
:
:COLLECT IIX MSG TYPE
:
SIIX10  LIS     RPKT,0          :USE AS INDEX OF MSG TYPE
        CHI     R0,80           :IS IT A GLOBOL?
        JEFS    SIIX20          :YES
:
        LIS     RPKT,(TURBAS-7)*2       :GET TURKEY BASE
:
SIIX20  JALR    RSL,RSL         :GET SECOND IIX CHAR
        NHI     R0,7F           :GET MESSAGE TYPE
        AR      R0,R0           MAKE HW INDEX
        AR      RPKT,R0         :ADD STARTING POINT
        A       RPKT,DIIIX,RDCB,        :ADD BASE ADDRESS
        LHL     R5,0,RPKT
        IF      IIXTRC
        JAL     R4,IIXMON
        EI
        J       PSEG,R5         :GO DO IT
:
:PROCESS DATA TYPE IIX MESSAGES
:
DATIIX  JALR    RSL,RSL         :GET DATA FLAG BYTE
        STB     R0,DIX25,RDCB,  :STORE X.25 FLAGS
        JALR    RSL,RSL         :GET FIRST BYTE OF CNT
        LR      RPKT,R0        :COPY
        SLLS    RPKT,8         :MAKE ROOM
        JALR    RSL,RSL         :GET SECOND BYTE
        OR      RPKT,R0        :PUT THE BYTES TOGETHER
:
:
        LB      R0,DIX25,RDCB,  :GET FLAGS AGAIN
        THI     R0,X.Q          :IS IT A Q-BIT PACKET?
        JNFS    DATI10          :YES
:
:TAKE CMD/RESPONSE JUMP (Q=0)
:
        L       R5,DIIIX,RDCB,  :LOCATE BRANCH TABLE
        LHL     R5,DSPI25*2,R5  :GET BRANCH ADDRESS
        IF      IIXTRC
        JAL     R4,IIXMON
        EI
        J       PSEG,R5
:
:Q BIT PACKET (Q=1) ... GET THE TYPE
:
DATI10  JALR    RSL,RSL         :REMOVE UCN
        JALR    RSL,RSL         :MSG TYPE
:
        LIS     R5,8            :LOCATE MSG TYPE
DATI20  CLB     R0,DSPTYP,R5
        JEFS    DATI30
        SIS     R5,1
        JGEBS   DATI20
:
:MESSAGE TYPE NOT FOUND - FLUSH
:
        IF      TSTSWT
        JAL     R10,CRASH               :?? CRASH FOR TESTING
        EI
        J       FSHIIX
:
:FOUND THE MESSAGE TYPE
:
DATI30  AR      R5,R5           :HW INDEX
        A       R5,DIIIX,RDCB,  :GET TABLE
        LHL     R5,DSPBAS*2,R5  :GET BRANCH ADDRESS
        IF      IIXTRC
        JAL     R4,IIXMON
        EI
        J       PSEG,R5
:
:ROUTINE TO FLUSH ALL MESSAGES
:
FSHIIX  LR      R0,RRC          :COPY COUNT
        SIS     R0,1            :DECREMENT FOR BYTE ALREADY GOTTEN
        JLEFS   FSH10           :IF NONE LEFT, JUMP
        JAL     R4,FLUSH        :TRASH THE DATA
        LIS     RRC,0           :SET COUNT TO ZERO
FSH10   JALR    RSL,RSL         :LET IDN EXIT
        JBS     FSHIIX          :DO IT AGAIN
:
:
:
:
:
:
        IF      IIXTRC
:
:TRACE IIX EVENTS
:
IIXMON  LHL     R6,DPORT,RDCB,  :GET PORT #
        LB      R7,IIXTRC,R6    :GET TRACE TABLE INDEX
        AIS     R7,2            :ADVANCE INDEX
        LBR     R7,R7
        STB     R7,IIXTRX,R6
        SLLS    R6,8            :MULTIPLY BY 256
        STH     R5,IIXTTB,R6,R7 :SAVE BRANCH ADDRESS
        JR      R4              :EXIT
:
        SEG     0
IIXTRX  BS      MAXPRT
        SEG     TRCSEG
IIXTTB  HS      MAXPRT*80
        SEG     1
        EI
:
:DATA TABLE FOR FINDING DSP MESSAGES
:
DSPTYP  BC      01,10,11,12,14,20,21,22,24

:
: SNDIIX
:
: SUBROUTINE TO SEND A "CANNED" IIX MESSAGE.
: FIRST A SIIX MESSAGE IS SENT, THEN THE CANNED MESSAGE.
:       R0,R4 = WORK REGISTERS (DESTROYED)
:       R1,R2,R3 = WORK REGISTERS (SAVED)
:       R5 = LINK REGISTER
:       RDCB = ADR OF DCB
:       R6 = ADR TO CANNED MESSAGE
:
SNDIIX  PUSH(R5)
        PUSH(R1)
        PUSH(R2)
        PUSH(R3)
        LHL     R2,DPORT,RDCB,          :GET PORT #
        LA      R3,M.SIIX               :ADR OF SIIX MSG
        JAL     R5,OCM,,                :SEND SIIX
:
        LHL     R2,DPORT,RDCB,          :GET PORT #
        LR      R3,R6                   :ADR TO CANNED MSG
        JAL     R5,OCS,,                :SEND IIX MSG
:
        POP(R3)
        POP(R2)
        POP(R1)
        RETJ(R5)
:
M.SIIX  SC      /"BF/                   :SIIX CODE
:

:
: SEND INVITATION TO CLEAR
:
: LOAD REASON CODE FOR SENDING AN INVITATION TO CLEAR
:
SNDIDQ  LHI     R0,12                   :"INVALID DQ FORMAT"
        J       SNDCLR
:
SNDDAT  LHI     R0,13                   :"INVALID DATA PKT FORMAT"
        J       SNDCLR
:
SNDFAC  LHI     R0,21                   :"FACILITY FAILURE"
        J       SNDCLR
:
: SEND AN "INVITATION TO CLEAR" (WITH REASON CODE IN R0) AND ZAP THE CIRCUIT
:
SNDCLR  STB     R0,M.INV+8,,            :PUT REASON CODE INTO MESSAGE
        LA      R6,M.INV,,              :ADR OF "INVITATION TO CLEAR " MSG
        JAL     R5,SNDIIX               :SEND THE MESSAGE
        J       CLRCIR                  :ZAP THE CIRCUIT AND FLUSH
:
: INVITATION TO CLEAR MSG (Q=1,M=0/MSG CODE 01/REASON TO BE FILLED IN)
        SEG     0
M.INV   SC      /"C0"94"80"00"03"00"01"00/
        SEG     1

:
: SEND INTERRUPT CONFIRMATION (IN RESPONSE TO AN INTERRUPT)
:
SNDINC  LA      R6,M.INC
        JAL     R5,SNDIIX
        J       FSHIIX
:
M.INC   SC      /"C0"8B/

:
: RECEIVED A REQUEST FOR INTERFACE ID AND VERSION NUMBER (87) ...
: SEND AN INTERFACE ID/VERSION (86) MESSAGE INDICATING THE HID
: AND VERSION/REVISION LEVEL.
:
GLOREQ  LA      R6,M.ID         
        JAL     R5,SNDIIX               :SEND ID/VERSION MSG
        J       FSHIIX
:
:
M.ID    BC      6,80,86,00,HID,VERSION,REVLEV

:
: RECEIVED A CIRCUIT RESET (21) ...
: RETURN A CIRCUIT RESET AND SET PROPER SEQUENCE 
: NUMBERS TO DISEQ AND DOSEQ IN THE DCB
:
DSPRST  JALR    RSL,RSL                 :GET RESPONSE SEQ #
        STB     R0,M.CRST+8,,           :STORE AS RESPONSE SEQ #
        SIS     R0,1            :STORE RCV'D SEQ#,GET EXPCTED SEQ #
        IF      HSTSWT
        STB     R0,DISEQ,RDCB,  
        ELSE
        STB     R0,DOSEQ,RDCB,
        EI
        JALR    RSL,RSL                 :GET COMMAND SEQ #
        STB     R0,M.CRST+9,,           :STORE AS COMMAND SEQ #
        SIS     R0,1            :STORE RCV'D SEQ #, GET EXPECTED SEQ #
        IF      HSTSWT
        STB     R0,DOSEQ,RDCB,
        ELSE
        STB     R0,DISEQ,RDCB,
        EI
        JALR    RSL,RSL                 :GET REASON CODE
        STB     R0,M.CRST+0A,,          :RETURN IT
        LA      R6,M.CRST,,
        JAL     R5,SNDIIX               :SEND CIRCUIT RESET MSG
        PUSH(R3)
        LHI     R3,RCVRST               :LOG CIRCUIT RESET
        JAL     R5,SUPLOG
        POP(R3)
        LHI     R0,D.UND                :RESET FLUSHING MODE
        RBT     R0,DFLAGS,RDCB,         : FOR OUT-OF-SEQ DATA
        J       FSHIIX                  
:
: CIRCUIT RESET MESSAGE (Q=1,M=0/ MSG CODE 21/RES SEQ #/
:                         CMD SEQ #/REASON CODE)
:
        SEG     0
M.CRST  SC      /"C0"94"80"00"05"00"21"00"00"00/
        SEG     1
        SUBTTL  LOGMOD - LOGON MODE ROUTINES
:       LOGIN MODE ROUTINES
        LO      BSCCHR
        LO      BSCRCV
        SEG     1
 
 
LOGSTA  EQ      1F              :MASK FOR LOGON STATUS FIELD
HSTERR  EQ      8               :BEGINS CODE FOR HOST ERRORS


:
:
:       STLOG - START THE LOGON PROCESS
:       SET REQUEST OUTSTANDING , SEND MENU SCREEN TO USER
:       SET LOGON TIMER , AND SET OUTPUT ROUTINES TO LOGON MODE
STLOG   PUSH(R5)
        TBT     RDEV,DEVPVC,,           :IS THIS A PVC DEVICE?
        JN      STLOG9                  :Y - DO NOT LOGON HERE
        JAL     R4,SLTIM                : START LOGON TIMER
        JAL     R5,STDCB                : INIT DCB FOR LOGON
        JAL     R5,ILSPM                : SET SCREEN PARMS
        JAL     R5,IAIVAR               : SET ASCII MODE SCREEN VAR.
        TS      MENFLG,,                : DISPLAY MENU?
        JEFS    STLOG8                  : N - SKIP
        JAL     R5,XMENU                :DISPLAY THE MENU SCREEN
STLOG8  SBT     RDEV,INGAT,,            : OPEN INPUT QUEUE GATE
        SBT     RDEV,OUTGAT,,           : OPEN OUTPUT GATE
STLOG9  RETJ(R5)

:
: STDCB - ROUTINE TO INIT DCB FOR LOGON
:
STDCB   LIS     R0,0                    
        STB     R0,DZAP,RDCB,           :INIT TO NO REASON CODE FOR DISCONNECT
        STH     R0,DFLAGS,RDCB,         :CLEAR FLAGS FIELD
        LIS     R0,LMODE
        STB     R0,DMODE,RDCB,          :LOGON OPERATING MODE
        LHI     R0,L.MENU       
        STB     R0,DLFLD,RDCB,          :SET "WAIT FOR MENU SELECTION"
        LIS     R0,D.REQ
        SBT     R0,DFLAGS,RDCB,         : SET REQUEST OUTSTANDING
        LA      R6,MENU-PSEG,,		: SET OUTPUT RTS TO LOGON MODE
        STH     R6,DODRA,RDCB,
        LI      R6,OLC-PSEG             : SET OUTPUT CTL RTES TO LOGON MODE
        STH     R6,DOCRA,RDCB,
        LI      R6,IDN-PSEG             :SET ISIS INPUT RTE ADDRS
        STH     R6,DIDRA,RDCB,
        LA      R6,ILC-PSEG
        STH     R6,DICRA,RDCB,
        LI      R6,STEXT-PSEG           :DISPLAY SUP MSG ON SCREEN
        STH     R6,DISRA,RDCB,          
        JR      R5

:
: THIS SUBROUTINE DISPLAYS THE MENU SCREEN FOR THE CURRENT DEVICE
:
XMENU   PUSH(R5)
        PUSHM(R13)
:?? HOPEFULLY R13-R15 ARE NOT USED INSIDE THE CALLED ROUTINES
        LHL     R6,DEVMAP,RDEV,RDEV     :GET MENU FOR THIS DEVICE
        SLLS    R6,2                    :MAKE FULLWORD INDEX INTO MENUS
        LHL     R14,MENUS+2,R6,         :INDEX TO MSTRS OF FIRST LOGON STRING
        STH     R14,DLSTR,RDCB,         :STORE IT FOR LATER
        LB      R15,MENUS,R6,           :NUMBER OF LOGON STRINGS
        STB     R15,DLCNT,RDCB,         :STORE IT FOR LATER
        AR      R15,R15                 :(DOUBLED)
        LIS     R13,0                   :COUNTS # OF LABELS (DOUBLED)
:
: DISPLAY HEADING OF MENU SCREEN
:
        LHI     R0,FIRBIT
        STH     R0,DIR0,RDCB,           :SET UP CONTROL BYTE
        JAL     R5,PBHIN,,              :START BISYNC MSG W/ STX INSERTED
        LIS     R14,0                    :INIT INDEX TO MENU SCREEN HEADING
XMEN10  LB      R7,MENUH1+2,R14,         :GET CHAR OF MENU SCREEN HEADING
        LB      R0,REVTAB,R7            :REVERSE ITS BITS
        JAL     R5,PBCIN,,              :STORE INTO MSG BUFFER
        AIS     R14,1
        CLH     R14,MENUH1,,
        JL      XMEN10
: PUT BODY OF HEADER MESSAGE INTO BUFFER
        LIS     R14,0
XMEN15  LB      R7,MENUHD+1,R14,
        NHI     R7,7F
        LB      R7,ASCEBC,R7
        LB      R0,REVTAB,R7
        JAL     R5,PBCIN,,
        AIS     R14,1
        CLB     R14,MENUHD,,
        JL      XMEN15
:
: DISPLAY THE ATTRIBUTES FOR EACH LABEL CORRESPONDING TO THE LOGON STRINGS
: IN THE MENU
:
XMEN20  LHI     R7,SBA.                 :INSERT SBA
        LB      R0,REVTAB,R7
        JAL     R5,PBCIN,,
        LB      R7,ROWADR+2,R13           :INSERT SBA ADR
        LB      R0,REVTAB,R7            : (STARTING ON SECOND ROW)
        JAL     R5,PBCIN,,
        LB      R7,ROWADR+3,R13
        LB      R0,REVTAB,R7
        JAL     R5,PBCIN,,
        LHI     R7,SF.                  :INSERT SF
        LB      R0,REVTAB,R7
        JAL     R5,PBCIN,,
        LHI     R7,ATUAD                :INSERT ATUAD TO ALLOW TABS
        LB      R0,REVTAB,R7
        JAL     R5,PBCIN,,
        LR      R13,R13                 :INSERT IC IF FIRST LABEL
        JNFS    XMEN25
        LHI     R7,IC.
        LB      R0,REVTAB,R7
        JAL     R5,PBCIN,,
XMEN25  LHI     R7,SP.                  :INSERT A SPACE BEFORE THE LABEL
        LB      R0,REVTAB,R7
        JAL     R5,PBCIN,,
        LHI     R7,SF.                  :INSERT SF
        LB      R0,REVTAB,R7
        JAL     R5,PBCIN,,
        LHI     R7,ATPND                :INSERT ATPND TO PREVENT LABEL OVERWRITE
        LB      R0,REVTAB,R7
        JAL     R5,PBCIN,,
:
: DISPLAY THE CHARACTERS OF THE LABELS
:
        LHL     R14,DLSTR,RDCB,         :GET BACK INDEX TO MSTRS
        LHL     R1,MSTRS,R14,R13        :GET INDEX TO LSTRS OF CURRENT STRING
        LHL     R1,LSTRS+4,R1,          :GET INDEX TO LABEL
        LIS     R14,0                    :COUNTS # OF CHARS IN LABEL
XMEN30  LB      R7,STRLAB+1,R1,R14       :GET CHAR IN LABEL
        NHI     R7,7F                   :MASK OUT PARITY BIT
        LB      R7,ASCEBC,R7            :CONVERT FROM ASCII TO EBCDIC
        LB      R0,REVTAB,R7            :REVERSE ITS BITS
        JAL     R5,PBCIN,,              :PUT IT INTO MSG BUFFER
        AIS     R14,1                    :INCREMENT COUNT OF CHARS IN LABEL
        CLB     R14,STRLAB,R1,           :TOTAL # AT START OF LABEL
        JL      XMEN30                  :LOOP UNTIL FINISH WITH LABEL
        AIS     R13,2                   :COUNT IS ADVANCED BY HALFWORDS
        CLR     R13,R15                 :ARE WE FINISHED WITH ALL LABELS?
        JL      XMEN20                  :N - JUMP BACK TO MORE
        AIS     R13,2                   :COMPENSATE FOR TITLE MSG IN ROW 0
        STB     R13,DLROW,RDCB,         :STORE ROW FOR NEXT LOGON MSG
:
: IF END OF ALL LABELS, DISPLAY TERMINATING ATTRIBUTES
:
        LIS     R14,0                    :INSERT TERMINATING ATTRIBUTES
XMEN40  LB      R7,MENUH2+2,R14,,        :TERMINATING ATTRIBUTES DEFINED IN MENUH2
        LB      R0,REVTAB,R7
        JAL     R5,PBCIN,,
        AIS     R14,1
        CLH     R14,MENUH2,,
        JL      XMEN40
:
:
: PREPARE TO SEND MENU SCREEN TO TERMINAL
:
        LHI     R0,RETX                 :INSERT ETX TO MSG
        JAL     R5,PBCIN,,
        JAL     R5,PBEIN,,              :END THE BISYNC MSG
        LHL     R0,DIR0,RDCB,
        OHI     R0,ETXBIT
        PUTCMD(IN,RDEV,RDEV)
        RLCMD(IN,RDEV,RDEV)
        POPM(R13)
        RETJ(R5)
:
: TABLE OF ROW ADDRESSES FOR MENU DISPLAY OF LOGON STRINGS
:
ROWADR  EQ      .
ROWQ    EQ      0
        RE      MAXROW
        SBAC(ROWQ,0,$A40)
ROWQ    EQ      ROWQ+2
        ER

:
: MENU - HANDLES THE SELECTION OF LOGON PROCEDURES
:        FROM THE MENU SCREEN.  EXPECTS THE CURSOR POSITION
:        TO DEFINE CHOICE SELECTED.
:
MENU    PUSH(R5)
        LB      R0,BBUFER+3,RBA,        :GET AID CHAR
        CHI     R0,AIDENT               :HIT "ENTER" KEY?
        JN     MENERR                  :N - ERROR
: DETERMINE CURSOR POSITION
        JAL     R5,FCURSOR              :DETERMINE CURSOR ROW NUMBER
        IF      TSTSWT
        JLEBS   .               :?? SHOULD NOT BE ZERO OR LESS
        EI
        CHI     R0,1                    :3101 SENDS EXTRA "SEND"
        JLE     MENERR                  :IF SO FLUSH IT
: DETERMINE WHICH STORED LOGON STRING IN THE MENU WAS SELECTED
:       DLSTR HAS INDEX TO MSTRS OF FIRST LOGON STRING IN MENU
:       DLCNT HAS COUNT OF LOGON STRINGS IN MENU
        LR      R1,R0                   :SAVE ROW SELECTED
        SIS     R1,2                    :ROW "2" IS ACTUALLY FIRST ROW
        CLB     R1,DLCNT,RDCB,          :WAS ROW SELECTED OUTSIDE LIMITS?
        JGE     MENERR                 :Y - TRY AGAIN
: MEN020 - ENTRY TO INITIATE LOGON WITH PREDETERMINED MENU POSITION
: CALLED WITH ABSOLUTE POSITION (FROM 0) IN R1

MEN020  AR      R1,R1                   :MAKE INTO HALFWORD INDEX
        AH      R1,DLSTR,RDCB,          :INDEX TO 1ST STRING IN MENU
        STH     R1,DLSTR,RDCB,          :SAVE INDEX TO SELECTED STRING
        LHL     R6,MSTRS,R1,            :GET SELECTED LOGON STRING
        LB      R0,LSTRS,R6,            :GET NO. OF ELEMENTS IN SELECTED STRING
        JE      MEN030                  :JUMP IF MANUAL MODE
: STORED LOGON...
        JAL     R5,SLOGON               :INITIATE STORED LOGON SEQUENCE
        J       MEN050
: MANUAL LOGON...
MEN030  LA      R6,GETB-PSEG,,
        STH     R6,DLGET,RDCB,          :STORE ADR OF ROUTINE TO GET CHAR
        LIS     R6,D.STOR
        RBT     R6,DFLAGS,RDCB,         :RESET BIT TO INDICATE MANUAL LOGON
        LA      R1,LOGSCN,,             :MANUAL LOGON SCREEN
        JAL     R5,XLERM                :DISPLAY SCREEN
        LHI     R6,LOGROW               :TWO ROWS AFTER "PASSWORD"
        STB     R6,DLROW,RDCB,          :STORE ROW FOR NEXT LOGON MSG
        JAL     R4,SLTIM                :SET LOGON TIMER
        JAL     R5,FLOUT                :FLUSH OUTPUT QUEUE
        LHI     R6,L.STR                :WAIT FOR LOGON STRING
        STB     R6,DLFLD,RDCB,
        LA      R6,OLD-PSEG,,		:GET ADR TO PROCESS LOGON STRING
        STH     R6,DODRA,RDCB,
        J       MEN050
:
: WRONG KEY PRESSED...SEND ERROR MESSAGE TO USER
:
MENERR  JAL     R5,PBBC                 :FREE BUFFER
        ADVCMD(OUT,RDEV,RDEV)
        JAL     R5,XMENU                :DISPLAY MENU SCREEN
MEN050  RETJ(R5)

:
: SLOGON - THIS ROUTINE INITIATES A STORED LOGON SEQUENCE,
:       WHETHER SELECTED IN A MENU OR AN AUTOMATIC PVC LOGON.
: EXPECTS: 
:       R0  - # OF ELEMENTS IN THE LOGON STRING
:       R6  - PTR TO LSTRS
:       RDEV,RDCB
:       R5  - LINK
:
SLOGON  PUSH(R5)
: INITIALIZE REQUIRED PARAMETERS FOR STORED LOGON PROCESSING
        AR      R0,R0                   :# OF ELEMENTS IN STRING (DOUBLED)
        STB     R0,DLSTRN,RDCB,          :STORE IT
        LHL     R1,LSTRS+2,R6,          :GET INDEX TO 1ST ELEMENT OF SELECTED STRING
        STH     R1,DLSTRA,RDCB,         :SAVE IT
        LIS     R0,0
        STB     R0,DLSTRC,RDCB,         :INIT COUNT OF ELEMENTS ALREADY PROCESSED
        LHL     R7,STRLST,R1,           :GET ELEMENT INDEX NUMBER
        SLLS    R7,2                    :MAKE FULLWORD INDEX
        L       R7,ELEADR,R7,           :GET ADR TO 1ST ELEMENT OF LOGON STR
        ST      R7,DLRBA,RDCB,          :SAVE IT
        LIS     R7,0    
        STH     R7,DLRBX,RDCB,          :INIT INDEX THRU CHAR IN ELEMENT
        LA      R0,GETSC-PSEG,,
        STH     R0,DLGET,RDCB,          :STORE ADR OF ROUTINE TO ACCESS CHARS
        LIS     R0,D.STOR
        SBT     R0,DFLAGS,RDCB,         :SET BIT INDICATING STORED LOGON MODE
: INITIATE STORED LOGON PROCEDURES
        LHI     R0,L.PN
        STB     R0,DLFLD,RDCB,          :"WAIT FOR PSEUDO-NEEDLE"
        JAL     R5,SEND07               :SEND REQUEST FOR PSEUDO-NEEDLE
        JAL     R5,FLOUT                       :FLUSH OUTPUT QUEUE
        RBT     RDEV,OUTGAT,,           :CLOSE OUTPUT GATE
        JAL     R4,SLTIM                       :SET LOGON TIMER
        RETJ(R5)

:
: FCURSOR - FIND CURSOR
:
: GIVEN CURSOR ADDR, FIND CURSOR (ROW NUMBER).
: EXPECT        RBA - ADR OF BISYNC MSG BUFFER FROM TERMINAL
:               RDEV - DEVICE #
: RETURNS       R0 = ROW NUMBER
:
FCURSOR PUSH(R5)
        LB      R5,DTYPE,RDEV,
        CHI     R5,C480                 :IS THIS A SMALL SCREEN?
        JE      FCUR50                  :Y-GO PROCESS IT
:
: LARGE SCREEN
:
        LB      R5,BBUFER+5,RBA,        :GET RIGHT BYTE OF CURSOR ADR
        NHI     R5,0030                 :NEED ONLY ESSENTIAL BITS
        SRLS    R5,4                    :INDEX 0,1,2,3
        LB      R0,BBUFER+4,RBA,        :GET LEFT BYTE OF CUROSR ADR
        NHI     R0,1F                   :NEED ONLY ESSENTIAL BITS
        SR      R0,R5                   :GET GROUP HEADER
        NHI     R0,1C                   :OBTAIN GROUP #
        THI     R0,10                   :GROUP # 0,1,2,3,4,5
        JE      FCUR10                  :IF GROUP # 5 OR 6
        SIS     R0,4                    :THEN DECREMENT BY 1
FCUR10  AR      R0,R5                   :CALCULATE ROW #
        AIS     R0,1    
        RETJ(R5)                        :RETURN
:
: SMALL SCREEN
:
FCUR50  LB      R5,BBUFER+4,RBA,        :GET LEFT BYTE OF CURSOR ADR
        NHI     R5,0F                   :NEED ONLY RIGHT NIBBLE
        SLLS    R5,1                    :DOUBLE IT AS INDEX TO TABLE
        LB      R0,BBUFER+5,RBA,        :GET RIGHT BYTE OF CURSOR ADR
        NHI     R0,0F                   :GET RIGHT NIBBLE OF R. BYTE
        JEFS    FCUR60                  :IF 0, INDEX OK
        AIS     R5,1                    :ELSE 8, THEN INCREMENT INDEX
FCUR60  LB      R0,SMTBL,R5             :GET ROW NUMBER
        RETJ(R5)                        :RETURN
:
: TABLE OF ROW NUMBER FOR SMALL SCREEN
:
SMTBL   BC      1,2,3,4,5,0,7,6,0,8,9,0A,0B,0C

:       ILSPM - INITIALIZE LOGON MODE SCREEN PARMS
ILSPM   LB      R6,DCSIZE,RDCB,         : GET NO. ROWS
        STB     R6,DMXROW,RDCB,         : SAVE AS LAST ROW
        LIS     R7,5                    : MIN. ROW = 5 FOR  80 CHAR LINE
        CLHI    R6,$A80
        JGEFS   ILSPM2                  : CHECK FOR SMALL SCREEN
        AR      R7,R7
ILSPM2  STB     R7,DMNROW,RDCB,         : SAVE TOP ROW NO.
        JR      R5
 
 
:       IAIVAR - INITIALIZE ASCII INPUT VARIABLES
IAIVAR  LB      R6,DMNROW,RDCB,
        STB     R6,DROW,RDCB,           : SET CURRENT ROW = MIN.
        LIS     R6,0
        STH     R6,DIFBA,RDCB,          :SET FIRST BUF ADR TO 0
        STH     R6,DIRBA,RDCB,          : SET CURRENT BUF. ADDR.=0
        STB     R6,DCOL,RDCB,           : COLUMN = 0
        LHI     R6,ACR                  : LAST CHAR = CARRIAGE RETURN
        STB     R6,DLC,RDCB,
        JR      R5
 
:       IAOVAR - INITIALIZE ASCII OUTPUT VARIABLES
IAOVAR  LIS     R6,0
        STB     R6,DOMSK,RDCB,
        STH     R6,DORBA,RDCB,          : CURRENT BUF. ADDR.
        JR      R5
 

:       OLD - DATA MSG IN OUTPUT QUEUE WHILE IN LOGON MODE
:       IT SHOULD CONTAIN A LOGON CHAR STRING
OLD     PUSH(R5)
        LB      R0,BBUFER+3,RBA,
        CHI     R0,AIDENT
        JE      OLD020
        CHI     R0,AIDPF1
        JE      OLD020
        J       OLD040                  : WRONG KEY PRESSED
OLD020  LHI     R0,L.PN                 :SET FLAG TO SHOW
        STB     R0,DLFLD,RDCB,          :"WAIT FOR PSUEDO-NEEDLE" STATE
        LA      R6,SNLFA-PSEG,,          : SET OUTPUT DATA RTE ADDR
                                        : TO SEND NEXT LOGON FIELD
        STH     R6,DODRA,RDCB,
        JAL     R5,SEND07               : SEND REQUEST FOR PSEUDO-
                                        : NEEDLE 
        RBT     RDEV,OUTGAT,,           : CLOSE OUTPUT GATE UNTIL
                                        : THE REPLY IS RECEIVED
        JAL     R4,SLTIM                : SET LOGON TIMER
        RETJ(R5)
 
:       OLD040 - WRONG KEY PRESSED
: RESTORE SCREEN TO TRY AGAIN
: ENTERED FROM OLD AND SNLF
OLD040  JAL     R5,PBBC                 : FREE BUF.
        ADVCMD(OUT,RDEV,RDEV)
        LA      R1,LOGSCN,,             : WRONG KEY PRESSED-RESTORE SCN
        JAL     R5,XLERM
        RETJ(R5)

:       SEND07 - SEND PORT 0 TYPE 7 MSG
:                (REQUEST FOR PSEUDO-NEEDLE)
:       INPUT - RDCB
SEND07  PUSH(R3)
        LIS     R0,0B           : SET UP MSG LENGTH
        LIS     R1,0            : PORT NO.
        LIS     R2,7            : MSG TYPE
        JAL     R4,SLOR,,       : START ISIS OUTPUT MSG
        LIS     R0,0            :
        JAL     R4,PUTCH,,
        LB      R0,DLSEQ,RDCB,  : GET LOGON SEQ. NO.
        AIS     R0,4            : ADVANCE IT BY 4
        STB     R0,DLSEQ,RDCB,  : SAVE IT
        SLHLS   R0,8            : SHIFT TO LEFT BYTE OF HALFWORD
        OH      R0,DDEV,RDCB,   : PUT DEVICE NO IN LOWER BYTE
                                : USE AS LOCAL KEY
        JAL     R4,PUTH,,
        LHI     R0,PN.IIX!PN.EXT        :SET "IIX CAPABLE" & EXTENDED STATUS
        JAL     R4,PUTH,,         
        LHI     R0,ORGHST       : ORIG. HOST
        JAL     R4,PUTH,,
        LHI     R0,TIDCHR       : TID CHAR
        JAL     R4,PUTCH,,
        JAL     R4,ELOR,,	: END THE MSG
        POP(R3)
        JR      R5
 
TIDCHR  EQ      0D1             : TID CHAR

:       RL09 - RCV PORT 0 TYPE 9 MSG (PSEUDO-NEEDLE REQ. FAILED)
RL09    PUSH(R5)
        JAL     R4,GETCH,,              : GET PAST ISIS-TYMNET KEY
        JAL     R4,GETH,,               : GET LOCAL KEY
        LR      RDEV,R0                 : SET UP DEVICE NUMBER
        NHI     RDEV,0FF                : MASK OFF LOGON SEG.NO.
        LHL     RDCB,DEVTAB,RDEV,RDEV   : GET DCB ADDR.
        SRHLS   R0,8                    : GET LOGON SEG.NO. IN R0
        CLB     R0,DLSEQ,RDCB,          : COMPARE TO EXPECTED ONE
        JN      RL0910                  : SKIP IF NOT SAME
        LHI     R0,D.REQ
        TBT     R0,DFLAGS,RDCB,         : IS A REQ. OUTSTANDING ?
        JE      RL0910                  :   N - SKIP
        JAL     R5,LZAP                 : ZAP THE PORT
RL0910  RETJ(R5)

:
: (B2)  RCVD NORMAL PSEUDO-NEEDLE MSG
:       FOR AN INACTIVE PORT
:
RLPN    PUSH(R5)
        JAL     R4,GETCH,,      : GET PAST ISIS-TYMNET KEY
        JAL     R4,GETH,,       : GET THE LOCAL KEY
        LR      RDEV,R0         : IT IS A DEVICE NO.
        NHI     RDEV,0FF        : MASK OFF THE LOGON SEQ.NO.
        LHL     RDCB,DEVTAB,RDEV,RDEV   : GET DCB ADDR.
        LB      R6,DLFLD,RDCB,          :GET STATE OF DEVICE
        CLHI    R6,L.PN                 :IS IT WAITING FOR PSEUDO-NEEDLE?
        JN     RLB310                  :N - ZAP THE PORT
        LHI     R6,L.USER               :Y- ADVANCE TO NEXT STATE
        STB     R6,DLFLD,RDCB,          :STORE "WAIT FOR USERNAME"
        SRHLS   R0,8            : GET LOGON SEQ. NO.
        CLB     R0,DLSEQ,RDCB,  : COMPARE TO EXPECTED SEQ. NO.
        JN      RLB310          : ZAP IT IF WRONG NO.
        SBT     R1,TOISIS,,             : SET B.P. FLAGS (BOTH WAYS)
        SBT     R1,FRISIS,,
        SBT     R1,ACP,,                :FLAG PORT AS ACTIVE
        STH     RDCB,PORTAB,R1,R1       : POINT PORT INDEX TO THIS DCB
        STH     R1,DPORT,RDCB,  : STORE PORT NO. IN DCB
        SBT     RDEV,DEVBUSY,,          :INDICATES DEVICE IS BUSY
        LHI     R0,FIRST-1
        STB     R0,XLIMIT,R1,           :INIT XMT LIMIT OF CHAR TO DISPATCHER
        JAL     R4,RLTIM        : RESET LOGON TIMER
        LIS     R0,D.STOR
        TBT     R0,DFLAGS,RDCB,         :STORED LOGON MODE?
        JEFS    RLB305                  :N - JUMP
        JAL     R5,SNLFB                :Y - SEND USERNAME
        JFS     RLB308
RLB305  SBT     RDEV,OUTGAT,,   : OPEN OUTPUT QUEUE GATE
                                : SO THAT THE USERNAME FIELD WILL BE SENT
RLB308  RETJ(R5)
:
: ZAP THE PORT SINCE EITHER PSEUDO-NEEDLE NOT EXPECTED
: OR WRONG SEQUENCE NULMBER.
:
RLB310  PUSHM(R13)
        LIS     R0,3
        LHI     R2,ZAPMSG       : SEND ZAP MSG TO THIS PORT
        JAL     R4,SLOR,,       : START MSG
        JAL     R4,ELOR,,       : END IT
        POPM(R13)
        RETJ(R5)

:
: (B4)  RCVD NORMAL LOGON STATUS MSG IN LOGON MODE
:
RLNL    PUSH(R5)
        LHL     RDEV,DDEV,RDCB, : GET DEVICE NUMBER
        JAL     R4,RLTIM        : RESET LOGON TIMER
        JAL     R4,GETCH,,      : GET STATUS
        NHI     R0,LOGSTA       : ISOLATE STATUS CODE
        JN      RLB610          : IF ERROR - SKIP
        J       RLB605          :IF OK, JUMP
:
: RECEIVED NORMAL LOGON STATUS VIA IIX
:       R0 - STATUS BYTE
:
RLNLB   PUSH(R5)
        LHL     RDEV,DDEV,RDCB,         :GET DEVICE NUMBER
        JAL     R4,RLTIM                :RESET LOGON TIMER
        LR      R0,R0                   :GET STUTUS COND. CODE
        JN      RLB610                  :JUMP IF ERROR
:
: STATUS IS "CONTINUE"...OK
:
RLB605  LB      R6,DLFLD,RDCB,  : ADVANCE NEXT LOGON FIELD
        AIS     R6,1
        STB     R6,DLFLD,RDCB,          :STORE NEXT LOGON FIELD
        LIS     R0,D.STOR
        TBT     R0,DFLAGS,RDCB,          :STORED LOGON MODE?
        JE      RLB620                  :N - JUMP
        JAL     R5,SNLFB                :SEND PASSWORD
        J       RLB630
:
: ERROR STATUS...EITHER USERNAME OR PASSWORD IS WRONG
:
RLB610  LR      R7,R0                   :SAVE STATUS CODE
        LIS     R0,D.STOR
        TBT     R0,DFLAGS,RDCB,         :STORED LOGON MODE?
        JE      RLB615                  :N - JUMP
:STORED LOGON MODE
        SLHLS   R7,2                    :MAKE FULLWORD INDEX
        L       R1,LEMSGB,R7            :GET ERROR MSG
        JAL     R5,PUTADR               :INSERT ROW ADDRESS INTO BUFFER
        JAL     R5,XLERM                :DISPLAY IT
        JAL     R5,LZAP                 :ZAP THE CIRCUIT
        J       RLB630
:MANUAL LOGON MODE
RLB615  PUSH(R7)
        SLHLS   R7,2            : R7 = 4* STATUS CODE
        L       R1,LEMSGA,R7     : GET ADDR OF ERR MSG TO SEND
        JAL     R5,PUTADR       :INSERT ROW ADDRESS
        JAL     R5,XLERM        : SEND IT TO PHYS. DEV.
        JAL     R5,IEND         :SEND ANY EXISTING MSG
        POP(R7)
        CLHI    R7,HSTERR       :IS THIS HOST ERROR CODE?
        JLFS    RLB616          :N - JUMP
        LI      R1,LOGS10               :ERASE USERNAME FIELD
        JAL     R5,XLERM
        LIS     R6,D.ERR                :SET HOST ERROR FLAG
        SBT     R6,DFLAGS,RDCB,         
        LHI     R6,L.USER       :RESET NEXT LOGON FIELD
        JFS     RLB617
RLB616  LB      R6,NLFTAB,R7    :GET NEXT LOGON FIELD FOR THIS STATUS
RLB617  STB     R6,DLFLD,RDCB,  :STORE NEXT LOGON FIELD
        JAL     R5,FLOUT        : FLUSH OUTPUT QUEUE
        JAL     R4,SLTIM        : SET LOGON TIMER
: FINISH PROCESSING NORMAL LOGON STATUS
RLB620  SBT     RDEV,OUTGAT,,   : OPEN OUTPUT QUEUE GATE
RLB630  RETJ(R5)
 
: NEXT LOGON FIELD STATE FOR THIS STATUS (USED AS INDEX)
NLFTAB  BC      L.USER,L.USER,L.USER,L.PASS,L.USER,L.PASS
 
:       LEMSG - ADDRESSES OF LOGON ERROR MSGS FOR EACH STATUS
LEMSGA  WC      LEM1,LEM1,LEM1,LEM2,LEM1,LEM2,LEM1,LEM1
        WC      LEM8,LEM9,LEMA,LEMB,LEMC,LEMD,LEME,LEMF,LEM10,LEM11,LEM12,LEM13
LEMSGB  WC      LEM5,LEM5,LEM5,LEM6,LEM5,LEM6,LEM5,LEM5
        WC      LEM8,LEM9,LEMA,LEMB,LEMC,LEMD,LEME,LEMF,LEM10,LEM11,LEM12,LEM13

:
: PUTADR - INSERTS THE NEXT ROW ADDRESS FOR LOGON ERROR MSG
:          (TO BE CALLED JUST BEFORE XLERM)
:       R1 = ADR TO MSG BUFFER
:       R5 - LINK
:
PUTADR  LB      R6,DLROW,RDCB,          :GET NEXT ROW
        LB      R7,ROWADR,R6            :INSERT ROW ADDRESS INTO MSG BUFFER
        STB     R7,6,R1
        LB      R7,ROWADR+1,R6
        STB     R7,7,R1
        AIS     R6,2                    :INCREMENT ROW # FOR NEXT MSG
        CLHI    R6,MAXROW*2
        JLFS    PUTA10
        LIS     R6,0
PUTA10  STB     R6,DLROW,RDCB,
        JR      R5

:       XLERM - BUILD BISYNC MSG AND PUT IT IN PHYS. DEVICE XMT Q
:       INPUT - RDCB = DCB OF LOGICAL DEVICE
:               GET DEVICE NO. FROM DCB
XLERM   PUSH(R5)
        PUSH(R0)
        LHI     R0,FIRBIT
        STH     R0,DIR0,RDCB,
        JAL     R5,PBMIN,,		: BUILD MSG IN BUF.
        LHL     R5,DDEV,RDCB,		: GET DEVICE NUMBER
        LHL     R0,DIR0,RDCB,
        OHI     R0,ETXBIT
        PUTCMD(IN,R5,R5)
        RLCMD(IN,R5,R5)
        POP(R0)
        RETJ(R5)
 

:
: (B6)  RCVD SUCCESSFUL LOGON MSG IN LOGON MODE
:
: ENTER "WAIT FOR DIALECT" MODE IF IIX CAPABLE
: ENTER ASCII MODE IF NOT IIX CAPABLE
RLSL    PUSH(R5)
        PUSHM(R13)
        LHI     R4,DZ.20                :"PROTOCOL VIOLATION" REASON CODE
        STB     R4,DZAP,RDCB,           :STORE IT FOR DISCONNECT MSG
        LHL     RDEV,DDEV,RDCB,         : GET DEVICE NUMBER
        JAL     R4,RLTIM                : RESET LOGON TIMER
        JAL     R4,GETCH,,              :GET IIX BYTE
        THI     R0,B6.IIX                :IS IT IIX CAPABLE?
        JEFS    RLSL10                  :N - "ENTER ASCII"
        LIS     R0,0                    :Y - ENTER DSP MODE
        ST      R0,DIABIT,RDCB,         :CLEAR DIALECT BITS
        LHI     R0,L.DIA                :"WAIT FOR DIALECTS" STATE
        JFS     RLSL20                  :
RLSL10  JAL     R5,ENTASC               : ENTER ASCII MODE
        LHI     R0,L.OK                 :"SUCCESSFUL LOGIN"
        TBT     RDEV,DEVPVC,,           :WAS THIS A PVC LOGON?
        JEFS    RLSL20                  :N - JUMP
        LIS     R4,1                    :Y - INCREMENT COUNT TO
        AHM     R4,NPVCL,,              :ALLOW FOR NEXT PVC LOGON
RLSL20  STB     R0,DLFLD,RDCB,          :SET NEW STATE
        LA      R0,STEXT-PSEG,,         : DISPLY ERROR MESSAGE IF ANY
        STH     R0,DISRA,RDCB,          :FLUSH EXTRANEOUS MSGS
        IF      DYNBUF
        LHI     R0,MINN0*2              :INIT N0 TO TWICE MINIMUM
        STH     R0,N0IN,RDCB,
        EI
        LIS     R0,D.REQ
        RBT     R0,DFLAGS,RDCB,         : RESET REQUEST OUTSTANDING FLAG
        LIS     R0,D.ERR
        RBT     R0,DFLAGS,RDCB,         :RESET HOST ERROR FLAG (IF ANY)
        POPM(R13)
        LIS     0,6                     :CLEAN OUT MESSAGE
        JAL     R4,FLUSH,,              :FLUSH ISIS INPUT RING
        JAL     R5,FLOUT                :FLUSH OUTPUT QUEUE
        LB      R0,OPORT,RDEV,          :GET PHYSICAL PORT NUMBER FOR THIS DEVICE
        STB     R0,ACCDAT+3,,           :REPORT IT AS CIRCUIT ORIGINATING PORT #
        LIS     R0,5                    :DEVICE TYPE FOR SYNC PORTS
        STB     R0,ACCDAT+2,,           :(DEVICE TYPE,PHY PORT #)
        LHI     R0,0E009                :CODE E, SUBTYPE 9
        STH     R0,ACCDAT,,             :READY TO SEND
        JAL     R5,ACCT                 :SEND CIRCUIT ORIGINATING PORT # TO ACCT
        SLLS    RDEV,2                  :MAKE FULLWORD INDEX
        L       R0,DEVLA,RDEV,          :GET LINE, CU, DEV ADDRESSES
        SRLS    RDEV,2                  :RESTORE RDEV TO DEVICE #
        SRLS    R0,8                    :SHIFT CU, DEV ADR TO R. HALFWD
        STH     R0,ACCDAT+2,,           :STORE INTO ACCT BUFFER
        LHI     R0,0E013                :CODE E, SUBTYPE 19
        STH     R0,ACCDAT,,             :READY TO SEND
        JAL     R5,ACCT                 :SEND CU AND DEV ADR TO ACCT
        RETJ(R5)

:
: SEND ADDENDUM TO ACCOUNTING
:
ACCT    PUSH(R5)
        LIS     R0,8                    :ADDENDUM TO ACCT MSG LENGTH
        LHL     R1,DPORT,RDCB,          :GET PORT NUMBER
        LHI     R2,ADACTG               :ADDENDUM TO ACCT MSG TYPE
        JAL     R4,SLOR,,               :START ISIS OUTPUT MSG
        LIS     R0,0
        JAL     R4,PUTCH,,              :FIRST BYTE IGNORED
        LHL     R0,ACCDAT,,             :GET CODE AND SUBTYPE
        JAL     R4,PUTH,,               :PUT INTO ISIS RINGS
        LHL     R0,ACCDAT+2,,           :GET DATA FOR ACCT
        JAL     R4,PUTH,,               :PUT INTO ISIS RINGS
        JAL     R4,ELOR,,               :END THE MSG
        RETJ(R5)
:
:
        SEG     0
ACCDAT  WS      1                       :STORES DATA FOR ADDENDUM TO ACCT
        SEG     1

:       SNLF - SEND NEXT LOGON FIELD
: THIS SUBROUTINE HAS TWO ENTRY POINTS...SNLFA, SNLFB
:
: SNLFA - MANUAL LOGON ENTRY POINT...CALLED FROM OSCAN
:         WITH OUTDAT=OUTGAT=1
:
SNLFA   PUSH(R5)
        LB      R7,BBUFER+3,RBA,        : GET AID CHAR
        CHI     R7,AIDENT               :ENTER KEY - OK
        JE      SNLF05
        CHI     R7,AIDPF1               :PF1 KEY - OK
        JE      SNLF05
        CHI     R7,AIDCLR               :   CLEAR KEY - ZAP CIRCUIT
        JN      OLD040                  :WRONG KEY PRESSED
        LIS     R0,DZ.3                 :"DROPPED BY USER" REASON CODE
        STB     R0,DZAP,RDCB,           :STORE FOR DISCONNECT MSG
        JAL     R5,LZAP                 :ZAP THE CIRCUIT
        RETJ(R5)
:
: SNLFB - STORED LOGON MODE ENTRY POINT...CALLED FROM RLPN,RLNL,GLOSTA
:
SNLFB   PUSH(R5)
        L       RBA,DLRBA,RDCB,         :GET ELEMENT ADR
        LHL     RBX,DLRBX,RDCB,         :GET CHAR INDEX
: IF USERNAME AND PASSWORD HAVE BEEN SENT, JUST SET TIMER AND WAIT.
SNLF05  PUSH(R14)
        LB      R7,DLFLD,RDCB,          : GET NEXT FIELD NO.
        CHI     R7,L.PSENT              : HAVE USERNAME AND PASS. BEEN SENT?
        JE      SNLF40                  :   Y - SET TIMER AND WAIT
        AIS     R7,1                    :ADVANCE TO NEW LOGON STATE
        STB     R7,DLFLD,RDCB,          :INDICATES FIELD "SENT"
        SHI     R7,L.USENT              :RESET INDEX TO LFA
        LB      R13,LFA,R7,             : GET BUF. ADDR CHARS FOR FIELD
        LB      R14,LFA+1,R7,           :(FOR CALLING FFLD IN MANUAL MODE)
        LIS     R0,D.GATE               
        TBT     R0,DFLAGS,RDCB,         :GATEWAY LOGON?
        JN      SNLF30                  :Y - JUMP
:
:       NOW TRANSMIT CHARS UNTIL A CONTROL CHAR IS FOUND
:
SNLF10  LIS     R0,4                    : GET MSG LENGTH
        LHL     R1,DPORT,RDCB,          : GET PORT NUMBER
        PUSH(R2)                        : SAVE R2 AND R3
        PUSH(R3)
        LHI     R2,NLOGCH               : NORMAL LOGON CHAR MSG
        JAL     R4,SLOR,,
        POP(R3)
        POP(R2)
        LHL     R4,DLGET,RDCB,          :GET ROUTINE ADR
        JAL     R4,PSEG,R4,             :GET CHAR
        LB      R0,EBCASC,R5            : TRANSLATE TO ASCII
        JEFS    SNLF15                  : EXIT IF CTL CHAR FOUND (MANUAL)
        CLHI    R0,ASEMI                : SEMICOLON ?
        JE      SNLF15                  :Y - EXIT
        OHI     R0,80                   : TURN ON HIGH ORDER BIT
        JAL     R4,PUTCH,,              : PUT CHAR INTO RING
        JAL     R4,ELOR,,               : END MSG
        J       SNLF10                  : REPEAT
: FINISHED TRANSMITTING CHARS...CONTROL CHAR FOUND
SNLF15  LHI     R0,ASEMI!80             :SEND SEMICOLON W/ HIGH BIT SET
        JAL     R4,PUTCH,,              : PUT INTO RING
        JAL     R4,ELOR,,               : END MSG
        J       SNLF40
:
: GATEWAY LOGON...SEND ENTIRE USERNAME OR PASSWORD FIELD
:
SNLF30  PUSH(R2)
        PUSH(R3)
        LHI     R0,$A40
        LHI     R2,$A37                 :GET ENOUGH SPACE FOR FIELD
        LHL     R1,DPORT,RDCB,  
        JAL     R4,SLOR,,               :START ISIS MSG
        POP(R3)
        POP(R2)
SNLF32  LHL     R4,DLGET,RDCB,          :GET ROUTINE ADR
        JAL     R4,PSEG,R4,             :GET NEXT LOGON CHR
        LB      R0,EBCASC,R5            :CONVERT TO ASCII
        JE      SNLF36                  :JUMP IF CONTROL CHAR
        CLHI    R0,ASEMI                :IS IT A SEMICOLON?
        JE      SNLF36                  :Y - JUMP
        OHI     R0,80                   :SET HIGH ORDER BIT ON
        JAL     R4,PUTCH,,              :PUT CHAR INTO MSG BUFFER
        J       SNLF32                  :REPEAT
SNLF36  LHI     R0,ASEMI!80             :SEND SEMICOLON W/ PARITY BIT ON
        JAL     R4,PUTCH,,                      
        JAL     R4,ELODR,,              :COUNT BYTES AND END MSG
:
: LOGON FIELD ENDED WITH SEMICOLON...SET TIMER & "LOGON IN PROGRESS"
:
SNLF40  LHL     RDEV,DDEV,RDCB,         :GET DEVICE NUMBER
        JAL     R4,SLTIM                : SET LOGON TIMER
        LA      R1,LEM3,,       : SEND LOGON IN PROG. MSG
        JAL     R5,PUTADR
        JAL     R5,XLERM
        RBT     RDEV,OUTGAT,,           : CLOSE OUTPUT QUEUE GATE
        POP(R14)
        RETJ(R5)
 

:       FFLD - FIND FIELD
:       INPUT - R13,R14 BUFFER ADDRESS CHARS TO BE FOUND
:       OUTPUT - RBX POINTS TO FIRST CHAR FOLLOWING SBA A1 A2
:       (IF THE FIELD WAS NOT FOUND ,IT POINTS TO ETB/ETX CHAR)
:       LOOK FOR AN SBA CHAR AND COMPARE FOLLOWING 2 CHARS TO R13,R14
:       LINK - R5
FFLD    LHI     RBX,-BBFLSZ+1           : INITIAL OFFSET
FFLD10  JAL     R4,GETBC                : GET NEXT CHAR FROM BUF.
        CHI     R0,SBA.                 : SBA CHAR ?
        JN      FFLD20                  :   N - SKIP
:       FOUND SBA
        JAL     R4,GETBC                : GET FIRST ADDR CHAR
        CR      R0,R13                  : 
        JN      FFLD20                  : IF NOT THE ONE WANTED - SKIP
        JAL     R4,GETBC                : GET SECOND ADDR CHAR
        CR      R0,R14                  : 
        JEFS    FFLD30                  : IF MATCHES - EXIT
FFLD20  CHI     R0,ETX                  : CHECK FOR END OF MSG
        JE      FFLD40
        CHI     R0,ETB
        JE      FFLD40
        J       FFLD10                  : NOT END OF MSG - REPEAT
FFLD30  JR      R5                      : RETURN
FFLD40  SIS     RBX,1                   : BACK UP SO THAT ETX/ETB WILL
                                        : BE THE FIRST CHAR RETRIEVED
        JR      R5                      : RETURN

:
: GETSC - SUBROUTINE TO GET NEXT CHAR IN STORED LOGON MODE
:       RBA - ADR TO ELEMENT OF LOGON STRING
:       RBX - RELATIVE INDEX TO CHAR ALREADY ACCESSED
:       R0 - RETURNED ASCII CHAR
:       R5 - RETURNED EBCDIC CHAR
:       R4 - LINK
:
GETSC   AIS     RBX,1                   :INCREMENT COUNT
        CLB     RBX,0,RBA               :IS ELEMENT COMPLETELY FINISHED?
        JLE     GETSC6                  :N - JUMP
        JAL     R5,NXTSC                :GET NEXT ELEMENT
        LIS     RBX,1                   :INIT ELEMENT CHAR INDEX
GETSC6  STH     RBX,DLRBX,RDCB,         :SAVE COUNT OF CHARS ALREADY ACCESSED
        LB      R0,0,RBA,RBX            :GET NEXT CHAR
        LR      R5,R0
        NHI     R5,7F                   :MASK OUT PARITY BIT
        LB      R5,ASCEBC,R5            :CONVERT TO EBCDIC
        JR      R4
:
: NXTSC - GET NEXT ELEMENT FOR STORED LOGON
:       - TO BE CALLED WHEN NEW ELEMENT IS REQUIRED TO INSURE LOGON INTEGRITY
:       - CALLER SHOULD SET RBX & DLRBX (TO 0 OR 1) AFTER CALL
:
:       RBA,RBX - SAME AS FOR GETSC
:       R5 - LINK
:
NXTSC   LB      RBX,DLSTRC,RDCB,        :MAKE SURE ELEMENTS EXIST
        AIS     RBX,2
        CLB     RBX,DLSTRN,RDCB,
        JLFS    NXTSC2
        IF      TSTSWT
        JBS     .
        ELSE
        JAL     R10,CRASH,,
        EI
NXTSC2  STB     RBX,DLSTRC,RDCB,        :ADVANCE TO NEXT ELEMENT
        LHL     RBA,DLSTRA,RDCB,
        LHL     RBX,STRLST,RBA,RBX
        SLLS    RBX,2
        L       RBA,ELEADR,RBX,         :GET ADR TO START OF ELEMENT
        ST      RBA,DLRBA,RDCB,         
        JR      R5

:
: GETB - SUBROUTINE TO SET RBX POINTING TO DESIRED BUFFER INDEX
:        AND GET CHAR FROM THE BUFFER (IE. FROM TERMINAL)
:       R0 - RETURNED ASCII CHAR
:       R5 - RETURNED EBCDIC CHAR
:       R2,R3 - POINTS TO BUFFER WITH CHARS
:       R13,R14 - POINTS TO BUFFER ADR (DESTROYED)
:       R4 - LINK
:
GETB    PUSH(R4)
        CR      R13,R14                 :NEED TO FIND FIELD?
        JEFS    GETB10                  :N - JUMP
        JAL     R5,FFLD                 :Y - FIND THE FIELD
        LR      R13,R14                 :NO MORE FIND FIELD
GETB10  JAL     R4,GETBC                        :GET CHAR
        LR      R5,R0
        LB      R0,EBCASC,R5            :CONVERT TO ASCII
        RETJ(R4)

:       ENTASC - ENTER ASCII MODE
:       SET UP INPUT,OUTPUT RTE ADDRESSES,SEND PROJECT CODE
:       AND SET VARIABLES. ALSO SEND ASCII SCREEN
ENTASC  PUSH(R5)
        LHL     RDEV,DDEV,RDCB,         : GET DEVICE NO.
        JAL     R5,SENDPJ               :SEND PROJECT CODE FOR STORED LOGON
        TBT     RDEV,DEVPVC,,           :IF PVC DEVICE,
        JEFS    ENTA4                   :INCREMENT # OF DEVICES OKAY TO START
        LIS     R5,1                    : A PVC LOGON
        AHM     R5,NPVCL,,
        JAL     R5,RNPVC                :CHECK TO LOGIN A PVC DEVICE
ENTA4
:       INITIALIZE RTE ADDRS
        LHI     R6,IAD-PSEG             : INPUT DATA RTE
        STH     R6,DIDRA,RDCB,
        LHI     R6,IAC-PSEG             : INPUT CTL RTE TABLE ADDR
        STH     R6,DICRA,RDCB,
        LHI     R6,OADM-PSEG            : OUTPUT DATA RTE
        STH     R6,DODRA,RDCB,
        LHI     R6,OAC-PSEG             : OUTPUT CTL RTE TABLE ADDR
        STH     R6,DOCRA,RDCB,

        IF      DYNBUF
        LIS     R0,0                    :INIT N0 TO ZERO
        STH     R0,N0IN,RDCB,           :NO DYNAMIC BUFFER SIZE FOR ASCII MODE
        EI

        LIS     R0,AMODE                :STORE OPERATING MODE
        STB     R0,DMODE,RDCB,
 
        LHI     R6,09D
        LHL     R1,DPORT,RDCB,
        STB     R6,XLIMIT,R1,
        JAL     R4,IZTP                 : INITIALIZE TERM. PARM.
 
:       FLUSH OUTPUT QUEUE , INITIALIZE VARIABLES AND SEND ASCII SCREEN
        JAL     R5,FLOUT                : FLUSH OUTPUT QUEUE
        SBT     RDEV,OUTGAT,,           : OPEN OUTPUT QUEUE GATA
        JAL     R5,IDTOR                : END INPUT MSG ( IF ANY )
        JAL     R5,ISAPM                : INIT. ASCII SCREEN PARMS.
        JAL     R5,XASCN                : SEND INITIAL ASCII SCREEN
        JAL     R5,IAIVAR               : INIT. ASCII VARIABLES
 
        RETJ(R5)
 

: SENDPJ - SEND PROJECT CODE FIELD FOR STORED LOGON STRING ONLY
:
SENDPJ  LIS     R0,D.STOR
        TBT     R0,DFLAGS,RDCB,         :STORED LOGON MODE?
        JER     R5                      :N - EXIT
        L       RBA,DLRBA,RDCB,         :IF NO PROJECT CODE,
        LHL     RBX,DLRBX,RDCB,         :THEN EXIT
        LB      R0,1,RBA,RBX            :(PEEK AT FIRST CHAR IN PROJECT CODE
        CLHI    R0,8D                   : IF IT IS A "8D", THEN EXIT)
        JER     R5
        PUSH(R5)
        LHI     R0,$A40
        LHI     R2,$A37                 :START DATA MSG OF 37 CHARS
        LHL     R1,DPORT,RDCB,          :GET PORT NUMBER
        JAL     R4,SLOR,,
        L       RBA,DLRBA,RDCB,         :SET UP POINTER TO CHARS
        LHL     RBX,DLRBX,RDCB,         : OF STORED LOGON STRING
:       SEND CHARS UNTIL A CTL CHAR IS FOUND
SEND10  LHL     R4,DLGET,RDCB,          :GET ROUTINE TO GET CHAR
        JAL     R4,PSEG,R4,             :GET NEXT CHAR OF PROJECT CODE
        LB      R6,EBCASC,R5            : TRANSLATE TO ASCII
        JEFS    SEND20                  : EXIT IF CTL CHAR
        OHI     R0,80                   : TURN ON HIGH ORDER BIT
        JAL     R4,PUTCH,,              : PUT CHAR INTO RING
        J       SEND10                  : REPEAT
: END OF PROJECT CODE 
SEND20  CLHI    R0,ACR!80               :SEND CR?
        JE      SEND60                  :N - JUMP
        OHI     R0,80
        CLHI    R0,ACR!80
        JE      SEND50                  :Y - JUMP
        IF      TSTSWT
        JBS     .
        ELSE
        J       SEND60
        EI
SEND50  JAL     R4,PUTCH,,              :SEND THE CR AS END OF PROJ CODE
SEND60  JAL     R4,ELODR,,              : END MSG CALCULATING ITS SIZE
        RETJ(R5)

:       XASCN - SEND INITIAL ASCII SCREEN
:       INPUT - RDEV,RDCB
XASCN   PUSH(R5)
        LB      R6,DRSIZE,RDCB,         : GET ROW SIZE
        CHI     R6,$A40                 : SMALL SCREEN ?
        JNFS    XASC10                  :  N - SKIP
        LA      R1,ASC480,,             : GET ADDR OF SMALL SCREEN MSG
        JFS     XASC20
XASC10  LA      R1,ASC192,,             : GET ADDR OF REGULAR SCREEN MSG
XASC20  LHI     R0,FIRBIT
        STH     R0,DIR0,RDCB,
        JAL     R5,PBMIN                : BUILD MSG
        LHL     R0,DIR0,RDCB,
        OHI     R0,ETXBIT
        PUTCMD(IN,RDEV,RDEV)
        RLCMD(IN,RDEV,RDEV)
        RETJ(R5)

:       ISAPM - INITIALIZE ASCII SCREEN PARAMETERS
ISAPM   LIS     R6,0
        STB     R6,DMNROW,RDCB,         : MINIMUM ROW NO.
        STB     R6,DROW,RDCB,           : CURRENT ROW NO.
        LB      R6,DCSIZE,RDCB,         : GET NO. ROWS
        SIS     R6,3                    : LEAVE 2 ROWS FOR INPUT
        STB     R6,DMXROW,RDCB,
        JR      R5
 
:       LZAP - LOGON MODE CIRCUIT ZAP
:       END INPUT MSG , ZAP PORT , SEND 'LOGON FAILED ' MSG
:       AND WAIT FOR NEXT LOGON REQUEST
:       INPUT - RDCB  WORK - R6,R1  LINK R5
LZAP    PUSH(R5)
        LHL     RDEV,DDEV,RDCB,         : GET DEVICE NO.
        TBT     RDEV,DEVPVC,,           :WAS THIS A PVC LOGON?
        JEFS    LZAP2                   :N - JUMP
        LIS     R5,1                    :Y - INCREMENT COUNT TO ALLOW
        AHM     R5,NPVCL,,              :FOR NEXT PVC LOGON
LZAP2   JAL     R5,IEND                 : END INPUT MSG
        LA      R1,LEM4,,               : SEND LOGON FAILED MSG TO TERM.
        JAL     R5,PUTADR
        JAL     R5,XLERM
        JAL     R5,SNDZAP               : SEND A ZAP MSG TO ISIS
        JAL     R5,DOZAP                : ZAP THE CIRCUIT
        SBT     RDEV,OUTGAT,,           : OPEN OUTPUT GATE
        RETJ(R5)
 
 
:       RCVD A ZAP MSG IN ISIS INPUT
RZAPL   PUSH(R5)
        LHL     RDEV,DDEV,RDCB,         : GET DEVICE NUMBER
        TBT     RDEV,DEVPVC,,           :WAS THIS A PVC LOGON
        JEFS    RZAPL2                  :N - JUMP
        LIS     R5,1                    :Y - INCREMENT COUNT TO ALLOW
        AHM     R5,NPVCL,,              :FOR NEXT PVC LOGON
RZAPL2  JAL     R5,IEND                 : END INPUT MSG
        LA      R1,LEM4,,               : SEND LOGON FAILED MSG TO TERM.
        JAL     R5,PUTADR
        JAL     R5,XLERM
        JAL     R5,DOZAP                : ZAP THE DEVICE AND PORT
        RETJ(R5)


: IEND - END INPUT ISIS MESSAGE DURING LOGON MODE
:
IEND    LHL     RBA,DIRBA,RDCB,         :MESSAGE ALREADY STARTED?
        JER     R5                      :N- RETURN
        PUSH(R5)
        LH      RBX,DIRBX,RDCB,         :GET MESSAGE BUFFER INDEX
        LHL     RSUM,DIRCNT,RDCB,       :GET ACCUMULATED CHECKSUM
        LA      R1,STEXT                :ADR OF ROUTINE TO END TEXT
        LHI     R0,ACR                  :SIMULATE A CR
        JALR    RSL,RSL                 :EXECUTE STEXT
        STH     RBA,DIRBA,RDCB,         :CLEAR DIRBA
        RETJ(R5)

:
: STEXT - RECEIVED A TEXT MESSAGE FROM SUPERVISOR DURING LOGIN
:         CALLED FROM IDN
:
STEXT   NHI     R0,7F                   :STRIP OFF PARITY
        CLHI    R0,ACR                  :IS CHAR CR?
        JE      STEXT6                  :Y-JUMP
        LR      R6,R0                   :CONVERT CHAR TO EBCDIC
        LB      R6,ASCEBC,R6
        JE      STEXTZ                  :EXIT IF CHAR IS CONTROL CHAR
:
: IF NO BUFFER FOR SUPERVISOR TEXT HAS BEEN OBTAINED,
: THEN GO GET ONE TO START A NEW MESSAGE
: USING DLROW FOR ROW NUMBER WHERE MESSAGE IS TO BE DISPLAYED.
:
        LR      RBA,RBA                 :MESSAGE BUFFER STARTED YET?
        JN      STEXT4                  :Y - JUMP
        PUSH(R6)                        :SAVE CURRENT CHAR
        LHI     R0,FIRBIT
        STH     R0,DIR0,RDCB,
        JAL     R5,PBHIN                :GET NEW BUFFER W/ STX INSERTED
        STH     RBA,DIFBA,RDCB,         :SAVE 1ST BUFFER ADR
        PUSH(RSL)
        LA      R1,LERR                 :INSERT HEADER
        JAL     R5,PBSIN                :(ESC.,WCMD,WCCK,SBA.)
        POP(RSL)
        LB      R6,DLROW,RDCB,          :GET ROW TO DISPLAY TEXT
        LB      R7,ROWADR,R6            :INSERT ROW ADDRESS
        LB      R0,REVTAB,R7
        JAL     R5,PBCIN
        LB      R7,ROWADR+1,R6
        LB      R0,REVTAB,R7
        JAL     R5,PBCIN
        AIS     R6,2                    :ADVANCE NEXT LOGON MSG ROW
        CLHI    R6,MAXROW*2
        JLFS    STEXT2
        LIS     R6,0
STEXT2  STB     R6,DLROW,RDCB,
        LHI     R7,SF.                  :INSERT SF
        LB      R0,REVTAB,R7
        JAL     R5,PBCIN
        LHI     R7,ATPND                :INSERT ATPND
        LB      R0,REVTAB,R7
        JAL     R5,PBCIN
        POP(R6)                         :RESTORE CURRENT CHAR
:
:
: HAVE A TEXT CHAR...REVERSE IT AND INSERT INTO BUFFER
:
STEXT4  LB      R0,REVTAB,R6
        JAL     R5,PBCIN
        J       STEXTZ
:
: HAVE A CR...SEND CURRENT MESSAGE IN BUFFER AND RESET RBA,DIFBA,DIRBA
:
STEXT6  LR      RBA,RBA                 :IS THERE A MSG WAITING?
        JE      STEXTZ                  :N - EXIT
        LHI     R0,RETX                 :INSERT ETX
        JAL     R5,PBCIN
        JAL     R5,PBEIN                :END THE MESSAGE
        LHL     RDEV,DDEV,RDCB,
        LHL     R0,DIR0,RDCB,
        OHI     R0,ETXBIT
        PUTCMD(IN,RDEV,RDEV)
        RLCMD(IN,RDEV,RDEV)
        LIS     RBA,0                   :RESET RBA,DIRBA,DIFBA
        STH     RBA,DIFBA,RDCB,         :(DIRBA RESET ON EXIT)
:
: EXIT POINT FOR ALL ISIS MESSAGE DURING LOGON
:
STEXTZ  JALR    RSL,RSL                 :RETURN VIA IDN
        J       STEXT
:
:
: LOGON CHARACTER ERROR RESPONSE MESSAGE HEADER
:
LERR    HC      $A4
        BC      ESC.,WCMD,WCCK,SBA.

:       OLC - OUTPUT CONTROL ROUTINE TABLE - LOGON MODE
OLC     HC      OCTOSS-PSEG             : NULL CMD
        HC      OCTOSS-PSEG             : DISC CMD
        HC      OCTOSS-PSEG             : TIME CMD
        HC      OCTOSS-PSEG             : YELLOW BALL CMD
        HC      OCTOSS-PSEG             : ORANGE BALL CMD
        HC      OCTOSS-PSEG             : EOT CMD
        HC      OLER-PSEG               : ERROR CMD
        HC      OLST-PSEG               : STATUS CMD
        HC      OCTOSS-PSEG             : ACK CMD
 
 
:       OLER - ERROR CMD IN OUTPUT QUEUE - LOGON MODE
OLER    PUSH(R5)
OLER10  ADVCMD(OUT,RDEV,RDEV)
        JAL     R5,SUPLOG               : REPORT SUP LOG
        JAL     R5,LZAP                 : ZAP THE DEVICE
        RETJ(R5)
 
:       OLST - STATUS CMD IN OUTPUT QUEUE - LOGON MODE
OLST    PUSH(R5)
        CI      R3,DEVEND               : DEVICE END STATUS ?
        JN      OLER10                  : TREAT AS AN ERROR IF NOT D.E.
        ADVCMD(OUT,RDEV,RDEV)
        POP(R5)
        J       4,R5
 
:       OCTOSS - TOSS CTL CMD IN OUTPUT QUEUE
OCTOSS  ADVCMD(OUT,RDEV,RDEV)
        J       4,R5                    : GO ON TO NEXT CMD
        SUBTTL  BACK - GENERAL BACKGROUND CODE
        RA      0
        LO      BSCCHR          :ACCESS BISYNC CHAR DEFINITIONS
        LO      BSCDTR          :ACCESS LOGICAL UNITS
	GL	LSTART,STARTS,IZBOM,CP.FNT,CP.ACT
	GL	PR.ON,PR.FNT,PR.ACT,ST.FNT,ST.ACT,RE.FNT,RE.ACT
	GL	DA.ON,DA.ONR,DA.ONX,DA.ACT,DA.FNT,PT.ON,PT.ACT
	GL	PT.FNT,PTRBIT

:       CONFIGURATION
:       -------------
SMRSCS  EQ      0               :IF SIMULATING WITH RSCS, TIME BETWEEN
                                :REQUESTS IN SECS, 0 IF NOT IN SIMULATION





ZAPMSG  EQ      09F             : ZAP MSG CODE
        SEG     0




:       PROCESS BASE ADDRESS
:       --------------------
BSEG    EQ      SEG1            :BASE ADDRESS FOR PROCESSES

:	LSTART - GMT AT LAST TIME SLOT WAS STARTED

LSTART	WS	1		:TIME SLOT WAS LAST STARTED
STARTS	HC	0		:NUMBER OF TIMES SLOT STARTED SINCE LOADED

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::                        I N I T I A L I Z A T I O N                        ::
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:       VARIABLE ALLOCATION
:       -------------------

        SEG     1
 
:       REGISTER ALLOCATION
:       -------------------
RBA     EQ      R3              : POINTER TO CURRENT BIG BUFFERLET
RACRC   EQ      R9              : ACCUMULATOR FOR CRC
RL      EQ      R8              : LINE NUMBER
RDEV    EQ      R11             : DEVICE NUMBER
 


:       ZAP ANY ACTIVE PORTS
:       --------------------

START	L	R1,GMT,,	:GET CURRENT GMT
	ST	R1,LSTART,,	:AND SAVE IT
	LIS	R1,1
	AHM	R1,STARTS,,	:BUMP SLOT STARTED COUNT
	LHI     R1,NPORTT-1     :PORT INDEX
        LIS     R5,0            :CONSTANT REG
        LHI     R2,ZAPMSG       :ISIS ZAPPER

IZ0110  NOP
        LIS     R0,3            :ZAPPER LENGTH
        JAL     R4,SLOR,,       :START MSG
        JAL     R4,ELOR,,       :END MSG
IZ0130  SIS     R1,1            :GO TO NEXT PORT
        JGBS    IZ0110

:       DISMISS WHILE ISIS PROCESSES ZAPPERS
        SVC     DISMISS,0


:       INITIALIZE PROCESSORS
:       ---------------------

IZSECT
        JAL     R0,IZT,,        :INIT TIMEOUT FREE LIST
        JAL     R4,IZBB,,       :INIT BIG BUFFERLETS
        JAL     R4,IZCFL,,      : INIT CMD FREE LIST
        JAL     R0,IZFRNT       : INIT ISIS INPUT HANDLER
        JAL     R4,INSTK                : INIT STACK PTR
        JAL     R5,IZDEV        : INIT B.G. DEVICE INFO
        JAL     R5,IZPORT       : INIT PORT INFO
        JAL     R5,IZOPRT       : INIT CIRCUIT ORIGNATION PORT NUMBER
        JAL     R5,IZIHNG       : INITIALIZE HANG TIMER
        JAL     R5,IZLTO        : INIT LOGON TIMERS
        JAL     R5,IZPCTO       : init. polling count timeout routine
        JAL     R5,IZIDTO       : INIT ISIS INPUT DATA TIMEOUT
        JAL     R5,IZXTO        : INIT XMT TIMEOUT
        JAL     R5,INITBP       : INIT. B.P. CHECK TIMER
	JAL	R5,IZBOM,,	: INIT GMT TIMEOUT ROUTINE
	JAL	R5,IZTMCK	: INIT GMT TIMEOUT ROUTINE
        JAL     R9,IZHOST       : INIT HOST STATUS
        JAL     R5,IZPVC        :INIT PVC TIMER
        JAL     R5,IZSPAM,,       : INIT. SPACE MAN. ROUTINES
        JAL     R10,IZBSC       : INIT BSC NON-LINE STUFF
        JAL     R10,IZBILN      :INIT BISYNC LINE STUFF
        JAL     R5,IZMFLG       : INIT DISPLAY MENU FLAG
        LHI     R0,3270         : INIT FRONT PANEL
        STH     R0,FPANEL,,
 

:       START FOREGROUND
:       ----------------

STFG
        IF      ISIS2   
        LA      R0,QBEG         : GET F.G. ADDR.
        SVC     SYS,CFGND.      : CONNECT IT
        ELSE
        SVC     2,QBEG          :CONNECT FOREGROUND
        JAL     R10,BCRASH      :CRASH IF WE CAN'T
        EI

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::                  B A C K G R O U N D   E X E C   L O O P                  ::
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:       VARIABLE ALLOCATION
:       -------------------

        SEG     0
EXRETA  WS      1               :EXEC RETURN ADDR
        SEG     1

EXEC    SVC     DISMISS,0       :DISMISS

        JAL     R0,TIMOUT,,     :PROCESS PERIODIC ROUTINES
        JAL     R0,INPUT        : ISIS INPUT HANDLER
        JAL     R5,ISCAN        : INPUT QUEUE SCANNER
        JAL     R5,RSCAN        : RCV SCANNER
        JAL     R5,OSCAN        : OUTPUT QUEUE SCANNER
	JAL	R5,ZAPPER	: GO ZAP CIRCUITS AS REQUIRED
 
        JAL     R4,GENXMT       : GENERATE REQUESTED TEST MSGS
        JAL     R4,GENRCV       : SAME FOR RCV QUEUE
        J       EXEC            :DO AGAIN

:       COMMON RETURN TO EXEC
:       ---------------------

EXECRT  L       R10,EXRETA,,    :GET EXEC RETURN ADDR
        JR      R10             :RETURN

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::                  F O R E G R O U N D   E X E C   L O O P                  ::
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

QBEG    JAL     R10,BSCEXC,,    :SERVICE BISYNC
        SVC     DISMISS,0       :DISMISS
        JBS     QBEG            :GO AGAIN

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::                            INITIALIZE BISYNC LINES
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:       REGISTER USAGE
:       --------------


IZBILN  LIS     R1,NBILIN-1     :INIT BISYNC ROUTINES
IZA110  JAL     R5,BSCEXI,,     :EXEC SCHEDULER
        LCS     R0,1            :INIT EMPTY POINTER TEST NO-MATCH

        JAL     R5,BSCSRV,,     :RCV
        LCS     R0,1            :XMT
        JAL     R5,BSCSXM,,
        SVC     DISMISS,2	: ALLOW CONNECT CTS ARRAY TO END
        LCS     R0,1            :DTR/DSR
        JAL     R5,BSCDTR
        LCS     R0,1            :POINT-TO-POINT PROTOCOL
        JAL     R5,BSCPTP,,
        SIS     R1,1            :DO ALL LINES
        JGE     IZA110

        JR      R10             : RETURN

        :       INITIALIZE NON-LINE ORIENTED BSC VARIABLES
IZBSC   LHI     R2,0FFFF        : SET UP BIT VALUE OF ALL ONES
        LHI     R1,(NCUB-1)*2
IZBSC2  
        SIS     R1,2
        JGEBS   IZBSC2
 
        JR      R10             :RETURN

 
:       GENXMT - GENERATE TEST MSGS IN XMT QUEUE
GENXMT  PUSH(R4)
        LH      RDEV,GENXM6,,   : GET DEVICE NUMBER
        JL      GENXM3          : SKIP IF < 0
        CLH     RDEV,NDEV,,     : OUT OF RANGE ?
        JG      GENXM3          :   Y - SKIP
        LHL     RDCB,DEVTAB,RDEV,RDEV
        LHL     R0,GENXM8,,
        OHI     R0,FIRBIT
        STH     R0,DIR0,RDCB,
        L       R1,GENXM7,,     : GET MSG PTR
        JAL     R5,PBMXMT
        LHL     R0,DIR0,RDCB,
        OHI     R0,ETXBIT
        PUTCMD(XMT,RDEV,RDEV)   : PUT DATA CMD IN XMT QUEUE
        RLCMD(XMT,RDEV,RDEV)
        LCS     R1,1            : SET GEN. DEV. NO. TO -1
        STH     R1,GENXM6,,
GENXM3  RETJ(R4)
 
        SEG     0
GENXM6  HC      -1              : DEV. NO. FOR MSG
GENXM7  WS      1               : PTR TO MSG
GENXM8  HS      1               : R0 VALUE
        SEG     1

 
:       GENRCV - GENERATE TEST MSGS IN RCV QUEUE
GENRCV  PUSH(R4)
        LH      RDEV,GENRC6,,   : GET DEVICE NO.
        JL      GENRC3          : SKIP IF < 0
        CLH     RDEV,NDEV,,     : SEE IF IN RANGE
        JG      GENRC3          : SKIP IF OUT OF RANGE
        L       R1,GENRC7,,     : GET MSG PTR

        JAL     R5,PUTBX
        LHL     R0,GENRC8,,     : GET R0 VALUE
        PUTCMD(RCV,RDEV,RDEV)
        RLCMD(RCV,RDEV,RDEV)    : PUT DATA CMD INTI RCV CMD LIST
        LCS     R1,1            : GET -1  AND
        STH     R1,GENRC6,,     : RESET GEN. DEV. NO.
GENRC3  RETJ(R4)
 
        SEG     0
GENRC7  WS      1               : PTR TO MSG FOR RCV QUEUE
GENRC8  HS      1               : R0 VALUE
GENRC6  HC      -1              : GEN. DEV. NO.
        SEG     1
        
 
:       COPY A MSG TO BUF. (NO REVERSE)
PUTBX   PUSH(R5)
        PUSH(R15)
        JAL      R4,GBB,,       : GET A BUF.
        J       BCRASH          : CRASH IF NOT AVAIL.
        LHI     RBX,-BBFLSZ+1   : INIT. OFFSET
        LIS     RCNT,0
        PUSH(RBA)
        LHI     R0,STX
        JAL     R5,PUTBC        : STORE STX
        LIS     R15,0           : INIT. INDEX
PUTBX1  LB      R0,2,R1,R15     : GET NEXT BYTE
        JAL     R5,PUTBC        : PUT IN BUF.
        AIS     R15,1
        CLH     R15,0,R1        : AT END OF STRING ?
        JL      PUTBX1          :   N - REPEAT
        LHI     R0,ETX          : ADD ETX
        JAL     R5,PUTBC
        LHI     R0,56           : ADD CKSUM = 5678
        JAL     R5,PUTBC
        LHI     R0,78
        JAL     R5,PUTBC
        LHL     R2,0,R1         : GET LENGTH
        AIS     R2,4            : ALLOW FOR STX,ETX,CKSUM
        POP(RBA)
        POP(R15)
        RETJ(R5)
 
 
:	ZAPPER - ZAP ALL CIRCUITS WHERE BITS ARE SET IN ARRAY ZPCRCT
:	R5	LINK

ZAPPER	PUSH(R5)

	LHI	R1,(NDEVB-1)*2		:SET UP INDEX
ZAPR05	LHL	R2,ZPCRCT,R1		:GET BITS OF CIRCUITS TO ZAP
	NH	R2,DEVBUS,R1,		:MAKE SURE DEVICES ARE BUSY
	JFFOH	R2,ZAPR10		:JUMP IF WE HAVE A CIRCUIT TO ZAP
ZAPR07	SIS	R1,2
	JGEBS	ZAPR05			:UNTIL DONE
	RETJ(R5)

ZAPR10	LR	RDEV,R1			:BUILD DEVICE NUMBER
	SLLS	RDEV,3
	OR	RDEV,R3
	CHI	RDEV,NDEVM		:ARE WE DONE FOR THIS HALFWORD
	JGE	ZAPR07
	RBT	RDEV,ZPCRCT		:SET AS ZAPPED
	LHL	RDCB,DEVTAB,RDEV,RDEV	:GET DCB
	PUSH(R1)			:SAVE INDEX
	JAL	R5,ZAP0			:GO ZAP CIRCUIT
	POP(R1)				:RETRIEVE INDEX
	J	ZAPR05			:AND DO NEXT ONE

:       IZDEV - INITIALIZE B.G. DEVICE INFO
:       ALLOCATE A DCB FOR EACH DEV. AND INIT. IT
:       POINT DEV. INDEX TO IT
:       INIT IN AND OUT QUEUES
IZDEV   PUSH(R5)
        LHL     RDEV,NDEV,,             : SET UP DEVICE NO.
        LHI     RDCB,2-DCBSZ            :INIT TO ZEROTH DCB
IZD10   AHI     RDCB,DCBSZ              :GET NEXT DCB
        IZCL(IN,RDEV,RDEV)              : INIT. INPUT QUEUE
        IZCL(OUT,RDEV,RDEV)             : INIT. OUTPUT QUEUE
        IZCL(SAV,RDEV,RDEV)             : INIT. SAVE QUEUE
        JAL     R5,INDDCB		: INIT THE DCB
        STH     RDCB,DEVTAB,RDEV,RDEV   : POINT DEV INDEX TO IT
        LIS     R6,0
	STH	R6,SS0SS1,RDEV,RDEV	: CLEAR STATUS SAVE AREA
        IF      DYNBUF
        STH     R6,NRSTRT,RDEV,RDEV     :CLEAR # OF RESTARTS
        STH     R6,NDXMT,RDEV,RDEV      :CLEAR # OF BYTES TRANSMITTED
        EI
        RBT     RDEV,LCMMODE,,          :CLEAR LCM BITS
        SIS     RDEV,1
        JGE     IZD10                   : REPEAT FOR ALL DEVICES
        STH     RDCB,DCBX               :STORE LAST ALLOCATED DCB
        RETJ(R5)

:       INDDCB - INIT DEVICE DCB CONTENTS
:       INPUT - RDEV,RDCB
INDDCB  PUSH(R5)
        LIS     R6,0
        STB     R6,DMODE,RDCB,          :INIT OPERATING MODE TO INACTIVE
        STH     R6,DPORT,RDCB,          : SET PORT NO. = 0
        STH     R6,DIFBA,RDCB,          :FIRST BUFFER ADDR
        STH     R6,DIRBA,RDCB,          : CURR. BUF. ADDR = 0
        STH     R6,DFLAGS,RDCB,         : TURN OFF ALL BIT FIELDS
        STH     R6,DLFLD,RDCB,         :RESET NEXT LOGON FIELD
        IF      DYNBUF
        STH     R6,N0XMT,RDCB,          :CLEAR N0 OF XMT QUEUE
        STH     R6,N0IN,RDCB,           :CLEAR N0 OF IN QUEUE
        EI
        RBT     RDEV,DEVBUSY,,          : INDICATES DEVICE IS IDLE
        STH     RDEV,DDEV,RDCB,
        STH     RDEV,DPDEV,RDCB,
        STH     RDEV,DLDEV,RDCB,
        LA      R6,IIXLST
        ST      R6,DIIIX,RDCB,          : IIX MESSAGE DISPATCH TABLE
        JAL     R5,SETOI                : OUTPUT RTES IN INACTIVE MODE
        JAL     R5,SETRP                : RCV RTES IN PASS-THRU MODE
        LB      R6,DTYPE,RDEV,          : GET DEVICE TYPE
        THI     R6,SMALL                : SMALL BUFFER SIZE ?
        JE      INDC20                  :   Y - SKIP
        LHI     R6,$A80
        STB     R6,DRSIZE,RDCB,         : DEFAULT ROW SIZE = 80 CHARS
        LHI     R6,$A24
        STB     R6,DCSIZE,RDCB,         : DEFAULT NO. ROWS = 24
        J       INDC30
INDC20  LHI     R6,$A40                 : ROW SIZE = 40
        STB     R6,DRSIZE,RDCB,
        LHI     R6,$A12                 : 12 ROWS
        STB     R6,DCSIZE,RDCB,
INDC30
        RETJ(R5)

:
: ROUTINES TO HANDLE PERMANENT VIRTUAL CIRCUITS (PVC)
:
:*************************************************************************
:
: IZPVC
:
: THIS ROUTINE INITIALIZES A TIMER TO PERIODICALLY CHECK WHETHER OR NOT
: A DEVICE CONFIGURED TO PVC SHOULD BE AUTOMATICALLY LOGGED ON.  HOWEVER,
: IF NO DEVICE IS CONFIGURED FOR PVC, THEN THE TIMER IS NOT TRIGGERED.
: FOR EACH DEVICE CONFIGURED FOR PVC, THE FIRST LOGON STRING IN ITS MENU
: IS USED FOR THE LOGON AND IT MUST NOT BE A MANUAL LOGON...
: OTHERWISE, CRASH.
:
IZPVC   PUSH(R5)
        LHI     R0,MAXPVC               :GET MAX SIMULTANIOUS PVC LOGONS
        STH     R0,NPVCL,,              :INIT TO START PVCLOGONS
        LIS     R0,0                    
        STH     R0,NPVCD,,              :RESET COUNTER OF PVC DEVICES
        LIS     R0,0                    :INIT CUPOLL TO ZERO
        LHI     R6,(NCUB-1)*2
IZPV05  STH     R0,CUPOLL,R6,
        SIS     R6,2
        JGEBS   IZPV05
:
: INITIALIZE LOGPVC TO DEVPVC AND FIND ALL PVC DEVICES TO CHECK ITS FIRST
: LOGON STRING (MAKE SURE THAT IT IS NOT MANUAL)
:
        LHI     R5,(NDEVB-1)*2
IZPV10  LHL     R6,DEVPVC,R5,            :LOGPVC <-- DEVPVC
        STH     R6,LOGPVC,R5,
        IF      PVCOP3          :OPTION 3...PVCTIM IS ELAPSED BEFORE RETRY
        LIS     R0,0
        STH     R0,L1PVC,R5,     :RESET TIMER BIT ARRAYS
        STH     R0,L2PVC,R5,
        EI
IZPV15  JFFOH   R6,IZPV30       :JUMP IF WE HAVE A PVC DEVICE
IZPV20  SIS     R5,2            :GO TO NEXT HALFWD OF DEVICES
        JGE     IZPV10
        J       IZPV40          :NO MORE HALFWORDS
: FOUND A PVC-CONFIGURED DEVICE...INSURE ITS FIRST LOGON STRING IS NOT MANUAL
IZPV30  XH      R6,HMASK,R7,R7  :RESET BIT TO MASK DEVICE SERVICED
        LR      RDEV,R5         :BUILD DEVICE NUMBER
        SLLS    RDEV,3
        OR      RDEV,R7
        CHI     RDEV,NDEVM      :IS DEVICE # W/IN LIMITS
        JGE     IZPV20          :N - FINISHED WITH THIS HALFWD
        SBT	RDEV,KLTPVC		:SET OK TO LOGON
        LHL     RDCB,DEVTAB,RDEV,RDEV   :GET DCB FOR THIS DEVICE
        LHL     R13,DEVMAP,RDEV,RDEV     :GET MENU FOR THIS DEVICE
        SLLS    R13,2                    :MAKE FULLWORD INDEX
        LHL     R14,MENUS+2,R13,          :GET INDEX TO 1ST LOGON STRING
        STH     R14,DLSTR,RDCB,         :STORE IT AS THE ONE CHOSEN
        LB      R15,MENUS,R13,            :GET # OF LOGON STRINGS
        STB     R15,DLCNT,RDCB,         :STORE IT FOR CONSISTENCY
        LHL     R7,MSTRS,R14,            :GET THE STORED LOGON STRING
        LB      R0,LSTRS,R7,             :GET # OF ELEMENTS IN STRING
        JE      IZPVCR                  :IF 0, THEN MANUAL...CRASH
        LIS     R7,1                    :INCREMENT # OF PVC DEVICES
        AHM     R7,NPVCD,,
        J       IZPV15                  :REPEAT
: IF THERE ARE PVC DEVICES,
: TRIGGER TIMER ROUTINE TO PERIODICALLY INSPECT PVC DEVICES
IZPV40  LHL     R0,NPVCD,,              :ANY PVC DEVICES?
        JE      IZPV90                  :N - DO NOT TRIGGER TIMER
        JAL     R5,RNPVC                :START SOME PVC LOGONS
        L       R7,FASTC,,              :SET TIMER
        LI      R1,PVCTIM*RATE,R7
        LA      R0,CKPVC
        JAL     R5,TOPUT,,              :PUT INTO TIMEOUT LIST
IZPV90  RETJ(R5)
:
IZPVCR  JAL     R10,CRASH,,
        HC      0
        BC      4*R14,97

:
: CKPVC
:
: THIS IS THE PVC TIMER ROUTINE THAT RUNS PERIODICALLY TO CHECK WHETHER OR
: NOT A PVC-CONFIGURED DEVICES NEEDS TO BE LOGGED ON AUTOMATICALLY.
:
CKPVC   AI      R1,PVCTIM*RATE  :NEXT TIME TO CHECK PVC
        JAL     R5,TOPUT,,      :PUT TIMER BACK ONTO TIMEOUT LIST

        IF      PVCOP2          :OPTION 2...AVERAGE PCVTIM
        JAL     R5,RNPVC        :INITIATE PVC LOGONS
        EI

        IF      PVCOP3          :OPTION 3...MINIMUM PVCTIM BEFORE RETRY
        LIS     R4,0
        LHL     R5,(NDEVB-1)*2
CKPV10  LHL     R6,LOGPVC,R5,
        OH      R6,L1PVC,R5,
        STH     R6,LOGPVC,R5,   :LOGPVC <-- LOGPVC .OR. L1
        LHL     R6,L2PVC,R5,
        STH     R6,L1PVC,R5,    :L1 <-- L2
        STH     R4,L2PVC,R5,     :L2 <-- 0

        ELSE    :PVCOP1,PVCOP2,PVCOP4

        LHI     R5,(NDEVB-1)*2
CKPV10  LHL     R6,DEVBUSY,R5,
        XHI     R6,0FFFF
        NH      R6,DEVPVC,R5,
        STH     R6,LOGPVC,R5,   :LOGPVC <-- DEVPVC .AND NOT. DEVBUSY

        EI      :PVCOP3

        SIS     R5,2            :REPEAT THRU ALL HALFWDS OF DEVICES
        JGE     CKPV10

        IF      PVCOP2
        ELSE
        JAL     R5,RNPVC        :INITIATE PVC LOGONS
        EI

        J       TORET,,         :ALL FINISHED...RETURN

:
: RNPVC
:
: THIS ROUTINE INITIATES LOGONS FOR ALL PVC DEVICESTHAT ARE READY TO BE
: LOGGED ON.  THE CRITERIA ARE PVC-CONFIGURED, OK TO LOGON, AND NOT BUSY.
: THE NUMBER OF SIMULTANEOUS PVC LOGONS MUST NOT EXCEED THE MAXIMUM.
:               LINK :  R5
:               WORK :  R4,R6,R7
: EXPECT RDEV AND RDCB TO HAVE CORRECT VALUES.
:
RNPVC   PUSH(R5)
        PUSH(RDEV)
        PUSH(RDCB)
:
: FIND A PVC-CONFIGURED DEVICE THAT IS NOT BUSY
:
        LHI     R5,(NDEVB-1)*2          :START AT LAST HALFWORD
RNPV10  LHL     R6,DEVBUSY,R5,          :GET DEVICE BUSY BITS
        XHI     R6,0FFFF                :INVERT TO GET DEVICE IDLE BITS
        NH      R6,DEVPVC,R5,           :MUST ALSO BE PVC DEVICE
        NH      R6,LOGPVC,R5,           :MUST BE OK TO DO LOGON
        NH	R6,KLTPVC,R5,		:AND NOT KILLED (BY BOM)
RNPV15  JFFOH   R6,RNPV30               :JUMP IF WE GOT A CANDIDATE
RNPV20  SIS     R5,2                    :GO TO NEXT HALFWD OF DEVICES
        JGE     RNPV10
        J       RNPV90                  :ALL FINISHED...RETURN
:
: FOUND AN IDLE, PVC-CONFIGURED DEVICE...
: CHECK IF ITS CU IS ANSWERING POLLS.
:
RNPV30  XH      R6,HMASK,R7,R7          :RESET BIT TO MARK PORT SERVICED
        LR      RDEV,R5                 :BUILD DEVICE # FOR THIS PORT
        SLLS    RDEV,3
        OR      RDEV,R7
        CHI     RDEV,NDEVM              :IS DEVICE # W/IN LIMITS?
        JGE     RNPV20                  :N - FINISHED WITH THIS HALFWD
        LB      R4,DEVCU,RDEV           :GET CU # FOR THIS DEVICE
        TBT     R4,CUPOLL,,             :IS CU ANSWERING POLLS?
        JE      RNPV15                  :N - TRY NEXT DEVICE
:
: INITIATE AUTOMATIC LOGON
:
        LHL     R4,NPVCL,,                :EXCEED MAX PVC SIMULTANEOUS LOGONS?
        JLE     RNPV90                  :Y - RETURN
        SIS     R4,1                    :N - DECREMENT COUNT
        STH     R4,NPVCL,,
        RBT     RDEV,LOGPVC,,           :INDICATE DEVICE BEING LOGGED IN
        PUSH(R5)
        PUSH(R6)
        LHL     RDCB,DEVTAB,RDEV,RDEV   :GET DCB FOR THIS DEVICE
        LA      R1,LEM14,,              :SEND "PVC LOGON IN PROGRESS"
        JAL     R5,XLERM
        LHI     R2,YBCMD                :SEND YELLOW BALL TO INSURE PREVIOUS MSG IS SEND OK
        PUTCMD(IN,RDEV,RDEV)
        RLCMD(IN,RDEV,RDEV)
	POP(R6)
        POP(R5)
        J       RNPV15                  :GO CHECK NEXT DEVICE
:
: RETURN
:
RNPV90
        POP(RDCB)
        POP(RDEV)
        RETJ(R5)

:       IZPORT - INITIALIZE PORT INFO
:       ALLOCATE A DUMMY DCB FOR INACTIVE PORTS AND POINT ALL PORT
:       INDICES TO IT
IZPORT  LHL     RDCB,DCBX               :GET LAST DCB INDEX
        AHI     RDCB,DCBSZ              :INCREMENT TO NEXT DCB INDEX
        LA      R6,IID-PSEG             : SET UP DATA RTE FOR INPUT
        STH     R6,DIDRA,RDCB,
        LA      R6,IIC-PSEG             : SET UP CTL RTE TABLE ADDR
        STH     R6,DICRA,RDCB,
        STH     RDCB,DUMDCB,,           : SAVE ADDR OF DUMMY DCB
        STH     RDCB,DCBX               :STORE LAST ALLOCATED DCB INDEX
:       POINT ALL PORT INDICES TO THIS DCB
        LHI     R1,NPORT-1              : R1 = PORT NO.
IZP10   STH     RDCB,PORTAB,R1,R1       : POINT PORT INDEX TO DCB
        RBT     R1,PORTUP
        SIS     R1,1                    : REDUCE PORT NUMBER
        JG      IZP10
        JR      R5
 
        GL      DUMDCB
        SEG     0
DUMDCB  HS      1                       : PTR TO DUMMY DCB
        SEG     1

:
: IZOPRT
: ROUTINE TO SET UP THE CIRCUIT ORIGINATION PORT NUMBER FOR EACH DEVICE
:
IZOPRT  LHL     RDEV,NDEV,,             :INDEX THRU ALL DEVICE NUMBERS
IPRT10  LB      R1,DEVLN,RDEV,          :GET LINE NUMBER
        LB      R1,LUN,R1,              :GET LOGICAL UNIT
        LA      R2,SVCPRT,,             :ADR TO STORE I/O ATTRIBUTES
        LIS     R3,2                    :GETTING 2 BYTES OF DATA
        SVC     IO,8000+R1,,            :QUERY I/O ATTRIBUTES
        JAL     R10,BCRASH               :FAIL
        LB      R0,SVCPRT+1,,           :GET THE PHYSICAL PORT NUMBER
        STB     R0,OPORT,RDEV,          :STORE IT AS ORIGINATING PORT NUMBER
        SIS     RDEV,1                  :DECREMENT DEVICE NUMBER
        JGE     IPRT10                  :REPEAT TIL ALL DEVICES ARE DONE
        JR      R5
:
:
        SEG     0
SVCPRT  HS      1                       :STORES DATA FROM I/O QUERY
OPORT   BS      NDEVM                   :ORIGINATION PORT NUMBER BY DEVICE
        SEG     1

:
: IZHOST
:
: THIS ROUTINE SENDS HOST STATUS OF "SHUT" FOR THE TERMINAL INTERFACE
:
: REGISTER:     R9 - LINK,   R2,R3,R5 - WORK
:
IZHOST
        LIS     R2,0            :PORT 0 MSG
        LA      R3,H.MSG        :ADR TO EXTENDED HOST STATUS MSG
        JAL     R5,OCM,,        :SEND IT
        JR      R9              :RETURN
:
:
HS.SHUT EQ      2               :HOST SHUT STATUS
        HS      0               :ALIGN H.MSG FOR ORGHST
        BC      0               :       "
H.MSG   BC      $A12
        BC      10,0
        HC      ORGHST,0,0
        BC      HS.SHUT,0,80,PRODID



:       OSCAN - OUTPUT CMD QUEUE SCANNER
RRX     EQ      R6                      : INDEX TO FLAG HWORDS
OSCAN   PUSH(R5)
:       LOOP OVER HALFWORDS OF OUTPUT QUEUE DATA PRESENT FLAGS
:       LOOKING FOR DEVICES WITH CMDS IN THEIR QUEUES
        LHI     RRX,(NDEVB-1)*2         : SET UP HWORD INDEX
OSCA00	LHL     R1,OUTDAT,RRX,          : GET DATA PRES. FLAG
        NH      R1,OUTGAT,RRX,          : MASK WITH GATE BITS
        JE      OSCA50                  :   EMPTY - GO ON TO NEXT HWORD
        STH     R1,OSCA80,,             : SAVE FLAGS HWORD
        SLHLS   RRX,3                   : CONVERT RRX TO FIRST DEV.NO. IN HWORD
        STH     RRX,OSCA90,,            : SAVE IT
OSCA05	JAL     R3,BIDH,,               : FIND FIRST BIT ON
        RBT     R2,OSCA80,,             : RESET BIT FOUND
        AH      R2,OSCA90,,             : CONVERT R2 TO DEVICE NO.
        LR      RDEV,R2                 : PUT INTO RDEV
OSCA10	PKCMD(OUT,RDEV,RDEV)
        JE      OSCA40                  : GET NEXT CMD - IF EMPTY EXIT
        LHL     RDCB,DEVTAB,RDEV,RDEV   : GET DCB ADDR
        LR      R2,R2                   : TEST CMD CODE
        JL      OSCA20                  :   CTL - SKIP

:	IF CPS TRACE ENABLED, COUNT CHARS OUTPUT FOR BOTH
:	NATIVE AND VIRTUAL MODE

	LH	R6,CP.ON,,		:IS CPS TRACE ENABLED
	JLFS	OSCA16			:IF NOT, SKIP AHEAD
	LH	R6,CP.LN,,		:SLOT OR LINE
	JLFS	OSCA15			:IF SLOT, SKIP AHEAD
	CLB	R6,DEVLN,RDEV		:IS THIS THE RIGHT LINE
	JNFS	OSCA16			:IF NOT SKIP AHEAD
OSCA15	LR	R6,R2			:ADJUST COUNT, SEE OND
	IF	BSCCST			:FOR EXPLANATION OF ADJUSTMENT
	SIS	R6,1
	ELSE
	SIS	R6,2
	EI	:BSCCST
	AM	R6,CP.CNT,,		:AND ADD IT IN

OSCA16	LHL     R6,DODRA,RDCB,          : GET DATA RTE ADDR
        JAL     R5,PSEG,R6,             : CALL IT
        J       OSCA40                  :   RETURN HERE WHEN THRU FOR DEV.
        J       OSCA10                  :   RETURN HERE TO CONTINUE
OSCA20	LHL     R5,DOCRA,RDCB,          : GET CTL RTE TABLE ADDR
        SR      R5,R2                   : NOW CONVERT CMD CODE TO POSITIVE
                                        : INDEX
        SR      R5,R2
        LHL     R5,PSEG,R5,             : GET ADDR OF RTE
        JAL     R5,PSEG,R5,             : CALL IT
        J       OSCA40                  :   RETURN HERE IF THRU FOR DEV.
        J       OSCA10                  :   RETURN HERE TO CONTINUE

OSCA40	LHL     R1,OSCA80,,             : RESTORE FLAGS HWORD
        JN      OSCA05                  :   NOT EMPTY - REPEAT
        LHL     RRX,OSCA90,,            : RESTORE FIRST DEV.NO.
        SRHLS   RRX,3                   : CONVERT BACK TO HOWRD INDEX
OSCA50  SIS     RRX,2
        JGE     OSCA00                  : REPEAT FOR EACH HWORD
        RETJ(R5)
 
        SEG     0
OSCA80  HS      1                       : SAVE FLAGS HWORD HERE
OSCA90  HS      1                       : SAVE FIRST DEV.NO. IN HWORD HERE
        SEG     1
 

:       ISCAN - INPUT QUEUE SCANNER
RRX     EQ      R6                      : INDEX TO FLAG HWORD
ISCAN   PUSH(R5)
:       LOOP OVER HALFWORDS OF INPUT DATA PRESENT FLAGS
:       LOOKING FOR DEVICES WITH CMDS IN THEIR QUEUES
        LHI     RRX,(NDEVB-1)*2         : SET UP HWORD INDEX
ISCA10  LHL     R1,INDAT,RRX,           : GET DATA PRES. FLAG HWORD
        NH      R1,INGAT,RRX,           : MASK WITH GATE HWORD
        JE      ISCA50                  :   EMPTY - GO ON TO NEXT HWORD
        STH     R1,ISCA80,,             : SAVE FLAGS HWORD
        SLHLS   RRX,3                   : CONVERT RRX TO FIRST DEV.NO. IN HWORD
        STH     RRX,ISCA90,,            : SAVE IT
ISCA20  JAL     R3,BIDH,,               : FIND FIRST BIT ON
        RBT     R2,ISCA80,,             : TURN OFF THE BIT FOUND
        AH      R2,ISCA90,,             : CONVERT R2 TO DEVICE NO.
        LR      RDEV,R2                 : PUT IN RDEV
        LHL     RDCB,DEVTAB,RDEV,RDEV   :
        LH      R1,DPDEV,RDCB,          : IS PHYS. DEVICE ASSIGNED?
        JL      ISCAN4                  :   N - SKIP FOR NOW
ISCAN1  PKCMD(IN,RDEV,RDEV)
        JE      ISCAN4
ISCAN5
        ADVCMD(IN,RDEV,RDEV)
        CHI     R2,DLYCMD               : DELAY CMD ?
        JN      ISCAN3                  :  N - MOVE IT TO XMT QUEUE
        JAL     R4,SXTIM                : SET XMT TIMER
        RBT     RDEV,INGAT,,            : CLOSE INPUT QUEUE GATE
        J       ISCAN4                  : THRU FOR THIS DEV FOR NOW
ISCAN3  LHL     RDCB,DEVTAB,RDEV,RDEV     : GET DCB ADDR.
        LH      R1,DPDEV,RDCB,          : GET PHYS. DEV. NO.
        JL      ISCAN4
        PUTCMD(XMT,R1,R1)
        RLCMD(XMT,R1,R1)                        : PUT INTO XMT QUEUE
        J       ISCAN1                  : GO ON TO NEXT CMD
ISCAN4
ISCA40  LHL     R1,ISCA80,,             : RESTORE FLAGS HWORD
        JN      ISCA20                  :   NOT EMPTY - REPEAT
        LHL     RRX,ISCA90,,            : RESTORE FIRST DEV. NO.
        SRHLS   RRX,3                   : CONVERT BACK TO HWORD INDEX
ISCA50  SIS     RRX,2
        JGE     ISCA10                  : REPEAT FOR EACH HWORD
        RETJ(R5)
 
        SEG     0
ISCA80  HS      1                       : SAVE FLAGS HWORD HERE
ISCA90  HS      1                       : SAVE FIRST DEV.NO. HERE
        SEG     1
 
 
:       IZAP - DUMMY ROUTINE TO ZAP INACTIVE DEVICE
IZAP    JR      R5
 

:       DOZAP - ZAP A DEVICE
:       INPUT - RDCB
DOZAP   PUSH(R5)
        PUSHM(R13)
        LIS     R0,3
        PUSH(R1)
        LHL     R1,DPORT,RDCB,          : GET PORT NO.
        JE      DOZAP1                  :  IF ZERO DONT SEND ISIS ZAP
        LHL     R0,DUMDCB,,             : GET ADDR OF DUMMY DCB
        STH     R0,PORTAB,R1,R1         : POINT PORT INDEX TO IT
        RBT     R1,PORTUP
        RBT     R1,ACP,,
        LIS     R1,0
        STH     R1,DPORT,RDCB,
DOZAP1  STB     R1,DMODE,RDCB,          : RESET DMODE TO IDLE
        STH     R1,DLFLD,RDCB,          :RESET
        LIS     R6,D.REQ
        RBT     R6,DFLAGS,RDCB,         : RESET REQUEST OUTSTANDING FLAG
        LHL     RDEV,DDEV,RDCB,         : GET DEV. NO.
        RBT     RDEV,DEVBUSY,,          :INDICATES DEVICE IS IDLE
	LIS	R0,0
	STH	R0,SS0SS1,RDEV,RDEV	:CLEAR SAVE STATUS AREA
        PUSH(R3)
        LHI     R3,XMTZAP               :LOG ZAP
        JAL     R5,SUPLOG
        POP(R3)
        TBT     RDEV,DEVPVC,,           :PVC DEVICE?
        JE      DOZAP4                  :N - JUMP
        LB      R6,DMODE,RDCB,          :GET MODE OF DEVICE
        CLHI    R6,LMODE
        JNFS    DOZAP2
        LIS     R5,1                    :FOR LZAP, INCREMENT # OF DEVICES
        AHM     R5,NPVCL,,              : OK TO DO PVC LOGON
        JFS     DOZAP3
DOZAP2
        IF      PVCOP4          :IMMEDIATE LOGON RETRY IF NON-LOGON ZAP
        SBT     RDEV,LOGPVC,,   :NZAP,AZAP...SET BIT TO DO LOGON
        EI
DOZAP3
        IF      PVCOP3
        SBT     RDEV,L2PVC,,            :RETRY LOGON AFTER ELAPSED PVCTIM
        EI
DOZAP4
        LIS     R6,IDMODE
        STB     R6,DMODE,RDCB,          :RESET TO IDLE MODE
        JAL     R4,RLTIM                : RESET LOGON TIMER
        JAL     R4,RIDTIM               : RESET INPUT DATA TIMER
        JAL     R4,RXTIM                : RESET XMT TIMER
        JAL     R5,FLOUT                : FLUSH OUTPUT QUEUE
        JAL     R5,FLINP                : FLUSH PARTIAL INPUT MSG. IF ANY
        JAL     R5,SETOI                : SET OUTPUT ADDRESSES TO INACT.
        TBT     RDEV,DEVPVC,,           :PVC DEVICE?
        JE      DOZAP9                  :N - JUMP
        JAL     R5,RNPVC                :INITIATE PVC LOGON
DOZAP9
        POP(R1)
        POPM(R13)
        RETJ(R5)





: FRESAV - FREE ITEMS ON THE SAVE QUEUE FOR CURRENT DEVICE

FRESAV  PUSH(R5)
FRESA1  PKCMD(SAV,RDEV,RDEV)
        JE      FRESA2
        ADVCMD(SAV,RDEV,RDEV)
        JAL     R5,PBBC,,
        J       FRESA1
FRESA2  RETJ(R5)

:       SEND DETACH MSG TO ISIS
:       INPUT - RDCB
SNDZAP  
        PUSH(R1)
        PUSH(R2)
        PUSH(R3)
        LHL     R1,DPORT,RDCB,          : GET PORT NUMBER
        JE      SNDZ90                  : SKIP IF NO PORT
:
: SEND ADDENDUM TO ACCOUNTING
:       BEFORE LOGON, DZAP IS NORMALLY 0
:       AFTER LOGON, DZAP IS NORMALLY $A20
:
        LB      R0,DZAP,RDCB,           :ANY REASON CDOE FOR DISCONNECT?
        JE      SNDZ10                  :N - JUST SEND DETACH MSG
        LIS     R0,8                    :ADDENDUM TO ACCT MSG LENGTH
        LHI     R2,ADACTG               :ADDENDUM TOACCT MSG CODE
        JAL     R4,SLOR,,               :START MSG
        LIS     R0,0
        JAL     R4,PUTCH,,              :IGNORE 1ST BYTE
        LHI     R0,0E000                :SEND CODE 0E
        JAL     R4,PUTH,,               : AND SUBTYPE 0
        LB      R0,DZAP,RDCB,           :GET REASON CODE
        JAL     R4,PUTH,,               :SEND IT
        JAL     R4,ELOR,,               :END THE MSG
        LIS     R0,0
        STB     R0,DZAP,RDCB,           :RESET REASON CODE
:
: SEND "DETACH" MESSAGE
:
SNDZ10  LIS     R0,3                    : GET MSG. LENGTH
        LHI     R2,DETMSG               : GET DETACH MSG CODE
        JAL     R4,SLOR,,               : START MSG
        JAL     R4,ELOR,,               : END MSG
SNDZ90
        POP(R3)
        POP(R2)
        POP(R1)
        JR      R5

:       SETOI - SET OUTPUT RTE ADDRS TO INACTIVE MODE
:       INPUT - RDEV,RDCB
SETOI   LA      R6,OID-PSEG             : DATA RTE ADDR
        STH     R6,DODRA,RDCB,
        LA      R6,OIC-PSEG             : STL RTE TABLE ADDR
        STH     R6,DOCRA,RDCB,
        SBT     RDEV,OUTGAT,,           : OPEN OUTPUT GATE
        JR      R5
 
:       SETRP - SET RCV RTE ADDRS TO PASS-THRU MODE
:       INPUT - RDCB
SETRP   LI      R6,RDP-PSEG             : DATA RTE ADDR
        STH     R6,DRDRA,RDCB,
        JR      R5

:       ACTIVATION ADDRESS FOR NEEDLE
ACTIVN  JAL     R10,BCRASH 
 
 
:       ACTIV0 - ACTIVATION ADDRESS FOR PORT 0 MSGS
POLMSG  EQ      10              :LAST LEGAL PORT 0 MSG TYPE
ACTIV0  CHI     R2,POLMSG               : LEGAL MSG TYPE ?
        JG      POM30                   :   N - CRASH
        SLHLS   R2,2                    : MAKE R2 INTO INDEX
        J       P0MSG,R2                : PROCESS MSG BY TYPE
 
 
:       P0MSG - JUMP TABLE FOR PORT 0 MSGS
P0MSG   J       POM10                   : TYPE 0
        J       POM10                   : TYPE 1
        J       POM10                   : TYPE 2
        J       POM30                   : TYPE 3
        J       POM30                   : TYPE 4
        J       POM30                   : TYPE 5
        J       POM20                   : TYPE 6
        J       POM30                   : TYPE 7
        J       POM30                   : TYPE 8 
        J       RL09                    : TYPE 9 - UNABLE TO PROVIDE P-N
        J       POM30                   : TYPE A
        J       POM30                   : TYPE B
        J       POM30                   : TYPE C
        J       POM10                   : TYPE D
        J       POM10                   : TYPE E
        J       POM30                   : TYPE F
        J       POM30                   : TYPE 10
 
POM10   JR      R5                      : JUST RETURN
 
POM20                                   : MSG TYPE 6 - GMT
        JAL     R4,GETCH,,              : SKIP CHAR
        JAL     R4,GETW,,               : SKIP GMT
        JR      R5                      : RETURN
 
POM30                                   : GOT WRONG MSG TYPE - CRASH
        JAL     R10,BCRASH 
 
ACTIVT  EQ      .
ACTIVO  EQ      .
PATCH   RE      40
        NOP
        ER
 
 
        SEG     2
TRX     HC      0
TRA     HS      200
TRS     EQ      200

:       RELBP - RELEASES BACK PRESSURE
        SEG     1
:       (IF SET)
RELBP   LHL     R1,DPORT,RDCB,
        JE      TORET,,                 : RETURN IF PORT NOT ASSIGNED
        SBT     R1,FRISIS,,             : SET B.G. FLAG
        JN      TORET,,                 : RETURN IF ALREADY RELEASED
        LHI     R0,3
        LHI     R2,SNDMSG               : SEND REL. B.P. MSG
        JAL     R4,SLOR,,
        JAL     R4,ELOR,,
        J       TORET,,
 
:       SETBP - SETS BACK PRESSURE TO ISIS
SETBP   LHL     R1,DPORT,RDCB,          : GET PORT NO.
        JER     R5                      : RETURN IF PORT NOT ASSIGNED
        RBT     R1,FRISIS,,             : RESET B.P. FLAG
        JER     R5                      : RETURN IF ALREADY SET
        PUSHM(R13)
        LIS     R0,3
        LHI     R2,NOSMSG               : SEND SET B.P. MSG TO ISIS
        JAL     R4,SLOR,,
        JAL     R4,ELOR,,
        POPM(R13)
        JR      R5
 
:       RCV SET B.P. MSG
RSETBP  LHL     RDEV,DDEV,RDCB,         : GET DEVICE NUMBER
        RBT     RDEV,OUTGAT,,           : SHUT OUTPUT GATE
        RBT     R1,TOISIS,,             : RESET PORT B.P. FLAG
        JR      R5
 
:       RRELBP - RCV RELEASE BACKPRESSURE MSG
RRELBP  LHL     RDEV,DDEV,RDCB,         : GET DEVICE NUMBER
        SBT     RDEV,OUTGAT,,           : OPEN OUTPUT GATE
        SBT     R1,TOISIS,,             : SET PORT B.P. FLAG
        JR      R5
 

:       FLINP - FLUSH PARTIAL INPUT MSG
FLINP   PUSH(R5)
        LHL     RBA,DIRBA,RDCB,         : GET CURRENT BUFFER ADR
        JE      FLINP1                  : IF EMPTY ,JUST RETURN
        JAL     R5,PBBC,,               : FREE BUF.
        LIS     RBA,0
        STH     RBA,DIRBA,RDCB,
        STH     RBA,DIFBA,RDCB,         : SET FIRST AND CURR. BUF.=0
FLINP1  RETJ(R5)
 
GOBIN  PUSH(R5)
        LHL     RDEV,DDEV,RDCB,         : GET DEVICE NUMBER
        JAL     R5,FLIN                 : FLUSH INPUT QUEUE
        SBT     RDEV,INGAT,,            : OPEN INPUT GATE
        JAL     R5,FLINP,,
        RETJ(R5)
 
:       BCRASH - CALLED WHEN A CRASH IS DESIRED
:       ALLOWS A 4-BYTE INSTRUCTION TO BE USED
BCRASH  J       CRASH,,         : CRASH
:	GMT TIMEOUT ROUTINES
:	=== ======= ========

:	THESE ROUTINES ARE USED IN CONJUNCTION WITH THE DERR AND RERR
:	COMMANDS IN THE BOM TO TRACK ERRORS.  ERRORS ARE STORED IN
:	BINS, ONE BIN PER EACH HOUR OF DAY PER EACH ERROR TYPE.
:	AT THE START OF A NEW HOUR, THE BINS FOR THAT HOUR ARE CLEARED,
:	THE NEW HOUR IS STORED INTO E.TIM, AND A BIT IS RESET IN THE
:	ARRAY E.SHRT THAT INDICATES THE COUNT FOR THIS HOUR STARTED
:	AT THE BEGINNING OF THE HOUR.

:	IZTMCK - INITIALIZE TH GMT TIMEOUT ROUTINE

IZTMCK	PUSH(R5)
	L	R3,GMT,,		:GET CURRENT GMT
	JL	IZTM10			:GMT IS INVALID!!!
	JAL	R5,CHOUR		:CONVERT TO CURRENT HOUR
	LR	R3,R6			:RANGE CHECK
	JL	IZTM10			:INVALID!!!
	CHI	R6,$A23			:RANGE CHECK
	JG	IZTM10			:INVALID!!!
IZTM05	STH	R6,E.TIM		:STH AS CURRENT HOUR
	LCS	R0,1			:SET ALL HOURS AS NOT FULL
	ST	R0,E.SHRT		:(THAT IS, NOT ICLUDED IN AVERAGE)
:	SCHEDULE TIMEOUT ROUTINE
	L	R1,FASTC,,
	AI	R1,RATE			:DO IT IN ONE SECOND
	LA	R0,TIMCHK		:GET ADDRESS OF ROUTINE
	JAL	R5,TOPUT,,		:PUT ON TIMEOUT RUN LIST
	RETJ(R5)

:	INVALID TIME USE BIN 24
IZTM10	LHI	R6,$A23
	J	IZTM05


:	TIMCHK - GMT TIME CHECK, CHECKS TO SEE IF A NEW HOUR HAS
:	STARTED.  IF SO, THE BINS FOR THE NEW HOUR ARE ZEROED.
:	ALSO CHECKS TO SEE IF ANY BOM TRACE COMMANDS THAT ARE
:	ENABLED NEED TO BE HALTED

TIMCHK	L	R3,GMT,,		:GET CURRENT GMT
	JL	TMCK99			:GMT IS INVALID!!!
	JAL	R5,CHOUR		:CONVERT TO CURRENT HOUR
	LR	R6,R3			:RANGE CHECK
	JL	TMCK99			:INVALID!!!
	CHI	R6,$A23			:RANGE CHECK
	JG	TMCK99			:INVALID!!!
	CH	R6,E.TIM		:HAS TIME CHANGED
	JE	TMCK05			:IF NOT, SKIP AHEAD
	RBT	R6,E.SHRT		:SET HOUR AS STARTING AT BEGINNING
TMCK04	STH	R6,E.TIM		:SET TO NEW HOUR
	LIS	R0,0
	ST	R0,E.PTO,R6,R6		:ZERO BIN FOR EACH ERROR TYPE
	ST	R0,E.RTN,R6,R6
	ST	R0,E.XRR,R6,R6
	ST	R0,E.RRR,R6,R6
	ST	R0,E.NAK,R6,R6

:	LOOK AT TRACE COMMANDS

TMCK05	LCS	R1,1			:SET UP R1 TO DISABLE TRACES
	L	R2,SLOWC,,		:SET UP R2 AS SLOWC

:	LOOK AT CPS TRACE
	LH	R0,CP.ON,,		:IS IT ENABLED
	JLFS	TMCK10			:SKIP AHEAD IF NOT ENABLED
	C	R2,CP.ACT,,		:IS IT TIME TO HALT TRACE
	JLFS	TMCK10			:SKIP AHEAD IF NOT TIME TO HALT
	STH	R1,CP.ON,,		:TURN IT OFF
	ST	R2,CP.FNT,,		:RECORD TIME HALTED
	
:	LOOK AT POLL RESPONSE TRACE
TMCK10	LH	R0,PR.ON,,		:IS IT ENABLED
	JLFS	TMCK15			:SKIP AHEAD IF NOT ENABLED
	C	R2,PR.ACT,,		:IS IT TIME TO HALT TRACE
	JLFS	TMCK15			:SKIP AHAEAD IF NOT TIME TO HALT
	STH	R1,PR.ON,,		:TURN IT OFF
	ST	R2,PR.FNT,,		:RECORD TIME HALTED

:	LOOK AT TIMESTAMP TRACE
TMCK15	LH	R0,ST.ON,,		:IS IT ENABLED
	JLFS	TMCK20			:SKIP AHEAD IF NOT ENABLED
	C	R2,ST.ACT,,		:IS IT TIME TO HALT TRACE
	JLFS	TMCK20			:SKIP AHEAD IF NOT TIME TO HALT
	STH	R1,ST.ON,,		:TURN IT OFF
	ST	R2,ST.FNT,,		:RECORD TIME HALTED
	
:	LOOK AT RESPONSE TIME TRACE
TMCK20	LH	R0,RE.ON,,		:IS IT ENABLED
	JLFS	TMCK25			:SKIP AHEAD IF NOT ENABLED
	C	R2,RE.ACT,,		:IS IT TIME TO HALT TRACE
	JLFS	TMCK25			:SKIP AHEAD IF NOT TIME TO HALT
	STH	R1,RE.ON,,		:TURN IT OFF
	ST	R2,RE.FNT,,		:RECORD TIME HALTED

:	LOOK AT DATA TRACE
TMCK25	LH	R0,DA.ON,,		:IS IT ENABLED
	JL	TMCK30			:IF NOT, SKIP AHEAD
	C	R2,DA.ACT,,		:IS IT TIME TO HALT TRACE
	JLFS	TMCK30			:SKIP AHEAD IF NOT TIME TO HALT
	STH	R1,DA.ON,,		:TURN IT OFF
	STH	R1,DA.ONR,,
	STH	R1,DA.ONX,,
	ST	R2,DA.FNT,,		:RECORD TIME HALTED

:	LOOK AT PROTOCOL TRACE
TMCK30	LH	R0,PT.ON,,		:IS IT ENABLED
	JLFS	TMCK35			:IF NOT SKIP AHEAD
	C 	R2,PT.ACT,,		:IS IT TIME TO HALT TRACE
	JLFS	TMCK35			:SKIP AHEAD IF NOT TIME TO HALT
	STH	R1,PT.ON,,		:TURN IT OFF
	RBT	R0,PTRBIT
	ST	R2,PT.FNT,,		:RECORD TIME HALTED

TMCK35
:	NOW RESCHEDULE TIMEOUT ROUTINE
TMCK50	L	R1,FASTC,,
	AI	R1,RATE*BOMTOR		:RUN AGAIN IN BOMTOR SECONDS
	LA	R0,TIMCHK		:GET ADDRESS OF ROUTINE
	JAL	R5,TOPUT,,		:PUT ON TIMEOUT LIST
	J	TORET,,

:	TIME IS INVALID
TMCK99	LHI	R6,$A24			:USE BIN ZERO FOR ERRORS
	J	TMCK04


:	CHOUR - CONVERTS GMT TO CURRENT HOUR
:	ROUTINE USES SOME CONSTANTS FROM DATE AND TIME CONVERSION
:	ROUTINES IN BOM
:	R3	GMT INPUT, AND RETURNS CURRENT HOUR
:	R5	LINK
	
	GL	SEC745,SECDAY,OURS

CHOUR	S	R3,SEC745,,		:MAKE REL TO 1/1/76
	LIS	R2,0			:CLEAR REG
	D	R2,SECDAY,,		:QUOTIENT IS # OF DAYS
					:REMAINDER IS TIME
	DH	R2,OURS,,		:R3 HAS NUMBER OF HOURS
	JR	R5			:AND RETURN

 
        SUBTTL  NATMOD - NATIVE MODE MODULE

	GL	CP.CNT,CP.LN,CP.ON,DA.RPT,DA.XPT,DA.RST
	GL	DA.RDS,DA.XST,DA.LNK,DA.FRE,DA.TL,DA.HD,DA.ESZ
 
        SEG     1
:       REGISTER USAGE
RSL     EQ      R1              : LINKAGE TO INPUT SUBROUTINE
RRC     EQ      R10             : ISIS RING RECORD COUNT (BYTES REMAINING)
RPKT    EQ      R11             : PACKET COUNT (BYTES REMAINING)
:
:
        LO      FRNTND
        LO      BSCCHR
:
:
 
:       IDN - ISIS INPUT DATA MSG - DEVICE IN NATIVE MODE
IDN     PUSH(R5)
        LHL     RSL,DISRA,RDCB,         
        AI      RSL,PSEG                : MAKE IT ABSOLUTE
        LR      RRC,R2                  : RRC = ISIS MSG CNT
        LHL     RBA,DIRBA,RDCB,         : LOAD BUF. ADDR. , OFFSET AND CNT
        LH      RBX,DIRBX,RDCB,
        LHL     RSUM,DIRCNT,RDCB,
        LH      RPKT,DIPCNT,RDCB,       : LOAD PACKET BYTE CNT
IDN10   JAL     R4,GETCH,,              : GET NEXT CHAR
        JALR    RSL,RSL                 : CALL PROCESSING SUBROUTINE
        SIS     RRC,1                   : REDUCE ISIS MSG CNT
        JG      IDN10                   : REPEAT TO END OF ISIS MSG
 
:       SAVE CONTEXT AND EXIT
        SI      RSL,PSEG                : MAKE SUBRTE. ADDR. RELATIVE
        STH     RSL,DISRA,RDCB,         : SAVE IT
        STH     RBA,DIRBA,RDCB,         : SAVE BUF. ADDR.
        STH     RBX,DIRBX,RDCB,         :      BUF. OFFSET
        STH     RSUM,DIRCNT,RDCB,       :      PARTIAL BUF. CNT
        STH     RPKT,DIPCNT,RDCB,       : SAVE PACKET BYTE COUNT
        RETJ(R5)

:
: GENERATE IIX AND DSP JUMP TABLE FOR TERMINAL INTERFACE
:
IIXLST  GENIIX
:
        GLOIIX(IIXLST,0,GLODIA)         :SELECT DIALECTS
        GLOIIX(IIXLST,2,GLOSMT)         :GATEWAY REACHED SMART HOST
        GLOIIX(IIXLST,3,GLODUM)         :GATEWAY REACHED DUMB HOST
        GLOIIX(IIXLST,4,GLOSTA)          :NORMAL LOGON STATUS
        GLOIIX(IIXLST,5,CLRCIR)         :RESYNCHRONIZE
        GLOIIX(IIXLST,7,GLOREQ)         :REQUEST INTERFACE ID/VERSION
:
        TURIIX(IIXLST,0A,SNDINC)                :INTERRUPT
        TURIIX(IIXLST,12,TURACP)        :CALL ACCEPT
        TURIIX(IIXLST,13,TURLEV)        :TURKEY LEVEL
        TURIIX(IIXLST,15,CLRIND)        :CLEAR INDICATION
        TURIIX(IIXLST,16,CLRCIR)        :RESET INDICATION
:
        DSPIIX(IIXLST,1,INVCLR)         :INVITATION TO CLEAR
        DSPIIX(IIXLST,10,UNDMSG)        :CMD/RES UNDELIVERED
        DSPIIX(IIXLST,11,UNDMSG)        :CMD/RES ABORTED
        DSPIIX(IIXLST,20,DSPENA)        :CIRCUIT ENABLE
        DSPIIX(IIXLST,21,DSPRST)        :CIRCUIT RESET
        DSPIIX(IIXLST,24,CLRCIR)        :CIRCUIT DISCONNECT
        DSPIIX(IIXLST,25,DSPQ0)         :DATA MESSAGE

:
:RECEIVED IMPROPER MESSAGE OR DATA...ZAP CIRCUIT AND FLUSH MSG
:
CLRCIR  PUSH(R1)
        LB      R0,DLFLD,RDCB,          :GET LOGIN STATE
        CHI     R0,L.NAT                :NATIVE MODE?
        JEFS    CLR10                    :Y - JUMP
        JAL     R5,LZAP                 :N - LOGON MODE ZAP
        JFS     CLR20
CLR10   JAL     R5,NZAP                 :NATIVE MODE ZAP
CLR20   LIS     R0,0
        STB     R0,DLFLD,RDCB,          :RESET DCB STATE
        POP(R1)
        J       FSHIIX                  :FLUSH MSG
:
:
: RECEIVED A CLEAR INDICATION...
: IF CLEARING CAUSE 13 AND DIAGNOSTIC CODE 139, THEN INVALID USERNAME
: AND LOGON FAILED.  SHOULD PRINT A MESSAGE ON SCREEN AND THEN
: CLEAR THE CIRCUIT.
:
CLRIND  LHI     R5,DZ.2                 :"DROPPED BY HOST" REASON CODE
        STB     R5,DZAP,RDCB,           :STORE FOR DISCONNECT MSG
        IF      TSTSWT
        J       CLRIND                  :?? LOOP TO SELF FOR NOW
        ELSE
        J       CLRCIR
        EI
:
: RECEIVED AN INVITATION TO CLEAR...
: IF CIRCUIT IS FOR A PERMANENT VIRTUAL CIRCUIT DEVICE, THEN JUST SEND
: A RESET INDICATION (X.25 RESET).  OTHERWISE, CLEAR THE CIRCUIT.
:
INVCLR  J       CLRCIR                  :??TEMPORARY RESPONSE
:??
:?? X.25 PVC IS NOT YET DEFINED, SO FOLLOWING CODE IS NOT USED.
:?? WHEN X.25 PVC IS READY, THEN IN ORDER TO FOLLOW 3270 DSP,
:?? X.25 RESET SHOULD BE SENT (CAUSE AND DIAGNOSTIC CODES
:?? MAY NEED TO BE REDEFINED).
:??
INVCLR  LHL     RDEV,DDEV,RDCB,         :GET DEVICE #
        TBT     RDEV,DEVPVC,,           :IS DEVICE PVC?
        JE      CLRCIR                  :N - CLEAR CIRCUIT
        LA      R6,M.RIND               :Y - SEND RESET INDICATION
        JAL     R5,SNDIIX
        J       FSHIIX
:
: RESET INDICATION CANNED MESSAGE
M.RIND  SC      /"C0"96"03"23/          :CAUSE CODE 03 (REMOTE PROCEDURE ERROR)
                                        :DIAGNOSTIC CODE 23 (INVALID PKT ON PVC)




:
: RECEIVED A RESPONSE UNDELIVERED/ ABORT MESSAGE FROM HOST PAD...
: RECORD TO SUP LOG.   R0 = MESSAGE TYPE (10 OR 11)
:
UNDMSG  LR      R2,R0                   :SAVE MESSAGE TYPE
        JALR    RSL,RSL                 :GET SEQ #
        SIS     R0,1                    :RESET SEQ #
        CLHI    R2,10                   :UNDELIVER OR ABORTED?
        JNFS    UNDMS4
        STB     R0,DOSEQ,RDCB,          :OUTPUT FOR UNDELIVER
        JFS     UNDMS6
UNDMS4  STB     R0,DISEQ,RDCB,          :INPUT FOR ABORT
UNDMS6  JALR    RSL,RSL                 :GET ERROR CODE
        AIS     R2,2
        SLLS    R2,8                    :MAKE MESSAGE TYP EITHER 12 OR 13
        OR      R2,R0                   :COMBINE MESSAGE TYPE WITH ERROR CODE
        LR      R3,R2                   :PASS ERROR CODE TO SUP
        JAL     R5,SUPLOG
        LIS     R3,0
        J       SNDFAC

: SUPLOG

: THIS ROUTINE IS TO SEND LINE ADR., CU ADR, DV ADR., AND ERROR CODE 
: TO THE SUPERVISOR LOG.   THE ERROR CODE IS DERIVED FROM THE DSP ERROR 
: CODE IN THE FOLLOWING MANNER:
:
:                               ORIGINAL        INPUT        OUTPUT
:       THIS PAD   XMT ----->   10XX     ----->  10XX  -----> 00-3F
:                  RCV ----->   11XX     ----->  11XX  -----> 40-7F
:       HOST PAD   XMT ----->   10XX     ----->  12XX  -----> 80-BF
:                  RCV ----->   11XX     ----->  13XX  -----> C0-FF

: WHERE ORIGINAL IS THE ERROR CODE AS DEFINED BY DSP, INPUT IS THE CODE
: USED AS INPUT TO THIS ROUTINE, AND OUTPUT IS THE CODE SENT TO THE
: SUPERVISOR LOG.
:
: LOG READ OUT: ERROR  LINE  CU  DV
:
: REGISTER USAGE:
:          R5   LINK
:          R3   INPUT ERROR CODE
:          R0   WORK
:
SUPLOG  PUSH(R5)
        LHI     R5,LOGSWT                       :IS SWITCH ON?
        JE      SUPLO8                          :SKIP IF NOT
        PUSH(R3)
        PUSH(R2)
        PUSH(R1)
        LHL     R5,DDEV,RDCB,                   :DEVICE NUMBER
        SLLS    R5,2
        LB      R0,DEVLA,R5,                     :LINE ADR.
        STB     R0,M.SUP+6,,
        LB      R0,DEVLA+1,R5,                   :CU ADR
        STB     R0,M.SUP+3,,
        LB      R0,DEVLA+2,R5,
        STB     R0,M.SUP+4,,                    :STORE DEV. ADR.
        EXBR    R0,R3
        NHI     R0,0F
        SLLS    R0,6
        NHI     R3,3F
        AR      R0,R3
        STB     R0,M.SUP+5,,                    :STORE ERROR CODE
        LIS     R2,0
        LA      R3,M.SUP,,
        JAL     R5,OCM,,
        POP(R1)
        POP(R2)
        POP(R3)
SUPLO8  RETJ(R5)
:
        SEG     0
M.SUP   BC      7
        BC      3,0,0FF,0FF,0FF,0FF,PRODID              :SUP MESSAGE
        SEG     1





:
: SELECT DIALECTS (IIX CODE 8080)
:
: COLLECT A LIST OF DIALECTS AND SET CORRESPONDING BIT IN DCB
:
GLODIA  JALR    RSL,RSL                 :GET LEFT BYTE OF CODE
        EXBR    RPKT,R0                 :SHIFT BYTE LEFT 8 BITS
        JALR    RSL,RSL                 :GET RIGHT BYTE OF CODE
        OR      RPKT,R0                 :FORM THE DIALECT CODE
        SHI     RPKT,D.BASE             :GET DIALECT INDEX
        NI      RPKT,0FFFF              :MASK OUT UNWANTED BITS
        IF      TSTSWT
        CLHI    RPKT,D.MAX  :??? SHOULD BE BETWEEN 0 - 3
        JGEBS    .       :??? IF BAD, LOOP TO ITSELF
        EI
        CLHI    RPKT,D.MAX              :DIALECT WITHIN RANGE?
        JGE     GLODIA                  :N-DISCARD IT AND GET NEXT ONE
        LB      RPKT,DIAPTY,RPKT        :TRANSLATE INTO PRIORITIZE DIALECT
        SBT     RPKT,DIABIT,RDCB,       :SET DIALECT BIT
        J       GLODIA                  :GO GET NEXT DIALECT
:
P.ASC   EQ      2                       :8081 ASCII
P.GAT   EQ      0                       :8082 GATEWAY
P.X25   EQ      3                       :8083 X25
P.DSP   EQ      1                       :8084 DSP
: DIALECT PRIORITY TABLE
: (PRIORITIES MUST CORRESPOND TO APPROPRIATE ENTRIES IN DIATBL)
DIAPTY  BC      P.ASC,P.GAT,P.X25,P.DSP

:
: RECEIVED AN IIX NORMAL LOGON MESSAGE (84)
:
GLOSTA  JALR    RSL,RSL                 :GET STATUS BYTE
        PUSH(RSL)
        NHI     R0,LOGSTA               :ISOLATE STATUS CODE
        CLHI    R0,1                    :RECEIVED A "PLEASE LOG IN"?
        JN      GLOS20                  :N - JUMP
:
: RECEIVED A "PLEASE LOG IN" FOR A GATEWAY LOGON
:
        LHI     R5,L.USER
        STB     R5,DLFLD,RDCB,          :SET USERNAME MODE
        LIS     R5,D.STOR
        TBT     R5,DFLAGS,RDCB,         :STORED LOGON MODE?
        JEFS    GLOS10                  :N - JUMP
        JAL     R5,NXTSC                :INSURE NEW ELEMENT
        LIS     RBX,0                   :RESET CHAR INDEX
        STH     RBX,DLRBX,RDCB,
        JAL     R5,SNLFB                :SEND USERNAME
        J       GLOS30
: MANUAL GATEWAY LOGON
GLOS10  LIS     R5,D.ERR
        RBT     R5,DFLAGS,RDCB,         :DID WE JUST GET A HOST ERROR?
        JN      GLOS20                  :Y - TREAT AS USERNAME ERROR
        LIS     R0,LOGROW               :ROW # FOR NEXT LOGON MSG
        STB     R0,DLROW,RDCB,          :STORE IT
        LA      R0,SNLFA-PSEG,,
        STH     R0,DODRA,RDCB,          :OUTPUT ROUTINE TO RECEIVE LOGON
        LHL     RDEV,DDEV,RDCB,         :GET DEVICE NUMBER
        JAL     R4,SLTIM                       :SET LOGON TIMER
        JAL     R5,FLOUT                :FLUSH OUTPUT QUEUE
        SBT     RDEV,INGAT,,            :SET INPUT GATE
        SBT     RDEV,OUTGAT,,           :SET OUTPUT GATE
        JFS     GLOS30
:
: RECEIVE STATUS OTHER THAN "PLEASE LOG IN"
:
GLOS20  JAL     R5,RLNLB                :PROCESS ERROR LOGON STATUS
:
:EXIT
:
GLOS30  LHL     RBA,DIRBA,RDCB,         :RESTORE REGISTERS FOR IDN
        LH      RBX,DIRBX,RDCB,         :(NOW RBA=0 IF CIRCUIT ZAPPED)
        LHL     RSUM,DIRCNT,RDCB,
        POP(RSL)
        J       STEXTZ                  :TO ECHO USERNAME FROM GATEWAY

:
: RECEIVED A "GATEWAY REACHED DUMB HOST" GLOBAL IIX MSG (83)
:
GLODUM  LIS     R0,D.GATE               :GATEWAY LOGIN MODE?
        RBT     R0,DFLAGS,RDCB,         :Y - RESET BIT
        JE      GLOD20                  :N - JUMP
        LHI     R0,L.OK
        STB     R0,DLFLD,RDCB,          :LOGON COMPLETE...SET MODE
        LHL     RDEV,DDEV,RDCB,         :GET DEVICE NUMBER
        JAL     R4,RLTIM                :RESET LOGON TIMER
        PUSH(RSL)
        JAL     R5,ENTASC               :ENTER ASCII MODE
        LHL     RBA,DIRBA,RDCB,         :CLEARED IN ENTASC, REQUIRED FOR EXIT
        POP(RSL)
GLOD20  J       STEXTZ

:
: RECEIVED A "GATEWAY REACHED A SMART HOST" GLOBAL IIX MSG (82)
:
GLOSMT  LIS     R0,D.GATE               :GATEWAY LOGIN MODE?
        RBT     R0,DFLAGS,RDCB,         :Y - RESET BIT
        JE      GLOSM8                  :N - EXIT
        LIS     R0,0
        ST      R0,DIABIT,RDCB,         :CLEAR DIALECT BIT ARRAY
        LHI     R0,L.DIA
        STB     R0,DLFLD,RDCB,          :"WAIT FOR DIALECTS" MODE
        LHL     RDEV,DDEV,RDCB,          
        JAL     R4,RLTIM                :RESET LOGON TIMER
        JAL     R5,FLOUT                :FLUSH OUTPUT QUEUE
        PUSH(RSL)
        JAL     R5,IEND                 :END ANY USERNAME ECHO MSG
        POP(RSL)
GLOSM8  J       STEXTZ

:
: RESPONDING TO A TIIX
:
: IF "WAITING FOR DIALECTS", THEN SELECT A DIALECT 
:
TIIX00  LB      R0,DLFLD,RDCB,          :GET STATE OF THE DCB
        CHI     R0,L.DIA                :IS IT WAIT FOR DIALECT SELECT?
        JNR     R5                      :N - RETURN
        AIS     R0,1                    :Y - INCREMET STATE NUMBER
        STB     R0,DLFLD,RDCB,          :STORE "RECEIVED TIIX"
        LI      R6,STEXT-PSEG           :ADR TO HANDLE SUP TEXT
        STH     R6,DISRA,RDCB,          :RESET DISPATCHER 
        L       R6,DIABIT,RDCB,         :GET DIALECT LIST
        JFFO    R6,TIIX10               :GET LEFT-MOST DIALECT
        J       LZAP                    :IF NO DIALECTS, ZAP THE CIRCUIT
TIIX10  RBT     R7,DIABIT,RDCB,         :DELETE DIALECT FROM LIST
        LHL     R6,DIATBL,R7,R7         :INDEX INTO DIALECT JUMP TABLE
        J       PSEG,R6,                :EXECUTE FOR SELECTED DIALECT
:
: JUMP TABLE FOR DIALECTS
: (CORRESPONDS TO PRIORITIES OF DIALECTS)
:
DIATBL  HC      DIAGAT-PSEG             :GATEWAY
        HC      DIADSP-PSEG             :DSP
        HC      DIAASC-PSEG             :ASCII
        HC      DIAX25-PSEG             :X25
:
: X25 DIALECT IS SELECTED...CLEAR THE CALL
:
DIAX25  PUSH(R5)
        JAL     R5,LZAP
        RETJ(R5)

:
: ASCII DIALECT IS SELECTED...ENTER ASCII MODE
:
DIAASC  PUSH(R5)
        L       R7,DIABIT,RDCB,         :ANY OTHER DIALECTS CONTENDING?
        JEFS    DIAA10                  :N - JUMP
        LA      R6,M.ASC                :Y - SELECT ASCII DIALECT
        JAL     R5,SNDIIX
DIAA10  JAL     R5,ENTASC               :ENTER ASCII MODE
        RETJ(R5)
:
:
M.ASC   SC      /"80"81"80"81/          :SELECT ASCII DIALECT

:
: GATEWAY DIALECT IS SELECTED...SET UP GATEWAY LOGON SEQUENCE
:
DIAGAT  PUSH(R5)
        LIS     R0,D.STOR
        TBT     R0,DFLAGS,RDCB,         :IS IT STORED LOGON MODE?
        JN      DIAG10                  :Y - JUMP
        LA      R1,LOGSCN
        JAL     R5,XLERM                :DISPLAY LOGON SCREEN
        LIS     R0,0                    :ROW 0 
        STB     R0,DLROW,RDCB,          : FOR GATEWAY INTERLINK MSG
DIAG10  LHI     R0,L.GATE
        STB     R0,DLFLD,RDCB,          :WAITING FOR GATEWAY INTERLINK MSG
        LIS     R0,D.GATE
        SBT     R0,DFLAGS,RDCB,         :GATEWAY LOGON MODE
        RETJ(R5)

:
: DSP DIALECT IS SELECTED...CHECK IF ALSO ASCII AND DISPLAY DSP SCREEN
:       (IF STORED LOGON MODE, JUMP TO DSP100 TO PROCESS DSP DATA)
:
DIADSP  PUSH(R5)
        JAL     R5,IEND                 :END ANY PENDING MSG
        LA      R0,FSHIIX-PSEG
        STH     R0,DISRA,RDCB,          :FLUSH ANY FURTHER SUP MSG
        LHI     R0,L.DSP
        STB     R0,DLFLD,RDCB,          :SET "WAIT FOR DSP" STATE
        LIS     R0,D.STOR
        TBT     R0,DFLAGS,RDCB,         :STORED LOGON MODE?
        JN      DSPSTO                  :Y - PROCESS DSP DATA
        LI      R6,DSPDAT-PSEG          :GET ADR TO RECEIVE DSP DATA
        STH     R6,DODRA,RDCB,          :SET IT TO OUTPUT RTE
        IF      DSPSCN                  : IF DSPSCN, THEN DISPLAY DSP SCREEN
        LA      R1,SCNDSP               :GENERAL DSP SCREEN
        JAL     R5,XLERM                :SEND IT TO PHYS DEVICE
        LHI     R0,10                   :ROW AFTER DSP SCREEN
        LHL     RDEV,DDEV,RDCB,         :GET DEVICE #
        TBT     RDEV,DEVCOL,,           :IS IT A 3279 W/COLOR?
        JEFS    DSP10                   :N - JUMP
        LA      R1,DSPCOL               :MSG TO ASK FOR COLOR
        JAL     R5,XLERM                :SEND MESSAGE
        LHI     R0,12                   :ROW # TO NEXT LOGON TEXT
DSP10   STB     R0,DLROW,RDCB,          :GET ROW FOR NEXT LOGON TEXT
        LHI     R0,P.ASC                :CHECK IF ASCII DIALECT ALSO OK
        RBT     R0,DIABIT,RDCB,         :RESET ASCII DIALECT BIT
        JEFS    DSP20                   :IF NO ASCII,JUMP
        LA      R1,DSPASC               :IF ASCII OK ALSO
        JAL     R5,XLERM                :THEN ASK USER IF ASCII OR DSP
        LHI     R0,L.ASC                :SET "WAIT FOR ASC OR DSP"
        STB     R0,DLFLD,RDCB,          :STORE  STATE IN DCB
DSP20   LHL     RDEV,DDEV,RDCB,           :GET DEVICE # (RDEV=RPKT)
        JAL     R4,SLTIM                :SET TIMER
        SBT     RDEV,INGAT,,              :OPEN INPUT GATE
        SBT     RDEV,OUTGAT,,             :OPEN OUTPUT GATE
        RETJ(R5)
:       NOT DISPLAY DSP SCREEN
        ELSE
        LIS     R5,3
        STB     R5,DCRM,RDCB,           :CRM = 3
        LIS     R5,0
        STB     R5,DNDIG,RDCB,
        STB     R5,DAPPL,RDCB,
        STB     R5,DCUA,RDCB,
        STB     R5,DDVA,RDCB,
        LHL     RDEV,DDEV,RDCB,
        SBT     RDEV,OUTGAT
        SBT     RDEV,INGAT
:       SEND SELECT DSP (8084) CODE
        LA      R6,M.DSP
        JAL     R5,SNDIIX
:       SEND TURKEY LEVEL
        LA      R6,M.TURL
        JAL     R5,SNDIIX
        JAL     R4,SLTIM                :USE LOGON TIMER
        LHI     R0,L.TURL               :"WAIT FOR TURKEY LEVEL"
        STB     R0,DLFLD,RDCB,
        JAL     R5,FLOUT
        RETJ(R5)
        EI

:
: GET DATA FROM DSP SCREEN 
:
DSPDAT  PUSH(R5)
        LB      R7,BBUFER+3,RBA,        :GET AID CHAR
        CHI     R7,AIDCLR               :CLEAR KEY?
        JE      DSPDA9                  :Y - ZAP CIRCUIT
        LB      R7,DLFLD,RDCB,          :N - GET LOGON STATE
        CHI     R7,L.DSP                :WAITING FOR RESPONSE TO DSP SCREEN?
        JE      DSP105                  :Y - GO TO DSP MODE
        CHI     R7,L.ASC                :WAITING FOR DSP OR ASCII?
        JE      DSP100                  :Y - CHECK IF ASCII IS DESIRED
DSPDA9  JAL     R5,LZAP                 :N - WRONG STATE...ZAP
        RETJ(R5)
:
: ENTRY FOR PROCESSING DSP SCREEN DATA IN STORED LOGON MODE
:
DSPSTO  LHL     RDEV,DDEV,RDCB,         :GET DEVICE NUMBER
        SBT     RDEV,INGAT,,            :OPEN INPUT GATE
        SBT     RDEV,OUTGAT,,           :OPEN OUTPUT GATE
        JAL     R5,NXTSC                :INSURE NEW ELEMENT
        LIS     RBX,0                   :RESET CHAR INDEX
        STH     RBX,DLRBX,RDCB,         
:
: ASKING ASCII OR DSP MODE...LOOK FOR A "Y" FOR ASCII
:
DSP100  PUSH(R14)
        LB      R13,DSPL0               :ADR WHERE ANSWER IS LOCATED
        LB      R14,DSPL0+1
        LHL     R4,DLGET,RDCB,          :GET ROUTINE ADR
        JAL     R4,PSEG,R4,                     :GET THE FIRST CHAR IN FIELD
        CHI     R5,Y.                   :IS IT A "Y"?
        JNFS    DSP105                  :N - JUMP
        LHL     RDEV,DDEV,RDCB,         :GET DEVICE NUMBER
        JAL     R4,RLTIM                :TURN OFF LOGON TIMER
        JAL     R5,DIAASC               :SELECT ASCII MODE
        J       DSP180
:
: DSP MODE...WHETHER ONLY CHOICE OR SELECTED BY USER
:
: GET CRM #
DSP105  LB      R13,DSPL1               :ADR TO CRM #
        LB      R14,DSPL1+1
        LHL     R4,DLGET,RDCB,          :GET ROUTINE ADR
        JAL     R4,PSEG,R4,                     :GET CRM #
        SHI     R5,N0.                  :CONVERT TO DECIMAL DIGIT
        JLE     DSPAGN                  :VERIFY VALID CRM #
        CLHI    R5,MAXCRM
        JG      DSPAGN
        CLHI    R5,4                    :CRM 4 (PRINTER)?
        JNFS    DSP108                  :N - JUMP
        TBT     RDEV,DEVBUSY,,          :IS CRT LOGGED IN?
        JE      DSPAGN                  :N - ERROR
DSP108  STB     R5,DCRM,RDCB,           :STORE CRM #
: GET DESTINATION INTERFACE ADDRESS
        LB      R13,DSPL2               :ADR TO DEST. INTERFACE ADR
        LB      R14,DSPL2+1
        LIS     R7,0                    :SET ADR COUNTER IN BYTES
DSP110  LHL     R4,DLGET,RDCB,          :GET ROUTINE ADR
        JAL     R4,PSEG,R4,                     :GET CHAR OF ADR
        LB      R6,EBCASC,R5            :SET COND. CODE
        JE      DSP130                  :END OF ADR IF CONTROL CHAR
        CLHI    R6,A9.                  :CHAR IS A DIGIT?
        JG      DSPAGN                  :N - GET ANSWER AGAIN
        SHI     R6,A0.
        JL      DSPAGN
        SLLS    R6,4                    :PUT DIGIT TO LEFT NIBBLE
        LHL     R4,DLGET,RDCB,          :GET ROUTINE ADR
        JAL     R4,PSEG,R4,                     :GET NEXT CHAR
        LB      R0,EBCASC,R5            :CONVERT TO ASCII
        JE      DSP120                  :END OF ADR IF CONTROL CHAR
        CLHI    R0,A9.                  :CHAR IS A DIGIT?
        JG      DSPAGN                  :N - GET ANSWER AGAIN
        SHI     R0,A0.                  
        JL      DSPAGN
        OR      R6,R0                   :COMBINE 2 DIGITS TO A BYTE
        STB     R6,DDEST,RDCB,R7        :STORE ADR
        AIS     R7,1                    :INCREMENT ADR BYTE COUNT
        J       DSP110                  :GET NEXT CHAR IF NOT FINISHED
: CALCULATE # OF DIGITS IN DEST. INTERFACE ADR (CALLED ADDRESS)
DSP120  STB     R6,DDEST,RDCB,R7        :STORE ODD ADR
        LR      R6,R7                   :CALCULATION FOR AN ODD # OF DIGITS
        SLLS    R6,1
        SIS     R6,1
        JFS     DSP135
DSP130  LR      R6,R7                   :CALCULATION FOR AN EVEN # OF DIGITS
        SLLS    R6,1
DSP135  STB     R6,DNDIG,RDCB,  :STORE # OF DIGITS OF CALLED ADR
: FINISHED WITH DESTINATION INTERFACE ADDRESS
        LIS     R6,0
DSP140  CHI     R7,7                    :FILL WITH ZEROS IF ADR
        JGEFS   DSP150                  :IS LESS THAN 14 DIGITS
        STB     R6,DDEST,RDCB,R7
        AIS     R7,1
        JBS     DSP140
DSP150  LHI     R0,D.WILD                 : INIT "WILD" BIT
        SBT     R0,DFLAGS,RDCB,
: GET APPLICATION IDENTIFIER
        LB      R13,DSPL3               :ADR TO APPLICATION ID
        LB      R14,DSPL3+1
        LHL     R4,DLGET,RDCB,
        JAL     R4,PSEG,R4,                     :GET APPLICATION ID
        LB      R6,EBCASC,R5            :CONTROL CHAR?
        JNFS    DSP153                  :N - STORE IT
        LIS     R5,0                    :Y - STORE 0
        JFS     DSP155
DSP153  LHI     R13,D.WILD                :GET "WILD" BIT
        RBT     R13,DFLAGS,RDCB,        :HOST DOES NOT SELECT THIS ADR
DSP155  STB     R5,DAPPL,RDCB,  :STORE INTO DCB AS EBCDIC
: GET DESTINATION CONTROL UNIT
        LB      R13,DSPL4               :ADR TO DEST CU ADR
        LB      R14,DSPL4+1
        LHL     R4,DLGET,RDCB,
        JAL     R4,PSEG,R4,                     :GET DEST CU ADR
        LB      R6,EBCASC,R5            :CONTROL CHAR?
        JNFS    DSP158                  :N - STORE IT
        LIS     R5,0                    :Y - STORE 0
        JFS     DSP160
DSP158  LHI     R13,D.WILD                :GET "WILD" BIT
        RBT     R13,DFLAGS,RDCB,        :HOST DOES NOT SELECT THIS ADR
DSP160  STB     R5,DCUA,RDCB,   :STORE INTO DCB AS EBCDIC
: GET DESTINATION DEVICE ADDRESS
        LB      R13,DSPL5               :ADR TO DSEST DEVICE ADR
        LB      R14,DSPL5+1
        LHL     R4,DLGET,RDCB,
        JAL     R4,PSEG,R4,                     :GET DEST DEVICE ADR
        LB      R6,EBCASC,R5            :CONTROL CHAR?
        JNFS    DSP165                  :N - STORE IT
        LIS     R5,0                  :Y - STORE 0
        JFS     DSP170
DSP165  LHI     R13,D.WILD                :SET WILD BIT
        RBT     R13,DFLAGS,RDCB,        :HOST DOES NOT SELECT THIS ADR
DSP170  STB     R5,DDVA,RDCB,   :STORE INTO DCB AS EBCDIC
: GET ANSWER TO TRANSPARENCY (DEFAULT IS "YES")
        LHL     RDEV,DDEV,RDCB,         :GET DEVICE #
        TBT     RDEV,DEVXPR,,           :CAN DEVICE HANDLE TRANSPARENCY?
        JE      DSP173                  :N - JUMP
        LB      R13,DSPL6               :ADR TO XPR ANSWER
        LB      R14,DSPL6+1
        LHL     R4,DLGET,RDCB,          :GET ROUTINE ADR
        JAL     R4,PSEG,R4,             :GET ANSWER
        CHI     R5,N.                   :IS IT A "NO"?
        JEFS    DSP173                  :Y - JUMP
        LIS     R0,D.XPR                :"XPR REQUESTED"
        SBT     R0,DFLAGS,RDCB,         :SET BIT FOR TRANSPARENCY MODE
: GET ANSWER TO COLOR (DEFAULT IS "YES")
DSP173  LIS     R0,0                    :INIT DEVICE NOT WANTING COLOR
        STB     R0,DATTR,RDEV,
        TBT     RDEV,DEVCOL,,           :CAN DEVICE HANDLE COLOR?
        JE      DSP175                  :N - JUMP
        LB      R13,DSPL7               :ADR TO COLOR ANSWER
        LB      R14,DSPL7+1
        LHL     R4,DLGET,RDCB,          :GET ROUTINE ADR
        JAL     R4,PSEG,R4,             :GET ANSWER TO COLOR
        CHI     R5,N.                   :IS IT A "NO"?
        JEFS    DSP175                  :Y - JUMP
        LHI     R0,.COLOR               :"COLOR REQUESTED"
        STB     R0,DATTR,RDEV,          :SET BIT TO REQUEST COLOR
: SEND SELECT DSP (8084) CODE
DSP175  LA      R6,M.DSP                :ADR TO DSP MSG
        JAL     R5,SNDIIX               :SEND THE MSG
: SEND TURKEY LEVEL
        LA      R6,M.TURL               :ADR TO TURKEY LEVEL MSG
        JAL     R5,SNDIIX               :SEND THE MSG
:SET TIMER AND GO INTO "WAIT FOR TURKEY LEVEL" STATE
        JAL     R4,SLTIM                :USE LOGON TIMER
        LHI     R0,L.TURL               :"WAIT FOR TURKEY LEVEL"
        STB     R0,DLFLD,RDCB,
:
: EXIT
:
DSP180  JAL     R5,FLOUT                :FLUSH OUTPUT QUEUE
        POP(R14)
        RETJ(R5)
:
:
: IIX MESSAGES
:
M.DSP   SC      /"80"81"80"84/          :SELECT DSP MSG
M.TURL  SC      /"C0"93"00"01/          :TURKEY LEVEL OF 1 MSG
:
: USER TYPE BAD DATA FOR DSP SCREEN
:
DSPAGN  LIS     R0,D.STOR
        TBT     R0,DFLAGS,RDCB,         :STORED LOGON MODE?
        JN      DSPAG2                  :Y - JUMP
        JAL     R5,DIADSP               :RE-DISPLAY DSP SCREEN
        JFS     DSPAG4
DSPAG2  LA      R1,LEM7,,               :"BAD STORED LOGON STRING"
        JAL     R5,PUTADR               :INSERT ROW ADDDRESS
        JAL     R5,XLERM                :DISPLAY IT
        JAL     R5,LZAP                 :ZAP THE CIRCUIT
DSPAG4  J       DSP180

:
: RECEIVED A "TURKEY LEVEL" IIX MESSAGE (93)
:
TURLEV  LB      R0,DLFLD,RDCB,          :GET STATE
        CLHI    R0,L.TURL               :IS IT "WAIT FOR TURKEY LEVEL"?
        JN      FSHIIX                  :N - FLUSH MESSAGE
        JALR    RSL,RSL                 :DISCARD LEFT BYTE OF TURKEY LEVEL
        JALR    RSL,RSL                 :GET RIGHT BYTE OF CODE
        CLHI    R0,1                    :SHOULD BE LEVEL 1
        JN      CLRCIR                  :IF NOT, ZAP THE CIRCUIT
:SEND CALLED ADDRESS
        LIS     R6,0                    :COPY CALLED ADR INTO MSG BUFFER
        LB      R0,DNDIG,RDCB,
        STB     R0,M.CALL+3,,
        JEFS    DSP210
DSP200  LB      R0,DDEST,RDCB,R6
        STB     R0,M.CALL+4,R6,
        AIS     R6,1
        CLHI    R6,7                    :1/# OF DIGITS,7/ADR DIGITS
        JLBS    DSP200
DSP210  LA      R6,M.CALL,,             :ADR TO CALLED ADR MSG
        JAL     R5,SNDIIX               :SEND THE MSG
: SEND CALLING ADDRESS
        LIS     R6,0                    :COPY CALLING ADR INTO MSG BUFFER
DSP220  LB      R0,CALADR,R6,
        STB     R0,M.CLNG+3,R6,
        AIS     R6,1
        CLHI    R6,8                    :1/# OF DIGITS,7/ADR DIGITS
        JLBS    DSP220
        LA      R6,M.CLNG,,             :ADR TO CALLING ADR MSG
        JAL     R5,SNDIIX               :SEND THE MSG
: SEND FACILITY
        LA      R6,M.FAC,,
        JAL     R5,SNDIIX
: SEND CALL USER DATA
CUDSZ   EQ      $A16                    :SIZE OF CALL USER DATA FIELD
        LHI     R0,PID.TI               :PROTOCOL ID
        STB     R0,M.CUD+4,,
        LHL     R6,DDEV,RDCB,           :GET DEVICE NUMBER
        LR      R5,R6
        SLLS    R5,2                    :MAKE FULLWORD INDEX
        LB      R0,DEVLA+1,R5,          :SOURCE CONTROL UNIT ADR
        STB     R0,M.CUD+5,,
        LB      R0,DEVLA+2,R5,          : SOURCE DEVICE ADR
        STB     R0,M.CUD+6,,
        LB      R0,DTYPE,R6,            :DEVICE FORMAT SIZE & TYPE
        LIS     R5,D.XPR
        TBT     R5,DFLAGS,RDCB,         :USER REQUESTED TRANSPARENCY?
        JEFS    DSP230                  :N - JUMP
        OHI     R0,XPRBIT^-8            :Y - SET BIT TO INDICATE SO
DSP230  STB     R0,M.CUD+7,,
        STB     R0,DLA,RDCB,            :STORE FOR LATER COMPARISON
        LB      R0,DATTR,R6,            :OTHER DEVICE ATTRIBUTES
        STB     R0,M.CUD+8,,
:
:       CRM 1  <=  PHYSICAL ADR MATCH LOGICAL ADR
:       CRM 2  <=  ALL ADDRESSES MUST BE SPECIFIED
:	CRM 3  <=  SOME ADDRESS MAY BE "WILD"
:       CRM 4  <=  ASSOCIATED DEVICE LOGON
:
        LB      R6,DCRM,RDCB,           :GET CRM #
        STB     R6,M.CUD+9,,            :STORE INTO MSG
        SIS     R6,1                    :ADJUST INDEX TO JUMP TABLE
        LHL     R5,DSPCRM,R6,R6         :GET ROUTINE ADR
        J       PSEG,R5,                :JUMP TO APPROPRIATE CRM HANDLER
:
DSPCRM  HC      DSP250-PSEG             :CRM 1
        HC      DSP260-PSEG             :CRM 2
        HC      DSP260-PSEG             :CRM 3
        HC      DSP280-PSEG             :CRM 4
:
: CRM 1
DSP250  LB      R0,DAPPL,RDCB,  :APPLICATION ID
        STB     R0,M.CUD+0A,,
        LIS     R6,7                    :START INDEX TO FILL W/ ZEROS
        J       DSP290
:
: CRM 2,3
DSP260  LB      R0,DAPPL,RDCB,  :APPLICATION ID
        STB     R0,M.CUD+0A,,
        LB      R0,DCUA,RDCB,   :CUA
        STB     R0,M.CUD+0B,,   
        LB      R0,DDVA,RDCB,   :DVA
        STB     R0,M.CUD+0C,,
        LIS     R6,9                    :START INDEX TO FILL W/ ZEROS
        J       DSP290
:
: CRM 4
DSP280  LIS     R0,0                    :APPL ID = 0
        STB     R0,M.CUD+0A,,   
        STB     R0,M.CUD+0B,,           :DEST CUA = 0
        LB      R0,DDVA,RDCB,   
        STB     R0,M.CUD+0C,,           :DEST DVA FROM SCREEN
: COPY THE ADDITIONAL DESTINATION DESIGNATOR INFORMATION FROM CRT DCB
        LH      R6,DPDEV,RDCB,          :GET CRT DEVICE #
        IF      TSTSWT
        JLBS    .
        ELSE
        JL      CLRCIR                  :SHOULD HAVE VALID CRT DEVICE #
        EI
        LHL     R4,DEVTAB,R6,R6         :GET CRT DCB
        LHL     R7,DPORT,R4,            :CRT SHOULD BE CONNECTED ALREADY
        JE      CLRCIR                  : IN ORDER TO USE CRM 4
        CLR     R4,RDCB                 :DCB'S SHOULD BE DIFFERENT
        IF      TSTSWT
        JEBS    .
        ELSE
        JE      CLRCIR                  :SAME DCB MEANS NO CRT
        EI
        LIS     R6,9                    :START INDEX TO FILL W/ ZEROS
        LB      R7,DSPCNT,R4,           :GET COUNT OF ADD'L INFO
        JEFS    DSP290                  :JUMP IF DONE
        CLHI    R7,4                    :INSURE COUNT W/IN BOUNDS
        IF      TSTSWT
        JGBS    .
        ELSE
        JG      CLRCIR
        EI
DSP285  LB      R0,DSPSAV-9,R4,R6       :GET ADD'L INFO
        STB     R0,M.CUD+4,R6,          :STORE INTO MSG BUFFER
        AIS     R6,1                    :INCREMENT INDEX TO BUFFER
        SIS     R7,1                    :DECREMENT COUNT
        JGBS    DSP285
:
: FILL REST OF CALL USER DATA FIELD WITH ZEROS
DSP290  LIS     R0,0                    :
DSP295  CLHI    R6,CUDSZ                :SIZE OF CALL USER DATA FIELD
        JGEFS   DSP298
        STB     R0,M.CUD+4,R6,
        AIS     R6,1
        JBS     DSP295
DSP298  LA      R6,M.CUD,,              :ADR TO CALL USER DATA MSG
        JAL     R5,SNDIIX               :SEND THE MSG
: SET TIMER AND SET "WAIT FOR CALL ACCEPT" STATE
        LHL     RDEV,DDEV,RDCB,         :GET DEVICE # (RDEV=RPKT)
        JAL     R4,SLTIM                :SET TIMER
        LHI     R0,L.ACP                :SET "WAIT FOR CALL ACCEPT"
        STB     R0,DLFLD,RDCB,
        J       STEXTZ                  :GET ERROR MSG FROM HI (IF ASNSWT=1)
:
:
: IIX MESSAGE BUFFERS
:
        SEG     0
M.CALL  SC      /"C0"87"00"00"00"00"00"00"00"00/        :CALLED ADR MSG
M.CLNG  SC      /"C0"88"00"00"00"00"00"00"00"00/        :CALLING ADR MSG
M.FAC   SC      /"C0"8D"00/                             :FACILITY MSG
M.CUD   BC      CUDSZ+3                         :CALL USER DATA MSG
        BC      0C0,89,10
        BS      CUDSZ
        SEG     1

:
: RECEIVED A "CALL ACCEPT" (92)
:
TURACP  LB      R0,DLFLD,RDCB,          :GET STATE
        CLHI    R0,L.ACP                :"WAIT FOR CALL ACCEPT"?
        JN      FSHIIX                  :N - FLUSH MSG
        LHI     R0,L.ENA                :"WAIT FOR CIRCUIT ENABLE" STATE
        STB     R0,DLFLD,RDCB,          :STORE NEW STATE
        LHL     RDEV,DDEV,RDCB,         :GET DEVICE # (RDEV=RPKT)
        JAL     R4,SLTIM                :SET TIMER
        J       FSHIIX                  :FLUSH MSG
:
: RECEIVED A CIRCUIT ENABLE (94 - 20)
:
DSPENA  LHL     RDEV,DDEV,RDCB,         :GET DEVICE # (RDEV=RPKT)
        JAL     R4,RLTIM                :RESET  TIMER
        LR      R6,RDEV
        SLLS    R6,2                    :MAKE FULLWORD INDEX
        JALR    RSL,RSL                 :GET SOURCE CUA
        CLB     R0,DEVLA+1,R6,          :COMPARE TO CUA SENT
        JN      CLRCIR                  :DIFFERENT - ZAP
        JALR    RSL,RSL                 :GET SOURCE DVA
        CLB     R0,DEVLA+2,R6,          :COMPARE TO DVA SENT
        JN      CLRCIR                  :DIFFERENT - ZAP
        JALR    RSL,RSL                 :GET DEVICE FORMAT SIZE AND TYPE
        CLB     R0,DLA,RDCB,            :COMPARE WITH ONE SENT
        JN      CLRCIR                  :DIFFERENT - ZAP
        JALR    RSL,RSL                 :GET DEVICE ATTRIBUTES
        CLB     R0,DATTR,RDEV,          :COMPARE WITH THOSE SENT
        JN      CLRCIR                  :DIFFERENT - ZAP
        JALR    RSL,RSL                 :GET CRM
	STB	R0,DSPSAV,RDCB,		:SAVE TEMPORARILY FOR LATER

        JALR    RSL,RSL                 :GET APPL ID OF HOST CRT
	STB	R0,DSPAPL,RDCB,		
        JALR    RSL,RSL                 :GET CUA     OF HOST CRT
	STB	R0,DSPCUA,RDCB,
        JALR    RSL,RSL                 :GET DVA     OF HOST CRT
	STB	R0,DSPDVA,RDCB,

	LIS	R0,4			:WAS CRM 4
	CLB	R0,DSPSAV,RDCB,
        JN      DSP305                  :N - DONE

: SAVE ADD'L DEST DESIGNATOR INFORMATION FOR CRM 4
        LR      R6,RRC                  :GET # OF BYTES IN INFOR
        SIS     R6,1                    :EXCLUDE CURRENT CHAR
        STB     R6,DSPCNT,RDCB,         :SAVE # OF ADDL INFO BYTE
        JE      DSP310                  :IF NONE, JUMP
        IF      TSTSWT
        JLBS    .
        ELSE
        JL      CLRCIR                  :IF NEG, THEN ERROR...ZAP
        EI
        LIS     R6,0                    :INDEX TO SAVE AREA
DSP300  JALR    RSL,RSL                 :GET CHAR OF ADD'L INFO
        STB     R0,DSPSAV,RDCB,R6       :SAVE IT IN DCB
        CLHI    RRC,1                   :LAST CHAR?
        JEFS    DSP310                  :Y - JUMP
        AIS     R6,1                    :INCREMENT INDEX
        CLHI    R6,4                    :SHOULD BE 0-4 CHAR ONLY
        JL      DSP300                  :OK - LOOP ATO GET NEXT CHAR
DSPCR   JAL     R10,CRASH,,             :ELSE - WRONG
: ENTER NATIVE MODE
DSP305  LIS     R0,0                    :FOR CRM = 1,2,3
        STB     R0,DSPCNT,RDCB,         : CLEAR COUNT OF ADD'L INFO
DSP310  LHI     R0,L.NAT                :NATIVE MODE
        STB     R0,DLFLD,RDCB,
        LHI     R0,DEVEND               :GET DEVICE END STATUS CODE
        STB     R0,M.STAT+9,,           :STORE SS1
        EXBR    R0,R0
        STB     R0,M.STAT+8,,           :STORE SS0
        LA      R6,M.STAT,,
        JAL     R5,SNDIIX               :SEND DEVICE END STATUS MSG TO HOST
        TBT     RDEV,DEVPVC,,           :WAS THIS A PVC LOGON
        JEFS    DSP315                  :N - JUMP
        LIS     R5,1                    :Y - INCREMENT COUNT TO ALLOW
        AHM     R5,NPVCL,,              :FOR NEXT PVC LOGON
DSP315
        PUSH(RSL)
        PUSH(RBA)
        PUSH(RBX)
        PUSH(RSUM)
        LA      R1,MSG5,,               :CLEAR SCREEN & UNLOCK KEYBOARD MSG
        JAL     R5,XLERM                :SEND MESSAGE TO TERMINAL
        POP(RSUM)
        POP(RBX)
        POP(RBA)
        POP(RSL)
        JAL     R5,ENTNAT               :ENTER NATIVE MODE
        J       FSHIIX                  :FLUSH MESSAGE

:
:
: RECEIVED A DATA PACKET (94, Q=0)
:       BRANCHED FROM DATIIX
:       RPKT = # OF BYTES IN REST OF PACKET
:       R0 = FLAGS (ALREADY STORED IN DFLAGS)
: THE DATA IS A "COMMAND" MSG FROM THE HOST INTERFACE 
: TO BE PASSED TO THE TERMINAL.
: HOWEVER, IT MUST BE CONVERTED TO A BISYNC MSG.
:
:
DSPQ0   LR      RBA,RBA                 : HAS A BISYNC MSG BEEN STARTED
        JN      DSPQ20                  :   Y - SKIP
        JALR    RSL,RSL                 :DISCARD UCN BYTE
        THI     R0,7F                   :UCN = 0?
        JE      DSPQ05                  :Y - SKIP
        PUSH(R3)
        LHI     R3,XMTUCN               :BAD UCN CODE
        JAL     R5,SUPLOG               :REPORT TO SUP
        POP(R3)
        J       SNDDAT                  :SEND INVITATION TO CLEAR
DSPQ05  JALR    RSL,RSL                 : RETURN FOR CONTROL BITS CHAR
        EXBR    R0,R0                   : SHIFT LEFT 8 BITS
        NHI     R0,LCMBIT!ACKBIT!XPRBIT!0FF     :REMOVE UNWANTED BITS
        OHI     R0,FIRBIT               :SET AS FIRST BLOCK
        STH     R0,DIR0,RDCB,           : SAVE CONTROL BITS
        JALR    RSL,RSL                 : RETURN FOR SEQ #
        CLB	R0,DISEQ,RDCB,		: CURRENT SEQ #
        JE      DSPQ10                  :IF SO, CONTINUE
: OUT OF SEQUENCE...
: IF "C/R UNDELIVERED" WAS JUST SENT, THEN FLUSH UNTIL WE GET BACK INTO
: SEQUENCE, ELSE WE JUST GOT A BAD DATA PACKET, SO CLEAR CIRCUIT.
        PUSH(R3)
        LHI     R3,XMTSEQ               :REPORT MESSAGE OUT OF SEQUENCE
        JAL     R5,SUPLOG
        POP(R3)
        LHI     R6,D.UND
        TBT     R6,DFLAGS,RDCB,
        JN      FSHIIX
        J       SNDDAT
: DATA IN SEQUENCE...CONTINUE
DSPQ10  LHI     R6,D.UND
        RBT     R6,DFLAGS,RDCB,         :RESET FLUSHING MODE
        SIS     RPKT,3                  : REDUCE PACKET CNT

:	TIMESTAMP RECEIPT OF STX IN IRING
	LH	R6,ST.ON,,		:ARE WE TIMESTAMPING
	JLFS	DSPQ11			:IF NOT, SKIP AHEAD
	CH	R6,DDEV,RDCB,		:IS THIS THE RIGHT DEVICE
	JNFS	DSPQ11			:IF NOT, SKIP AHEAD
	LB	R5,ST.DSP+1,,		:GET DISPLACEMENT
	L	R6,FASTC,,		:GET CURRENT TIME IN FASTC
	ST	R6,ST.ST4,R5,		:AND SAVE TIME

: DETERMINE NORMAL/TRANSPARENCY MODE AND GET BUFFER
DSPQ11	THI     R0,XPRBIT               :TRANSPARENCY MODE?
        JN	DSPQ16                  :Y - JUMP
       
:	DATA TRACE - WRITE IN RECEIVE CODE AND STX IF TRACING
	LH	R5,DA.ON,,		:ARE WE DOING DATA TRACE
	JL	DSPQ14			:IF NOT, SKIP AHEAD
	CH	R5,DDEV,RDCB,		:IS THIS THE RIGHT DEVICE
	JNFS	DSPQ14			:IF NOT, SKIP AHEAD
	STH	R5,DA.ONR,,		:FLAG REST OF TRACE, OK TO BEGIN
	JAL	R5,DA.RCV		:GET LINK AND PUT IN STX

DSPQ14	JAL     R5,PBHIN                :GET BUFFER AND INSERT STX
        J	DSPQ18

:	DATA TRACE - WRITE IN RECEIVE CODE AND DLE STX IF TRACING
DSPQ16	LH	R5,DA.ON,,		:ARE WE DOING DATA TRACE
	JL	DSPQ17			:IF NOT, SKIP AHEAD
	CH	R5,DDEV,RDCB,		:IS THIS THE RIGHT DEVICE
	JNFS	DSPQ17			:IF NOT, SKIP AHEAD
	STH	R5,DA.ONR,,		:FLAG REST OF TRACE, OK TO BEGIN
	JAL	R5,DA.RCV		:GET LINK AND PUT IN DLE STX

DSPQ17  JAL     R5,PXHIN                :GET BUFFER AND INSERT DLE STX
DSPQ18  STH     RBA,DIFBA,RDCB,         :SAVE 1ST BUFFER ADR
        LIS     R0,0
        STH     R0,DTCNT,RDCB,          :ZERO TOTAL MSG COUNT
:
: COPY DATA FROM RING TO BISYNC MSG BUFFER...CHECK TO SEE IF WE NEED TO
: COUNT DATA

DSPQ20	LH	R0,CP.ON,,		:IS CPS TRACE ENABLED
	JLFS	DSPQ25			:IF NOT, SKIP AHEAD
	LH	R0,CP.LN,,		:FOR SLOT OR LINE
	JLFS	DSPQ22			:SKIP AHEAD IF SLOT
	LHL	R5,DDEV,RDCB,		:GET DEVICE NUMBER
	CLB	R0,DEVLN,R5		:IS THIS THE RIGHT LINE
	JNFS	DSPQ25			:SKIP AHEAD IF NOT THIS LINE
DSPQ22	AM	RPKT,CP.CNT,,		:ADD NUMBER OF CHARS TO LINE/SLOT TOTAL

DSPQ25	LHL     R0,DIR0,RDCB,           :GET CONTROL BYTE
        THI     R0,XPRBIT               :TRANSPARENT MODE?
        JN      DSPQ40                  :Y - JUMP
: NORMAL MODE...
DSPQ30  LHL     R5,DTCNT,RDCB,          
        AIS     R5,1                    :INCREMENT TOTAL BYTE COUNT OF MSG
        STH     R5,DTCNT,RDCB,
        THI     R5,0FF                  :TIME TO SEND "TIME FILL" SYNS?
        JNFS    DSPQ32                  :N - JUMP
: ONE SECOND IS APPROXIMATED BY  256  BYTES OF DATA FOR 2400 BAUD LINE.
: TERMINAL NEEDS TIME FILL SYNCS EVERY SECOND FOR SYNCHRONIZATION.
        LHI     R0,RSYN                 :SEND TWO "TIME FILL" SYNS
        JAL     R5,PBCIN
        JAL     R5,PBCIN
: COPY DATA CHARACTER FROM ISIS RING TO BUFFER IN NORMAL MODE
DSPQ32  JALR    RSL,RSL                 :RETURN FOR NEXT CHAR
        LR      R6,R0

:	DATA TRACE, IF TRACING DATA SAVE UP TO FIRST 10 BYTES 
	LH	R5,DA.ONR,,		:ARE WE TRACING DATA
	JL	DSPQ35			:IF NOT, SKIP AHEAD
	CH	R5,DDEV,RDCB,		:IS THIS THE RIGHT DEVICE
	JN	DSPQ35			:IF NOT, SKIP AHEAD
	LHL	R4,DA.RPT,,		:GET TRACE ENTRY INDEX
	LB	R5,ST.SEG+1,R4,		:GET RECEIVE CHARACTER COUNT
	CHI	R5,DA.ESZ-1		:HAVE WE SAVED OUR 10 CHARS YET
	JGFS	DSPQ35			:IF DONE FOR THIS MSG, SKIP AHEAD
	STB	R6,ST.SEG,R4,R5		:SAVE CHAR
	AIS	R5,1			:BUMP CHAR COUNT
	STB	R5,ST.SEG+1,R4,		:SAVE COUNT

DSPQ35	LB      R0,REVTAB,R6            :REVERSE IT
        JAL     R5,PBCIN                :PUT INTO BUFFER
        SIS     RPKT,1                  :DECREMENT PACKET BYTE COUNT
        JG      DSPQ30                  :IF NOT DONE, GET NEXT CHAR
        IF      TSTSWT
        JLBS    .                       :LOOP IF COUNT IF NEGATIVE
        EI
: CHECK M BIT TO SEE IF END OF A BLOCK OF MESSAGE
        LB      R6,DIX25,RDCB,          :GET X.25 FLAGS
        THI     R6,X.M                  :M BIT ON?
        JN      DSPQ90                  :   Y - GO ON TO NEXT PACKET
        J       DSPQ50
: TRANSPARENCY MODE...
DSPQ40  LHL     R5,DTCNT,RDCB,
        AIS     R5,1                    :INCREMENT TOTAL BYTE COUNT OF MSG
        STH     R5,DTCNT,RDCB,
        THI     R5,0FF                  :TIME TO SEND "TIME FILL" SYNS?
        JNFS    DSPQ42                  :N - JUMP
: ONE SECOND IS APPROXIMATED BY  256  BYTES OF DATA FOR A 2400 BAUD LINE.
: EVERY SECOND, THE TERMINAL NEEDS TIME FILL SYNCS (DLE SYN) FOR SYNCHRONIZATION.
        LHI     R0,RDLE                 :SEND DLE SYN TO TIME FILL
        JAL     R5,PBCIN
        LHI     R0,RSYN
        JAL     R5,PBCIN
: COPY DATA CHARACTER FROM ISIS RING TO BUFFER IN TRANSPARENCY MODE
DSPQ42  JALR    RSL,RSL                 :GET NEXT CHAR
        CLHI    R0,DLE                  :IS IT A DLE?
        JNFS    DSPQ44                  :N - JUMP
        LHI     R0,RDLE                 :Y - STORE TWO DLE'S
        JAL     R5,PBCIN                :STORE INTO BUFFER
        J	DSPQ46

DSPQ44  LR      R6,R0

:	DATA TRACE, IF TRACING DATA SAVE UP TO FIRST 10 BYTES 
	LH	R5,DA.ONR,,		:RE WE TRACING DATA
	JL	DSPQ45			:IF NOT, SKIP AHEAD
	CH	R5,DDEV,RDCB,		:IS THIS THE RIGHT DEVICE
	JN	DSPQ45			:IF NOT, SKIP AHEAD
	LHL	R4,DA.RPT,,		:GET TRACE ENTRY INDEX
	LB	R5,ST.SEG+1,R4,		:GET RECEIVE CHAR COUNT
	CHI	R5,DA.ESZ-1		:HAVE WE SAVED OUR 10 CHARS YET
	JGFS	DSPQ45			:IF DONE FOR THIS MSG, SKIP AHEAD
	STB	R6,ST.SEG,R4,R5		:SAVE CHAR
	AIS	R5,1			:BUMP CHAR COUNT
	STB	R5,ST.SEG+1,R4,		:SAVE COUNT

DSPQ45	LB      R0,REVTAB,R6            :REVERSE THE CHAR
DSPQ46  JAL     R5,PBCIN                :STORE INTO BUFFER
        SIS     RPKT,1                  :DECREMENT PACKET BYTE COUNT
        JG      DSPQ40                  :IF NOT DONE, GET NEXT CHAR
        IF      TSTSWT
        JLBS    .                       :LOOP IF COUNT IS NEGATIVE
        EI
: CHECK M BIT TO SEE IF END OF A BLOCK OF MESSAGE
        LB      R6,DIX25,RDCB,          :GET X.25 FLAGS
        THI     R6,X.M                  :M BIT ON?
        JN      DSPQ90                  :Y - GO ON TO NEXT PACKET
: INSERT DLE BEFORE LAST CHAR OF MESSAGE BLOCK
        LB      R0,BBUFER+BBFLSZ-2,RBA,RBX      :GET LAST CHAR IN BUFFER
        LHI     R6,RDLE
        STB     R6,BBUFER+BBFLSZ-2,RBA,RBX      :STORE DLE IN ITS PLACE
        PUSH(RSUM)                      :CKSUM NOW OKAY, SO SAVE IT
        JAL     R5,PBCIN                :PUT BACK LAST CHAR INTO BUFFER
        POP(RSUM)                       :RESTORE CKSUM
        IF      TSTSWT
        CLHI    R0,RETX         :LAST CHAR SHOULD BE ETX, ETB, ENQ, ITB
        JEFS    DSPQT2
        CLHI    R0,RETB
        JEFS    DSPQT2
        CLHI    R0,RENQ
        JEFS    DSPQT2
        CLHI    R0,RITB
        JNBS    .               :IF BAD LAST CHAR, LOOP TO SELF
DSPQT2
        EI
:
: REACHED END OF A BLOCK OF INPUT BISYNC MESSAGE TO TERMINAL
:
DSPQ50  LB      R6,BBUFER+BBFLSZ-2,RBA,RBX      :GET LAST CHAR IN BUFFER
        CLHI    R6,RENQ                 :ABORT THIS MSG BLOCK
        JN      DSPQ60                  :N - JUMP TO SEND BLOCK
        LHL     R0,DIR0,RDCB,
        THI     R0,FIRBIT               :IS THIS THE 1ST BLOCK?
        JE	DSPQ55                  :N - SEND ABORT MSG
       
:	DATA TRACE, IF DATA TRACING SAVE ENQ AND SET LINK AS DONE
	LH	R4,DA.ONR,,		:ARE WE TRACING DATA
	JL	DSPQ52			:IF NOT, SKIP AHEAD
	CR	R4,R5			:IS THIS THE RIGHT DEVICE
	JN	DSPQ52			:ID NOT, SKIP AHEAD
	LHL	R7,DA.RPT,,		:GET TRACE ENTRY INDEX
	LB	R4,ST.SEG+1,R7,		:GET CHAR COUNT
	CHI	R4,DA.ESZ		:SKIP AHEAD IF WE ALREADY HAVE LAST CHAR
	JNFS	DSPQ51
	LB	R6,REVTAB,R6		:REVERSE BACK TO ASCII
	STB	R6,ST.SEG-1,R7,R4	:SAVE ETX, ETB, OR ENQ
DSPQ51	LIS	R6,0
	RBT	R6,ST.SEG,R7,		:SET LINK AS NOT IN USE

DSPQ52	JAL     R5,PBBC,,               :Y - FREE THIS BUFFER
        J       DSPQ80

:ABORT THIS MESSAGE.... SEND ENQ TO TERMINAL

DSPQ55  OHI     R0,ENQBIT               :SET ENQ BIT FOR F.G.
        LIS     R4,0                    :
        STH     R4,DIRBA,RDCB,          :CLEAR CURRENT BUFFER ADDRESS
        AHI     RBX,BBFLSZ-2-BSXWSZ+1   :GET BYTE COUNT
        AHM     RBX,CNTIN,RDCB,         :COUNT TOTAL BYTES IN CURRENT MSG
        J       DSPQ66  

: SEND ETB/ETX TO TERMINAL

DSPQ60  PUSH(R6)                :SAVE LAST CHAR OF BLOCK
        JAL     R5,PBEIN        : APPEND CHECKSUM
        POP(R6)                 :RESTORE LAST CHAR OF BLOCK
        LHL     R0,DIR0,RDCB,   : GET R0 FOR MSG (CTL BYTE AND SEQ NO)
        CLHI    R6,RETB
        JN      DSPQ62
        OHI     R0,ETBBIT               :SET TO INDICATE ETB BLOCK
        J       DSPQ66
DSPQ62
        IF      TSTSWT
        CLHI    R6,RETX
        JEFS    DSPQ64
        JBS     .			:LOOP IF BAD LAST CHAR
DSPQ64
        EI
	LB	R5,DISEQ,RDCB,		
	AIS	R5,1			:UPDATE NEXT RECEIVE SEQ #
	STB	R5,DISEQ,RDCB,
	OH	R5,DIR0,RDCB,		:COMBINE WITH CONTROL BYTE
	STH	R5,DIR0,RDCB,		:AND SAVE
        OHI     R0,ETXBIT               :SET TO INDICATE ETX OR ENQ BLOCK
DSPQ66  LHL     R5,DDEV,RDCB,           :GET DEVICE NUMBER

:	DATA TRACE, IF DATA TRACING SAVE ETX, ETB, OR ENQ AND SET LINK AS DONE
	LH	R4,DA.ONR,,		:ARE WE TRACING DATA
	JL	DSPQ68			:IF NOT, SKIP AHEAD
	CR	R4,R5			:IS THIS THE RIGHT DEVICE
	JN	DSPQ68			:ID NOT, SKIP AHEAD
	LHL	R7,DA.RPT,,		:GET TRACE ENTRY INDEX
	LB	R4,ST.SEG+1,R7,		:GET CHAR COUNT
	CHI	R4,DA.ESZ		:SKIP AHEAD IF WE ALREADY HAVE LAST CHAR
	JNFS	DSPQ67
	LB	R6,REVTAB,R6		:REVERSE BACK TO ASCII
	STB	R6,ST.SEG-1,R7,R4	:SAVE ETX, ETB, OR ENQ
DSPQ67	LIS	R6,0
	RBT	R6,ST.SEG,R7,		:SET LINK AS NOT IN USE

:	TIMESTAMP RECEIPT OF ETX IN IRING
DSPQ68	LH	R6,ST.ON,,		:ARE WE TIMESTAMPING
	JLFS	DSPQ69			:IF NOT, SKIP AHEAD
	CR	R6,R5			:IS THIS THE RIGHT DEVICE
	JNFS	DSPQ69			:IF NOT, SKIP AHEAD
	LB	R4,ST.DSP+1,,		:GET DISPLACEMENT
	L	R6,FASTC,,		:GET CURRENT TIME IN FASTC
	ST	R6,ST.ST5,R4,		:AND SAVE TIME

DSPQ69	PUTCMD(IN,R5,R5)        : PUT DATA CMD IN INPUT Q
        IF      DYNBUF
DELTAN  EQ      2               :FACTOR TO INCREASE N0 DUE TO # OF RESTARTS
MINETX  EQ      20              :TIME TO ALLOW XMT OF LAST BUFFER (IN CHARS)
:
: "DYNAMIC BUFFER SIZE" MEANSTHAT THE MINIMUM NUMBER OF DATA BYTES IN THE
: FIRST BUFFER OF A MESSAGE BEFORE ITS RELEASE TO THE IN QUEUE IS
: DYNAMICALLY VARYING, ACCORDING TO THE CONDITION OF THE XMT LINE,
: SUCHG THAT BOTH THE NUMBER OF SYNC INSERTINS AND THE NUMBER OF
: UN-TRANSMITTED DATA AT THE TIME ETX IS SEEN ARE MINIMIZED.
: IF DYNAMIC XMT BUFFER SIZE IS IN EFFECT, THEN THE ADJUSTMENT TO N0, SIZE
: OF THE INITIAL TRANSMIT BUFFER, IS CALCULATED HERE.  FOREGROUND GIVES NRSTRT,
: NUMBER OF INSTANCES WHERE THE ROTOR MUST BE RESTARTED BECAUSE THE DATA
: WERE TRASMITTED TOO FAST.  HERE, THE BACKGROUND CALCULATES M, THE NUMBER
: OF UN-TRANSMITTED DATA STILL LEFT IN THE QUEUE, WHICH IS USED TO DECREASE
: THE PREVIOUS N0 BECAUSE THERE WAS INSUFFICIENT TIME TO TRANSMIT THE DATA.
:
: CALCULATE M
        LHL     R6,DCIN,R5,R5   :CALCULATE TOTAL # OF DATA BYTES
        AH      R6,DCXMT,R5,R5  : ALREADY SENT TO QUEUE FOR TRANSMISSION
        CH      R6,CNTIN,RDCB,  :COMPARE TO # OF BYTES IN CURRENT MSG
        IF      TSTSWT
        JLBS    .               :LOOP IF CURRENT MSG LARGER THAN WHAT IS IN QUEUEE
        EI
        JEFS    DSPQ70          :JUMP IF FG & BG PROCESSING CURRENT MSG
        LHL     R6,CNTIN,RDCB,  :M = # OF BYTES OF CURRENT MSG IF FG
        JFS     DSPQ72          : IS PROCESSING A PREVIOUS MSG
DSPQ70  SH      R6,NDXMT,R5,R5  :M = DCIN + DCXMT - NDXMT
        SR      R6,R2           :DO NOT COUNT BYTES NOT YET RELEASED
        IF      TSTSWT
        JLBS    .               :VALUE SHOULD NOT BE NEGATIVE
        EI
        SHI     R6,MINETX       :ALLOW FOR SOME TIME TO XMT LAST BUFFER
        JGEFS   DSPQ72          :M IS OK IF IT IS NON-NEGATIVE
        LIS     R6,0            :M IS ZERO IF IT IS NEGATIVE
:CALCULATE NEW N0 = N0 + NRSTRT * DELTAN - (MIN(M,N0))/2
DSPQ72  CH      R6,N0IN,RDCB,
        JLEFS   DSPQ74
        LHL     R6,N0IN,RDCB,
DSPQ74  SRLS    R6,1
        IF      TSTSWT
        JLBS    .               :FACTOR TO DECREASE N0 SHOULD NOT BE NEGATIVE
        CHI     R6,MAXN0
        JGBS    .               :FACTOR TO DECREASE N0 SHOULD NOT BE TOO BIG
        EI
        LH      R7,NRSTRT,R5,R5 
        IF      TSTSWT
        JLBS    .               :# OF RESTARTS SHOULD NOT BE NEGATIVE
        EI
        SLLS    R7,DELTAN
        SR      R7,R6
        AH      R7,N0IN,RDCB,   :NEW N0
        IF      TSTSWT
        JLBS    .
        EI
        CHI     R7,MINN0        :MAKE SURE NEW N0 IS WITHIN LIMITS
        JG      DSPQ76
        LHI     R7,MINN0
        JFS     DSPQ78
DSPQ76  CHI     R7,MAXN0
        JLEFS   DSPQ78
        IF      TSTSWT
        JBS     .               :WHY IS NEW N0 SO BIG???
        EI
        LHI     R7,MAXN0
DSPQ78  STH     R7,N0IN,RDCB,   :STORE NEW N0
        EI
        RLCMD(IN,R5,R5)
        JAL     R5,TSBP         : TEST FOR B.P. TOWARD ISIS
:
: CLEAR BUFFERLET ADR IN DCB AND RETURN
:
DSPQ80  LIS     RBA,0           : SET RBA AND DIFBA TO ZERO
        STH     RBA,DIFBA,RDCB, :
        STH     RBA,DIRBA,RDCB,
        J       DSPQ99
:
: WE HAVE REACHED THE END OF A PACKET AND "MORE" BIT IS SET...
: THIS MEANS THAT MORE DATA IS COMING FOR THIS MESSAGE BLOCK.  IF WE HAVE
: MORE THAN 1 CHAR IN THE BUFFER SO FAR, SEND IT ON TO FOREGROUND BEFORE
: DISMISSING.  HOWEVER, MUST CHECK THAT ONLY AN EVEN # OF DATA BYTES
: IS SENT.
:
DSPQ90  AHI     RBX,BBFLSZ-2-BSXWSZ+1   :MAKE OFFSET INTO # OF DATA BYTES
        CLHI    RBX,1                   :MORE THAN 1 BYTE OF DATA?
        IF      TSTSWT
        JLBS    .                       :LOOP IF NEG # OF DATA BYTES
        EI
        JGFS    DSPQ92                  :JUMP IF MORE THAN 1 DATA BYTE
        SHI     RBX,BBFLSZ-2-BSXWSZ+1   :RESTORE RBX IF ONLY 1 DATA BYTE
        J       DSPQ99                  :RETURN
DSPQ92  THI     RBX,1                   :EVEN # OF DATA BYTES?
        JN      DSPQ95                  :N - JUMP TO MAKE EVEN
: AN EVEN # OF DATA BYTES ALREADY IN BUFFER READY TO BE SENT
        JAL     R5,PBQIN                :SEND THE BUFFER AND GET ANOTHER
        SIS     RBX,1                   :NO IMMEDIATE STORAGE OF DATA
        J       DSPQ99                  :RETURN
: AN ODD # OF DATA BYTES DETECTED...TAKE OUT THE LAST CHAR AND SEND THE BUFFER
DSPQ95  SIS     RBX,1                   :DECREMENT # OF DATA BYTES
        PUSH(R0)                        :R0 STILL HAS LAST CHAR PLACED IN BUFFER
        JAL     R5,PBQIN                :SEND THIS BUFFER AND GET ANOTHER
        POP(R0)
        STB     R0,BBUFER+BBFLSZ-2,RBA,RBX      :STORE LAST CHAR
:
: DISMISS THIS PROCESS
:
DSPQ99  J       FSHIIX                  :RETURN

:	DA.RCV - DATA TRACE ROUTINE.  CALLED FROM DSPQ IF TRACING
:	DATA.  ROUTINE LOCATES AN UNUSED OR THE OLDEST LINK IN
:	WHICH TO SAVE DATA AND INSERT RECEIVE COMMAND AND STX
:	OR DLE STX, IF TRANSPARENT.

DA.RCV	PUSH(R5)			:SAVE RETURN
	LHL	R5,DA.FRE,,		:GET POINTER TO ENTRY ON FREE LIST
	LHL	R4,ST.SEG+DA.ESZ,R5,	:GET ENTRIES LINK
	JE	DA.R10			:IF ZERO, FREE LIST IS EMPTY
	STH	R4,DA.FRE,,		:PUT NEXT LINK AT TOP OF FREE LIST
	
DA.R02	LHL	R4,DA.TL,,		:GET POINTER TO TAIL OF DATA ENTRIES
	CHI	R4,DA.HD-ST.SEG		:IS DATA LIST EMPTY
	JNFS	DA.R04			:IF NOT, SKIP AHEAD
	STH	R5,DA.HD,,		:PUT ON FRONT OF LIST
	JFS	DA.R05
DA.R04	STH	R5,ST.SEG+DA.ESZ,R4,	:PUT ENTRY ON END OF LIST
DA.R05	STH	R5,DA.TL,,		:MAKE TAIL POINTER POINT TO IT
	LIS	R6,0
	STH	R6,ST.SEG+DA.ESZ,R5,	:INDICATE THIS IS LAST LINK ON DATA LIST
	J	DA.R20

DA.R10	LHL	R5,DA.HD,,		:GET FIRST LINK ON LIST
	LIS	R6,0
	TBT	R6,ST.SEG,R5,		:SEE IF IN USE
	JE	DA.R15			:IF NOT, SKIP AHEAD
DA.R11	LR	R4,R5			:SAVE PREVIOUS LINK
	LHL	R5,ST.SEG+DA.ESZ,R5,	:LOOK AT NEXT LINK
	JNFS	DA.R13
	JAL	R10,CRASH,,		:SHOULDN'T RUN OUT OF UNBUSY LINKS
DA.R13	TBT	R6,ST.SEG,R5,		:IS IT IN USE
	JNBS	DA.R11
	LHL	R6,ST.SEG+DA.ESZ,R5,	:WHAT IS NEXT LINK
	STH	R6,ST.SEG+DA.ESZ,R4,	:POINT PREVIOUS TO IT
DA.R15	LHL	R4,ST.SEG+DA.ESZ,R5,	:GET POINTER TO NEXT LINK
	STH	R4,DA.HD,,		:PUT NEXT LINK AS HEAD
	J	DA.R02			:GO PUT LINK ONTO TAIL OF DATA LIST
	

DA.R20	STH	R5,DA.RPT,,		:SAVE CURRENT RECEIVE DATA LINK POINTER
	THI	R0,XPRBIT		:TRANSPARENT MODE?
	JNFS	DA.R25			:IF TRANSPARENT, SKIP AHEAD
	LI	R4,DA.RST		:01030200 - RCV CODE, CHAR CNT, STX
	JFS	DA.R26
DA.R25	LI	R4,DA.RDS		:01041002 - RCV CODE, DLE, CHAR CNT, STX
DA.R26	ST	R4,ST.SEG,R5,
	SBT	R6,ST.SEG,R5,		:SET THIS LINK AS BUSY
	RETJ(R5)



:       OND - OUTPUT DATA MSG IN NATIVE MODE
:
: RECEIVED A BISYNCH DATA MESSGEFROM THE TERMINAL.
: CONVERT IT TO A DSP "RESPONSE" MESSAGE AND SEND IT ON TO THE HOST PAD
: VIA THE ISIS RINGS.
:       RBA = INDEX TO BUFFER CONTAINING DATA
:       R2  = # OF BYTES IN MESSAGE
:       R0  = CONTROL BYTE FROM CMDLK
:
OND     PUSH(R5)
        STH     RBA,DORBA,RDCB,         :SAVE BUFFER ADR OF DATA MSG
        STH     R0,DOR0,RDCB,           :SAVE CONTROL BYTE FROM CMDLK
: IF FIRST DATA BLOCK, THEN
:       DATA COUNT = # DATA BYTES - CKSUM (2) - STX (1) - CU - DV
:                       + UCN (1) + CTR BYTE (1) + SEQ # (1)
:                  = # DATA BYTES - 2
: ELSE SUBSEQUENT BLOCKS, SO
:       DATA COUNT = # DATA BYTES - CKSUM (2) - STX (1)
:                       + UCN (1)
:                  = # DATA BYTES - 2
: HENCE, DATA COUNT = # DATA BYTES - 2    FOR BOTH CASES.
        LR      RCNT,R2                 :# OF DATA BYTES IN MESSAGE
        SIS     RCNT,2                  :ADJUST DATA COUNT
: BEGIN MESSAGE PACKET...SEND SIIX AND START ISIS OUTPUT RECORD
        LIS     R0,3                    :SEND SIIX MSG
        LHL     R1,DPORT,RDCB,          :
        LHI     R2,SIIX
        JAL     R4,SLOR,,
        JAL     R4,ELOR,,
        LHI     RBX,-BBFLSZ+2           :INIT MSG INDEX PASSED STX
        LHL     RBA,DORBA,RDCB,         :RESTORE BUFFER ADR OF DATA MSG
        JAL     R5,SLODR                :START ISIS OUTPUT RECORD
        LHI     R0,0C0                  :DATA DIALECT CODE (C094)
        JAL     R5,OCHAR
        LHI     R0,94
        JAL     R5,OCHAR
: SEND IIX FLAGS AND 2-BYTE PACKET LENGTH
        LHI     R0,0                    :SEND IIX FLAGS (M=0,Q=0)
        JAL     R5,OCHAR
        EXBR    R0,RCNT                 :SEND LEFT BYTE OF LENGTH
        JAL     R5,OCHAR
        LR      R0,RCNT                 :SEND RIGHT BYTE OF LENGTH
        JAL     R5,OCHAR
: DETERMINE PACKET HEADER (UCN,CONTROL BYTES,SEQUENCE #)

	LHL     R6,DOR0,RDCB,           :GET CONTROL BYTE FROM CMDLK
        THI     R6,FIRBIT               :IS THIS THE FIRST BLOCK?
        JE      OND20                   :N - JUMP
        LHI     R0,UCN                  :Y - SET FS=0 IN UCN
        JAL     R5,OCHAR                :SEND UCN
        NHI     R6,LCMBIT!ACKBIT!XPRBIT :STRIP OFF UNWANTED BITS
        EXBR    R0,R6                   :CONTROL BYTE IN LEFT BYTE
        JAL     R5,OCHAR                :SEND CONTROL BYTE WITH MSG ID = 0
        LB      R0,DOSEQ,RDCB,          
        JAL     R5,OCHAR                :SEND SEQUENCE NUMBER
        SIS     RCNT,3                  :DECREASE FOR UCN,CTR,SEQ #
        AIS     RBX,2                   :SKIP CU DV BYTES

:	DATA TRACE - GET LINK AND SAVE STX
	LH	R0,DA.ON,,		:ARE WE TRACING DATA
	JLFS	OND15			:IF NOT, SKIP AHEAD
	CH	R0,DDEV,RDCB,		:IS THIS THE RIGHT DEVICE
	JNFS	OND15			:IF NOT SKIP AHEAD
	STH	R0,DA.ONX,,		:FLAG REST OF TRACE, OK TO BEGIN
	JAL	R5,DA.XMT		:GO GET LINK AND PUT IN STX

:	TIMESTAMP MSG STARTED IN ORING
OND15	LH	R0,ST.ON,,		:ARE WE TIMESTAMPING
	JL	OND30			:IF NOT, SKIP AHEAD
	CH	R0,DDEV,RDCB,		:IS THIS THE RIGHT DEVICE
	JN	OND30			:IF NOT, SKIP AHEAD
	LB	R5,ST.DSP+1,,		:GET DISPLACEMENT
	L	R0,FASTC,,		:GET CURRENT TIME IN FASTC
	ST	R0,ST.ST2,R5,		:SAVE TIME

        JFS     OND30
OND20   LHI     R0,UCN                  :SUBSEQUENT BLOCKS
        OHI     R0,BIT.FS               :SEND UCN W/ FS=1
        JAL     R5,OCHAR
        SIS     RCNT,1                  :DECREASE COUNT FOR UCN
: COPY DATA FROM OUTPUT BUFFER TO ISIS RING
OND30   JAL     R4,GETBC                :GET CHAR FROM BUFFER

:	DATA TRACE - IF TRACING DATA, SAVE UP TO FIRST 10 BYTES
	LH	R5,DA.ONX,,		:ARE WE TRACING DATA
	JL	OND32			:IF NOT, SKIP AHEAD
	CH	R5,DDEV,RDCB,		:IS THIS THE RIGHT DEVICE
	JN	OND32			:IF NOT SKIP AHEAD
	LHL	R4,DA.XPT,,		:GET TRACE ENTRY LINK POINTER
	LB	R5,ST.SEG+1,R4,		:GET XMIT CHARACTER COUNT
	CHI	R5,DA.ESZ-1		:HAVE WE SAVED 10 CHARS YET
	JGFS	OND32			:IF DONE FOR THIS MSG, SKIP AHEAD
	STB	R0,ST.SEG,R4,R5		:SAVE CHAR
	AIS	R5,1			:BUMP CHAR COUNT
	STB	R5,ST.SEG+1,R4,		:SAVE COUNT

OND32	JAL     R5,OCHAR                :OUTPUT BYTE TO RING
        SIS     RCNT,1                  ::DECREMENT PACKET COUNT
        JG	OND30
:
: END OF BISYNC MSG BLOCK...ENTIRE DATA BLOCK HASBEEN OUTPUTTED.
: NOW FREE BUFFERS, FLUSH CMD, AND RETURN.
:
        LHL     RDEV,DDEV,RDCB, : GET DEVICE NUMBER

:	DATA TRACE - PUT IN ETX, ETB, OR ENQ...R0 CONTAINS THE LAST CHARACTER
:	AND AS SUCH MUST BE STILL VALID FOR THIS TRACE
	LH	R5,DA.ONX,,		:ARE WE TRACING DATA
	JL	OND35			:IF NOT, SKIP AHEAD
	CR	R5,RDEV			:IS THIS THE RIGHT DEVICE
	JN	OND35			:IF NOT SKIP AHEAD
	LHL	R5,DA.XPT,,		:GET POINTER TO CURRENT LINK
	LB	R4,ST.SEG+1,R5,		:GET CHAR COUNT
	CHI	R4,DA.ESZ		:HAVE WE ALREADY PUT IN LAST CHAR
	JLFS	OND33			:IF SO, SKIP AHEAD
	STB	R0,ST.SEG-1,R4,R5	:SAVE CHAR
OND33	LIS	R0,0
	RBT	R0,ST.SEG,R5,		:SET LINK AS COMPLETE

:	TIMESTAMP ETX OF MSG PUT INTO ORING
OND35	LH	R0,ST.ON,,		:ARE WE TIMESTAMPING
	JLFS	OND40			:IF NOT, SKIP AHEAD
	CR	R0,RDEV			:IS THIS THE RIGHT DEVICE
	JNFS	OND40			:IF NOT, SKIP AHEAD
	LB	R4,ST.DSP+1,,		:GET DISPLACEMENT
	L	R0,FASTC,,		:GET CURRENT TIME IN FASTC
	ST	R0,ST.ST3,R4,		:AND SAVE TIME

OND40	JAL     R4,ELODR,,		: END CURRENT OUTPUT RECORD
	LHL	R0,DOR0,RDCB,
	THI	R0,ETXBIT		:CHECK ETX?
	JEFS	OND41			:NO. DON'T UPDATE SEND SEQ #
	LB	R0,DOSEQ,RDCB,
	AIS	R0,1
	STB	R0,DOSEQ,RDCB,		:UPDATE NEXT SEND SEQ #
OND41   PKCMD(OUT,RDEV,RDEV)    :GET FIRST BUF. ADDR. AGAIN
        ADVCMD(OUT,RDEV,RDEV)   :FLUSH THE CMD
        JAL     R5,PBBC,,       : FREE BUF.
        LI      R6,OND-PSEG     : SET OUTPUT RTE. ADDR. = OND
        STH     R6,DODRA,RDCB,
        RETJ(R5)
 
 
 
:	DA.XMT - DATA TRACE ROUTINE.  CALLED FROM OND IF TRACING
:	DATA.  ROUTINE LOCATES AN UNUSED OR THE OLDEST LINK IN
:	WHICH TO SAVE DATA AND INSERT XMT CODE AND STX.

DA.XMT	PUSH(R5)			:SAVE RETURN
	LHL	R5,DA.FRE,,		:GET POINTER TO ENTRY ON FREE LIST
	LHL	R4,ST.SEG+DA.ESZ,R5,	:GET ENTRIES LINK
	JE	DA.X10			:IF ZERO, FREE LIST IS EMPTY
	STH	R4,DA.FRE,,		:PUT NEXT LINK AT TOP OF FREE LIST
	
DA.X02	LHL	R4,DA.TL,,		:GET POINTER TO TAIL OF DATA ENTRIES
	CHI	R4,DA.HD-ST.SEG		:IS DATA LIST EMPTY
	JNFS	DA.X04			:IF NOT, SKIP AHEAD
	STH	R5,DA.HD,,		:PUT ON FRONT OF LIST
	JFS	DA.X05
DA.X04	STH	R5,ST.SEG+DA.ESZ,R4,	:PUT ENTRY ON END OF LIST
DA.X05	STH	R5,DA.TL,,		:MAKE TAIL POINTER POINT TO IT
	LIS	R6,0
	STH	R6,ST.SEG+DA.ESZ,R5,	:INDICATE THIS IS LAST LINK ON DATA LIST
	J	DA.X20

DA.X10	LHL	R5,DA.HD,,		:GET FIRST LINK ON LIST
	LIS	R6,0
	TBT	R6,ST.SEG,R5,		:SEE IF IN USE
	JE	DA.X15			:IF NOT, SKIP AHEAD
DA.X11	LR	R4,R5			:SAVE PREVIOUS LINK
	LHL	R5,ST.SEG+DA.ESZ,R5,	:LOOK AT NEXT LINK
	JNFS	DA.X13
	JAL	R10,CRASH,,		:SHOULDN'T RUN OUT OF UNBUSY LINKS
DA.X13	TBT	R6,ST.SEG,R5,		:IS IT IN USE
	JNBS	DA.X11
	LHL	R6,ST.SEG+DA.ESZ,R5,	:WHAT IS NEXT LINK
	STH	R6,ST.SEG+DA.ESZ,R4,	:POINT PREVIOUS TO IT
DA.X15	LHL	R4,ST.SEG+DA.ESZ,R5,	:GET POINTER TO NEXT LINK
	STH	R4,DA.HD,,		:PUT AS HEAD OF LIST
	J	DA.X02			:GO PUT LINK ONTO TAIL OF DATA LIST
	

DA.X20	STH	R5,DA.XPT,,		:SAVE CURRENT RECEIVE DATA LINK POINTER
	LI	R4,DA.XST		:00030200 - RECEIVE CODE, CHAR CNT, STX
	ST	R4,ST.SEG,R5,		:WRITE INTO FIRST TWO BYTES OF LINK
	SBT	R6,ST.SEG,R5,		:SET THIS LINK AS BUSY
	RETJ(R5)

:       OCHAR - OUTPUT A CHAR TO THE ISIS RING
:       THEN CHECK FOR END OF ISIS RECORD
:       DISMISS IF SO
:       INPUT - R0 = OUTPUT CHAR    RRC = ISIS RECORD CNT
:       LINK  - R5      WORK - R4 , R6
OCHAR   JAL     R4,PUTCH,,
        SIS     RRC,1           : REDUCE ISIS RECORD CNT
        JGR     R5              : RETURN IF NOT AT END
        JAL     R4,ELODR,,      : END ISIS RECORD
:       NOW DISMISS OUTPUT PROCESS FOR THIS DEVICE
        STH     RBA,DORBA,RDCB, : SAVE BUF. ADDR. PTR.
        STH     RBX,DORBX,RDCB, : SAVE BUF. OFFSET
        STH     RCNT,DORCNT,RDCB, : SAVE BISYNC BLOCK CNT
        STH     RPKT,DOPCNT,RDCB, : SAVE PACKET COUNT
        SI      R5,PSEG         : CONVERT R5 TO RELATIVE ADDR
        STH     R5,DOSRA,RDCB,  : SAVE RETURN ADDRESS
        LI      R4,OCHA10-PSEG : SET UP OUTPUT ADDRESS
        STH     R4,DODRA,RDCB, : STORE IT
        RETJ(R5)                : RETURN TO OUTPUT SCANNER
:       BEGIN PROCESSING OUTPUT DATA MSG AGAIN AT THIS POINT
OCHA10  PUSH(R5)
        LHL     RBA,DORBA,RDCB, : RESTORE BUF. ADDR.
        LH      RBX,DORBX,RDCB, :         BUF. OFFSET
        LHL     RCNT,DORCNT,RDCB, :       BISYNC BLOCK COUNT
        LH      RPKT,DOPCNT,RDCB, :       PACKET COUNT
        JAL     R5,SLODR        : START A NEW ISIS OUTPUT RECORD
        LHL     R5,DOSRA,RDCB,  : GET RETURN ADDRESS (RELATIVE)
        J       PSEG,R5,        : GO THERE
 
 
:       SLODR - START A MAXIMUM LENGTH OUTPUT DATA RECORD
:       INPUT - RDCB     LINK - R5  WORK - R4
:       R0,R1,  SAVED AND RESTORED
SLODR   PUSH(R0)
        PUSH(R1)
        PUSH(R3)
        LHL     R1,DPORT,RDCB,  : GET PORT NUMBER
        LB      RRC,XLIMIT,R1,  : GET MAX RECORD SIZE
        LIS     R0,3            : ALLOW 3 BYTES FOR HEADER
        AR      R0,RRC          : R0 = NO. BYTES NEEDED IN RING
        JAL     R4,SLOR,,       : START THE RECORD
        POP(R3)
        POP(R1)
        POP(R0)
        JR      R5              : RETURN

:       ONC - CTL MSG IN OUTPUT QUEUE FROM TERMINAL - NATIVE MODE
ONC     HC      OCTOSS-PSEG             :  0 - NULL CMD
        HC      OCTOSS-PSEG             : -1 - DISCONNECT COMMAND
        HC      OCTOSS-PSEG             : -2 - RECORD TIME
        HC      OCTOSS-PSEG             : -3 - YELLOW BALL
        HC      OCTOSS-PSEG             : -4 - ORANGE BALL
        HC      OCTOSS-PSEG             : -5 - EOT
        HC      ONERR-PSEG              : -6 - ERROR CMD
        HC      ONSTA-PSEG              : -7 - STATUS CMD
        HC      ONACK-PSEG              : -8 - ACK CMD
:
:
:
:       ONERR - ERROR CMD
: DETECTED AN ERROR CONDITION...SEND "COMMAND/RESPONSE UNDELIVERED"
: OR "COMMAND/RESPONSE ABORTED" MESSAGE TO HOST.
:       R3 = MESSAGE ID, ERROR CODE
:       R0 = SEQ #
:
ONERR   PUSH(R5)
        ADVCMD(OUT,RDEV,RDEV)
: IF "C/R UNDELIVERED" MSG, THEN MUST FLUSH ALL MESSAGES WITH SEQUENCE NUMBERS
: OTHER THAN CURRENT ONE IN ORDER TO RESYNCHRONIZE
        THI     R3,RCVERR               :XMT/RCV ERROR?
        JN      ONERR2                  :RCV ERROR - JUMP
        LHI     R2,D.UND               :XMT ERROR -
        SBT     R2,DFLAGS,RDCB,         :SET TO FLUSH OUT-OF-SEQ DATA
        LR      R2,R0                   :GET CURRENT SEQ #
        IF      TSTSWT
        CLB     R0,DISEQ,RDCB,          :SHOULD BE <= TO SEQ # IN DCB
        JGBS    .                       :IF NOT, LOOP TO SELF
        EI
        SIS     R2,1
        STB     R2,DISEQ,RDCB,
        SBT     RDEV,XMTFSH,,             :SET FLAG TO ASK F.G. TO FLUSH XMTQ
        JFS     ONERR4
: IF "C/R ABORTED", THEN MUST GET SEQ # FROM DOSEQ
ONERR2  LB      R0,DOSEQ,RDCB,          :GET SEQ # FOR RCV ERROR
: LCM BIT ALREADY INSIDE ERROR CODE... SEND ERROR MSG
ONERR4  STB     R0,M.ERR+8,,            :STORE SEQ #
        STB     R3,M.ERR+9,,            :STORE ERROR CODE
        EXBR    R3,R3
        STB     R3,M.ERR+7,,            :STORE MESSAGE ID
        LA      R6,M.ERR,,
        JAL     R5,SNDIIX               :SEND ERROR MESSAGE
        EXBR    R3,R3                   :RESTORE ERROR CODE
        JAL     R5,SUPLOG               :RECORD TO SUP LOG
        POP(R5)
        J       4,R5
 
:
:
:       ONSTA - STATUS MSG FROM TERMINAL
: CONVERT TO DSP STATUS MSG AND SEND TO HOST
:       R3 = STATUS CODE (SS0,SS1)
:
ONSTA   PUSH(R5)
        ADVCMD(OUT,RDEV,RDEV)
	STH	R3,SS0SS1,RDEV,RDEV	:SAVE STATUS
        STB     R3,M.STAT+9,,           :STORE SS1
        EXBR    R3,R3
        STB     R3,M.STAT+8,,           :STORE SS0
        LA      R6,M.STAT,,
        JAL     R5,SNDIIX               :SEND STATUS MESSAGE
        POP(R5)
        J       4,R5
 
:
:
:       ONACK - OUTPUT AN ACK CMD
: CONVERT TO DSP ACK MESSAGE AND SEND TO HOST.
: (CALLED FROM OSCAN WHICH PUTS SEQUENCE # INTO R0)
:
ONACK   PUSH(R5)
        ADVCMD(OUT,RDEV,RDEV)
        STB      R0,M.ACK+8,,            :INSERT SEQUENCE #
        LA      R6,M.ACK,,
        JAL     R5,SNDIIX               :SEND ACK MSG
        POP(R5)
        J       4,R5                    : RETURN FOR NEXT CMD
:
:
: CONTROL MESSAGES TO HOST
:
        SEG     0
M.STAT  SC      /"C0"94"80"00"04"00"12"FF"FF/   :STATUS MSG
M.ACK   SC      /"C0"94"80"00"03"00"14"FF/      :ACK MSG
M.ERR   SC      /"C0"94"80"00"04"00"FF"FF"FF/   :ERROR MESSAGE
        SEG     1

: ENTER NATIVE MODE
ENTNAT  PUSH(R5)
        PUSHM(R13)
        LHL     RDEV,DDEV,RDCB,         : GET DEVICE NUMBER
        JAL     R4,RIDTIM               : RESET INPUT DATA TIMER
        JAL     R4,RXTIM                : RESET TIMER ON INPUT QUEUE
        JAL     R5,FLINP                : FLUSH PARTIAL INPUT MSG(IF ANY)
        LI      R6,IDN-PSEG             : SET UP NATIVE MODE
        STH     R6,DIDRA,RDCB,          : INPUT AND OUTPUT PROC. RTE.
        LI      R6,INC-PSEG             : ADDRS.
        STH     R6,DICRA,RDCB,
        LI      R6,OND-PSEG
        STH     R6,DODRA,RDCB,
        LI      R6,ONC-PSEG
        STH     R6,DOCRA,RDCB,
        JAL     R5,FLOUT                : FLUSH OUTPUT QUEUE
        SBT     RDEV,INGAT,,            : OPEN INPUT QUEUE GATE
        LIS     R6,NMODE                        : SET MODE = NATIVE
        STB     R6,DMODE,RDCB,
        LIS     R6,0                    :INIT COMMAND/RESPONSE SEQ NUMBER
        STB     R6,DISEQ,RDCB,          : TO 0
        STB     R6,DOSEQ,RDCB,
:
:CHECK TO SEE IF THERE IS A "LOGICAL" ATTACHMENT.  IF THER IS
:THEN THIS MUST BE RESET TO INSURE THAT ANY DATA COMMING FOR
:TIS DEVICE GOES TOTHE REAL DEVICE.
:
        LH      R6,DPDEV,RDCB,          :IF NORMAL THE
        CH      R6,DLDEV,RDCB,          :PHY=LOG
        JE      RAETX
:
:R6 POINTS TO THE DEVICE THAT DID THE LOG IN
:  1)PLACE THE CORRECT PHISICAL DEVICE INTO THE CURRENT DCB
:
        STH     RDEV,DPDEV,RDCB,
        STH     RDEV,DLDEV,RDCB,
:
:  2)SET -1 IN THE PHYSICAL LOGICAL DEVICE THAT IS POINTED TO BY R6
:
        LHL     R7,DEVTAB,R6,R6         :DCB FOR "OTHER" DEVICE
        LCS     R5,1
        STH     R5,DPDEV,R7,
        STH     R5,DLDEV,R7,
:
:  3)CHNGE TO NETWORK SERVICES SCREEN
:
        PUSH(R1)
        PUSH(R2)
        PUSH(R3)
        PUSH(RDEV)
        PUSH(RDCB)
        PUSH(RRC)
        LR      RDEV,R6                 :PUT UP NET SERVICES
        LR      RDCB,R7
        JAL     R5,XNET                 :DISPLAY NETWORK SERVICES SCREEN
:
: DONE - CLEAN UP
:
        POP(RRC)
        POP(RDCB)
        POP(RDEV)
        POP(R3)
        POP(R2)
        POP(R1)
:
RAETX
        POPM(R13)
        RETJ(R5)
 
:       ZAP ROUTINE FOR NATIVE MODE
NZAP    PUSH(R5)
        JAL     R5,NZEND                : END ANY PARTIAL MSG
        LA      R1,NZMSG                : SEND LOGOUT MSG TO TERM.
        JAL     R5,XLERM
        JAL     R5,SNDZAP               : SEND ZAP MSG TO ISIS
        JAL     R5,DOZAP                : ZAP THE CITCUIT
        RETJ(R5)
 
 
:       RCVD. ZAP MSG IN ISIS INPUT
RZAPN   PUSH(R5)
        LHL     R9,DIRCNT,RDCB,         : RESTORE FOR CHECKSUM
        JAL     R5,NZEND                : END ANY PARTIAL MSG
        LA      R1,NZMSG                : SEND LOGOUT MSG TO USER
        JAL     R5,XLERM
        JAL     R5,DOZAP                : ZAP DEVICE AND PORT
        RETJ(R5)



:
: IMMEDIATELY END A PARTIAL MSG BY SENDING IT WITH ETX IN NATIVE MODE
:
NZEND   PUSH(R5)
        LHL     RBA,DIRBA,RDCB,         :ANY PARTIAL BUFFER MSG?
        JE      NZEND6                  :N - RETURN
        LH      RBX,DIRBX,RDCB,         :GET BUFFER INDEX OF MSG
        LHL     R0,DIR0,RDCB,           :IF NORMAL MSG, END WITH ETX
        THI     R0,XPRBIT
        JN      NZEND2
        LHI     R0,RETX
        JAL     R5,PBCIN
        J       NZEND4
NZEND2  LHI     R0,RDLE                 :IF TRANSPARENT MSG, END WITH DLE ETX
        JAL     R5,PBCIN
        LHI     R0,RETX
        JAL     R5,PBCIN
NZEND4  JAL     R5,PBEIN                        :INSERT CHECKSUM
        LHL     R5,DDEV,RDCB,
        LHL     R0,DIR0,RDCB,
        OHI     R0,ETXBIT               :SET ETX BIT
        PUTCMD(IN,R5,R5)
        RLCMD(IN,R5,R5)
        LIS     R0,0
        STH     R0,DIRBA,RDCB,          :ZERO BUFFER ADR
        STH     R0,DIFBA,RDCB,
NZEND6  RETJ(R5)
        SUBTTL  ASCMOD - ASCII MODE ROUTINES
:       ASCII MODE - DATA ROUTINES
        LO      BSCRCV
        SEG     1
 
:       OUTPUT A DATA MSG TO ISIS (ASCII MODE)
 
:       ENTRY POINTS
 
:       OADM - STARTING A DATA MSG
OADM    PUSH(R5)
        PUSH(R2)
        PUSH(R3)
        PUSH(R9)
        JAL     R4,RXTIM,,	: END TIMER 
        SBT     RDEV,INGAT,,    : OPEN INPUT GATE
        JAL     R5,IDTOR,,      : END CURRENT MSG
        LA      R1,OAD150,,     : GET ADDR OF UNLOCK KBD MSG
        JAL     R5,XLERM        : SEND TO TERMINAL
        POP(R9)
        POP(R3)
        POP(R2)
        LB      R0,BBUFER+3,RBA,        : GET AID CHAR
        STB     R0,DOAID,RDCB,          : STORE IT IN DCB
        CHI     R0,AIDENT               : ENTER KEY ?
        JE      OADM1
        CHI     R0,AIDPF1               : PF 1 KEY  ?
        JE      OADM1
        CLHI    R0,AIDPF2               : PF 2 KEY ?
        JE      OAD250
        CLHI    R0,AIDPA2               : PA 2 KEY ?
        JE      OAD250
        CLHI    R0,AIDPF4               : PF 4 KEY ?
        JE      OAD400
        CLHI    R0,AIDCLR               : CLEAR KEY ?
        JE      OAD400
        CLHI    R0,AIDPF5               : PF 5 KEY ?
        JE      OAD300
        CLHI    R0,AIDPA1               : PA 1 KEY ?
        JE      OAD300
 
:       OTHER KEY - DROP THE MSG
        JAL     R5,PBBC,,               : FREE THE BUF.
        ADVCMD(OUT,RDEV,RDEV)
        RETJ(R5)
:       ENTER OR PF1 PRESSED
OADM1
        LHI     RBX,-BBFLSZ+1+6
        LB      R0,BBUFER+BBFLSZ-2+1,RBA,RBX,   : GET FOURTH BYTE
        CHI     R0,SBA.
        JNFS    OADM2
        AIS     RBX,3                   : SKIP SBA SEQUENCE
OADM2
        LIS     RMASK,0                 : INIT MASK FOR BITS 1,2
        J       OAD020                  : PROCESS THE MSG
 
:       OADS - STARTING A MSG SEGMENT
OADS    PUSH(R5)
        LHI     RBX,-BBFLSZ+1+4         : INIT OFFSET TO FIRST DATA CHAR
        J       OAD020                  : PROCESS THE SEGMENT
 
:       OADR - RESTART AFTER STOP FOR FULL RING
OADR    PUSH(R5)
        LHL     RBA,DORBA,RDCB,         : GET CURRENT BUF. ADDR
        LH      RBX,DORBX,RDCB,         : GET OFFSET
        LB      RMASK,DOMSK,RDCB,
        J       OAD020                  : RESTART PROCESSING
 
:       OADF - FLUSH SEGMENTS UNTIL ETX IS FOUND THE RESTORE
:       DODRA TO OADM
OADF    PUSH(R5)
OADF10  JAL     R4,GETLST               : GET LAST CHAR
        CHI     R0,ETX                  : ETX ?
        JNFS    OADF20                  :  N - SKIP
        LI      R0,OADM-PSEG            : RESET DATA ROUTINE ADDRESS
        STH     R0,DODRA,RDCB,          : IN DCB
        J       OADFX
OADF20
        LI      R0,OADF-PSEG            : SET DATA ROUTINE ADDR
        STH     R0,DODRA,RDCB,          : TO THIS ROUTINE
        J       OADFX                   : NOW FLUSH IT
 
:       GETLST - GET LAST CHAR IN MSG (ETB/ETX)
:       DUMMY FOR NOW (RETURNS ETX)
GETLST  LHI     R0,ETX
        JR      R4
 
:       OAD250 - SEND BREAK MSG
OAD250  JAL     R5,PBBC,,               : FREE BUF. IN THIS MSG
        ADVCMD(OUT,RDEV,RDEV)
        LIS     R0,3
        LHL     R1,DPORT,RDCB,          : GET PORT NO.
        LHI     R2,BRKMSG               : SEND BREAK MSG
        JAL     R4,SLOR,,
        JAL     R4,ELOR,,
        POP(R5)
        J       4,R5                    : RETURN
OAD300  LHI     R5,DZ.3                 :"DROPPED BY USER" REASON CODE
        STB     R5,DZAP,RDCB,           :STORE FOR DISCONNECT MSG
        JAL     R5,AZAP                 : ZAP THE DEVICE
        POP(R5)
        J       4,R5
 
 
:       PF4 OR CLEAR KEY PRESSED - RESTORE SCREEN
OAD400  JAL     R5,PBBC,,               : FREE BUF.
        ADVCMD(OUT,RDEV,RDEV)
        JAL     R5,XASCN                : SEND INITIAL ASCII SCREEN
        JAL     R5,FLINP                : FLUSH PARTIAL INPUT SCREEN
        LIS     R6,0                    : INIT. COL = 0
        STB     R6,DCOL,RDCB,
        LB      R6,DMNROW,RDCB,         : INIT. ROW = TOP
        STB     R6,DROW,RDCB,
        RETJ(R5)                        : RETURN
 
:       EXIT POINTS
 
:       OAD100 - OUTPUT LIMIT REACHED , WAIT
OAD100  
        STH     RBA,DORBA,RDCB,         : SAVE BUF. ADDR
        STH     RBX,DORBX,RDCB,         : SAVE OFFSET
        STB     RMASK,DOMSK,RDCB,       : SAVE BIT 1,2 MASK
        LI      R0,OADR-PSEG            : RESTORE ROUTINE ADDRESS
        STH     R0,DODRA,RDCB,          : IN DCB
        LHL     RDEV,DDEV,RDCB,         : RELOAD DEVICE NUMBER
        RETJ(R5)
 
:       OADFX - FLUSH DATA MSG AND EXIT
OADFX   LHL     RDEV,DDEV,RDCB,         : RELOAD DEVICE NO.
        PKCMD(OUT,RDEV,RDEV)
        ADVCMD(OUT,RDEV,RDEV)
        JAL     R5,PBBC,,               : FREE BUF.
        POP(R5)
        J       4,R5                    : SKIP RETURN - GET NEXT CMD
 

:       OAD020 - PROCESS THE MSG
OAD020
:       START AN ISIS OUTPUT MSG
        PUSH(R1)
        PUSH(R2)
        PUSH(R3)
        LHL     R1,DPORT,RDCB,          : GET PORT NO.
        LB      R2,XLIMIT,R1,           : GET MSG. LENGTH LIMIT
        LR      R0,R2
        AIS     R0,3                    : R0 = LEN.+3 BYTE OVERHEAD
        JAL     R4,SLOR,,               : START MAX. LENGTH MSG.
        LB      R10,XLIMIT,R1,          : GET MSG. LENGTH AGAIN
	POP(R3)
        POP(R2)
        JAL     R5,OACOPY               : COPY CHARS TO RING
        JAL     R4,ELODR,,              : END ISIS MSG
        POP(R1)
        SIS     RBX,1                   : BACK UP OFFSET
        JAL     R4,GETBC                : AND GET ETB/ETX CHAR AGAIN
        CHI     R0,ETB                  : ETB ?
        JE      OAD40                   :   Y - EXIT LOOP
        CHI     R0,ETX                  : ETX ?
        JN      OAD100                  :   N - END OF BISYNC MSG NOT 
                                        :       REACHED - WAIT
:       ETX FOUND - END OF COMPLETE BISYNC MSG
        LI      R0,OADM-PSEG            : SET DATA RTE ADDR TO START OF MSG
        STH     R0,DODRA,RDCB,          : STORE IN DCB
        J       OADFX                   : FLUSH MSG AND EXIT
 
:       ETB FOUND - END OF MSG SEGMENT
OAD40   LI      R0,OADS-PSEG            : SET DATA ROUTINE ADDR
        STH     R0,DODRA,RDCB,          : FOR NEXT SEGMENT OF MSG
        J       OADFX
 
        SEG     0
:       OAD150 - KEYBOARD UNLOCK MSG
OAD150  HC      2
        BC      ESC.,EAUCMD
        SEG     1
 

 
:       OACOPY - COPY CHARS TO OUTPUT RING (ASCII MODE)
:       EXIT WHEN MSG CNT = 0  OR ETX/ETB FOUND
:       INPUT - RBA,RBX = BUF. ADDR,OFFSET  R10=ISIS BYTE CNT
OACOPY
OACOP1  JAL     R4,GETBC                : GET NEXT CHAR
        LR      R6,R0
        LB      R0,EBCASC,R6            : TRANSLATE TO ASCII
        LR      R0,R0                   : SET COND. CODE
        JE      OACOP4                  :   SPECIAL HANDLING NEEDED ?
        XR      R0,RMASK                : SET BITS 1,2
        LIS     RMASK,0                 : NOW SET MASK TO ZER0
OACOP2  OHI     R0,80                   : TURN ON HIGH ORDER BIT
        JAL     R4,PUTCH,,              : PUT CHAR INTO RING
        SIS     R10,1                   : REDUCE BYTE CNT
        JG      OACOP1                  :   NOT ZERO - REPEAT
        JR      R5                      : RETURN
 
:       SPECIAL HANDLING FOR CTL CHARS , CENT , FIELD MARK
OACOP4  CHI     R6,SBA.                 : SBA CHAR ?
        JE      OAC010                  :   Y -
        CHI     R6,ETX                  : ETX ?
        JE      OAC020                  :   Y -
        CHI     R6,ETB                  : ETB ?
        JE      OAC030                  :   Y -
        CHI     R6,CENT.                : CENT CHAR ?
        JE      OAC040
        CHI     R6,FM.                  : FIELD MARK CHAR ?
        JE      OAC050
:       DEFAULT CASE - JUST DROP IT AND RESET MASK
        LIS     RMASK,0
        J       OACOP1                  : GO ON TO NEXT CHAR
 

:       SBA CHAR
OAC010  LIS     RMASK,0
        JAL     R4,GETBC                : FLUSH 2 FOLLOWING ADDR CHARS
        JAL     R4,GETBC
        LHI     R0,ACR                  : OUTPUT A CARRIAGE RETURN
        J       OACOP2
 
:       ETX -  END OF BISYNC MSG
OAC020  LIS     RMASK,0
        LB      R6,DOAID,RDCB,          : GET AID CHAR
        CHI     R6,AIDENT               : ENTER KEY PRESSED ?
        JNR     R5                      :   N - RETURN FROM OACOPY
:       ENTER KEY PRESSED , SEND CR TO RING THEN EXIT
        LHI     R0,ACR
        JAL     R4,PUTCH,,
        JR      R5
 
:       ETB - END OF BISYNC MSG SEGMENT
OAC030  JR      R5                      : RETURN FROM OACOPY
 
:       CENT CHAR
OAC040  XHI     RMASK,$020              : COMPLEMENT BIT 2
        J       OACOP1                  : GO ON TO NEXT CHAR
 
:       FIELD MARK
OAC050  XHI     RMASK,$040              : COMPLEMENT BIT 1
        J       OACOP1                  : GO ON TO NEXT CHAR
 

:       ASCII MODE  ROUTINES FOR ISIS INPUT
 
:       IAD - RCVD ISIS DATA MSG
:       
IAD     PUSH(R5)
        LR      R10,R2                  : PUT ISIS MSG CNT IN R10
        LHL     RDEV,DDEV,RDCB,         :GET DEVICE NUMBER

:	COUNT CHARACTERS IF REQUIRED
	LH	R0,CP.ON,,		:IS CPS TRACE ON
	JLFS	IAD10			:IF NOT, SKIP AHEAD
	LH	R0,CP.LN,,		:FOR LINE OR SLOT
	JLFS	IAD09			:IF SLOT, SKIP AHEAD
	CLB	R0,DEVLN,RDEV		:IS THIS RIGHT LINE
	JNFS	IAD10			:IF NOT, SKIP AHEAD
IAD09	AM	R10,CP.CNT,,		:ADD IN CHARACTERS

IAD10	JAL     R4,RIDTIM,,		:RESET INPUT DATA TIMER
        LHL     RBA,DIRBA,RDCB,         : GET CURRENT BUF. ADDR
        LH      RBX,DIRBX,RDCB,         : GET OFFSET
        LHL     RSUM,DIRCNT,RDCB,       : GET ACCUMULATED CHECKSUM
        LB      RCOL,DCOL,RDCB,         : GET COLUMN NO.
IAD20   LR      RBA,RBA                 : NEED TO START NEW MSG ?
        JNFS    IAD25                   :   N - SKIP
        JAL     R5,XASM                 : START NEW BISYNC MSG
IAD25   JAL     R4,GETCH,,              : GET NEXT CHAR FROM RING
        NHI     R0,7F                   : SET BIT 0 = 0
        LR      R7,R0
        LB      R6,ASCEBC,R7            : TRANSLATE TO EBCDIC
        LB      R0,REVTAB,R6            : REVERSE THE CHAR
        LR      R0,R0                   : SET COND. CODE
        JE      IAD100                  : SPECIAL HANDLING NEEDED ?
:       NORMAL HANDLING FOR ASCII DATA CHAR
        AIS     RCOL,1                  : ADVANCE COLUMN NUMBER
        CLB     RCOL,DRSIZE,RDCB,       : END OF ROW ?
        JLFS    IAD28                   :   N - SKIP
:       LINE HAS WRAPPED AROUND
        LIS     RCOL,0                  : SET COLUMN = 0
        JAL     R5,INCROW               : INCREMENT THE ROW NUMBER
IAD28   STB     R7,DLC,RDCB,            : UPDATE LAST CHAR
        JAL     R5,PBCIN                : PUT CHAR INTO BUFFER
IAD30   SIS     R10,1                   : REDUCE ISIS MSG CNT
        JG      IAD20                   : REPEAT UNTIL CNT = 0
 
:       END OF ISIS DATA MSG - SAVE REGISTERS AND EXIT
IAD40   STH     RBA,DIRBA,RDCB,         : CURRENT BUF. ADDR
        STH     RBX,DIRBX,RDCB,         : OFFSET
        STH     RSUM,DIRCNT,RDCB,       : ACCUMULATED CHECKSUM
        STB     RCOL,DCOL,RDCB,         : SAVE COLUMN NO.
        LHL     R5,DPDEV,RDCB,          :CHECK ON A PRINTER
        LB      R5,DTYPE,R5,
        THI     R5,PRTR
        JNFS    IAD50
        LHL     RDEV,DDEV,RDCB,
        JAL     R4,SIDTIM,,		: SET INPUT DATA TIMER
IAD50
:       EXIT TO SCANNER
        RETJ(R5)
 

:       SPECIAL HANDLING FOR INPUT CONTROL CHARS
IAD100  CHI     R7,ACR                  : CARRIAGE RETURN ?
        JE      IAD110
        CHI     R7,ALF                  : LINE FEED ?
        JE      IAD120
        CHI     R7,ABS                   BACK SPACE
        JE      IAD130
        CHI     R7,ABEL                 : BELL CHAR ?
        JE      IAD140
        CHI     R7,AFF          : FORM FEED ?
        JE      IAD150

:       DEFAULT CASE - UPDATE LAST CHAR AND GO ON TO NEXT CHAR
        STB     R7,DLC,RDCB,    : UPDATE LAST CHAR PROCESSED
        J       IAD30
 
:       CR - CLEAR REST OF LINE AND SET COL,ROW TO START OF NEW LINE
IAD110  STB     R7,DLC,RDCB,            : UPDATE LAST CHAR
        LB      R6,DROW,RDCB,           : GET ROW NUMBER
:       CHECK FOR END OF LINE BEFORE CLEARING LINE
        LB      R0,DRSIZE,RDCB,         : GET ROW SIZE
        SIS     R0,1                    : MAX COL. = ONE LESS
        CR      RCOL,R0                 : COMPARE TO COL.NO.
        JGEFS   IAD115                  :JUMP IF AT LAST COLUMN
        JAL     R5,CLRLN                : CLEAR REST OF LINE
        JFS     IAD118
IAD115  LIS     R0,0                    :GET REVERSED NULL
        JAL     R5,PBCIN                :CLEAR LAST COLUMMN OF ROW
IAD118
        LIS     RCOL,0                  : SET COLUMN = 0
        JAL     R5,INCROW               : NEW ROW
        J       IAD30                   : GO ON TO NEXT CHAR
 
:       LINE FEED - CLEAR REST OF LINE , ADVANCE ROW NUMBER
:       AND CLEAR LINE TO COLUMN NUMBER
IAD120  LB      R6,DLC,RDCB,    : GET LAST CHAR
        CHI     R6,ACR          : WAS IT A CARRIAGE RETURN ?
        JE      IAD125                  :   Y - DONT DO ANYTHING
        STB     R7,DLC,RDCB,            : UPDATE LAST CHAR
        LB      R6,DROW,RDCB,           : CLEAR REST OF LINE
:       CHECK FOR END OF LINE BEFORE CLEARING IT
        LB      R0,DRSIZE,RDCB,         : GET ROW SIZE
        SIS     R0,1                    : MAX COL = ONE LESS
        CR      RCOL,R0                 : COMPARE TO COL.NO.
        JGEFS   IAD122                  :   SKIP IF AT END OF LINE
        JAL     R5,CLRLN
        JFS     IAD123
IAD122  LIS     R0,0                    :GET REVERSED NULL
        JAL     R5,PBCIN                :CLEAR LAST COLUMN OF ROW
IAD123
        PUSH(RCOL)              :SAVE CURRENT COLUMN
        LIS     RCOL,0          :RESET RCOL IF GOING TO NEXT SCREEN
        JAL     R5,INCROW               : NEW ROW
        POP(RCOL)                       :RESTORE CURRENT COLUMN NUMBER
        LR      RCOL,RCOL               : CHECK COLUMN NUMBER
        JE      IAD30                   :   0 - THRU
:       NOW CLEAR THE NEW LINE UP TO COLUMN NUMBER
        LHI     R7,RA.                  : RA ORDER CHAR
        LB      R0,REVTAB,R7            : REVERSE IT
        JAL     R5,PBCIN                : PUT IT IN BUF.
        LB      R6,DROW,RDCB,           : GET ROW NUMBER
        LR      R7,RCOL                 : GET COLUMN NO. IN R7
        JAL     R5,DOBA                 : PUT BUFFER ADDR INTO BUF.
        LIS     R0,0                    : R0 = NULL REVERSED
        JAL     R5,PBCIN                        : PUT IT IN BUF.
        J       IAD30
IAD125  STB     R7,DLC,RDCB,            : LF AFTER CR , UPDATE LAST 
        J       IAD30                   : CHAR AND GO ON
 
:       BACK SPACE - BACK UP COLUMN NUMBER UNLESS IN COL. 0
:       AND PUT OUT AN SBA SEQUENCE
IAD130  STB     R7,DLC,RDCB,            : UPDATE LAST CHAR
        SIS     RCOL,1                  : BACK UP COL. NO.
        JGEFS   IAD135                  : SKIP IF COL. NO. > 0
        LIS     RCOL,0                  : SET COLUMN = 0
        J       IAD30                   : WE CANT BACK UP - SO GO TO
IAD135  LHI     R7,SBA.                 : GET SBA CHAR
        LB      R0,REVTAB,R7            : REVERSE IT
        JAL     R5,PBCIN                : PUT IN IN BUF.
        LB      R6,DROW,RDCB,           : GET ROW NO.
        LR      R7,RCOL                 : GET COL. NO. IN R7
        JAL     R5,DOBA                 : PUT BUF. ADDR. INTO BUF.
        J       IAD30
 
:       BELL CHAR
IAD140  STB     R7,DLC,RDCB,            : UPDATE LAST CHAR
        LHL     R6,DIFBA,RDCB,          : GET FIRST BUF. ADDR.
        LB      R7,BBUFER+3,R6,         : GET WCC CHAR
        LB      R7,REVTAB,R7            : REVERSE IT (TO NORMAL)
        OI      R7,WCCALM               : TURN ON ALARM BIT
        LB      R0,REVTAB,R7            : REVERSE IT
        STB     R0,BBUFER+3,R6,         : REPLACE ORIGINAL WCC CHAR
        J       IAD30
 
:       FORM FEED - ERASE TO END OF OUTPUT AREA,WRITE MSG
:       AND SET ROW AND COLUMN TO TOP OF OUTPUT AREA FOR NEW MSG
IAD150  STB     R7,DLC,RDCB,            : UPDATE LAST CHAR
        LHI     R0,NULL.                : OUTPUT A NULL
        JAL     R5,PBCIN
        LHI     R7,PT.                  : AND THEN A PROGRAM TAB
        LB      R0,REVTAB,R7
        JAL     R5,PBCIN
        LB      R7,DMXROW,RDCB,         : SET ROW NUMBER TO END OF AREA
        STB     R7,DROW,RDCB,
        LIS     RCOL,0                  : SET COLUMN NUMBER = 0
        JAL     R5,INCROW               : ADVANCE ROW NUMBER TO FORCE
                                        : END OF SCREEN WRITE
        LB      R7,DMNROW,RDCB,         : SET ROW NUMBER TO TOP OF AREA
        STB     R7,DROW,RDCB,
        LIS     RCOL,0
        J       IAD30
 
 
:       INCROW - INCREMENT ROW NUMBER IN DCB AND END MSG
:       IF SCREEN WRAPAROUND OCCURS
:       IF THE MSG IS ENDED, A DELAY CMD WILL BE PLACED IN THE
:       INPUT QUEUE ALSO. THIS WILL PREVENT OVERWRITING PART OF
:       THE OUTPUT.
INCROW  PUSH(R5)
        LB      R6,DROW,RDCB,           : GET ROW NUMBER
        AIS     R6,1                    : ADVANCE IT
        STB     R6,DROW,RDCB,           :SAVE TEMPORARY ROW NUMBER
        LHL     R5,DPDEV,RDCB,          :CHECK FOR A PRINTER
        LB      R5,DTYPE,R5,
        THI     R5,PRTR
        JEFS    INCR10                  :BRANCH IF NOT A PRINTER

        JAL     R5,XAME                 :FOR PRINTERS WE OUTPUT EACH LINE
        J       INCR15
:
INCR10  CLB     R6,DMXROW,RDCB,         : AT END OF DISPLAY AREA ?
        JL      INCR20                  :   N - SKIP
:       RECHED END OF SCREEN - OUTPUT MSG,DELAY
        JAL     R5,XAME                 : END BISYNC MSG AND PUT IN INPUT
                                        : QUEUE
        LHI     R2,DLYCMD               : GET DELAY CMD CODE
        LHL     R5,DDEV,RDCB,           : GET DEVICE NO.
        LHI     R0,FIRBIT!ETXBIT        : SET CONTROL BITS
        PUTCMD(IN,R5,R5)
        RLCMD(IN,R5,R5)
INCR15  LB      R6,DMNROW,RDCB,         : RE-SET ROW NO. AT TOP
        STB     R6,DROW,RDCB,           :SAVE ROW NUMBER
        JAL     R5,XASM                 :START ANOTHER BSC MSG
INCR20
        RETJ(R5)
DLYCMD  EQ      $A-10                   : DELAY CMD CODE

:       CLRLN - CLEAR  REST OF LINE IN DEVICE BUFFER
:       INPUT - R6 = ROW NUMBER
CLRLN   PUSH(R5)
        PUSH(R6)
        LHI     R5,RA.                  : GET RA ORDER CHAR
        LB      R0,REVTAB,R5            : REVERSE IT
        JAL     R5,PBCIN                : STORE IT IN BUF.
        POPPSH(R6)                      : RETRIEVE ROW NO.
        LB      R7,DRSIZE,RDCB,         : GET ROW SIZE
        SIS     R7,1                    : SUBTRACT ONE TO GET LAST COL.
        JAL     R5,DOBA                 : STORE BUF. ADDR CHARS
        LIS     R0,0                    : GET REVERSED NULL
        JAL     R5,PBCIN                        : STORE IT
        JAL     R5,PBCIN                : STORE ANOTHER NULL TO ERASE LAST
                                        : COL.
        POP(R6)
        RETJ(R5)
 
:       DSHLN - PUT A LINE OF DASHES IN MSG
:       INPUT - R6 = ROW NUMBER
DSHLN   PUSH(R5)
        PUSH(R6)
        LHI     R5,RA.                  : GET RA ORDER CHAR
        LB      R0,REVTAB,R5            : REVERSE IT
        JAL     R5,PBCIN                : STORE IT IN BUF.
        POPPSH(R6)                      : RETRIEVE ROW NO.
        LB      R7,DRSIZE,RDCB,         : GET ROW SIZE
        SIS     R7,1                    : SUBTRACT ONE TO GET LAST COL.
        JAL     R5,DOBA                 : STORE BUF. ADDR CHARS
        LHI     R5,DASH.
        LB      R0,REVTAB,R5            : GET REVERSE DASH
        JAL     R5,PBCIN                        : STORE IT
        JAL     R5,PBCIN                : STORE ANOTHER NULL TO ERASE LAST
                                        : COL.
        POP(R6)
        RETJ(R5)
 

:       DOBA - PUT BUFFER ADDRESS CHARS INTO BUF.
:       INPUT - R6 = ROW NO.  , R7 = COL. NO.  (BOTH DESTROYED)
DOBA    PUSH(R5)
        PUSH(R6)
        LB      R0,DRSIZE,RDCB,         : GET ROW SIZE
        MHR     R6,R0                   : R6 = ROW  NO * LENGTH
        AR      R7,R6                   : R7 = BUFFER ADDRESS
:       NOW CONVERT TO CHARS AND STORE
        PUSH(R7)
        SRHLS   R7,6                    : GET HIGH ORDER BITS INTO PLACE
        JAL     R5,DOBA2                :  CONVERT TO CHAR AND STORE
        POP(R7)
        JAL     R5,DOBA2                : NOW DO LOW ORDER BITS
        POP(R6)
        RETJ(R5)
:       DOSBA2 - TAKE 6 BITS CONVERT TO CHAR AND STORE
DOBA2   PUSH(R5)
        NHI     R7,3F                   : ISOLATE 6 BITS
        LB      R7,SPCHRS,R7            : GET SPECIAL CHAR CORRESPONDING
        LB      R0,REVTAB,R7            : REVERSE IT
        JAL     R5,PBCIN                : STORE IT
        RETJ(R5)
 

:       XASM - START A BISYNC MSG ( ASCII MODE )
:       SETS UP DIFBA , RBX , RSUM
XASM    PUSH(R5)
        PUSH(R1)
        LHI     R5,FIRBIT
        STH     R5,DIR0,RDCB,
        JAL     R5,PBHIN                : START MSG IN BUF.
        STH     RBA,DIFBA,RDCB,         : SAVE FIRST BUF. ADDR
        LA      R1,XASM30               : GET ADDR OF BEGINNING MSG STRING
:       CHECK FOR DEVICE TYPE
:       IF PRINTER , USE PRINTER HEADER
        LHL     R6,DPDEV,RDCB,          : GET DEVICE NO.
        LB      R6,DTYPE,R6,            : GET DEVICE TYPE
        THI     R6,PRTR                 : IS IT A PRINTER ?
        JE      XASM20                  :   N - SKIP
        LA      R1,XASM40               :   Y - USE PRINTER HEADER
        LIS     RCOL,0                  :      AND RESET COL AND ROW
        LB      R7,DMNROW,RDCB,
        STB     R7,DROW,RDCB,
XASM20
        JAL     R5,PBSIN                : STORE IT
        LB      R6,DROW,RDCB,           : GET ROW NO.
        LR      R7,RCOL                 : GET COL. NO.
        JAL     R5,DOBA                 : STORE BUF. ADDR CHARS
        POP(R1)
        RETJ(R5)
 
XASM30  HC      4
        BC      ESC.,WCMD,WCCK,SBA.
XASM40  HC      4                       : PRINTER HEADER
        BC      ESC.,EWCMD,WCCP8S,SBA.
 
:       XAME - END BISYNC MSG (ASCII MODE)
:       CLEARS REST OF CURRENT LINE AND ALL OF THE NEXT LINE
:       THEN IT ENDS THE MSG AND PUTS IT THE INPUT QUEUE
:       RBA IS SET TO ZERO SO THAT A NEW MSG WILL BE STARTED
XAME    PUSH(R5)
:       CHECK DEVICE TYPE - IF PRINTER,DONT PUT CENT,AND DASHES
        LHL     R6,DPDEV,RDCB,           : GET DEVICE NO.
        LB      R6,DTYPE,R6,            : GET DEVICE TYPE
        THI     R6,PRTR                 : IS IT A PRINTER
        JN      XAME20                  :   Y - SKIP CENT AND DASHES
:       CHECK ROW NUMBER-IF AT END OF SCREEN,DONT OUTPUT CENT +DASHES
        LB      R6,DROW,RDCB,           : GET ROW NO.
        CLB     R6,DMXROW,RDCB,         : COMPARE TO END OF DISPLAY AREA
        JGE     XAME20                  : SKIP IF AT END
        LHI     R5,CENT.                : PUT CENT CHAR AT CURRENT
        LB      R0,REVTAB,R5            : ROW AND COLUMN
        JAL     R5,PBCIN
        LR      R0,RCOL                 : CHECK FOR END OF ROW
        AIS     R0,2                    : ADVANCE ONE FOR CENT,ONE TO
                                        : COMPENSATE FOR ZERO ORIGIN
        CLB     R0,DRSIZE,RDCB, 
        JGEFS   XAME05                  : SKIP IF AT END OF ROW
        LB      R6,DROW,RDCB,           : GET ROW NO.
        JAL     R5,CLRLN                : CLEAR REST OF CURRENT LINE
XAME05  LB      R6,DROW,RDCB,           : GET ROW NO. AGAIN
        AIS     R6,1                    : ADVANCE ROW NUMBER BY ONE
        CLB     R6,DMXROW,RDCB,         : AT END OF DISPLAY AREA ?
        JGE     XAME20                  :   Y - SKIP
                                        : (AND TAKE CARE OF END OF SCREEN
        JAL     R5,DSHLN                : CLEAR NEXT LINE
XAME20  LHI     R0,RETX                 : GET REVERSED ETX
        JAL     R5,PBCIN                : STORE IT
        JAL     R5,PBEIN                : PUT CHECKSUM IN BUF.
                                        : AND GET FINAL BYTE CNT
        LHL     R5,DDEV,RDCB,           : GET DEVICE NO.
        LHL     R0,DIR0,RDCB,
        OHI     R0,ETXBIT               :SET PROPER BITS
        PUTCMD(IN,R5,R5)
        RLCMD(IN,R5,R5)             : PUT DATA CMD IN INPUT QUEUE
        LIS     R5,0                    :CLEAR DIFBA AND DIRBA
        STH     R5,DIFBA,RDCB,
        STH     R5,DIRBA,RDCB,
        JAL     R5,TSBP                 : CHECK TO SEE IF B.P. NEEDED
        RETJ(R5)
 
 
 

:       IZTP - INITIALIZE TERMINAL PARAMETERS
:       R1 = PORT NO. , R4=LINK , R6=WORK
MXPARM  EQ      $A17            : HIGHEST VALID PARM. NUMBER
IZTP    SBT     R1,DOECHO       : TURN ECHO ON
        RBT     R1,ECTLI        : 
        SBT     R1,ELFCR        : ECHO LF WITH CR
        SBT     R1,ECRLF        : ECHO CR WITH LF
        RBT     R1,CRDE         : NO CARRIAGE RETURN DELAY
        LHI     R6,55           : SET INPUT AND OUTPUT BAUD RATE=1200
        STB     R6,BRATE,R1
        RBT     R1,PARITY               
        RBT     R1,HAFDUX       : FULL DUPLEX
        LIS     R6,0
        STB     R6,PAB,R1       : PARM. A AND B = 0
        LHI     R6,10
        STB     R6,PCD,R1       : PARM. C = 1 , PARM. D = 0
        RBT     R1,XONENA       : X-ON NOT ENABLED
        RBT     R1,YONENA       : REV. X-ON NOT ENABLED
 
        JR      R4              : RETURN
 
:	QUERY TERMINAL PARAMETERS

RAB0    PUSH(R5)
        JAL     R4,GETCH,,      : GET PARAMETER NO.
	LR	R5,R0		:MAKE A COPY
QPARM1	EXBR	R7,R5		:SET UP RESPONSE
	LR	R2,R5
        CHI     R2,MXPARM       : LEGAL PARM. NUMBER ?
        JLEFS   QPARM2          :   Y - SKIP
        LHI     R2,MXPARM+1     :   N - USE DUMMY PARM. NUMBER
QPARM2
	AR	R2,R2		:MAKE HALF-WORD INDEX
	LHL	R3,QSADDR,R2	:GET PARAMETER ADDRESS POINTER
        LHL     R4,QFAN,R2      :GET ROUTINE ADDR
        J       SEG1,R4,,       :GO DO IT

QFAN	HC	QECHO-SEG1	:0 - ECHO CONTROL
	HC	QBIT-SEG1	:1 - ECHO CONTROL-I
	HC	QBIT-SEG1	:2 - ECHO LF W/CR
	HC	QBIT-SEG1	:3 - ECHO CR W/LF
	HC	QBIT-SEG1	:4 - CR DELAY
	HC	QFLEFT-SEG1	:5 - INPUT BAUD RATE
	HC	QFRITE-SEG1	:6 - OUTPUT BAUD RATE
	HC	QBIT-SEG1	:7 - PARITY
	HC	QBIT-SEG1	:8 - HALF DUPLEX
	HC	QFLEFT-SEG1	:9 - PARAMETER A
	HC	QFRITE-SEG1	:10 - PARAMETER B
	HC	QFLEFT-SEG1	:11 - PARAMETER C
	HC	QBIT-SEG1	:12 - X-ENABLE
	HC	QBIT-SEG1	:13 - ECHO CONTROL-H
	HC	QBIT-SEG1	:14 - REVERSE X-ENABLE
	HC	QFRITE-SEG1	:15 - PARAMETER D
        HC      QBIT-SEG1       : 16 - KATAKANA CHAR SET
        HC      QBIT-SEG1       : 17 - FLUSH OUTPUT (TO TERM.) ON BREAK
        HC      QBIT-SEG1       : DUMMY ENTRY FOR INVALID PARM NUMBER


:	QUERY BIT PARAMETER
QBIT	LIS	R0,0		:EXPECT TO RETURN A ZERO
	TBT	R1,0,R3		:IS BIT ON?
	JEFS	QRESP		:NO...SKIP
	LIS	R0,1		:YES...RETURN A ONE
	JFS	QRESP

:	QUERY (LEFT) PARAMETER
QFLEFT	LB	R0,0,R3,R1	:GET PARAMETER
	SRHLS	R0,4		:AND JUSTIFY IT
	JFS	QRESP

:	QUERY (RIGHT) FIELD PARAMETER
QFRITE	LB	R0,0,R3,R1	:GET IT
	NHI	R0,0F		:MASK IT OFF

QRESP	OR	R7,R0		:MERGE THE FIELDS
QRESP1  PUSHM(R13)              : SAVE INPUT RING REG.
        LHI     R2,STPMSG       : OUTPUT A SET TERM.PARM.MSG
        LIS     R0,3            : LENGTH = 3
        JAL     R4,SLOR,,       : START OUTPUT MSG
        LR      R0,R5           : GET PARM. NO.
        JAL     R4,PUTCH,,
        LR      R0,R7           : GET VALUE
        JAL     R4,PUTCH,,
        JAL     R4,ELOR,,       : END RECORD
        POPM(R13)
        RETJ(R5)                : RETURN
 

 
:	SET TERMINAL PARAMETERS
 
RAB1    PUSH(R5)
        JAL     R4,GETCH,,      : GET PARM. NO.
	LR	R5,R0
        JAL     R4,GETCH,,      : GET THE PARM. VALUE
	LR	R2,R5		:MAKE PARAMETER INTO INDEX
        CHI     R2,MXPARM       : LEGAL PARM. NUMBER ?
        JLEFS   RAB12           :   Y - SKIP
        LHI     R2,MXPARM+1     :   N - USE DUMMY INDEX
RAB12
	AR	R2,R2
	LHL	R3,QSADDR,R2	:GET PARAMETER ADDRESS
        LHL     R4,SFAN,R2      :GET ROUTINE ADDR
        J       SEG1,R4,,       :GO DOIT

SFAN	HC	SECHO-SEG1	:0 - ECHO CONTROL
	HC	SBIT-SEG1	:1 - ECHO CONTROL-I
	HC	SBIT-SEG1	:2 - ECHO LF W/CR
	HC	SBIT-SEG1	:3 - ECHO CR W/LF
	HC	SBIT-SEG1	:4 - CR DELAY
        HC      QPARM1-SEG1     :5 - INPUT BAUD RATE
        HC      QPARM1-SEG1     :6 - OUTPUT BAUD RATE
	HC	SBIT-SEG1	:7 - PARITY
	HC	SBIT-SEG1	:8 - HALF DUPLEX
        HC      SFLEFT-SEG1     :9 - PARAMETER A
        HC      SFRITE-SEG1     :10- PARAMETER B
        HC      SFLEFT-SEG1     :11- PARAMETER C
	HC	SBIT-SEG1	:12 - X-ENABLE
	HC	SBIT-SEG1	:13 - ECHO CONTROL-H
	HC	SBIT-SEG1	:14 - REVERSE X-ENABLE
        HC      SFRITE-SEG1     :15- PARAMETER D
        HC      SBIT-SEG1       : 16 - KATAKANA CHAR SET
        HC      SBIT-SEG1       : 17 - FLUSH OUTPUT ON BREAK
        HC      SBIT-SEG1       : DUMMY ENTRY FOR INVALID PARM. NUMBER

:	POINTERS TO PARAMETER TABLES
QSADDR  HC      DOECHO          : 0 - ECHO CONTROL
	HC	ECTLI		:1 - ECHO CONTROL-I
	HC	ELFCR		:2 - ECHO LF W/CR
	HC	ECRLF		:3 - ECHO CR W/LF
	HC	CRDE		:4 - CARRIAGE RETURN DELAY
	HC	BRATE		:5 - INPUT BAUD RATE
	HC	BRATE		:6 - OUTPUT BAUD RATE
	HC	PARITY		:7 - PARITY
	HC	HAFDUX		:8 - HALF-DUPLEX
	HC	PAB		:9 - PARAMETER A
	HC	PAB		:10 - PARAMETER B
	HC	PCD		:11 - PARAMETER C
	HC	XONENA		:12 - X-ENABLE
	HC	ECTLH		:13 - ECHO CONTROL-H
	HC	YONENA		:14 - REVERSE X-ENABLE
        HC      PCD             :15 - PARAMETER D
        HC      KATKAN          : 16 - KATAKANA CHAR SET
        HC      FSHBRK          : 17 - FLUSH OUTPUT ON BREAK
        HC      DUMTAB          : 18 - DUMMY ENTRY FOR INVALID PARAMETER NO.


:	ECHO CONTROL
SECHO	NHI	R0,1
	JEFS	SECHO1
        SBT     R1,ECHO         : SET ECHO
        J       QPARM1          :ACKNOWLEDGE
SECHO1	RBT	R1,ECHO		:RESET ECHO
        J       QPARM1          : ACKNOWLEDGE

QECHO   LIS     R0,1            :PREPARE FOR ECHO ON RESULT
        TBT     R1,ECHO         :ECHO ON ?
        JNFS    QECHO2          :YEP
        LIS     R0,0            :ECHO NOT ON
QECHO2  J       QRESP           :GO ANSWER REQUEST

:	SET A BIT
SBIT	RBT	R1,0,R3		:TURN IT OFF
	NHI	R0,1		:TEST
	JE	QPARM1		:DONE...REPORT IT BACK
	SBT	R1,0,R3		:ELSE TURN IT ON AGAIN
	J	QPARM1		:AND ACKNOWLEDGE


:	SET (LEFT) FIELD
SFLEFT	LIS	R4,0F		:SET MASK
	SLHLS	R0,4		:JUSTIFY VALUE
	JFS	SFIELD		:AND SKIP

:	SET (RIGHT) FIELD
SFRITE	LHI	R4,0F0		:SET MASK

SFIELD	LB	R7,0,R3,R1	:GET CURRENT VALUE
	NR	R7,R4		:MASK IT OUT
	OR	R7,R0		:PLACE NEW VALUE
	STB	R7,0,R3,R1	:PUT NEW VALUE BACK
	J	QPARM1		:AND ACKNOWLEDGE IT

 

:       OAC - OUTPUT CONTROL RTE. TABLE - ASCII MODE
OAC     HC      OCTOSS-PSEG             : NULL CMD
        HC      OCTOSS-PSEG             : DISC CMD
        HC      OCTOSS-PSEG             : TIME CMD
        HC      OCTOSS-PSEG             : YELLOW BALL CMD
        HC      OCTOSS-PSEG             : ORANGE BALL CMD
        HC      OCTOSS-PSEG             : EOT CMD
        HC      OAER-PSEG               : ERROR CMD
        HC      OAST-PSEG               : STATUS CMD
        HC      OCTOSS-PSEG             : ACK CMD
 
 
:       OAER - ERROR CMD IN OUTPUT QUEUE - ASCII MODE
OAER    PUSH(R5)
OAER10  ADVCMD(OUT,RDEV,RDEV)
        JAL     R5,SUPLOG                :REPORT TO SUP
        JAL     R5,AZAP                 : ZAP THE DEVICE
        RETJ(R5)
 
:       OAST - STATUS CMD IN OUTPUT QUEUE - ASCII MODE
OAST    PUSH(R5)
        CHVR    R3,R3                   : FORCE SIGN EXTENTION
        CHI     R3,DEVEND               : DEVICE END STATUS ?
        JN      OAER10                  :   N - TREAT AS AN ERROR
        ADVCMD(OUT,RDEV,RDEV)
        POP(R5)
        J       4,R5                    : GO ON TO NEXT CMD
 
:       AZAP - ZAP DEVICE IN VIRTUAL TERMINAL MODE
:       INPUT RDCB WORK - R1  LINK - R5
AZAP    PUSH(R5)
        LHL     RDEV,DDEV,RDCB,         : GET DEVICE NUMBER
        JAL     R5,IDTOR,,              :END INPUT MSG IF ANY
        JAL     R5,SNDZAP               : SEND A ZAP MSG
        LA      R1,NZMSG                : SEND 'LOGGED OUT ' MSG
        JAL     R5,XLERM
        JAL     R5,DOZAP                : ZAP PORT AND DEVICE
        RETJ(R5)
 
 
 
:       RCVD. ZAP MSG IN ISIS INPUT
RZAPA   PUSH(R5)
        LHL     RDEV,DDEV,RDCB,         : GET DEVICE NO.
        JAL     R5,IDTOR,,              : END INPUT DATA MSG (IF ANY)
        LA      R1,NZMSG                : SEND 'LOGED OUT' MSG
        JAL     R5,XLERM                :
        JAL     R5,DOZAP                : ZAP PORT AND DEVICE
        RETJ(R5)

:       ZAP MSG TO USER IN NORMAL MODE
NZMSG   HC      $A20
        BC      ESC.,WCMD,WCCKM,SBA.
        SBAC($A22,1,$A80)
        BC      SF.,ATPND,IC.
        BC      L.,O.,G.,G.,E.,D.,SP.,O.,U.,T.,PT.
 
        SUBTTL	PUTBUF-BISYNC MESSAGE BUILDING UTILITIES
:       UTILITY ROUTINES TO BUILD MSGS IN BUFFERLET CHAINS
        SEG     1
        LO      BSCCHR
:       
:       PUTBM - PUT A CANNED MSG INTO BUF.
:       PUTBS - PUT A CANNED STRING INTO AN EXISTING BUF. CHAIN
:       PUTBC - PUT ONE CHAR INTO A BUF. CHAIN
:       PUTBH - START A MSG (PUT STX INTO BUF.)
:       PUTBE - END THE MSG (CHECKSUM AND GET BYTE)
:       CKSUM - CHECKSUM THE COMPLETED RECORD
 
:       COMMON REGISTER USAGE
:       INPUT - R1 (PUTBM,PUTBS)
:               R0 (PUTBC) CHAR TO BE ADDED TO MSG
:               RBA,RBX,RCNT CURRENT BUFFERLET ADDRESS,OFFSET AND 
:               PARTIAL COUNT OF BYTES
:       WORK - R4,R6,R7,R0      LINK R5
 
 
:       PUTBM - PUT A CANNED BISYNC MSG INTO BUF.
:               R1 POINTS TO THE MSG STRING HMORD CNT , DATA
PUTBM   PUSH(R5)
        JAL     R5,PUTBH        : START THE MSG
        PUSH(R3)                : SAVE FIRST BUF. ADDR.
        JAL     R5,PUTBS        : ADD THE STRING
        LHI     R0,RETX         : LOAD REVERSE ETX
        JAL     R5,PUTBC        : ADD IT
        POPPSH(R3)              : RESTORE FIRST BUF. ADDR.
        JAL     R5,CKSUM        : CHECKSUM THE MSG
        JAL     R5,PUTBE        : END THE MSG AND GET BYTE CNT
        POP(R3)                 : GET FIRST BUF. ADDR. AGAIN
        RETJ(R5)                : RETURN WITH R2=BYTE CNT AND R3=
                                : FIRST BUFFERLET ADDR.


        IF      TSTSWT
: PUTBMX - SAME AS PUTBM BUT IN TRANSPARENCY MODE.
:
PUTBMX  PUSH(R5)
        JAL     R5,PUTBHX               :START THE MSG
        PUSH(R3)
        JAL     R5,PUTBS                :STORE MSG INTO BUFFER
        LHI     R0,RDLE
        JAL     R5,PUTBC                :INSERT DLE ETX
        LHI     R0,RETX
        JAL     R5,PUTBC
        POPPSH(R3)
        JAL     R5,CKSUMX               :TRANSPARENCY CHECK SUM
        JAL     R5,PUTBE                :END THE MSG
        POP(R3)
        RETJ(R5)
        EI
 
:       PUTBS - PUT A CANNED STRING INTO BUF.
:               AS THE CHAR ARE PUT INTO THE MSG THEY ARE REVERSED
:       INPUT R1 AS FOR PUTBM
PUTBS   PUSH(R5)
        PUSH(R15)
        LIS     R15,0
PUTBS1  LB      R7,2,R1,R15     : GET NEXT BYTE
        LB      R0,REVTAB,R7    : REVERSE IT
        JAL     R5,PUTBC        : STORE IT
        AIS     R15,1           : ADVANCE INDEX
        CLH     R15,0,R1        : END OF STRING ?
        JL      PUTBS1          :   N - REPEAT
        POP(R15)
        RETJ(R5)
 
 

:       PUTBC - PUT ONE CHAR INTO BUF.
PUTBC   AIS     RBX,1           : ADVANCE OFFSET
        JNFS    PUTBC1          : END OF BUF. ?
                                :   Y - GET A NEW ONE
        LR      RBX,RBA         : SAVE OLD BUF. ADDR.
        JAL     R4,GBB,,        : GET A NEW BUF.
        J       PUTCR             : CRASH IF NOT AVAILABLE
        STH     RBA,BBUFER+BBFLSZ-2,RBX,        : LINK TO OLD BUF.
        LHI     RBX,-BBFLSZ+2   : INITIALIZE OFFSET
        SR      RCNT,RBX        : ADD TO PARTIAL CNT
PUTBC1  STB     R0,BBUFER+BBFLSZ-2,RBA,RBX      : STORE THE CHAR
        JR      R5
 
 
:       PUTBH - START A MSG IN BUF. AND PUT STX
:       OUTPUT - RBA,RBX,RCNT
PUTBH   PUSH(R5)
        JAL     R4,GBB,,        : GET FIRST BUF.
        J       PUTCR             : CRASH IF NOT AVAILABLE
        LHI     RBX,-BBFLSZ+1   : INITIALIZE OFFSET
        LHI     RCNT,BBFLSZ-1   : INITIALIZE PARTIAL COUNT
        LHI     R0,RSTX         : GET REVERSE STX CHAR
        JAL     R5,PUTBC        : PUT INTO BUF.
        RETJ(R5)


: PUTBHX - GET BUFFER TO START A BISYNC MESSAGE
:          AND PUT A DLE STX INTO IT.
:       OUTPUT - RBA,RBX,RCNT
:       USES   - R0,R4,R6,R7
:       LINK   - R5
:
PUTBHX  PUSH(R5)
        JAL     R4,GBB,,        :GET 1ST BUFFER OF MSG
        J       PUTCR                     :CRASH IF NONE AVAILABLE
        LHI     RBX,-BBFLSZ+1           :INIT OFFSET
        LHI     RCNT,BBFLSZ-1           :INIT PARTIAL COUNT
        LHI     R0,RDLE
        JAL     R5,PUTBC                :PUT IN REVERSED DLE
        LHI     R0,RSTX
        JAL     R5,PUTBC                :PUT IN REVERSED STX
        RETJ(R5)
  
 
:       PUTBE - END THE MSG IN BUF.
PUTBE   PUSH(R5)
        EXBR    R0,R0           : GET FIRST BYTE INTO PLACE
        JAL     R5,PUTBC        : STORE IT
        EXBR    R0,R0           : GET SECOND BYTE INTO PLACE
        JAL     R5,PUTBC        : STORE IT
        AR      RBX,RCNT        : GET FINAL BYTE CNT
        RETJ(R5)
 
 
:       CKSUM - CHECKSUM THE MSG
:       OUTPUT - R0 = CHECKSUM
CKSUM   PUSH(R5)
        LR      R5,RBX
        AR      R5,RCNT         : GET BYTE CNT OF MSG
        SIS     R5,1            : SUBTRACT ONE FOR STX
        LHI     RBX,-BBFLSZ+2   : SET OFFSET PAST STX
        CRCINT(R6)
CKSUM1  JAL     R4,GETBC        : GET NEXT BYTE
        CHI     R0,RSYN         : IF A SYNC DON'T CHECKSUM IT
        JEFS    CKSUM2
        CRCACC(R6,R0,R7)        : CHECKSUM IT
CKSUM2  SIS     R5,1            : REDUCE BYTE CNT
        JG      CKSUM1          : REPEAT IF CNT NOT ZERO
        CRCEND(R6,R0,R7)        : FINISH CHECKSUM
        LR      R0,R6           : LEAVE CHECKSUM IN R0
        RETJ(R5)


: CKSUMX - CHECK SUM A MESSAGE IN TRANSPARENT MODE.
:       OUTPUT - R0 CONTAINS 2 BYTES OF CRC-16 CHECK SUM
:       USES   - R0,R4,R6,R7
:       LINK   - R5
:
CKSUMX  PUSH(R5)
        LR      R5,RBX
        AR      R5,RCNT                 :GET BYTE COUNT OF MSG
        SIS     R5,2                    :SUBTRACT FOR DLE STX
        LHI     RBX,-BBFLSZ+3           :SET OFFSET PAST DLE STX
        CRCINT(R6)                      :INIT THE CHECK SUM
CKSMX1  JAL     R4,GETBC                :GET CHAR
        CLHI    R0,RDLE                 :IS IT A DLE?
        JN      CKSMX2                  :N - JUMP
        SIS     R5,1                    :Y - IGNORE IT
        JAL     R4,GETBC                :GET CHAR AFTER DLE
        CLHI    R0,RSYN
        JE      CKSMX3                  :IGNORE DLE SYN
: IF CHAR AFTER DLE IS DLE, ETX, ETB, OR ITB,
: THEN CHECK SUM ONLY THE SECOND CHAR,
: ELSE CHECK SUM BOTH THE DLE AND THE SECOND CHAR.
        CLHI    R0,RDLE
        JE      CKSMX2
        CLHI    R0,RETX
        JE      CKSMX2
        CLHI    R0,RETB
        JE      CKSMX2
        CLHI    R0,RITB
        JE      CKSMX2
        LHI     R4,RDLE
        CRCACC(R6,R4,R7)
CKSMX2  CRCACC(R6,R0,R7)                :CHECK SUM IT
CKSMX3  SIS     R5,1                    :DECREMENT MSG COUNT
        JG      CKSMX1                  :REPEAT UNTIL END OF MSG
        CRCEND(R6,R0,R7)                :FINISH THE CHECK SUM
        LR      R0,R6                   :RETURN CHECK SUM IN R0
        RETJ(R5)
 

:       GETBC - GET NEXT CHAR FROM BUF. CHAIN
:       INPUT - RBA,RBX
:       OUTPUT- R0 = CHAR
:       LINK  - R4
GETBC   AIS     RBX,1           : ADVANCE OFFSET
        JNFS    GETBC1          : SKIP IF NOT AT END OF BUF.
        LR      RBX,RBA
        LHL     RBA,BBUFER+BBFLSZ-2,RBA,        : GET ADDR OF NEXT BUF.
        JNFS    .+6
        JAL     R10,CRASH,,
        LHI     RBX,-BBFLSZ+2   : INITIALIZE OFFSET
GETBC1  LB      R0,BBUFER+BBFLSZ-2,RBA,RBX      : GET THE CHAR
        JR      R4              : RETURN
 
:
: CRASH HERE IF NO BUFFER IF AVAILABLE WHEN TRYING TO GET ONE
:
PUTCR   JAL     R10,CRASH,,
        BC      0,0,4*RBA,99            :???NEED APPROPRIATE CODE
        SUBTTL	PBQUE-BISYNC MESSAGE BUILDING UTILITIES
:       UTILITY ROUTINES TO BUILD MSGS INTO QUEUES
:       QUEUES ARE "XMT" FOR HI AND TI
:       QUEUES ARE "XMT FOR HI AND TI, "IN" FOR TI
        SEG     1
        LO      BSCCHR
:
: CRASH HERE IF NO BUFFER IS AVAILABLE WHEN TRYING TO GET ONE
:
PBCRSH  JAL     R10,CRASH,,
        BC      0,0,4*RBA,99            :???NEED APPROPRIATE CODE HERE
:       
: ??? = XMT OR IN
:       PBM??? - PUT A CANNED MSG INTO BUF.
:       PBS??? - PUT A CANNED STRING INTO AN EXISTING BUF. CHAIN
:       PBC??? - PUT ONE CHAR INTO A BUF. CHAIN
:       PBH??? - START A MSG (PUT STX INTO BUF.)
:       PBE??? - END THE MSG (CHECKSUM AND GET BYTE)
 
:       COMMON REGISTER USAGE
:       INPUT - R1 POINTS TO CANNED MESSAGE STRING
:               R0 CHAR TO BE ADDED TO MSG
:               RBA CURRENT BUFFERLET ADDRESS
:               RBX CURRENT BUFFERLET OFFSET
:               RSUM ACCUMULATED CHECK SUM
:               R4 WORK
:               R5 LINK
:       PUTB1 = PBM??? + PBS???
:       PUTB2 = PBC??? + PBH??? + PBE???
 
 
PUTB    MACRO(QUE) [
        PUTB1(QUE)
        PUTB2(QUE)
]

PUTB1   MACRO(QUE) [
 
:       PBM`QUE - PUT A CANNED BISYNC MSG INTO BUFFER
:               R1 POINTS TO THE MSG STRING HMORD CNT , DATA
PBM`QUE PUSH(R5)
        LHL     R5,DIR0,RDCB,
        THI     R5,XPRBIT
        JN      PBM1`QUE        :JUMP IF TRANSPARENCY
        JAL     R5,PBH`QUE        : START THE MSG
        JAL     R5,PBS`QUE        : ADD THE STRING
        J       PBM2`QUE
PBM1`QUE        JAL     R5,PXH`QUE        :START THE MSG
        JAL     R5,PBS`QUE                :STORE MSG INTO BUFFER
        LHI     R0,RDLE
        JAL     R5,PBC`QUE                :INSERT DLE ETX
PBM2`QUE LHI     R0,RETX
        JAL     R5,PBC`QUE
        JAL     R5,PBE`QUE                :END THE MSG
        RETJ(R5)

 
:       PBS`QUE - PUT A CANNED STRING INTO BUF.
:               AS THE CHAR ARE PUT INTO THE MSG THEY ARE REVERSED
:       INPUT R1 AS FOR PUTBM
PBS`QUE   PUSH(R5)
        PUSH(R15)
        LIS     R15,0
          LB      R7,2,R1,R15     : GET NEXT BYTE
        LB      R0,REVTAB,R7    : REVERSE IT
        JAL     R5,PBC`QUE        : STORE IT
        AIS     R15,1           : ADVANCE INDEX
        CLH     R15,0,R1        : END OF STRING ?
        JL      .-14              :   N - REPEAT
        POP(R15)
        RETJ(R5)
 
 
:
: PBQ`QUE - GIVEN THE NUMBER OF DATA BYTES IN RBX, THIS SUBROUTINE WILL
:       SEND THIS CURRENT BUFFER AT RBA TO THE LIST (QUE), AND GET ANOTHER
:       BUFFER.  CAREFUL...R0 IS DESTROYED.
:       ALSO NOTE THAT RBX IS SET UP FOR IMMEDIATE STORAGE OF DATA. 
:       IF UPON RETURN, NO DATA BYTE IS TO BE STORED IMMEDIATELY,
:       THEN RBX SHOULD BE DECREMENTED.
:
PBQ`QUE PUSH(R5)
        AHM     RBX,CNT`QUE,RDCB,       :COMPUTE # OF DATA BYTES SENT SO FAR
        LHL     R0,DIR0,RDCB,           :GET CONTROL BYTE
        LHL     R5,DDEV,RDCB,           :GET DEVICE #
        PUTCMD(`QUE,R5,R5)
        IF      -HSTSWT
        LIS     R6,AMODE                :IF VIRTUAL TERMINAL MODE,
        CLB     R6,DMODE,RDCB,          :THEN RELEASE BUFFER IMMEDIATELY
        JE      PBQ2`QUE
        EI
        IF      DYNBUF
        LHL     R6,CNT`QUE,RDCB,        :IF # OF DATA BYTES EXCEEDS N0,
        CLH     R6,N0`QUE,RDCB,         :THEN OK TO RELEASE BUFFER,
        JLFS    PBQ2`QUE                :ELSE WAIT UNTIL SO
        EI
        RLCMD(`QUE,R5,R5)
PBQ2`QUE
        NHI     R0,@FIRBIT              :INSURE FUTURE BLOCKS NOT TAGGED AS 1ST
        STH     R0,DIR0,RDCB,
        JAL     R4,GBB,,                :GET ANOTHER BUFFER
        J       PBCRSH
        LHI     RBX,-BBFLSZ+2+BSXWSZ    :INIT OFFSET
        STH     RBA,DIRBA,RDCB,         :SAVE CURRENT BUFFER ADR
        RETJ(R5)  ]

PUTB2   MACRO(QUE) [

:
: PBC`QUE - PUT A CHAR INTO BUFFER.  IF BUFFER IS FULL, THEN PUT
:            BUFFER ONTO QUEUE AND GET ANOTHER BUFFER.  CHAR IS CHECKSUMMED.
:
PBC`QUE PUSH(R5)
        AIS     RBX,1           :INCREMENT BUFFER OFFSET
        IF      TSTSWT
        JGBS    .                       :LOOP IF INVALID OFFSET
        EI
        JL      PBC1`QUE                :JUMP IF BUFFER NOT FULL
        PUSH(R0)
        AHI     RBX,BBFLSZ-2-BSXWSZ     :DETERMINE # OF DATA BYTES IN BUFFER
        JAL     R5,PBQ`QUE              :SENT THIS BUFFER AND GET ANOTHER
        POP(R0)
PBC1`QUE        LHL     R4,DIR0,RDCB,
        THI     R4,XPRBIT               :JUMP IF TRANSPARENCY DATA
        JN      PBC3`QUE
        STB     R0,BBUFER+BBFLSZ-2,RBA,RBX, :STORE CURRENT CHAR
        CHI     R0,RSYN                 :IF SYN, THEN DO NOT CHECKSUM
        JEFS    PBC2`QUE
        CRCACC(RSUM,R0,R4)
PBC2`QUE        J       PBC6`QUE
:HANDLE TRANSPARENCY DATA
        SEG     0
PBCC`QUE        HS      NDEVB           :BIT ARRAY...1=PREVIOUS CHAR STORED WAS A DLE
        SEG     1
PBC3`QUE        STB     R0,BBUFER+BBFLSZ-2,RBA,RBX      :STOR CURRENT CHAR
                LHL     R5,DDEV,RDCB,   :GET DEVICE #
        RBT     R5,PBCC`QUE,,           :WAS PREVIOUS CHAR STORED A DLE?
        JN      PBC4`QUE                :Y -JUMP
        CHI     R0,RDLE                 :IS CURRENT CHAR A DLE?
        JN      PBC5`QUE                :N - GO STORE AND CHECKSUM
        SBT     R5,PBCC`QUE,,           :SET BIT TO INDICATE DLE DETECTED
        J       PBC6`QUE                :FINISH W/DLE FOR NOW
: PREVIOUS CHAR WAS A DLE...IF CURRENT CHAR IS DLE,ETX,ETB,OR ITB,
: THEN CHECKSUM ONLY THE CHRRENT CHAR, ELSE CHECKSUM BOTH THE DLE AND
: THE CURRENT CHAR. IF CURRENT CHAR IS SYN, THEN WE HAVE DLE SYN WHICH
: IS A TIME FILL SYNS INSERTION,HENCE DO NOT CHECKSUM EITHER CHAR.
PBC4`QUE        CHI     R0,RSYN         :IF SYN CHAR
                JE      PBC6`QUE        :THEN DO NOT CHECKSUM
                CHI     R0,RDLE
        JE      PBC5`QUE
        CHI     R0,RETX
        JE      PBC5`QUE
        CHI     R0,RETB
        JE      PBC5`QUE
        CHI     R0,RITB
        JE      PBC5`QUE
: THIS IS AN ABORTED SITUATION...SHOULD NOT GET DLE WITH THE FOLLOWING CHAR
: NOT DLE,ETX,ETB,ITB, OR SYN. FOR LACK OF BETTER METHOD TO DEAL WITH 
: THIS, THE DLE IS TREATED AS A DATA CHAR, HENCE IT IS CHECKSUM.
        PUSH(R0)
        LHI     R0,RDLE
        CRCACC(RSUM,R0,R4)
        POP(R0)
PBC5`QUE                                                :STORE CURRENT CHAR
        CRCACC(RSUM,R0,R4)                      :AND CHECKSUM IT
PBC6`QUE RETJ(R5)
 
 
:       PBH`QUE - START A MSG IN BUF. AND PUT STX
:       OUTPUT - RBA,RBX,RSUM
PBH`QUE   PUSH(R5)
        JAL     R4,GBB,,          : GET FIRST BUF.
        J       PBCRSH            : CRASH IF NOT AVAILABLE
        STH     RBA,DIRBA,RDCB,         :STORE CURRENT MSG BUFFER ADR
        LHL     R0,DIR0,RDCB,           
        OHI     R0,FIRBIT       : SET FIRST BIT
        STH     R0,DIR0,RDCB,
        LIS     R0,0
        STH     R0,CNT`QUE,RDCB,        :RESET COUNT
        LHI     RBX,-BBFLSZ+1+BSXWSZ+1   : INITIALIZE OFFSET
        CRCINT(RSUM)            :INITIALIZE CHECKSUM
        LHI     R0,RSTX         : GET REVERSE STX CHAR
        STB     R0,BBUFER+BBFLSZ-2,RBA,RBX      :PUT INTO BUFFER
        RETJ(R5)


: PXH`QUE - GET BUFFER TO START A BISYNC TRANSPARENCY MESSAGE
:          AND PUT A DLE STX INTO IT.
:       OUTPUT - RBA,RBX,RSUM
:       USES   - R0,R4,R6,R7
:       LINK   - R5
:
PXH`QUE  PUSH(R5)
        JAL     R4,GBB,,          :GET 1ST BUFFER OF MSG
        J       PBCRSH                    :CRASH IF NONE AVAILABLE
        STH     RBA,DIRBA,RDCB,         :STORE CURRENT MSG BUFFER ADR
        LHL     R0,DIR0,RDCB,
        OHI     R0,FIRBIT       :SET FIRST BIT
        STH     R0,DIR0,RDCB,
        LIS     R0,0
        STH     R0,CNT`QUE,RDCB,        :RESET COUNT
        LHL     R4,DDEV,RDCB,
        RBT     R4,PBCC`QUE,,           :RESET "PREVIOUS WAS DLE" FLAG
        LHI     RBX,-BBFLSZ+1+BSXWSZ+1         :INIT OFFSET
        CRCINT(RSUM)                    :INIT CHECKSUM
        LHI     R0,RDLE^8+RSTX          :CHEATING BY USING QUICK STORE
        STH     R0,BBUFER+BBFLSZ-2,RBA,RBX      :OF DLE AND STX
        AIS     RBX,1                   :READJUST OFFSET
        RETJ(R5)
  
 
:       PBE`QUE - END THE MSG IN BUF.
PBE`QUE   PUSH(R5)
        LIS     R4,0
        STH     R4,DIRBA,RDCB,          :CLEAR CURRENT BUFFER ADR
        CRCEND(RSUM,R0,R4)
        LR      R0,RSUM         :PUT FINAL CHECKSUM INTO R0
        EXBR    R0,R0           : GET FIRST BYTE INTO PLACE
        JAL     R5,PBC`QUE        : STORE IT
        EXBR    R0,R0           : GET SECOND BYTE INTO PLACE
        JAL     R5,PBC`QUE        : STORE IT
        AHI     RBX,BBFLSZ-2-BSXWSZ+1   :GET BYTE COUNT
        AHM     RBX,CNT`QUE,RDCB,       :COUNT TOTAL BYTES IN CURRENT MSG
        LIS     R5,0
        STH     R5,DIRBA,RDCB,          :CLEAR CURRENT BUFFER ADR.
        RETJ(R5)
]


        PUTB(XMT)
        IF      -HSTSWT
        PUTB(IN)
        EI
        SUBTTL  DOBP - BACK PRESSURE HANDLER
        SEG     1
:       INIT. B.P. TIMER
INITBP  PUSH(R5)
        L       R7,FASTC,,      : GET CURRENT TIME
	LA	R0,CKBP		:PUT RELBP ON TIMEOUT LIST
	LHI	R1,RATE/2,R7	:SET HALF SECOND TIMEOUT
	JAL	R5,TOPUT,,	:
        RETJ(R5)
:
:
:		CODE TO PERIODICALLY CHECK IF BACKPRESSURE CAN
:		BE RELEASED ON ANY PORTS
CKBP    AHI     R1,RATE/2       : GET NEXT RUN TIME
	JAL	R5,TOPUT,,	:PUT BACK ON TIMEOUT LIST FOR ONE SECOND
:
:	CHECK ALL PORTS FOR BACKPRESSURE APPLIED
:
	LHI	R5,(NGRP-1)*2	:
	LHI	R6,(NGRP-1)*10	:SET UP POINTERS
RBP1	LCS	R7,1		:
	XH	R7,FRISIS,R5,	:CHECK IF BACKPRESSURE APPLIED
	NH	R7,ACP,R5,	:AND PORT ACTIVE
RBP2	LR	R1,R7		:TEST
	JNFS	RBP3		:SKIP.. SOMETHING TO DO
	SIS	R5,2		:DECREMENT POINTERS
	SHI	R6,10		:
	JGEBS	RBP1		:CHECK NEXT RING GROUP
	J	TORET,,		:OTHERWISE RETURN
:
RBP3	JAL	R3,BIDH,,		:DETERMINE WHICH PORT ON GROUP NEEDS SERVICE
	XH	R7,HMASK,R2,R2	:MARK PORT AS SERVICED
	AR	R2,R6		:FORM PORT NUMBER
	LR	RPORT,R2		:COPY IT
	SLHLS	R2,2		:FORM BUFFER NUMBER
	LHL	RDCB,PORTAB,RPORT,RPORT	:GET DCB POINTER FROM PORT TABLE
        LHL     RDEV,DDEV,RDCB, : GET DEVICE NUMBER
        IF      HSTSWT
        LHL     R0,DCXMT,RDEV,RDEV      : GET DATA USE CNT(IN Q)
        ELSE
        LHL     R0,DCIN,RDEV,RDEV       : GET DATA USE CNT(IN Q)
        LH      R4,DPDEV,RDCB,  : GET PHYS. DEV. NO.
        JL      RBP2            :   NONE - DONT REL. B.P.
        AH      R0,DCXMT,R4,R4  : ADD DATA USE CNT IN XMT Q
        EI
        CI      R0,DCREL        : COMPARE TO REL. LIMIT
        JG      RBP2            : IF GREATER , DONT RELEASE
	SBT	RPORT,FRISIS,,	:RELEASE BACKPRESSURE
	LIS	R0,3		:FORM 3 BYTE MESSAGE
	LHI	R2,SNDMSG	:GET MESSAGE
	JAL	R4,SLOR,,		:START LOGICAL OUTPUT RECORD
	JAL	R4,ELOR,,		:END IT
	J	RBP2		:AND CONTINUE
 
:       TEST AND SET B.P.
TSBP    PUSH(R5)
        LHL     R5,DDEV,RDCB,   : GET DEV. NO.
        IF      HSTSWT
        LHL     R0,DCXMT,R5,R5  : GET IN Q USE CNT
        ELSE
        LHL     R0,DCIN,R5,R5   : GET IN Q USE CNT
        LH      R4,DPDEV,RDCB,  : GET PHYS. DEV. NO.
        JL      TSBP20          :   NONE - SET B.P.
        AH      R0,DCXMT,R4,R4  : ADD XMT Q USE CNT
        EI
        CI      R0,DCSET        : COMPARE TO SET B.P. LIMIT
        JL      TSBP30          :   LESS - DONT SET B.P.
TSBP20  PUSH(R2)
        PUSH(R3)
        PUSH(R1)
        LHL     R1,DPORT,RDCB,
        LIS     R0,3            : SEND SET B.P. MSG
        LHI     R2,NOSMSG
        JAL     R4,SLOR,,       : START MSG
        JAL     R4,ELOR,,       : END MSG
        RBT     R1,FRISIS,,       : SET B.P. TOWARD ISIS FLAG
        POP(R1)
        POP(R3)
        POP(R2)
TSBP30  RETJ(R5)
 
        SUBTTL   RCV QUEUE PROCESSING ROUTINES
 
        SEG     1
RRX     EQ      R6                      : HWORD INDEX REGISTER FOR RSCAN
:       RSCAN - SCAN RCV QUEUE FOR CMDS
:       CALLED FROM EXEC LOOP
:       USES DRDRA ROUTINE ADDRESS IN DCB TO PROCESS CMD
:       LINK - R5
RSCAN   PUSH(R5)
        LHI     RRX,(NDEVB-1)*2         : INIT INDEX TO HWORDS
RSCA10  LHL     R1,RCVDAT,RRX,          : GET DATA PRESENT FLAGS
        NH      R1,RCVGAT,RRX,          : MASK WITH GATE FLAGS
        JE      RSCA50                  :   EMPTY - NEXT HWORD
        STH     R1,RSCA80,,             : SAVE FLAGS
        SLHLS   RRX,3                   : GET NO. OF FIRST DEV. IN HWORD
        STH     RRX,RSCA90,,            : SAVE IT
RSCA20  JAL     R3,BIDH,,               : FIND NEXT DEV. WITH DATA PRES.
        RBT     R2,RSCA80,,             : TURN OFF CURRENT BIT IN SAVED FLAGS
        AH      R2,RSCA90,,             : R2 = DEVICE NO.
        LR      RDEV,R2                 : PUT DEVICE NO. IN RDEV
RSCA30  PKCMD(RCV,RDEV,RDEV)
        JE      RSCA40                  :   EMPTY - NEXT DEVICE (WITH DATA)
        LHL     R7,DEVTAB,RDEV,RDEV     : GET DCB
        LHL     R6,DIRBA,R7,           : ANY DATA IN XMT BUFFER?
        JN      RSCA40                  : Y - HOLD CMD IN RCV QUEUE
        ADVCMD(RCV,RDEV,RDEV)           : FLUSH CMD
        LHL     RDCB,DEVTAB,RDEV,RDEV   : GET DCB ADDR
        LHL     R5,DRDRA,RDCB,          : GET PROC. ROUTINE ADDR.
        JAL     R5,PSEG,R5,             : CALL IT
        J       RSCA30                  : GO BACK FOR NEXT CMD
RSCA40  LHL     R1,RSCA80,,             : RESTORE FLAGS
        JN      RSCA20                  : REPEAT UNTIL HWORD IS EMPTY
        LHL     RRX,RSCA90,,            : RESTORE FIRST DEV. IN HWORD
        SRHLS   RRX,3                   : MAKE RRX INDEX TO HWORD AGAIN
RSCA50  SIS     RRX,2                   : NEXT HWORD
        JGE     RSCA10                  : REPEAT FOR EACH HWORD
        RETJ(R5)
 
        SEG     0
RSCA80  HS      1                       : SAVE FLAG HWORD HERE
RSCA90  HS      1                       : SAVE SHIFTED HWORD INDEX HERE


LCMMODE HS      NDEVB                   :BIT ARRAY...1=FG TELLS BG WE ARE IN LCM
        SEG     1

:       RDP - CMD IN RCV QUEUE  - DEVICE IS IN PASS-THRU MODE
:       INPUT - RDEV,RDCB   LINK - R5
RDP     PUSH(R5)
        LH      R1,DLDEV,RDCB,          : GET LOGICAL DEVICE NO.
        JL      RDP20                   : DUMP MSG IF NO LOG. DEV.
        LR      R2,R2                   : DATA OR CTL CMD ?
        JL      RDP10                   :    CTL - COPY TO OUTPUT QUEUE
        THI     R0,FIRBIT               : FIRST SEGMENT OF MSG ?
        JE      RDP10                   :   N - COPY IT
        IF      TWOPF
        LB      R5,DEVLN,RDEV,          :R5=LINE NUMBER
        LHL     R7,DEVTAB,R1,R1         :R7=DCB
        LIS     R6,D.NSRV                :HAS ONE NETKEY BEEN HIT?
        RBT     R6,DFLAGS,R7,
        JE      RDP05                   :NO
:
:IF NET KEY SEND THIS MESSAGE ON
:
        LB      R7,BBUFER+3,R3,         :GET AID
:NETKEY, PFMEN1... LOG OFF AND INITIATE LOGON TO THE FIRST DESTINATION IN MENU.
:NETKEY, PFMEN2... LOG OFF AND INITIATE LOGON TO THE SECOND DESTINATION IN MENU.
:NETKEY, PFMEN ... LOG OFF AND GET THE MENU SCREEN
:NETKEY, NETKEY... SEND NETKEY TO HOST
:OTHER.... GET NETWORK SERVICE
        CHI     R7,PFMEN1               
        JE      RDP50
        CHI     R7,PFMEN2               
        JE      RDP60
        CHI     R7,PFMEN                :DISPLAY MENU SCREEN
        JE      RDP70
        CLB     R7,PFNET,R5,
        JE      RDP10                   :SEND THE MESSAGE ON
        J       RDP40                   :NOT NET-KEY SEND ON
: PROBLEM...RACE CONDITION WHEN THE HOST SENDS A READ MODIFY COMMAND,
: AND THE RESPONSE FROM THE TERMINAL IS A NETWORK SERVICES KEY.
: WAS THE KEY STRUCK FOR THE HOST TO READ, OR FOR NETWORK SERVICES?
: THIS WOULD NOT BE A PROBLEM IF THE TERMINAL INTERFACE WAS GOING TO
: A HOST INTERFACE WITH SAVEQ=1.
: PARTIAL SOLUTION...ASSUME NETWORK SERVICES WAS REQUESTED IN LCM
: IS FOR THE HOST (AND NOT FOR NETWORK SERVICES).
RDP05   RBT     RDEV,LCMMODE,,          :LIMITED CONVERSATIONAL MODE?
        JN      RDP10                   :Y - PASS "KEY" TO HOST
:
: IF NETKEY SET BIT AND TRASH IT
:
        LB      R6,BBUFER+3,R3,         :GET AID
        CLB     R6,PFNET,R5,
        JN      RDP10                     :NOT THE NET KEY
        LIS     R6,D.NSRV
        SBT     R6,DFLAGS,R7,           :SET FLAG FOR NEXT INPUT
RDP07   JAL     R5,PBBC,,               :GET RID OF THE BUFFER
        LA      R1,UNLKB,,              :SEND AN UNLOCK KEYBOARD
        JAL     R5,XNMSG
        RETJ(R5)
        ELSE
        LB      R6,BBUFER+3,R3,         : GET AID CHAR
        LB      R7,DEVLN,RDEV           : GET LINE NUMBER
        CLB     R6,PFNET,R7             : NET MODE KEY FOR THIS LINE ?
        JE      RDP40                   :   Y - ENTER NET MODE
        EI
RDP10   PUTCMD(OUT,R1,R1)               : COPY CMD TO OUTPUT QUEUE
        RLCMD(OUT,R1,R1)
        RETJ(R5)
 
:       NO LOGICAL DEVICE - DUMP CMD
RDP20   LR      R2,R2
        JLFS    RDP30                   : IF DATA CMD FREE BUF.
        JAL     R5,PBBC,,
RDP30   RETJ(R5)
 
:       RDP40 - SEND READ BUFFER CMD TO STORE DATA IN TERMINAL
:               SCREEN.  SET UP RTE. ADR.
RDP40   LHL     R7,DEVTAB,R1,R1         : GET LOG. DEVICE DCB ADDR.
        LB      R6,DLFLD,R7,            :GET CURRENT STATE
        CHI     R6,L.PN                 :WAITING FOR PSEUDO-NEEDLE?
        JE      RDP10                   :   Y - JUST COPY MSG TO OUT Q
        JAL     R5,PBBC,,               : GET RID OF THE BIG BUFFER
        LA      R1,MSG2                 : SEND READ BUFFER CMD
        JAL     R5,XNMSG                : TO TERMINAL
        LI      R6,RDP80-PSEG           : STORE RTE. ADR.
        STH     R6,DRDRA,RDCB,
        RETJ(R5)


: RDP50 & RDP60 - LOG OFF CURRENT CIRCUIT AND LOG ONTO FIRST OR
: SECOND DESTINATION ON MENU SCREEN, DEPENDING ON ENTRY POINT
:
	IF	TWOPF
RDP50   LIS     R5,0                    :SET FIRST MENU DESTINATION
        JFS     RDP65
RDP60   LIS     R5,1                    :FOR SECOND MENU DESTINATION
RDP65   STH     R5,MENCHC,,
        LHL     R1,DEVMAP,RDEV,RDEV     :GET MENU FOR THIS DEVICE
        SLLS    R1,2                    :MAKE IT FULL WORD
        LHL     R5,MENUS+2,R1,           :INDEX TO MSTRS OF FIRST LOGON STRING
        STH     R5,DLSTR,RDCB,          :STORE IT
	LB	R5,MENUS,R1,		:NUMBER OF LOGON STRINGS
	STB	R5,DLCNT,RDCB,		:STORE IT FOR LATER
	LHL	R5,MENCHC,,		:GET MENU CHOICE NUMBER
	CLB	R5,DLCNT,RDCB,		:IS THERE ENOUGH CHOICES ON MENU
	JGE	RDP07			:IF NOT TRASH MESSAGE
	LA	R1,LEM15,,		:CLEAR SCREEN
	JAL	R5,XLERM,,
	JAL	R5,ZAP0,,		:ZAP CURRENT CIRCUIT
	LIS	R5,0			
	STB	R5,DLROW,RDCB,		:START AGAIN AT ROW ZERO
	STH	R5,MENFLG,,		:TELL STLOG NOT TO DISPLAY MENU
	JAL	R5,STLOG,,		:START LOGON PROCESS
	LHL	R1,MENCHC,,  		:SET UP R1 FOR 1ST OR 2ND MENU DESTINATION
	JAL	R5,MEN020,,		:GO DO LOGON
	RETJ(R5)

:	RDP70 - LOG OFF CURRENT CIRCUIT AND DISPLAY MENU SCREEN

RDP70	
	JAL	R5,ZAP0,,		:ZAP CURRENT CIRCUIT
	JAL	R5,STLOG,,		:START LOGON PROCESS
	RETJ(R5)
	EI


:
:       RDP80 - STORE DATA IN SAVEQ AND DISPLAY NSS
:
RDP80   LR      R2,R2
        JLE     RDP87                   : NOT SAVE IF COMMAND
        J       RDP84
RDP83   ADVCMD(RCV,RDEV,RDEV)
RDP84   PUTCMD(SAV,RDEV,RDEV)
        PKCMD(RCV,RDEV,RDEV)
        THI     R0,ETXBIT               : LAST BLOCK?
        JN      RDP85                   :Y - RELEASE IT.
        LR      R2,R2                   : ANY MORE DATA?
        JG      RDP83                   : Y - C0NTINUE
        J       RDP87
RDP85   RLCMD(SAV,RDEV,RDEV)
        JAL     R5,NETPAT               : SET LOG.-PHYS. PATH
        JAL     R5,XNET                 : DISPLAY NETWORK SERVICE SCREEN
RDP87   RETJ(R5)






:	IZMFLG - INITIALIZE MENU FLAG TO -1

IZMFLG  TS      MENFLG,,                :SET MENU FLAG TO -1
	JR	R5

:	MENU FLAG IS -1 IF MENU IS TO BE DISPLAYED BY STLOG
:	AND IS ZERO IF MENU NOT TO BE DISPLAYED

	SEG	0
MENFLG	HC	-1
MENCHC	HS	1			:0 OR 1 FOR FIRST OR SECOND
					:MENU DESTINATION
	SEG	1

:
: XNET - DISPLAY NETWORK SERVICES SCREEN WITH CRT STATUS AND
:        LIST OF PRINTERS.  ALSO SET RCV ROUTINE DISPATCH ADDRESS.
:
XNET    PUSH(R5)
        LI      R6,RDN-PSEG             : GET NET MODE PROC. RTE ADDR
        STH     R6,DRDRA,RDCB,          : SET RCV RTE ADDR IN DCB
        LA      R1,NETSCN               : SEND NET MODE SCREEN
        JAL     R5,XNMSG
        JAL     R5,XMNET                : DISPLAY MORE INFO. ON NET S.SCREEN
        JAL     R5,XUPNET               : DISPLAY CRT AND PRINTER STATUS
        RETJ(R5)
:
: XUPNET - DISPLAY UPDATED STATUS OF CRT AND PRINTERS
:          FOR THE NETWORK SERVICES SCREEN
:
XUPNET  PUSH(R5)
        TBT     RDEV,DEVBUSY,,          :IS CRT BUSY?
        JEFS    XNET10
        LA      R1,NETS1,,              :Y - SEND "CRT IS LOGGED IN"
        JFS     XNET20
XNET10  LA      R1,NETS6,,              :N -SEND "CRT NOT LOGGED IN"
XNET20  JAL     R5,XNMSG
        JAL     R5,XPRTRS               :DISPLAY THE PRINTERS
        RETJ(R5)
:
: DISPLAY MORE INFORMATION IN NET WORK SERVICE SCREEN
: XMNET - DISPLAY NODE #, SLOT # LINE #, CU ADR. AND DEV ADR.
:
XMNET   PUSH(R5)
        LHL     R1,NODEX,,              :NODE #
        NHI     R1,0FFF                 : DELETE UNWANT BITS
: (NODEX)HEX --->(NODEX)OCT.
        LIS     R5,4
XMNE10  LR      R6,R1
        NHI     R6,7
        OHI     R6,0F0                  :CHANGE TO EBCDIC CODE
        STB     R6,NETS7A+5,R5,          :INSERT LAST DIGIT TO BUFFER
        SRHLS   R1,3                    :FOR NEXT DIGIT
        SIS     R5,1
        JGBS    XMNE10                  :CONTINUE IF NOT DONE
        LHL     R1,SLOTNO,,             :GET SLOT # AND INSERT IT INTO BBUFER
        OHI     R1,0F0
        STB     R1,NETS7A+13,,
        LB      R1,DEVLN,RDEV,          :GET LINE # AND DISPLAY IT
        OHI     R1,0F0
        STB     R1,NETS7B+6,,
        LR      R5,RDEV
        SLLS    R5,2
        LB      R1,DEVLA+1,R5,           :GET CU ADR.
        STB     R1,NETS7B+13,,           :INSERT IT
        LB      R1,DEVLA+2,R5,          :GET DEV ADR.
        STB     R1,NETS7B+20,,
        LA      R1,NETS7,,                :DISPLAY THIS MESSAGE
        JAL     R5,XNMSG
        RETJ(R5)
        

:
: XPRTRS - DISPLAY THE PRINTER INFORMATION IN THE NETWORK SERVICES SCREEN
:       R5 - LINK
:       RDEV - DEVICE # OF CRT
:       RDCB - DCB OF CRT
:       R1,R2,R3,R4,R5,R6,R7,R9,R10,R13,R14,R15 - WORK (DESTROYED)
:
XPRTRS  LB      R15,DEVCU,RDEV,         :GET CU# FOR THIS DEVICES
        LB      R0,CUPTR,R15,R15         :GET # OF PRINTERS FOR THIS CU
        JER     R5                      :IF NONE - RETURN
:
: THERE ARE PRINTERS TO BE DISPLAYED...
:
        PUSH(R5)
        LHL     R0,DIR0,RDCB,           :SAVE REAL CONTROL BYTES
        PUSH(R0)
        LHI     R0,FIRBIT
        STH     R0,DIR0,RDCB,
        JAL     R5,PBHXMT               :GET MSG BUFFER W/ STX INSERTED
        LA      R1,NETS2,,              :INSERT ESC,WCMD,WCC
        JAL     R5,PBSXMT
        LIS     R13,0                   :INDEX INTO PTRDEV
:
: INSERT EACH PRINTER INFO INTO MSG BUFFER
:
XPRT10  LB      R14,CUPTR+1,R15,R15     :GET INDEX TO PRINTERS
        LB      R14,PTRDEV,R13,R14       :GET PRINTER DEVICE #
        LB      R0,ROWADR+12,R13,R13       :INSERT ROW ADR
        STB     R0,NETS3A,,
        LB      R0,ROWADR+13,R13,R13     
        STB     R0,NETS3A+1,,
        CLHI    R13,0A                  :INSERT PRINTER NUMBER
        JGE     XPRT20
        LHI     R0,N0.
        AR      R0,R13
        STB     R0,NETS3B,,
        LHI     R0,SP.
        STB     R0,NETS3B+1,,
        J       XPRT30
XPRT20  LHI     R0,N1.
        STB     R0,NETS3B,,
        LR      R0,R13
        AHI     R0,N0.-0A
        STB     R0,NETS3B+1,,
XPRT30  LR      R5,R14                   :INSERT PRINTER POLLING ADR
        SLLS    R5,2
        LB      R0,DEVLA+2,R5,
        STB     R0,NETS3C,,
        LA      R1,NETS3,,              :INSERT ROW ADR, #, POLL ADR
        JAL     R5,PBSXMT
        TBT     R14,DEVBUSY,,            :INSERT IDLE/BUSY STATUS INTO BUFFER
        JNFS    XPRT40
        LA      R1,NETS4,,              :"IDLE"
        JFS     XPRT50
XPRT40  LA      R1,NETS5,,              :"BUSY"
XPRT50  JAL     R5,PBSXMT
        LHL     R1,PTRMAP,R14,R14         :GET INDEX TO PRINTER LABEL
        CLI     R1,0FFFF                :ANY LABEL FOR THIS PRINTER?
        JE      XPRT70                  :N - GO TO NEXT PRINTER
        LIS     R10,0
XPRT60  LB      R5,PTRLAB+1,R1,R10      :GET CHAR IN LABEL
        NHI     R5,7F                   :STRIP OFF PARITY BIT
        LB      R5,ASCEBC,R5            :CONVERT FROM ASCII TO EBCDIC
        LB      R0,REVTAB,R5            :REVERSE ITS BITS
        JAL     R5,PBCXMT                :PUT IT INTO THE MSG BUFFER
        AIS     R10,1
        CLB     R10,PTRLAB,R1,
        JLBS    XPRT60                  :REPEAT UNTIL LABEL IS FINISHED
XPRT70  AIS     R13,1
        CLB     R13,CUPTR,R15,R15       :(COMPARE W/ # PTRS FOR THIS CU)
        JL      XPRT10                  :REPEAT UNTIL ALL PRINTERS DONE
:
: SEND THE PRINTERS INFOR TO THE NETWORK SERVICES SCREEN
:
        LHI     R0,RETX                 :INSERT ETX INTO MSG BUFFER
        JAL     R5,PBCXMT
        JAL     R5,PBEXMT                :END THE BISYNC MSG
        LHL     R0,DIR0,RDCB,
        OHI     R0,ETXBIT
        PUTCMD(XMT,RDEV,RDEV)
        RLCMD(XMT,RDEV,RDEV)
        POP(R0)
        STH     R0,DIR0,RDCB,           :RESTORE REAL CONTROL BYTES
        RETJ(R5)

:       RDN - PROCESS CMD IN RCV QUEUE
:       DEVICE IN NET MODE
:       INPUT - RDEV , RDCB  LINK - R5
RDN     PUSH(R5)
        LR      R2,R2                   : DATA OR CTL CMD ?
        JL      RDN10                   :   CTL - CHECK FOR ERR OR STATUS
        THI     R0,FIRBIT               :   DATA- FIRST SEGMENT ?
        JE      RDN30                   :          N - DUMP IT
        LB      R6,BBUFER+3,R3,         : FIRST SEGMENT - GET AID CHAR
        CHI     R6,AIDCLR               : CLEAR KEY ?
        JE      RDN70                   :   Y - EXIT NET MODE
        CHI     R6,AIDPF2               : PF 2 KEY ?
        JE      RDN40                   :   Y - LOG ON PRINTER
        CHI     R6,AIDPF1               : PF 1 KEY ?
        JE      RDN50                   :   Y - LOG OFF CRT
        CHI     R6,AIDPF3               : PF 3 KEY ?
        JE      RDN60                   :   Y - LOGOFF PRINTER
        JAL     R5,PBBC,,               : OTHER KEY - FREE BUF.
        LA      R1,NETS10,,             :RESET CURSOR AND TRY AGAIN
        J       RDN200
 
RDN10   CHI     R2,ERRCMD               : CTL CMD - IS IT ERR ?
        JE      RDN95                   :   Y - EXIT NET MODE
        CHI     R2,STACMD               : STATUS CMD ?
        JE      RDN95                   :   Y - EXIT NET MODE
        RETJ(R5)                        : OTHER CTL CMD - DUMP IT
 
RDN30   JAL     R5,PBBC,,               : NON-FIRST DATA MSG SEGMENT
        RETJ(R5)                        : FLUSH IT AND RETURN
 
:
: LOG ON PRINTER
:
RDN40   JAL     R5,GETPD                : GET PRINTER DEVICE NUMBER
        JAL     R5,PBBC,,               : FREE BUF.
        LR      R6,R0                   : SET PRTR DEVICE COND. CODE
        JL      RDN120                  :   N - SEND ERR MSG
        LHL     R7,DEVTAB,R6,R6         : GET PRTR DCB
        CLH     R6,DLDEV,R7,            : IS PRTR BEING CONNECTED BY SOMEONE ELSE?
        JN      RDN130                  :   Y - SEND ERR MSG
        TBT     R6,DEVBUSY,,            :PRINTER ALREADY CONNECTED?
        JN      RDN140                  :Y - SEND ERROR MSG
        JAL     R5,PCPATH               : SET LOG-PHYS DEVICE PATH
        LI      R6,RDP-PSEG             : RESET RCV. SCANNER
        STH     R6,DRDRA,RDCB,
        PUSH(RDEV)
        PUSH(RDCB)
        LH      RDEV,DLDEV,RDCB,        : GET PTR. DEV. NO.
        LHL     RDCB,DEVTAB,RDEV,RDEV   : GET ITS DCB PTR.
        JAL     R5,OID,,                :SET UP MENU SCREEN FOR PRTR LOGON
        POP(RDCB)
        POP(RDEV)
        RETJ(R5)
:
: LOG OFF CRT
:
RDN50   LR      R6,RDEV         : PUT THIS DEV. NO INTO R6
        J       RDN65           : AND HANDLE LIKE PRINTER LOGOFF
 
:       LOGOFF PRINTER
RDN60   JAL     R5,GETPD        : GET PRINTER ADDR AND DEV. NO.
        LR      R6,R0           : WAS THE SPECIFIED ADDR. FOUND
        JGE     RDN65           :   Y - SKIP
        JAL     R5,PBBC,,       :   N - FREE BUF.
        J       RDN120          :       AND SEND ERROR MSG
 
:       DEVICE FOUND
RDN65   PUSH(R6)
        JAL     R5,PBBC,,
        POP(R6)
        TBT     R6,DEVBUSY,,    : IS THE DEVICE LOGGED IN ?
        JE      RDN110          :   N - SEND ERROR MSG
        PUSH(RDEV)              :   Y - SAVE CRT DEV.NO.
        LIS     R0,DZ.3         :"DROPPED BY USER" REASON CODE
        STB     R0,DZAP,RDCB,   :STORE FOR DISCONNECT MSG
        LR      RDEV,R6         :       GET SPECIFIED DEV. NO.  IN RDEV
        LHL     RDCB,DEVTAB,R6,R6       :GET DCB OF DEVICE TO BE LOGGED OFF
        JAL     R5,NZAP         : ZAP THE CIRCUIT
        POP(RDEV)               : RESTORE CRT DEV. NO.
        LHL     RDCB,DEVTAB,RDEV,RDEV   :GET DCB OF CRT
        LA      R1,NETS20,,     : SEND UNLOCK KBD MSG TO CRT
        J       RDN200
 
:       EXIT NET MODE
:       OCCURS WHEN CLR KEY TYPED OR ERROR OR STATUS CMD FOUND
:       RETURN DATA IN SAVEQ TO TERMINAL SCREEN IF ANY
RDN70   JAL     R5,PBBC,,       : FREE BUF.
        PKCMD(SAV,RDEV,RDEV)
        JE      RDN75
:       STORE CURSOR POSITION
        LIS     R5,4
        LB      R0,BBUFER,R3,R5
        STB     R0,CUSRST+3
        LB      R0,BBUFER+1,R3,R5
        STB     R0,CUSRST+4
RDN75   LHI     R0,FIRBIT
        STH     R0,DIR0,RDCB,
        JAL     R5,PBHXMT       : BUILD HEADER
        LA      R1,MSG6         : CLEAR SCREEN + UNLOCK KEYBOARD
        JAL     R5,PBSXMT       
        LIS     R1,6            : DATA COUNT,VALID DATA START FROM BYTE 6
        STH     RBX,RDNSR2      : STORE XMTQ INDEX
        STH     RBA,RDNSR3      : STORE XMTQ B.A.
RDN77
        PKCMD(SAV,RDEV,RDEV)
        JE      RDN92           : N - EXIT
        STH     R3,SAVHED       : SAVE BUFFER HEAD OF SAVEQ
        STH     R3,SAVBUF               : STORE SAVEQ BUFFER POINT
RDN80   LHL     R3,SAVBUF               : GET SAVEQ BUFFER POINTER
        LB      R5,BBUFER,R3,R1 :PUT DATA IN SAVEQ TO XMTQ
        LB      R0,REVTAB,R5    :REVERSE IT
        CHI     R0,RETX         
        JE      RDN88           : EXIT IF LAST DATA
        CHI     R0,RETB
        JN      RDN82
        ADVCMD(SAV,RDEV,RDEV)
        LHL     R3,SAVHED       :RELEASE SAVEQ BUFFER POINTER
        JAL     R5,PBBC,,
        LIS     R1,1            :RESET COUNTER
        J       RDN77
RDN82
        PUSH(R0)
        LH      RBX,RDNSR2
        LHL     RBA,RDNSR3
        JAL     R5,PBCXMT
        STH     RBX,RDNSR2
        STH     RBA,RDNSR3
        POP(R0)
        LHL     R3,SAVBUF
        AIS     R1,1
        CHI     R1,BBFLSZ-3     : BBUFER LIMIT?
        JLE     RDN80           : CONTINUE IF NOT
        LIS     R1,0            : RESET COUNTER
        LHL     R3,BBUFER+BBFLSZ-2,R3,   : GET NEXT POINTER
        JEFS    RDN83           : CRASH IF NO BBUFER
        STH     R3,SAVBUF       : STORE SAVEQ BUFFER POINTER
        J       RDN80
RDN83   JAL     R10,CRASH,,     : PROG. BUG
RDN88   ADVCMD(SAV,RDEV,RDEV)
        LHL     R3,SAVHED       : RELEASE SAVEQ BUF. POINTER
        JAL     R5,PBBC,,
RDN92   LH      RBX,RDNSR2
        LHL     RBA,RDNSR3
: restore cursor position
        LA      R1,CUSRST
        JAL     R5,PBSXMT
        LHI     R0,RETX
        JAL     R5,PBCXMT
        JAL     R5,PBEXMT
        LHL     R0,DIR0,RDCB,
        OHI     R0,ETXBIT
        PUTCMD(XMT,RDEV,RDEV)
        RLCMD(XMT,RDEV,RDEV)
        RBT     RDEV,LCMMODE,,  : TO ALLOW NEXT NSS
        JFS     RDN98
RDN95   JAL     R5,FRESAV
        JAL     R5,XASCN,,      : SEND INITIAL ASCII SCREEN TO USER
RDN98   JAL     R5,XNPATH       : RESET LOG.-PHYS. DEVICE PATH
        LI      R6,RDP-PSEG     : SET RCV RTE. ADDR. TO PASS-THRU MODE
        STH     R6,DRDRA,RDCB,
        RETJ(R5)



        SEG     1

:       ZAPRTE - TABLE OF ZAP ROUTINE ADDRS. BY MODE
ZAPRTE  HC      IZAP-PSEG       : IDLE MODE
        HC      LZAP-PSEG       : LOGON MODE
        HC      AZAP-PSEG       : ASCII (VIRT.TERM.) MODE
        HC      NZAP-PSEG       : NATIVE MODE ZAP
 
:       GET ERR MSG ADDRESSES AND SEND TO USER
RDN110  LA      R1,NETS30       :"DEVICE NOT LOGGED ON"
        J       RDN200
 
RDN120  LA      R1,NETS40       :"CURSOR IN WRONG POSITION"
        J       RDN200
 
RDN130  LA      R1,NETS50       :"SOMEONE  ELSE IS LOGGING PTR IN"
        J       RDN200

RDN140  LA      R1,NETS60,,     :"PRINTER ALREADY CONNECTED"
        J       RDN200

 
:       SEND MSG AND EXIT
RDN200  PUSH(R1)
        LA      R1,NETSCN       :REFRESH NETWORK SERVICES SCREEN
        JAL     R5,XNMSG
        JAL     R5,XMNET                :DISPLAY MORE INFO. ON NETWORK S. SCREEN
        JAL     R5,XUPNET               :DISPLAY UPDATED STATUS
        POP(R1)
        JAL     R5,XNMSG        : BUILD AND SEND MSG
        RETJ(R5)

:       XNMSG - BUILD AND SEND MSG TO TERMINAL
XNMSG   PUSH(R5)
        LHI     R0,FIRBIT       :SET FIRST BIT FOR MSG
        STH     R0,DIR0,RDCB,
        JAL     R5,PBMXMT       : BUILD BISYNC MSG
        LHL     R0,DIR0,RDCB,   : GET CONTRO BITS
        OHI     R0,ETXBIT        :SET CONTROL BITS OF MSG
        PUTCMD(XMT,RDEV,RDEV)
        RLCMD(XMT,RDEV,RDEV)
        RETJ(R5)

:       NETPAT - SET LOGICAL - PHYSICAL DEVICE PATH FOR NET MODE
:       INPUT - RDEV,RDCB  WORK R4,R6 LINK R5
NETPAT  LHL     R6,DLDEV,RDCB,  : GET CURRENT LOG. DEV.
        LHL     R7,DEVTAB,R6,R6 : AND ITS DCB
        STH     R6,DPDEV,R7,    : RESET ITS LOG. AND PHYS. DEV. NOS.
        STH     R6,DLDEV,R7,
        LCS     R7,1            : NOW SET LOG. AND PHYS DEV FOR RDEV=-1
        STH     R7,DLDEV,RDCB,
        STH     R7,DPDEV,RDCB,
        JR      R5
 
:       PCPATH - SET LOG.-PHYS. PATH FOR PRINTER CONNECT
PCPATH  
        PUSH(R1)
        PUSH(R2)
        PUSH(R3)
        PUSH(R5)
:       INSERT SET B.P. HERE
        POP(R5)
        POP(R3)
        POP(R2)
        POP(R1)
        LHL     R7,DEVTAB,R6,R6         : GET PRINTER DCB PTR
        STH     R6,DLDEV,RDCB,  : CRT'S LOG. DEV. = PRTR
        STH     RDEV,DPDEV,R7,  : PRTR'S PHYS. DEV. = CRT
        LCS     R4,1
        STH     R4,DPDEV,RDCB,  : CRT'S PHYS.DEV. = NULL
        STH     R4,DLDEV,R7,    : PRTR'S LOG. DEV. = NULL
        JR      R5
 
:       XNPATH - RESETS LOG.-PHYS. PATH ON EXIT FROM NET MODE
XNPATH  STH     RDEV,DLDEV,RDCB,
        STH     RDEV,DPDEV,RDCB,        : SET BOTH LOG. AND PHYS. DEV.
        JR      R5              : TO THE DEVICE AND EXIT

:
: GETPD - GET PRINTER DEVICE NUMBER FROM CURSOR POSITION
:       EXPECT RBA - MSG BUFFER ADR
:              RDEV - CRT DEVICE #
:       RETURNS R0 - PRINTER DEVICE # SELECTED
:                  - -1 IF CURSOR IN WRONG POSITION
:
GETPD   PUSH(R5)
        JAL     R5,FCURSOR,,            :GET ROW # OF CURSOR
        SHI     R0,0A                   :SUBTRACT BASE ROW # FOR PRINTERS
        JL      GETPD2                  :IF CURSOR BEFORE PRTRS, RETURN -1
        LB      R5,DEVCU,RDEV,          :GET CU #
        CLB     R0,CUPTR,R5,R5          :CURSOR BEYOND PROPER POSITION?
        JGE     GETPD2                  :Y - RETURN -1
        LB      R5,CUPTR+1,R5,R5        :INDEX TO PRINTERS OF THIS CU
        AR      R5,R0                   :INDEX TO SELECTED PRINTER
        LB      R0,PTRDEV,R5,           :GET PRINTER DEVICE #
        JFS     GETPD4
GETPD2  LCS     R0,1                    :IF NO GOOD, RETURN -1
GETPD4  RETJ(R5)

        SUBTTL  SPACE MANAGEMENT ROUTINES
:       SPACE MANAGEMENT ROUTINES

:	SOME GLOBALS
	GL	CMDZPS,BFZPS
 
:       REGISTER USAGE
RRTE    EQ      R4      : ADDRESS OF USAGE COUNT ROUTINE
RUC     EQ      R7      : USAGE COUNT 
RT1     EQ      R6      : WORK REGISTER
RT2     EQ      R7      : WORK REGISTER

:	STORAGE
	SEG	0
CMDZPS	HS	1			:number of circuits zapped due to 
					:insufficient command links since last start
BFZPS	HS	1			:number of circuits zapped due to
					:insufficient buffers since last start
 
:       CONSTANST
SPATIM  EQ      $A2     : TIMOUT PERIOD FOR EXECUTION
        SEG     1
 
:       INITIALIZE SPACE MANAGEMENT
IZSPAM  PUSH(R5)        : SAVE RETURN ADDR.
        L       R1,FASTC,,      : SET UP TIMEOUT LIST ENTRY
        AI      R1,RATE*SPATIM
        LA      R0,SPAMAN       : ADDR. OF SPACE MAN. RTE.
        JAL     R5,TOPUT,,      : PUT ON TIMEOUT LIST
:       NOW CLEAR FLUSH XMT QUEUE FLAGS
        LIS     RT1,0
        LHI     RT2,(NDEVB-1)*2 : SET UP HWORD INDEX
IZSP10  STH     RT1,XMTFSH,RT2, : ZERO HWORD
        SIS     RT2,2           : NEXT HWORD
        JGEBS   IZSP10          : REPEAT FOR EACH HWORD
        STH	RT1,CMDZPS,,	: ZERO ZAP COUNTS
	STH	RT1,BFZPS,,
        RETJ(R5)
 
 
:       SPACE MANAGER ROUTINE
:       RUNS PERIODICLY, CHECKING FOR LOW LEVEL OF FREE SPACE
:       IN BUFFERLET , CMDLIST OR MAP FREE LISTS.
:       FOR EACH LOW LEVEL OF A RESOURCE , IT FINDS THE DEVICE
:       WITH THE LARGEST USAGE AND ZAPS ITS CIRCUIT
SPAMAN  L       R1,FASTC,,      : FIRST SCHEDULE NEXT EXECUTION
        AI      R1,RATE*SPATIM
        LA      R0,SPAMAN
        JAL     R5,TOPUT,,
 
:       CHECK CMDLIST FREE LEVEL
        LHL     RT1,CMDCNT      : GET FREE LINK CNT
        CI      RT1,CMDLO       : COMPARE TO LOW LEVEL
        JGEFS   SPAM10          :   OK - SKIP
        LA      RRTE,CNTCMD     : RTE. TO COUNT USAGE
        JAL     R5,ZAPMAX       : FIND LARGEST USER AND ZAP
	LIS	RT1,1		: BUMP ZAP COUNT
	AHM	RT1,CMDZPS,,
:       CHECK BUFFERLET FREE LEVEL
SPAM10  LHL     RT1,BUFCNT      : GET FREE BUF. COUNT
        CI      RT1,BUFLO       : COMPARE TO LOW LEVEL
        JGEFS   SPAM20          :   OK - SKIP
        LA      RRTE,CNTBUF     : RTE. TO COUNT USAGE
        JAL     R5,ZAPMAX       : FIND LARGEST USER AND ZAP 
        LIS	RT1,1		: BUMP ZAP COUNT
	AHM	RT1,BFZPS,,
        IF      HSTSWT
:       CHECK MAP LINK FREE LEVEL
SPAM20  LHL     RT1,MAPCNT,,    : GET FREE MAP LINK COUNT
        CI      RT1,MAPLO       : COMPARE TO LOW LEVEL
        JGE     SPAM30          :   OK - SKIP
        LA      RRTE,CNTMAP     : RTE. TO COUNT USAGE
        JAL     R5,ZAPMAX       : FIND LARGEST USER AND ZAP
SPAM30  J       TORET,,         : RETURN TO TIMEOUT PACKAGE
        ELSE
SPAM20  J       TORET,,         : RETURN TO TIMEOUT PACKAGE
        EI
 

:       ROUTINE TO FIND THE LARGEST USER OF A RESOURCE
:       AND ZAP HIM TO FREE AS MANY UNITS OF THE RESOURCE AS POSSIBLE
ZAPMAX  PUSH(R5)
        LCS     RT1,1           : INITIALIZE DEV. WITH MAX COUNT=NULL
        STH     RT1,IMAX,,
        LIS     RT1,0			: INITIALIZE MAX. COUNT FOUND = 0
        STH     RT1,CNTMAX,,
:       LOOP OVER DEVICES,LOOKING FOR MAX. USE COUNT
        LHL     RDEV,NDEV,,		:SET UP DEVICE INDEX
ZAPM10  LHL     RDCB,DEVTAB,RDEV,RDEV   : GET DCB PTR FOR THE DEVICE
        TBT     RDEV,XMTFSH,,           : ARE WE WAITING FOR F.G. TO
                                        : FLUSH XMT QUEUE FOR THIS DEVICE
        JN      ZAPM20                  :   Y - SKIP IT
        IF      HSTSWT
        TBT     RDEV,DUNAV      : IS THE DEVICE IN USE?
        JN      ZAPM20          :NO-IGNORE THIS DEVICE
        EI
        JALR    R5,RRTE         : CALL USAGE COUNT ROUTINE
        CLH     RUC,CNTMAX,,    : COMPARE USE COUNT TO MAX
        JLEFS   ZAPM20          :   NOT NEW MAX - SKIP
        STH     RDEV,IMAX,,     :   NEW MAX - SAVE DEV. NO.
        STH     RUC,CNTMAX,,    :             AND USE COUNT
ZAPM20  SIS     RDEV,1          : NEXT DEVICE
        JGE     ZAPM10          : REPEAT FOR EACH DEVICE
:       LOOP COMPLETED - IF ANY DEVICE FOUND, ZAP IT
        LH      RDEV,IMAX,,     : GET DEVICE INDEX WITH MAX USE COUNT
        JLFS    ZAPM30          :   NONE FOUND - SKIP
        SBT     RDEV,XMTFSH,,		: ASK F.G. TO CLEAR XMT QUEUE
        LHL     RDCB,DEVTAB,RDEV,RDEV	: GET DCB POINTER
        LHI     R0,DZ.21		:"RESOURCE LIMIT EXCEEDED"
        STB     R0,DZAP,RDCB,           :STORE DISCONNECT REASON CODE
        IF      HSTSWT
        JAL     R5,OZAP,,		: ZAP THE DEVICE
        ELSE
        JAL     R5,NZAP,,		: ZAP THE DEVICE
        EI
ZAPM30  RETJ(R5)
 
:       MAXIMUM USAGE COUNT VARIABLES
        SEG     0
XMTFSH  HS      NDEVB
IMAX    HS      1               : INDEX OF DEVICE WITH MAX. USAGE
CNTMAX  HS      1               : MAX. USAGE COUNT FOUND SO FAR
        SEG     1

:       USAGE COUNT ROUTINES 
:       ALL USE THESE REGISTERS -
:       INPUT RDEV  , RDCB
:       OUTPUT RUC = USAGE COUNT FOR DEVICE
:       LINK    R5
 
 
:       CMDLIST USAGE CNT
        IF      HSTSWT
CNTCMD  LHL     RUC,CCXMT,RDEV,RDEV     : XMT QUEUE USE COUNT
        AH      RUC,CCRCV,RDEV,RDEV     : ADD RCV QUEUE USE COUNT
        ELSE
CNTCMD  LHL     RUC,CCIN,RDEV,RDEV      : IN QUEUE USE COUNT
        AH      RUC,CCOUT,RDEV,RDEV     : ADD OUT QUEUE USE COUNT
        LH      RT1,DPDEV,RDCB,         : GET PHYS. DEVICE INDEX
        JLR     R5                      : RETURN IF NULL
        AH      RUC,CCXMT,RT1,RT1       : ADD XMT QUEUE USAGE COUNT
        AH      RUC,CCRCV,RT1,RT1       : ADD RCV QUEUE USAGE COUNT
        EI
        JR      R5
 
 
:       BUFFERLET USAGE COUNT
        IF      HSTSWT
CNTBUF  LHL     RUC,DCXMT,RDEV,RDEV     : XMT QUEUE DATA BYTE USE COUNT
        AH      RUC,DCRCV,RDEV,RDEV     : ADD RCV QUEUE COUNT
        ELSE
CNTBUF  LHL     RUC,DCIN,RDEV,RDEV      : IN QUEUE DATA BYTE USE COUNT
        AH      RUC,DCOUT,RDEV,RDEV     : ADD OUT QUEUE USE COUNT
        LH      RT1,DPDEV,RDCB,         : GET PHYSICAL DEVICE INDEX
        JLFS    CNTB10                  : NULL - SKIP
        AH      RUC,DCXMT,RT1,RT1       : ADD XMT QUEUE USE COUNT
        AH      RUC,DCRCV,RT1,RT1       : ADD RCV QUEUE USE COUNT
CNTB10
        EI
        LHL     RT1,DIRBA,RDCB,         : PARTIAL INPUT MSG ?
        JER     R5                      :   N - THRU , RETURN
        AH      RUC,DIRCNT,RDCB,        : ADD WHOLE BUF. CNT
        AH      RUC,DIRBX,RDCB,         : ADD OFFSET WITHIN BUF.
        JR      R5
 
 
        IF      HSTSWT
:       MAP LINK USAGE COUNT
CNTMAP  LHL     RUC,DNMAP,RDCB,         : GET MAP USAGE COUNT
        JR      R5
        EI
 
 
        SUBTTL  SCREENS
:
: THIS FILE CONTAINS MISCELLANEOUS LOGIN SCREENS, SCREEN ADDRESSES,
: ETC. AT THE END ARE INSTRUCTIONS TO ADJUST SEGMENT OVERFLOWS.
:
        LIST    L,F,-X,-R
        SEG     1
:       BUFFER ADDR CHARS OF USERNAME AND PASSWORD FIELDS
LFA     SBAC(4,$A11,$A40)
        SBAC(6,$A11,$A40)
 
PJFLD   SBAC(0,$A11,$A40)               : PROJECT CODE FIELD ADDR CHARS
 
 
:       ASCII SCREEN MSGS
ASC480  HC      $A19                    : SMALL SCREEN MSG
        BC      ESC.,EWCMD,WCCKM,SBA.
        SBAC($A10,0,$A40)               : BEGINNING OF INPUT AREA
        BC      SF.,ATUAD,IC.,SBA.
        SBAC($A11,0,$A40)
        BC      SF.,ATUAD,SBA.
        SBAC($A11,$A39,$A40)            : START PROT. FIELD IN LAST POSITION
        BC      SF.,ATPND               : POSITION OF THE SCREEN
 
ASC192  HC      $A19                    : REGULAR SCREEN MSG
        BC      ESC.,EWCMD,WCCKM,SBA.
        SBAC($A22,0,$A80)               : START OF INPUT AREA
        BC      SF.,ATUAD,IC.,SBA.
        SBAC($A23,0,$A80)
        BC      SF.,ATUAD,SBA.
        SBAC($A23,$A79,$A80)
        BC      SF.,ATPND
 
 

        SEG     0
:       LOGON ERROR MSGS
LEM1    HC      $A25
        BC      ESC.,WCMD,WCCK,SBA.
        SBAC(0A,0,$A40)
        BC      T.,Y.,P.,E.,SP.,U.,S.,E.,R.,N.,A.,M.,E.,SBA.
        SBAC(4,$A11,$A40)
        BC      IC.,NULL.,PT.
 
LEM2    HC      $A25
        BC      ESC.,WCMD,WCCAK,SBA.
        SBAC(0A,0,$A40)
        BC      T.,Y.,P.,E.,SP.,P.,A.,S.,S.,W.,O.,R.,D.,SBA.
        SBAC(6,$A11,$A40)
        BC      IC.,NULL.,PT.
 
:       LEM3 - LOGON IN PROGRESS MSG
LEM3    HC      $A23
        BC      ESC.,WCMD,WCCN,SBA.
        SBAC(8,2,$A40)
        BC      L.,O.,G.,O.,N.,SP.,I.,N.,SP.,P.,R.,O.,G.,R.,E.,S.,S.
:
: LEM 4 - ZAP MSG TO USER IN LOGON MODE
:
LEM4    HC      $A23
        BC      ESC.,WCMD,WCCAKM,EAU.
        SBAC(0E,2,$A40)
        BC      L.,O.,G.,O.,N.,SP.,F.,A.,I.,L.,E.,D.
        BC      NULL.,NULL.,NULL.,NULL.,NULL.

:
: LEM5 - USERNAME ERROR MSG FOR STORED LOGON
:
LEM5    HC      $A40
        BC      ESC.,WCMD,WCCN,SBA.
        SBAC(2,0,$A40)
        BC      U.,S.,E.,R.,N.,A.,M.,E.,SP.,E.,R.,R.,O.,R.,SP.
        BC      D.,U.,R.,I.,N.,G.,SP.,S.,T.,O.,R.,E.,D.,SP.
        BC      L.,O.,G.,O.,N.
:
: LEM6 - PASSWORD ERROR MSG FOR STORED LOGON
:
LEM6    HC      $A40
        BC      ESC.,WCMD,WCCN,SBA.
        SBAC(2,0,$A40)
        BC      P.,A.,S.,S.,W.,O.,R.,D.,SP.,E.,R.,R.,O.,R.,SP.
        BC      D.,U.,R.,I.,N.,G.,SP.,S.,T.,O.,R.,E.,D.,SP.
        BC      L.,O.,G.,O.,N.
:
: LEM7 - "BAD STORED LOGON STRING"
:
LEM7    HC      $A46
        BC      ESC.,WCMD,WCCN,SBA.
        SBAC($A46,2,$A40)
        BC      SF.,ATPND
        BC      B.,A.,D.,SP.,S.,T.,O.,R.,E.,D.,SP.
        BC      D.,S.,P.,SP.,E.,L.,E.,M.,E.,N.,T.,SP.
        BC      DASH.,SP.,L.,O.,G.,O.,N.,SP.,A.,B.,O.,R.,T.,E.,D.
:
: LEM8 - "PLEASE SEE YOUR REP"
:
LEM8    HC      $A28
        BC      ESC.,WCMD,WCCN,SBA.
        SBAC(8,2,$A40)
        BC      P.,L.,E.,A.,S.,E.,SP.,S.,E.,E.,SP.,Y.,O.,U.,R.,SP.
        BC      R.,E.,P.,DOT.,DOT.,DOT.
:
: LEM9 - "BAD MUD"
:
LEM9    HC      $A13
        BC      ESC.,WCMD,WCCN,SBA.
        SBAC(8,2,$A40)
        BC      B.,A.,D.,SP.,M.,U.,D.
:
: LEMA - "CIRCUITS BUSY"
:
LEMA    HC      $A19
        BC      ESC.,WCMD,WCCN,SBA.
        SBAC(8,2,$A40)
        BC      C.,I.,R.,C.,U.,I.,T.,S.,SP.,B.,U.,S.,Y.
:
: LEMB - "HOST NOT AVAILABLE"
:
LEMB    HC      $A24
        BC      ESC.,WCMD,WCCN,SBA.
        SBAC(8,2,$A40)
        BC      H.,O.,S.,T.,SP.,N.,O.,T.,SP.,A.,V.,A.,I.,L.,A.,B.,L.,E.
:
: LEMC - "HOST OUT OF PORTS"
:
LEMC    HC      $A23
        BC      ESC.,WCMD,WCCN,SBA.
        SBAC(8,2,$A40)
        BC      H.,O.,S.,T.,SP.,O.,U.,T.,SP.,O.,F.,SP.,P.,O.,R.,T.,S.
:
: LEMD - "HOST DOWN"
:
LEMD    HC      $A15
        BC      ESC.,WCMD,WCCN,SBA.
        SBAC(8,2,$A40)
        BC      H.,O.,S.,T.,SP.,D.,O.,W.,N.
:
: LEME - "HOST SHUT"
:
LEME    HC      $A15
        BC      ESC.,WCMD,WCCN,SBA.
        SBAC(8,2,$A40)
        BC      H.,O.,S.,T.,SP.,S.,H.,U.,T.
:
: LEMF - "TRY AGAIN IN 2 MINUTES"
:
LEMF    HC      $A28
        BC      ESC.,WCMD,WCCN,SBA.
        SBAC(8,2,$A40)
        BC      T.,R.,Y.,SP.,A.,G.,A.,I.,N.,SP.,I.,N.,SP.,N2.
        BC      M.,I.,N.,U.,T.,E.,S.
:
: LEM10 - "ACCESS NOT PERMITTED"
:
LEM10   HC      $A26
        BC      ESC.,WCMD,WCCN,SBA.
        SBAC(8,2,$A40)
        BC      A.,C.,C.,E.,S.,S.,SP.,N.,O.,T.,SP.
        BC      P.,E.,R.,M.,I.,T.,T.,E.,D.
:
: LEM11 - "NO HOST SPECIFIED"
:
LEM11   HC      $A23
        BC      ESC.,WCMD,WCCN,SBA.
        SBAC(8,2,$A40)
        BC      N.,O.,SP.,H.,O.,S.,T.,SP.,S.,P.,E.,C.,I.,F.,I.,E.,D.
:
: LEM12 - "BAD HOST NUMBER"
:
LEM12   HC      $A21
        BC      ESC.,WCMD,WCCN,SBA.
        SBAC(8,2,$A40)
        BC      B.,A.,D.,SP.,H.,O.,S.,T.,SP.,N.,U.,M.,B.,E.,R.
:
: LEM13 - "MUD ERROR"
:
LEM13   HC      $A16
        BC      ESC.,WCMD,WCCN,SBA.
        SBAC(8,2,$A40)
        BC      M.,U.,D.,SP.,E.,R.,R.,O.,R.
:
: LEM14 - "PVC LOGON IN PROGRESS"
:
LEM14   HC      $A27
        BC      ESC.,WCMD,WCCN,SBA.
        SBAC(8,2,$A40)
        BC      P.,V.,C.,SP.,L.,O.,G.,O.,N.,SP.,I.,N.,SP.
        BC      P.,R.,O.,G.,R.,E.,S.,S.
:
: CLEAR SCREEN AND UNLOCK KEYBOARD MESSAGE
:
LEM15   HC      4
        BC      ESC.,EWCMD,WCCAKM,IC.

:
: "CRT IS CURRENTLY LOGGED IN" MESSAGE
:
NETS1   HC      $A36
        BC      ESC.,WCMD,WCCK,SBA.
        SBAC(0C,3,$A40)
        BC      C.,R.,T.,SP.,I.,S.,SP.,C.,U.,R.,R.,E.,N.,T.,L.,Y.,SP.
        BC      L.,O.,G.,G.,E.,D.,SP.,I.,N.,NULL.,NULL.,NULL.,NULL.
:
: PORTIONS OF THE PRINTER LABEL MESSAGE
:
NETS2   HC      $A3
        BC      ESC.,WCMD,WCCN
:
NETS3   HC      $A11
        BC      SBA.
NETS3A  SBAC(12,0,$A40)
        BC      SF.,ATUAD
NETS3B  BC      N0.,N0.,SP.,SP.,SP.
NETS3C  BC      40
:
:
NETS4   HC      $A10
        BC      SP.,SP.,SP.,I.,D.,L.,E.,SP.,SP.,SP.
:
:
NETS5   HC      $A10
        BC      SP.,SP.,SP.,B.,U.,S.,Y.,SP.,SP.,SP.
:
: "CRT IS CURRENLY NOT LOGGED IN" MESSAGE
:
NETS6   HC      $A36
        BC      ESC.,WCMD,WCCK,SBA.
        SBAC(0C,3,$A40)
        BC      C.,R.,T.,SP.,I.,S.,SP.,C.,U.,R.,R.,E.,N.,T.,L.,Y.,SP.
        BC      N.,O.,T.,SP.,L.,O.,G.,G.,E.,D.,SP.,I.,N.
:
: NODE#, SLOT#, LINE #, CU ADR. AND DEV ADR.
:
NETS7   HC      $A63
        BC      ESC.,WCMD,WCCK,SBA.
        SBAC(2,0,$A40)
NETS7A  BC      N.,O.,D.,E.,COLON.,SP.,N0.,N0.,N0.,N0.,DOT.,SP.,SP.
        BC      S.,L.,O.,T.,COLON.,SP.,N0.,DOT.,SP.,SP.
NETS7B  BC      L.,I.,N.,E.,COLON.,SP.,N0.,DOT.,SP.,SP.,C.,U.,SP.,A.,D.,R.,
        BC      COLON.,SP.,N0.,DOT.,SP.,SP.,D.,E.,V.,SP.,A.,D.,R.,COLON.,SP.
        BC      SP.,DOT.,SP.

        SEG     1
:
: MENU SCREEN HEADER
:
        IF      \MENUHD
        ELSE
MENUHD  SC      /SELECT LOGON PROCEDURE/
        EI
MENUH1  HC      $A8
        BC      ESC.,EWCMD,WCCKM,SBA.
        SBAC(0,0,$A40)
        BC      SF.,ATPND
:
: MENU SCREEN TERMINATING ATTRIBUTES
:
MENUH2  HC      $A5
        BC      SBA.
        SBAC($A46,0,$A40)
        BC      SF.,ATPND

:       LOGON SCREEN
LOGSCN  HC      $A60
        BC      ESC.,EWCMD,WCCKM,SBA.
        SBAC(2,0,$A40)
        BC      SF.,ATPND,P.,L.,E.,A.,S.,E.,SP.,L.,O.,G.,I.,N.
        BC      SBA.
        SBAC(4,1,$A40)          : USERNAME FIELD
        BC      U.,S.,E.,R.,N.,A.,M.,E.,COLON.,SF.,ATUADM,IC.,SBA.
        SBAC(6,0,$A40)
        BC      SF.,ATPND,P.,A.,S.,S.,W.,O.,R.,D.,COLON.,SF.,ATUANM,SBA.
        SBAC(8,0,$A40)
        BC      SF.,ATPND
        BC      SP.,SF.,ATUADM,SP.
:
: ERASE USERNAME FIELD
:
LOGS10  HC      $A9
        BC      ESC.,WCMD,WCCN,SBA.
        SBAC(4,$A11,$A40)
        BC      IC.,NULL.,PT.

:
: DSP SCREEN
:
SCNDSP  HC      $A212
        BC      ESC.,EWCMD,WCCKM,SBA.
        SBAC(2,0,$A40)
        BC      SF.,ATPND
        BC      C.,O.,N.,N.,E.,C.,T.,I.,O.,N.,SP.
        BC      R.,E.,Q.,U.,E.,S.,T.,SP.,M.,O.,D.,E.,COLON.
        BC      SF.,ATUAD,IC.,SBA.
        SBAC(4,0,$A40)
        BC      SF.,ATPND
        BC      D.,E.,S.,T.,I.,N.,A.,T.,I.,O.,N.,SP.
        BC      I.,N.,T.,E.,R.,F.,A.,C.,E.,SP.
        BC      A.,D.,D.,R.,E.,S.,S.,COLON.
        BC      SF.,ATUAD,SBA.
        SBAC(6,0,$A40)
        BC      SF.,ATPND
        BC      A.,P.,P.,L.,I.,C.,A.,T.,I.,O.,N.,SP.
        BC      I.,D.,E.,N.,T.,I.,F.,I.,E.,R.,COLON.
        BC      SF.,ATUAD,SBA.
        SBAC(8,0,$A40)
        BC      SF.,ATPND
        BC      D.,E.,S.,T.,I.,N.,A.,T.,I.,O.,N.,SP.
        BC      C.,O.,N.,T.,R.,O.,L.,SP.,U.,N.,I.,T.,COLON.
        BC      SF.,ATUAD,SBA.
        SBAC(0A,0,$A40)
        BC      SF.,ATPND
        BC      D.,E.,S.,T.,I.,N.,A.,T.,I.,O.,N.,SP.
        BC      D.,E.,V.,I.,C.,E.,SP.
        BC      A.,D.,D.,R.,E.,S.,S.,COLON.
        BC      SF.,ATUAD,SBA.
        SBAC(0C,0,$A40)
        BC      SF.,ATPND
        BC      D.,O.,SP.,Y.,O.,U.,SP.,W.,A.,N.,T.,SP.
        BC      E.,X.,T.,E.,N.,D.,E.,D.,SP.
        BC      A.,T.,T.,R.,I.,B.,U.,T.,E.,S.,QUES.
        BC      SF.,ATUAD,SBA.
        SBAC(0E,0,$A40)
        BC      SF.,ATPND
:
: DISPLAY QUESTION TO SELECT ASCII MODE
:
DSPASC  HC      $A41
        BC      ESC.,WCMD,WCCK,SBA.
        SBAC(0,0,$A40)
        BC      SF.,ATPND
        BC      D.,O.,SP.,Y.,O.,U.,SP.,W.,I.,S.,H.,SP.
        BC      T.,O.,SP.,U.,S.,E.,SP.,A.,S.,C.,I.,I.,SP.
        BC      M.,O.,D.,E.,QUES.
        BC      SF.,ATUADM,IC.
:
: DISPLAY QUESTION FOR 3279 TERMINAL ABOUT WANTING "COLOR"
:
DSPCOL  HC      $A33
        BC      ESC.,WCMD,WCCK,SBA.
        SBAC(0E,0,$A40)
        BC      SF.,ATPND
        BC      D.,O.,SP.,Y.,O.,U.,SP.,W.,A.,N.,T.,SP.
        BC      C.,O.,L.,O.,R.,QUES.
        BC      SF.,ATUAD,SBA.
        SBAC(10,0,$A40)
        BC      SF.,ATPND

:
: BUFFER ADDRESS TO ANSWERS OF DSP SCREEN QUESTIONS
:
        HS      0
DSPL0   SBAC(0,$A32,$A40)               :DO YOU WISH ASCII?
DSPL1   SBAC(2,$A26,$A40)               :CRM #
DSPL2   SBAC(4,$A32,$A40)               :DESTINATION INTERFACE ADR
DSPL3   SBAC(6,$A25,$A40)               :APPLICATION ID
DSPL4   SBAC(8,$A27,$A40)               :DESTINATION CUA
DSPL5   SBAC(0A,$A29,$A40)               :DESTINATION DVA
DSPL6   SBAC(0C,$A34,$A40)              :EXTENDED ATTRIBUTES?
DSPL7   SBAC(0E,$A20,$A40)              :COLOR?

:
: NETWORK SERVICES SCREEN
:
NETSCN  HC      0
        BC      ESC.,EWCMD,WCCKM,SBA.
        SBAC(0,09,$A40)
        BC      N.,E.,T.,W.,O.,R.,K.,SP.,S.,E.,R.,V.,I.,C.,E.,S.,SBA.
        SBAC(4,0,$A40)
        BC      C.,L.,R.,SP.,SP.,SP.,R.,E.,T.,U.,R.,N.,SP.,T.,O.,SP.
        BC      C.,O.,N.,V.,E.,R.,S.,A.,T.,I.,O.,N.,SBA.
        SBAC(6,0,$A40)
        BC      P.,F.,N1.,SP.,SP.,SP.,L.,O.,G.,SP.,O.,F.,F.,SP.
        BC      C.,R.,T.,SBA.
        SBAC(8,0,$A40)
        BC      P.,F.,N2.,SP.,SP.,SP.,L.,O.,G.,SP.,O.,N.,SP.
        BC      P.,R.,I.,N.,T.,E.,R.,SBA.
        SBAC(0A,0,$A40)
        BC      P.,F.,N3.,SP.,SP.,SP.,L.,O.,G.,SP.,O.,F.,F.,SP.
        BC      P.,R.,I.,N.,T.,E.,R.,SBA.
        SBAC(0E,0,$A40)
        BC      P.,O.,S.,I.,T.,I.,O.,N.,SP.,C.,U.,R.,S.,O.,R.,SP.
        BC      T.,O.,SP.,S.,E.,L.,E.,C.,T.,SP.,P.,R.,I.,N.,T.,E.,R.,SBA.
        SBAC(10,0,$A40)
        BC      N.,O.,DOT.,SP.,SP.,A.,D.,R.,SP.,SP.,S.,T.,A.,T.
        BC      SP.,SP.,SP.,L.,A.,B.,E.,L.,SBA.
        SBAC(12,0,$A40)
        BC      IC.
:
:
SAVORG  EQ      .
        SETO(NETSCN,0)
        HC      SAVORG-NETSCN-2
        ORG     SAVORG

:
: "WRONG KEY...TRY AGAIN" MESSAGE
:
NETS10  HC      $A35
        BC      ESC.,WCMD,WCCK,SBA.
        SBAC(12,0,$A40)
        BC      IC.,SBA.
        SBAC($A46,0,$A40)
        BC      W.,R.,O.,N.,G.,SP.,K.,E.,Y.,DOT.,DOT.,DOT.
        BC      T.,R.,Y.,SP.,A.,G.,A.,I.,N.,RA.
        SBAC($A46,39,$A40)
        BC      NULL.
:
: ERASE ERROR MSG AND RESET CURSOR POSITION
:
NETS20  HC      $A14
        BC      ESC.,WCMD,WCCK,SBA.
        SBAC(12,0,$A40)
        BC      IC.,SBA.
        SBAC($A46,0,$A40)
        BC      RA.
        SBAC($A46,39,$A40)
        BC      NULL.
:
: "DEVICE NOT LOGGED IN" MESSAGE
:
NETS30  HC      $A34
        BC      ESC.,WCMD,WCCK,SBA.
        SBAC(12,0,$A40)
        BC      IC.,SBA.
        SBAC($A46,0,$A40)
        BC      D.,E.,V.,I.,C.,E.,SP.,N.,O.,T.,SP.
        BC      L.,O.,G.,G.,E.,D.,SP.,I.,N.,RA.
        SBAC($A46,39,$A40)
        BC      NULL.

:
: "CURSOR IN WRONG POSITION FOR SELECTION" MESSAGE
:
NETS40  HC      $A52
        BC      ESC.,WCMD,WCCK,SBA.
        SBAC(12,0,$A40)
        BC      IC.,SBA.
        SBAC($A46,0,$A40)
        BC      C.,U.,R.,S.,O.,R.,SP.,I.,N.,SP.,W.,R.,O.,N.,G.,SP.
        BC      P.,O.,S.,I.,T.,I.,O.,N.,SP.,F.,O.,R.,SP.
        BC      S.,E.,L.,E.,C.,T.,I.,O.,N.,RA.
        SBAC($A46,39,$A40)
        BC      NULL.
:
: "SOMEONE ELSE IS LOGGING PRINTER IN" MESSAGE
:
NETS50  HC      $A48
        BC      ESC.,WCMD,WCCK,SBA.
        SBAC(12,0,$A40)
        BC      IC.,SBA.
        SBAC($A46,0,$A40)
        BC      S.,O.,M.,E.,O.,N.,E.,SP.,E.,L.,S.,E.,SP.,I.,S.,SP.
        BC      L.,O.,G.,G.,I.,N.,G.,SP.,P.,R.,I.,N.,T.,E.,R.,SP.,RA.
        SBAC($A46,39,$A40)
        BC      NULL.
:
: "PRINTER IS ALREADY LOGGED IN" MESSAGE
:
NETS60  HC      $A42
        BC      ESC.,WCMD,WCCK,SBA.
        SBAC(12,0,$A40)
        BC      IC.,SBA.
        SBAC($A46,0,$A40)
        BC      P.,R.,I.,N.,T.,E.,R.,SP.,I.,S.,SP.,A.,L.,R.,E.,A.,D.,Y.,SP.
        BC      L.,O.,G.,G.,E.,D.,SP.,I.,N.,RA.
        SBAC($A46,39,$A40)
        BC      NULL.
 
        LIST    L,F,-X,-R
 
        :       COMMAND LISTS

        SEG     0
DEFCMD  MACRO(LNAME) [
        GL      GP`LNAME,NP`LNAME,RP`LNAME,PP`LNAME,CC`LNAME,DC`LNAME
        GL      LNAME`DAT,LNAME`GAT
GP`LNAME   HS   NDEVM           :GET PTR
NP`LNAME   HS   NDEVM           :NEXT PTR
RP`LNAME   HS   NDEVM           :RELEASE PTR
PP`LNAME   HS   NDEVM           :PUT PTR
CC`LNAME   HS   NDEVM           :CMD LINK USE CNT
DC`LNAME   HS   NDEVM           :DATA BYTE USE CNT
LNAME`DAT  HS   NDEVB           :DATA PRESENT BIT FLAG
LNAME`GAT  HS   NDEVB           :GATE BIT FLAG (1=OPEN)
]
        DEFCMD(RCV)
        DEFCMD(XMT)
        DEFCMD(IN)
        DEFCMD(OUT)
        IF      HSTSWT
         IF      SAVEQ
        DEFCMD(SAV)
         EI	:SAVEQ
        ELSE
	 IF	HSBCSW
	 ELSE
        DEFCMD(SAV)
	 EI	:HSBCSW
        EI	:HSTSWT
        SEG     1
	SUBTTL	STATL.LIB . . . Long-token version of STATUS.LIB
:******************************************************************
:
:	This program is the sole property and confidential
:	information of Tymshare, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.
:
:*******************************************************************

  IF	1-\DB.STA			: DEFAULT DEBUG/STATUS TO ON
DB.STA	EQ	1
  EI

  IF	DB.STA				: ASSEMBLE ONLY WITH DEBUG STATUS ON

	SEG	A.CODE
	MO	.,STATUS
	RA	$00
	GL	DSTART,DS.ELL,DS.ILL,DS.ERR,DS.DLM
	GL	DS.TOK,DS.NUM,DS.EXI,DS.QUI,DS.GCH,DS.CUC,DS.DEL

:	STATUS - User Command Handler
:
:	Version history:
:	13.3  08/19/83  <JOK>Changed DS.TOK to return first 8 chars of
:		TOKEN, changed DS.CMD to retain first 8 chars of command,
:		and changed DSTART to accept up to 8-character commands.
:	13.2  01/27/81  <BAB>Added RADIX=0 at start of mod.  Added jump
:		following 'QUIT' SVC to allow DDT "P" (proceede) command
:		to return the user to ":>" prompt.
:	13.1  11/17/81	<BAB>Added DNEXTK support, DS.DLM (last delimiter),
:		and fixed backspace for > 4 character entry, added the
:		command thought to be invalid to invalid command message.
:	13	08/81	<JK>Maintenance assumed by BAB from John Kopf
:
:		The Status package is intended to provide an extension to DDT,
:	invokable via the "?STAT" command in DDT.  Once invoked you may re-
:	activate it (provided you have not issued any DDT "G" (go) commands)
:	by typing "P ".
:
:		There is limited editing control built into the package:
:	ESC	aborts back to command level,
:	^W	discards partial 'token' already input (word or number),
:	^A	discards last char of token (backspace).
:	^H	discards last char of token (backspace).

:		Delimiters may occur in multiple (e.g. ", " is OK).  Valid
:	delimiters are:
:	C/R	L/F	H/T	","	and BLANK.

:		Entry Points:
:	DSTART	Place to exit on completion of command.
:	DNEXTK  Get next token with out prompt.
:	DS.ILL	Place to exit on illegal command -- types "Illegal command"
:	DS.ERR	Place to exit on command error -- types "type '\' "
:	DS.EXI	Place to exit machine.
:	DS.QUI	Place to exit back to DDT.
:	DS.GCH	Get a character...Link on R1, char (with high-order bit forced)
:			in R0...normal return if detected ^W, skip-4 if detect
:			^A, aborts back to DSTART if detects ESC.
:	DS.DEL	Check for delimiter...Link on R2, Character in R0.  Skip-4
:			return unless this is a delimiter, then normal return.
:	DS.CUC	Convert to upper case...Link on R1, Character in R0.
:	DS.TOK	Get a string token...Link on R4, TOKEN returned in R3/R2...
:			inputs up to 4 characters, returns them (in uppercase)
:			left justified, 0 fill
:	DS.NUM	Get a number...Link on R5, expects Radix in R4...
:			number returned in R0.  May ABORT if any character is
:			input other than valid digit or delimiter.
:	DS.DLM  Location of last delimeter entered (1 byte)

:		There are two built-in commands:
:	Quit	exit back to DDT.
:	EXIt	exit machine.

:		additional commands may be defined via the DS.CMD macro:
:	 DS.CMD(TEXT,ADDR)
:	Where:	TEXT	The (UPPERCASE) target command string.
:		ADDR	The virtual address to transfer to, to service that
:				command.
:	DS.CMD generates a 16-byte descriptor for this command, at the point
:	assembly where it is invoked.  This descriptor is on a WORD boundary.



OUT	EQ	0B			: Output SVC
IN	EQ	0A			: Input SVC

DS.ELL	EQ	0			: Null pointer for end-of-linked-list

	SEG	A.DATA
DS.DLM	BS	1			: Last delimiter encountered
R4SAV	WS	1			: Save-area for R4 in DS.TOK
BADSTR	SC	/'xxxxxxxx'"8D"8A/	: Place to put bad command
STOKEN	EQ	BADSTR+2		: String-buffer for token
	SEG	A.CODE

:	Define elements for command-block
C.NEXT	EQ	0			: Pointer to next command-block
C.ADDR	EQ	C.NEXT+4		: Pointer to command-handler
C.STR	EQ	C.ADDR+4		: Relative position of string

:	Define macro to generate this command-block
DS.CMD	MACRO(STR,ADDR)[ WS	0
   IF	DS.ELL
Q	WS	0
	ORG	DS.ELL
	WC	Q
	ORG	Q
   EI
DS.ELL	WC	0,ADDR
	AC	/STR/
	WS	0
 IF	DS.ELL+10-. ; WC 0; EI
]


:	TABLE OF COMMANDS, AND TARGET ROUTINES.
CMDLST	DS.CMD(Q,DS.QUI)		: Exit back to DDT
	DS.CMD(QUIT,DS.QUI)		: Exit back to DDT
	DS.CMD(EXIT,DS.EXI)		: Exit
	DS.CMD(EXI,DS.EXI)		: Exit




:	Diagnostic messages
TERR	SC	/Illegal command /
TTERR	SC	/type '\'"8D"8A/
PROMPT	SC	/"8D"8A:>/		: "CR|LF:>"
BKSPAC	SC	/"88 "88/		: Back-space
	SUBTTL	Command-scanner, Verifier, and Bitcher

:	Command-input Handler
DOIT	L	R0,C.ADDR,R1		: Go service this command
	JALR	R0,R0

:	Next Command
DSTART	SVC	OUT,PROMPT		: Issue Prompt
DNEXTK	JAL	R4,DS.TOK		: Get command-token
	LA	R1,CMDLST		: Search for string-match
DSTAR1	CL	R3,C.STR,R1		: check first-word
	JNFS	DSTAR2			: no match
	CL	R2,C.STR+4,R1		: second-word
	JE	DOIT			: Proceed if find a match

DSTAR2	L	R1,C.NEXT,R1		: Else continue scan
	JGBS	DSTAR1

DS.ILL	SVC	OUT,TERR		: "ILLEGAL COMMAND"
	SVC	OUT,BADSTR,,

DS.ERR	SVC	OUT,TTERR		: Tell user to type Flush-char

BITCH	JAL	R1,DS.GCH		: Flush input
	 JBS	BITCH;	 NOPR	0			: ^W...Ignore
	  JBS	BITCH;	  NOPR	0			: ^A...Ignore
	CLHI	R0,0DC			: Read until "\" is found
	JNBS	BITCH
	J	DSTART			: Then exit


:	Built-in Commands

:		Command EXIt
:		===========-
DS.EXI	SVC	KIO,0			: Disconnect


:		Command Quit (exit back to DDT)
:		=========---
DS.QUI	SVC	KIO,1			: Return to DDT
	J	DSTART			: If operator typed "P", get next command
	SUBTTL	U T I L I T I E S

:	Get a Command-token...Up to 8 chars long
:		Skips over extra characters to next delimiter
:	Link on R4
:	Token returned in R3/R2, Left justified, 0-fill
DS.TOK	ST	R4,R4SAV,,		: save R4

TOKEN0	LIS	R0,0			: clear token buffer
	LA	R3,STOKEN,,		: set char-pointer
	ST	R0,0,R3
	ST	R0,4,R3

:	Scan for first character of TOKEN
TOKEN1	JAL	R1,DS.GCH		: Get next char
	 JBS	TOKEN1;	 NOPR	0			: ^W...Ignore
	  JBS	TOKEN1;	  NOPR	0			: ^A...Ignore
	JAL	R2,DS.DEL		: Skip over delimiters
	 J	TOKEN1
	JAL	R1,DS.CUC		: Convert to Upper-case
	CHI	R0,00DC			: = "\" ?
	JE	DSTART			: YES.  Print Prompt, get next command
	STB	R0,0,R3			: no...start TOKEN accumulation
	AIS	R3,1			: advance pointer
	LIS	R4,1			: 1 char. found so far

TOKEN2	JAL	R1,DS.GCH		: Get another char
	 J	TOKEN0			: ^W...Start over
	  J	TOKEN4			: ^A...Toss last char
	JAL	R1,DS.CUC		: Convert to upper-case
	JAL	R2,DS.DEL		: Check for delimiter
	 J	TOKEN3			: Got one...skip to clean up
	CHI	R0,00DC			: = "\" ?
	JE	DS.ILL			: YES.  Treat as Illegal
	AIS	R4,1			: one more character
	CHI	R4,8			: If >= 8 chars, do not use this one
	JG	TOKEN2			: YES...Scan for delimiter
	STB	R0,0,R3			: NO...Accumulate chars
	AIS	R3,1			: advance cursor
	J	TOKEN2			: ..and get another char

TOKEN3	L	R4,R4SAV,,		: Restore R4
	L	R3,STOKEN,,		: place TOKEN into Registers
	L	R2,STOKEN+4,,
	JR	R4			: Return TOKEN in R2/R3


:	Handle backspace in TOKEN
TOKEN4	SIS	R4,1			: one less char
	JLE	TOKEN0			: re-initialize if none left
	CHI	R4,8			: If after backspace TOKEN is >= 8
	JGE	TOKEN2			: then just decrement counter
	LIS	R0,0			: else... drop one character
	SIS	R3,1			:   back-up pointer
	STB	R0,0,R3
	J	TOKEN2			: and get next char

:	Utility routine to read a number
:	uses R0-R3
:	Expects RADIX in R4
:	Link on R5
:	Aborts if first non-delimiter is not digit
:	Else returns number in R0
DS.NUM	JAL	R1,DS.GCH		: get next char
	 JBS	DS.NUM;	 NOPR	0			: ^W...ignore
	  JBS	DS.NUM;	 NOPR	0			: ^A...Ignore
	JAL	R2,DS.DEL		: check for delimiter char
	 J	DS.NUM
	JAL	R2,DS.DIG		: test if char is digit
	 J	DS.ILL			: not a digit - give error-message
	CLR	R0,R4
	JGE	DS.ILL			: digit is bigger than RADIX...Abort
	LR	R3,R0			: put first digit into accumulator
NUMBER	JAL	R1,DS.GCH		: read next char
	 J	DS.NUM			: ^W...Start over
	  J	DIVIDE			: ^A...Toss last digit
	JAL	R2,DS.DEL		: Check for delimiter
	 LR	R0,R3;	 JR	R5	  :YES
	JAL	R2,DS.DIG		: skip if digit
	J	DS.ILL			: NO...Abort
	CLR	R0,R4
	JGE	DS.ILL			: RADIX error...Bitch
	MR	R2,R4			: build number
	AR	R3,R0			: add new digit
	J	NUMBER			: get next digit

DIVIDE	LIS	R2,0			: got a ^A...Make double-precision arg.
	DR	R2,R4			: Quotent into R3, where we want it
	J	NUMBER			: now go back for more digits

:	Digit test
:	Check character read...Skip return if digit
:	Then R0=Binary value of HEX digit
:	uses R1, Link on R2
DS.DIG	JAL	R1,DS.CUC		: Convert to upper-case
	LR	R1,R0			: Copy char
	SHI	R1,0B0			: is it "0"?
	JLR	R2			: return if less than "0"
	SIS	R1,0B9-0B0		: is it "9"
	JLEFS	DIGIT			: less than "9", then a good digit
	SIS	R1,0C1-0B9		: is it "A"?
	JLR	R2			: return if less than "A"
	SIS	R1,0C6-0C1		: is it "F"?
	JGR	R2			: return if greater than "F"
	SIS	R0,7			: 0A - "A" (partial conversion)

DIGIT	SHI	R0,0B0			: "0"
	J	4,R2			: skip-return

:	Check for delimiter
:	Link	R2
:	Uses	R0,R1
:	Skip-4 return unless (R0) is a delimiter-character
DS.DEL	LHI	R1,DLEN-1		: number of delimiter chars
	STB	R0,DS.DLM,,		: save delimiter

DELIM	CLB	R0,DLIST,R1		: compare to a delimiter
	JER	R2			: return if delimiter
	SIS	R1,1			: check next delimiter
	JGEBS	DELIM			: loop if any more delimiters
	J	4,R2			: skip-return

:	List of delimiter chars
DLIST	AC	' ,'			: Blank,","
	BC	8D,8A,89		: CR,LF,HT
DLEN	EQ	.-DLIST			: Number of delimiter chars

:	Input a Character
:	Link	R1
:	Normal-return:   ^W Input...Flush entry
: 	Skip-4 return:  ^A or ^H Input...flush last char
:	  SKIP-8 return: Char in R0 (high-bit on)
:	Aborts to command-scanner on "ESC"
DS.GCH	SVC	IN,0F			: get the char
	 J	DS.GCH
	OHI	R0,80			: set high-order bit
	CLHI	R0,9B			: check for escape
	 JE	DSTART			: abort, proceed with prompt if so
	CLHI	R0,97			: check for ^W
	 JER	R1			: normal-return
	CLHI	R0,81			: check for ^A
	 JE	4,R1			: Skip-4 return
	CLHI	R0,88			: check for ^H
	 JN	8,R1			: No, skip-8 return, Char in R0

	SVC	OUT,BKSPAC		: Back-space
	J	4,R1			: skip-4 return for ^H

:	Convert char in (R0) to upper-case
:	Link on R1
DS.CUC	CLHI	R0,0E1			: Compare with "a"
	JLR	R1			: Exit if it can't be lower-case
	CLHI	R0,0FA			: Compare with "z"
	JGR	R1			: Not lower-case...Just return
	SHI	R0,20			: Lower-case...Convert to upper-case
	JR	R1			: and return

	EM

  EI	: (DB.STA)
	SUBTTL	?STAT Command Handlers:  HELP, CODE, STATUS, INStructions, CRASH

:	BISYNC OPERATION MONITOR - THIS FILE IS USED FOR BOM FOR BOTH THE
:	STANDARD 3270 TERMINAL INTERFACE AND THE HONG KONG SHANGHAI BANK
:	CUSTOM 3270 TERMINAL INTERFACE.  USE CARE WHEN MAKING CHANGES OR
:	CORRECTIONS TO ENSURE THAT THEY WORK IN BOTH ENVIRONMENTS.  CODE
:	CNA BE IF SWITCHED USING THE LABEL:
:	HSBCSW	EQ	1		:1 MEANS FOR HSBC

:	Valid commands accepted are:

:	EXIT or EXI - log off
:	QUIT or Q - exit ?STAT (back to DDT)
:	HELP or ? - print this list
:	CODE - Describes code
:	INS or INST - Instructions
:	STATUS - Slot status
:	CODE - Crash information
:	MODE aaa - Reads or sets selection mode
:	QLINE ll - Query line status
:	QCU ll,cc - Query CU status
:	QDEV ll,cc,dd - Query device status
:	RESET - Reset CU error counts
:	RERR ll - Restart line error counts
:	DERR - Display error count
:	DNPLL - CUs not being polled
:	DNRSP - CUs not responding to polls
:	POLL ll,cc - Poll specified CUs
:	NOPOLL ll,cc - Stop polling specified CUs
:	KILL ll,cc,dd - Kill specified circuits
:	BUILD ll cc dd - Rebuild specified circuits
:	ECPS ll,m - Enable CPS trace
:	DCPS - Display CPS trace
:	EPR ll,cc,m - Enable poll response trace
:	DPR - Display poll response trace
:	ESTAMP ll,cc,dd,m - Enable timestamp trace
:	DSTAMP - Display timestamp trace
:	EREST ll,cc,dd,m - Enable response trace
:	DREST - Display response trace
:	EPROT ll,m - Enable protocol trace
:	DPROT - Display protocol trace
:	EDAT ll,cc,dd,m - Enable data trace
:	DDAT - Display data trace
:	DISABLE - Halt enabled traces


:	Error diagnostics:

:	Bad line number
:	Bad TC number
:	Bad Terminal number


:	Conventions:
:	R11 -	Current terminal number
:	R12 -	Final terminal number
:	R13 -	Current TC number
:	R14 -	Final TC number
:	R15 -	Current line number

:	Some globals
	GL	CTA


	SEG	A.CODE
	MO	.,STATUS
        LO      BSCSXM


:	First of all, We'll define some MACROs to make the code more readable!


	KILL	IFERR,GETNUM,PRINT,DPRINT	: Insure no conflicts

:	MACRO to input a number (into R0):
:	ARG -	radix to be used

GETNUM	MACRO(RAD)[
 IF	$A RAD-15
	LHI	R4,$A RAD
 ELSE
	LIS	R4,$A RAD
 EI
	JAL	R5,DS.NUM,,
]

:	MACRO to print a number (in R0) on terminal
:	ARG	Use
:	 1	Number of Digits
:	 2	Any sum of:	.S, .B, .Z, one of [ .D, .H, or .O]

.S	EQ	80			: Signed output
.B	EQ	20			: Blank fill
.Z	EQ	40			: Zero fill
.D	EQ	0A			: Decimal
.O	EQ	08			: Octal
.H	EQ	10			: Hexidecimal

DPRINT	MACRO(ND,M2)[
	LHI	R1,(ND*100)!M2
	SVC	KIO,$A 10
]

:	MACRO to print a line of text on terminal
:	ARG -	address of line of text (SC format)

PRINT	MACRO(LINE)[
	SVC	K.OUT,LINE
]

:	MACRO to perform test, print MSG if false
IFERR	MACRO(CND,MSG)[
	J`CND`FS	.+8
	LA	R1,MSG
	J	PERR
]

:	MACRO to see if last delimiter was a carriage return, jumps to ADR
:	if not carriage return to process following argument
ANYARG	MACRO(ADR)[
	LHI	R0,8D
	CLB	R0,DS.DLM,,
	JN	ADR
]

	DS.CMD(HELP,HELP)		: Print Command List
	DS.CMD(?,HELP)			: Print Command List
	DS.CMD(CODE,CODE)		: Print Banner (which code this is).
	DS.CMD(INS,INSTR)		: Print instructions
	DS.CMD(INST,INSTR)		: Print instructions
	DS.CMD(STATUS,STAT)		: Print status of slot
	DS.CMD(CRASH,CRSH.R)		: Print information on last cras

HELP	HS	0
	JAL	R2,BANNER		:PRINT BANNER
	PRINT(HELP01)
	PRINT(HELP02)
	PRINT(HELP03)
	PRINT(HELP04)
	PRINT(HELP05)
	PRINT(HELP06)
	PRINT(HELP07)
	PRINT(HELP08)
	PRINT(HELP09)
	PRINT(HELP0A)
	PRINT(HELP0B)
	PRINT(HELP0C)
	PRINT(HELP0D)
	PRINT(HELP0E)
	PRINT(HELP0F)
	PRINT(HELP10)
	PRINT(HELP11)
	PRINT(HELP12)
	PRINT(HELP13)
	PRINT(HELP14)
	PRINT(HELP15)
	PRINT(HELP16)
	PRINT(HELP17)
	PRINT(HELP18)
	PRINT(HELP19)
	PRINT(HELP1A)
	PRINT(HELP1B)
	PRINT(HELP1C)
	PRINT(HELP1D)
	PRINT(HELP1E)
	PRINT(HELP1F)
	PRINT(HELP20)
	PRINT(HELP21)
	PRINT(HELP22)
	J	DSTART,,

CODE	JAL	R2,BANNER		:Print banner
	PRINT(TRMVER)			:print version number
	LHI	R0,VERSION
	DPRINT(3,.O!.B)
	PRINT(DOT)
	LHI	R0,REVLEV
	DPRINT(2,.O!.Z)
	PRINT(NL)
	PRINT(SLTID)			:print slot id
	LHI	R0,SID
	DPRINT(3,.H!.B)
	PRINT(KHOST)			:print kernal host number
	LHL	R0,HOSTX,,
	DPRINT(5,.D!.B)
	PRINT(OHOST)			:print origination host number
	LHI	R0,ORGHST
	DPRINT(5,.D!.B)
	PRINT(ASSM)			:print date and time of assembly
	LI	R3,ASMTIM
	LHI	R4,10
	LA	R5,DATTMS,,
	JAL	R6,DATIME
	SVC	K.OUT,PDATE,,		:output date and time

        PRINT(NLNH)                     : print # of lines etc

	IF	HSBCSW
        LHI     R0,N.UNK                : print # of unknown terminals (if any)
        JEFS    CODE8
        PRINT(NUNKH)
	EI	:HSBCSW

CODE8
	PRINT(NL)			:new line
	LHI	R0,NBILM		:number of lines
	DPRINT(4,.D!.B)
	LHI	R0,NCUM			:number of control units
	DPRINT(7,.D!.B)
	LHI	R0,NDEVM		:number of terminals
	DPRINT(7,.D!.B)

	IF	HSBCSW
	LHI	R0,N.ATM		:number of ATM's
	DPRINT(6,.D!.B)
	LHI	R0,N.PDP		:number of PDP's
	DPRINT(6,.B!.D)
	LHI	R0,N.VDU		:number of VDU's
	DPRINT(6,.D!.B)
	LHI	R0,N.TT			:number of TT's
	DPRINT(5,.D!.B)
	LHI	R0,N.GTP		:number of GTP's
	DPRINT(6,.B!.D)
	LHI	R0,N.UNK		:unknown terminals
	JEFS	CODE10
	LHI	R0,N.UNK
	DPRINT(6,.D!.B)
	EI	:HSBCSW

CODE10
	J	DSTART,,

:	STAT - prints out status information  for slot

STAT	JAL	R2,BANNER		:display banner
	PRINT(HOST)			:host status etc
	L	R1,CTA+60,,		:get pointer to PORTS in CTA
	LB	R1,0,R1			:get host status
	SRLS	R1,6			:right justify 2 bits of host status
	JEFS	STAT05			:00 - answered
	CHI	R1,1
	JEFS	STAT06			:01 - down
	CHI	R1,2
	JEFS	STAT07			:10 - shut
	PRINT(GONE)			:11 - gone (only other choice)
	JFS	STAT08
STAT05	PRINT(ANSW)
	JFS	STAT08
STAT06	PRINT(DOWN)
	JFS	STAT08
STAT07	PRINT(SHUT)
STAT08	LHL	R0,STARTS,,		:get number of times slot started
	SIS	R0,1			:subtract 1 for restarts
	DPRINT(0B,.D!.B)
	PRINT(SPACE4)
	L	R3,LSTART,,		:get time of last start
	JLEFS	NLSTRT			:skip if time not available
	LHI	R4,10			:number of chars to output
	LA	R5,DATTMS,,		:where to put time for output
	JAL	R6,DATIME		:convrt time from GMT to normal
	SVC	K.OUT,PDATE,,		:send it out
	JFS	STAT10
NLSTRT	PRINT(NOTAVL)			:if start itme not available

STAT10	LIS	R2,0
	LIS	R3,0
	LHI	R1,(NDEVB*2)-1		:number of bytes of DEVBUS array
STAT20	LB	R6,DEVBUS,R1,,		:get count of busy devices
	LR	R5,R6			:transfer to R%
	NHI	R5,0F			:strip off all but rightmost 4 bits
	LB	R5,BITCNT,R5
	AR	R2,R5			:accumulate count
	LR	R5,R6			:do other half of byte
	SRLS	R5,4
	LB	R5,BITCNT,R5
	AR	R2,R5
	LB	R7,DEVPVC,R1,,		:check for PVC circuits
	NR	R6,R7			:but only if device busy
	LR	R5,R6			:transfer to R%
	NHI	R5,0F			:strip off all but rightmost 4 bits
	LB	R5,BITCNT,R5
	AR	R3,R5			:accumulate count
	LR	R5,R6			:do other half of byte
	SRLS	R5,4
	LB	R5,BITCNT,R5
	AR	R3,R5
	SIS	R1,1			:for all bytes of DEVBUS
	JGE	STAT20
	LR	R0,R2			:put numb of circuits in R0
	DPRINT(8,.B!.D)			:output count
	LR	R0,R3			:put numb of PVC circuits in R0
	DPRINT(0E,.D!.B)

	PRINT(BUFL)			:print buffers left
	LH	R0,BUFCNT		:get number of free buffers
	DPRINT(6,.B!.D)
	LHI	R0,NBBFLT		:get number of used buffers
	SH	R0,BUFCNT
	DPRINT(0C,.B!.D)
	LH	R0,BFZPS,,		:get umber of circuit zaps due to
					:insufficient buffers
	DPRINT(0B,.D!.B)
	LH	R0,CMDCNT		:get number of free command links
	DPRINT(0D,.D!.B)
	LHI	R0,NCMDLK		:get number of command links used
	SH	R0,CMDCNT
	DPRINT(0D,.D!.B)
	LH	R0,CMDZPS,,		:get number of circuits zapped due to
					:insufficient command links
	DPRINT(0D,.B!.D)
	J	DSTART,,

:	CRSH.R - Prints information about the last crash.  This includes
:	crash time, crash point, crash code, PSW, registers stack, jump table,
:	IRING, and ORING.  If SVRNGS is 1, IRING and ORING are saved, if
:	SVRNGS is 0, they aren't saved.

	LO	CRASH
CRSH.R	JAL	R2,BANNER		:display banner
	PRINT(CCNT)			:display crash count
	LHL	R0,CRAT,,		:get count
	DPRINT(4,.B!.H)			:display it
	SIS	R0,1
	JLE	CSHRND			:stop here is only one crash

	PRINT(TIME)			:display time in GMT of last crash
	L	R3,CTIME,,
	JLEFS	CSHR05
	LHI	R4,10
	LA	R5,DATTMS,,
	JAL	R6,DATIME		:convert time to character string
	SVC	K.OUT,PDATE,,		:print it
	JFS	CSHR10
CSHR05	PRINT(NOTAVL)			:not avail if zero or neg

CSHR10	PRINT(FSTC)			:display time of crash in FASTC
	L	R0,FTIME,,
	JLEFS	CSHR15
	DPRINT(8,.Z!.H)
	JFS	CSHR20
CSHR15	PRINT(NOTAVL)			:not avail if zero or neg

CSHR20	PRINT(CPNT)			:display crash point
	L	R0,CRAT+CPOINT,,
	DPRINT(8,.Z!.H)

	PRINT(CCODE)			:display crash code
	LHL	R0,CRAT+CRASHC,,
	DPRINT(4,.B!.H)

	PRINT(CPSW)			:display PSW at time of crash
	L	R0,PSWSAV,,
	DPRINT(8,.Z!.H)

	PRINT(NL)
	PRINT(REGS)			:display registers at time of crash
	PRINT(NL)
	LIS	R2,0
	LIS	R3,4
CSHR25	L	R0,CRAT+CRXREG,R2,	:get register
	DPRINT(8,.Z!.H)			:and display it
	AIS	R2,4
	CHI	R2,4*10			:are we done
	JGEFS	CSHR30			:if yes, jump
	SIS	R3,1			:time for new line
	JEFS	CSHR26			:if so, do it
	PRINT(SPACE2)			:else, print 2 spaces
	J	CSHR25			:and do next
CSHR26	PRINT(NL)			:new line
	LIS	R3,4
	J	CSHR25			:and do next
	
CSHR30	PRINT(STCK)			:display stack
	LIS	R2,0			:get stack size
	LIS	R3,6			:numb of words per line
CSHR35	L	R0,SAVSTK,R2,		:get word of stack
	DPRINT(8,.Z!.H)			:print it
	AIS	R2,4
	CHI	R2,STCKSZ*4		:are we done
	JGE	CSHR40			:if so, jump
	SIS	R3,1			:is it end of line
	JGFS	CSHR36
	PRINT(NL)			:if so, start new line
	LIS	R3,6
	J	CSHR35
CSHR36	PRINT(SPACE2)			:else, print 2 spaces
	J	CSHR35			:and go do next word

CSHR40	PRINT(JPX)			:jump trace index
	L	R0,SAVTRX,,
	DPRINT(8,.H!.Z)
	PRINT(JPTB)			:jump table

	LHI	R2,-80			:init index into jump table
	LIS	R3,4			:new line counter
CSHR45	L	R0,SAVTRC+80,R2,	:get trace element
	DPRINT(8,.H!.Z)
	AIS	R2,4			:are we done yet
	JGE	CSHR50
	SIS	R3,1			:new line yet
	JLEFS	CSHR47
	PRINT(SPACE2)			:else, two spaces
	JBS	CSHR45			:and do it again
CSHR47	PRINT(NL)			:new line
	LIS	R3,4			:init for next new line
	J	CSHR45			:and do it again

CSHR50
	IF	SVRNGS	
	PRINT(IPNT)			:iring pointer
	LHL	R0,SAVIRX,,		:get pointers
	DPRINT(4,.H!.Z)
	PRINT(SPACE2)
	LHL	R0,SAVIRX+2,,
	DPRINT(4,.H!.Z)
	PRINT(ISZ)			:IRSIZE
	LI	R0,IRSIZE
	DPRINT(8,.H!.B)
	PRINT(IRNG)			:iring

	LI	R2,-IRSIZE		:init index into iring
	LIS	R3,8			:init new line index
CSHR55	LHL	R0,SVIRNG+IRSIZE,R2,	:get halfword from iring
	DPRINT(4,.H!.Z)			:and print it
	AIS	R2,2			:are we done yet
	JGEFS	CSHR60
	SIS	R3,1			:are we ready for a new line
	JLEFS	CSHR57
	PRINT(SPACE2)			:else, print two spaces
	JBS	CSHR55			:do it again
CSHR57	PRINT(NL)			:new line
	LIS	R3,8			:init for next new line
	J	CSHR55			:and do it again

CSHR60	PRINT(OPNT)			:oring pointer
	LHL	R0,SAVORX,,		:get pointers
	DPRINT(4,.H!.Z)
	PRINT(SPACE2)
	LHL	R0,SAVORX+2,,
	DPRINT(4,.H!.Z)
	PRINT(OSZ)			:ORSIZE
	LI	R0,ORSIZE
	DPRINT(8,.H!.B)
	PRINT(ORNG)			:oring

	LI	R2,-ORSIZE		:init index into oring
	LIS	R3,8			:init new line index
CSHR65	LHL	R0,SVORNG+ORSIZE,R2,	:get halfword from oring
	DPRINT(4,.H!.Z)			:and print it
	AIS	R2,2			:are we done yet
	JGEFS	CSHR70
	SIS	R3,1			:are we ready for a new line
	JLEFS	CSHR67
	PRINT(SPACE2)			:else, print two spaces
	JBS	CSHR65			:do it again
CSHR67	PRINT(NL)			:new line
	LIS	R3,8			:init for next new line
	J	CSHR65			:and do it again
	EI	:SVRNGS

CSHR70
CSHRND	J	DSTART,,
	FO	CRASH

:	CRSH.P - Code to do extended crash processing.  Save IRING
:	and ORING, time of crash in fastc, stack, jump trace.

	LO	CRASH
CRSH.P
	LHL	R0,CRAT			:has slot crashed more than once
	SIS	R0,1
	JGFS	CSHP05
	JR	R5			:if not, just return

CSHP05	L	R0,FASTC,,		:get FASTC and save
	ST	R0,FTIME,,

:  copy stack at time of crash

	LA	R3,STACK+(STCKSZ*4)-2,,	:end of source block
	LA	R4,SAVSTK+(STCKSZ*4)-2,, :end of destination block
	LHI	R1,10*((STCKSZ*2)-1)	:10*(number of halfwords -1)
	COPY	R3,R1			:copy stack

: copy jump trace at time of crash

	 LO	TRACE
	LA	R3,TRING+(20*4)-2	:end of jump trace table
	 FO	TRACE
	LA	R4,SAVTRC+(20*4)-2,,	:end of jump trace save area
	LHI	R1,((21*2)-1)*10	:(number of halwords-1)*10
	COPY	R3,R1			:copy jump trace table and index

: copy iring and oring at time of crash

	IF	SVRNGS
	L	R1,ORING,,		:get oring pointers
	ST	R1,SAVORX,,		:and save...can't copy 1st hword of seg
	LA	R3,IRING+4+IRSIZE-2,,	:address of last hword of rings
	LA	R4,SVIRNG+IRSIZE-2,,	:edn of oring-iring save area
	LI	R1,(((IRSIZE+ORSIZE+4)/2)-1)*10 :(numb of hwords-1)*10
	COPY	R3,R1			:copy oring, iring pointers, &iring
	EI	:SVRNGS
	JR	R5			:and return

	SEG	A.BOM
FTIME	WC	0			:FASTC at time of last crash, zero
					:if not yet crashed

:	Storage for crash information

	SEG	A.BOM
SAVSTK	WS	STCKSZ			:stack save area
SAVTRX	WS	1			:jump trace index
SAVTRC	WS	20			:jump trace table save area

: Ring storage area

	IF	SVRNGS
	WS	0
SAVORX	HS	2			:ORING pointers
SVORNG	BS	ORSIZE			:ORING save area
SAVIRX	HS	2			:IRING pointers
SVIRNG	BS	IRSIZE			:IRING save area
	EI	:SVRNGS

	SEG	1
	FO	CRASH

:	INSTR - Print editing characters and delimiters

INSTR	JAL	R2,BANNER		: display banner
	PRINT(INSTM1)			: display text
	PRINT(INSTM2)
	PRINT(INSTM3)
	PRINT(INSTM4)
	PRINT(INSTM5)
	PRINT(INSTM6)
	PRINT(INSTM7)
	PRINT(INSTM8)
	J	DSTART,,


HELP01	SC	/"8D"8AValid commands are:/
HELP02	SC	/"8D"8AEXIT or EXI - log off/
HELP03	SC	/"8D"8AQUIT or Q - exit ?STAT (back to DDT)/
HELP04	SC	/"8D"8AHELP or ? - print this list/
HELP05	SC	/"8D"8ACODE - Describes code/
HELP06	SC	/"8D"8AINS or INST - Instructions/
HELP07	SC	/"8D"8ASTATUS - Slot status/
HELP08	SC	/"8D"8ACODE - Crash information/
HELP09	SC	/"8D"8AMODE aaa - Reads or sets selection mode/
HELP0A	SC	/"8D"8AQLINE ll - Query line status/
HELP0B	SC	/"8D"8AQCU ll,cc - Query CU status/
HELP0C	SC	/"8D"8AQDEV ll,cc,dd - Query device status/
HELP0D	SC	/"8D"8ARESET - Reset CU error counts/
HELP0E	SC	/"8D"8ARERR ll - Restart line error counts/
HELP0F	SC	/"8D"8ADERR - Display error count/
HELP10	SC	/"8D"8ADNPLL - CUs not being polled/
HELP11	SC	/"8D"8ADNRSP - CUs not responding to polls/
HELP12	SC	/"8D"8APOLL ll,cc - Poll specified CUs/
HELP13	SC	/"8D"8ANOPOLL ll,cc - Stop polling specified CUs/
HELP14	SC	/"8D"8AKILL ll,cc,dd - Kill specified circuits/
HELP15	SC	/"8D"8ABUILD ll cc dd - Rebuild specified circuits/
HELP16	SC	/"8D"8AECPS ll,m - Enable CPS trace/
HELP17	SC	/"8D"8ADCPS - Display CPS trace/
HELP18	SC	/"8D"8AEPR ll,cc,m - Enable poll response trace/
HELP19	SC	/"8D"8ADPR - Display poll response trace/
HELP1A	SC	/"8D"8AESTAMP ll,cc,dd,m - Enable timestamp trace/
HELP1B	SC	/"8D"8ADSTAMP - Display timestamp trace/
HELP1C	SC	/"8D"8AEREST ll,cc,dd,m - Enable response trace/
HELP1D	SC	/"8D"8ADREST - Display response trace/
HELP1E	SC	/"8D"8AEPROT ll,m - Enable protocol trace/
HELP1F	SC	/"8D"8ADPROT - Display protocol trace/
HELP20	SC	/"8D"8AEDAT ll,cc,dd,m - Enable data trace/
HELP21	SC	/"8D"8ADDAT - Display data trace/
HELP22	SC	/"8A"8DDISABLE - Halt enabled traces/

INSTM1	SC	/"8D"8AEditing characters are:/
INSTM2	SC	/"8D"8AESC   - abort back to command level/
INSTM3	SC	/"8D"8A^W    - discards partial token/
INSTM4	SC	/"8D"8A^A    - discards last char of token (backspace)/
INSTM5	SC	/"8D"8A^H    - discards last char of token (backspace)/
INSTM6	SC	/"8D"8A"8AValid delimiters are:/
INSTM7	SC	/"8D"8A LF  HT  ' ' and ','./
INSTM8	SC	/"8A"8DCR terminates command line./

NL	SC	/"8D"8A/		: new-line (CR/LF)
SPACE1	SC	/ /			: 1 space
SPACE2	SC	/  /			: 2 spaces
SPACE3	SC	/   /			: 3 spaces
SPACE4	SC	/    /			: 4 spaces
SPACE5	SC	/     /			: 5 spaces
DOT	SC	/./			: dot
COLON	SC	/:/			: colon

TRMVER	SC	/"8A"8D3270 TERMINAL INTERFACE  VERSION/
SLTID	SC	/"8A"8DSID/
KHOST	SC	/    KHOST/
OHOST	SC	/    ORGHST/
ASSM	SC	/    ASSM  /

	IF	HSBCSW
NLNH    SC      /"8A"8A"8D#LINE   #CU   #DEV   ATM   PDP   VDU   TT   GTP/
NUNKH   SC      /   UNK/
	ELSE
NLNH    SC      /"8A"8A"8D#LINE   #CU   #DEV/
	EI	:HSBCSW

HOST	SC	/"8A"8DHOST     RESTRTS      LAST START      CIRCUITS   PVC CIRCUITS"8A"8D/
NOTAVL	SC	/  NOT AVAILABLE /
BUFL	SC	/"8A"8A"8DBUF LEFT   BUF USED   BUF ZAPS   CMDLNK LEFT   CMDLNK USED   CMDLNK ZAPS"8A"8D/
GONE	SC	/GONE/
SHUT	SC	/SHUT/
DOWN	SC	/DOWN/
ANSW	SC	/ANSW/

TIME	SC	/"8A"8DTIME  /
FSTC	SC	/"8A"8DFASTC  /
CPNT	SC	/"8A"8DCRASH POINT  /
CCODE	SC	/"8A"8DCRASH CODE  /
CPSW	SC	/"8A"8DPSW  /
CCNT	SC	/"8A"8DCRASH COUNT  /
REGS	SC	/"8A"8DREGISTERS"8A"8D/
STCK	SC	/"8A"8D"8ASTACK"8A"8A"8D/
JPX	SC	/"8A"8A"8DJUMP INDEX  /
JPTB	SC	/"8A"8A"8DJUMP TABLE"8A"8A"8D/
IPNT	SC	/"8A"8A"8DIRING POINTERS  /
ISZ	SC	/"8A"8A"8DIRSIZE  /
IRNG	SC	/"8A"8D"8AIRING"8A"8A"8D/
OPNT	SC	/"8A"8A"8DORING POINTERS  /
OSZ	SC	/"8A"8A"8DORSIZE  /
ORNG	SC	/"8A"8D"8AORING"8A"8A"8D/



:	BITCNT - TABLE GIVES NUMBER OF BITS SET IN BYTE, USED TO
:	DETERMINE NUMBE OF BITS SET IN BIT ARRAY

BITCNT	BC	0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4

	SUBTTL	?STAT Command Handlers:  QLINE, QCU, QDEV, RESET, DERR, RERR

	DS.CMD(QLINE,QLN)		: Query line
	DS.CMD(QCU,QCU)			: Query control unit
	DS.CMD(QDEV,QDV)		: Query device
	DS.CMD(RESET,RECNT)		: Reset error counts
	DS.CMD(RERR,RER)		: Reset error counts in bins
	DS.CMD(DERR,DER)		: Display error counts from bins
	HS	0


:	QLN - Query line.  Prints status of specified line or status of
:	all lines if no line is specified.

QLN	ANYARG(QLN10)			:is a line specified
	JAL	R2,BANNER		:no...print banner
	PRINT(LNHD1)			:print line status headings
	LIS	R15,0			:start with line 0
QLN05	CHI	R15,NBILM-1		:is this a valid line
	JG	DSTART			:quit when done
	JAL	R5,PLST			:go print status for this line
	AIS	R15,1			:next line
	JBS	QLN05			:till done

QLN10	JAL	R7,GETLIN		:go get line number
	JAL	R2,BANNER		:print banner
	PRINT(LNHD1)			:print line status heading
	JAL	R5,PLST			:print status for specified line
	J	DSTART			:that's all

:	QCU - Query control unit.  Prints status of specified control unit
:	or status of all control units on given line if only line number
:	is specified.

QCU	JAL	R7,CHKSYN		:check syntax
	LH	R0,CMODE,,		:if in REL mode, there is no line number
	JL	QCU10			:so skip to get CU number
	JAL	R7,GETLIN		:go get line number
	ANYARG(QCU10)			:is there a CU specified
	LB	R12,FCU,R15		: get first controller
	LB	R13,FCU+1,R15		: get first controller of next line
	JAL	R2,BANNER		:go print banner
	PRINT(CUHD1)			:go print heading
QCU05	JAL	R5,PCST			:go print CU status
	AIS	R12,1			:next CU
	CR	R12,R13
	JLBS	QCU05			:til done
	J	DSTART

QCU10	JAL	R7,GETCU		:go get CU number
	JAL	R2,BANNER		:go print banner
	PRINT(CUHD1)			:go print heading
	JAL	R5,PCST			:go print CU status
	J	DSTART

:	QDV - Query device.  Prints device status for specified device
:	or for all devices on CU if no device is specified.  The line and
:	CU number must be specified, unless in REL mode

QDV	JAL	R7,CHKSYN		:check syntax
	LH	R0,CMODE,,		:if in REL mode, there is no LINE or CU number
	JL	QDV20			:so skip to get device number
	JAL	R7,GETLIN		:go get line number
	JAL	R7,CHKSYN		:check syntax

QDV10	JAL	R7,GETCU		:go get Cu number
	ANYARG(QDV20)			:is there a device specified
	LB	R11,FDEV,R12		:get first device on CU
	LB	R14,FDEV+1,R12		:get first device on next CU
	JAL	R2,BANNER		:go print banner
	PRINT(DVHD1)			:go print heading
QDV15	JAL	R5,PDST			:go print device status
	AIS	R11,1			:for next device
	CR	R11,R14
	JLBS	QDV15			:until done
	J	DSTART

QDV20	JAL	R7,GETDV		:go get device number
	JAL	R2,BANNER		:go print banner
	PRINT(DVHD1)			:go print heading
	JAL	R5,PDST			:go print device status
	J	DSTART

:	PLST	 - print line status.  Relative line number, line address,
:	line ID number, sync port number, number of CUs, number of devices,
:	and whether RTS, HNG, and DSR are required.
:	R5	link

PLST	PRINT(NL)			: new line
	LR	R0,R15			: line number
	DPRINT(3,.B!.D)			: 4 decimal digits, blank fill
        LB      R0,LNADR,R15,            : line adr
        DPRINT(7,.H!.B)
        LHL     R0,EDPLN,R15,R15        : EDP (TELCO) Line number
        DPRINT(7,.B!.D)
        LB      R6,XLUN,R15,            : logical unit number
        LA      R7,INFO,,               : buffer adr
        LIS     R8,3                    : # of attributes to return
        SVC     IOCTRL,8000+R6,,	: query status (get port #)
        J       PLST05                  : bad return from SVC call
        LB      R0,INFO+1,,             : port number
        LB      R1,INFO,,               : port type
        JEFS    PLST06                  : 0 means synch
PLST05  LHI     R0,$A 99                : flag bad port #
PLST06  DPRINT(6,.B!.D)                 : print port #
	LB	R4,FCU,R15		:get first cu for line
	LB	R0,FCU+1,R15		:get first CU for next line
	SR	R0,R4			:subtract to get number of CUs on line
	DPRINT(7,.D!.B)
	LB	R2,FCU+1,R15		:get first CU on next line
	LB	R3,FDEV,R4		:get first device on first CU for line
	LB	R0,FDEV,R2		:get first device on first CU for next line
	SR	R0,R3			:subtract to get number of devices on line
	DPRINT(7,.D!.B)
	TBT	R15,RTSCTS,,		:is RTS/CTS required
	JEFS	PLST07			:if no, jump
	LIS	R0,1
	JFS	PLST08
PLST07	LIS	R0,0
PLST08	DPRINT(5,.D!.B)
	TBT	R15,DHNGBT,,		:is hang logic required
	JEFS	PLST09			:if no jump
	LIS	R0,1
	JFS	PLST10
PLST09	LIS	R0,0
PLST10	DPRINT(6,.D!.B)
	 LO	BSCDTR
	TBT	R15,DTRDSR,,		:is DTR/DSR required or possible
	 FO	BSCDTR
	JEFS	PLST13			:if no, jump
	TBT	R15,BSCDSR		:if yes, is DSR high or low
	JEFS	PLST11			:if low, jump
	LIS	R0,1
	JFS	PLST12
PLST11	LIS	R0,0
PLST12	DPRINT(6,.D!.B)
	JFS	PLST14
PLST13	PRINT(QUEST)
PLST14	JR	R5			: ...and return

:	PCST - Print contol unit status information
:	R12	current relative CU number
:	R5	link

PCST	PRINT(NL)			:print new line
	LR	R0,R12			:print relative CU number
	DPRINT(2,.D!.B)
	IF	HSBCSW
	LB	R0,CUADR,R12,		:print CU address
	ELSE
	LB	R0,CULA,R12,		:print CU address
	EI	:HSBCSW
	DPRINT(6,.H!.B)
	LHL	R0,EDPCU,R12,R12	:print CU user defined ID
	DPRINT(6,.D!.B)
	LB	R1,FDEV,R12		:get first device for CU
	LB	R0,FDEV+1,R12		:get first device for next CU
	SR	R0,R1			:subtract to get numb of devices on CU
	DPRINT(5,.D!.B)

:	Get status of CU
	TBT	R12,POLLCU		:is it being polled
	JNFS	PCST05			:if yes, jump
	PRINT(NOTP)			:else, print NOPOLL
	JFS	PCST07
PCST05	TBT	R12,CUPOLL,,		:if polled, is CU responding
	JNFS	PCST06			:if yes h, jump
	PRINT(NOTR)			:else, print NO RESPONSE
	JFS	PCST07
PCST06	PRINT(CUACT)			:must be ACTIVE

PCST07	LHL	R0,PLLTO,R12,R12	:number of poll timeouts
	DPRINT(4,.H!.B)
	LHL	R0,RXMT,R12,R12		:number of retransmissions
	DPRINT(6,.H!.B)
	LHL	R0,XERR,R12,R12		:number of xmit errors
	DPRINT(7,.H!.B)
	L	R0,XMTTOT,R12,R12	:number of transmissions
	NI	R0,0FFFFFF		:only six hex digits
	DPRINT(7,.H!.B)
	LHL	R0,NAKS,R12,R12		:number of naks
	DPRINT(6,.H!.B)
	LHL	R0,RERR,R12,R12		:number of receive errors
	DPRINT(6,.H!.B)
	L	R0,RCVTOT,R12,R12	:number of msg blocks received
	NI	R0,0FFFFFF		:only six digits
	DPRINT(7,.H!.B)
	JR	R5			:and return

:       PDST - Print device status information
:	R11	current relative device number
:	R5	link

PDST	PRINT(NL)			: print new line
        LR      R0,R11                  : terminal number
        DPRINT(3,.B!.D)

	IF	HSBCSW
        LB      R0,DEVADR,R11           : terminal address
	ELSE
	LR	R1,R11			: put into R1
	SLLS	R1,2			: make fullword index
	LB	R0,DEVLA+2,R1,		: terminal address
	EI	:HSBCSW

        DPRINT(5,.H!.B)
        LHL     R0,EDPTN,R11,R11        : HSBC EDP terminal number
        DPRINT(6,.D!.B)

	IF	HSBCSW
        LB      R1,DTYPE,R11            : determine terminal type
        CLHI    R1,DV.ATM
        JNFS    PDST1
        PRINT(ATMMSG)
        J       PDST9
PDST1  CLHI    R1,DV.PDP
        JNFS    PDST2
        PRINT(PDPMSG)
        J       PDST9
PDST2  CLHI    R1,DV.VDU
        JNFS    PDST3
        PRINT(VDUMSG)
        J       PDST9
PDST3  CLHI    R1,DV.TT
        JNFS    PDST4
        PRINT(TTMSG)
        JFS	PDST9
PDST4  CLHI    R1,DV.GTP
        JNFS    PDST5
        PRINT(GTPMSG)
        JFS	PDST9
PDST5  PRINT(UNKMSG)
	EI	:HSBCSW

PDST9	TBT	R11,DEVPVC,,		:is device a PVC
	JEFS	PDST10
	LIS	R0,1
	JFS	PDST11
PDST10	LIS	R0,0
PDST11	DPRINT(4,.D!.B)
	TBT	R11,DEVCOL,,		:is device color capable
	JEFS	PDST12
	LIS	R0,1
	JFS	PDST13
PDST12	LIS	R0,0
PDST13	DPRINT(5,.D!.B)
	TBT	R11,DEVXPR,,		:can device handle extended features (transparent)
	JEFS	PDST14
	LIS	R0,1
	JFS	PDST15
PDST14	LIS	R0,0
PDST15	DPRINT(5,.D!.B)
	LB	R1,DEVLN,R11		:get line for device
	LB	R0,PFNET,R1		:get netkey for line (device)
	DPRINT(6,.H!.B)
	LHL	R2,DEVTAB,R11,R11	:get dcb for device
	LHL	R0,DPORT,R2,		:get dispatcher port for device
	DPRINT(6,.H!.B)
	LB	R0,DMODE,R2,		:get mode
	JEFS	PDST20			:0=idle
	SIS	R0,1
	JEFS	PDST21			:1=logon
	SIS	R0,1
	JEFS	PDST22			:2=ascii
	SIS	R0,1
	JEFS	PDST23			:3=native
	PRINT(MUNK)			:else, mode unknown
PDST20	PRINT(MIDLE)
	JFS	PDST25
PDST21	PRINT(MLOG)
	JFS	PDST25
PDST22	PRINT(MASC)
	JFS	PDST25
PDST23	PRINT(MNAT)
PDST25	LHL	R0,SS0SS1,R11,R11	:get last status halfword
	DPRINT(6,.H!.B)

	LB	R0,DMODE,R2,		:get current mode (R2 is RDCB)
	SIS	R0,3			:in NATIVE mode?
	JN	PDST30			:if not (IDLE, LOGON, OR ASCII), skip ahead
	LB	R0,DSPAPL,R2,		:get application id
	DPRINT(4,.B!.H)
	LB	R0,DSPCUA,R2,		:get control unit address (logical)
	DPRINT(4,.B!.H)
	LB	R0,DSPDVA,R2,		:get device address (logical)
	DPRINT(4,.B!.H)
	JFS	PDST35

PDST30	PRINT(NANA)			:not available'
PDST35	JR      R5			:and return

:	RER - Reset error counts in bins.  This resets the error
:	counts that are displayed by the DERR command.  It also
:	sets a new line (or all lines) to be monitored and sets a bit
:	in the array D.SHRT to indicate that the current count did not
:	start at the begining of the current hour.

RER	ANYARG(RER10)			:is a line specified
	LCS	R0,1			:prepare for all lines
	JFS	RER15
RER10	JAL	R7,GETLIN		:go get line number

RER15	STH	R0,E.LIN		:set current line (or whole slot) to monitore
	LCS	R0,1			:set all hours as not full
	ST	R0,E.SHRT		:(that is, not to be counted in average)
	JAL	R4,E.ZERR		:go zero bins
	J	DSTART

:	DER - Display error counts from bins.  Total each error type and
:	display total and average per hour.

DER	LH	R15,E.TIM		:get current time and see if data is valid
	JL	BADGMT			:GMT not available, data not valid
	CHI	R15,$A24		
	JGE	BADGMT
	SBT	R15,E.SHRT		:set current hour as not full
	ANYARG(DER10)			:if any args skip ahead
	JAL	R2,BANNER		:else, print banner and procede
	LCS	R8,1			:set do not print flag in R8
	LHI	R7,E.BINS-1		:number of bins to look at
	LR	R9,R7			:number of bins to include in average
	LH	R15,E.TIM		:get current time
	AIS	R15,1			:start with earliest bin
	CHI	R15,E.BINS-1		:have we gone too far
	JLFS	DER05			:no, skip ahead
	LIS	R15,0			:else, start with first bin
DER05	J	DER15			:go do it

DER10	GETNUM(10)			:get number of bins to display
	LR	R7,R0			:put into R7, numb of bins to look at
	JLE	BADPRM			:range check on low end
	CHI	R7,E.BINS		:range check on high end
	JGE	BADPRM
	JAL	R2,BANNER		:go print banner
	LR	R9,R7			:keep track of numb of bins to include in average
	LIS	R8,0			:set print flag to print
	LHI	R0,E.BINS		:compute first bin to print
	SR	R0,R7			:numb of bins - number to print
	LHL	R15,E.TIM		:get current time
	AR	R15,R0			:combine with previous difference
	CHI	R15,E.BINS-1		:is it ok, or do we need to wrap
	JLFS	DER15			:ok, skip ahead
	SHI	R15,E.BINS-1		:else, wrap

DER15	PRINT(NL)
	LH	R3,E.LIN		:slot or line
	JLFS	DER16			:if slot, skip ahead
	LR	R2,R15			:save R15
	LR	R15,R3			:put rel line into R15
	LR	R3,R7			:save R7
	JAL	R7,OUT.LN		:output line number, as per current mode
	LR	R15,R2			:restore R15
	LR	R7,R3			:restore R7
	JFS	DER17
DER16	PRINT(SLT)			:' -slot-'
DER17	PRINT(NL)
	PRINT(DERHD1)			:print heading

:	Zero accumulators for computing average
	LIS	R2,0			:R2 is E.PTO
	LIS	R3,0			:R3 is E.RTN
	LIS	R4,0			:R4 is E.XRR
	LIS	R5,0			:R5 is E.NAK
	LIS	R6,0			:R6 is E.RRR
:	Zero accumulators for real totals
	LIS	R10,0			:R10 is E.PTO
	LIS	R11,0			:R11 is E.RTN
	LIS	R12,0			:R12 is E.XRR
	LIS	R13,0			:R13 is E.NAK
	LIS	R14,0			:R14 is E.RRR

DER20	LR	R8,R8			:check print flag
	JLFS	DER201
	PRINT(NL)
	LR	R0,R15			:get time (bin#)
	DPRINT(3,.D!.B)
DER201	LHL	R0,E.PTO,R15,R15	:get numb of poll timeouts in bin
	AR	R10,R0			:bump total
	LR	R8,R8			:check print flag
	JLFS	DER21
	DPRINT(9,.D!.B)
DER21	TBT	R15,E.SHRT		:is it a full hour
	JNFS	DER22
	AR	R2,R0			:bump total for average
DER22	LHL	R0,E.RTN,R15,R15	:get numb of retransmissions
	AR	R11,R0			:bump total
	LR	R8,R8			:check print flag
	JLFS	DER23
	DPRINT(8,.D!.B)
DER23	TBT	R15,E.SHRT		:is it a full hour
	JNFS	DER24
	AR	R3,R0			:bump total for average
DER24	LHL	R0,E.XRR,R15,R15	:get numb of xmit errors
	AR	R12,R0			:bump total
	LR	R8,R8			:check print flag
	JLFS	DER25
	DPRINT(9,.D!.B)
DER25	TBT	R15,E.SHRT		:is it a full hour
	JNFS	DER26
	AR	R4,R0			:bump total for average
DER26	LHL	R0,E.NAK,R15,R15	:get numb of naks
	AR	R13,R0			:bump total
	LR	R8,R8			:check print flag
	JLFS	DER27
	DPRINT(8,.D!.B)
DER27	TBT	R15,E.SHRT		:is it a full hour
	JNFS	DER28
	AR	R5,R0			:bump total for average
DER28	LHL	R0,E.RRR,R15,R15	:get numb of receive errors
	AR	R14,R0			:bump total
	LR	R8,R8			:check print flag
	JLFS	DER29
	DPRINT(8,.D!.B)
DER29	TBT	R15,E.SHRT		:is it a full hour
	JNFS	DER30
	AR	R6,R0			:bump total for average
	JFS	DER35
DER30	LR	R8,R8			:check print flag
	JLFS	DER31
	PRINT(STAR)			:put asterik for not included in tot or ave
DER31	SIS	R9,1			:decrement divisor

DER35	SIS	R7,1			:decrement bins to look at counter
	JLEFS	DER40			:if done looking, skip ahead
	AIS	R15,1			:bump bin number to look at
	CHI	R15,E.BINS-1		:do we need to wrap
	JL	DER20			:no, go do next bin
	LIS	R15,0			:else, wrap
	J	DER20

DER40	RBT	R15,E.SHRT		:set last bin as full hour
	PRINT(NL)
	PRINT(NL)
	LR	R0,R10			:get poll timeout total
	DPRINT(0C,.D!.B)
	LR	R0,R11			:get retran total
	DPRINT(8,.D!.B)
	LR	R0,R12			:get xmit error total
	DPRINT(9,.D!.B)
	LR	R0,R13			:get nak total
	DPRINT(8,.D!.B)
	LR	R0,R14			:get receive error total
	DPRINT(8,.D!.B)
	PRINT(TOTS)

	PRINT(APH)			:compute and print averages
	LR	R0,R9			:is divisor 0
	JEFS	DER45
	LR	R0,R2			:get dividend PTO
	DHR	R0,R9
	LR	R0,R1
DER45	DPRINT(0C,.D!.B)

	LR	R0,R9			:is divisor zero
	JEFS	DER46
	LR	R0,R3			:get dividend RTN
	DHR	R0,R9
	LR	R0,R1
DER46	DPRINT(8,.D!.B)

	LR	R0,R9			:is divisor zero
	JEFS	DER47
	LR	R0,R4			:get dividend XRR
	DHR	R0,R9
	LR	R0,R1
DER47	DPRINT(9,.D!.B)

	LR	R0,R9			:is divisor zero
	JEFS	DER48
	LR	R0,R5			:get dividend NAK
	DHR	R0,R9
	LR	R0,R1
DER48	DPRINT(8,.D!.B)

	LR	R0,R9			:is divisor zero
	JEFS	DER49
	LR	R0,R6			:get dividend RRR
	DHR	R0,R9
	LR	R0,R1
DER49	DPRINT(8,.D!.B)
	J	DSTART
	
:	Storage for error counts

	SEG	A.BOM
:	As displayed by the QCU command

XMTTOT	WS	NCUM			:Number of message blocks xmitted (ETB & ETX)
RCVTOT	WS	NCUM			:Number of message block received (ETB & ETX)
PLLTO	HS	NCUM			:Number of poll timeouts
RXMT	HS	NCUM			:Number of retransmissions
XERR	HS	NCUM			:Number of xmit errors
NAKS	HS	NCUM			:Number of naks sent to control unit
RERR	HS	NCUM			:Number of receive errors
ZCNT	HS	0			:Label to use to zero counts

:	As displayed by the DERR command

E.PTO	HS	E.BINS			:Poll timeouts
E.RTN	HS	E.BINS			:Retransmissions
E.XRR	HS	E.BINS			:Xmit errors
E.NAK	HS	E.BINS			:Naks sent to CUs
E.RRR	HS	E.BINS			:Receive errors
E.ZCNT	HS	0


:       Table to store information about Line, Control Unit
:       , and Device 

LNADR	BS	NBILM		:Line address
CULN	BS	NDEVM		:Line number for each control unit
	IF	1-HSBCSW
CULA	BS	NCUM		:Unmasked control unit address
	EI
EDPLN	RE	NBILM		:EDP line number
	HC	$A999		:Default if EDP line number not defined
	ER
EDPCU	RE	NCUM		:EDP control unit number
	HC	$A99		:Default if not defined
	ER
EDPTN	RE	NDEVM		:EDP terminal number
	HC	$A9999		:Default if EDP terminal number not defined
	ER

: redefine macro to do third pass CONFIG

	KILL	DEFLN,DEFCU,DEFDEV,ECONF
	KILL	DEFCOL,DEFXPR,DEFELE,DEFPVC
	KILL	DEFCAL,DEFSTR,DEFMEN,DEFPTR
	KILL	MENDEV,LSTRST

: END CONFIGURATION MACRO
: NO ARGUMENTS
	
ECONF	MACRO
[
	ORG	SAVORG
	NUMBER	SAVORG
LNO	EQ	LNO+1
CUNO	EQ	CUNO+1
DEVNO	EQ	DEVNO+1
]

: DEFINE LINE MACRO
: PARAMETER C1 = LOGICAL ADDRESS 
:	    C2 = PF KEY FOR NET SCREEN
:	    C3 = CLEAR TO END/REQUEST TO SEND HANDSHAKE FLAG
:	    C4 = USER DEFINED LINE ID NUMBER

DEFLN	MACRO(C1,C2,C3,C4)
[
LNO	EQ	LNO+1
	SETO(LNADR,LNO)
	BC	C1
	SETO(EDPLN,LNO*2)
	IF	C4
	HC	$A C4
	ELSE
	HC	LNO
	EI
LC1	EQ	C1
CUX	EQ	0
]

: DEFINE CONTROL UNIT MACRO
: PARAMETER C1 = CONTROL UNIT ADDRESS
:	    C2 = USER DEFINE CU ID NUMBER

DEFCU	MACRO(C1,C2)
[
CUNO	EQ	CUNO+1
	IF	1-HSBCSW
	SETO(CULA,CUNO)
	BC	C1
	EI
CUC	EQ	C1
	SETO(EDPCU,CUNO*2)
	IF	C2
	HC	$A C2
	ELSE
	HC	CUX
	EI
DUX	EQ	0
]

: DEFINE DEVICE MACRO
: PARAMETERS  C    = POLLING ADDRESS 		 
:	      T    = CRT/PRT, SCREEN SIZE
:	      RPTRA= RELATED PRINTER ADDRESS
:	      TNUM = 4 DIGIT USER DEFINED DEVICE ID	       	         

DEFDEV	MACRO(C,T,RPTRA,TNUM)
[
DEVNO	EQ	DEVNO+1
	SETO(EDPTN,DEVNO*2)
	IF	TNUM
	HC	$A TNUM
	ELSE
	HC	DUX
	EI
DUX	EQ	DUX+1
]

: DEFINE COLOR MACRO

DEFCOL	MACRO
[
]

: DEFINE TRANSPARANCY MACRO

DEFXPR	MACRO
[
]

: DEFINE PVC MACRO

DEFPVC	MACRO
[
]

: MACRO TO DEFINE A LOGON ELEMENT 

DEFELE	MACRO
[
]

: MACRO TO DEFINE THE CALLING ADDRESS

DEFCAL	MACRO
[
]

: MACRO TO DEFINE LOGON STRING

DEFSTR	MACRO
[
]

: MACRO TO DEFINE A MANU

DEFMEN	MACRO
[
]

: MACRO TO DEFINE LABELS FOR PRINTER DEVICES

DEFPTR	MACRO
[
]

: MACRO TO DEFINE THE DEVICE MANU MAPPINGS

MENDEV	MACRO
[
]

: MACRO TO START LOGON STRING SECTION

LSTRST	MACRO
[
]

: CALL THE CONFIGURATIOON MACRO

	CONFIG

:
	SEG	A.CODE

:	RECNT - reset error counts to zero (XMTTOT, RCVTOT, PLLTO, RXMT,
:	XERR, NAKS, and RERR).

RECNT	JAL	R4,ZERRCT		:go zero counts
	J	DSTART			:that's all

:	ZERRCT - Zero error counts.  Called by RECNT and by IZBOM.
:	R4	link

ZERRCT	LIS	R0,0
	LHI	R1,ZCNT-XMTTOT-2	:number of bytes to zero -2
ZRCT1	STH	R0,XMTTOT,R1,   	:zero locations
	SIS	R1,2
	JGEBS	ZRCT1			:til done
	JR	R4			:and return

:	E.ZERR - Zero error counts.
:	R4	link

E.ZERR	LIS	R0,0
	LHI	R1,E.ZCNT-E.PTO-2	:number of bytes to zero -2
E.ZER1	STH	R0,E.PTO,R1,	   	:zero locations
	SIS	R1,2
	JGEBS	E.ZER1			:til done
	JR	R4			:and return


LNHD1	SC	/"8A"8DLINE   LADR   LID   SPRT   #CU   #DEV   RTS   HNG   DSR"8A"8D/
QUEST	SC	/     ?/
CUHD1	SC	/"8A"8DCU  CUADR  CID  #DEV    STATUS    PTO  REXMT  XERR   XTOT  NAKS  RERR   RTOT"8A"8D/

	IF	HSBCSW
DVHD1	SC	'"8A"8DDEV  DADR  DID  TYPE  PVC  COL  XPR  NKEY  DPRT  STATE    S/S   AP  CA  DA"8A"8D'
	ELSE
DVHD1	SC	'"8A"8DDEV  DADR  DID  PVC  COL  XPR  NKEY  DPRT  STATE    S/S   AP  CA  DA"8A"8D'
	EI	:HSBCSW

DERHD1	SC	/"8A"8DHOUR     PTO   RE-TRAN    XERR    NAKS    RERR"8D"8A/

NOTP	SC	/     NOPOLL   /
NOTR	SC	/  NO RESPONSE /
CUACT	SC	/     ACTIVE   /

	IF	HSBCSW
ATMMSG  SC      /   ATM/
PDPMSG  SC      /   PDP/
VDUMSG  SC      /   VDU/
TTMSG   SC      /   TT /
GTPMSG  SC      /   GTP/
UNKMSG  SC	/    ? /
	EI	:HSBCSW

MIDLE	SC	/    IDLE  /
MLOG	SC	/   LOGIN  /
MASC	SC	/   VIRTUAL/
MNAT	SC	/   NATIVE /
MUNK	SC	/     ??   /
STAR	SC	/*/
TOTS	SC	/    TOTALS"8A"8D/
APH	SC	/"8A"8DAVERAGE PER HOUR"8A"8D/
NANA	SC	/  NA  NA  NA/
	SUBTTL	?STAT Command Handlers:  POLL, NOPOLL, KILL, BUILD

	DS.CMD(POLL,PLL)		:poll specified CU
	DS.CMD(NOPOLL,NPLL)		:stop polling specified CU
	DS.CMD(KILL,KLL)		:zap specified circuits
	DS.CMD(BUILD,BLD)		:rebuild killed PVC's

:	Open Line
PLL	LCS	R9,1			: set "poll" flag
	JFS	PLL05			: ...and skip to common code


NPLL	LIS	R9,0			: set "nopoll" flag and fall through

:	Resume or stop polling on line or CU specified
PLL05	JAL	R7,CHKSYN		:check syntax
	LH	R0,CMODE,,		:if in REL mode, there is no line number
	JL	PLL10			:so skip to get CU number
	JAL	R7,GETLIN		:go get line number
	ANYARG(PLL10)			:is there a CU specified
	LB	R13,FCU,R15		: get first controller
	LB	R14,FCU+1,R15		: get first controller of next line

	IF	HSBCSW
PLL06	LR	R9,R9			: open/close?
	JEFS	PLL07			: close
	TBT	R13,HSTNPL		:is host polling
	JNFS	PLL08			:if not, skip to next CU
	SBT	R13,POLLCU		: set open
	RBT	R13,BOMNPL		: and set not closed by bom
	JFS	PLL08

PLL07	RBT	R13,POLLCU		: set closed
	SBT	R13,BOMNPL		:by bom

PLL08	AIS	R13,1			: for next CU
	CR	R13,R14
	JL	PLL06			:repeat until done
	J	DSTART

PLL10	JAL	R7,GETCU		:go get CU number
	LR	R9,R9			:start or stop polling
	JEFS	PLL11			: closed
	TBT	R0,HSTNPL		:is host pollin
	JN	DSTART			:if not, thats all
	SBT	R0,POLLCU		: set open
	RBT	R0,BOMNPL		:and not closed by bom
	J	DSTART

PLL11	RBT	R0,POLLCU		: set closed
	SBT	R0,BOMNPL		:by bom
	J	DSTART

	ELSE
PLL06	LR	R9,R9			: open/close?
	JEFS	PLL07			: close
	SBT	R13,POLLCU		: set open
	JFS	PLL08

PLL07	RBT	R13,POLLCU		: set closed

PLL08	AIS	R13,1			: for next CU
	CR	R13,R14
	JLBS	PLL06			:repeat until done
	J	DSTART

PLL10	JAL	R7,GETCU		:go get CU number
	LR	R9,R9			:start or stop polling
	JEFS	PLL11			: closed
	SBT	R0,POLLCU		: set open
	J	DSTART

PLL11	RBT	R0,POLLCU		: set closed
	J	DSTART
	EI	:HSBCSW

:	KILL - zap specified circuits.  PVC's that are zapped will not
:	be rebuilt.
:	BUILD - rebuild PVC circuits that were killed.

KLL	LCS	R9,1			:set KILL flag
	JFS	KLL05			:...and skip to common code

BLD	LIS	R9,0			:set BUILD flag

:	Kill or Build circuits for specified devices
KLL05	JAL	R7,CHKSYN		:check syntax
	LH	R0,CMODE,,		:if in REL mode, there is no LINE or CU number
	JL	KLL20			:so skip to get device number
	JAL	R7,GETLIN		:go get line number
	ANYARG(KLL10)			:if more args, go get CU number
	LH	R13,FDEVL,R15		:get first device on line
	LH	R14,FDEVL+2,R15		:get first device on next line
KLL06	LR	R9,R9			:build or kill
	JEFS	KLL07			:build
	SBT	R13,ZPCRCT		:zap circuit for device
	RBT	R13,KLTPVC		:If PVC, don't rebuild
	JFS	KLL08
KLL07	SBT	R13,KLTPVC		:set ok to rebuild killed PVC's

KLL08	AIS	R13,1			:for next device
	CR	R13,R14
	JLBS	KLL06			:until done
	J	DSTART

KLL10	JAL	R7,GETCU		:get 2nd arg (CU number)
	ANYARG(KLL20)			:is there a device specified
	LB	R13,FDEV,R12		:get first device on CU
	LB	R14,FDEV+1,R12		:get first device on next CU
KLL16	LR	R9,R9			:build or kill
	JEFS	KLL17			:build
	SBT	R13,ZPCRCT		:zap circuit for device
	RBT	R13,KLTPVC		:If PVC, don't rebuild
	JFS	KLL18
KLL17	SBT	R13,KLTPVC		:set ok to rebuild killed PVC's

KLL18	AIS	R13,1			:for next device
	CR	R13,R14
	JLBS	KLL16			:until done
	J	DSTART

KLL20	JAL	R7,GETDV		:get 3rd arg (device)
	LR	R9,R9			:build or kill
	JEFS	KLL27			:build
	SBT	R0,ZPCRCT		:zap circuit for device
	RBT	R0,KLTPVC		:If PVC, don't rebuild
	JFS	KLL28
KLL27	SBT	R0,KLTPVC		:set ok to rebuild killed PVC's
KLL28	J	DSTART

	SUBTTL	?STAT Command handlers:  MODE, DNPLL, DNRSP

	DS.CMD(MODE,SMODE)		:set or display current mode
	DS.CMD(DNPLL,DNPOLL)		:display control units not being polled
	DS.CMD(DNRSP,DNRESP)		:display CU's not responding to to polls

:	SMODE - Set or display current mode.  Sets mode if followed by
:	argument or displays current mode if no argument.

:	REL	EQ	-1	relative position number
:	ADR	EQ	0	address
:	USR	EQ	1	user defined ID

MODTAB	BC	0C1,0D2,0D5		:ADR,REL,USR

	SEG	A.BOM
CMODE	HC	DFTMOD			:current mode
	SEG	A.CODE

	HS	0
SMODE	ANYARG(SMOD20)			:are there any arguments
	PRINT(CRNTMD)			:if not, just print current mode
	LH	R0,CMODE,,		:get current mode
	JLFS	SMOD05
	JEFS	SMOD10
	PRINT(USRM)			:user defined ID
	J	DSTART
SMOD05	PRINT(RELM)			:relative position number
	J	DSTART
SMOD10	PRINT(ADRM)			:address
	J	DSTART

SMOD20	JAL	R4,DS.TOK		:get argument
	EXHR	R3,R3			:right justify 1st char of token
	EXBR	R3,R3
	CLB	R3,MODTAB		:determine requested mode
	JEFS	SMOD25
	CLB	R3,MODTAB+1
	JEFS	SMOD30
	CLB	R3,MODTAB+2
	JE	SMOD35
	LA	R1,INVMOD		:argument invalid
	J	PERR
SMOD25	LIS	R0,ADR			:address
	STH	R0,CMODE,,
	J	DSTART
SMOD30	LHI	R0,REL			:relative position number
	STH	R0,CMODE,,
	J	DSTART
SMOD35	LIS	R0,USR			:user defined ID
	STH	R0,CMODE,,
	J	DSTART

:	DNPOLL - display all control units that are not currently polling.

DNPOLL	JAL	R2,BANNER		:display banner
	PRINT(LNCU)			:print heading LINE    CU
	LIS	R6,0			:init index into POLLCU
	LHI	R7,NCUM			:number of control units
DNP05	LHL	R2,POLLCU,R6		:get CU's being polled
	XHI	R2,0FFFF		:flip the bits
DNP10	JFFOH	R2,DNP15		:on bits are CU's not being polled
	SHI	R7,10			:are ther mor CU's to check
	JLE	DSTART			:that's all
	AIS	R6,2			:do next group of CU's
	JBS	DNP05

DNP15	STH	R2,S.TMP,,		:save array
	RBT	R3,S.TMP,,		:reset bit
	LHL	R2,S.TMP,,		:and put back in reg
	CHI	R3,NCUM			:are we getting too far into last halfword
	JGE	DSTART
	LB	R4,CULN,R3,		:get line number for CU
	LH	R1,CMODE,,		:get current mode
	JEFS	DNP25
	JG	DNP30
DNP20	LR	R0,R4
	DPRINT(3,.D!.B)			:print line number
	LR	R0,R3
	DPRINT(7,.D!.B)			:print CU number
	J	DNP10			:get next one
DNP25	LB	R0,LNADR,R4,		:ADR mode...get line address
	DPRINT(3,.H!.B)
	IF	HSBCSW
	LB	R0,CUADR,R12,		:print CU address
	ELSE
	LB	R0,CULA,R12,		:print CU address
	EI	:HSBCSW
	DPRINT(7,.H!.B)
	J	DNP10			:get next one
DNP30	LHL	R4,EDPLN,R4,R4		:USR mode...get line ID
	LHL	R3,EDPCU,R3,R3		:get CU ID
	J	DNP20			:go print them
	

:	DNRESP - display all control units that are not currently responding
:	to polls.

DNRESP	JAL	R2,BANNER		:display banner
	PRINT(LNCU)			:print heading LINE    CU
	LIS	R6,0			:init index into CUPOLL
	LHI	R7,NCUM			:number of control units
DNR05	LHL	R2,CUPOLL,R6,		:get CU's not responding to poll
	XHI	R2,0FFFF		:flip the bits
	NH	R2,POLLCU,R6		:only for CU's being polled
DNR10	JFFOH	R2,DNR15		:on bits are CU's not responding
	SHI	R7,10			:are ther more CU's to check
	JLE	DSTART			:that's all
	AIS	R6,2			:do next group of CU's
	JBS	DNR05

DNR15	STH	R2,S.TMP,,		:save array
	RBT	R3,S.TMP,,		:reset bit
	LHL	R2,S.TMP,,		:and put back in reg
	CHI	R3,NCUM			:are we getting too far into last halword
	JGE	DSTART
	LB	R4,CULN,R3,		:get line number for CU
	LH	R1,CMODE,,		:get current mode
	JEFS	DNR25
	JG	DNR30
DNR20	LR	R0,R4
	DPRINT(3,.D!.B)			:print line number
	LR	R0,R3
	DPRINT(7,.D!.B)			:print CU number
	J	DNR10			:get next one
DNR25	LB	R0,LNADR,R4,		:ADR mode...get line address
	DPRINT(3,.H!.B)
	IF	HSBCSW
	LB	R0,CUADR,R3,		:get CU address
	ELSE
	LB	R0,CULA,R3,		:get CU address
	EI	:HSBCSW
	DPRINT(7,.H!.B)
	J	DNR10			:get next on...
DNR30	LHL	R4,EDPLN,R4,R4		:USR mode...get line ID
	LHL	R3,EDPCU,R3,R3		:get CU ID
	J	DNR20			:go print them


CRNTMD	SC	/"8D"8ACURRENT MODE IS /
ADRM	SC	/ADR/
USRM	SC	/USR/
RELM	SC	/REL/
LNCU	SC	/"8A"8DLINE    CU"8A"8D/

	SUBTTL	?STAT Command Handlers:  ECPS, DCPS, EPR, DPRM, ESTAMP, DSTAMP

	DS.CMD(ECPS,ECP)		:Enable cps trace
	DS.CMD(DCPS,DCP)		:Display cps trace
	DS.CMD(EPR,EPR)			:Enable poll response trace
	DS.CMD(DPR,DPR)			:Display poll response trace
	DS.CMD(ESTAMP,EST)		:Enable time stamp trace
	DS.CMD(DSTAMP,DST)		:Display time stamp trace
	HS	0

:	ECP - Enable character per second trace.  Trace counts the
:	number of characters sent in each direction for the specified
:	line or the entire slot for either the default or specifed
:	amount of time.  Every time a new time is specified it becomes the
:	default.  If only one argument is entered, it is assumed to be
:	a line number.  The total number of chars is divided by the number of
:	seconds to give cps.  If no args are entered, keeps track of
:	throughput for entire slot.

ECP	ANYARG(ECP10)			:are ther any args
	LCS	R0,1			:no...set up for entire slot
	STH	R0,CP.LN,,		:max line number +1 for slot
ECP05	LH	R0,CP.DFT,,		:get duration
ECP06	JAL	R7,TR.ACT		:calulate when to halt trace
	ST	R0,CP.ACT,,		:store for timer to look at
	ST	R1,CP.STT,,		:store time trace enabled
	LIS	R0,0			:zero actual time trace ran
	ST	R0,CP.CNT,,		:zero count
	STH	R0,CP.ON,,		:start it
	J	DSTART

ECP10	JAL	R7,GETLIN		:go get line number
	STH	R0,CP.LN,,		:turn on trace for line
	ANYARG(ECP20)			:is there another arg
	J	ECP05			:no...use existing default time

ECP20	JAL	R7,GETTIM		:go get time
	STH	R0,CP.DFT,,		:store new time
	J	ECP06			:go set up timer


:	DCP - Display character per second trace
	
DCP	JAL	R2,BANNER		:print banner
	LH	R0,CP.ON,,		:is trace running
	JLFS	DCP02			:if no, skip ahead
	LCS	R0,1
	STH	R0,CP.ON,,		:turn it off
	L	R4,SLOWC,,
	ST	R4,CP.FNT,,		:save time stopped

DCP02	LH	R15,CP.LN,,		:is it slot or line
	JLFS	DCP05			:jump if slot
	PRINT(NL)
	JAL	R7,OUT.LN		:output line number
	JFS	DCP06
DCP05	PRINT(SLT)			:-SLOT-
DCP06	PRINT(CPDFT)			:'dft dur'
	LHL	R0,CP.DFT,,		:get default
	DPRINT(7,.B!.D)
	PRINT(CPCPS)			:'chars/sec'

	L	R4,CP.FNT,,
	S	R4,CP.STT,,		:calculate number of seconds trace ran
	L	R5,CP.CNT,,		:get number of chars
	JGFS	DCP15			:skip ahead if posative count
	LIS	R0,0
	JFS	DCP20
DCP15	LR	R3,R5			:move to low bits of dividend
	LIS	R2,0			:clear high bits of dividend
	DR	R2,R4			:comput chars per second
	LR	R0,R3			:put quotient into r0

DCP20	DPRINT(8,.D!.B)			:output chars per second
	PRINT(CPTOT)			:'total chars'
	LR	R0,R5			:get total chars
	DPRINT(0C,.D!.B)
	PRINT(CPACT)			:'period'
	LR	R2,R4			:get actual time of test in seconds
	JAL	R7,TRCPER		:convert to minutes and output
	J	DSTART
:	EPR - Enable poll response trace.  Trace keeps track of the the
:	number of ticks in FASTC it takes for polls to be resopnded to
:	for the specified Control Unit.  The average response time for
:	for the duration of the trace is displayed by the DPR command
:	in milliseconds.

EPR	ANYARG(EPR05)			:no args means for slot
	LCS	R12,1			:set R12 to indicate slot
	J	EPR15

EPR05	LH	R0,CMODE,,		:get current mode
	JLFS	EPR10			:skip ahead if REL mode
	JAL	R7,GETLIN		:get line number
	JAL	R7,CHKSYN		:check syntax
EPR10	JAL	R7,GETCU		:get CU number
	ANYARG(EPR20)			:is there a duration
EPR15	LH	R0,PR.DFT,,		:no...get current default
EPR16	JAL	R7,TR.ACT		:calculate when to halt trace
	ST	R0,PR.ACT,,		:store for time to look at
	ST	R1,PR.STT,,		:store time trace enabled
	LIS	R0,0			
	ST	R0,PR.TCK,,		:zero number of ticks
	ST	R0,PR.NMB,,		:zero number of polls
	LCS	R1,1
	ST	R1,PR.ALR,,		:indicate already done (for data routine)
	STH	R12,PR.SAV,,		:save CU number
	STH	R0,PR.ON,,		:start it
	J	DSTART

EPR20	JAL	R7,GETTIM		:go get time
	STH	R0,PR.DFT,,		:save it as new default duration
	J	EPR16			:go do it

:	DPR - Display results of poll response time trace

DPR	JAL	R2,BANNER		:display banner
	PRINT(NL)
	LH	R12,PR.SAV,,		:get CU number for trace
	JGEFS	DPR02			:if CU, skip ahead
	PRINT(SLT)			:' -slot-'
	JFS	DPR03

DPR02	JAL	R6,OUT.CU		:output CU number
DPR03	PRINT(CPDFT)			:'default duration'
	LH	R0,PR.DFT,,		:get duration
	DPRINT(7,.d!.b)
	LH	R0,PR.ON,,		:is trace running
	JLFS	DPR05			:if not skip ahead
	LCS	R0,1
	STH	R0,PR.ON,,		:else, halt trace
	L	R0,SLOWC,,
	ST	R0,PR.FNT,,		:save time halted

DPR05	PRINT(PRRSP)			:'RESPONSE(ms)'
	LIS	R0,0			:set up divide
	L	R1,PR.TCK,,		:get total number of ticks
	L	R2,PR.NMB,,		:get number of polls
	DR	R0,R2			:divide to get ticks/poll
	LR	R0,R1			:convert ticks to ms
	JAL	R5,TKTOMS
	J	DPR30			:ticks was a negative number

	DPRINT(6,.D!.B)
DPR10	PRINT(PRPLLS)			:'polls'
	L	R0,PR.NMB,,		:get number of polls
	DPRINT(8,.D!.B)
	PRINT(CPACT)			:'period'
	L	R2,PR.FNT,,		:ending time
	S	R2,PR.STT,,		:minus starting time
	JAL	R7,TRCPER		:convert to minutes and output
	J	DSTART

DPR30	PRINT(INVLD)			:invalid - negative number of ticks
	J	DPR10
:	EST - Enable timestamp trace.  The timestamp trace records the time
:	that specific events occur while proccesing a msg for the specified
:	device.

EST	JAL	R7,CHKSYN		:check syntax
	LH	R0,CMODE,,		:get current mode
	JLFS	EST20			:skip ahead if REL mode
	JAL	R7,GETLIN		:get line number
	JAL	R7,CHKSYN		:check syntax
EST10	JAL	R7,GETCU		:get CU number
	JAL	R7,CHKSYN		:check syntax

EST20	JAL	R7,GETDV		:go get DEVICE number
	JAL	R7,CKVIRT		:make sure not in Virtual mode
	ANYARG(EST30)			:is there a duration
EST25	LH	R0,ST.DFT,,		:no...get current default
EST26	JAL	R7,TR.ACT		:calculate when to halt trace
	ST	R0,ST.ACT,,		:store for time to look at
	ST	R1,ST.STT,,		:store time trace enabled
	LIS	R0,0			:set flag and initial displacement
	STH	R0,ST.DSP,,		:to zero
	STH	R0,ST.FLG,,		:set not to save xmt STX
	JAL	R5,ST.ZER		:go zero trace area
	STH	R11,ST.SAV,,		:save DEVICE number
	STH	R11,ST.ON,,		:start it
	J	DSTART

EST30	JAL	R7,GETTIM		:go get time
	STH	R0,ST.DFT,,		:save it as new default duration
	J	EST26			:go do it

	
:	DST - Display timestamp trace.  Displays last two timestamp
:	traces along with the round trip msg time in ms.

DST	JAL	R2,BANNER		:go print banner
	LH	R0,ST.ON,,		:is trace running
	JLFS	DST05			:if not skip ahead
	LCS	R0,1
	STH	R0,ST.ON,,		:else, halt trace
	L	R0,SLOWC,,
	ST	R0,ST.FNT,,		:else, halt trace

DST05	PRINT(STDFT)			:'default duration'
	LH	R0,ST.DFT,,		:get duration
	DPRINT(7,.D!.B)
	PRINT(CPACT)			:'period'
	L	R2,ST.FNT,,		:calculate seconds ran
	S	R2,ST.STT,,
	JAL	R7,TRCPER		:convert to minutes and output
	PRINT(NL)
	PRINT(NL)
	LHL	R11,ST.SAV,,
	JAL	R5,OUT.DV		:print device number
	PRINT(STDIS)			:'dispatcher port number'
	LHL	R1,DEVTAB,R11,R11	:get dcb
	LHL	R0,DPORT,R1,		:get dispatcher port number
	DPRINT(4,.D!.B)
	PRINT(STLST)			:'  last   prior'

	LB	R6,ST.DSP+1,,		:displacement for last into R6
	JEFS	DST10
	LIS	R7,0			:displacement for prior must be zero
	JFS	DST12
DST10	LHI	R7,STDSP		:else, prior is displaced - into R7

DST12	LIS	R4,0			:zero index
	PRINT(STRST)			:'rcv etx'
	JAL	R5,DST50		:print times
	PRINT(STRET)			:'rcv etx'
	JAL	R5,DST50
	PRINT(STSTO)			:'stx oring'
	JAL	R5,DST50
	PRINT(STETO)			:'etx oring'
	JAL	R5,DST50
	PRINT(STSTI)			:'stx iring'
	JAL	R5,DST50
	PRINT(STETI)			:'etx iring'
	JAL	R5,DST50
	PRINT(STSEL)			:'xmt select'
	JAL	R5,DST50
	PRINT(STXST)			:'xmt stx'
	JAL	R5,DST50
	PRINT(STXET)			:'xmt etx'
	JAL	R5,DST50
	PRINT(STXCMP)			:'xmt complete'
	JAL	R5,DST50

	PRINT(STDLY)			:'delay(ms)'
	L	R0,ST.ST7,R6,		:delay is xmit STX - receive STX
	JEFS	DST15
	S	R0,ST.ST0,R6,
	JAL	R5,TKTOMS		:convert ticks to ms
	J	DST30			:number of tick was negative

DST15	DPRINT(6,.D!.B)
	PRINT(SPACE5)
DST16	L	R0,ST.ST7,R7,		:compute delay for prior trace
	JEFS	DST17
	S	R0,ST.ST0,R7,
	JAL	R5,TKTOMS		:convert ticks to ms
	J	DST32			:number of ticks was negative
DST17	DPRINT(6,.D!.B)

DST19	J	DSTART

DST30	PRINT(INVLD)			:number of ticks was negative
	PRINT(SPACE3)
	J	DST16

DST32	PRINT(INVLD)			:number of ticks was negative
	J	DST19

:	Print timestamps
:	R6	displacement for last stamp
:	R7	displacement for prior stamp
:	R4	index for stamp to print
:	R5	link

DST50	L	R0,ST.ST0,R6,R4
	DPRINT(8,.H!.Z)
	PRINT(SPACE3)
	L	R0,ST.ST0,R7,R4
	DPRINT(8,.H!.Z)
	PRINT(NL)
	AIS	R4,4
	JR	R5

	SUBTTL	?STAT Command Handlers:  EREST, DREST, EDAT, DDAT, EPROT, DPROT, DISABLE

	DS.CMD(EREST,ERE)		:enable response time trace
	DS.CMD(DREST,DRE)		:display response time trace
	DS.CMD(EDAT,EDA)		:enable data trace
	DS.CMD(DDAT,DDA)		:display data trace
	DS.CMD(EPROT,EPRT)		:enable protocol trace
	DS.CMD(DPROT,DPRT)		:display protocol trace
	DS.CMD(DISABLE,DSB)		:disable all enabled traces
	HS	0

:	ERE - Enable reponse time trace.  Trace records when first
:	STX of message is received and then records response time
:	when first STX fo msg is xmitted.  The total response time
:	is averaged and later output in ms.

ERE	JAL	R7,CHKSYN		:check syntax
	LH	R0,CMODE,,		:get current mode
	JLFS	ERE20			:skip ahead if REL mode
	JAL	R7,GETLIN		:get line number
	JAL	R7,CHKSYN		:check syntax
	JAL	R7,GETCU		:get CU number
	JAL	R7,CHKSYN		:check syntax

ERE20	JAL	R7,GETDV		:go get DEVICE number
	JAL	R7,CKVIRT		:make sure not in Virtual mode
	ANYARG(ERE30)			:is there a duration
ERE25	LH	R0,RE.DFT,,		:no...get current default
ERE26	JAL	R7,TR.ACT		:calculate whne to halt trace
	ST	R0,RE.ACT,,		:store for time to look at
	ST	R1,RE.STT,,		:store time trace enabled
	LIS	R0,0			
	ST	R0,RE.FLG,,		:set both flags to zero
	ST	R0,RE.MST,,		:zero tick  accumulator
	STH	R0,RE.NMB,,		:zero msg numb accumulator
	STH	R11,RE.SAV,,		:save DEVICE number
	STH	R11,RE.ON,,		:start it
	J	DSTART

ERE30	JAL	R7,GETTIM		:go get time
	STH	R0,RE.DFT,,		:save it as new default duration
	J	ERE26			:go do it

:	DRE - Display response time trace.

DRE	JAL	R2,BANNER		:print banner
	PRINT(NL)
	LHL	R11,RE.SAV,,		:get device number
	JAL	R5,OUT.DV		:print device number
	PRINT(CPDFT)			:'dft dur'
	LHL	R0,RE.DFT,,		:get default
	DPRINT(7,.B!.D)
	PRINT(RERSP)			:'response ave'
	LH	R0,RE.ON,,		:is trace running
	JLFS	DRE10			:if no, skip ahead
	LCS	R0,1
	STH	R0,RE.ON,,		:turn it off
	L	R4,SLOWC,,
	ST	R4,RE.FNT,,		:save time stopped

DRE10	L	R3,RE.RSP,,		:get total number ticks
	GL	PATCH0
	ST	R3,PATCH0,,
	LIS	R2,0			:clear high bits of dividend
	LH	R4,RE.NMB,,		:get number of msgs sent
	STH	R4,PATCH0+4,,
	DR	R2,R4			:comput chars per second
	LR	R0,R3			:put quotient into r0
	ST	R0,PATCH0+8,,
	ST	R2,PATCH0+0C,,
	JAL	R5,TKTOMS		:convert ticks to ms
	J	DRE50			:jump if invalid

DRE15	DPRINT(7,.D!.B)			:output response time
DRE16	PRINT(REMSG)			:'response #'
	LR	R0,R4			:get number of msgs
	DPRINT(06,.D!.B)
	PRINT(CPACT)			:'period'
	LIS	R0,0			:clear high bits of dividend
	L	R2,RE.FNT,,		:get end time
	S	R2,RE.STT,,		:subract to get total seconds run
	JAL	R7,TRCPER		:convert to minutes and output
	J	DSTART

DRE50	PRINT(INVLD)			:'invalid'
	J	DRE16

:	EDA - Enable data trace.  The data trace saves the first 10
:	characters of every message and whether it was an ETX or ETB
:	block.  The data is stored in a ring buffer using a dual pointer
:	system to ensure that xmit and receive data is not mixed.  The
:	xmit and receive msgs are interleaved.

EDA	JAL	R7,CHKSYN		:check syntax
	LH	R0,CMODE,,		:get current mode
	JLFS	EDA20			:skip ahead if REL mode
	JAL	R7,GETLIN		:get line number
	JAL	R7,CHKSYN		:check syntax
	JAL	R7,GETCU		:get CU number
	JAL	R7,CHKSYN		:check syntax

EDA20	JAL	R7,GETDV		:go get DEVICE number
	JAL	R7,CKVIRT		:make sure not in Virtual mode
	ANYARG(EDA30)			:is there a duration
EDA25	LH	R0,DA.DFT,,		:no...get current default
EDA26	JAL	R7,TR.ACT		:calculate when to halt trace
	ST	R0,DA.ACT,,		:store for time to look at
	ST	R1,DA.STT,,		:store time trace enabled
	JAL	R4,DA.FL		:put all links on free list
	LIS	R0,0			
	LIS	R1,1			
	STH	R11,DA.SAV,,		:save DEVICE number
	STH	R11,DA.ON,,		:start it
	J	DSTART

EDA30	JAL	R7,GETTIM		:go get time
	STH	R0,DA.DFT,,		:save it as new default duration
	J	EDA26			:go do it

:	DDA - 	Display data trace.  

DDA	LH	R0,DA.ON,,		:is trace still running
	JL	DDA02			:skip ahead if not
	LCS	R0,1
	STH	R0,DA.ON,,		:else, halt trace
	STH	R0,DA.ONR,,
	STH	R0,DA.ONX,,
	L	R0,SLOWC,,		:save time halted
	ST	R0,DA.FNT,,

DDA02	JAL	R2,BANNER		:display banner
	PRINT(NL)
	LH	R11,DA.SAV,,		:get DEVICE number for trace
	JAL	R5,OUT.DV		:print device number
	PRINT(CPDFT)			:'default duration'
	LH	R0,DA.DFT,,		:get duration
	DPRINT(7,.d!.b)
	PRINT(CPACT)			:'period'
	L	R2,DA.FNT,,		:ending time
	S	R2,DA.STT,,		:minus starting time
	JAL	R7,TRCPER		:convert to minutes and output

	PRINT(NL)
	LH	R5,DA.HD,,		:check to see if any data
	CHI	R5,DA.TL-ST.SEG
	JNFS	DDA05			:skip to process data on linked list
	PRINT(NODAT)			:'NO DATA IN TRACE'
	J	DDA40

DDA05	LIS	R6,0			:used to test for completed link
	LIS	R2,7			:used to test for xmt and rcv
DDA10	LIS	R3,2			:index into link
	TBT	R2,ST.SEG,R5,,		:xmt or rcv
	JNFS	DDA15			:skip ahead if rcv
	PRINT(DRCV)			:'RCV:  '
	JFS	DDA20
DDA15	PRINT(DXMT)			:'XMT:  '

DDA20	LB	R0,ST.SEG,R5,R3		:get byte of data
	IF	BSCCST
	NHI	R0,7F			:if ASCII, strip off parity bit
	EI
	DPRINT(2,.H!.Z)			:print data
	THI	R3,1			:print space every other byte
	JEFS	DDA22
	PRINT(SPACE1)
DDA22	AIS	R3,1			:bump character count
	CLB	R3,ST.SEG+1,R5,		:have we read entire link yet
	JL	DDA20			:read em til done
	
DDA30	TBT	R6,ST.SEG,R5,		:check to see msg was completed
	JEFS	DDA35			:skip ahead if complete
	PRINT(DINC)			:else, 'msg incomplete'
DDA35	LHL	R5,ST.SEG+DA.ESZ,R5,	:get next link
	JEFS	DDA40			:zero means last link on list
	J	DDA10			:else, go output data on this link

DDA40	J	DSTART
:	EPRT - Enable protocol trace.  Records xmit and receive protocol
:	and address of appropriate state table for each operation.

EPRT	JAL	R7,CHKSYN		:check syntax
	JAL	R7,GETLIN		:get line number
	ANYARG(EPRT30)			:is there a duration
EPRT25	LH	R0,PT.DFT,,		:no...get current default
EPRT26	JAL	R7,TR.ACT		:calculate when to halt trace
	ST	R0,PT.ACT,,		:store for time to look at
	ST	R1,PT.STT,,		:store time trace enabled
	JAL	R4,PT.ZER		:go zero trace table and index
	STH	R15,PT.SAV,,		:save line number
	STH	R15,PT.ON,,		:start it
	SBT	R15,PTRBIT
	J	DSTART

EPRT30	JAL	R7,GETTIM		:go get time
	STH	R0,PT.DFT,,		:save it as new default duration
	J	EPRT26			:go do it

:	DPRT - display protocol trace.

DPRT	JAL	R2,BANNER		:display banner
	LH	R0,PT.ON,,		:is trace still running
	JLFS	DPRT03			:if not, skip ahead
	RBT	R0,PTRBIT		:else, halt trace
	LCS	R0,1
	STH	R0,PT.ON,,
	L	R0,SLOWC,,
	ST	R0,PT.FNT,,		:save time halted


DPRT03	PRINT(NL)
	LH	R15,PT.SAV,,		:get LINE number for trace
	JAL	R7,OUT.LN		:print line number
	PRINT(CPDFT)			:'default duration'
	LH	R0,PT.DFT,,		:get duration
	DPRINT(7,.d!.b)
	PRINT(CPACT)			:'period'
	L	R2,PT.FNT,,		:ending time
	S	R2,PT.STT,,		:minus starting time
	JAL	R7,TRCPER		:convert to minutes and output

	PRINT(NL)
	L	R4,PTPTTB,,		:has any data been collected yet
	JNFS	DPRT05			:if so, skip ahead
	PRINT(NODAT)			:'no data'
	J	DSTART

DPRT05	LHL	R5,PTPTRX		:get protocol trace table index
	L	R2,PTPTTB,R5,		:look at next entry
	JNFS	DPRT10			:non-zero means table has wrapped
	LIS	R5,0			:else, start reading table from beginning

DPRT10	LB	R2,PTPTTB,R5,		:get xmit code (1st byte)
	LB	R3,PTPTTB+1,R5,		:get rcv code (2nd byte)
	LHL	R4,PTPTTB+2,R5,		:get address or error type (2nd halfword)
	LH	R0,PTPTTB,R5,		:is 1st byte negative
	JGE	DPRT20			:GE indicates potential xmit code
	
	CHI	R2,0FD			:is it error code
	JN	DPRT15			:if not skip ahead
	PRINT(PTERR)			:'error:  count'
	LBR	R0,R3			:put error count into R0
	DPRINT(4,.D!.B)
	PRINT(PTTYPE)			:'type  '
	LR	R0,R4			:put error type into R0
	DPRINT(4,.H!.Z)			:output error type
	J	DPRT50			:done with this entry

DPRT15	PRINT(DXMT)			:'xmt:  '
	PRINT(INVLD)			:  Invalid!'
	J	DPRT30			:go look at rcv code

DPRT20	CHI	R2,PT.XMX		:is this a valid xmt code
	JGEBS	DPRT15			:if not, invalid!

	PRINT(DXMT)			:'xmt  '
	LHL	R6,PT.XMT,R2,R2		:translate code to text string
	AI	R6,PSEG			:add in segment offset
	SVC	K.OUT,0,R6		:print string
	PRINT(SPACE3)

DPRT30	CHI	R3,0FF			:is there a rcv op code
	JE	DPRT50			:if not, done with this entry
	CHI	R3,PT.RMX		:is it a valid rcv code
	JLFS	DPRT35			:skip ahead if valid
	PRINT(PTRCV)			:'rcv:  '
	PRINT(INVLD)			:'Invalid!'
	JFS	DPRT40			:check out address

DPRT35	PRINT(PTRCV)			:'rcv:  '
	LHL	R6,PT.RCV,R3,R3		:convert rcv code to text string
	AI	R6,PSEG			:add in segment offset
	SVC	K.OUT,0,R6		:ouoput test string
	PRINT(SPACE3)

	 LO BSCPTP
DPRT40	CHI	R4,SXSEL-PSEG		:translate state addresses
	JNFS	DPRT41
	PRINT(PTXSEL)			:'sxsel'
	J	DPRT50

DPRT41	CHI	R4,SRINIT-PSEG
	JNFS	DPRT42
	PRINT(PTRNIT)			:'srinit'
	J	DPRT50

DPRT42	CHI	R4,SRWACK-PSEG
	JNFS	DPRT43
	PRINT(PTRWCK)			:'srsack'
	J	DPRT50

DPRT43	CHI	R4,SRCV-PSEG
	JNFS	DPRT44
	PRINT(PTSRCV)			:'srcv'
	J	DPRT50

DPRT44	CHI	R4,SXMT-PSEG
	JNFS	DPRT45
	PRINT(PTXMT)			:'sxmt'
	J	DPRT50

DPRT45	CHI	R4,SENQ-PSEG
	JNFS	DPRT46
	PRINT(PTENQ)			:'senq'
	JFS	DPRT50

DPRT46	CHI	R4,SXTTD-PSEG
	JNFS	DPRT47
	PRINT(PTTTD)			:'sxttd'
	JFS	DPRT50
	 FO	BSCPTP

DPRT47	LR	R0,R4			:couldn't decode, just print address
	DPRINT(4,.D!.Z)

DPRT50	AIS	R5,4			:bump trace table index
	CLHI	R5,PTPSIZ		:are we off end of table
	JLFS	DPRT55			:if not, skip ahead
	LIS	R5,0
DPRT55	CH	R5,PTPTRX		:have we printed entire table
	JN	DPRT10			:read next table entry, til done

DPRT30	J	DSTART


:	Table to translate xmit and receive codes for protocol trace
:	into text string for output.

PT.RCV	HC	PTETX-PSEG,PTETB-PSEG,PTENQ-PSEG,PTEOT-PSEG,PTNAK-PSEG
	HC	PTDISC-PSEG,PTACK1-PSEG,PTWACK-PSEG,PTACK0-PSEG
	HC	PTRVI-PSEG,PTTTD-PSEG,PTMULT-PSEG,PTABRT-PSEG
	HC	PTLSNC-PSEG,PTOVER-PSEG,PTNOBF-PSEG,PTTMOT-PSEG
	HC	PTCRC-PSEG,PTLDAT-PSEG,PTUNK-PSEG,PTFRCE-PSEG
	
PT.RMX	EQ	15			:maximum rcv code value

PT.XMT	HC	PTDATA-PSEG,PTENQ-PSEG,PTEOT-PSEG,PTNAK-PSEG
	HC	PTTTD-PSEG,PTACK1-PSEG,PTWACK-PSEG,PTACK0-PSEG
	HC	PTRVI-PSEG,PTDISC-PSEG

PT.XMX	EQ	9			:maximum xmit code value
:	DSB - Disable command.  Halt all enabled traces.

DSB	LCS	R0,1			:set up R0 as -1 to halt traces
	L	R1,SLOWC,,		:set up R1 as time when halted

	LH	R2,CP.ON,,		:is CPS trace enabled
	JLFS	DSB05			:skip ahead if not
	STH	R0,CP.ON,,		:else, halt it
	ST	R1,CP.FNT,,

DSB05	LH	R2,PR.ON,,		:is poll response trace enabled
	JLFS	DSB10			:if not skip ahead
	STH	R0,PR.ON,,		:else, halt it
	ST	R1,PR.FNT,,

DSB10	LH	R2,ST.ON,,		:is timestamp trace enabled
	JLFS	DSB15			:if not, skip ahead
	STH	R0,ST.ON,,		:else, halt it
	ST	R1,ST.FNT,,

DSB15	LH	R2,RE.ON,,		:is response time trace enabled
	JLFS	DSB20			:if not, skip ahead
	STH	R0,RE.ON,,		:else, halt it
	ST	R1,RE.FNT,,

DSB20	LH	R2,DA.ON,,		:is data trace enabled
	JLFS	DSB25			:if not, skip ahead
	STH	R0,DA.ON,,		:else, halt it
	STH	R0,DA.ONR,,
	STH	R0,DA.ONX,,
	ST	R1,DA.FNT,,

DSB25	LH	R2,PT.ON,,		:is protocol trace enabled
	JLFS	DSB50			:if not, skip ahead
	STH	R0,PT.ON,,		:else, halt it
	RBT	R2,PTRBIT
	ST	R1,PT.FNT,,

DSB50	J	DSTART

:	Storage for trace routines

	SEG	A.BOM
TR.BGN	HS	0

:	character per second trace storage

CP.ON	HS	1			:on/off switch, -1 is off
CP.LN	HS	1			:line number or -1 for slot
CP.DFT	HS	1			:default minutes to run trace
CP.STT	HS	2			:when trace was last started, in SLOWC
CP.FNT	HS	2			:when trace was stopped, in SLOWC
CP.ACT	HS	2			:when to halt trace, in SLOWC
CP.CNT	HS	2			:character count

:	poll response trace storage

PR.ON	HS	1			:-1 is off, else CU number
PR.SAV	HS	1			:holds CU number for display
PR.DFT	HS	1			:default minutes to run trace
PR.STT	HS	2			:when trace last started, in SLOWC
PR.FNT	HS	2			:when trace finished, in SLOWC
PR.ACT	HS	2			:when to halt trace, in SLOWC
PR.NMB	HS	2			:number of polls during trace
PR.TCK	HS	2			:total ticks in FASTC for poll responses
PR.ALR	HS	2			:already timed response flag
PR.PLL	WS	NBILM			:FASTC of poll

:	Timestamp trace storage


ST.ON	HS	1			:-1 is off, else DEVICE number
ST.SAV	HS	1			:holds DEVICE number for display
ST.DFT	HS	1			:default minutes to run trace
ST.STT	HS	2			:when trace last started, in SLOWC
ST.FNT	HS	2			:when trace finished, in SLOWC
ST.ACT	HS	2			:when to halt trace, in SLOWC
ST.DSP	HS	1			:1st byte flag, 2nd byte displacement
ST.FLG	HS	1			:indicates xmt 2nd STX xmitted

ST.BEG	HS	0
ST.ST0	HS	2			:STX of incoming msg proc by foreground
ST.ST1	HS	2			:ETX of incoming msg proc by foreground
ST.ST2	HS	2			:STX of incoming msg put in ORING
ST.ST3	HS	2			:ETX of incoming msg put in ORING
ST.ST4	HS	2			:STX of msg received by IRING
ST.ST5	HS	2			:ETX of msg received of IRING
ST.ST6	HS	2			:XMT select
ST.ST7	HS	2			:STX of msg xmitted by foreground			
ST.ST8	HS	2			:ETX of msg xmitted by foreground
ST.ST9	HS	2			:XMT complete
ST.MID	HS	0
STDSP	EQ	ST.MID-ST.BEG		:displacement for second trace
	HS	STDSP/2			:storage for second set of traces
ST.END	HS	0
ST.SIZ	EQ	ST.END-ST.BEG		:bytes in timestamp trace area

:	response time trace storage

RE.ON	HS	1			:-1 is off, else DEVICE number
RE.SAV	HS	1			:holds DEVICE number for display
RE.DFT	HS	1			:default minutes to run trace
RE.STT	HS	2			:when trace last started, in SLOWC
RE.FNT	HS	2			:when trace finished, in SLOWC
RE.ACT	HS	2			:when to halt trace, in SLOWC
RE.NMB	HS	1			:number of messages during trace
RE.RSP	HS	2			:total ticks in FASTC for msg response
RE.FLG	HS	2			:1st rcv STX (if multiblock msg), 2nd xmt flag
RE.MST	HS	2			:when STX of message received

:	data trace storage area

DA.ON	HS	1			:-1 is off, else DEVICE number
DA.ONR	HS	1			:-1 is off, else DEVICE number
DA.ONX	HS	1			:-1 is off, else DEVICE number
DA.SAV	HS	1			:holds DEVICE number for display
DA.DFT	HS	1			:default minutes to run trace
DA.STT	HS	2			:when trace last started, in SLOWC
DA.FNT	HS	2			:when trace finished, in SLOWC
DA.ACT	HS	2			:when to halt trace, in SLOWC

DA.ESZ	EQ	$A12			:numb of bytes in link minus link pointer
DA.RST	EQ	01030200		:receive code, char cnt, stx
DA.RDS	EQ	01041002		:receive code, char cnt, dle, stx
DA.XST	EQ	00030200		:xmit code, char cnt, stx

DA.RPT	HS	1			:receive data index
DA.XPT	HS	1			:xmit data index
DA.FRE	HS	1			:pointer to free list
DA.HD	HS	1			:points to head of linked list
DA.TL	HS	1			:points to tail of linked list
DA.LNK	HS	(DATRSZ*(DA.ESZ+2))/2	:data trace area (links)
DA.END	HS	0			:end of data trace area

DA.SIZ	EQ	DA.END-DA.LNK		:size in bytes of data trace area

:	Protocol trace data area

PT.ON	HS	1			:-1 is off, else LINE number
PT.SAV	HS	1			:holds LINE number for display
PT.DFT	HS	1			:default minutes to run trace
PT.STT	HS	2			:when trace last started, in SLOWC
PT.FNT	HS	2			:when trace finished, in SLOWC
PT.ACT	HS	2			:when to halt trace, in SLOWC

TR.END	HS	0
	SEG	A.CODE


:	ST.ZER - zero timestamp trace are when trace enabled
:	R5	LINK

ST.ZER	LIS	R0,0
	LHI	R1,ST.END-ST.BEG-2	:number of bytes -2 to zero
ST.ZR1	STH	R0,ST.BEG,R1,		:zero them
	SIS	R1,2
	JGEBS	ST.ZR1			:til done
	JR	R5


:	DA.FL - for data trace.  Zeroes out data storage area and puts
:	all the links back onto the free list.  Called at initialization
:	and whenever the data trace is enabled.
:	R4	link

DA.FL	LHI	R2,DA.TL-ST.SEG		:point head of linked list at tail
	STH	R2,DA.HD,,
	LHI	R2,DA.HD-ST.SEG		:point tail of list at head
	STH	R2,DA.TL,,
	LHI	R3,DA.LNK-ST.SEG	:point free list pointer to first link
	STH	R3,DA.FRE,,

	LIS	R2,0			:zero out the data storage area
	LHI	R2,((DA.END-DA.LNK)/2)-2	:get number of halfwords to zero
DA.FL2	STH	R2,DA.LNK,R2,		:zero it
	SIS	R2,2			:decrement index
	JGEBS	DA.FL2			:til done

	LHI	R2,DATRSZ-2		:number links on free list -2
DA.FL5	AHI	R3,DA.ESZ+2		:addres of next link
	STH	R3,ST.SEG-2,R3,		:point preceding link to current
	SIS	R2,1			:decrement link count
	JGEBS	DA.FL5			:til done
	JR	R4			:and return

:	PT.ZER - Zeros prototcol trace storage area.  Called by IZBOM
:	and whenever trace is enabled.  The zeroed storage area is
:	used to determine whether or trace has yet wrapped.  Also zero
:	trace table index
:	R4	link

PT.ZER	LIS	R2,0
	LHI	R3,PTPSIZ-4		:number of bytes to zero
PT.ZR1	ST	R2,PTPTTB,R3,		:zero trace table
	SIS	R3,4			:for next word
	JGEBS	PT.ZR1			:til done
	STH	R2,PTPTRX		:zero trace table index
	JR	R4

:	Text strings for trace commands

ULINE	SC	/LINE /
UCU	SC	/CU /
UDEV	SC	/DEV /
SLT	SC	/ -SLOT-/
CPDFT	SC	/   DUR(min)/
STDFT	SC	/"8A"8DDUR(min)/
CPCPS	SC	'"8A"8D"8ACHARS/SEC'
CPTOT	SC	/   TOTAL CHARS/
CPACT	SC	/   PER/
PRPLLS	SC	/   POLLS/
PRRSP	SC	/"8A"8D"8ARESP(ms)/
INVLD	SC	/  Invalid!/
STDIS	SC	/   PORT NUMBER/
STLST	SC	/"8A"8A"8D               LAST       PRIOR/
STRST	SC	/"8A"8A"8DRCV STX      /
STRET	SC	/RCV ETX      /
STSTO	SC	/STX ORING    /
STETO	SC	/ETX ORING    /
STSTI	SC	/STX IRING    /
STETI	SC	/ETX IRING    /
STSEL	SC	/XMT SELECT   /
STXST	SC	/XMT STX      /
STXET	SC	/XMT ETX      /
STXCMP	SC	/XMT COMPLETE /
STDLY	SC	/DELAY(ms)    /
RERSP	SC	/"8A"8D"8ARESP AVE/
REMSG	SC	/   RESP #/
NODAT	SC	/"8A"8DNo Data/
DXMT	SC	/"8A"8DXMT:  /
DRCV	SC	/"8A"8DRCV:  /
DINC	SC	/  MSG Incomplete/

PTETX	SC	/ETX/
PTETB	SC	/ETB/
PTEOT	SC	/EOT/
PTNAK	SC	/NAK/
PTTTD	SC	/TTD/
PTACK1	SC	/ACK1/
PTACK0	SC	/ACK0/
PTWACK	SC	/WACK/
PTRVI	SC	/RVI/
PTDISC	SC	/DISC/
PTENQ	SC	/ENQ/
PTMULT	SC	/MULT/
PTABRT	SC	/ABORT/
PTLSNC	SC	/LOST SYNC/
PTOVER	SC	/OVERRUN/
PTNOBF	SC	/NO INIT BUFFERLET/
PTTMOT	SC	/TIMEOUT/
PTCRC	SC	/CRC ERR/
PTLDAT	SC	/LOST DATA/
PTUNK	SC	/UNKNOWN MSG/
PTFRCE	SC	/FRCD CMPLT/
PTDATA	SC	/DATA/
PTRCV	SC	/  RCV:  /
PTERR	SC	/"8A"8DERROR:   COUNT/
PTTYPE	SC	/  TYPE  /
PTXSEL	SC	/SXSEL/
PTRNIT	SC	/SRINIT/
PTRWCK	SC	/SRWACK/
PTSRCV	SC	/SRCV/
PTXMT	SC	/SXMT/
PTENQ	SC	/SENQ/
PTTTD	SC	/SXTTD/

	SUBTTL	Utility Routines

:	GETLIN - go get argument, which will be the line number
:	R7	link
:	R15	returns REL line number
:	R0	returns REL line number

GETLIN	JAL	R6,GETARG		:get line number
	JAL	R6,CKLN			:range check and convert to REL
	LR	R15,R0			:put REL line number into R15
	JR	R7			:and return

:	GETCU - go get argument, which will be the line number
:	R7	link
:	R12	returns REL line number
:	R0	returns REL line number
:	R15	if required, called with REL line number in R15

GETCU	JAL	R6,GETARG		:get CU number
	JAL	R6,CKCU			:range check and convert to REL
	LR	R12,R0			:put REL CU into R12
	JR	R7			:return

:	GETDV - go get argument, which will be the device number
:	R7	link
:	R11	returns REL device number
:	R0	returns REL device number
:	R12	if required, called with REL CU in R12

GETDV	JAL	R6,GETARG		:get device number
	JAL	R6,CKDV			:range check and convert to REL
	LR	R11,R0			:put REL device number into R11
	JR	R7			:and return

:	GETTIM - go get argument, which will be the duration
:	R7	link
:	R0	returns duration

GETTIM	GETNUM(10)			:get duration
	JAL	R6,CKTIME		:range check
	JR	R7			:and return

:	GETARG - get argument, but muust first check mode (REL, ADR, USR)
:	to know radix of arg.
:	R6	link
:	R0	holds argument on return

GETARG	LH	R0,CMODE,,		:get current mode
	JEFS	GARG			:jump if ADR mode
	GETNUM(10)			:REL and USR are decimal
	JR	R6			:and return
GARG	GETNUM(16)			:ADR is hex
	JR	R6			:and return

:	CKLN - convert line number to relative position and range
:	check value.
:	R6	link
:	R0	contains line number

CKLN	LH	R1,CMODE,,		:get current mode
	JL	CKLN20			:jump for REL mode
	JG	CKLN10			:jump for USR mode

	THI	R0,-0100		:range check address
	JN	BADLIN
	LHI	R13,NBILM-1		:get max line number
CKLN01	CLB	R0,LNADR,R13,		:search for line # address match
	JEFS	CKLN05			:jump if match successful
	SIS	R13,1
	JGEBS	CKLN01			:continue if more to look at
	J	BADLIN			:else, abort
CKLN05	LR	R0,R13			:put REL numb into R0
	JR	R6			:and return

CKLN10	LHI	R13,NBILM*2-2		:2*max line number
CKLN11	CLH	R0,EDPLN,R13,		:search for line number ID match
	JEFS	CKLN15			:jump if successful
	SIS	R13,2
	JGEBS	CKLN11			:continue if more to look at
	J	BADLIN			:else, abort
CKLN15	SRLS	R13,1			:divide by two
	LR	R0,R13			:put into R0
	JR	R6			:and return

CKLN20	LR	R0,R0			:range check REL number
	JL	BADLIN
	CHI	R0,NBILM
	JGE	BADLIN
	JR	R6			:and return

:	CKCU - convert to REL CU number and range check value
:	R6	link
:	R0	contains CU number
:	R15	REL line number must be passed to routine in reg
:		unless it is known that CU number is in REL mode

CKCU	LH	R1,CMODE,,		:get current mode
	JL	CKCU20			:jump for REL mode
	JG	CKCU10			:jump for USR mode

	THI	R0,-0100		:range check address
	JN	BADCU
	LB	R13,FCU,R15		:get first CU for line
	LB	R14,FCU+1,R15		:get first CU for next line
CKCU01
	IF	HSBCSW
	CLB	R0,CUADR,R13,		:search for CU address match
	ELSE
	CLB	R0,CULA,R13,		:search for CU address match
	EI	:HSBCSW
	JEFS	CKCU05
	AIS	R13,1
	CR	R13,R14
	JLBS	CKCU01			:continue if more to look at
	J	BADCU			:else, abort
CKCU05	LR	R0,R13			:put REL CU numb into R0
	JR	R6			:and return

CKCU10	LB	R13,FCU,R15		:get first CU for line
	AR	R13,R13			:make halfword index
	LB	R14,FCU+1,R15		:get first CU for next line	
	AR	R14,R14			:make halfword index
CKCU11	CLH	R0,EDPCU,R13,		:search for CU ID match
	JEFS	CKCU15			:jump if successful
	AIS	R13,2
	CR	R13,R14
	JLBS	CKCU11			:continue if more to look at
	J	BADCU
CKCU15	SRLS	R13,1			:divide by 2
	LR	R0,R13			:put REL CU number into R0
	JR	R6			:and return

CKCU20	LR	R0,R0			:range check REL CU number
	JL	BADCU
	CHI	R0,NCUM
	JGE	BADCU
	JR	R6			:and return

:	CKDV - convert to REL Device number and range check value
:	R6	link
:	R0	contains Device number
:	R12	REL CU number must be passed to routine in reg
:		unless it is known that Device number is in REL mode

CKDV	LH	R1,CMODE,,		:get current mode
	JL	CKDV20			:jump for REL mode
	JG	CKDV10			:jump for USR mode

	THI	R0,-0100		:range check address
	JN	BADDEV
	LB	R13,FDEV,R12		:get first Device for CU
	LB	R14,FDEV+1,R12		:get first device for next CU

CKDV01
	IF	HSBCSW
	CLB	R0,DEVADR,R13		:search for device address match
	ELSE
	LR	R1,R13			:put device number inot R1
	SLLS	R1,2			:make fullword index
	CLB	R0,DEVLA+2,R1,		:search for device address match
	EI	:HSBCSW

	JEFS	CKDV05			:jump if successful
	AIS	R13,1
	CR	R13,R14
	JLBS	CKDV01			:continue if more to look at
	J	BADDEV			:else, abort
CKDV05	LR	R0,R13			:put REL CU numb into R0
	JR	R6			:and return

CKDV10	LB	R13,FDEV,R12		:get first device for CU
	AR	R13,R13			:make halfword index
	LB	R14,FDEV+1,R12		:get first device for next CU
	AR	R14,R14			:make halfword index
CKDV11	CLH	R0,EDPTN,R13,		:search for device ID match
	JEFS	CKDV15			:jump if successful
	AIS	R13,2
	CR	R13,R14
	JLBS	CKDV11			:continue if more to look at
	J	BADDEV
CKDV15	SRLS	R13,1			:divide by 2
	LR	R0,R13			:put REL CU number into R0
	JR	R6			:and return

CKDV20	LR	R0,R0			:range check REL device number
	JL	BADDEV
	CHI	R0,NDEVM
	JGE	BADDEV
	JR	R6			:and return

:	CKTIME - range check durations input by trace commands
:	R0	time
:	R6	link

CKTIME	LR	R0,R0			:range check
	JLE	BADTIM
	CHI	R0,BMTTMX		:range check
	JG	BADTIM
	JR	R6			:and return

:	TKTOMS - Convert ticks of FASTC to milliseconds.  FASTC is equal
:	to 600 ticks per second.  Skip return (+4) for zero or valid
:	conversion.  Non-skip return if value passed was negative.
:	R0	ticks to convert and ms is returned in
:	R5	link
:	R1 - R2	work registers

TKTOMS	LR	R1,R0			:check for zero or negative number
	JE	4,R5		
	JLR	R5

	LHI	R2,$A1667		:convert ticks to ms
	MR	R0,R2
	LHI	R2,$A1000
	DR	R0,R2
	LR	R0,R1			:put ms into R0

	J	4,R5

:	TRCPER - Caluculate number of hours, minutes and seconds for trace
:	and ouput.
:	R7	link
:	R2	number of seconds

TRCPER	LHI	R4,$A60*60		:set up divisor
	DHR	R2,R4			:divide sec/60*60
	LR	R0,R3			:put hours into R0
	DPRINT(4,.D!.B)
	PRINT(COLON)			:':'
	LHI	R4,$A60			:set up divisor
	DHR	R2,R4			:divide remaining sec/60
	LR	R0,R3			:put minutes into r0
	DPRINT(2,.D!.Z)
	PRINT(COLON)
	LR	R0,R2			:put remainder (seconds) into R0
	DPRINT(2,.D!.Z)
	JR	R7			:and return

:	CHKSYN - Check for Syntax errors.  Looks to see if carriage return
:	was entered before all required arguments were entered.  If so, it
:	prints message 'syntax error!' and does error return.

CHKSYN	LHI	R0,8D			:was last delimiter a CR
	CLB	R0,DS.DLM,,
	JE	BADSYN			:if CR, error
	JR	R7			:else, just return

:	TR.ACT - Convert the trace duration fro minutes to seconds
:	and calculates time in SLOWC to halt trace.
:	R0	trace duration, returns time in SLOWC to halt trace
:	R7	link
:	R1	returns SLOWC

TR.ACT	LHI	R1,$A60			:60 seconds per minute
	MHR	R0,R1			:number of seconds to run test
	L	R1,SLOWC,,		:get current time SLOWC
	AR	R0,R1			:time to halt test
	JR	R7			:and return

:	CKVIRT - make sure trace is not being enabled for device operating
:	in Virtual mode.
:	R7	link
:	R0,R5	work registers
:	R11	relative device number, preserved

CKVIRT	LIS	R0,2			:DMODE = 2, indicates virtual mode
	LHL	R5,DEVTAB,R11,R11	:get DCB
	CLB	R0,DMODE,R5,		:is device in virtual mode
	JNR	R7			:if not, return
	J	BADVRT			:else, error

:	OUT.LN - Outputs 'LINE ' followed by line number, with the
:	line number expressed in the current mode.
:	R15	relative line number
:	R7	link 

OUT.LN	PRINT(ULINE)			:'line '
	LH	R14,CMODE,,		:get current mode
	JEFS	OLN10			:jump for ADR
	JG	OLN20			:jump for USR

	LR	R0,R15			:must be REL
	DPRINT(2,.D!.B)
	JR	R7			:and return

OLN10	LB	R0,LNADR,R15,		:convert rel to ADR
	DPRINT(2,.H!.Z)
	JR	R7			:and return

OLN20	LHL	R0,EDPLN,R15,R15	:convert rel to USR
	DPRINT(5,.D!.B)
	JR	R7			:and return


:	OUT.CU - Output 'CU ' and CU number as per current mode.
:	If in ADR or USR mode, first go to OUT.LN to print line number.
:	R12	relative CU number
:	R6	link

OUT.CU	LH	R14,CMODE,,		:get current mode
	JGEFS	OCU10			:must be ADR or USR

	PRINT(UCU)			:'CU '
	LR	R0,R12			:else, REL
	DPRINT(4,.D!.B)
	JR	R6			:and return

OCU10	LB	R15,CULN,R12,		:get rel line number
	JAL	R7,OUT.LN		:go print line number
	PRINT(SPACE2)
	PRINT(UCU)			:'CU '
	LR	R14,R14			:what's mode
	JGFS	OCU20

	IF	HSBCSW
	LB	R0,CUADR,R12,		:get CU address
	ELSE
	LB	R0,CULA,R12,		:get CU address
	EI	:HSBCSW
	DPRINT(2,.H!.Z)
	JR	R6			:and return

OCU20	LHL	R0,EDPCU,R12,R12	:get CU's USR
	DPRINT(5,.D!.B)
	JR	R6			:and return


:	OUT.DV - Output 'DEV ' and device number as per current mode.
:	If ADR or USR mode, first go print line and CU numbers.
:	R11	relative device number
:	R5	link

OUT.DV	LH	R14,CMODE,,		:what is current mode
	JGEFS	ODV10			:jump for ADR or USR

	PRINT(UDEV)			:'DEV '
	LR	R0,R11			:must be REL
	DPRINT(4,.D!.B)
	JR	R5			:and return

ODV10	LB	R12,DEVCU,R11		:get relative CU number
	JAL	R6,OUT.CU		:go print CU and line numbers
	PRINT(SPACE2)
	PRINT(UDEV)			:'DEV '
	LR	R14,R14			:what was mode?
	JGFS	ODV20			:jump for USR

	IF	HSBCSW
	LB	R0,DEVADR,R11		:get device address
	ELSE
	LR	R1,R11			:put device number in r1
	SLLS	R1,2			:make into fullword index
	LB	R0,DEVLA+2,R1,		:get device address
	EI	:HSBCSW

	DPRINT(2,.H!.Z)
	JR	R5			:and return

ODV20	LHL	R0,EDPTN,R11,R11	:get device USR
	DPRINT(5,.D!.B)
	JR	R5			:and return
:	Device in Virtual mode, trace invalid
BADVRT	LA	R1,BVIRT		:set message
	J	PERR			:print it and exit

:	Syntax error
BADSYN	LA	R1,BSYNTX		:set message
	J	PERR			:print it and exit

:	Bad trace duration arg entered
BADTIM	LA	R1,BDTM1		:set message
	JFS	PERR			:print it and exit

:	Bad GMT (unavailable), the error data not valid
BADGMT	LA	R1,BGMT1		:set message
	JFS	PERR			:print it and exit

:	Bad paramater value
BADPRM	LA	R1,BPRM1		:set message
	JFS	PERR			:print it and exit

:	Bad Line number
BADLIN	LA	R1,BLM1			: set message
	JFS	PERR			: print it and exit

:	Bad CU number
BADCU	LA	R1,BTCM1		: set message
	JFS	PERR			: print it and exit

:	Bad Device number
BADDEV	LA	R1,BTM1			: set message...and fall through

:	PERR(MSG)
:	Print ERRor:
:	NL/MSG/NL
:	R1 -	Pointer to message
:	Exits to DSTART!
PERR	PRINT(NL)			: New-line
	PRINT(0`,R1)			: MSG
	PRINT(NL)			: New-line
	J	DS.ERR,,		: ...and Error-exit

:	PLOC(PORT)
:	Print location:
:	"Node No. oooo"
:	R3 -	link register
PLOC	SVC	K.OUT,LOC1		: "Node No. "
	LHL	R0,NODEX,,		: get node number
	DPRINT(4,.O)			: 4 octal digits, no fill
	JR	R3			: and return

:	BANNER - prints banner for each BOM command includes node
:	number, slot number and current dat and time in GMT.
:	R1	Link register

BANNER	PRINT(BANNR)			:BOM -- Bisync Operations Monitor
	PRINT(NODE)			:NODE followed by node number
	LHL	R0,NODEX,,
	DPRINT(4,.O)
	PRINT(SLOT)			:SLOT followed by slot number
	LHL	R0,SLOTNO,,
	DPRINT(2,.H!.B)
	PRINT(SPACE4)			:put in some spaces
	L	R3,GMT,,		:get GMT
	JLFS	NOTIME			:jump if GMT not available
	LHI	R4,10			:DATIME to output 16d characters
	LA	R5,DATTMS,,		:address of where to output date from
	JAL	R6,DATIME		:convert GMT to date and time
	SVC	K.OUT,PDATE,,		:output date and time
	PRINT(NL)			:new line
	JR	R2			:and return
NOTIME	PRINT(NOGMT)
	PRINT(NL)
	JR	R2

BANNR	SC	/"8A"8D"8ABOM -- Bisync Operations Monitor/
NOGMT	SC	/Date and time not available/
NODE	SC	/"8D"8ANODE  /
SLOT	SC	/    SLOT /
	SEG	A.DATA
PDATE	BC	10			:followed by 16d characters
DATTMS	BS	10
	SEG	A.CODE

BLM1	SC	/Bad line number!/
BTCM1	SC	/Bad CU number!/
BTM1	SC	/Bad Device number!/
LOC1	SC	'"8D"8ANode No. '
INVMOD	SC	/Invalid Mode!/
BPRM1	SC	/Bad Parameter Value!/
BGMT1	SC	/DERR error data not valid, GMT not available!/
BDTM1	SC	/Duration Argument invalid!/
BSYNTX	SC	/Syntax Error!/
BVIRT	SC	/Virtual mode, Trace invalid!/

        SEG	A.BOM
INFO    HS      2
S.TMP	HS	2			:status temporary storage
	SEG	A.CODE

:	IZBOM - Initialize bisync operations monitor
:	R5	link

IZBOM	LHI	R0,DFTMOD		:get default mode for BOM commands
	STH	R0,CMODE,,		:and put it in there
	
	LIS	R0,0
	LHI	R1,(NDEVB*2)-2
IZBM05	STH	R0,ZPCRCT,R1		:zero circuit zapping array
	SIS	R1,2
	JGEBS	IZBM05			:till done
	
	IF	HSBCSW
	LH	R1,CLRCNT,,		:for hsbc, don't clear error counts
	JLFS	IZBM07			:except after new load
	TS	CLRCNT,,		:set don't clear flag
	EI	:HSBCSW

	JAL	R4,ZERRCT		:go zero error counters
IZBM07	JAL	R4,E.ZERR		:go zero error counters (bins)

	LHI	R0,E.DLIN		:init derr for slot or line
	STH	R0,E.LIN

:	zero trace storage area

	LIS	R0,0
	LHI	R1,TR.END-TR.BGN-2	:number of bytes to zero -2
IZBM10	STH	R0,TR.BGN,R1,   	:zero locations
	SIS	R1,2
	JGEBS	IZBM10			:til done

:	put in values for trace variable as necessary

	LCS	R0,1			:R0 is -1
	LIS	R1,1			:R1 is 1

	STH	R0,CP.ON,,		:CPS trace is off
	LHI	R2,CPSTM		:set default duration for CPS trace
	STH	R2,CP.DFT,,	

	STH	R0,PR.ON,,		:poll response trace is off
	STH	R1,PR.ALR,,		:set to already timed
	LHI	R2,PRTM			:set default duration for poll respnse trace
	STH	R2,PR.DFT,,

	STH	R0,ST.ON,,		:timestamp trace is off
	LHI	R2,STMPTM		:set default duration for timestamp trace
	STH	R2,ST.DFT,,

	STH	R0,RE.ON,,		:response time trace is off
	LHI	R2,RESTM		:set default dur for response time trace
	STH	R2,RE.DFT,,

	JAL	R4,DA.FL		:init data trace area
	STH	R0,DA.ON,,		:turn off data trace
	STH	R0,DA.ONR,,
	STH	R0,DA.ONX,,
	LHI	R2,DATTM		:set default duration for data trace
	STH	R2,DA.DFT,,

	JAL	R4,PT.ZER		:zero protocol trace table
	STH	R0,PT.ON,,		:turn off protocol trace
	LIS	R2,0
	ST	R2,PTRBIT
	LHI	R2,PROTTM		:set default duration for protocol trace
	STH	R2,PT.DFT,,

	JR	R5			:and return

:	Storage for misc BOM init switches etc

	SEG A.DATA
	IF	HSBCSW
CLRCNT	HC	0			:don't clear flag
	EI	HSBCSW


	SUBTTL	Data Conversion Routines

:	These routines were taken from (isis2)convrt.lib and then
:	modified for use in the BOM.

	RA	0

:*****************************************************************
:
:	BINDEC IS A ROUTINE TO CONVERT INTERNAL BINARY REPRESENTATION OF
:	DATA TO ASCII DECIMAL CHARACTERS.
:
:	ARGUMENTS: R9 CONTAINS THE BINARY NUMBER
:	           R10 CONTAINS NUMBER OF DIGITS OF OUTPUT
:	           R11 POINTS TO OUTPUT AREA
:	LINK ON R4
:
:****************************************************************
:
	SEG	A.DATA
:
RSAVEC	HS	10	:REGISTER SAVE AREA
:
	SEG	A.CODE
:
DIGASC	AC	/0123456789ABCDEF/
:
:	FIRST CHECK FOR A NEGATIVE NUMBER
:		IF FOUND, PUT A LEADING '-' (MINUS SIGN) IN FIELD
BINDEC	STM	R8,RSAVEC,,	:PRESERVE REGISTERS
	LR	R9,R9		: TEST FOR NEGATIVE NUMBER
	JGEFS	NOTNEG		:JUMP IF NOT NEGATIVE
	LHI	R12,$0 00AD	:'ASCII '-'
	STB	R12,0,R11
	SIS	R10,1		: ROOM FOR ONE LESS DIGIT
	AIS	R11,1		: DITTO
	JLE	RTRN		:NO ROOM FOR DIGIT AFTER MINUS SINE
:	COMPLEMENT THE NUMBER TO POSITIVE
	XI	R9,-1
	AIS	R9,1
NOTNEG	SIS	R11,1
	LIS	R12,$A 10	: DIVISOR
DIV	SR	R8,R8		: CLEAR HI ORDER BITS OF DIVIDEND
	DR	R8,R12		:GET LOW DIGIT IN R9
	LB	R13,DIGASC,R8	:GET ASCII EQUIVALENT OF DEC NUMBER
	STB	R13,0,R10,R11	:STORE IN REVERSE ORDER
	SIS	R10,1		:DECREMENT COUNTER
	JGBS	DIV		: KEEP LOOPING
RTRN	LM	R8,RSAVEC,,	:RESTORE THE REGISTERS
	JR	R4		:AND RETURN


	SUBTTL	GMT Clock Conversion Routines

:	These routines were taken from (isis2)datime.lib and then
:	modified for use in the BOM.

	RA	$0 0A

:
:***************************************************************
:
:	THIS PROCEDURE CONVERTS THE GMT CLOCK
:	RELATIVE TO 1/1/74 FROM SECONDS TO
:	DDMMMYY HH:MM (GMT) OR
:	DDMMMYY HH:MM:SS (GMT)
:
:	PARMS
:		R3 = # OF SECONDS SINCE 1/1/74 (BEYOND1/1/76)
:		R4 = CHARACTERS OF OUTPUT (13 OR 16)
:		R5 = ADDRESS OF OUTPUT STRING
:		R6 = LINK REGISTER
:	ALL REGISTERS ARE PRESERVED
:
:**************************************************************
:
	SEG	A.DATA
:
RSAVE	HS	$020	:REGISTER SAVE AREA
:
	SEG	A.CODE
DATIME	STM	R0,RSAVE,,	:PRESERVE THE REGISTERS
	S	R3,SEC745	
:	MAKE TIME RELATIVE TO 1/1/76 - THE START OF
:	A 'QUAD-YEAR'.  'QUAD-YEAR' = 1 LEAP
:	YEAR + 3 REGULAR YEARS.  THERE ARE
:	24 QUADS PLUS 4 REG YEARS IN A CENTURY
:
	SR	R2,R2		: CLEAR HI ORDER BYTES
	D	R2,SECDAY	:QUOTIENT IS # OF DAYS
:				:REMAINDER IS TIME
	LR	R14,R2		:COPY TIME OF DAY
	SR	R2,R2		:CLEAR HI ORDER BYTES
	D	R2,QUADAY	:DIVIDE BY DAYS IN A QUAD
:
:	QUOTIENT(R3) IS NUMB. OF QUAD YEARS
:	REMAINDER(R2) IS # OF DAYS INTO QUAD-YEAR
:
	LHI	R8,76		:BASE YEAR
	SLLS	R3,2		:QUAD YEAR * 4
	AR	R8,R3		:ADD TO BASE YEAR
	LA	R7,LEPYEA	:POINT TO DAYS IN MONTH
	C	R2,W366		:IS IT IN CURRENT YEAR?
	JL	MONTHD		:JUMP IF SO
	S	R2,W366		:SUBTRACT DAYS IN YEAR
	AIS	R8,1		:ADD 1 TO YEAR
	LR	R11,R2		:GET REMAIN DAYS IN QUAD
	SR	R10,R10
	D	R10,W365	:AND DIVIDE BY REGYEAR
:	R11 HAS ADDTL YEARS
:	R10 HAS DAYS IN YEAR
	LR	R2,10
	AR	R8,R11
	LI	R7,REGYER	:POINT TO DAYS IN MONTHS
:
:	DAYS IN R2
:	YEAR IN R8
MONTHD	SR	R6,R6		:MONTH COUNTER
	AIS	R2,1		:MAKE 1/1/76 = DAY 1
MONLOP	LR	R9,R2		:SAVE DAYS
	LB	R3,0,R6,R7	:GET DAYS IN MONTH
	SR	R2,R3		:AND SUBTRACT FROM DAYS IN YEAR
	JLEFS	DAZE		:IF MINUS OR ZERO WE'RE IN THE MONTH
	AIS	R6,1		:INCREMENT INDEX
	JBS	MONLOP
:
:	DAYS IN R3
:	MONTH NUMBER - 1 IN R6
:	YEAR IN R8
:
:	SAVE R4 AND R5
DAZE	SIS	R4,8		:SUBTRACT OUT DATE LENGTH
	LR	R13,R4		:PRESERVE IT
	LR	R11,R5		:COPY OUPUT AREA POINTER
:
:	CONVERT DAY
	LIS	R10,2		:# OF OUTPUT CHARACTERS
	JAL	R4,BINDEC	:CONVERT TO DECIMAL ASCII
:
:	MOVE IN MONTH
	AIS	R11,2
	SLHLS	R6,2		:MULTIPLY MONTH NUMBER BY 4
	L	R4,MONTHS,R6	:GET THE NAME IN R4
	STB	R4,2,R11
	SRLS	R4,8
	STB	R4,1,R11
	SRLS	R4,8
	STB	R4,0,R11
	AIS	R11,3
:
:	CONVERT YEAR
	LR	R9,R8
	LIS	R10,2
	JAL	R4,BINDEC	:CONVERT TO CHARACTERS
	LHI	R3,$00A0	:ASCII SPACE
	STB	R3,2,R11	:PUT IT AFTER DATE
	LHI	R5,3,R11	:SET UP OUTPUT POINTER
	LR	R4,R13		:COPY LENGTH ARGUEMENT
	LR	R3,R14		:COPY TIME OF DAY
	JFS	TIME1		:JUMP
:*************************************************************
:
:	GET THE TIME STAMP
:
:	TIME STAMP ROUTINE
:		THIS ROUTINE CONVERTS THE FULLWORD GMT TIME OF DAY
:	TO HH:MM OR HH:MM:SS
:
:	PARAMETERS:
:		R3 = FULLWORD TIME OF DAY (GMT CLOCK)
:		R4 = 5 OR 8 (# OF CHARACTERS TO OUTPUT)
:		R5 = FULLWORD ADDRESS OF OUTPUT
:		R6 = LINK REGISTER
:
:	DIVIDE TIME BY SECONDS PER DAY.  THE REMAINDER
:	IS THE SECONDS IN THIS DAY, WHICH IS WHAT THIS
:	ROUTINE IS ALL ABOUT
:
:****************************************************************
TMSTMP	STM	R0,RSAVE,,	:PRESERVE THE REGISTERS
  IF \TIMZON
	AHI	R3,TIMZON*$A3600	:TIME ZONE CONVERSION
  EI
TIME1	SR	R8,R8		:INDEX FOR OUTPUT AREA
:
	SR	R2,R2		:CLEAR HI-ORDER BITS
	D	R2,SECDAY
:		SECONDS NOW IN R2
	LR	R3,R2		:GET READY FOR
	SR	R2,R2		:ANOTHER DIVIDE
	D	R2,TENOUR	:GET TENS OF HOURS
	JAL	R6,ASCOUT	:PRINT IT OUT IN ASCII
	DH	R2,OURS		:GET HOURS
:		R2 HAS REMAINDER, R3 HAS QUOTIENT
	JAL	R6,ASCOUT	:PRINT IT OUT
	LHI	R3,$00BA	:COLON
	JAL	R6,PRTOUT
	DH	R2,TENMIN
	JAL	R6,ASCOUT
	DH	R2,MIN
	JAL	R6,ASCOUT
:	THE CONDITION CODE HAS BEEN SET -
:	SET IF ANY MORE CHARACTER WANTED
	JE	RETURN		:JUMP IF ONLY 5 CHAR
:
:	PUT IN COLON BEFORE SECONDS
	LHI	R3,$00BA
	JAL	R6,PRTOUT
	DH	R2,TENSEC
	JAL	R6,ASCOUT
	LR	R3,R2		:GET SECONDS IN R3
	JAL	R6,ASCOUT
RETURN	LM	R0,RSAVE,,	:RESTORE THE REGISTERS
	JR	R6		:RETURN
:
:
ASCOUT	AHI	R3,$00B0
PRTOUT	STB	R3,0,R8,R5
	AIS	R8,1	: UPDATE INDEX
	SIS	R4,1
	JR	R6

:
DECMAL	XC	0001020304050607080910111213141516171819202122232425262728293031
SECDAY	WC	24*60*60	:SECONDS IN A DAY
TENOUR	WC	10*60*60	:TENS OF HOURS
OURS	HC	60*60		:HOURS
TENMIN	HC	10*60		:TENS OF MINS
MIN	HC	60		:MIN
TENSEC	HC	10		:TENS OF SECS
  IF	\TIMZON
SEC745	WC	24*60*60*365*2-TIMZON*60*60	:SECONDS IN 74 & 75 PLUS 
						:TIME-ZONE CORRECTION
  ELSE
SEC745	WC	24*60*60*365*2	:SECONDS IN 74 AND 75
  EI
W365	WC	365
W366	WC	366
QUADAY	WC	4*365+1
LEPYEA	BC	31,29,31,30,31,30,31,31,30,31,30,31
REGYER	BC	31,28,31,30,31,30,31,31,30,31,30,31
	WS	0
MONTHS	AC	/ Jan/
	AC	/ Feb/
	AC	/ Mar/
	AC	/ Apr/
	AC	/ May/
	AC	/ Jun/
	AC	/ Jul/
	AC	/ Aug/
	AC	/ Sep/
	AC	/ Oct/
	AC	/ Nov/
	AC	/ Dec/
	EM	:status

	RA	0	:RADIX TO HEX

	SUBTTL	PATCH AREA DEFINITIONS
:**********************************************************************
:
:	This program is the sole property and confidential
:	information of TYMSHARE, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.
:
:**********************************************************************
	RA	0		:	PATCH.LIB

:	This library defines symbols, macros and areas used for patching
:	released code and keeping a history of patches in Engine memory.

:	A file containing the actual patches to the code should be
:	assembled as the last file before saving the NIB file.

:	Patches are added by ORGing to the area to patch,
:	zeroing memory for the length of the patch, writing new
:	code starting at that area.
:	Three macros have been defined to do this.
:	Each patch should start with a PATCH macro and if the
:	patch is for more than one area it should be continued
:	with a CONPATCH macro.  The patch should be ended with
:	an ENDPATCH macro.
:
:	Using these macros will cause the patch number, author
:	area patched, and reason for patch to be output during assembly.
:	Also, a history table starting at PATHIS will be created with
:	16 (10hex) byte entries.
:	Each entry will contain the date and time of patch and the author.
:	Also, the ?VERNO DDT command will indicate that patches are
:	installed by reporting a version biased by 100 octal.
:	For example, if the version is 1.13, ?VERNO will report 101.13.
:
:	If a patch must be temporarily added by hand, the
:	history area and the version (cell VERREV) should be updated.
:
:	The following symbols may be defined before assemply of PATCH.LIB.
:	If not defined they will take the default listed.
:
:	VERSION release version number, will be ORed with octal 100.
:		default: 00
:	VERREV	area in seg 0E which contains a one byte version and
:		a one byte revision.  Defined by FINISH.LIB.
:		default: none, symbol must be defined.
:	A.ERR	defines segment to use for patch history area
:		default: seg 0
:	PATHIS	defines the start of the patch history area,
:		each entry will be 16 bytes as follows,
:		19yy/mmdd/hhmm/uname(10 chars 0 filled)
:		where 19yy, mmdd and hhmm are in bcd (4 bits per decimal
:		digit) and uname is in ASCII.
:		default: an area will be defined by this library
:	PHSIZE defines the length in bytes of the PATHIS area.
:		default: 140 hex
:	PATCH0	defines the start of a Segment 0 patch area.
:		default: an area will be defined by this library
:	P0SIZE defines the length in bytes of the PATCH0 area.
:		default: 200 hex
:	PATCH1	defines the start of a code segment  patch area.
:		default: an area will be defined by this library
:	P1SIZE defines the length in bytes of the PATCH1 area.
:		default: 400 hex
:	SEGn,SnSIZE	Must be defined for the area being patched when
:		the patch is made.
:
:	The following symbols are used by the patch macros.
:	They may be read by, but should not be modified by, a patch.
:
:	PAHPTR	pointer to the next available entry in PATHIS
:	PA0PTR	This symbol may be used to place a patch at the next
:		available address in the PATCH0 area.  It starts out
:		equal to PATCH0 and is moved up after each patch in
:		the PATCH0 area.  Use of the symbol assumes that all
:		patches from PATCH0 to PATCH0+P0SIZE will be done in order.
:	PA1PTR	This symbol may be used to place a patch at the next
:		available address in the PATCH1 area.  It starts out
:		equal to PATCH1 and is moved up after each patch in
:		the PATCH1 area.  Use of the symbol assumes that all
:		patches from PATCH1 to PATCH1+P0SIZE will be done in order.
:	QPATS	current patch segment number
:	QPATB	starting address of current patch
:	QPATL	length of current patch
:	QPATA	0 IF PATCH IS IN PATCH0 AREA, 1 IF IN PATCH1, ELSE -1
:	PATACT	> 0 if when a patch is active.



::	PATCH(yymmdd,hhmm,uname,fba,lba1,len)	grab a patch area
:
:		yymmdd	Date patch written, if patch is modified in ANY
:		way this must be updated.
:		hhmm	Time patch written, current Cupertino time.
:		If patch is modified this also must be updated.
:		uname	ONTYME username of person who authored patch.
:		Personal name, not NETMID or NET3 or such.
:	fba	adress of start of patch
:	lba1	address of next byte after end of patch
:	len	length (default hex) of patch in bytes if lba1 is missing
:
:	CONPATCH(fba,lba1,len)	continue a patch in a new area
:		Similar to PATCH but moves to a new area, must be
:		preceeded by a PATCH statement.
:
:	ENDPATCH(comment)	End a PATCH started with PATCH call.
:
:		comment	Description of patch to be output during
:			assembly.  Commas should be preceeded by `.
:
:	Example:
:	:	PATCH TO FIX HDLC ROOM CHECKING ROUTINE
:	  IF	HDLC&(LAPB!LAP)
:	PATCH(811009,1422,FRED,XROOM,,2)
:		LIS	R4,7
:	ENDPATCH(fix hdlc room checking routine)
:	  EI
:
:	:	PATCH TO FIX TRANSMITER BUG
:	PATCH(811009,1630,DDM,XSEND,XSE010)
:	  IF	FINACT	:IF INTERFRAME FILL TIMER ENABLED
:		J	PA1PTR
:	  EI
:	PATRTN	LR	R6,RSIO
:		AHI	R6,OUTSCT,RSIP
:
:	CONPATCH(PA1PTR,,0C)
:		SBT	RL,FRMTMT,,	:INDICATE FRAME TRANSMITTED
:		JNR	R7		:IF ALREADY TRANSMITTED
:		J	PATRTN		:RETURN TO PATCHED AREA
:	ENDPATCH(fix transmitter bug)

	GL	VERSIO,VERREV,A.ERR,PATHIS,PHSIZE,PATCH0,P0SIZE,PATCH1,P1SIZE
	GL	PAHPTR,PA0PTR,PA1PTR,QPATS,QPATB,QPATL,QPATA,PATACT

:	FIRST DEFINE SOME MACROS
	GL	.35.
.35.	EQ	$A 35
	KILL	.NE.
.NE.	MACRO(P1,P2)[(((P1)-(P2))!((P2)-(P1)))^-.35.]
	KILL	.GT.
.GT.	MACRO(P1,P2)[((P2)-(P1))^-.35.]

:	NEXT DEFINE SOME DEFAULTS
  IF	1-\A.ERR
A.ERR	EQ	0
  EI
  IF	1-\PHSIZE
PHSIZE	EQ	140
  ELSE
PHSIZE	EQ	(PHSIZE+0F)/10*10
  EI
  IF	1-\P0SIZE
P0SIZE	EQ	200
  EI
  IF	1-\P1SIZE
P1SIZE	EQ	400
  EI
  IF	1-\PATHIS
	SEG	A.ERR
PATHIS	HS	PHSIZE/2
  EI
  IF	1-\PATCH0
	SEG	0
PATCH0	HS	P0SIZE/2
  EI
  IF	1-\PATCH1
	SEG	A.CODE
PATCH1	HS	P1SIZE/2
  EI

PAHPTR	EQ	PATHIS	:INIT HISTORY POINTER TO START OF AREA
PA0PTR	EQ	PATCH0	:INIT PTR TO START OF AREA
PA1PTR	EQ	PATCH1	:INIT PTR TO START OF AREA
PATACT	EQ	0	:FLAG NO PATCH ACTIVE
QPATA	EQ	-1	:CLEAR PATCH AREA FLAG
QPATS	EQ	-1
QPATB	EQ	-1
QPATL	EQ	-1

	KILL	PATCH
PATCH	macro(day,tim,usr,fba,lba1,len)[
  IF	\VERSION
VERSION EQ	VERSION!$8100
  ELSE
VERSION EQ	$8100
  EI
	SEG	0E
	ORG	VERREV
	BC	VERSION
	SEG	A.CODE
  IF	PATACT
 REMARK %>>>> ERROR **** Previous PATCH not ended with ENDPATCH <<<<%
  ELSE
PATACT	EQ	1
  EI
 REMARK %%PATCH added on day at tim by usr`.
	SEG	A.ERR
	ORG	PAHPTR
   IF	(PAHPTR+1)-(PATHIS+PHSIZE)
 REMARK %>>>> ERROR **** Too many PATCHs, increase PHSIZE beyond ; NUMBER $0PHSIZE
 REMARK x and reassemble <<<<%
   EI
	WC	$0 day!19000000
	HC	$0 tim
Q	AC	\usr\
Q1	HS
	ORG	Q+$a10	:skip to next history area
PAHPTR	HS
  IF	Q1-.	:IF UNAME>10 CHARARACTERS, CLEAR OVERFLOW
	RE	Q1-.
	BC	0
	ER
  EI

QPATS	EQ	((fba)&$00FF0000)^-$010
QPATB	EQ	fba
QPATC	EQ	lba1
  IF	lba1 0
QPATL	EQ	(lba1)-(fba)
  ELSE
QPATL	EQ	len 2
  EI
  IF	(.NE.(QPATC,0))&(.GT.(QPATB-QPATC+2,0))
 REMARK %>>>> ERROR **** Address of patch end < address of patch start <<<<%
  EI
  IF	(QPATB+1)-(PATCH1)	:IF PATCHING IN PATCH1,
   IF	(PATCH1+P1SIZE)-QPATB	: BUT NOT OUTSIDE IT,
QPATA	EQ	1	:PATCHING PATCH1 AREA
    IF	(QPATB+QPATL)-(PATCH1+P1SIZE)	:BUT NO PATCH AREA LEFT
 REMARK %>>>> ERROR  **** PATCH1 area overflow <<<<%
    EI
   EI
  EI
  IF	(QPATB+1)-(PATCH0)	:IF PATCHING IN PATCH0,
   IF	(PATCH0+P0SIZE)-QPATB	: BUT NOT OUTSIDE IT,
QPATA	EQ	0	:PATCHING PATCH0 AREA
    IF	(QPATB+QPATL)-(PATCH0+P0SIZE)	:BUT NO PATCH AREA LEFT
 REMARK %>>>> ERROR  **** PATCH0 area overflow <<<<%
    EI
   EI
  EI
  IF	QPATA+1		:IF PATCHING IN PATCH0 OR PATCH1 AREA
 REMARK %	Starts at PATCH; NUMBER $0QPATA; REMARK +
 NUMBER	$0PA|QPATA|PTR-PATCH|QPATA|
 REMARK  and is ; NUMBER $0QPATL; REMARK x bytes long%
  ELSE
 REMARK %     Starts at fba and is 
 NUMBER $0 QPATL
 REMARK x bytes long%
  EI

	SEG	QPATS
	ORG	QPATB
	RE	QPATL
	BC	0
	ER
  IF	(.+1)-(S|QPATS|SIZE+SEG|QPATS|)
 REMARK %>>>> ERROR **** PATCH causes SEG; NUMBER $0qpats
 REMARK  overflow <<<<%
  EI
	ORG	QPATB

::	CONPAT(fba,lba1,len)	CONTINUE A PATCH
	KILL	CONPAT
CONPAT	MACRO(cfba,clba1,clen)[
PATACT	EQ	PATACT+1
  IF	2-PATACT
REMARK %>>>> ERROR **** CONPAT not preceded by a PATCH <<<<%
  EI
  IF	QPATA+1		:IF PATCH WAS IN A PATCH AREA
PA|QPATA|PTR	EQ	.
  EI
QPATA	EQ	-1	:CLEAR FLAG
QPATS	EQ	((cfba)&$00FF0000)^-$010
QPATB	EQ	cfba
QPATC	EQ	clba1
  IF	clba1 0
QPATL	EQ	(clba1)-(cfba)
  ELSE
QPATL	EQ	clen 2
  EI
  IF	(.NE.(QPATC,0))&(.GT.(QPATB-QPATC+2,0))
 REMARK %>>>> ERROR **** Address of conpatch end < address of conpatch start <<<<%
  EI
  IF	(QPATB+1)-(PATCH1)	:IF PATCHING IN PATCH1,
   IF	(PATCH1+P1SIZE)-QPATB	: BUT NOT OUTSIDE IT,
QPATA	EQ	1	:PATCHING PATCH1 AREA
QPATA	EQ	1	:PATCHING PATCH1 AREA
    IF	(QPATB+QPATL)-(PATCH1+P1SIZE)	:BUT NO PATCH AREA LEFT
 REMARK %>>>> ERROR  **** PATCH1 area overflow <<<<%
    EI
   EI
  EI
  IF	(QPATB+1)-(PATCH0)	:IF PATCHING IN PATCH0,
   IF	(PATCH0+P0SIZE)-QPATB	: BUT NOT OUTSIDE IT,
QPATA	EQ	0	:PATCHING PATCH0 AREA
    IF	(QPATB+QPATL)-(PATCH0+P0SIZE)	:BUT NO PATCH AREA LEFT
 REMARK %>>>> ERROR  **** PATCH0 area overflow <<<<%
    EI
   EI
  EI
  IF	QPATA+1		:IF PATCHING IN PATCH0 OR PATCH1 AREA
 REMARK 	Continues at PATCH; NUMBER $0QPATA; REMARK +
 NUMBER	$0PA|QPATA|PTR-PATCH|QPATA|
 REMARK  and is ; NUMBER $0QPATL; REMARK x bytes long%
  ELSE
 REMARK 	Continues at cfba and is 
 NUMBER $0 QPATL
 REMARK x bytes long%
  EI
	SEG	QPATS
	ORG	QPATB
	RE	QPATL
	BC	0
	ER
  IF	.-(S|QPATS|SIZE+SEG|QPATS|)
 REMARK %>>>> ERROR **** PATCH causes SEG; NUMBER $0qpats
 REMARK overflow <<<<$
  EI
	ORG	QPATB

::	ENDPATCH(com)	End a patch - does error checking, outputs comment
	KILL	ENDPATCH
ENDPATCH	macro(c1,c2,c3,c4,c5)[
PATACT	EQ	0
  IF	.-(QPATB+QPATL)
 REMARK %>>>> ERROR **** BAD CONPATCH(cfba,clba1,clen) <<<<%
  EI
  IF	QPATA+1		:IF PATCH WAS IN A PATCH AREA
PA|QPATA|PTR	EQ	.
  EI
QPATA	EQ	-1	:CLEAR FLAG
	SEG	A.CODE
 REMARK <<< c1````c2````c3````c4````c5 >>>
]
]

	KILL	ENDPATCH
ENDPATCH	macro(c1,c2,c3,c4,c5)[
PATACT	EQ	0
  IF	.-(QPATB+QPATL)
 REMARK %>>>> ERROR **** BAD PATCH(day,tim,usr,fba,lba1,len) <<<<%
  EI
  IF	QPATA+1		:IF PATCH WAS IN A PATCH AREA
PA|QPATA|PTR	EQ	.
  EI
QPATA	EQ	-1	:CLEAR FLAG
	SEG	A.CODE
 REMARK <<< c1``c2``c3``c4``c5 >>>
]
]
        SUBTTL  Control Table Allocation and Diagnostics - FINISH.LIB
 
:**********************************************************************
:                                                                     *
:       This program is the sole property and confidential            *
:       information of Tymshare, Inc., and may not be copied          *
:       in whole or in part or disclosed to any third party           *
:       without the prior written consent of Tymshare.                *
:                                                                     *
:**********************************************************************

	RA	0		:	FINISH.LIB

:	this file should always be assembled LAST!

:ALLOCATE FPANEL IF USER HAS NOT
  IF	\FPANEL
  ELSE
	SEG	A.DATA
FPANEL  HS      1
  EI
  IF	\FRISIS
  ELSE
	SEG	0
FRISIS	HS	$A (MAXPRT+15)/16
  EI
  IF	\TOISIS
  ELSE
	SEG	0
TOISIS	HS	$A (MAXPRT+15)/16
  EI

:GENERATE DIAGNOSTICS
Q	EQ	0
	NOLIST
	RE	0F
SEG|Q|	EQ	SEG|Q|&07FFFFFFF
	IF	SEG|Q|%(Q*10000)
	REMARK	%"SEG
	NUMBER	Q
	REMARK	" has been redefined
	EI

  IF	1-(\PATCH0)
	SEG	0
PATCH0	WS	20	:SEGMENT ZERO PATCH AREA
  EI
  IF	1-(\PATCH1)
	SEG	1
PATCH1	WS	20	:SEGMENT ONE PATCH AREA
  EI
  IF	1-(\PATCH2)
	SEG	2
PATCH2	WS	20	:SEGMENT TWO PATCH AREA
  EI
:	DEFINE SIZES
	SEG	Q
S|Q|SIZE EQ	.-SEG|Q|
Q	EQ	Q+1
	ER
	LIST

:	BITCH IF ANY SEGMENTS OVERFLOW
	NOLIST
Q	EQ	0;	RE	0F;	IF	S|Q|SIZE-10000;	REMARK	%Segment 
	NUMBER	Q;	REMARK	- overflow, exceeded by 
	NUMBER	$A ($0S|Q|SIZE-10000);	REMARK	d bytes;	EI
Q	EQ	Q+1;	ER
	LIST

      IF        \XMEMRY
      ELSE
XMEMRY  EQ      0
      EI

:	SET UP CTA TABLE
  IF	SESIZE
	REMARK	%SEGMENT E IS RESERVED FOR CTA. REMOVE OTHER ALLOCATIONS.%%
  ELSE
	SEG	0E
      IF        XMEMRY
CTA     WC      CNTRL+$01000    :Control flags
      ELSE
CTA	WC	CNTRL	:CONTROL FLAGS
      EI

	WC	CTASIZ	:SIZE OF CTA AREA
AREAS
Q	EQ	0
	RE	0E
	WC	S|Q|SIZE	:AREA SIZE
Q	EQ	Q+1
	ER

	HC	0E	:NUMBER OF PROTECTION BYTES
    IF	\APROT0
	BC	APROT0	:SET AREA 0 PROTECTION
    ELSE
	REMARK	%DEFAULT AREA PROTECTIONS ASSUMED.%
	BC	6	:EXECUTION PROTECTED
    EI
    IF	\APROT1
	BC	APROT1	:SET AREA ONE PROTECTION
    ELSE
	BC	5	:WRITE PROTECTED
    EI
Q	EQ	2
	RE	0C
    IF	\APROT|Q|
	BC	APROT|Q|
    ELSE
	BC	6	:EXECUTION PROTECTED
    EI
Q	EQ	Q+1
	ER

	WC	ENTRY	:ENTRY POINT ADDRESS
    IF	\DSTART
	WC	DSTART	:DDT START ADDRESS
    ELSE
	WC	0	:NO USER DDT CODE
    EI

	WC	FPANEL	:ADDRESS OF FRONT PANEL DISPLAY CELL

	WC	HOSTS	:HOST TABLE ADDRESS
	WC	PORTS	:PORT TABLE ADDRESS
	WC	PTABLE	:PERMUTER TABLE ADDRESS
	WC	IRING	:INPUT RING ADDRESS
	WC	ORING	:OUTPUT RING ADDRESS
	WC	FRISIS	:ADDRESS TO INPUT BACKPRESSURE BIT ARRAY
	WC	TOISIS	:ADDRESS OF OUTPUT BACKPRESSURE ARRAY
  IF	\PCTTBL
	WC	PCTTBL	:PROJECT CODE TERMINATION TABLE
  ELSE
	WC	0	:NULL TABLE
  EI
COREST	WS	1	:ABSOLUTE CORE ADDRESS OF START OF SLOT
	HC	MAXHST	:MAXIMUM HOSTS FOR SLOT
	HC	MAXPRT	:HIGHEST PORT NUMBER FOR SLOT
	HC	IRSIZE	:INPUT RING SIZE
	HC	ORSIZE	:OUTPUT RING SIZE
SLOTNO	HS	1	:SLOT NUMBER (SUPPLIED BY ISIS)
VERREV	HS	0
  IF	\VERSION
	BC	VERSION	:VERSION NUMBER
  ELSE
	BC	0
  EI
  IF	\REVLEV
	BC	REVLEV	:REVISION LEVEL
  ELSE
	BC	0
  EI

    IF	\QSTART
	WC	QSTART	:DDT QUERRY START ADDRESS
    ELSE
	WC	0	:NO USER CODE
    EI
        HC      EMMAC0-CTA
    IF  \NMACSS
        HC      NMACSS          :Number of MAC Register Sets
    ELSE
        HC      0               :No extended MAC sets
    EI
        HC      0               :Segments to be saved

    IF \PRODID
    ELSE
      IF  \HID0
PRODID  EQ      HID0            :Define PRODID as alias
      ELSE
      EI  :HID0
    EI :PRODID

    IF \PRODID
      IF PRODID-$a255
        REMARK  %PRODID is too large%
        QUIT    1
      EI
      IF PRODID-$a48
      ELSE
        REMARK  %PRODID is too small%
        QUIT    1
      EI
    ELSE
        REMARK  %PRODID - Slot Product id must be defined%
        QUIT    1
    EI :PRODID
        HC      PRODID          :slot Product id

	WS	10	:RESERVED FOR FUTURE EXPANSION

HOSTS	HS	0	:BEGINNING OF HOST TABLE
Q	EQ	0
	RE	MAXHST
    IF	\HOST|Q|
	HC	HOST|Q|	:HOST NUMBER
    ELSE
	HC	0	:NO ASSEMBLED IN HOST NUMBER
    EI
Q	EQ	Q+1
	ER

PORTS	HS	0	:BEGINNING OF PORT TABLE
Q	EQ	0
	RE	MAXHST
    IF	\HPRT|Q|
	HC	HPRT|Q|
    ELSE
	HC	0	:NO ASSEMBLED IN NUMBER OF PORTS
    EI
Q	EQ	Q+1
	ER

PTABLE	HS	MAXPRT+1	:PERMUTER TABLE

EMMAC0  WS      0               :Extended Memory MAC Register sets
    IF XMEMRY
      IF \NMACSS
        EXPMAC
        REMARK  %Using Extended Memory Option%
        NUMBER  $a NMACSS
        REMARK  MAC Register sets allocated%
        NUMBER  $a EMEMR3
        REMARK k allocated on non-zero meg
      ELSE
        REMARK  %NMACSS must be specified with extended memory%
        QUIT    1
      EI        :NMACSS
    EI          :XMEMRY

CTASIZ	EQ	.-CTA	:CTA AREA SIZE
SESIZE	EQ	.-CTA	:SEG E SIZE
  EI

:	TELL MEMORY REQUIREMENTS
Q	EQ	0
QQ	EQ	0
QQQ	EQ	0
	RE	0F
	IF	S|Q|SIZE
	REMARK	%SEGMENT 
	NUMBER	Q
	REMARK	-length 
QQQ	EQ	S|Q|SIZE
	NUMBER	$A QQQ
	REMARK	d, requires 
Q3	EQ	(S|Q|SIZE+0FF)&(@0FF);	NUMBER	Q3
QQ	EQ	QQ+Q3
	REMARK	x bytes of core.
	EI
Q	EQ	Q+1
	ER

:	GIVE FINAL SIZES
	REMARK	%       
	NUMBER	(QQ+$03FF)/400$A	:FORCE TO BASE 10 FOR OUTPUT
	REMARK	d K-bytes of core

	UN		:spew out all undefined symbols

  "@@