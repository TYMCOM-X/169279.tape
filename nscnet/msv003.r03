        subttl  Menu Server R-file, Main Code. (MSVDEF.Sxx)
:msvdef.s32
:   move stuff to seg 4 in order to give more space for configuration
:   the stuff moved includes the strings and tables related to the 
:   tym file

:MSVDEF.S30
:   Create V3 R0. PIR's per release notice.

:MSVDEF.S20
:   From MSVDEF.S13   JSB 01/61/87.
:   Create V2 R1.  PIR's, NSR's per Release notice.

:(J.BURKE:36)MSVDEF.S13
: ******************************************************************
: **                  PROPRIETARY INFORMATION                     **
: **                                                              **
: **  This  source  code  listing  constitutes  the proprietary   **
: **  property of MDC-TYMNET.  The recipient, by receiving this   **
: **  program listing, agrees that neither this listing nor the   **
: **  information disclosed herein nor any part thereof shall be  **
: **  reproduced or transferred to other documents or used or dis-**
: **  closed to others for manufacturing or for any other purpose **
: **  except as specifically authorized in writing by MDC-TYMNET. **
: ******************************************************************
: **                   PROGRAM IDENTIFICATION                     **
: **                                                              **
: **  Version Number     : 3.03          Release Date : 06/15/88  **
: **                                                              **
: **  File Name          : MSV003.R03                             **
: **                                                              **
: **  File Description   : Limited Release Version                **
: **                                                              **
: **  File Abstract      : Menu Server Release R-File.            **
: **                                                              **
: ******************************************************************
: **                CONFIGURATION SPECIFICATION                   **
: **                                                              **
: **  Core Memory Requirement:  39K                               **
: **                                                              **
: **  Basic Code Size: 39K (no users)                             **
: **                                                              **
: **  Additional Code Size per Tymfile Parameter Unit:            **
: **     40K per 100 simultaneous users (N.User)                  **
: **                                                              **
: **     (this size includes one menu and auxiliary strings in    **
: **      the Tymfile totalling about 2K bytes.)                  **
: **                                                              **
: **  Estimated Code Growth for Next 12 Months: 3K.               **
: **                                                              **
: **  Sample Configurations:                                      **
: **                                                              **
: **  Hardware/Firmware Requirements: none.                       **
: **                                                              **
: **  Other Software Requirements: none.                          **
: **                                                              **
: **  Slot Limitations: none.                                     **
: **                                                              **
: ******************************************************************
: **                   DOCUMENT SPECIFICATION                     **
: **                                                              **
: **  Software Requirements Specification       :                 **
: **                                                              **
: **  Functional Specification (GED)            : msv003.ers      **
: **                                                              **
: ******************************************************************
: **                      MAINTENANCE HISTORY                     **
: **                                                              **
: **  Ver   Date    By   PIR/NSR         Reason for Change        **
: ** ----- -------- ---  -------- ------------------------------  **
: ** 3.03  06/15/88 jh            correct string terminor         **
: **                              user hit break key while login  **
: **                              nadr won't work if port>100 hex **
: ** 3.02  04/15/88 JH            give more space for tym file    **
: **                              configuration                   **
: **                              ubufer overflow cause by data   **
: **                              packet from tsat                **
: **                                                              **
: ** 3.01  12/03/87 JH   1541     nad does not work properly      **
: **   "     "      JH   1542     hardwired hostkey violates      **
: **                              network security                **
: **   "     "      JH   1565     TP doesn't send to host         **
: **                                                              **
: ** 3.00  10/31/87 JH   2188     Multiple password               **
: **   "     "      JH   2344     Katakana support                **
: **   "     "      JH   2135     Accounting                      **
: **   "     "      JH   1930     Tickler                         **
: **                                                              **
: **   "     "      JH   1477     handling of auxcircuit requests **
: **   "     "      JH   1504     auto.select combines with       **
: **                              c.handlogin                     **
: **   "     "      JH   1490     wrong revision number           **
: **   "     "      JH   1489     msv output to consat with parity**
: **                              bit set                         **
: **                                                              **
: **                                                              **
: ** 2.00  4/20/87  AM   2134     Resend string                   **
: **                                                              **
: **   "     "      AM   2174     Improved match/send buffer      **
: **                                                              **
: **   "     "      AM   2186     Host/Login Timeout              **
: **                                                              **
: **   "     "      AM   0874     MSV hangs if uses auto_select   **
: **                              and password option             **
: **   "     "      AM   1180     a login string overrun the      **
: **                              maximum buffer size             **
: **   "     "      AM   1244     when wrong password entered     **
: **                                                              **
: **   "     "      AM   1245     identifying the full defined    **
: **                              command                         **
: **                                                              **
: **                                                              **
: **                                                              **
: ** 1.13  12/11/86 JSB   994     Correct echo problems causing   **
: **                              double echo, bad screens.       **
: **   "     "      JSB   961     Pass Transparency-Mode          **
: **                              transparently.                  **
: **   "     "      JSB   868     Fix errors in Port Quota and    **
: **                              Rotor-Table limit.              **
: **   "     "      JSB  1043     Fix crash from overrunning UCB. **
: **                                                              **
: **                                                              **
: **                                                              **
: ******************************************************************

: MENU SERVER OPTIONS SETUP

ENGINE	eq	Yes
ISIS2   eq      Yes

MaxHst  eq      h+1
MaxPrt  eq      nPort-1
CNTRL	eq	200

nTout	eq	6

rUCB    eq      $a 13           :register dedicated for use as UCB base
TOINAC  eq      $a10            :period in seconds for the inactivity timer

        : 04/22/88 JH msv3.02
        : move the action code to seg 4. that will leave a space to 
        : put the code even if more than 64K.
A.RDAT  EQ      4               :THE SEG 4 FOR STRINGS AND ACTION CODE
APROT4  EQ      5               : SEG 4 is write protected only

A.TEXT  EQ      3               :THE SEG 3 FOR THE ACTION CODES.
                                : THE SIZES OF THE CODES ARE GENERATED
                                : BY THE TYM FILE
APROT3  EQ      4               : SEG 3 is read only

:(J.BURKE)STRUCT.S04
: by J. Burke 1 Jul. 86
: Add bottom-test loops.  Add "Short" parameters and automatic short
: jumps backward.

: (TTMSISIS2)STRUCT.03L copied from (MATS.P2)STRUCT.02S on 04.27.81
: by Vaysburd in order to add global variables WHILE, UNTIL, COUNT,
: FOREVER.
: (moved to TTMSISIS2 on 5-12-81).
: (MATS.P2)STRUCT.02S copied from (MATS.P2)STRUCT.01S on 10-24-80
: by Steve Gimnicher in order to add radix definitions to constants in
: FLIPCC and JUMPCC macros.

: STRUCT.NAD - MACROS TO ALLOW STRUCTURED PROGRAMMING
: PROGRAMMER: STEVE GIMNICHER
: DATE: 11-21-79 modified 4-25-80
:
: DATA DEFINITIONS FOR STRUCTURED PROGRAMMING

        RA      0
        SEG     0
        GL      L,LE,E,N,GE,G,C,NC,O,NO,THEN,IF.NST,IF.NDX
        GL      DO.NST,DO.NDX

        GL      WHILE,UNTIL,COUNT,FOREVER
IF.NST  EQ      0               : # OF NESTED IFS
IF.NDX  EQ      0               : INCREMENTED WITH EACH IFF CALL
DO.NST  EQ      0               : # OF NESTED DOS
DO.NDX  EQ      0               : INCREMENTED WITH EACH DO CALL
: DO.NDX & IF.NDX ARE USED TO CREATE UNIQUE STATEMENT LABELS

: VALUES FOR JUMP MNEMONICS
: The values given the jump mnemonics correspond to the values
: needed in the mask field, M, in the JT and JF instructions.
: The values for the JF instruction are hex 10 larger than those
: used in the JT instruction, in order to distinguish them.
L       EQ      1
G       EQ      2
N       EQ      3
O       EQ      4
C       EQ      8

GE      EQ      11
LE      EQ      12
E       EQ      13
NO      EQ      14
NC      EQ      18

: DO TYPES
WHILE   EQ      1
UNTIL   EQ      2
COUNT   EQ      3
FOREVE  EQ      4

SHORT   EQ      20              :parameter to request a short jump.
THEN    EQ      21              :the word THEN (has no real use).


IFF    MACRO(COND,DTHEN,SHORP)

:   COND may be any of the conditions xx used in a Jxx op code.
:   The second parameter may be THEN or SHORT.
:   The third parameter may be SHORT.
:   SHORT means generate a short jump.
:   THEN has no use at all.  But people use it so we keep it.
[
IF.NST  EQ      IF.NST+1        : BUMP NESTING LEVEL
IF.NDX  EQ      IF.NDX+1        : INCREMENT IF.NDX

QSHORT  EQ      SHORP 0                 :Use 3rd param as "short"
        IF      .EQ.(DTHEN+0,SHORT)     :but if 2nd is "short",
QSHORT    EQ      SHORT                   :then it is "short".
        EI

        GL      LB.|$0IF.NST|   : GLOBAL STATEMENT LABEL
LB.|$0IF.NST| EQ  IF.NDX        : UNIQUE PORTION OF LABELS
T       EQ      LB.|$0IF.NST|   : UNIQUE PORTION OF LABEL USED BELOW
        FLIPCC(COND,E.|$0T|,QSHORT)    : FLIP COND AND GENERATE JUMP TO ELSE
        ]


ORELSE  MACRO(SHORP)
:
: ELSE PORTION OF IF STATEMENT
: SHORP: if present, and if the value is SHORT, generate a short jump.
:
[
        IF      IF.NST          : WAS IFF CALLED FIRST?
T         EQ      LB.|$0IF.NST| : YES - GET UNIQUE PART OF END & ELSE LABEL
          IF      .NE.(SHORP+0,SHORT)
            J       N.|$0T|       : JUMP AROUND ELSE CLAUSE
          ELSE
            JFS     N.|$0T|
          EI
E.|$0T|   EQ      .             : BEGINNING OF ELSE CLAUSE
        ELSE
          REMARK  %ORELSE MACRO: IMPROPERLY NESTED IFF/ORELSE/ENDIF MACROS
        EI
        ]


ENDIF  MACRO
:
: END AN IF STATEMENT
:
[
        IF      IF.NST          : WAS IFF CALLED FIRST?
T         EQ      LB.|$0IF.NST| : YES - GET UNIQUE PART OF END & ELSE LABEL
          IF      \E.|$0T|      : WAS ELSE LABEL USED?
          ELSE
E.|$0T|     EQ      .           : NO - CREATE IT
          EI
N.|$0T|   EQ      .             : END OF AN IF STATEMENT
IF.NST    EQ      IF.NST-1      : DECREMENT IF NESTING LEVEL
          KILL    E.|$0T|,N.|$0T|       : REMOVE LABELS FROM SYMBOL TABLE
        ELSE
          REMARK  %ENDIF MACRO: IMPROPERLY NESTED IFF/ORELSE/ENDIF MACROS
        EI
        ]


EXITIF  MACRO(COND)
:
: THIS MACRO CAUSES CONTROL TO EXIT FROM THE LOWEST LEVEL ACTIVE
: IF STATEMENT.  IT MAY BE CONDITIONAL OR UNCONDITIONAL. SOME
: SAMPLE CALLS ARE
:    EXITIF           THIS IS THE UNCONDITIONAL FORM
:    EXITIF(LE)
:
[
        IF      IF.NST          : WAS IFF CALLED FIRST?
T         EQ      LB.|$0IF.NST| : YES - GET UNIQUE PART OF LABEL
          J`COND  N.|$0T|       : GENERATE JUMP
        ELSE                    : IFF NOT CALLED FIRST
          REMARK  %EXITIF MACRO: USED OUTSIDE OF IF CONSTRUCT
        EI
        ]


:----------------------------------------------------
:   MACRO  DO(TYPE,PARM,SHORP)
:
: Permissible TYPE's are:
:     WHILE   - PARM is the condition.  Loop while the condition is true.
:     UNTIL   - PARM is the condition.  Loop while the condition is false.
:     COUNT   - PARM is a register containing a number.  Loop as many times as
:               the number.  Quit if the number is LE 0.  You must consider
:               the reg to be destroyed, and must not use it in the loop.
:     FOREVE  - loop forever.  PARM is not used.
:
: Example:
:       lr      r1,r1
:       DO(WHILE,G)             :do it if r1 is Greater than to 0.
:         ...                     :  use area at [r1]
:         l       r1,0,r1         :link through r1,
:       ENDDO                   :loop while the next link is nonzero.
:
: SHORP - If SHORP is SHORT, the DO macro will use a short jump for the jump
: it puts at the top of the loop.  Does not matter for bottom-test loops.
: Note: the jump at the bottom is automatically a short jump if in range.
:
: The loop is tested at the top for DO(WHILE), DO(UNTIL), and DO(COUNT),
: that is, you can have a loop which is not executed at all when the condition
: is initially false.
:
: You may write a "bottom-test" loop, that is, the code is executed once
: before testing the condition at all, by writing TYPE,PARM on the ENDDO and
: not on the DO.  TYPE is always required in the one place or the other.
: See ENDDO for details about bottom-test.
:
: For WHILE and UNTIL, you must write an instruction which sets the condition
: code, in front of the ENDDO, and also in front of the DO unless you write
: a bottom test loop.

DO      MACRO(TYPE,PARM,SHORP)   [
DO.NST  EQ      DO.NST+1        : INCREMENT NESTING LEVEL
DO.NDX  EQ      DO.NDX+1        : INCREMENT DO INDEX.

        KILL    TYP.|$0DO.NST|    :undefine the do type.
        GL      TYP.|$0DO.NST|,DOL.|$0DO.NST|,INS.|$0DO.NST|

DOL.|$0DO.NST| EQ DO.NDX        : UNIQUE PORTION OF DO LABEL
INS.|$0DO.NST| EQ   PARM        : SAVE PARAM 2.

      IF      .NE.(TYPE+0,0)      :IF the type is written on the DO macro,

TYP.|$0DO.NST| EQ TYPE          : DEFINE THE DO TYPE.
        IF      TYPE-3
        ELSE
          IF      TYPE-2
            LR      PARM,PARM   : DO COUNT
            IF      .EQ.(SHORP+0,SHORT)
              JLEFS   B.|$0DO.NDX|: IF <= 0 DONT EXECUTE CODE
            ELSE
              JLE     B.|$0DO.NDX|: IF <= 0 DONT EXECUTE CODE
            EI
          ELSE
            IF        TYPE-1
              JUMPCC(PARM,B.|$0DO.NDX|,SHORP)   :DO UNTIL. JUMP ON ZERO CASE.
            ELSE
              IF          TYPE
                FLIPCC(PARM,B.|$0DO.NDX|,SHORP)   :DO WHILE. JUMP ON ZERO CASE.
              ELSE
                REMARK      %DO MACRO: INVALID TYPE
                NUMBER      TYPE
              EI
            EI
          EI
        EI
      EI
T.|$0DO.NDX|    EQ        .     : TOP OF DO LOOP.
        ]



ENDDO   MACRO(TYPE,PARM)
:
: END A DO STATEMENT.
: TYPE,PARM are as for a DO. When written on the ENDDO instead of the DO,
: the loop gets executed once before the Condition is tested.  Then:
:
: for WHILE or UNTIL, you must execute an instruction which sets the condition
: code, right before ENDDO.  But you don't need it in front of the DO.
: COUNT - The loop always executes once, even if the count is zero or neg.
: But if the reg is GT 0, the number is exactly how many times.  If the
: reg contains 1, the loop executes once.  Do not use the reg inside the
: loop or after.
: FOREVER - It makes no difference whether FOREVER is on DO or on ENDDO.
:
: If TYPE is not on the DO, it must be on the ENDDO.  It may not be on both.

[
QTYP  EQ      TYPE 0
      IF      DO.NST          : WAS DO CALLED FIRST?
T       EQ      DOL.|$0DO.NST|: YES - GET UNIQUE PART OF LABELS

        IF      1-\TYP.|$0DO.NST|   :if TYPE was not on the DO,
          IF      1-QTYP              :IF not here either, 
            REMARK %*** DO/ENDDO WITH NO TY`PE. PROGRAMMING ERROR AT 
            NUMBER $0.
            REMARK %*** BAD ASSEMBLY.%
          EI                          :
TYP.|$0DO.NST|  EQ      TYPE 0          :pick up Type.
INS.|$0DO.NST|  EQ      PARM -1
        ELSE                        :else TYPE was on the DO,
          IF      TYPE+0              :TYPE here also is not allowed..
            REMARK %*** DO and ENDDO both have ty`pe. PROGRAMMING ERROR AT 
            NUMBER $0.
            REMARK %*** BAD ASSEMBLY.%
          EI
        EI

        IF      .LE.(TYP.|$0DO.NST|,0)!.GT.(TYP.|$0DO.NST|,4)
          REMARK %*** BAD DO TY`PE TYPE. PROGRAMMING ERROR AT 
          NUMBER $0.
          REMARK %*** BAD ASSEMBLY.%
        ELSE
          IF      TYP.|$0DO.NST|-3
            J    |$0T|     : DO FOREVER. JUMP TO TOP OF LOOP
          ELSE
            IF      TYP.|$0DO.NST|-2
              SIS     INS.|$0DO.NST|,1:DO COUNT. DECREMENT COUNT
              JG      T.|$0T|   : IF > 0, REPEAT LOOP
            ELSE
              IF      TYP.|$0DO.NST|-1
                FLIPCC(INS.|$0DO.NST|,T.|$0T|):DO UNTIL.GENERATE CONDITIONAL JUMP
              ELSE
                IF      TYP.|DO.NST|
                  JUMPCC(INS.|$0DO.NST|,T.|$0T|):DO WHILE.GENERATE JUMP
                EI
              EI
            EI
          EI
        EI
B.|$0T| EQ      .             : BOTTOM OF LOOP
DO.NST  EQ      DO.NST-1      : DECREMENT NESTING LEVEL
        KILL    T.|$0T|,B.|$0T|   : KILL LABELS
      ELSE
          REMARK  %*** ENDDO MACRO: USED OUTSIDE OF DO.  PROGRAMMING ERROR AT 
          NUMBER  $0.
          REMARK  .%*** BAD ASSEMBLY.%
      EI
        ]


EXITDO  MACRO(COND,SHORP)
:
: THIS MACRO CAUSES CONTROL TO EXIT FROM THE LOWEST LEVEL ACTIVE
: DO STATEMENT.  IT MAY BE CONDITIONAL OR UNCONDITIONAL.  SOME
: SAMPLE CALLS ARE
:    EXITDO           THIS IS THE UNCONDITIONAL FORM
:    EXITDO(LE)
: SHORP - If SHORP is SHORT, the jump is a Short jump.
:
[
        IF      DO.NST          : WAS DO CALLED FIRST?
T         EQ      DOL.|$0DO.NST|: YES - GET UNIQUE PART OF LABEL
          IF      .EQ.(SHORP+0,SHORT)
            J`COND`FS  B.|$0T|       : GENERATE JUMP INSTRUCTION
          ELSE
            J`COND  B.|$0T|       : GENERATE JUMP INSTRUCTION
          EI
        ELSE
          REMARK  %EXITDO MACRO: USED OUTSIDE OF DO CONSTRUCT
        EI
        ]


: JUMPCC Macro - Generate a JT cc,addr or JF cc,addr according to the
: CC, which is any valid condition of a jump opcode.
: Generate an automatic short jump backward if the address is backward and
: in range.
: SHORP - If SHORP is SHORT and Addr is not yet defined, generate a short
: jump forward.
:
JUMPCC  MACRO(CC,ADDR,SHORP)    [
        IF      CC-$010         :if CC is a False/Opposite type ..
QCC       EQ      CC-$010         :use opposite
          JUMPX(QCC,F,ADDR,SHORP) :and false.
        ELSE
          JUMPX(CC,T,ADDR,SHORP)
        EI
]


: FLIPCC Macro - generate a jump on the OPPOSITE of CC.
:
FLIPCC  MACRO(CC,ADDR,SHORP)    [
        IF      CC-$010         :if CC is a False/Opposite type ..
QCC       EQ      CC-$010         :use opposite
          JUMPX(QCC,T,ADDR,SHORP) :and true.
        ELSE                    :else
          JUMPX(CC,F,ADDR,SHORP)  :use False.
        EI
]


: JUMPX Macro - generate short or long jump - automaticaly if ADDR is
: defined, else according to whether SHORP is SHORT.
: TF - is T or F to give JT or JF.
: COND - is a valid hex actual condition code from 00 to 0f.

JUMPX   MACRO(COND,TF,ADDR,SHORP)    [
        IF      (1-\ADDR)               :if addr is not defined,
          IF      .NE.(SHORP+0,SHORT)     :use the SHORP.
            J`TF    COND,ADDR
          ELSE
            J`TF`FS COND,ADDR
          EI
        ELSE                            :else defined,
          IF    .GT.(.,ADDR+$01E)         :if we are too far above it,
            J`TF    COND,ADDR
          ELSE                            :else it is in range.
            J`TF`BS COND,ADDR
          EI
        EI
]


: (J.BURKE)CASE.S01
:
:   CASE statement.  If <reg> contains <value i>, then execute <code i>.
:
:       CASE MACRO(reg)
:         WHEN(value 1)
:           code 1
:         WHEN(value 2)
:           code 2
:          ...
:         OTHERWise
:           otherwise code.
:       ENDCASe
:
:   WHEN(value-i) macro: defines a case branch.  Also generates the
:       jump-to-the-end for the previous branch.
:       value-i must be pre-defined.
:
:   ORWHEN(value-i) macro.  Combines this case with the previous.
:       That is, write  WHEN(val-i) then ORWHEN(val-j), ORWHEN(val-k) to
:       say that val-i, val-j, and val-k go to the same branch.
:
:   OTHERWISE macro: all values not listed in a WHEN go to the "otherwise"
:       code, including values out of bounds.
:
:       OTHERWISE is REQUIRED.
:
:   Symbols used by these macroes ...
:     CA.LVL        level of the current open case.  Initialized to 0,
:                   an outer CASE will be at level 1.  Nesting errors
:                   are checked against this.
:     CA.Q          Internal.
:     CAC.|level|   The count of WHEN's so far at <level>.  <level> is
:                   hex.
:     CAE.|level|   Label which the When's jump to to exit.
:     CAF.|level|   Sequence number for the first WHEN label in the CASE
:                   at <level>.  <level> is hex.
:     CAH.|level|   Highest value in any WHEN at <level>.
:     CAJ.|level|   Label of the jump table at <level>.  CAJ.|level| is
:                   actually defined to the table minus the offset of
:                   the minimum value.
:     CAL.|level|   Lowest value in any WHEN at <level>.
:     CAO.|level|   Label of the Otherwise branch.
:     CAQ.|level|   Sequence number of the last WHEN label at <level>.
:                   <level> is hex.
:     CAS.|level|   Base symbol for referencing case branches.
:     CFL.|level|   Final Low Value, and
:     CFH.:level:   Final High Value.  These are defined by ENDCASE and
:                   referenced by CASE to test limits.  They must be
:                   killed first, otherwise this CASE would refer to
:                   the previous values.
:     CV.|seq|      The Case value for the WHEN branch |seq|.
:     CW.|seq|      The label of a WHEN branch.  <seq> is incremented
:                   for every WHEN in the whole assembly, however, if
:                   you nest two cases, <seq> reverts to its previous
:                   value when the inner CASE is closed with ENDCASE.
:                   <seq> is hex.
 

 
: CASE(REG) - initialize symbols.  Jump via the jump table.
:        Destroys REG.
 
CASE    MACRO(REG)  [
        IF    1-\CA.LVL         : IF the first CASE (in this MO)
CAQ.0     EQ    0
CA.LVL    EQ    0
        EI

CA.LVL  EQ    CA.LVL+1
        KILL  CFL.|$0 CA.LVL|,CFH.|$0 CA.LVL|,CAO.|$0 CA.LVL|
        KILL  CAJ.|$0 CA.LVL|,CAE.|$0 CA.LVL|,CAS.|$0 CA.LVL|
CAL.|$0 CA.LVL| EQ    $07FFFFFFF          :init Low value =max.
CAH.|$0 CA.LVL| EQ    -CAL.|$0 CA.LVL|-1   :init High value =max neg.
                        :(note this permits either the lowest or the highest
                        : possible values in REG.)

CAF.|$0 CA.LVL| EQ    CAQ.|$0 CA.LVL-1|+1   :First sequence in this block
                                          :is cur+1 from the outer block.
CAQ.|$0 CA.LVL| EQ    CAF.|$0 CA.LVL|-1   :Init the "last WHEN" seq to
                                          :First -1.
CAC.|$0 CA.LVL| EQ    0                   :count of WHEN's =0.
 
        CI  REG,CFL.|$0 CA.LVL|     :   (DON'T make this Logical!)
        JL  CAO.|$0 CA.LVL|         : jump, too low.
        CI  REG,CFH.|$0 CA.LVL|
        JG  CAO.|$0 CA.LVL|         : jump, too high.
 
        LH  REG,CAJ.|$0 CA.LVL|,REG,REG    :   (DON'T make this Logical!)
        J   CAS.|$0 CA.LVL|,REG,           :Jump to the case branch.
CAS.|$0 CA.LVL| HS    0
 
]
 
 
: WHEN(value-i) - the case branch for value-i.
:   1. Generates jump for the previous branch, then
:   2. Generates the case label and value symbol for this branch.
:      Actually, calls ORWHEN to do this work.
 
WHEN    MACRO(VALUE)  [
        IF      CAQ.|$0 CA.LVL|-CAF.|$0 CA.LVL|+1  :if not first,
          J       CAE.|$0 CA.LVL|,,                    :jump to end.
        EI
        ORWHEN(VALUE)
]
 
 
: ORWHEN(value-i) - case branch for value-i is a fallthrough from the
:   previous branch.
:   Does the real work for case branches.
 
ORWHEN  MACRO(VALUE)  [
CA.Q    EQ      CAQ.|$0 CA.LVL|+1   :next sequence.
CAQ.|$0 CA.LVL| EQ      CA.Q

        KILL  CW.|$0 CA.Q|,CV.|$0 CA.Q|
CW.|$0 CA.Q|    HS      0           :branch label.
CV.|$0 CA.Q|    EQ      VALUE       :value of the current Sequence.
 
        IF      VALUE-CAH.|$0 CA.LVL|       :check for Max Value.
CAH.|$0 CA.LVL|  EQ    VALUE
        EI
        IF      CAL.|$0 CA.LVL|-(VALUE)       :check for Min Value.
CAL.|$0 CA.LVL|  EQ    VALUE
        EI
 
]
 
 
OTHERWise MACRO   [
        IF      CAQ.|$0 CA.LVL|-CAF.|$0 CA.LVL|+1  :if not first,
          J       CAE.|$0 CA.LVL|,,                   :jump to end.
        EI
CA.Q    EQ      CAQ.|$0 CA.LVL|+1   :next sequence.
CAQ.|$0 CA.LVL| EQ      CA.Q
CAO.|$0 CA.LVL| HS      0           :branch label.
        KILL    CV.|$0 CA.Q|        :must be no value for OTHERWISE.
]
 
 
: ENDCASE - generates the jump table and the end label.
 
ENDCASe MACRO   [
    IF    CA.LVL              :IF this isn't a mismatched ENDCASE ...
        IF    CAH.|$0 CA.LVL|+1-CAL.|$0 CA.LVL|
        ELSE                  :No WHEN or ORWHEN cases were defined
          REMARK % CAH = 
          NUMBER CAH.|$0 CA.LVL|
          REMARK   CAL = 
          NUMBER CAH.|$0 CA.LVL|
CAH.|$0 CA.LVL|   EQ    1
CAL.|$0 CA.LVL|   EQ    1
          REMARK % NO WHEN OR ORWHEN CASES WERE DEFINED,
          REMARK % CASE STATEMENT HIGH VALUE IS <= THE LOW, BOTH SET TO 1 %
        EI
        IF    (CAH.|$0 CA.LVL|+1-CAL.|$0 CA.LVL|+1)-$010000
          REMARK % CASE VALUES RANGE IS GREATER THAN 64K AT ADDRESS = 
          NUMBER $0 .
          REMARK   ***% *** BAD ASSEMBLY. ***%
        EI
        J     CAE.|$0 CA.LVL|,,   :exit from the last WHEN.
 
CFL.|$0 CA.LVL| EQ    CAL.|$0 CA.LVL|       :final low Value,
CFH.|$0 CA.LVL| EQ    CAH.|$0 CA.LVL|       :final high Value.
 
        HS    0          :Jump Table.  The label of the table is
                         :offset backwards by the lowest <value> ...
CAJ.|$0 CA.LVL| EQ    .-CAL.|$0 CA.LVL|*2
 
          IF    1-\CAO.|$0 CA.LVL|
            REMARK  % *** PROGRAMMER ERROR!  The OTHERWISE is missing at addr =
            NUMBER  $0 .
            REMARK  . ***% *** BAD ASSEMBLY. ***%
          ELSE
            IF    CAH.|$0 CA.LVL|-CAL.|$0 CA.LVL|
              RE    CAH.|$0 CA.LVL|+1-CAL.|$0 CA.LVL|   : Hi+1 minus Lo.
                                     :fill table with Otherwise entries...
                HC    CAO.|$0 CA.LVL|-CAS.|$0 CA.LVL|
              ER
            EI
          EI
 
CA.Q      EQ    CAF.|$0 CA.LVL|       :seq of our first branch,
          RE    CAQ.|$0 CA.LVL|-CAF.|$0 CA.LVL|+1:For all branches under this CASE,
            IF    \CV.|$0 CA.Q|         :IF this branch has a Value,
                                          :(may be an OTHERWISE.)
              ORG   CAJ.|$0 CA.LVL|+CV.|$0 CA.Q|*2   :ORG to value,
              HC    CW.|$0 CA.Q|-CAS.|$0 CA.LVL|     :point to WHEN.
            EI
CA.Q        EQ    CA.Q+1                :bump seq.
          ER
          ORG   CAJ.|$0 CA.LVL|+CAH.|$0 CA.LVL|*2+2
 
CAE.|$0 CA.LVL|  HS    0            :exit symbol.
          IF    (CAE.|$0 CA.LVL|&$00F0000)-(CAS.|$0 CA.LVL|&$00F0000)
            REMARK % CASE STATEMENT CROSSES SEGMENT BOUNDARY, ADDRESS = 
            NUMBER $0 CAS.|$0 CA.LVL|
            REMARK   ***% *** BAD ASSEMBLY. ***%
          EI
CA.LVL    EQ    CA.LVL-1
 
    ELSE
        REMARK  % *** PROGRAMMER ERROR!  Extra ENDCASE at addr =
        NUMBER  $0 .
        REMARK  . ***% *** BAD ASSEMBLY. ***%
    EI
]
 
	subttl	ISIS Assembly Switch Definitions	- Start.Lib

:	This program is the sole property and confidential
:	information of Tymshare, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.

	remark %Start.Lib Version 

sRev	eq	0
	number sRev
	remark .0

sLev	eq	05
	number sLev

: Version 0.05 01/19/83 MDS
:	Delete Remark regarding incompatibility with ISIS 5.00
:
: Version 0.04 03/12/82  MDS
:	Add new fields to SYS SVC Sub-operand definitions,
:	per ISIS2 v.5.01
:
: Version 0.03 03/08/82  MDS
:	Add new fields to Seg F table per ISIS 5.01
:	(note - Start.lib ** NOT ** compatible with ISIS 5.00
:	because SLCNT and LCX were reversed in 5.00 )
:
: Version 0.02  12/08/81  MDS
:	Add QSTART remark, add I/O sub-ops for mother board.
:	Delete ISIS (one) code - force ISIS2
:
: Version 0.01  01/08/81  MDS
:	Correct relative addresses of local clock index and values.


: this file SHOULD ALWAYS be assembled IMMEDIATELY AFTER the *.TYM file


ISIS2	EQ	1	:Force ISIS2 for other library routines
			:Note - ISIS 1 is no longer supported

:			ISIS - II Version
:
:
: The following parameters SHOULD BE DEFINED IN THE *.TYM FILE:
:
:	MaxHst	maximum number of hosts associated with this interface slot
:
:	MaxPrt	number of highest port associated with this interface slot
:		(number of ports - 1)
:
:	IRsize	 number of bytes to provide for input ring, from dispatcher
:
:	ORsize	 number of bytes to provide for output ring, to dispatcher
:
:	CNTRL	dispatcher control bits
:
:	ENGINE	set to 1 if executing on a Tymnet Engine
:
:
: the following symbols MUST be defined SOMEWHERE in the assembly:
:
:	Iring	the start of the input ring, from dispatcher
:
:	Oring	the start of the output ring, to dispatcher
:
:	Entry	the location of the first instruction to be executed
:
:
: the following symbols ARE DEFINED for convenience:
:
:	Rate	the rate of the fast clock (ticks/second)
:
:	nRate	word containing the value of RATE
:
:	FastC	word containing  realtime fast clock
:
:	SlowC	word containing  realtime slow clock (1-second)
:
:	GMT	word containing GMT clock
:
:	Temper	byte containing machine temperature
:
:	Volts	byte containing machine voltage
:
:	VerNo	halfword containing ISIS version number
:
:	WWVBT	word containing WWVB time
:
:	HostX	halfword containing kernel host number
:
:	NodeX	halfword containing kernel node number
:
:	LCX	halfword, offset of local clocks within seg F
:
:	SlCnt	halfword, number of slots known to ISIS dispatcher
:
:	LCT	halfword, pointer to crash table
:
:	MaxP0	halfword, highest port 0 msg. #
:
:	MaxMsg	halfword, highest msg # for all other ports
:
:	LP0LST	halfword, length table for port 0 msgs.
:
:	LENGTH	length table for msgs. all other ports
:
:	R0-R15	symbolic names for the registers
:
:	segN	the start address of segment N (0-0E)
:
:	Hosts	halfword array of host numbers as known by the dispatcher (R/O)
:
:	Ports	halfword array of ports/host as known by dispatcher (R/O)
:
:
: the following symbols MAY be defined. defaults used otherwise
:
:	AprotN	protection byte for area N. default area 1 write protected,
:		other areas execution protected.
:
:	HostN	host number for host position N. default none.
:
:	HprtN	number of ports for host position N. default none.
:
:	Dstart	user DDT execution start address. default none.
:
:	Qstart  user DDT query handler start address, default none.
:
:	Fpanel	halfword cell for front panel display. default cell allocated
:
:	FrISIS	bit array for input backpressure (1=no backpressure) default
:		array allocated.
:
:	ToISIS	bit array for output backpressure (1=no backpressure) default
:		array allocated.
:
:	Version	version number for slot code (default zero)
:
:	PcTtbl	bit array for indicating terminating character for project
:		code. (default none)
:
:	RevLev	revision level for slot code (default zero)
:
:	a.data	segment number for data area. Default 0
:
:	a.code	segment number for code area. Default 1
:
:	a.bdat	segment number for based data. Default 2.
:
:	a.ring	segment number for rings. Default 2.
:
:	a.buff	segment numberfor buffer(let)s. Default 2.
:
:
: in addition, most SVC calls have been assigned symbolic names.
	gl	FastC,SlowC,Rate,nRate,GMT,Temper,Volts,VerNo,HostX,NodeX
	gl	r0,r1,r2,r3,r4,r5,r6,r7,r8,r9,r10,r11,r12,r13,r14,r15
	gl	IRsize,ORsize,CNTRL,ENTRY,Iring,Oring,ENGINE,LCX
	gl	VerRev,CoreSt,Fpanel,Hosts,Ports,FrISIS,ToISIS,SlotNo
	ra	0

Rate	eq	$a 600		:clock rate, ticks per second
nRate	eq	0f0000		:word, contains RATE
FastC	eq	0f0004		:word, contains fast clock (ticks)
SlowC	eq	0f0008		:word, contains slow clock (seconds)
GMT	eq	0f000c		:word, contains GMT (seconds since 1/1/72)
Temper	eq	0f0010		:byte, contains machine temperature
Volts	eq	0f0011		:byte, contains machine voltage
VerNo	eq	0f0012		:halfword, ISIS version number
WWVBT	eq	0f0014		:word, WWVB time (format ??)
HostX	eq	0f0018		:halfword, kernel host number
NodeX	eq	0f001a		:halfword, kernel node number
LCX	eq	0f001c		:halfword, offset of LoClks within seg F

: LoClkX and LoClkS must be referenced by the pointer in LCX

: LoClkX eq	LoClks-2 	:halfword, index to current clock from LoClkX

: LoClks eq	Seg F + contents of LCX

: clocks for slots, array of word entries per slot
: 1st halfword is user ticks, 2nd is sys ticks for slot

SlCnt	eq	0f001e		:halfword, number of dispatcher slots
LCT	eq	0f0020		:halfword, pointer to crash table
MaxP0	eq	0f0022		:halfword, max. msg. # for port 0
MaxMsg	eq	0f0024		:halfword, max. msg #, all non-0 ports
LP0LST	eq	0f0026		:halfword, offset to port 0 msg length table
LENGTH	eq	0f0028		:byte table, lengths of non-0 port msgs

r0	eq	0
r1	eq	1
r2	eq	2
r3	eq	3
r4	eq	4
r5	eq	5
r6	eq	6
r7	eq	7
r8	eq	8
r9	eq	9
r10	eq	$a 10
r11	eq	$a 11
r12	eq	$a 12
r13	eq	$a 13
r14	eq	$a 14
r15	eq	$a 15

	gl	a.data,a.code,a.bdat,a.ring,a.buff

	if	\a.data
	else
a.data	  eq	  0			:default data area
	ei

	if	\a.code
	else
a.code	  eq	  1			:default code area
	ei

	if	\a.bdat
	else
a.bdat	  eq	  2			:default based data area
	ei

	if	\a.ring
  	else
a.ring	  eq	  2			:default ring area
	ei

	if	\a.buff
	else
a.buff	  eq	  2			:default buffer area
	ei

: SVC definitions

	gl	DISMIS,FASTD,SYS,RSTRT.,CFGND.,DBGON.,DBGOF.,TSTDB.
	gl	FREEZ.,THAW.,TFREZ.,RDDTR.,RDDTP.,RBREG.,RBPSD.
	gl	RFREG.,RFPSD.,RDMAC.,RBMAC.,RFMAC.,SET1P.,SETP.,SETBE.
	gl	SETFE.,IO,IOQRY.,CSYNI.,CSYNO.,FSYNO.,TIISC.
	gl	CSUPF.,CSUPR.,FREZS.,THAWS.,ALARM.,RSCLK.,SSCLK.,SUDIA.
	gl	SFREZ.,HALT.,SHALT.
	gl	TIISI.,CASYN.,CPRT.,FPRT.,CSIO.,CMBRD.,FMBIN.,FMBOT.
	gl	SHARE,K.IN,K.OUT,KIO,BDISC,SDISC

DISMIS	eq	0	:dismiss SVC
FASTD	eq	1	:fast dismiss SVC

SYS	eq	2	:sys SVC

:	sys SVC suboperands

RSTRT.	eq	0	:Restart syscall
CFGND.	eq	1	:Connect foreground syscall
DBGON.	eq	2	:Debug mode ON syscall
DBGOF.	eq	3	:Debug mode OFF syscall
TSTDB.	eq	4	:Test debug mode syscall
FREEZ.	eq	5	:Freeze slot syscall
THAW.	eq	6	:Thaw slot syscall
TFREZ.	eq	7	:Test freeze syscall
RDDTR.	eq	8	:Read DDT register syscall
RDDTP.	eq	9	:Read DDT PSD syscall
RBREG.	eq	0a	:Read background register syscall
RBPSD.	eq	0b	:Read background PSD syscall
RFREG.	eq	0c	:Read foreground register syscall
RFPSD.	eq	0d	:Read foreground PSD syscall
RDMAC.	eq	0e	:Read DDT MAC register syscall
RBMAC.	eq	0f	:Read background MAC register syscall
RFMAC.	eq	10	:Read foreground MAC register syscall
SET1P.	eq	11	:Set 1 protect syscall
SETP.	eq	12	:Set protection syscall
SETBE.	eq	13	:Set background execution addr syscall
SETFE.	eq	14	:Set foreground execution addr syscall
LMAC.	eq	15	:Set up MAC from CTA (DDT only)
CSUPF.	eq	16	:Check SUP freeze state
CSUPR.	eq	17	:Check SUP run Q state
FREZS.	eq	18	:Freeze the SUP
THAWS.	eq	19	:Thaw the SUP
ALARM.	eq	1a	:Set/Clear alarm
RSCLK.	eq	1b	:Read the super-clock
SSCLK.	eq	1c	:Set the super-clock
SUDIA.	eq	1d	:Set user diagnostic
UCORE.	eq	1e	:Get slot physical addr & size (DDT only)
SFREZ.	eq	1f	:Super-freeze slot
HALT.	eq	20	:Halt the slot
SHALT.	eq	21	:Super-halt the slot
SVSPY.	eq	22	:Start/Stop SPY
DISCO.	eq	23	:Disconnect Logical Unit


:	I/O suboperands

IO	eq	3	:I/O SVC

IOQRY.	eq	8000	:Query I/O attributes
CSYNI.	eq	0	:Connect SYNC input
CSYNO.	eq	1	:Connect SYNC output
FSYNO.	eq	2	:Force SYNC output
CASYN.	eq	3	:Connect ASYNC
CPRT.	eq	4	:Connect Printer
FPRT.	eq	5	:Force Printer
TIISC.	eq	6	:T-II SYNC Connect
TIISI.	eq	7	:T-II SYNC Idle test
CSIO.	eq	8	:Connect SIO
CMBRD.	eq	9	:Connect SIO mother board
FMBIN.	eq	0a	:Force mother board input
FMBOT.	eq	0b	:Force mother board output
SHARE	eq	04	:Shared device SVC
K.IN	eq	0a	:Kernel Input SVC
K.OUT	eq	0b	:Kernel Output SVC
KIO	eq	0d	:Kernel-I/O (general) SVC
BDISC	eq	0e	:Big disc SVC (obsolete)
SDISC	eq	0f	:Small disc SVC (obsolete)
	if	IRSize&3
	  remark  %IRsize should be multiple of 4
IRsize	  eq	  (IRsize!3)+1
	ei

	if	ORsize&3
	  remark  %ORsize should be multiple of 4
ORsize	  eq	  (ORsize!3)+1
	ei

	if	\MaxPrt
	else
	  remark  %Please define MaxPrt. NPORTT assumed.
MaxPrt	  eq	  NPORTT-1					:huh?
Hprt0	  eq	  MaxPrt
	ei

	if	\MaxHst
	else
	  remark  %Please define MaxHst. 1 assumed.
MaxHst	  eq	  1
Host0	  eq	  HostNo
	ei

: define start of segments

	nolist
X	eq	0
	re	$a 15

	  if	  \seg|X|
	    gl	    seg|X|
	  else
	    seg	    X
	    gl	    seg|X|
seg|X|
  	  ei

X	  eq	  X+1
	er
	list

: generate diagnostics

X	eq	0
	nolist
Y	eq	0
	re	$a 15
	  if	  ((X*10000)%seg|X|)&7fffffff
Y	    eq	    1
	    remark %Symbol SEG
	    number X
	    remark is not defined properly. Value is 
	    number seg|X|
	  ei
X	  eq	  X+1
	er
	list

	if	Y
	  remark  %Start.Lib **MUST** be assembled FIRST!!%
	ei
	subttl	ISIS Ring Handling Routines	- Fring.Lib
:
:	This program is the sole property and confidential
:	information of Tymshare, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.
:
	ra	0		:	Fring.Lib
:
:	ISIS RING HANDLERS
:
:	This package is the fast, efficient ring handler set
:
:	The following CONSTRAINTS apply:
:
:	1.  Once started, register 14 or 15 is dedicated to that
:	    operation, until it is "ended".
:
:	2.  If a new operation is started before the previous operation is
:	    "ended", the previous operation is aborted, and the
:	    appropriate ring is effectively left unchanged.
:
:	This package now permits simultaneous input and output!!!
:
:		R15 is used for output operations
:		R14 is used for input operations
:
:*: 	NOTE: ISIS II will soon use negative indexing, like this ring package.
:*:	To convert this package, remove all lines with ':*:' in them,
:*:	and change all occurrences of 'LHL R15/R14' to 'LH R15/R14'.
:
:	The package contains both utility and primitive routines:
:
:
:	UTILITY ROUTINES are called with link R5,
:		they preserve registers R6--R14.
:
:	OCS	Output Canned String
:		R2 = port #, R3 = pointer to string (SC format)
:		OCS will output string as a data message to the specified
:		port. OCS goes to completion, and "ends the operation.
:
:	OCM	Output Canned Message
:		R2 = port #, R3 = pointer to string (SC format)
:		OCM will output the string as a message to the specified port
:		OCM goes to completion, and "ends the operation.
:
:	OBS	Output Byte String
:		R2 = number of characters, R3 = pointer to string
:		OBS will output specified string into the current message
:		message must have already been "started", and is NOT "ended".
:
:
:	PRIMITIVE INPUT ROUTINES.  All link on R4, & preserve R1-R3, R5-R13, R15:
:
:	Look	Determine if an input message exists...normal return if not
:		skip (4) return if so, and then:
:		R1 = port number
:		R2 = message type code (peek)
:		On skip return, condition codes are set such that JE will
:		succeed on port 0.  The port number will have been removed
:		from the message but the message code will not have been
:		removed (you get a peek at it).
:
:	GetCH	Get a character, returned in R0.
:
:	GetH	Get a halfword, returned in R0.  An even number of bytes 
:		should have been removed previously for expected results.
:
:	GetW	Get a word, returned in R0.  An even number of halfwords 
:		should have been removed previously for expected results.
:
:	Flush	Flush away ("end") remainder of input message.  R0 is number
:		of bytes remaining to flush.
:
:	ELIR	End-Logical-Input-Record.  "Ends" current message, sets
:		up pointers for next message.
:
:
:	PRIMITIVE OUTPUT ROUTINES.  All link on R4, preserve R1-R3, R5-R14,
:		unless used for arguments, or otherwise specified:
:
:	Space	Returns R0 = number of characters of space available in	
:		output ring. Sets up R15 for "start" of message.
:
:	Room	R0 = number of characters required for next message,
:		returns when that much room is available in output ring.
:		MAY DISMISS.
:		sets up R15 for "start" of message. SMASHES R1.
:
:	SLOR	Start Logical Output Record.
:		R0 = number of bytes required.
:		R1 = port #
:		R2 = message type code.
:		Provides function of ROOM, PUTH, and PUTCH for first 3 chars
:		of message. MAY DISMISS. SMASHES R3.
:
:	PutCH	places character in R0 in next position of ring.
:
:	PutH	places halfword in R0 in next position of ring.  Even number
:		of bytes have been output previously in this message.
:
:	PutW	places word in R0 in next position of ring.  Even number of
:		halfwords should have been output previously in this message.
:
:	ELODR	End Logical Output Data Record
:		places byte count into message type to make data message,
:		then "ends" message.  Smashes R0, R1.
:
:	ELOR	End Logical Output Record
:		"ends" message.
:
:
:	CONVENTIONS:
:
:		routines use dedicated registers:
:
:		r15	output ring index
:		r14	input ring index
:
:	note....
:		IRsize and ORsize must each be less than 32k.


	gl	Iring,Oring,IRsize,ORsize
	gl	OCS,OCM,OBS
	gl	Look,GetCH,GetH,GetW,Flush,ELIR
	gl	Space,Room,SLOR,PutCH,PutH,PutW,ELODR,ELOR

	mo	(.),Ring

NFMI	eq	0		:relative index of Next-Fill-Message-Index
CEI	eq	2		:relative index of Current-Empty-Index
RING	eq	4		:relative index of start of ring data

	seg	A.RING
Oring
	hc	0		:Next-Fill-Message-Index
	hc	0		:Current-Empty-Index
	bs	ORsize		:the output RING
Iring
	hc	0		:NFMI 		offset = 0
	hc	0		:CEI		offset = 2
	bs	IRsize		:the input RING offset = 4

	seg	a.code

:	Look at a ring entry
:
:	if ring empty
:	  normal return
:	else 
:	  skip return
:	  condition code reflects port number
:	  r1 = port
:	  r2 = message type
:	  all registers set up for transfer
:	  position is advanced past port#
:	endif

	bnd	2

	if	\Look
.Look.
	else
Look	
	ei

	lhl	r14,(CEI+Iring),,
	clh	r14,(NFMI+Iring),,
	jer	r4			:normal ret if CEI = NFMI (empty)

	shi	r14,(IRsize)		:*: convert to negative index

	if	\(seqring)
	  l	  r1,(Csnum),,
	  st	  r1,(IRsnum+IRsize),r14,
	  ais	  r1,(1)
	  st	  r1,(Csnum),,
	ei

	lhl	r1,(Iring+RING+IRsize),r14, :port #

	ais	r14,(2)
	lb	r2,(Iring+RING+IRsize),r14, :message type

	lr	r1,r1			:set CC according to port number
	j	4,r4			:skip return


:	Get a CHaracter from the input ring
:	character returned in r0
GetCH
	LB	r0,(Iring+RING+IRsize),r14,
	ais	r14,(1)
	jlr	r4

	lhi	r14,(-IRsize)
	jr	r4

:	Get a Half-word from the input ring
:	assume have removed an integral number of half-words from record
:	half-word returned in r0
GetH
	LHL	r0,(Iring+RING+IRsize),r14,
	ais	r14,(2)		
	jlr	r4				

	lhi	r14,(-IRsize)
	jr	r4				

:	Get a Word from the input ring
:	assume have removed an integral number of words from record
:	word returned in r0
GetW
	L	r0,(Iring+RING+IRsize),r14,
	ais	r14,(4)
	jlr	r4

	lhi	r14,(-IRsize)
	jr	r4

:	Flush an input record
:	number of chars to flush in r0
Flush
	ar	r14,r0			:advance ring and fall through

:	End Logical Input Record
ELIR
	ais	r14,(3)			:force to next word
	nhi	r14,(0fffc)
	jlfs	ei1
	  shi	  r14,(IRsize)
ei1
	ahi	r14,(IRsize)		:*: unconvert
	sth	r14,(CEI+Iring),,
	jr	r4

:	Output "Canned" Message
:	link on r5
:	r2 = port #
:	r3 = pointer to string (format: n\B1\...\Bn)
OCM
	lb	r0,(0),r3
	ais	r0,(5)
	nhi	r0,(0fffc)
	jal	r4,Room			:HANG in "Room" til there is some

	if	\(seqring)
	  l	  r4,(Csnum),,
	  st	  r4,(ORsnum+ORsize),r15,
	ei

	lr	r0,r2
	jal	r4,PutH			:port #

	lb	r2,(0),r3		:load r2 with "how many bytes"
	j	ocs1

:	Output "Canned" String
:	link on r5
:	r2 = port #
:	r3 = pointer to text string (format n\B1\...\Bn)
OCS
	lb	r0,(0),r3
	ais	r0,(6)
	nhi	r0,(0fffc)
	jal	r4,Room

	if	\(seqring)
	  l	  r4,(Csnum),,
	  st	  r4,(ORsnum+ORsize),r15,
	ei

	lr	r0,r2
	jal	r4,PutH			:port number

	lb	r2,(0),r3		:length into count-down register

	lr	r0,r2			:length is also message type
	jal	r4,PutCH
ocs1
	  ais	  r3,(1)
	  lb	  r0,(0),r3		:dig out a character
	  jal	  r4,PutCH

	sis	r2,(1)			:count down till all sent
	jgbs	ocs1

	jal	r4,ELOR

	jr	r5

:	Output a Byte String
:	link on r5
:	r3 = pointer to string
:	r2 = number of characters to output from string
obs1
	  ais	  r3,(1)
OBS
	  lb	  r0,(0),r3
	  jal	  r4,PutCH

	sis	r2,(1)
	jgbs	obs1

	jr	r5

:	find how much Space is in the ring (how big a message it will take)
:	returns r0 = the number of characters of space
Space
	lhl	r15,(NFMI+Oring),,

	lcs	r0,(4)			:(fffffffc)
	nh	r0,(CEI+Oring),,	:force emptier to word boundary

	sr	r0,r15			:space between us and emptier
	jgfs	s1
	  ahi	  r0,(ORsize)		:wrap
s1
	sis	r0,(4)			:possible overflow

	shi	r15,(ORsize)		:*: convert to negative index
	jr	r4

:	insure there is Room in the ring (dismiss if necessary)
:	expects r0 = number of characters of space
Room
	lhl	r15,(NFMI+Oring),,
	shi	r15,(ORsize)		:*: convert to neg. index
rm1
	  lcs	  r1,(4)		:(fffffffc)
	  nh	  r1,(CEI+Oring),,	:force to word boundary
	  shi	  r1,(ORsize)		:*:

	  sr	  r1,r15
	  jgfs	  rm2			:NFMI < CEI
	  jer	  r4			:NFMI = CEI (dispatcher caught up)
	  ahi	  r1,(ORsize)		:NFMI > CEI
rm2
	  sis	  r1,(4)		:allow for potential overflow
	  cr	  r0,r1
	  jler	  r4			:room enough

	  svc	  DISMISS,0		:wait for dispatcher to move CEI enough
	j	rm1

:	Start Logical Output Record
:	provides function of Room, PutH, & PutCH for first 3 chars of message
:	r0 = number of characters of space required
:	r1 = port #
:	r2 = message character code
SLOR
	lhl	r15,(NFMI+Oring),,
	shi	r15,(ORsize)		:*: convert to neg. index

	if	\(seqring)
	  l	  r3,(Csnum),,
	  st	  r3,(ORsnum+ORsize),r15,
	ei
sl1
	  lcs	  r3,(4)		:(fffffffc)
	  nh	  r3,(CEI+Oring),,	:force receiver to word boundary
	  shi	  r3,(ORsize)		:*:

	  sr	  r3,r15
	  jgfs	  sl2
	    ahi	    r3,(ORsize)		:possible ring fold
sl2
	  sis	  r3,(4)		:allow for potential overflow
	  cr	  r3,r0
	  jgefs	  sl3			:if enough room

	  svc	  DISMISS,0
	jbs	sl1

sl3
	stH	r1,(Oring+RING+ORsize),r15,   :port # (2 bytes)
	stB	r2,(Oring+RING+ORsize+2),r15, :message type (1 byte)
	ais	r15,(3)
	jr	r4

:	Put a CHaracter into the ring
:	r0 = character
PutCH
	STB	r0,(Oring+RING+ORsize),r15,
	ais	r15,(1)
	jlr	r4

	lhi	r15,(-ORsize)
	jr	r4

:	Put a Half-word into the ring
:	r0 = half-word
PutH
	STH	r0,(Oring+RING+ORsize),r15,
	ais	r15,(2)
	jlr	r4

	lhi	r15,(-ORsize)
	jr	r4

:	Put a Word into the ring
:	r0 = word
PutW
	ST	r0,(Oring+RING+ORsize),r15,
	ais	r15,(4)
	jlr	r4

	lhi	r15,(-ORsize)		 
	jr	r4

:	End Logical Output Data Record
ELODR
	lhl	r1,(NFMI+Oring),,
	shi	r1,(ORsize)		:*: convert to neg. index
	lr	r0,r15
	sr	r0,r1			:compute size of message
	jgefs	ed1
	  ahi	  r0,(ORsize)		:correct
ed1
	sis	r0,(3)			:allow for header
	jer	r4			:if zero length message

	stb	r0,(Oring+RING+ORsize+2),r1, :insert message type into message


:	End Logical Output Record
ELOR
	ais	r15,(3)
	nhi	r15,(0fffc)
	jlfs	el1
	  lhi	  r15,(-ORsize)		:fold
el1
	ahi	r15,(ORsize)		:*: unconvert
	sth	r15,(NFMI+Oring),,	:advance pointer to next message

	if	\(seqring)
	  l	  r0,(Csnum),,
	  ais	  r0,(1)
	  st	  r0,(Csnum),,
	ei

	jr	r4

	em
	subttl	ISIS startup and Crash Library	- Crash.Lib

        remark  %Crash.Lib    11-15-84 AWT
	remark	%This version has an option for extended crash processing.

:	This program is the sole property and confidential
:	information of Tymshare, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.
:
:
:	R E V I S I O N     H I S T O R Y
:
:       Set UPSW to turn off tracing.
:       Added <Ctime> and <CrTime> to save crash times in GMT.
:       Added a <nCrSav> option to keep old copies of crash tables.
:         April 13, 1983 AWT
:
:	Changed the supervisor's log message to report the <ProdID>.
:	  Sep. 20, 1982 SCY.
:
:	<Entry2> (restart service) changed to clear input and output
:	rings PRIOR to issuing Restart SVC to prevent crash-loop if
:	Dispatcher has crashed.
:	  June 17, 1982 MDS.
:
:
:			ISIS - II Version
:
:	Generalized crash package.
:
:	Handles both SOFTWARE and HARDWARE crashes.  On ANY crash, the
:	registers are saved in <CrxReg>, and <CrshCt> is incremented.
:
:	SOFTWARE crashes occur via  jal r10,Crash.  <Crash> saves (R10) in cell
:	<Cpoint>.  Software crashes may be "good" or "bad"...if "good", the
:	calling sequence is:
:
:		jal	r10,Crash
:		hc	0			:"good" crash 
:		bc	4*rLink
:		bc	ReasonCode	
:
:	it usually takes on this appearance:
:
:		jal	r10,Crash
:		bc	0,0,r5*4,0f1
:				
:	Register (rLink) is saved in <Cfrom>, and ReasonCode is saved in <CrashC>
:
:	In the event of a HARDWARE FAILURE, <Cpoint> contains the instruction
:	address at the time of failure, <CrashC> contains the failure reason,
:	and <Cfrom> is set to -1 (all f's).
:
:	On COMPLETION of CRASH PROCESSING, transfers to label <Start>, defined
:	in the user code.
:
:	The symbol <CrStop> may be set to 0 or 1.  If 1 the crash routine will
:	be executed only once.  The second time through the crash area will
:	be set up as specified above and then registers will be restored to
:	their entry value and the slot will be FROZEN. If it is thawed it
:	will restart.
:
:       The symbol <nCrSav> defines the NUMBER of CRASH TABLES to be saved.
:       It will be set to 1 by default. (In TymFil <CrshTb> macro is used
:       to define <nCrSav>)
:
:       :R craT,CrTsiz (or 4C)		dumps the last crash table, 
:       :R craT+CrTlen (or 50),CrTsiz 	dumps the previous one and so on    
:
:       :R Ctime,4			gives the last crash time (in GMT),
:	:R Ctime+CrTlen,4		gives the previous one and so on.
:
:	The symbol <ExCrsh>, if set to 1, allows a JAL to label
:	<Crsh.P> out of the crash routine for EXTENDED CRASH PROCESSING.
:	The link is R5.  <ExCrsh> is defaulted to 0.
	ra	0			:crash.lib	mfr 07/14/81

	gl	Crash,CrashC,Cpoint,Cfrom,CrReg,Entry,Start,craT,CrshCt,CrStop
        gl      ProdID,nCrSav,Ctime,CrTime,ExCrsh

	mo	(.),Crash

	if	\(CrStop)
	else
CrStop	  eq	  0
	ei

	if	\(nCrSav)		:# of crash tables to save
	else				:it may be defined in tymfil
nCrSav    eq      1			:otherwise it is 1 by default
	ei

	if	\(ExCrsh)		:default to no extended crash handling
  	else
ExCrsh	  eq	  0
	ei

	:--------------  define a crash table entry  ------------
x	eq      (.)
        org     0
CrshCt	hs	1			:crash count - how many times crashed
CrashC	hs	1			:crash code (init'ed to manual restart)
Cpoint	hs	2			:crash point - where crash occured
Cfrom	hs	2    			:crash from - where crash called from
CrxReg	hs	20
CrTsiz	eq	(.)			:crash table size - WITHOUT CrTime
CrTime  hs      2			:time of crash (GMT)
CrTlen  eq	(.)			:crash table length - WITH CrTime
	org	x
	:--------------------------------------------------------

        seg     a.data

Ctime   ws	1			:time of LAST crash
CraT    bs      (CrTlen*nCrSav)		:storage for crash table(s)
CrReg   eq      (CraT+CrxReg)		:it's in the globals
FgndFl	hs	1
SixteenWords ws $a 16
TrBoff  wc      0,Fail0         	:trace bit off, go to Fail0
TrCoff  wc      0,Crash0        	:trace bit off, go to Crash0
PswSav  wc      0,Start         	:restore PSW, go to initialization code
ChFlag  wc      0               	:used for any changes on PSW

	seg	a.code
CrshCd
	bc	1			:manual restart
	bc	0			:power failure
	bc	0e			:parity error
	bc	10			:dispatcher crash
	bc	11			:illegal instruction
	bc	12			:illegal SVC
	bc	13			:system crash
	bc	14			:protection violation
	bc	15			:non-recoverable device check
	bc	16			:watch frog timer - - time out

: general machine failure

	bnd	2
Fail
	hs	4			:PSD saved here
	hs	4			:r0,r1 saved here

        st      r0,(SixteenWords),,
        st      r2,(SixteenWords+4),,

        jal     r2,SavPsw       	:save current PSW

        l       r0,(SixteenWords),,
        l       r2,(SixteenWords+4),,

        UPSW    TrBoff          	:turns trace bit off
Fail0
	lb      r0,(CrshCd),r1
	clhi	r0,12
	jnfs	f1			:if not illegal SVC

	  lhl	  r0,(FgndFl)
	  jn	  Entry2		:if caused by foreground
f1
	stm     r0,(SixteenWords),,

        jal     r2,PshTbs		:push down crash tables

        l       r1,(GMT),,
        st      r1,(Ctime),,		:Ctime is NOW

        lm      r0,(SixteenWords),,
	stm     r2,(CraT+CrxReg+8),,	:put regs 2 thru 15 away

        sth     r0,(CraT+CrashC),,	:put crash code away

	lm      r12,(Fail)		:get PSD (2 wds) and r0, r1 into r12-r15
        stm     r14,(CraT+CrxReg),,	:put r0, r1 away

        st      r13,(CraT+Cpoint),,	:put failure address away

	lcs	r1,(1)
        st      r1,(CraT+Cfrom),,	:write f's to Cfrom area in crash tablw

        j       Entry1			:start up again

:	crash routine and general initializer
:	if "good" call to crash, has halfword 0's following,
:	then byte with 4*link register, then byte with crash reason
Crash
	st      r0,(SixteenWords),,
        st      r2,(SixteenWords+4),,         

        jal     r2,SavPsw		:save current PSW

        l       r0,(SixteenWords),,
        l       r2,(SixteenWords+4),,

        UPSW    TrCoff          	:turns trace bit off
Crash0
	stm     r0,(SixteenWords),,

        jal     r2,PshTbs       	:push down the crash tables

        l       r1,(GMT),,
        st      r1,(Ctime),,		:time of crash is NOW

        lm      r0,(SixteenWords),,
        stm     r0,(CraT+CrxReg),,

        st      r10,(CraT+Cpoint),,                    

	lis	r0,($a10)		:(unknown crash code)
	lcs	r1,(1)			:all f's

	lhl	r2,(0),r10		:check first 2 bytes past jal r10,crash
	jnfs	c1			:if they were NOT 00 00

	  lb	  r0,(3),r10		:get user-supplied crash "reason"

	  lb	  r2,(2),r10		:get calling register * 4
          l       r1,(CraT+CrxReg),r2 	:get contents of register
c1
	sth     r0,(CraT+CrashC),, 	:put crash "reason" away
        st      r1,(CraT+Cfrom),,  	:put "where from crashed" away

	jfs	Entry1

: enter here with restart

Entry
	lis	r0,(1)
        sth     r0,(CraT+CrashC),, 	:put a "1" in CrashC
Entry1
	lis	r1,(1)
        ahm     r1,(CraT+CrshCt),,	:count the crashes in CrshCt

	if	CrStop			:if stopping on consecutive crashes
	  clhi	  r0,(1)
	  jle	  Entry2		:if power failure or manual restart

	  ohi	  r0,(0cc00)
	  sth	  r0,(Fpanel),,		:set front panel to bad crash

	  if	  ExCrsh
	    jal	    r5,Crsh.P,,		:go do EXTENDED CRASH PROCESSING
	  ei	  

	  lm      r0,(CraT+CrxReg),, 	:restore registers

	  svc	  SYS,HALT.		:HALT THE SLOT
	ei	

	lis	r0,(1)
	svc	SYS,RFPSD.		:get 2nd word of foreground PSD

	cli	r0,(.)			:is foreground executing THIS instruction
	jnfs	Entry2
	  sth	  r0,(FgndFl)		:yep, it was - set the foreground flag
Entry2
	if	CrStop
	else
 	  if	  ExCrsh
	    jal	    r5,Crsh.P,,		:if not stopping on crashes and
	  ei				: ExCrsh is true, jal on r5 to Crsh.P
	ei

	lis	r0,(0)
	st	r0,(Oring),,		:reset output and input rings
	st	r0,(Iring),,

	la	r0,(Fail)		:load trap area address
	svc	SYS,RSTRT.		:issue a restart svc

	jal	r10,Crash		:1 non-skip return "can't happen"

	lis	r0,(0)			:2 skip return - ok
	sth	r0,(FgndFl)		:clear the foreground flag

	jal	r4,Space,,

	lhi	r0,(0300)		:00000300
	jal	r4,PutW,,		:port 0 + report to sup's log + key

	lhl	r0,(CraT+CrshCt),,
	jal	r4,PutCH,,		:crash count

	lis	r0,(0)
	jal	r4,PutCH,,		:reserved byte

	lis	r0,(1)
	jal	r4,PutCH,,		:report type = 1

	lhl	r0,(CraT+CrashC),,
	jal	r4,PutCH,,		:crash code

	lhi	r0,(ProdID)
	jal	r4,PutCH,,		:Product ID

	jal	r4,ELOR,,

        l       r1,(ChFlag),,
        clhi    r1,(1)
        je	Start,,			:no PSW change, use cur PSW, "START"

        lis     r1,(0)
        st      r1,(ChFlag),,     	:clear ChFlag for future PSW change

        UPSW    PswSav          	:restore PSW, do externally defined "START"

SavPsw 
	lis     r0,(1)
        st      r0,(ChFlag),,     	:indicate PSW will be modified

	svc     SYS,RBPSD.
        cli     r0,(.)
        jnfs	s1			:if foreground running

	  lis     r0,(0)
          svc     SYS,RBPSD.
          st      r0,(PswSav),,		:save PSW of background job
          jr      r2
s1
	  lis     r0,(0)
          svc     SYS,RFPSD.
          st      r0,(PswSav),,     	:save PSW of foreground job
          jr      r2

PshTbs
	lhi     r1,(CrTlen*nCrSav)-(CrTlen*2)
        jlr     r2              	:if only 1 crash table, return
p1
	  lm      r6,(CraT),r1		:push down the crash table
          stm     r6,(CraT+CrTlen),r1

          lm      r6,CraT+(CrTlen/2),r1
          stm     r6,(CraT+CrTlen)+(CrTlen/2),r1

        shi     r1,(CrTlen)
        jgebs	p1

        l       r1,(Ctime),,
        st      r1,(CraT+CrTsiz),,
       
	jr      r2

	em
	subttl	Standard Timeout Routine Library	- TimOut.lib

:	This program is the sole property and confidential
:	information of Tymshare, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.
:
: YOU MUST DEFINE <nTout> to the MAXIMUM NUMBER of entries you ever expect
: to have waiting to execute

:+---------+---------+-----------------------------+
:| Head    | Head    |				   | (this example shows how
:| Free    | Active  |	       u n u s e d	   | things look after IZT
:| List    | List    |				   | is run.  nTout is set 
:| Pointer | Pointer |				   | to 3)   
:+----+----+----+----+----+----+----+----+----+----+
:| 00   0a | 00   00 |                             |   <-- list head pointers
:+----+----+----+----+----+----+----+----+----+----+


:+---------+-------------------+-------------------+
:|	   | Address of	       |		   |
:| List    | Routine to be     | Activation	   |
:| Pointer | Executed	       | Time		   |
:+----+----+----+----+----+----+----+----+----+----+
:| 00   14 |                   |                   |
:+----+----+----+----+----+----+----+----+----+----+
:| 00   1e |                   |                   |
:+----+----+----+----+----+----+----+----+----+----+
:| 00   00 |                   |                   |
:+----+----+----+----+----+----+----+----+----+----+

	ra	0
	gl	IZT,TimOut,TOret,TOput,CRASH,TOget,TOnow,nTout
	mo	(.),TimOut

	seg	a.data

	if	6-(.)
	  bs	  6-(.)	 		: ?
	ei

ScratchWord 		hs	2

Tlist	    		bs	(nTout+1)*(2+4+4)

HeadFreeListPointer   	eq	Tlist
HeadActiveListPointer 	eq	(Tlist+2)
HALPoffset	      	eq	2

ListPointer		eq	Tlist
AddressOfRoutine	eq	(Tlist+2)
ActivationTime		eq	(Tlist+6)

rThisOneR1     		eq	r1 
rOneBeforeR2   		eq	r2
rIndexR2       		eq	r2
rCurrentOneR2  		eq	r2
rPreviousOneR3 		eq	r3 

	seg	a.code
	bnd	2

:-----------------------------------------------------
: TORET: Routines called by TIMOUT should exit to here

TOret
	l	r0,(ScratchWord)

:--------------------------------------------------------------
: TIMOUT SHOULD BE CALLED PERIODICALY, link on r0, this routine 
: will in turn jump to any routines which should be serviced
: might clobber r1, r2, r3, r4

TimOut
	lhl	rIndexR2,(HeadActiveListPointer)
	jer	r0				:if none on active list

	l	r1,(FastC),,
	cl	r1,(ActivationTime),rIndexR2
	jlr	r0				:if not time for this one

	st	r0,(ScratchWord)		:put r0 in safe place

	lhl	r3,(ListPointer),rIndexR2	:get pntr to next one in list
	sth	r3,(HeadActiveListPointer)	: put it at head of active list

	lhl	r4,(HeadFreeListPointer)	:get (old) head free list pntr
	sth	r4,(ListPointer),rIndexR2	: put it in this one's pntr
	sth	rIndexR2,(HeadFreeListPointer)	: this one now head of free list

	l	r0,(AddressOfRoutine),rIndexR2
	jr	r0				:go do user's timeout routine

:--------------------------------------------------
: call TOput to PLACE AN ENTRY on the timeout LIST:
: link on R5, r2,r3 stepped on. enter with:
: R0 = address of the routine
: R1 = time to call routine

TOput
	lis	rCurrentOneR2,(HALPoffset)
p1
	  lr	  rPreviousOneR3,rCurrentOneR2

	  lhl	  rCurrentOneR2,(ListPointer),rPreviousOneR3
	  jefs	  p2				:if end of active list

	cl	r1,(ActivationTime),rCurrentOneR2 :spec'd time vs. time in list
 	jgbs	p1
p2
	lhl	r4,(HeadFreeListPointer)	:load r4 with next avail. slot
	jlefs	KaBlooey			:(if nTout was set too small)
	sth	r4,(ListPointer),rPreviousOneR3	:earlier one points to new one 

 	lhl	r3,(ListPointer),r4		
	sth	r3,(HeadFreeListPointer)	:shorten free list

	sth	rCurrentOneR2,(ListPointer),r4	:make new one point to next one
	st	r0,(AddressOfRoutine),r4	:store routine address,
	st	r1,(ActivationTime),r4		: activation time.

	jr	r5

KaBlooey
	jal	r10,CRASH			:make <nTout> bigger or
	bc	0,0,4*r5,0f			: stop calling <ToPut>

:---------------------------------------------------------------
: TOnow should be called to REMOVE an entry, AND EXECUTE it NOW!
: link on r5. r1, r2, r3 clobbered
: call with routine address in r0

TOnow
	lis	rThisOneR1,(HALPoffset)
n1
	  lr	  rOneBeforeR2,rThisOneR1

	  lhl	  rThisOneR1,(ListPointer),rOneBeforeR2
	  jer	  r5				:if end of list

	cl	r0,(AddressOfRoutine),rThisOneR1
	jnbs	n1				:if no match

	lhl	r3,(ListPointer),rThisOneR1	:make the one before point to
	sth	r3,(ListPointer),rOneBeforeR2	: where this one points.

	lhl	r3,(HeadFreeListPointer)	:get (old) head free list pntr
	sth	r3,(ListPointer),rThisOneR1	:put it in this one's pntr
	sth	rThisOneR1,(HeadFreeListPointer) :make this one head free list 

	st	r5,(ScratchWord)		:put r5 in a safe place
	jr	r0				:do that timeout routine now

:-----------------------------------------------------------------
: TOget should be called to DELETE an entry ALREADY ON timout list
: link on r5. r1, r2, r3 clobbered.
: enter with R0 = routine address (preserved)

TOget
	lis	rThisOneR1,(HALPoffset)
g1
	  lr	  rOneBeforeR2,rThisOneR1

	  lhl	  rThisOneR1,(ListPointer),rOneBeforeR2
	  jer	  r5

	cl	r0,(AddressOfRoutine),rThisOneR1
	jnbs	g1

	lhl	r3,(ListPointer),rThisOneR1	:make the one before this one
	sth	r3,(ListPointer),rOneBeforeR2	: pnt to where this one pntd

	lhl	r3,(HeadFreeListPointer)	:get (old) head free list pntr
	sth	r3,(ListPointer),rThisOneR1	:put it in this one's pntr
	sth	rThisOneR1,(HeadFreeListPointer)  :make this one head free list

	jr	r5
:-----------------------------------------------------------
: IZT   called at initilization, link on r0. clobbers r1, r2

IZT
	lhi	r1,(nTout*(2+4+4))
	lis	r2,(0)		
	sth	r2,(ListPointer),r1		:last entry in free list is 0
iz1
	  sth	  r1,(ListPointer-(2+4+4)),r1	:working backwards, make 
						: list pointers point forward.
	sis	r1,(2+4+4)
	jgbs	iz1

	sth	r2,(HeadActiveListPointer)	:active list init'd to empty

	jr	r0

	em
	subttl	Data Conversion Routines	- CONVRT.LIB

:	This program is the sole property and confidential
:	information of Tymshare, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.

:	BinDec is a routine to convert internal binary representation of
:	data to ascii decimal characters.
:
:	arguments: r9  - (rNum) contains the binary number to be converted
:	           r10 - (rCount) specifies the number of characters in output area
:	           r11 - (rPoint) points to output area
: 	  link on: r4

	ra	$0 0
	mo	(.),Convrt
	gl	BinDec,BinHex,BinOct

rNUM	   eq	9
rCount	   eq	$a 10
rPoint	   eq	$a 11
DecimalTen eq	$a 10
MinusSign  eq	0ad

	seg	a.data
rSave	hs	10
	seg	a.code

	nolist
ZeroToF	ac	/o123456789abcdef/
	list

BinOct
	stm	r8,rSave
	lis	r14,8
	jfs	bx
BinDec
	stm	r8,rSave
	lis	r14,DecimalTen
bx
	lr	rNum,rNum		:negative?
	jgefs	bd1

	  lhi	  r12,MinusSign
	  stb	  r12,0,rPoint		:stick "-" at output pointer

	  ais	  rPoint,1
	  sis	  rCount,1
	  jle	  exit			:if no room for digit after minus sign

	  xi	  rNum,-1		:make the number positive
	  ais	  rNum,1
bd1
	sis	rPoint,1
bd2
	  lis	  r8,0			:watch out for remainder
	  dr	  r8,r14		:(rNum is in r9) (radix is in r14)

	  lb	  r13,ZeroToF,r8
	  stb	  r13,0,rPoint,rCount

	sis	rCount,1
	jgbs	bd2

exit
	lm	r8,rSave
	jr	r4
:	BinHex is a routine to convert internal binary representation of
:	data to ASCII hex characters. a space character is appended on the
:	end of the hex character string .
:
:	arguments: r8  - (rOutPoint) address of where to put ascii characters
:			 This register is returned updated to just past
:			 the final blank
:	           r9  - (rLoopCount) byte count
:		   r10 - (rInPoint) start address of memory to be processed
:	     link: r4

rOutPoint  eq	8
rLoopCount eq	9
rInPoint   eq	$a 10
Blank	   eq	20

BinHex
	stm	r9,rSave
bh1
	  lb	  r11,0,rInPoint
	  lbr	  r12,r11
	  srhls	  r12,4			:shift upper 4 bits right 4, discard lower 4 

	  lb	  r13,ZeroToF,r12
	  stb	  r13,0,rOutPoint

	  lis	  r12,$2 00001111
	  nr	  r12,r11		:discard upper 4 bits

	  lb	  r13,ZeroToF,r12
	  stb	  r13,1,rOutPoint

	  sis	  rLoopCount,1
	  jlefs	  finishup

	  ais	  rOutPoint,2
	  ais	  rInPoint,1
	j	bh1

finishup
	lhi	r13,Blank
	stb	r13,2,rOutPoint

	ais	rOutPoint,3

	lm	r9,rSave
	jr	r4

	em
	subttl	Time Stamp - 12:01 or 12:01:35

:	this routine converts the fullword GMT time of day
:	to HH:MM or HH:MM:SS
:
:	parameters:
:		r3 = fullword time of day (GMT clock)
:		r4 = (r5or8r4) 5 or 8 (# of characters to output)
:		r5 = (rAddrR5) fullword address of where to put output
:		r6 = link register

	ra	$0 0a			:RADIX IS DECIMAL
	mo	(.),DaTime
	gl	DaTime,TmStmp,Date

r5or8r4 eq 4
rAddrR5 eq 5

TmStmp
	stm	r0,safe

	if 	\(TimZon)
	  ahi	  r3,(TimZon)*(60*60)	:time zone correction
	ei

rPutR8 eq 8

t1
	sr	rPutR8,rPutR8

	sr	r2,r2
	d	r2,c24x60x60		:div secs since 1/1/76 by secs in 1 day

	lr	r3,r2
	sr	r2,r2
	d	r2,c10x60x60		:div secs in THIS day by 10 hr worth of secs 
	jal	r6,AscPut

	dh	r2,c60x60		:div rem from above by # secs in 1 hr
	jal	r6,AscPut

Colon	eq	$0 0ba
	lhi	r3,Colon
	jal	r6,JustPut

	dh	r2,k10x60		:div quo from above by 10 min worth of secs
	jal	r6,AscPut

	dh	r2,c60			:div quo from above by 1 min worth of secs
	jal	r6,AscPut
	jefs	t2			:jump if only 5 characters specified

	lhi	r3,Colon
	jal	r6,JustPut

	dh	r2,c10			:div quo from above by 10 secs worth of secs
	jal	r6,AscPut

	lr	r3,r2			:just raw seconds
	jal	r6,AscPut
t2
	lm	r0,safe
	jr	r6

AscPut
	lr	r3,r3
	jnfs	ap

	lhi	r3,$0 80+6f
	jfs	JustPut
ap
	ahi	r3,$0 80+30
JustPut
	stb	r3,0,rPutR8,rAddrR5
	ais	rPutR8,1
	sis	r5or8r4,1
	jr	r6

	subttl	13 or 16 characters of date and time - 18Dec85 12:01:35
:
:	this procedure converts the GMT clock
:	relative to 1/1/74 from seconds into:
:
:	"DDMMMYY HH:MM"    example: "18Dec84 12:34" or:
:
:	"DDMMMYY HH:MM:SS" example: "23Jun85 01:02:03"
:
:	input parameters:
:
:		r3 = # of seconds since 1/1/74 (beyond 1/1/76) ??
:		r4 = how many characters to output (13 or 16)
:		r5 = address of where to put output string
:		r6 = link register
:
:	all registers are preserved
:
:	make time relative to 1/1/76 - the start of
:	a 'quad-year'.  'quad-year' = 1 leap
:	year + 3 regular years.  there are
:	24 quads plus 4 reg years in a century

	seg	a.data
safe	ws	$0 10
	seg	a.code

DaTime
	stm	r0,safe
	s	r3,TwoYrsOfSecs

rSecondsOfThisDay eq 14

	sr	r2,r2
	d	r2,c24x60x60		:div total # secs elapsed by # secs in 1 day 

	lr	rSecondsOfThisDay,r2

	sr	r2,r2
	d	r2,c4x365p1		:div # of days elapsed by # of days in a quad

rNquadYears eq 3

	slls	rNquadYears,2		:times 4

rYear eq 8	

	lhi	rYear,76		:(19)76
	ar	rYear,rNquadYears

rPointerToDaysInMonthTable eq 7

	la	rPointerToDaysInMonthTable,LeapYearDaysInMonthTable

rNdaysIntoQuadYear eq 2

	c	rNdaysIntoQuadYear,c366
	jl	MonthD

	li	rPointerToDaysInMonthTable,RegYearDaysInMonthTable

	s	rNdaysIntoQuadYear,c366

	lr	r11,rNdaysIntoQuadYear
	sr	r10,r10
	d	r10,c365

rAddtlYears eq 11

	ais	rYear,1
	ar	rYear,rAddtlYears

rDaysIntoYear eq 10
rDays eq 2

	lr	rDays,rDaysIntoYear

rMonth eq 6
rSavDays eq 9
rDysInAmonth eq	3	

monthd
	sr	rMonth,rMonth
	ais	rDays,1			:make 1/1/76 = day 1

monlop
	lr	rSavDays,rDays
	lb	rDysInAmonth,0,rMonth,rPointerToDaysInMonthTable
	sr	rDays,rDysInAmonth
	jlefs	daze			:if minus or zero we're in the month

	ais	rMonth,1
	jbs	monlop


rLenOut eq 4
rAddOut eq 5
rSavrLenOut eq 13

daze
	sis	rLenOut,8		:subtract out len of "ddmmmyy "
	lr	rSavrLenOut,rLenOut	:going to mash r4

	lis	r10,2			:put this many
	lr	r11,r5			: here - (r5 was an input parameter)
	jal	r4,BinDec		:day

	lb	r4,(0),r11
	clhi	r4,$0 80+30
	jnfs	d1

	lhi	r4,$0 80+20
	stb	r4,(0),r11
d1
	slhls	rMonth,2
	l	r4,MonthText,rMonth 
	ais	r11,2
	stb	r4,2,r11

	srls	r4,8
	stb	r4,1,r11

	srls	r4,8
	stb	r4,0,r11

	ais	r11,3

	lr	r9,rYear
	lis	r10,2
	jal	r4,BinDec		:convert year to characters

Blank	eq	$0 20
	lhi	r3,Blank
	stb	r3,2,r11

	lhi	r5,3,r11		:set up output pointer
	lr	r4,rSavrLenOut
	lr	r3,rSecondsOfThisDay
	j	t1


	subttl	Fullword Date - 12181201

:	THIS routine returns a fullword representation of the date
:	and time. the format of the result is MMDDHHMM where
:	MM, DD, HH, & MM represent month, day, hour, & minutes respectively
:	all in decimal format. i.e. Dec 18 12:01 would be 12181201.
:
:	if the symbol TimZon is defined it should be the time-zone
:	correction factor from CUT (coordinated universal time)
:	i.e. pst is -8.
:
:	on input:
:
:		r3 = gmt clock value
:		r6 = result fullword
:
:	link on r5
:
:	preserves registers r7 - r15
:
:	make time relative to 1/1/76 - the start of
:	a 'quad-year'.  'quad-year' = 1 leap
:	year + 3 regular years.  there are
:	24 quads plus 4 reg years in a century

Date
	stm	r7,safe
	s	r3,TwoYrsOfSecs

rSecondsOfThisDay eq 14

	sr	r2,r2
	d	r2,c24x60x60		:divide by 1 day's worth of seconds

	lr	rSecondsOfThisDay,r2

: r3 has # of days elapsed 

	sr	r2,r2
	d	r2,c4x365p1		:divide by # days in a quad

rNquadYears eq 3
rNdaysIntoQuadYear eq 2
rYear eq 8

	lhi	rYear,76		:(19)76

	slls	rNquadYears,2
	ar	rYear,rNquadYears

rPointerToDaysInMonthTable eq 7

	la	rPointerToDaysInMonthTable,LeapYearDaysInMonthTable

	c	rNdaysIntoQuadYear,c366
	jl	mnthd

	li	rPointerToDaysInMonthTable,RegYearDaysInMonthTable

	s	rNdaysIntoQuadYear,c366
	lr	r11,rNdaysIntoQuadYear
	sr	r10,r10
	d	r10,c365

rDaysInYear eq r10
rAddtlYears eq r11
rDays eq 2

	lr	rDays,rDaysInYear

	ais	rYear,1
	ar	rYear,rAddtlYears

rMonth eq 6
rSavDays eq 9
rDysInAmonth eq 3

mnthd
	sr	rMonth,rMonth
	ais	rDays,1			:make 1/1/76 = day 1
mloop
	lr	rSavDays,rDays
	lb	rDysInAmonth,0,rMonth,rPointerToDaysInMonthTable
	sr	rDays,rDysInAmonth
	jlefs	daze1			:if minus or zero we're in the month

	ais	rMonth,1
	jbs	mloop

daze1
	ais	rMonth,1
	lb	r6,DecimalTable,rMonth
	slls	r6,8				:MM

	lb	r9,DecimalTable,rSavDays
	or	r6,r9
	slls	r6,8				:DD

	lr	r2,rSecondsOfThisDay
	dh	r2,c60x60
	lb	r3,DecimalTable,r3
	or	r6,r3
	slls	r6,4				:H

	dh	r2,k10x60
	or	r6,r3
	slls	r6,4				:H

	dh	r2,c60
	or	r6,r3				:MM

	lm	r7,safe
	jr	r5

c365	wc	365			:constants for divide instructions
c366	wc	366			:(days in 2 kinds of years)

c4x365p1 wc	4*365+1			:this is the number of days in a quad year

c24x60x60 wc	24*60*60		:24 hrs		  (days)
c10x60x60 wc	10*60*60		:10 hrs		  (10s of hours)
c60x60	hc	60*60			:1 hr		  (hours)
k10x60	hc	10*60			:1/6 hr (10 min)  (10s of minutes)
c60	hc	60			:1 min		  (minutes)
c10	hc	10			:1/6 min (10 sec) (10s of seconds)

	nolist
DecimalTable 
	xc	00010203040506070809
	xc	10111213141516171819
	xc	202122232425262728293031

LeapYearDaysInMonthTable bc 31,29,31,30,31,30,31,31,30,31,30,31
RegYearDaysInMonthTable  bc 31,28,31,30,31,30,31,31,30,31,30,31
	list

	if	\(TimZon)
TwoYrsOfSecs wc (24*60*60*365*2)-(TimZon*60*60)	:secs in 1974 & 1975 plus tzc 
	else
TwoYrsOfSecs wc (24*60*60*365*2)		:seconds in 1974 and 1975
	ei

MonthText ac	/ Jan/
	ac	/ Feb/
	ac	/ Mar/
	ac	/ Apr/
	ac	/ May/
	ac	/ Jun/
	ac	/ Jul/
	ac	/ Aug/
	ac	/ Sep/
	ac	/ Oct/
	ac	/ Nov/
	ac	/ Dec/
	em
	ra	$0 0			:radix back to hex

                subttl define the output msg from MSV (MSVMSG.S30)

: (MENUDEV)MSVMSG.S32 - GWH,   02/29/88
:       STORE THE MSG IN SEG A.TEXT except retry msg.

: (menudev)MSVMSG.S30 - GWH,    9/30/87
:       The file contains all the output message form the Menu Server

        NOLIST
        SEG     A.TEXT

                :---------------------------:
                : MESSAGE FOR THE TICKLER   :
                :---------------------------:

TMDIS   SC      /"0a"0d<ms> *** Tickler is on display now"0a"0d/
TMNDIS  SC      /"0a"0d<ms> *** There is no tickler on display"0a"0d/
TMUPDT  SC      /"0A"0D<ms> *** Tickler is going to be updated in a minute."0a"0d/
TMDNOW  SC      /"0A"0D<ms> *** The following tickler is going to effect right away."0a"0d/
TMNXTT  SC      /"0a"0d<ms> *** Next tickler will be displayed at /
TMTM    SC      /HH:MM X.M. /
TMTIME  SC      /HH:MM X.M."0a"0d/
TMNEWM  SC      /"0A"0D"0A"0D<ms> *** NEW TICKLER"07"0A"0D/
TMNOW   SC      /"0A"0D<ms> *** Display next tickler right away."0a"0d/
TMCMND  SC      /"0a"0d<ms> Select command: (1) new (2) type (3) reschedule (4) quit"0A"0D->/
TMERCM  SC      /"0a"0d<ms> ?? INVALID COMMAND ??"07 Please try again."0a"0d/
TMABOT  SC      /"0a"0d<ms> Abort existing next tickler? CR,Y,y to continue."0a"0d/
TMENTR  SC      /"0a"0d<ms> ( ^D - exit, ^A - delete last char, ^Q - erase this line )/
TMPRMP  SC      /"0a"0d<ms> -> /
TMFULL  SC      /"0A"0D<ms> *** The tickler buffer is full. type ^D to exit."07"0a"0d/
TMTOLN  SC      /"0A"0D<ms> *** This line is too long."07"0a"0d/
TMESCH  SC      /"0a"0d<ms> Please enter the schedule."0a"0d (HHMM<cr>, <cr> for now, <esc> to cancel)"0a"0d-> /
TMERS   SC      /"0A"0D<ms> ??INVALID SCHEDULE?? Please try again."07"0a"0d-> /
TMEFF   SC      /"0a"0d<ms> Display next tickler right away (Y,N,<esc>)"0a"0d-> /
TMSCH   SC      /"0A"0D<ms> Display next tickler at /
TMCFM   SC      /(Y,N,<ESC>)"0a"0d-> "07 /
TMHDC   SC      /"0A"0D<ms> *** currently on display "0a"0d/
TMNNX   SC      /"0A"0D<ms> *** No next tickler."0a"0d/
TMEMPT  SC      /"0A"0D<ms> Empty tickler."0a"0d"07/
TM2MA   SC      /"0A"0D<ms> Second M.A. login request is not permitted"0a"0d"07/
TMABRT  SC      /"0A"0D<ms> NEXT TICKLER CANCELLED."07/
TMBYE   SC      /"0A"0D<ms> TICKLER: BYE NOW. SEE YOU AGAIN."0A"0D/

                :---------------------------:
                : MESSAGES FOR RETRY        :
                :---------------------------:

RETMS1  SC      /"8a"8d(MS) Retrying Login, First try failed."07"0a"0d/

        SEG     A.BDAT
                : only because N will be changed
RETMS2  SC      /"8a"8d(ms) N tries failed./
RETMS3  SC      /"8a"8d(ms) N tries failed. Maximum retry exceeded./
        SEG     A.TEXT


                :---------------------------:
                : DATA LOST MESSAGE         :
                :---------------------------:

GreyBallTxt  sc	/"8d"8a"8a"8a"8a[ms] Input from terminal lost."8d"8a"8a"8a"8a/
HBLKTX       sc /"8d"8a"8a"8a"8a[ms] Output from Host lost."8d"8a"8a"8a"8a/
BlackBallTxt sc	/"8d"8a"8a"8a"8a[ms] Output to terminal lost."8d"8a"8a"8a"8a/
HGRYTX       sc /"8d"8a"8a"8a"8a[ms] Input to Host lost."8d"8a"8a"8a"8a/

                :---------------------------:
                : DEFAULTS FOR CONFIGURABLE :
                : MESSAGES                  :
                :---------------------------:
                :All the configurable messages composes of data strings
                :and terminates by appending 2 bytes zero at the end.
                :Each string has the format as below:
                : /bit flag/string length/char string

HitSpace	:right after the "welcome" message (if no PW required)
        bc      0       :default it to 7bit string
        sc /"0d"0a[ms] To continue, please strike the space bar. /
	hc	0

NRtxt		:when a "rotor list" gets exhausted
        bc      0
        sc /"0d"0a"8a[ms] Can't connect another user right now, please try again later"0d"0a"0a/
        hc      0

NPtxt		:when a host's port quota is exhausted
        bc      0
        sc /"0d"0a"0a[ms] No menu ports available, please try again later"8d"8a"8a/
	hc	0

IStxt		:can't find what was just typed in list of valid selections
        bc      0
        sc /"8d"8a[ms] Invalid selection, please try again"3a /
	hc	0

TMtxt		:12 is the limit
        bc      0
        sc /"8d"8a"8a[ms] Too many characters, please try again"3a /
	hc	0

ZappedTxt	:you might not want this if the menu is automatic
        bc      0
        sc /"8d"8a"8a[ms] circuit cleared"8d"8a"8a/
	hc	0
                                                
                :-------------------------------:
                : NORMAL LOGON STATUS MESSAGES  :
                :-------------------------------:

nls0	sc	/"8d"8a[ms] continue"87 /
plimsg	sc	/"8d"8a[ms] please log in: /
nls2	sc	/"8d"8a[ms] error, type username:"87 /
nls3	sc	/"8d"8a[ms] error, type password:"87 /
nls4	sc	/"8d"8a[ms] username: /
nls5	sc	/"8d"8a[ms] password: /
nlsill	sc	/"8d"8a[ms] Supervisor Rejects Log-in, code unknown!"87"8d"8a/

nls8  sc.beg
	ac	/"8d"8a"8a[ms] please see your representative/
	ac      /"8d"8a     if you are having difficulty logging in"8d"8a"8a/
      sc.end

nls9	sc	/"8d"8a"8a[ms] bad mud"07"8d"8a/
nlsa	sc	/"8d"8a"8a[ms] circuits busy"8d"8a/
nlsb	sc	/"8d"8a"8a[ms] host not available"8d"8a/
nlsc	sc	/"8d"8a"8a[ms] host out of ports"8d"8a/
nlsd	sc	/"8d"8a"8a[ms] host down"8d"8a/
nlse	sc	/"8d"8a"8a[ms] host shut"8d"8a/
nlsf	sc	/"8d"8a"8a[ms] try again in 2 minutes"8d"8a/
nls10	sc	/"8d"8a"8a[ms] access not permitted"07"8d"8a/
nls11	sc	/"8d"8a"8a[ms] no host specified"8d"8a/
nls12	sc	/"8d"8a"8a[ms] bad host number"07"8d"8a/
BAHMS   EQ      nls12
nls13	sc	/"8d"8a"8a[ms] mud error"07"8d"8a/


                :-------------------------------:
                : PSEUDO-NEEDLE REJECT and      :
                : LOGIN FAILURE (B5) MESSAGES   :
                :-------------------------------:

a0txt	sc	/"8d"8a"8a[ms] ISIS unable to complete request [pnrj]"8d"8a/
a1txt	sc	/"8d"8a"8a[ms] format error [pnrj]"8d"8a/
a2txt	sc	/"8d"8a"8a[ms] bad user name [pnrj]"8d"8a/
a3txt	sc	/"8d"8a"8a[ms] bad MUD [pnrj]"8d"8a/
a4txt	sc	/"8d"8a"8a[ms] system unavailable [pnrj]"8d"8a/
a5txt	sc	/"8d"8a"8a[ms] down-line load or dial-out failure [pnrj]"8d"8a/
a6txt	sc	/"8d"8a"8a[ms] timeout [pnrj]"8d"8a/
a7txt	sc	/"8d"8a"8a[ms] access not permitted [pnrj]"8d"8a/
a8txt	sc	/"8d"8a"8a[ms] out of origination ports [pnrj]"8d"8a/
a9txt	sc	/"8d"8a"8a[ms] try again later [pnrj]"8d"8a/
aAtxt	sc	/"8d"8a"8a[ms] bad requesting-host number [pnrj]"8d"8a/
aBtxt	sc	/"8d"8a"8a[ms] requesting-host not up on requesting node [pnrj]"8d"8a/
UKPRJM	sc	/"8d"8a"8a[ms] LOGON ERR (unknown type) [pnrj]"8d"8a/


                :-------------------------------:
                : ZAP and "OTHER" MESSAGES      :
                :-------------------------------:
 
ZMZAP   sc      /"8d"8a"8a[ms] Host connection lost."8d"8a/
ZMLTO   sc      /"8d"8a"8a[ms] Timeout, Host not responding."8d"8a/
ZMCON   sc      /"8d"8a"8a[ms] Bad configuration. Check the config file."8d"8a"07/
BDCON   eq      ZMCON

DISKEY  sc      /"8d"8a"8a[ms] Keystroke discarded."8d"8a"07/

MSCKT   SC      /"8D"8A[ms] Building host circuit now. Please wait!"8a"8dtype 3 <esc> keys for menu."0a"0d/

AUXIMS  SC      /"8A"8D[ms] Request from auxiliary circuit is not allowed"8a"8d/

        LIST        subttl msstog.sxx includes data structures,equate

: msstog.s33
:  6/15/88  jgh  string terminor hc->bc

: msstog.s32
:  4/06/88  jgh  adjust the ubmax if pass.tpc is used

:MSSTOG.S30
:  9/30/87  JGH  Create V3 R1 from MSSTOG.S20.
:  1/15/87  JSB  Create V2 R1 from MSSTOG.S13.

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::
::    REVISION HISTORY - LATEST FIRST
::  6/15/88   JH  v3 r3, string terminor should bc 0,0
::
::  7/24/87  JGH  V3 R1, PIR's per release report.
::
::  1/15/87  JSB  V2 R1, PIR's and NSR's per release report.
::
:: 10/29/86  JSB  Fix echoing problem. add some structures: cstate,
::                some error counters.
::
:: 10/21/86  JSB  Various comments.
::
:: 10/20/86  JSB  Split out from (JERICSON)MC.R12.
::
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
	subttl data structures (MSSTOG.Sxx)

	drnote(limited release version 3.03 JAN 29 90)

	ra	$0 0

	seg	a.code

	if	\(PC4slot)
CNTRL	  eq	  CNTRL+100		:project code jazz (nsr 481)

PctTbl	  wc	  $2 00000000000001000000000000000000  :0d
	  wc	  $2 00000000000000000000000000000000
	  wc	  $2 00000000000000000000000000000000
	  wc	  $2 00000000000000000000000000000000

	  wc	  $2 00000000000001000000000000000000  :8d
	  wc	  $2 00000000000000000000000000000000
	  wc	  $2 00000000000000000000000000000000
	  wc	  $2 00000000000000000000000000000000
	ei

SEGF    EQ      $00F0000
	nolist


        SEG     A.CODE
CRLFbuf	     bc	2,0d,0a
UPCURbuf     bc	3,5e,0d,0a      :"hat" CR LF.
BKSPbuf	     bc	1,8             :a ctl-H (BS).
BELBUF       bc 1,7             :a ctl-G (BEL).
BKSPAC       BC 3,8,20,8        :BS,SP,BS

SetXlimBuf   bc	2,0b9,9d

ECHOoffBuf   bc	3,0b1,0,0
ECHOonBuf    bc	3,0b1,0,1

DetachBuf	bc	1,9e
ZapBuf		bc	1,9f
ETMBUF          bc      1,0A8
LTMBUF          bc      1,0A9
RedBuf		bc	1,0ab
GreenBuf	bc	1,0aa
::OrangeBuf	bc	1,0ad
YellowBuf	bc	1,0ac
DemOffBuf	bc	1,0a7
DemOnBuf	bc	1,0a6
HangBuf		bc	1,0af

GobblerBuf	bc	1,0a2
GOBBLER		eq	0a2
                bnd     4


        SEG     A.TEXT
        : move variable size table to another seg. leave more space in a.code

rhn     eq      0
        re	(h+1)
	  if	  \(H|rhn|chis)
Hit|rhn|				:hit
y	    eq	    (H|rhn|fhis)
    	    re	    (H|rhn|chis)
              Str|y|
y             eq      y+1
            er
            bc      0,0
	  ei
rhn	  eq	  rhn+1
	er

rhn     eq      0
        re	(h+1)
	  if	  \(H|rhn|cnrs)
NR|rhn|					:NR
y	    eq	    (H|rhn|fnrs)
    	    re	    (H|rhn|cnrs)
              Str|y|
y             eq      y+1
            er
            bc      0,0
	  ei
rhn	  eq	  rhn+1
	er

rhn     eq      0
        re	(h+1)
	  if	  \(H|rhn|cnps)
NP|rhn|					:NP
y	    eq	    (H|rhn|fnps)
    	    re	    (H|rhn|cnps)
              Str|y|
y             eq      y+1
            er
            bc      0,0
	  ei

rhn	  eq	  rhn+1
	er

rhn     eq      0
        re	(h+1)
	  if	  \(H|rhn|ciss)
IS|rhn|					:IS
y	    eq	    (H|rhn|fiss)
    	    re	    (H|rhn|ciss)
              Str|y|
y             eq      y+1
            er
            bc      0,0
	  ei
rhn	  eq	  rhn+1
	er

rhn     eq      0
        re	(h+1)
	  if	  \(H|rhn|ctms)
TM|rhn|					:TM
y	    eq	    (H|rhn|ftms)
    	    re	    (H|rhn|ctms)
              Str|y|
y             eq      y+1
            er
            bc      0,0
	  ei
rhn	  eq	  rhn+1
	er

rhn     eq      0
        re	(h+1)
	  if	  \(H|rhn|czas)
Zap|rhn|				:Zap
y	    eq	    (H|rhn|fzas)
    	    re	    (H|rhn|czas)
              Str|y|
y             eq      y+1
            er
            bc      0,0
	  ei
rhn	  eq	  rhn+1
	er
:----------------
	bnd	4
HitTab
rhn	eq	0
	re	(h+1)
	  if	  \(Hit|rhn|)		:if another set of words is defined
	    wc	    (Hit|rhn|)		:use 'em
	  else				:otherwise
	    wc	    HitSpace		:use the default text string
	  ei
rhn	  eq	  rhn+1
	er

NRtab
rhn	eq	0
	re	(h+1)
	  if	  \(NR|rhn|)
	    wc	    (NR|rhn|)
	  else
	    wc	    NRtxt
	  ei
rhn	  eq	  rhn+1
	er

NPtab
rhn	eq	0
	re	(h+1)
	  if	  \(NP|rhn|)
	    wc	    (NP|rhn|)
	  else
	    wc	    NPtxt
	  ei
rhn	  eq	  rhn+1
	er

IStab
rhn	eq	0
	re	(h+1)
	  if	  \(IS|rhn|)
	    wc	    (IS|rhn|)
	  else
	    wc	    IStxt
	  ei
rhn	  eq	  rhn+1
	er

TMtab
rhn	eq	0
	re	(h+1)
	  if	  \(TM|rhn|)
	    wc	    (TM|rhn|)
	  else
	    wc	    TMtxt
	  ei
rhn	  eq	  rhn+1
	er

Zaptab	
rhn	eq	0
	re	(h+1)
	  if	  \(Zap|rhn|)
	    wc	    (Zap|rhn|)
	  else
	    wc	    ZappedTxt
	  ei
rhn	  eq	  rhn+1
	er


LOtab
rhn	eq	0
	re	(h+1)
	  if	  \(LO|rhn|)
	    wc	    (LO|rhn|)
	  else
	    wc	    0
	  ei
rhn	  eq	  rhn+1
	er

        SEG     A.CODE
        bnd     4
:--------------------------------
: ZARTAB - Reasons for zapping ... 4*zrzn from the UCB is the index to this
: table of pointers.
: Reasons for zapping includes all the possible ways in which the login
: can be aborted.
: For certain Zap Reasons we do not attempt retry.  See NORETS, right after
: the messages.
:
: The Reasons For Zapping include subsets which are the Normal (B4) codes,
: Failure (B5 and pnrj), and "other".  For each subset, you add a base value
: to the specific code to compute a Zap Reason Code.  For example, code 3
: from a Login Failure (B5) is "Bad Mud".  The base symbol for the B5/pnrj
: codes is PNRRZN.  So the Zap Reason Code for "Bad Mud" is PNRRZN+3.

: macro to create Zap-Reason (Other) codes ...

ZRCODE  MACRO (name) [
zc`name    eq     (.-ZARTAB)/4
           wc     zm`name
  ]

ZARTAB  wc      0               :zap reason 0 is reserved for "not an error",
                                :used for normal host logoff, that is, after
                                :login to the host is complete.

: normal logon status message pointers ...

NLSTAB  ws      0
NLSRZN  eq      (NLSTAB-ZARTAB)/4       :first NLS code amongst zap reazns.
      	wc	nls0
	wc	plimsg
	wc	nls2
	wc	nls3
	wc	nls4
	wc	nls5
	wc	nlsill
	wc	nlsill
	wc	nls8
	wc	nls9
	wc	nlsa
	wc	nlsb
	wc	nlsc
	wc	nlsd
	wc	nlse
	wc	nlsf
	wc	nls10
	wc	nls11
	wc	nls12
	wc	nls13
        wc      nlsill
NLSMAX  eq      (.-4-nlstab)/4  :the max NLS code.

: pseudo-needle reject and B5 (Login Failure) message pointers ...

PnRjTab ws      0
pnrrzn  eq      (PNRJTAb-ZARTAB)/4      :first pnrj code in zap reazns.
	wc	a0txt
        wc      a1txt
	wc	a2txt
	wc	a3txt
	wc	a4txt
	wc	a5txt
	wc	a6txt
	wc	a7txt
	wc	a8txt
	wc	a9txt
	wc	aAtxt
	wc	aBtxt
                        :the previous is the highest real one.
	wc	UKPRJM                   :this is the "unknown-type' msg.

pnRjMax eq	((.-pnRjTab)/4)-1	:the highest VALID pnRj type.

: Other Zap Reason pointers ...
ZOTRZN  eq      (.-ZARTAB)/4            :the first Zap-Other reason code.
        ZRCODE(LTO)                     :Login Timeout.
        ZRCODE(ZAP)                     :  "circuit zapped".
        ZRCODE(CON)                     :bad configuration

ZARMAX  eq      (.-4-ZARTAB)/4          :the max Zap Reason.

        SEG     A.CODE
: NORETS bit array, one bit for every Zap Reason Code.  Bit is 1 if we
: should not retry upon this type of failure...

        DBIT(nlsrzn+9)
        DBIT(nlsrzn+$00f)
        DBIT(pnrrzn+1)
        DBIT(pnrrzn+2)
        DBIT(pnrrzn+3)
        DBIT(pnrrzn+4)
        DBIT(pnrrzn+7)
        DBIT(pnrrzn+9)
        DBIT(pnrrzn+$00a)
        DBIT(pnrrzn+$00b)
        DBIT(zotrzn+2)          :bad configuration
GENDB(NORETS,zarmax+1)


        SEG     A.TEXT
        bnd     4
        : move this configurable stuff to a new seg 04/08/88

:----------------
: here's the per-host, per-command rotor entry availability bit arrays and
: the rotor tables themselves.

: First, a macro to generate one rotor list ..

CMDROT  MACRO  [
	      seg     a.data
H|rhn||cmd|EntryAvailabilityBitArray hs (H|rhn||cmd|CountOfElements+0f)/10
	      seg     a.TEXT
	      bnd     20
H|rhn||cmd|BaseOfRotorEntrys eq (.)
z	      eq      (H|rhn||cmd|FirstRotorElementStringNumber)
	      re      (H|rhn||cmd|CountOfElements)
q	        Re|z|
                if      .ge.(.,q+$020)
                  REMARK %*** ROTOR ENTRY Re|z| TOO BIG, limit 32 chars!
                  REMARK %*** This log-in entry will not work.%
                ei
	        org     q+$01f          :$01f+1 = $020 bytes per rotor entry.
                bc      0               :guarantee zero when string too long.
z	        eq      z+1
	      er
   ]


rhn	eq	0
	re	(h+1)
cmd	  eq	  10			:STARTS AT 10!!!
	  re	  (H|rhn|Ccnt)
	    if	    \(H|rhn||cmd|CountOfElements)
              CMDROT                        :gen rotor list for the command.
	    ei
cmd	    eq	    cmd+1
	  er
rhn	  eq	  rhn+1
	er


: here's the byte array to tell 8bit tickler or not
RHN     EQ      0
TKL8
        RE      (H+1)
          IF \TKL8|RHN|
            BC  TKL8|RHN|
          ELSE
            BC  0
          EI
RHN       EQ    RHN+1
        ER

: Here's the byte array to indicate which host has 8bit message in menu
: state.( welcome,select,menu )

RHN     EQ      0
MENU8   
        RE      (H+1)
          IF \MENU8|RHN|
            BC  MENU8|RHN|
          ELSE
            BC  0
          EI
RHN       EQ    RHN+1
        ER

TKLNLE  EQ      $A  80+1        :extra one for the length byte(SC format)
: Here's the table of M.A.'s username for the tickler process

        BND     2
MAIDX
        RE      (H+1)
          HC  -1
        ER

MATTL   EQ      0
RHN     EQ      0
MANAME  
        RE      (H+1)
          IF \TKL.|RHN|
            M.A.|RHN|
QZ          EQ  .
            ORG MAIDX+RHN*2
                HC      MATTL
            ORG QZ
MATTL       EQ  MATTL+UNAMEL+1
          EI
RHN       EQ    RHN+1
        ER
        KILL    QZ

: here's the half word array to store the pointer of where each host's
: tickler message begins.
TKLTTL  EQ      0
RHN     EQ      0
        BND     2
TKLPNT
        RE      (H+1)
          IF \TKL.|RHN|
            HC  TKLTTL
TKLTTL      EQ  TKLN|RHN|*TKLNLE+1+TKLTTL   :the offset from the begining
          ELSE
            HC  -1
          EI
RHN       EQ    RHN+1
        ER

: here's the halfword array to store the size ,in bytes of each tickle. 
RHN     EQ      0
        BND     2
TKLSIZ
        RE      (H+1)
          IF \TKLN|RHN|
            HC  TKLN|RHN|*TKLNLE+1      :+1 for terminator
          ELSE
            HC  0
          EI
RHN       EQ    RHN+1
        ER

: here's the half word array to store the tickler timout
RHN     EQ      0
TKLHTO
        RE      (H+1)
          IF    \THTO|RHN|
            HC  THTO|RHN|
          ELSE
            HC  0
          EI
RHN       EQ    RHN+1        
        ER

: here's the bit array to indicate which menu hosts sort of would like the
: user to type in a password

        SEG     A.CODE
rhn	eq	0
shifty	eq	$2 1000000000000000
Accum	eq	0
	re	(h+1)
	  if	  \(H|rhn|pu)		:if "host RHN password used" DEFINED
Accum	    eq	    Accum!shifty  
	  ei
shifty	  eq	  shifty^(-1)		:shift that "1" right 1 position
rhn	  eq	  rhn+1
	er
hpuBA	hc	Accum			:host password used bit array

        if      .GT.(h,$a15)
          remark %*** MORE THAN 16 HOSTS NOT SUPPORTED!  USE LESS HOSTS!
          remark %*** BAD ASSEMBLY.%
        ei


: auto select 

rhn	eq	0
shifty	eq	$2 1000000000000000
Accum	eq	0
	re	(h+1)
	  if	  \(AS|rhn|)		:if "auto select |rhn|" DEFINED
Accum	    eq	    Accum!shifty  
	  ei
shifty	  eq	  shifty^(-1)		:shift that "1" right 1 position
rhn	  eq	  rhn+1
	er
aselBA	hc	Accum			:auto select

: auto logoff

rhn	eq	0
shifty	eq	$2 1000000000000000
Accum	eq	0
	re	(h+1)
	  if	  \(AL|rhn|)		:if "auto logoff |rhn|" DEFINED
Accum	    eq	    Accum!shifty  
	  ei
shifty	  eq	  shifty^(-1)		:shift that "1" right 1 position
rhn	  eq	  rhn+1
	er
alogBA	hc	Accum			:auto logoff

: auto redisplay of menu bit array defined here

rhn	eq	0
shifty	eq	$2 1000000000000000
Accum	eq	0
	re	(h+1)
	  if	  \(AR|rhn|)		:if "auto redisplay |rhn|" DEFINED
Accum	    eq	    Accum!shifty  
	  ei
shifty	  eq	  shifty^(-1)		:shift that "1" right 1 position
rhn	  eq	  rhn+1
	er
arBA	hc	Accum			:auto redisplay


: no pause after welcome bit array defined here

rhn	eq	0
shifty	eq	$2 1000000000000000
Accum	eq	0
	re	(h+1)
	  if	  \(NPAW|rhn|)		:if "NPAW|rhn|" DEFINED
Accum	    eq	    Accum!shifty  
	  ei
shifty	  eq	  shifty^(-1)		:shift that "1" right 1 position
rhn	  eq	  rhn+1
	er
npawBA	hc	Accum			:no pause after welcome


: here's the status and key table used during slot initialization

sAndKtab
rhn	eq	0
	re	(h+1)
	  if	  \(hKey|rhn|)		:if multi-based host set-up
	    bc	    4			:say "there's a key"
	    bc	    (hKey|rhn|)		:this is the key
	  else
	    bc	    0
	    bc	    0
	  ei
rhn	  eq	  rhn+1
	er


:--------
: HOSMES(MESS,FST,CNT) macro - generate out the n instances of
:   one kind of message, which is different for each host.
: MESS|host| will be the label of the message for each |host|.
: FST and CNT are the names for the first String Number and count of strings,
: and are used to form H|host|FST and H|host|CNT, the actual names.

HOSMES  macro(ME,fmes,cmes)  [
rhn     eq      0
        re	(h+1)
	  if	  \(H|rhn|cmes)
ME`|rhn|					:menu
y	    eq      (H|rhn|fmes)
    	    re	    (H|rhn|cmes)
              Str|y|
y             eq      y+1
            er
            bc      0,0
	  ei
rhn	  eq	  rhn+1
	er
  ]

        SEG     A.TEXT
        HOSMES(SE,fses,cses)
        HOSMES(ME,fmes,cmes)                    :menus.
        HOSMES(HTO,fhto,chto)                   :host timeout messages.
        HOSMES(LTO,flto,clto)                   :login timeout messages.


rhn     eq      0
        re	(h+1)
	  if	  \(H|rhn|ctis)
TI|rhn|					:menu timeout.
y           eq      (H|rhn|ftis)
            re      (H|rhn|ctis)
              Str|y|
y             eq      y+1
            er  
            bc      0,0
	  ei
rhn	  eq	  rhn+1
	er


rhn     eq      0
        re	(h+1)
	  if	  \(H|rhn|cwes)
WE|rhn|					:welcome
y           eq      (H|rhn|fwes)
            re      (H|rhn|cwes)
              Str|y|
y             eq      y+1
            er  
            bc      0,0
	  ei
rhn	  eq	  rhn+1
	er

rhn     eq      0
        re	(h+1)
	  if	  \(H|rhn|clos)
LO|rhn|					:logoff
y           eq      (H|rhn|flos)
            re      (H|rhn|clos)
              Str|y|
y             eq      y+1
            er  
            bc      0,0
	  ei
rhn	  eq	  rhn+1
	er

	
rhn     eq      0
        re	(h+1)
	  if	  \(H|rhn|cpas)
PA|rhn|					:password
y           eq      (H|rhn|fpas)
            re      (H|rhn|cpas)
              Str|y|
y             eq      y+1
            er  
            bc      0,0
	  ei
rhn	  eq	  rhn+1
	er


        SEG     A.CODE
:generate version/host message

 	hc	lMsgVer
MsgVer	eq	(.)-1
	ac	~Version ~
	bc	0b0+Version
	ac	~.~
	bc	0b0+RevLev/8
	bc	0b0+RevLev-((RevLev)/8)*8)
	ac	~, Host ~
lMsgVer	eq	(.)-MsgVer-1


:	compute HrhnD1 to HrhnD6 for host number
:	example :   0  0  0  8  3  5 
:		   D1 D2 D3 D4 D5 D6

Digits  eq      6
rhn	eq	0
	re	(h+1)			:find decimal #s for each host
H|rhn|fsd eq	  1
d	  eq	  (Digits)
nn	  eq	  (HOST|rhn|)
	  re	  (Digits)		:'could be up to "Digits" long
H|rhn|D|d|  eq	    (nn-(nn/0a)*0a)
nn	    eq	    (nn/0a)
 	    if	    (H|rhn|D|d|)
H|rhn|fsd     eq      d
	    ei
d	    eq	    d-1
	  er
rhn	  eq	  rhn+1
	er

: put printable characters into memory sc style

rhn	eq	0
	re	(h+1)	
H|rhn|txt				:   |
y	  eq	  (H|rhn|fsd)		:123456
	  bc	  Digits-y+1		:000835  6-4+1=3
	  re	  Digits-y+1
	    bc 	    (H|rhn|D|y|)+0b0
y	    eq	    y+1
	  er
rhn	  eq	  rhn+1
	er

: make a table of the addresses of these little strings

	bnd	4
HnumTxtTab
rhn	eq	0
	re	(h+1)
	  wc	  (H|rhn|Txt)
rhn	  eq	  rhn+1
	er

: make a table of the timeout ticks for each host
: use default if none specified for this host.  Round up to the
: timeout interval and give him an extra tick besides because the
: timeout routine may run immediately after a timeout begins and so can
: count down the first whole tick in virtually zero time.

tixTab  bs      0
rhn	eq	0
	re	(h+1)
	  if	  \MTO|rhn|
q	    eq	    (MTO|rhn|+TOINAC-1)/TOINAC+1  :turn seconds into ticks.
	  else
q	    eq	    (MTODef+TOINAC-1)/TOINAC+1    :turn seconds into ticks.
	  ei
          if      q&$00FFFFFF00         :if that's not a one-byte value,
            REMARK % *** A MENU TIMEOUT IS OUT OF RANGE, MUST BE 0 TO 
            NUMBER $a255*TOINAC
            REMARK  second, in decimal.%
          ei
          if .le.(q,1)          :if q = 1 means no logtimeout readjust it
q           eq  0
          ei
          bc      q
rhn	  eq	  rhn+1
	er

: define the quota for each host as nUsers if quota was not specified
: make a table of the quotas

	bnd	2
qtaTab
rhn     eq      0
        re	(h+1)
	  if	  \(qta|rhn|)
	  else
qta|rhn|    eq	    nUsers
	  ei
	  hc	  (qta|rhn|)
Hprt|rhn| eq	  (qta|rhn|)
rhn	  eq	  rhn+1
	er

	seg	a.data

RemainingQuotaTab hs (h+1)

             BC 0                       :force B7 starts at halfowrd boundary
ACCBUF       bc 6,0B7,0,0,0,0,0         :B7 message

:----------------

ServerPortsRemaining hs 1
:------------------

	seg	a.code

     if      CostMacroInvoked	:<----------<<<

MnCsTab
:------
rhn	eq	0
	re	(h+1)
	  if	  \(MnCs|rhn|)
	  else
MnCs|rhn|   eq	    0
	  ei
	  bc	  (MnCs|rhn|)
rhn	  eq	  rhn+1
	er

MxCsTab
:------
rhn	eq	0
	re	(h+1)
	  if	  \(MxCs|rhn|)
	  else
MxCs|rhn|   eq	    0			:host free
	  ei
	  bc	  (MxCs|rhn|)
rhn	  eq	  rhn+1
	er

HiAvTab
:------
rhn	eq	0
	re	(h+1)
	  if	  \(HiAv|rhn|)		:defined
	    if	    (HiAv|rhn|)		:positive
	      if      .GT.((HiAv|rhn|),(qta|rhn|))
	        Error(HIAV paramater for host ,1)
	        number (Host|rhn|)$a
	        ErrLin( exceeded quota)
HiAv|rhn|       eq      ((qta|rhn|)*3)/4
	      ei
	    else 			:negative (or 0)
HiAv|rhn|     eq      ((qta|rhn|)*3)/4
	    ei
	  else				:not defined
HiAv|rhn|   eq	    0
	  ei
	  hc	  (HiAv|rhn|)
rhn	  eq	  rhn+1
	er

LoAvTab
:------
rhn	eq	0
	re	(h+1)
	  if	  \(LoAv|rhn|)
	    if	    (LoAv|rhn|)+2
	      if      .GT.((LoAv|rhn|),(HiAv|rhn|))
	        Error(LOAV paramater for host ,1)
	        number (Host|rhn|)$a
	        ErrLin( was greater than HIAV paramater,0)
	      ei
	    else
LoAv|rhn|     eq    (qta|rhn|)/4	:default, if hostcost option used
	    ei
	  else
LoAv|rhn|   eq	    0		:default, if hostcost option not used
	  ei
	  hc	  (LoAv|rhn|)
rhn	  eq	  rhn+1
	er

nociTab		:number of cost increments
:------
rhn	eq	0
	re	(h+1)
	  if	  \(noci|rhn|)
	  else
noci|rhn|   eq	    0
	  ei
	  if	  .GT.((noci|rhn|),2)&.EQ.((LoAv|rhn|),(HiAv|rhn|))
	    Error(Steps were specified for calculating,1)
	    ErrLin(cost of host ,1)
	    number (Host|rhn|)$a
	    ErrLin( but LOAV and HIAV paramaters were equal,1)
	  ei

y	  eq	  (HiAv|rhn|)-(LoAv|rhn|)+2
	  if	  .GT.((noci|rhn|),y)
	    Error(NOCI paramater for host,1)
	    number (Host|rhn|)$a
	    ErrLin(exceeds the difference between HIAV and LOAV)
	    ErrEnd( paramaters)
	  ei

	  bc	  (noci|rhn|)
rhn	  eq	  rhn+1
	er

	bnd	2
TableFinder
:----------
y	eq	0
rhn	eq	0
	re	(h+1)
	  hc	  y
	  if	  \(MxCi|rhn|)
	  else
MxCi|rhn|   eq	    0
	  ei
y	  eq	  y+(MxCi|rhn|)
rhn	  eq	  rhn+1
	er

	seg	a.data

noppciTab hs h+1			:number of paths per cost interval
:--------

CostTable
:--------
rhn	eq	0
	re	(h+1)
	  bs	  (MxCi|rhn|)
rhn	  eq	  rhn+1
	er

CostAsSupBelievesIt bs (h+1)
:---------------

CostInReality bs (h+1)
:------------

	seg	a.code

      ei				:end of conditional host cost stuff

: PORT AVAILABILITY LIMITS TABLES
:--------------------------------

	bnd	2
aaTab
:----
rhn	eq	0
	re	(h+1)
	  if	  \(aa|rhn|)
	  else
aa|rhn|	    eq	    1
	  ei
	  if	  .LE.((qta|rhn|),1)
aa|rhn|     eq	    0
	  ei
	  hc	  (aa|rhn|)
rhn	  eq	  rhn+1
	er

ubTab
:----
rhn	eq	0
	re	(h+1)
	  if	  \(ub|rhn|)
	  else
ub|rhn|	    eq	    1
	  ei
	  if	  .EQ.((qta|rhn|),0)
ub|rhn|     eq	    1
	  else
	    if	    .GE.((aa|rhn|),(qta|rhn|))
	      Error(AA paramater for host ,1)
	      number (Host|rhn|)$a
	      ErrLin( must be less than quota,1)	:??
	    ei
	  ei
	  hc	  (ub|rhn|)
rhn	  eq	  rhn+1
	er

	seg	a.data

HpaInReality       hs 1
:-----------

HpaAsSupBelievesIt hs 1
:-----------------

	seg	a.code

                :mapping the hour from 00~23 to 00~11 AM/PM form
HRMAP   XC      313230313032303330343035303630373038303931303131
        XC      313230313032303330343035303630373038303931303131


          IF \PWLEN
          ELSE
PWLEN       EQ    $A16    :10H OR 4 WORD
          EI

PWENTL  EQ      PWLEN/2*2+2     :length per entry, halfword boundary


        SEG     A.DATA
	list

	subttl equates (MSSTOG.Sxx)

rTsatSideR10 eq	r10
rIncomingR1  eq	r1
rMsgTypeR2  eq	r2
rHostSideR6 eq	r6

rPWindexR6  eq	r6	:holds password index
rUbufInxR7  eq	r7	:holds ubufer index

CR	eq	0d
LF	eq	0a

Escape	eq	1b
Rubout	eq	7f
ctlA	eq	1
CTLD    EQ      4
ctlH	eq	8
ctlQ	eq	11
Tab	eq	9

Semicolon eq	3b
Exclaim   eq	21
Question  eq	3f

ASC0    EQ      30
ASCUPY  EQ      59
ASCLWY  EQ      79
ASCUPN  EQ      4E
ASCLWN  EQ      6E

: The tickler command...
TCNEW   EQ      31
TCDIS   EQ      32
TCSCH   EQ      33
TCQUIT  EQ      34

: define Flags and data field
INVAL   EQ      0
VALID   EQ      1
ABORT   EQ      2

TKHOUR  EQ      0
TKMIN   EQ      2
SCHTMH  EQ      0               :display schedule as the form HH:MM P.M.
SCHTMM  EQ      3
SCHMRK  EQ      6

: other constants for tickelr
MXTIDX  EQ      4
MXHOUR  EQ      $A 24
MXMIN   EQ      $A 60
NOON    EQ      $A 60*12
P.M     EQ      50
A.M     EQ      41

: B7 message offset
B7TYPE  EQ      3
B7INV   EQ      3
ACCTYP  EQ      $00EA

OPPWLE  EQ      4               :the length of psw opcode 

nGrp	   eq	(NPORT+0f)/10	:compute number of groups
nTrmCh	   eq	$a 20		:(14h)

        IF \TPC|h|
TTLLTH    EQ    TTLLTH+1
        EI

        IF .GT.(TTLLTH+4+ROTMAX,$0100)
BADCON    EQ TTLLTH+4+ROTMAX    :SET THE ERROR FLAG          
          REMARK %*** TOTAL LOGIN STRINGS REQUIRES  
          NUMBER $A BADCON
          REMARK  BYTES. 
          REMARK %*** IN THE LAST COMMAND OF THE 
          NUMBER $A H+1
          REMARK TH HOST. MAXIMUM IS 252 BYTES.
          REMARK %*** THIS REQUEST IS IGNORED. LOGIN WILL NOT WORK. ***%
        ELSE
UBMAX     eq  .MAX.(TTLLTH+4+ROTMAX,UBMAX)   :compare with the requirement
                                :of the last command plus rotor string and 4
                                :bytes of overhead - first two bytes unused
                                :and last two bytes for terminator'00''00'
        EI

        :The following code is to figure out how many typeahead characters
        :is allowed and the required ubufer size.

        IF \BADCON              :WE HAVE BAD CONFIGURATION
UBUFSIZCON      EQ  .MIN.(UBMAX,$0100)
        ELSE
          IF \UBUFSIZCON
            IF .GT.(UBUFSIZCON,$0100)   :ubufer size is greater than 256 bytes
              REMARK %*** BAD CONFIGURATION ***
              REMARK %*** THE MAX UBUFER SIZE ALLOWED IS 256 BYTES ***
              REMARK %*** UBUFER SIZE IS ASSIGNED TO 256 BYTES.***%
UBUFSIZCON    EQ  $0100
            ELSE
              IF .LT.(UBUFSIZCON,UBMAX)
                REMARK %*** WARNING: BIGGER UBUFFER IS REQUIRED ACCORDING 
                REMARK TO THE CONFIGURATION. ***%
                REMARK %***          NEW VALUE IS ASSIGNED        ***%
                REMARK %--- THE CONFIGURATION REQUIRES UBUFER SIZE AT LEAST 
                NUMBER $A UBMAX
                REMARK  BYTES. (UBMAX)---%
              EI
UBUFSIZCON    EQ  .MAX.(UBUFSIZCON,UBMAX)
            EI
          ELSE
UBUFSIZCON  EQ  UBMAX
          EI

          IF \TPAHD
TPAHD       EQ  .MAX.(PWLEN+1,TPAHD)
            REMARK %***TYPEAHEAD ENLARGED TO 
            NUMBER $A TPAHD
            REMARK BYTES ***%
          ELSE
TPAHD       EQ  .MAX.(PWLEN+1,$020)  :to prevent user struck in type ahead psw
          EI

          IF .GT.(UBUFSIZCON+TPAHD,$0100)
TPAHD       EQ  $0100-UBUFSIZCON
            REMARK %*** TYPEAHEAD CAUSES THE UBUFER OVERFLOW.***
            REMARK %*** ONLY 
            NUMBER $A .MAX.(TPAHD,0)
            REMARK   BYTES ARE ALLOWED WITH THIS TYM FILE***%
            REMARK *** MSV LOGIN MAY NOT WORK ***%
          EI

UBUFSIZCON    EQ  TPAHD+UBUFSIZCON
          REMARK % UBUFER SIZE IS 
          NUMBER $A UBUFSIZCON
          REMARK  BYTES FOR THIS CONFIGURATION.%
        EI

            
:	crash codes:	meaning		 	cfrom value

bumType	eq	0f0	illegal ISIS msg type	MSG TYPE
bumPort	eq	0f1	ISIS port too big	ISIS PORT NUMBER
bumItype eq	0f2	illegal Intra-Node msg	INTRA-NODE MSG TYPE

BREAKdetected		eq	0ae
PsuedoNeedle		eq	0b2

	seg	a.data

	bnd	4
clrFrom  ws   0       :Beginning of area which initialization zeroes out.

TKLTIC  HS      H+1     :Ticks of next tickler's schedule
TKLSTM  HS      H+1     :time difference in mins between schedule and now
TKLSCH  WS      H+1     :Fullword for each host,contains ascii HHMM
MALGIN  BS      (H+8)/8 :the bit array to exclude the MA access

        SEG     A.BDAT
        : the reason put these into seg a.bdat is to leave more space
        : in a.data seg. 
        bnd     4
TKLMSC  BS      TKLTTL  :the place to stroe the current tickler
TKLMSS  BS      TKLTTL  :where to store the next tickler

        SEG     A.DATA
CURTKL  HS      NGRP    :Ture when a tickler is currently displayed
NXTTKL  HS      NGRP    :True when next tickler is waiting

PortToUCBmap hs	NPORT	:UCB associated with any given port, true pointer
                        :  in seg 0. Used as Key for the PsNeedle request!
ToArray	   Bs	NPORT	:Menu-state inactivity time out, how many ticks he
        	        :  has left.  =0 if not being timed out.
cstate     bs   nport   :current state of the circuit (See CMPOI for values).

:if the TID is O, the SAT reflects the ETM/LTM.
: the following 2 array are for keeping track of the etm/ltm send by msv.
MSVETM     BS   NPORT   :add 1 when ETM out from MSV
MSVLTM     BS   NPORT   :add 1 when LTM out from MSV 

LogOnPorts hs	nGrp	:[Hostside] causes logon character sender to run.
LGWAIT     hs   nGrp    :[Tsatside] Logon sender is in Wait State.
handBA	   hs	nGrp	:so logon character sender waits for a char initially
doingPW	   hs	nGrp	:True when the user is entering a Password.

UCBinUse   hs	nGrp	:actually, bit=1 when UCB is free.

dem	   hs   nGrp	:for Sat: we have gotten EDEM from Sat (i.e. Sat
                        :    is not echoing).
                        :for Host: we have sent EDEM to Host, it should echo.
tymsat	   hs	nGrp	:This port is a Sat.
green	   hs	nGrp	:for Sat: we are holding green ball from Sat.
                        :for Host: we have sent green ball to host.
nbo	   hs	nGrp	:No green or red Ball Out, used for Host only.
                        :   For host, MUST be set if GREEN is set.
                        :   NBO=0 and GREEN=0 means Red Ball is out to host.
                        :   See the ISIS RB and GB handlers for more info.
HYBOUT      HS   NGRP   :yellow ball out from host
                        :  1-means yellow ball out o means no.

ToISIS	   hs	nGrp	:ports we can send data on (0 if we got backp.)
FrISIS	   hs	nGrp	:1 means we have not backp'd the port.

doingLogon hs	nGrp	:Tymnet Login in progress (no B6 yet).u
MAUSER     HS   NGRP    :bit array to indicate user is MA.

ETMOUT     HS   NGRP    :1 means etm out to the SAT 0 means none

: tymsat parameters

ECHO	   hs	nGrp	:0 ECHO. last Set Echo value we got from the circuit.
                        :  Initialized to 1 for Sat, to 0 for Host.
                        :  Note that Echo=0 for Sat DOES NOT mean we are not
                        :  supposed to echo.  DEM is what tells us to echo,
                        :  and for Password we simply don't call the echoing.

      : Terminal Parameters (B1 message codes) ...
EctlI	   hs	nGrp	:1 echo <CTL>I
Elfcr	   hs	nGrp	:2 echo <LF> with <CR>
Ecrlf	   hs	nGrp	:3 echo <CR> with <LF>
CRde	   hs	nGrp	:4 <CR> delay
Brate	   hs	NPORT	:5 and 6 input and output baud rates
Parity	   hs	nGrp	:7 bit for parity
HafDux	   hs	nGrp	:8 half duplex ports
pAB	   hs	NPORT	:9 and 10 parameters A,B
pCD	   hs	NPORT	:11 and 15 parameters C,D
XonEna	   hs	nGrp	:12 X on enable
EctlH	   hs	nGrp	:13 echo <CTL>H
YonEna	   hs	nGrp	:14 reverse X on enable
KATA	   hs	nGrp	:16 KATAKANA
T.Brk	   hs	nGrp	:17 terminate output on break
Ec.Esc	   hs	nGrp	:18 echo <ESCAPE>
Q.Mod	   hs	nGrp	:19 'Q'-mode, DEM on <CR>

clrTo    ws   0     :End of area which init clears.

scratch	ws	1               :general use.  Calls can destroy it.
scra2   ws      1               :another ditto.
ZFSV9   ws      1               :scratch for ZHOST/FOGHOS.
ZFSV11  ws      1
SHIPR5  ws      1               :scratch for SHIPTOsat.
SHIPR6  WS      1
TKSCR1  WS      1               :scratch for tickler
TKSCR2  WS      1
TKSCR3  WS      1
WAKSC1  WS      1
WAKSC2  WS      1               :used by WAKELG to save reg
SAVEOX  hs      1               :save the current oring message index.
STMASK  HS      1               :mask for this string used by ocsms/obsms

: modifyable messages

NLCbuf	bc	(1+1),0b3,00	:NORMAL LOGON CHARACTER message

QTPbuf	bc	(1+1)		:QUERY TERMINAL PARAMETERS
	bc	0b0
QTPpar	bc	00

STPbuf	bc	(1+1+1)		:SET TERMINAL PARAMETERS
	bc	0b1
STPpar	bc	00
STPval	bc	00

	bnd	2
	bs	1
PnReqBuf bc	(1+1+2+2+2+1)	:REQUEST NORMAL CIRCUIT PSUEDO-NEEDLE
PnTyp	bc	07
PnKey	bc	00		:(dispatcher's key)
PnLkey	hc	1111		:local key
PnDial	hc	1111		:dialect (iix (80), req ext status (40))
PnHost	hc	1111		:originating host
PnNID	bc	11		:NID


	bnd	2
	bs	1
ErhsBuf	bc	(1+1+2+2+2+1+1+1+1)
	bc	10		:10h = EXTENDED REPORT HOST STATUS
	bc	00		:key (set by dispatcher)
ErhsHst	hc	1111		:host number
ErhsPrt	hc	1111		:number of ports
ErhsRhn	hc	1111		:relative host number
ErhsSta	bc	11		:host status
ErhsKey	bc	11		:host key
        bc      00         	:IIX quotient
        bc      ProdID  	:product I.D.

	bnd	2
	bs	1

hcoBuf	bc	(1+1+2+2+2)
	bc	0c		:0c = REPORT HOST COST
	bc	00		:key (set by dispatcher)
hcoHst	hc	1111		:host number
hcoCst	hc	1111		:HOST COST
hcoRhn	hc	1111 		:relative host number

	bnd	2
	bs	1

hpaBuf	bc	(1+1+2+2+2)
	bc	0a		:0a = REPORT HOST PORT AVAILABILITY
	bc	00		:key (set by dispatcher)
hpaHst	hc	1111		:host number
hpaPrt	hc	1111		:NUMBER OF PORTS
hpaRhn	hc	1111 		:relative host number

: little "where" message

	hc	sz
where	eq	(.)-1
	ac	~"8d"8a"8a~
	ac	~ms ver ~
	bc	0b0+Version
	ac	~.~
	if	.eq.((RevLev/8),0)
	  bc	  80+6f
	else
	  bc	  0b0+RevLev/8
	ei
	if	.eq.((RevLev-((RevLev)/8)*8),0)
	  bc	  80+6f
	else
	  bc	  0b0+RevLev-((RevLev)/8)*8)
	ei
	ac	~  kh ~
khnum	bs	4
	ac	~  n ~
nodenum	bs	5
	ac	~  s ~
slotnum	bs	1
	ac	~  h ~
sz	eq	(.)-where-1

	hc	sz2
rhtxt	eq	(.)-1
	ac	~  rh ~
rhnum	bs	1
	ac	~"8d"8a~
sz2	eq	(.)-rhtxt-1

	hc	sz3
whenTxt eq	(.)-1
	ac	~"8d"8Athis menu server was assembled ~
whenA	ac	~1234567890123~
	ac	~, fired up ~
whenF	ac	~1234567890123~
	ac	~"8d"8a~
sz3	eq	(.)-whenTxt-1

	hc	sz4
itxt	eq	(.)-1
	ac	~"8a"8dI-file notes:"8a"8d~
	inote
	ac	~"8d"8a~
sz4	eq	(.)-itxt-1

	hc	sz5
rtxt	eq	(.)-1
	ac	~"8a"8dR-file notes:"8a"8d~
	rnote
	ac	~"8d"8a~
sz5	eq	(.)-rtxt-1

	if	\ttag
	  hc	  sz6
ttxt	  eq	  (.)-1
	  ac	  ~"8a"8dT-file notes:"8a"8d~
	  tnote
	  ac	  ~"8a"8d~
sz6	  eq	  (.)-ttxt-1
	  gl	  ttxt			:<----<<
	ei

	gl	whenTxt,itxt,rtxt	:<----<<

: greeting message buffer

GreetBuf
	bc	0	
	bs	$a 156	

GrBufEnd eq	(.)-2


:- - - - - - - - - - - - - - - - - - - - - - - - -
: ERROR COUNTERS

ERRCTS  WS      0               :Beginning of all Error Counters.

    : Scalar Counters ...
ERRHGB  hc      0               :Unexpected green ball from host,
ERRHGP  hc      0               :  - last port where it happened.
ERRBGB  hc      0               :got green from Sat while Red still out.
ERRBGP  hc      0               :  - last port where it happened.
ERHBLK  hc      0               :count Blackballs from host.
ERHGRY  hc      0               :count Greyballs from host.
ERTBLK  hc      0               :count Blackballs from terminal.
ERTGRY  hc      0               :count Greyballs from terminal.

ERHCON  HC      0               :count for error set up in ubufer
ERETM   HC      0               :count for extra ETM or ETM fm sat that
                                :might cause the 8bit support doesn't work
ERLTM   HC      0               :count of extra LTM or LTM from sat
ECEND   WS      0               :End of all Error Counters.


: USER CONTROL BLOCK (UCB) layout
	   bnd	4
UCBbase   			:the ADDRESS of the FIRST user block

	   org	0
        :For saving Sat Process regs.  See SVSATL/LDSATL macroes below ...
saveR6	   Ws	1               
saveR7	   Ws	1
saveR9	   Ws	1

RTNAD1     WS   1               :these return address is for save the login
RTNAD2     WS   1               :routine return address (SNDLGC,INSPW..)
RTNAD3     WS   1
RTNAD4     WS   1

INVOCE     WS   1               :invoice number for session between user 
                                : and MSV
TsatDataHandler Ws 1		:FW address to jump to on data from tymsat side
HSHAND     ws   1               :FW address to jump to on data from host side
UCMPTR     ws   1               :remember pointer to Login Code.
HTOLAC     ws   1               :Time (SLOWC) when the last activity happened.
UHTIVL     hs   1               :length in seconds of the current Host Timeout
                                :  interval, signed number.  0 for no timeout.
ULTO       hs   1               :Current Login-Timeout value.
ULCLK      hs   1               :Countdown for the login timeout.  GT 0 if
                                :  still counting, = seconds to go.  If already
                                :  0, no timeout.
UNRT       hs   1               :how many retries to do.
UTRIES     hs   1               :how many times we tried this login.

userName   hs	(unamel+2)/2    :username and terminator 00 byte (without
                                :  CR or semi).

TsatSide   hs	1		:port # attached to TYMSAT
hostSide   hs	1		:port # hooked to HOST 
YBtimer	   hs	2
IIX	   Hs	1

BAbase     hs	1		:which rotor bit array
BAbit	   hs	1		:which bit of that bit array (to release)

TcNotInYetBA hs	(nTrmCh+0F)/(8+8)
origTcForTsatSide Bs nTrmCh

zrzn       bs   1               :Zap reason when circuit is lost.
                                :  Zero is for a normal host logout.  We must
                                :  preset a zero after we complete the Host
                                :  Login stage.  Otherwise, ZRZN is an error
                                :  code and message index.  See ZARTAB.


CURPW      HS   1               :current psw index (offset)
CURCMD     BS   1               :current match command
loginEmptyIndex	bs 1		:Where to take characters out from ubufer.
matchIndex bs	1               :index in a partially matched match string.
LGFILL     bs   1		:Where to store what user types into UBUFER.
STYPEA     bs   1
PWFROM     BS   1               :byte pointer to the rest psw in savetype ahead
PWPOSI     BS   1               :byte pointer to current psw opcode

NID	   bs	1               :also called CCT - Terminal Characteristic.
TPC	   bs	1               :Throughput Class.

relativeHost bs 1		:0, 1, 2 etc. corresponds to host # in needle

MCHOLD     bs   MHSIZE          :the buffer holds the matched input chars

           BND  2
ubufer	   hs	(UbufSizCon+1)/2  :for logon strings and buf
                                : when in pass thru.
strSiz	   hs	1		:used by "Str2Buf" routine
fMsgPr	   eq	1000		:set if greeting message not sent
flagBits   hs	1		:FLAGS INDICATING CONDITION OF tymsat side

        : the password array need to be writable
        BND     2
PWARRY  EQ      .-PWENTL        :Password array to store the password
                                :one entry below the real one, so don't
                                :have to adjust the index
        RE  PS.IDX
           HS   PWENTL/2        :half word bnd entry 
        ER

	   bnd	4
UCBlength  eq   (.)


: SVSATL, LDSATL - macroes to save and restore Sat Process Linkage regs...

SVSATL  MACRO  [
	st	rAddOfEntryR5,(TsatDataHandler),rUCB
	st	r6,(saveR6),rUCB
	st	r7,(saveR7),rUCB
	st	r9,(saveR9),rUCB
  ]

LDSATL  MACRO  [
	l	r6,(saveR6),rUCB		 
	l	r7,(saveR7),rUCB		
	l	r9,(saveR9),rUCB		
	l	rAddOfEntryR5,(TsatDataHandler),rUCB
  ]


	org	UCBbase
	nolist

	re	nUsers
	  org	  (.)+UCBlength
	er

	list

pastTheEnd eq	(.)


        SEG     A.DATA                subttl initialization,login process,main loop (MSVMAI.Sxx)
:(menudev)MSVMAI.S30
: from .s20 JWH, 7/1/87
:(J.BURKE)MSVMAI.S20
: from .S13, JSB, 1/12/87.

::(J.BURKE)MSVMAI.S13

:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::
::    REVISION HISTORY - LATEST FIRST
::
:: 11/04/87   JWH   Change for new release MSV3.00
::
:: 01/12/87   JSB   Fix the Match-String handling so it is no longer
:                   dependent on ISIS packet boundaries.
::
:: 10/29/86   JSB   Fix echoing logic: where it was reflecting
::                  some echo-related functions, now it will pass
::                  through all echo functions when connected to
::                  a host.  Don't mess with this stuff until you
::                  are sure you understand it.
::
::some time   mysterious   Removed all trace of the mod described
::in btween   programmer   under 06/06/84 PWD.
::
:: 06/06/84   PWD   Modified B6 routine to check last byte of
::                  user buffer, if non-zero then don't dump
::                  data from host.  Byte is set for 370 hosts
::                  in menu command decoder.
::
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

	subttl	initialization (MSVMAI.Sxx)

: clear selected fields in the user blocks

        seg     a.code
cmdbas  eq      seg|a.code|             :base for refs to ISIS cmd tables.

START   HS      0
	if	\(seqring)
	  lis	  r0,(0)
	  st	  r0,(ORsnum),,		:0000 03 report to sups log is magic
	ei

	la	rUCB,(UCBbase)
st1
	  lis	  r0,0
	  sth	  r0,(TsatSide),rUCB
	  sth	  r0,(flagBits),rUCB
	  sth	  r0,(BAbase),rUCB

          jal     r5,RsetPW,,           :destroy r0-r5

        ahi     rUCB,(UCBlength)
	clhi	rUCB,(pastTheEnd)
	jlbs	st1		

	lhl	r9,(HOSTX),,		:HostX is kernal host number
	lis	r10,(4)
	la	r11,(khnum)
	jal	r4,BinDec

	lhl	r9,(NODEX),,		:NodeX is kernal node number
	lis	r10,(5)
	la	r11,(nodenum)
	jal	r4,BinOct

	lhl	r9,(SLOTNO),,		:SlotNo is slot number 
	lis	r10,(1)
	la	r11,(slotnum)
	jal	r4,BinDec

ritenow curgmt
	li	r3,(ritenow)		:time of ASSEMBLY
	lhi	r4,($a13)
	la	r5,(whenA)		:stick printable into message
	jal	r6,DATIME

	l	r3,(GMT),,		:time slot FIRED UP
	lhi	r4,($a13)
	la	r5,(whenF)		:stick printable into message
	jal	r6,DATIME

: send Report Host Availability message(s) to SUP

	lis	r12,(h)
st3
	  lhl	  r0,(HOSTS),r12,r12	:set up in Finish.Lib
	  sth	  r0,(ErhsHst)

	  lhl	  r1,(PORTS),r12,r12
	  nhi	  r1,(1ff)		:?
	  sth	  r1,(ErhsPrt)

	  sth	  r12,(ErhsRhn)		:relative host number

	  lhl	  r1,(sAndKtab),r12,r12
	  sth	  r1,(ErhsSta)		:status and key

	  lis	  r2,(0)
	  la	  r3,(ErhsBuf)
	  jal	  r5,OCM		:send an EXTENDED REPORT HOST STATUS

	sis	r12,(1)
	jge	st3

: clean out bit arrays

	lis	r0,(0)
	lhi	r1,(clrTo-clrFrom-4)
st4
	  st	  r0,(clrFrom),r1		

	sis	r1,(4)
	jgebs	st4

	nolist
rhn	eq	0
	re	(h+1)			:hosts
cmd	  eq	  10			:STARTS AT 10
	  re	  (H|rhn|Ccnt)		:per-host command count

	    if	    \(H|rhn||cmd|CountOfElements)
	      lhi     r1,(H|rhn||cmd|CountOfElements)-1
loop
	        sbt     r1,(H|rhn||cmd|EntryAvailabilityBitArray)
	      sis     r1,(1)
	      jgebs   loop		:including 0th

	      kill    loop
	    ei
cmd	    eq	    cmd+1
	  er
rhn	  eq	  rhn+1
	er
	list

: set all UCBs to "available"

	lhi	r1,(nUsers-1)		:careful, just UCBs we have
st6
	  sbt	  r1,(UCBinUse)		:all on (means all available)
	sis	r1,(1)
	jgebs	st6			:including 0th

: set up these routines to run 

	jal	r0,IZT			:initialize timeout list

	l	r7,(FASTC),,		:present fast clock time

	lhi	r1,(RATE*$a10),r7 	:10 seconds
	la	r0,(InactivityTimeoutTester)
	jal	r5,TOPUT

	lhi	r1,(RATE*(1)),r7	:1 second
 	la	r0,(PerhapsSendReports)
	jal	r5,TOPUT

        LHI     R1,RATE*$A60,R7         :per minute
        LA      R0,TKLTMO               :routine update the tickler 
        JAL     R5,TOPUT

: copy each host's port quota to its "RemainingQuotaTab" entry
: set each host's cost to 0 

	lis	r2,(0)
	lhi	r1,(h)
st5
	  lhl	  r0,(qtaTab),r1,r1
	  sth	  r0,(RemainingQuotaTab),r1,r1

	  if	  CostMacroInvoked
	    stb	    r2,(CostAsSupBelievesIt),r1
	  ei

	sis	r1,(1)
	jgebs	st5

	lhi	r0,(nUsers)
	sth	r0,(ServerPortsRemaining)

: yeah, they're all up

	lcs	r0,(1)
	sth	r0,(HpaAsSupBelievesIt)	:so they agree
	sth	r0,(HpaInReality)

	if	CostMacroInvoked
	  jal	  r4,IniCst
	ei

	j	Idle

:: host cost table initialization
:
: calculates host costs at MIDPOINTS of intervals
: which divide the region *HiAvTab* to *LoAvTab*, of 
: available paths to a host. bullshit.
:
:	destroys: r0-11
:	link on r4

      if      CostMacroInvoked
IniCst
	lhi	r1,(h+1)
iLoop
	sis	r1,(1)
	jlr	r4

	lb	r3,(nociTab),r1,
	jebs	iLoop			:if no intervals to find cost for

	lb	r7,(MxCsTab),r1,	:66
	jebs	iLoop			:if host always free (not multi-based)

	  lhl	  r2,(TableFinder),r1,r1 :(for varying length cost tables)
	  stb	  r7,(CostTable),r2,	:put maxcost in first table position

	  lhl	  r9,(HiAvTab),r1,r1
	  lhl	  r6,(LoAvTab),r1,r1
	  sr	  r9,r6			:find spread (9-2=7)

	  lb	  r8,(MnCsTab),r1,	:22

	  sis	  r3,(2)		:1 each for max and min costs
	  jlefs	  i2			:if only 2 (max and min) costs

	    dhr	    r9,r3		:r9 / r3 = r10 (7/2)
	    sth	    r10,(noppciTab),r1,r1 :r10 = num of paths per cost int (3)
  
	    lr	    r9,r7
	    sr	    r9,r8		:r9 = 44  (66-22=44)
	    ais	    r3,(1)
	    dhr	    r9,r3		:44/3=16 (22,38,4e,64...)
					:r10 = cost increment per step (16)
i2
	      ais     r2,(1)		:bump host cost table pointer forward

	      sis     r3,(1)
	      jlefs   i3		:if last cost entry

	      sr      r7,r10		:next lower cost ((66),50,3a,(24)...)
	      stb     r7,(CostTable),r2,
	    jbs	    i2

i3
	  stb	r8,(CostTable),r2,	:stuff MnCsTab at end of cost table

	  stb	r8,(CostInReality),r1	:make it the cost when started up
	j	iLoop
      ei

	subttl login character sender (MSVMAI.Sxx)

:--------------------
:  WAKELG subroutine - Wake up any waiting login process whose
:       wakeup bit is set. After going through all ports, it goes back
:       to main loop - IDLE.
:
:  IN:  LOGONPORTs bit array. if has 1's for host ports on which we
:       are ready to send logon character (B3) messages for Username
:       or password.
:  OUT: LOGONPORTs bit cleared.
:  REGISTERS USED - no registers preserved.

WAKELG  hs      0
	lhi	r7,(2*nGrp)-2           :start from the highest group
WAK1
        lhl	r0,(LogOnPorts),r7      :Do while (not end of all port)
	sth	r0,(WAKSC1)             :  get next group
WAK2                                    :  Do while (not all zero in 
	  lhl	  r0,(WAKSC1)           :    this group)
	  JFFOH	  r0,WAK3               :    serch for ready port
                                        :  end dowhile(not all zero)
	sis	r7,(2)                  :  advance index
	jgebs	WAK1                    :end dowhile(not end of ports)

        svc     FASTD,0
	j       idle

WAK3
	rbt	r1,(WAKSC1)		:bookkeeping

	lbr	r0,r7
	slhls	r0,(3)			:mult r7 * 8 then add to r1 to arrive
	ar	r1,r0			: at host side's port number

	rbt	r1,(LogOnPorts)

	lhl	rUCB,(PortToUCBmap),r1,r1

        ST      R7,WAKSC2
        L       R5,HSHAND,RUCB
        LIS     R12,0                   :IRCOUNT = 0 no data packet.
                                        :this is a must if R5 is in
                                        :HPWAIT which depends on IRcount
                                        :to decide who is calling.
        JALR    R11,R5                  :go to host process routine

        ST      R5,HSHAND,rUCB          :save what to do in next
        L       R7,WAKSC2               :where we left

        J       WAK2

:--------------------
: SNDLGC subroutine - login process entry point.
:       The initial host process which sends login characters (B3)
:       for ports which are logging in.
:
:       Exit to IDLE if we decide to Zap the host.
:
:       This process is set up upon Good Pseudo Needle (B2).
:       When B6 arrives, the process is changed to BEGHOS. Therefore
:       this process is never entered with a data packet.
:
: IN:   
:       R1      - host side port#
:       R13     - rUCB. the UCB addr for this port.
:
: OUT:  R5 - return address when we get awaken later.

SNDLGC
        LIS     R6,0                    
        STH     R6,CURPW,RUCB           :clear the current psw
        LB      R6,LOGINEMPTY,RUCB      :get index into ubufer
        CLB     R6,LGFILL,RUCB 

        DO(WHILE,L)             :Do while index LT lgfill[ucb]
                                :send either Username or Password
          LB    R8,UBUFER,R6,RUCB       :get the char in the ubufer
          IFF(E)                :  If it's an opcode
            LB  R3,UBUFER+1,R6,RUCB     :get the cmd
            CLI R3,OPPSW
            IFF(E)                      :If it's a psw command
              LB        R3,CURCMD,RUCB  
              CLI       R3,OPNAME
              IFF(E)                      :if doing username
                LB      R1,UBUFER+2,R6,RUCB
                SLLS    R1,8
                LB      R3,UBUFER+3,R6,RUCB
                OR      R1,R3               :the offset in pwarry
                LB      R3,PWARRY,R1,rucb    
                IFF(E)                      :if we dont have the username
                  LA    R3,NLS4,,               :send 'user name' msg to user
                  LHI   R1,$07F
                  JAL   R5,SHIPTOTSAT
                ENDIF                       :endif we dont have the username
              ORELSE                    :orelse tymenet psw or others
                CLI     R3,OPTYPW           :tymenet PSW
                IFF(E)                      :if oppsw is for psw
                  LB      R3,UBUFER+2,R6,RUCB :get the psw offset
                  LB      R1,UBUFER+3,R6,RUCB
                  SLLS    R3,8
                  AR      R3,R1
                  LB      R1,PWARRY,R3,rucb       :first byte of the psw
                  IFF(E)                      :if we don't have the psw yet
                    LA        R3,NLS5,,
                    LHI       R1,$07F         :set mask = 7bit string
                    JAL       R5,SHIPTOTSAT   :display text to user.
                  ENDIF                       :endif dont have the psw yet
                ENDIF                       :endif oppsw is for psw
              ENDIF                       :endif doing username

              LIS       R3,0
              STB       R3,CURCMD,RUCB        :clear the flag
              STB       R6,PWPOSI,RUCB        :save the current ubufer index
                                                
              LB        R3,UBUFER+2,R6,RUCB   :the psw offset
              STB       R3,CURPW,RUCB         :save the current psw index
              LB        R3,UBUFER+3,R6,RUCB
              STB       R3,CURPW+1,RUCB       :save the current psw index
              LH        R3,CURPW,RUCB         :get the offset

              LB        R8,PWARRY,R3,rucb         :first byte in the psw entry

              IFF(E)                          :If there is no psw
                JAL     R7,INSPW
                        :to promp user and acquire PW.
                        :It might suspend this process for a later
                        :wake-up. Meanwhile it will exit through the colink
                        :IN - R11 the return addr to co-link
                        :     R7  the return addr to this routine
                        :     R13 addr points to UCB of this port
                        :OUT- 
                        :REG  R11,R13  preserved.

                LB      R6,LOGINEMPTY,RUCB
                LH      R3,CURPW,RUCB           :get the psw index
              ENDIF

              LA        R7,PWARRY,R3,rucb    
              LIS       R9,0
              STB       R6,LOGINEMPTY,RUCB

              JAL       R6,SNDPW
                        :send psw in PWARRY entry plus CR by B3
                        :IN R7 points to the char string
                        :   R9 index to where to start from in the string
                        :REG R0-R9 destroyed

                        :now adjust the loginempty index 
                        :doing this only because try to compatible with
                        :previous version.
              LB        R6,LOGINEMPTY,RUCB
              LB        R2,UBUFER+3,R6,RUCB    :the next char
              CHI       R2,CR
              IFF(E,SHORT)              :if char = cr
                AIS     R6,OPPWLE+1        :  skip it
              ORELSE(SHORT)
                AIS     R6,OPPWLE
              ENDIF

              EXITDO            :exit done with this psw cmd
            ORELSE
              CLI       R3,OPINFO
              IFF(E)            :if opcode info
                AIS     R6,2
                LR      R9,R6           :where to get the lable
                JAL     R8,SNDINF       :send the info string to user
                        :IN: R9 - where to get the address of the string
                LR      R6,R9           :get the loginempty index
              ORELSE            :bad command from error configuration
                LA        R3,ZMCON,,    :bad configuration message
                LHI       R1,$07F       :7bit message
                JAL       R5,SHIPTOTSAT

                LHI       R9,ZCCON
                STB       R9,ZRZN,RUCB
                JAL       R9,ZHOST

                J         IDLE
              ENDIF             :endif it is op-info
            ENDIF               :endif it is a psw command

          ORELSE                :the UN or PW is ready
            LIS R3,0
            STB R3,CURCMD,RUCB  :clear the command flag

            OHI R8,$080         :turn on parity bit for SUP
            STB R8,NLCBUF+2
            LA  R3,NLCBUF
            LH  R2,HOSTSIDE,RUCB
            JAL R5,OCM          :send b3

            AIS R6,1            :advance the empty index

            CLHI        R8,SEMICOLON!$080
            IFF(E,SHORT)
              EXITDO              :exit end of psw or username
            ORELSE(SHORT)
              CLHI      R8,CR!$080
              IFF(E,SHORT)
                EXITDO              :exit end of psw or username
              ENDIF
            ENDIF

          ENDIF                 :endif whether data or an opcode

          CLB   R6,LGFILL,RUCB :is it end of UBUFER
        ENDDO                   :sending chars in a UN or in a PW
                
        STB     R6,LOGINEMPTYINDEX,RUCB        :save the ubufer index

        LA      R5,SNDLGC       :we might be waken up to send psw either
                                :after sending UN or re-enter PSW
        JR      R11

: SNDPW - routine send password in PWARRY entry to SUP by B3 message.
:       It adds a CR at the end of password.
:
: LINK  R6
:
: IN -  R7 points to the char string
:       R9 the index where the login char starts from
:
: OUT - R9 the next char to be processed in the char string
: REG   R0-R9 destroyed
SNDPW
        LB      R8,0,R9,R7      :get the char
        DO(WHILE,N)             :do while not end of psw
          OHI     R8,$080           :turn on the parity bit for SUP
          STB     R8,NLCBUF+2
          LA      R3,NLCBUF
          LH      R2,HOSTSIDE,RUCB  :host port number
          JAL     R5,OCM            :send a B3 message

          AIS     R9,1

          LB      R8,0,R9,R7      :get the next char
        ENDDO                   :end do while not end of psw

        LHI     R8,CR!$080      :send CR with parity bit on
        STB     R8,NLCBUF+2
        LA      R3,NLCBUF
        LH      R2,HOSTSIDE,RUCB  :host port number
        JAL     R5,OCM            :sned a B3 message

        JR      R6

        SUBTTL  INSERT PASSWORD - get the PSW from user or ubufer(MSVMAI.Sxx)


: INSPW subroutine - insert password into PW array.
:       If the password is not in the password array, promp the user.
:       SAVETYPEAHEAD is accumulating the user's keystrokes in Ubufer
:       starting at STYPEA.
:
:       If a complete password has not arrived in the Ubufer, call 
:       HPWAIT, which goes into a wait until it arrives.
:
:       On entry there may be an open data packet from the host in 
:       IRING, or maybe not while doing the match. To resolve this 
:       situation when we go into wait, we simply make the C0-call.
:       If we get data back, we give it to the HOSTTOTSAT process 
:       and call co-routine again.
:
:       This routine is called during both Tymnet login and host login.
:
: LINK  R7
: IN:   R11     - the Co-routine linkage address
:       R13     - rUCB
:
: REG:  only R13,R11 preserved
:
INSPW
        ST      R7,RTNAD2,RUCB
        DO(FOREVER)             :repeating while user enters too many..

          LHL   R6,HOSTSIDE,RUCB
          TBT   R6,DOINGLOGIN
          IFF(E,SHORT)          :If not doing login then
            JAL   R6,PRPA         :dispaly the password prompt
          ENDIF                 :endif 

          LB    R1,STYPEA,RUCB
          LHI   R6,PWLEN+1
          LH    R3,CURPW,RUCB
          LIS   R5,0
          STB   R5,PWARRY,R3,rucb          :clear the psw entry
 
         DO(COUNT,R6)          :move psw chars as they arrive
            CLB R1,LGFILL,RUCB  
            IFF(GE)              :if need to wait for PW
              STB       R1,PWFROM,RUCB

              JAL       R6,HPWAIT
                        :IN - R11 co-link return addr
                        :     R7  return addr of previous caller
                        :REG- R7,R11,R13 are preserved

                        :restore everything we need
              LB        R1,PWFROM,RUCB  
              LB        R2,STYPEA,RUCB
              SR        R2,R1

              LHI       R6,PWLEN+1
              LH        R3,CURPW,RUCB   :the psw index
              AR        R6,R2           :r6 = pwlen+1+(stypea-pwfrom)
              SR        R3,R2           :r3 = pwindex+pwfrom-stypea
            ENDIF               :endif need to wait

            LB  R0,UBUFER,R1,RUCB       :get the char
            LR  R2,R0
            LHL R10,TSATSIDE,RUCB
            TBT R10,ETMOUT
            IFF(E,SHORT)
              NHI   R2,$07F
            ENDIF

            CHI R2,CR
            JE  IPW8
            CHI R2,SEMICOLON
            JE  IPW8

            CHI R2,ESCAPE
            IFF(E,SHORT)
              AIS       R1,1
              JAL       R5,SHIFUB               :R1 = from

              LB        R1,STYPEA,RUCB          :start from stypea
              J         IPW6
            ENDIF

            STB R0,PWARRY,R3,rucb           :move char into psw entry
        
            AIS R1,1
            AIS R3,1
          ENDDO         :enddo on pwlen

          L     R0,SLOWC,,      :to make SAVETYPEAHEAD wait for orange
          AHI   R0,$A20         :set timer = 20sec
          ST    R0,YBTIMER,RUCB

          AIS   R1,1
          CLB   R1,LGFILL,RUCB
          IFF(LE,SHORT)         :if user type more
            LA  R3,DISKEY,,     :keystrokes are disgard
            LHI R1,$07F         :7bit message
            JAL R5,SHIPTOTSAT
          ENDIF

          LH    R2,TSATSIDE,RUCB
          LA    R3,YELLOWBUF
          JAL   R5,OCM

          JAL   R6,PRTM         :type too many char

          LB    R1,STYPEA,RUCB
          STB   R1,LGFILL,RUCB
IPW6
         ENDDO   :end repeating while mistakes

IPW8
        AIS     R1,1
        JAL     R5,SHIFUB       :  IN:  R1 = from
        LIS     R5,0
        STB     R5,PWARRY,R3,rucb    

        L       R7,RTNAD2,RUCB  :the return addr of previous caller
        JR      R7


: SHIFUB subrouinte - shift typeahead data in UBUFER forward. 
:       starting from the next char to be processed to the destination
:       begining at location STYPEA[UCB] in the UBUFER. Then, adds
:       tw byte '0' at the end.
:
: LINK  R5
: IN:   R1 - the index to where to start from
: REG   R1,R2,R4 are destoryed
:
SHIFUB
        LB      R2,STYPEA,RUCB

        CLB     R1,LGFILL,RUCB
        DO(WHILE,L)     :do while( char in the savetypeahead )
          LB    R4,UBUFER,R1,RUCB
          STB   R4,UBUFER,R2,RUCB       :shift it over
          AIS   R1,1
          AIS   R2,1
          CLB   R1,LGFILL,RUCB
        ENDDO           :enddo while (char in the stypea )

        STB     R2,LGFILL,RUCB
        LIS     R4,0
        STB     R4,UBUFER,R2,RUCB
        STB     R4,UBUFER+1,R2,RUCB     :put terminator

        JR      R5


: HPWAIT - Host process wait until password arrives.
:       meanwhile send any host data to SAT. Wait for SAVETYPEAHEAD
:       to get the password and wake us up again.  The login process 
:       re-enter at the return point here.
:       this routine may be called by either tymnet login or host
:       login.
:
: LINK  R6       
: IN:   R11 - return address to co-routine
:       R13 - RUCB
:
: OUT:  LGWAIT[Tsatside] set in order to be woken up when PSW is ready
:
: REG:  R11,R13 are preserved
:
HPWAIT  HS      0
        ST      R11,RTNAD1,RUCB         :save previous co-routine rtn addr
        ST      R6,RTNAD3,RUCB

        LH      R1,TSATSIDE,RUCB
        SBT     R1,LGWAIT

        JALR    R5,R11
                :it returns from host data rcvd in main loop with
                : IRcount<>0 or from WAKELG with IRcount = 0

        LA      R5,HOSTTOTSAT,, :set host handler= HOSTTOTSAT
        ST      R5,HSHAND,RUCB

        LR      R12,R12
        DO(WHILE,N)             :Do while we have char
          ST    R11,RTNAD4,RUCB   :save the co-routine rtn addr
          LA    R5,HOSTTOTSAT,,   
          JALR  R11,R5            :consume the current pkt at HOSTTOTSAT

          L     R11,RTNAD4,RUCB   :Get the co-routine return addr
          JALR  R5,R11            :Go back to where it comes from
                                  :To get a char or be waken up later.
          LR    R12,R12           :Check IRcount
        ENDDO                   :End do while have char

        L       R11,RTNAD1,RUCB :restore the co-routine return address
                                :when it is called first time
        L       R6,RTNAD3,RUCB  :return to caller

        JR      R6


	subttl idle loop (MSVMAI.Sxx)

Idle
	jal	r0,TIMOUT		:perform a timeout routine if one was due 

: Call LOOK, whereupon:
: r1 has port, r2 has message type, 
: normal return on empty input ring,
: skip return (+4) if something in input ring - condition codes set on
: exit: zero if Port Zero message ...

	jal	r4,LOOK			:anything in the ISIS input ring?

          J     WAKELG                  :+0 exit, no messages then go for
                                        :+4 exit, there is a message.
        je      PORTZE                  :jump to handle Port 0.

	clhi	rIncomingR1,(NPORT)
	jge     consume			:if port # is too high for this slot

	lbr	rMsgTypeR2,rMsgTypeR2			
	je	NEEDLEin                :go handle needle (Sat).

	clhi	rMsgTypeR2,(PsuedoNeedle)
        je      psneed                  :go handle pseudoneedle (host).

	lhl	rUCB,(PortToUCBmap),rIncomingR1,rIncomingR1
	je	ism5                    :jump, got something on unassigned
                                        :  circuit.
	lhl	rTsatSideR10,(TsatSide),rUCB
	je	ism5                    :jump, Sat is zapped already.

: Is a valid active assigned port.
: Note that rIncomingR1, rUCB, rMsgTypeR2 and rTsatSideR10 are now set up.

        l       r0,slowc,,
        st      r0,HTOLAC,RUCB          :record time of last activity.
	clhi	rMsgTypeR2,(9e)
	jge	ICMAND                  :jump, ISIS command.

: is data message

	cr	rIncomingR1,rTsatSideR10
	je	ISM6SA                  :jump, data is from Tymsat side.

: data is from Host Side ...
          jal     r4,GETCH                :consume message type,
          l       r5,HSHAND,rucb          :get handler,
          lbr     r12,rMsgTypeR2          :R12= how many data

          do                              :DO
            jal     r4,GETCH
                                            :R2=message count,
            jalr    r11,r5                  :jump to host handler.
            sis     r12,1
          enddo(while,g)                  :UNTIL packet exhausted.
          st      r5,HSHAND,rucb          :save handler.
          jal     r4,ELIR
          j       IDLE

    : Here if not a good port ...
ism5    hs      0
	clhi	rMsgTypeR2,(9e)
	jge     Consume			:jump to eat stray "signals".

                     			:eat stray data ...
	ais	r14,(1)
	lbr	r0,rMsgTypeR2
	jal	r4,Flush
	j	Idle

          
	subttl handle data from tymsat side (MSVMAI.Sxx)

: Here's where characters from the "tymsat side" are handed to various
: "user processes".  The address is picked up from TSATDAtahandler in the
: UCB.  The major process addresses are:
:
: "CmndMode" accepts a user's menu-selection typein, looks up what the user
: typed in the command table, and proceeds to perform the log-in (or text)
: which the user selected.
:
: "Eat" causes characters to be discarded until an orange ball is returned,
: or a waiting-for-orange-ball timeout occurs, then sets the process to
: "CmndMode".  We use this when we receive uninterpretable characters from
: the user in command mode, because he may think he is now typing to the
: host and we don't want to mistake it for a good selection.
:
: "Send2Host" passes characters from the Tymsat Side to the host once the
: transparent user-to-host connection is established.
:
: msv 3.0 - no GETPW routine. the msv requests psw only when needed.
: After psneed received, set the host handler to "SNDLGC".
: "GetPW" puts up to 32 characters into rUCB (passWrd),
: sends the menu, and sets the next state to "CmndMode"

: note that a jalr rRetToCharSupR11,rAddOfEntryR5 jumps to the address
: in rAddOfEntryR5 and stores the address
: of the instruction that follows it in rRetToCharSupR11.

rRetToCharSupR11 eq r11
rAddOfEntryR5    eq r5

: R0: current character.
: R12: count remaining in the current ISIS packet, including the current
:       character.  Note: the process should not decrement R12 for a single
:       character.  If the process consumes further characters, it should 
:       decrement R12 for ALL BUT the first character and should exit if R12
:       =1.
: R14:  current index of IRING for GETCH.
: R5 is the coroutine linkage.
: R6, R7, and R9 are saved for the process in the UCB if the process exits
: via the coroutine linkage, and restored on re-entry.

: Some Register usage information:
: r5			r6		r7		r9

:Send2Host		rHostSideR6	rUbufInxR7	...
:Pause			...		...		...
:HandLogIn		index		host side port	"0"
:SaveTypeAhead		index		...		"0"
:Eat			...		...		...
:CmndMode		rIndexR6	rAddressR7	(GetToken ret addr)
:(GetToken)		rIndexR6	rAddressR7	(GetToken ret addr)

ISM6SA  hs      0
	l	r6,(saveR6),rUCB		 
	l	r7,(saveR7),rUCB		
	l	r9,(saveR9),rUCB		
	l	rAddOfEntryR5,(TsatDataHandler),rUCB

	ais	r14,(1)			:skip over length

    : Call the character Consumer Co-Routine until it eats all the chars.
    : The Co-routine is allowed to do further GETCH's and decrement R12.
    : It must exit after it consumes the last char, with R12 =1.
	lbr	r12,rMsgTypeR2          :FOR R12 = how many data,
ISM7C	  jal	  r4,GetCH              :REPEAT
                  : R1 = port,
                  : R12 = how many data characters in msg,
	  jalr	  rRetToCharSupR11,rAddOfEntryR5    :enter the co-routine.
	sis	r12,(1)
	jgbs	ISM7C		        :ENDDO WHILE chars left.

	jal	r4,ELIR

	st	rAddOfEntryR5,(TsatDataHandler),rUCB
	st	r6,(saveR6),rUCB
	st	r7,(saveR7),rUCB
	st	r9,(saveR9),rUCB

	j	Idle	


:----------------
: port number IS 0 - handle PnRj but ignore or crash on others

PORTZE  clhi	rMsgTypeR2,(9)
	je	PnRjIn			:if Psuedo-needle reject

	clh 	rMsgTypeR2,MAXP0,,
	jgfs	bummer			:if outside table range

        lh      r5,LP0LST,,
	lb	r0,SEGF,rMsgTypeR2,r5
	jefs	bummer			:jump if no length for it.

	  jal	  r4,FLUSH
	  j	  Idle	

    : Unable to continue in the IRING ...
bummer  hs      0
	jal	r10,CRASH
	bc	0,0,(rMsgTypeR2*4),(bumItype)


: (0000,09) pseudo-needle reject 
: ------------------------------
PnRjIn
	jal	r4,GetH 		:ignore SUBTYPE / KEY

	jal	r4,GetH			
	lr	rUCB,r0			:rUCB := local key

	jal	r4,GetCH		:reason code
	jal	r4,ELIR

	clhi	r0,(PnRjMax)
	jlefs	PnRj1			:if reason code is within bounds
	  lis	  r0,(PnRjMax)
PnRj1
	lbr	r5,r0			:(r0 can't be used as index)
        la      r3,pnrrzn,r5            :turn it into a
        stb     r3,zrzn,rUCB            :   general Zap Reason code.
	slhls	r5,(2)                  :( *4 )
	l	r3,(PnRjTab),r5
        lhi     r1,$07F                 :set mask = 7bit
	jal	r5,shipToTsat		:explain situation to user

	lhl	rTsatSide,(TsatSide),rUCB
	jal	r9,FOGHOS               :Get rid of host info
        j       IDLE

                subttl  NEEDLER HANDLING (MSNEED.Sxx)
:(menudev:39)MSNEED.S30
: 06/24/87 JWH  V3 R1: reject the aux cir request

:(J.BURKE)MSNEED.S20
: 01/12/87 JSB  V2 R1: Fix crash upon auto-sel + PW.

:(J.BURKE)MSNEED.S13
: 11/5/86 JSB   R13: Various comments, fix to correct the echo problem.
:
: 11/5/68 JSB   Split out from MC.R12

:-------------------
: b2 - Jump here to handle psuedo-needle, i.e. new circuit toward a host.
:   "Local Key" in the PsNeedle is the UCB pointer!

psneed  hs      0
	sbt	rIncomingR1,(doingLogon)
	sbt	rIncomingR1,(ToISIS)
	sbt	rIncomingR1,(FrISIS)
	rbt	rIncomingR1,(ECHO)
	rbt	rIncomingR1,(dem)
	sbt	rIncomingR1,(nbo)       :host is initially No-Ball-Out.
	rbt	rIncomingR1,(green)
	rbt	rIncomingR1,(tymsat)	:this ain't no tymsat
        RBT     R1,HYBOUT               :no yellow ball from host

        lhi     r6,cshost               :Make this circuit a Host circuit.
        stb     r6,cstate,rIncomingR1

	jal	r4,GetH			:discard "b2" and "key"

	jal	r4,GetH			:UCB was used as local key
	sth	r0,(PortToUCBmap),rIncomingR1,rIncomingR1

	jal	r4,ELIR

	lr	rUCB,r0

	sth	rIncomingR1,(hostSide),rUCB 

        LIS     R0,0
        STB     R0,PWPOSI,RUCB

        LA      R0,SNDLGC               :set the host handler to SNDLGC
        ST      R0,HSHAND,RUCB          :in order to send login stream

	lhl	r0,(TsatSide),rUCB
	tbt	r0,(HandBA)
	jn	Idle			:wait for hand typed login

	  sbt	  rIncomingR1,(LogOnPorts) :start programmed login

          LA      R3,MSCKT,,            :info user now building host ckt
          LHI     R1,$07F
          JAL     R5,SHIPTOTSAT

          LHI     R3,OPNAME             :set first time through flag
          STB     R3,CURCMD,RUCB
	  j	  Idle


:----------
: NEEDLEin - jump here to accept a Needle from the IRING.
:   Always consume the needle here.  Validate the login: host number in the
:   needle tells which menu this user wants.  Reject if too any ports used
:   for that host.
:
:   Normal Termination:
:   If the user is valid and we will take more input from him/her, 
:   we will call the beginning of the user process at BGUSER.  When this
:   returns, the process is calling for a character.  We store the linkage
:   in TSATDAtahandler[UCB] so that the process will continue when some
:   data arrives.
:   If we reject this login, circuit is zapped and needle discarded.

NEEDLEin  hs    0
	sbt	rIncomingR1,(ToISIS)
	sbt	rIncomingR1,(FrISIS)
        lhi     r6,csmenu               :Make the circuit's State
        stb     r6,cstate,rIncomingR1   : terml-at-menu.

	jal	r4,GetH	 		:additional length
	jal	r4,GetW	 		:invoice number
        ST      R0,SCRATC

	jal	r4,GetH	 		:destination host 
	lr	r5,r0

	jal	r4,GetH			:discard originating node
	jal	r4,GetW	 		:discard originating host / originating port
        jal     r4,GetH 		:unused
        jal     r4,GetCH 		:unused

        jal     r4,GetCH 		:TPC (throughput class)
	lbr	r10,r0

	jal	r4,GetH	 		:IIX bit, (destination node)
	lr	r11,r0

	jal	r4,GetCH		:NID (terminal characteristic)
        lbr     r12,r0                  :save the orig CCT
	NHI     R0,03F                  :ignor the first 2 bit in CCT
        IFF(E)                          :if (request from aux circuit)
          JAL   R4,GETCH
          JAL   R4,FLUSH                :toss the rest

          LR    R12,R1                  :save port#
          LR    R2,R12
          LA    R3,AUXIMS,,
          LHI   R1,$07F
          JAL   R5,OCSMS

          LR    R2,R12
          LA    R3,DETACHBUF
          JAL   R5,OCM                  :zap the user

          J     IDLE
        ENDIF

    : IRING is positioned at length of the Username.
    : determine RHN (relative host number) ...

	lis	r6,(h)
ne2
	  clh	  r5,(HOSTS),r6,r6
	  je	  ne3			:jump, found the host.
	sis	r6,(1)
	jgebs	ne2			:if more hosts to check

        JAL     R4,GETCH                :get the username length
        JAL     R4,FLUSH                :get rid of this ISIS packet

        lr	r12,rIncomingR1		:save r1
	lr	r2,r12                  :port,
	la      r3,BAHMS,,              :"Bad Host Number"
        LHI     R1,$07F                 : a 7bit string
	jal     r5,OCSMS                :  put out msg.

	lr	r2,r12
	la	r3,(DetachBuf)
	jal	r5,OCM			:send a DETACH message

	j	Idle


    : Found the host ...
ne3
	lhl	r0,(RemainingQuotaTab),r6,r6
	je	ne6                     :jump, host's quota exceeded.

: find a UCB that isn't in use (catch condition of no ms ports) ...

	lis	r7,(0)                  :REPEAT
ne4
	  lhl	  r8,(UCBinUse),r7
	  JFFOH	  r8,ne5                  :jump, got a free UCB.
	ais	r7,(2)
	chi	r7,(2*nGrp)
	jlbs	ne4                     :UNTIL past last group.

	jfs	ne6			:jump, no UCB.

        : Got a UCB ...
ne5
	slhls	r7,(3)
	ar	r9,r7			:compute UCB ordinal.

	rbt	r9,(UCBinUse)		:mark UCB "in use" 

	lhi	r7,(UCBlength)
	mhr	r9,r7
	la	rUCB,(UCBbase),r9,      :arrive at UCB address.
	j	ne9                     :jump to continue.


    : Zap user, giving him the "no Ports" message (NPTAB points to msg)...
ne6
	jal	r4,GetCH		:(length of userName field)
	jal	r4,FLUSH		:toss userName field

	slls	r6,(2)                  :host ord. *4,
	l       r7,(NPtab),r6,          :point to message,
        lr	r12,rIncomingR1		:save r1

        LB      R0,1,R7                 :get the string length
        DO(WHILE,N)                     :do while (not end of msg)
          LB    R0,0,R7                 :string type
          IFF(N)                        :if ( *8bit )
            TBT R12,ETMOUT
            IFF(E,SHORT)                :if (non-trans)
              LR  R2,R12                  :port#
              LA  R3,ETMBUF
              JAL R5,OCM                  :send ETM

              SBT R12,ETMOUT              :turn the flag on
              LB  R3,MSVETM,R12
              AIS R3,1
              STB R3,MSVETM,R12           :add 1 to count
            ENDIF                       :endif(non-trans)

            LHI R1,$00FF                :mask for 8bit
          ORELSE(SHORT)                 :else (*7bit)
            LHI R1,$07F
          ENDIF                         :endif (*8bit)

          LR  R2,R12
          LR  R3,R7                   :send string out
          AIS R3,1                    :point to the begining of the SC format
          JAL R5,OCSMS

          LB  R0,1,R7                 :get the length
          AIS R7,2                    :two bytes overhead   
          AR  R7,R0                   :point to next string
          LB  R0,1,R7
        ENDDO                         :enddo while (not end of msg)

        TBT     R12,ETMOUT
        IFF(N,SHORT)                  :if sat in transparent mode
          LR    R2,R12
          LA    R3,LTMBUF
          JAL   R5,OCM                :reset the sat mode

          RBT   R12,ETMOUT            :clear the flag
          LB    R3,MSVLTM,R12
          AIS   R3,1
          STB   R3,MSVLTM,R12
        ENDIF

	lr	r2,r12
	la	r3,(DetachBuf)
	jal	r5,OCM			:send a DETACH message

	j	Idle
	:-----------

    : Got a UCB.  Put some Needle info into UCB ...
ne9
	stb	r10,(TPC),rUCB

	sth	r11,(IIX),rUCB
	stb	r12,(NID),rUCB

	stb	r6,(relativeHost),rUCB

        L       R7,SCRATC
        ST      R7,INVOCE,RUCB

	lcs	r7,(1)
	jal	r9,ChangeRemainingQuota

    : copy userName from needle into "userName", discarding the "!"
    : and the terminating delimiter and storing a 0 to indicate the end 
    : msv3.00 always keep the username in order to detect the M.A.'s login

	jal	r4,GetCH		:length of userName

        lbr     r3,r0
        lis     r5,(0)	        	:put-em-in index (look out for "!")

ne10    hs      0                       :DO - consume username from needle.
	  jal	    r4,GetCH
	  clhi    r0,Exclaim!$080         :A Override char?
	  jefs    ne11     		  :if an Override "!", don't move it.
            chi     r5,unamel
            iff(l)                          :if not too big for us ...
              stb     r0,(userName),rUCB,r5     :move Username character.
	      ais     r5,(1)
            endif                           :endif not too big
ne11
	  sis	  r3,(1)
	jgbs	  ne10                :ENDDO - consume username.

        stb     r3,(userName-1),rUCB,r5  :r3 is 0, overwrite the <semi> or <cr>

        jal	  r4,ELIR
	

    : Initialize the UCB and port variables ...
              : R6 = host number.
              : R13=RUCB.

	lb	r0,(tixTab),r6
	stb	r0,(ToArray),rIncomingR1	:start the inactivity timeout mechanism

	sbt	rIncomingR1,(tymsat)		:this is a tymsat
	sbt	rIncomingR1,(dem)		:tymsats start out in dem
	rbt	rIncomingR1,(green)		:don't have greenball from sat.
        rbt     rIncomingR1,LGWAIT              :login not happening.
        RBT     R1,ETMOUT                       :start with non-transparent

	sth	rUCB,(PortToUCBmap),rIncomingR1,rIncomingR1

	sth	rIncomingR1,(TsatSide),rUCB

	lis	r0,0
	sth	r0,(hostSide),rUCB
        ST      R0,YBTIMER,RUCB         :no yellow ball out 
        STB     R0,MSVETM,R1
        STB     R0,MSVLTM,R1

        JAL     R5,RSETPW               :clear the psw entries r0-r5 destroyed

: Check the username to detect the M.A.'s login

        LH      R4,MAIDX,R6,R6  :get the offset
        IFF(GE)                 :if the host has a valid M.A.
          LA      R6,MANAME,R4,
          LA      R7,USERNAME,RUCB
          JAL     R4,MTCH
                  :EXIT +0 failure (not match or too long)
                  :EXIT +2  match

            JFS   NE12            :continue the menu service if fail
          JAL   R11,TKLCMD      :if match then go to tickler process
                                :return when requesting data
          ST    R5,TSATDATAHANDLER,RUCB :store the return address
          J     IDLE            
        ENDIF                   :endif the host has a valid M.A.

: send a slew of query terminal parameters messages to the tymsat side
NE12
	lhi	r8,(nTrmCh)
	lhl	rTsatSideR10,tsatside,rucb
ne13
	  sis	  r8,(1)
	  stb	  r8,(QTPpar)

	  lr	  r2,rTsatSideR10
	  la	  r3,(QTPbuf)
	  jal	  r5,OCM		:send a QUERY TERMINAL PARAMETERS msg

	lbr	r8,r8
	jgbs	ne13
	:--------
        if      .gt.(ntrmch,$a32)
          remark %*** NTRMCH GOT TOO BIG, AT LOCATION HEX (
          number $0.
          remark ), BAD ASSEMBLY.%***%
        ei
	li	r0,(7fffffff)
	st	r0,(TcNotInYetBA),rUCB  :WHAT GOOD IS THIS?

	lis	r0,(1)
	stb	r0,(origTcForTsatSide),rUCB :the INITIAL VALUE for ECHO is 1

        LB      R2,RELATIVEHOST,RUCB
        LB      R0,MENU8,R2,
        IFF(G,SHORT)                    :is it 8bit menu?
          LR    R2,RTSATSIDER10           :send ETM message if 8bit menu
          LA    R3,ETMBUF
          JAL   R5,OCM
          SBT   R10,ETMOUT
          LB    R3,MSVETM,R10
          AIS   R3,1
          STB   R3,MSVETM,R10
        ENDIF

        jal     r6,PrWE			:"welcome"

    : Begin the User process for the TSAT ...

        lis     R12,0                     :with char count =0,
        jal     RRETTOcharsupr11,BGUSER   :enter the user process,
        SVSATL                            :save its regs.

	j	Idle


	 subttl  MTEHAN.Sxx, Main Terminal Data Handler Co-Routines


: mtehan.s32  JH 02/29/88
:       change the instrs which refer 'CT' table into RX3
:       change the send2host routine. make the same as HOST2sat 
:       
: MTEHAN.S30  From mtehan.s20 by GWH 09/30/87
:       Changes are made for MSV 3.00
:       FOR MULTIPASSWORD -
:       no GPW in BGUSER, prompt for PW only when it is required
:       SAVETYPEAHEAD wakes up the login process if login activation 
:       char is received.
:       FOR KATAKANA - ???

:(J.BURKE)MTEHAN.S20
: From (J.BURKE)MSHAND.S13 by JSB, 12/12/86.
:       Fix crash upon auto-sel plus PW.
:	Remove host handlers, leave Terminal handlers.
:
:(J.BURKE)MSHAND.S13
:   Split out from MC.R12 by JSB, 11/5/86

: - - - - - - - - - - - - - -
: SEND2Host - Coroutine entry for Sending characters to the host once we
:   have a host circuit ...
:   Note: once we establish a transparent connection, we never have DEM in
:   the Menu Server - the host begins in Echo-Off and all subsequent echo-
:   related messages are passed through.
:
: IN - R0  the input char
:      R6  the Host port number
:      R12 the input count
: LINK - R11
:        R5 handlering routine address( preserved )
: register destoryed - R0 through R4, R8


SEND2Host      hs      0
        lr      r8,r0                   :save the input char
        lr      r1,rHostsideR6          :the port number
        lhi     r0,(3),R12              :the size required
        jal     r4,SLOR

        lr      r0,r8                   :get the char back
        jal     r4,PUTCH                :put it.

        sis     r12,1                   :count 1 off
        DO(WHILE,G,SHORT)               :do while still has input ...
           jal  r4,GETCH                  :get the next input char
           jal  r4,PUTCH                  :pass the input char to Tsat
           sis  r12,1
        ENDDO
	jal	r4,ELODR                :close the packet.
        ais     r12,1                   :re-adjust count for exit.

        jr      r11                     :go back to the co-routine, wait
                                        :next input message from host.

:TopOfLoop
:	jalr    rAddOfEntryR5,rRetToCharSupR11
:
:      : Process entry for passing data to host ...
:Send2Host
:	ais	rUbufInxR7,(1)
:	stb	r0,(ubufer),rUbufInxR7,rUCB :pass the original to the host
:
:	chi	r12,(1)
:	jg	TopOfLoop		:if more of the isis message to process
:
:	jal	r5,ShipBufNOW		:thru with this particular message 
:	j	TopOfLoop
:
:	
:: SHIPBUfnow Subroutine:
:: Puts the length of the "accumulated" data at UBUFER+1 into byte UBUFER+0,
:: then sends the buffer to the host.
:
:: RUBUFInxr7: in, has the count, how many bytes at UBUFER+1.
::             out, =0.
:
:ShipBufNOW  hs  0
:	stb	rUbufInxR7,(ubufer),rUCB
:
:	lbr	rUbufInxR7,rUbufInxR7
:	jer	r5			:return if nothing to send
:
:	lis	rUbufInxR7,(0) 
:
:	lr	r2,rHostSideR6
:	la	r3,(ubufer),rUCB
:        LHI     R1,$00FF                :set the mask = 8bit
:	j	OCSMS			:then OCSMS does jr to r5


:--------------------------------
: HANDLOgin - Tsat Handler for doing a user's manual login.
:
HandLogIn  hs   0
	rbt	rTsatSideR10,(doingPW)  :initially say, is not a password.

    : HLI0 is set up elswhere as an a process entry ...
hli0    hs      0
	lis	r6,2			:Reset to the start.
	stb	r6,(loginEmptyIndex),rUCB
        stb     r6,LGFILL,rUCB          : (pre-store)

        LIS     R9,3
        STB     R9,MATCHINDEX,RUCB      :initial the max esc count
        
	lis	r9,(0)			:handy zero.
	lhl	r7,(hostSide),rUCB
hli1
          tbt     rTsatSideR10,(doingPW)
          IFF(E,SHORT)			:if ECHO desired (not doing PW)..
            jal     r5,ECHOchar             :Echo it (destroy R0)
            lr      r0,r8                   :char in R8,
          ENDIF

          ohi     r0,$080               :set the parity bit on
          CLHI    R0,80+ESCAPE
          IFF(E)                        :if char = escape then
            LB    R1,MATCHINDEX,RUCB
            SIS   R1,1
            IFF(LE)                       :if 3ESC's then
              LHI R0,-1,R12               :adjust to get actual data count
              JAL R4,FLUSH                :flush the current ISIS packet
              LIS R0,0
              STB R0,ZRZN,RUCB            :for zaphost to stop retrying
              JAL R9,ZHOST                :clean out host

              J   IDLE
            ENDIF                         :endif 3ESC'
            STB   R1,MATCHINDEX,RUCB
          ORELSE(SHORT)                   :else char <> escape
            LIS   R1,3
            STB   R1,MATCHINDEX,RUCB      :reset the esc count
          ENDIF                           :endif char = escape

          stb     r0,(ubufer),rUCB,r6     :for "SeeIfLogonCharsNeedSent"
	  stb     R9,(ubufer+1),rUCB,r6
          stb     r9,(ubufer+2),rUCB,r6

	  sbt	  r7,(LogOnPorts)	:make "SeeIfLogonCharsNeedSent" work

          ais     r6,1                  :bump buffer index.
          stb     r6,LGFILL,rUCB        :save pointer

          clhi	  r6,(ubufSizCon-3)
          jge     HLI8F                 :jump out, he typed way too much.
	  clhi    r0,CR!$080
	  je	  HLI5                  :IF a CR
 	  clhi	  r0,SEMICOlon!$080
          iff(e)                        :OR a Semicolon,
HLI5        hs      0                       :Then, end of UN or PW ...
            cbt     RTSATSider10,DOINGPw    :flip the PW state over.
            iff(n)                          :IF that was the PW,
              jalr    RADDOFentryr5,RRETTOcharsupr11    :get char,
              J       SAVETYpeahead                     :GO, save typeahead.
            endif                           :end if  that was the PW
          endif
hli6      jalr	  rAddOfEntryR5,rRetToCharSupR11
	j	hli1

    : Exit to here on too many characters.  We just wait for Tymnet to
    : abort him, and go into Savetypeahead which will notice if he hits
    : 3 ESC's...
HLI8F   hs      0                       :Exit to here, no good.
        JAL     R6,prtm                 :"Too many characters",
        J       SAVETYpeahead           :go here to detect ESC's (though
                                        :   Login will probly zap him)


:--------------------------------
: SAVETYpeahead - TSAT Handler while the automatic log-in is happening -
:   Save whatever the user types, in UBUFER.
:   Detect 3 Esc's from user.

SaveTypeAhead  hs  0
        lis    	r9,(0)			:handy zero.
	lis	r7,(3)			:for counting ESC's.
        do(forever)
  	  LB	  r6,LGFILL,rUCB        :where to put chars.
          lr      r3,r0                 :copy char,
          TBT     R10,ETMOUT
          IFF(E)                        :if in non-transparent mode
            NHI R3,$07F                 :take only 7bit
          ENDIF                         :endif non-trans

          CLHI    R3,ESCAPE
	  jnfs	  alos.3
	    sis	    r7,(1)
	    jgfs    alos.5                  :if 3 Escape's,
                                              :Cancel the login ...
              lhi     r0,-1,r12               :adjust to get actual data count,
              jal     r4,FLUSH                :Flush the current ISIS packet,
              stb     r9,zrzn,rUCB            :for zhost to stop retrying.  
	      jal     r9,ZHOST                :Clean out Host,

              j       IDLE                    :Exit to idle.
alos.3
	  lis	  r7,3                  :not esc, reset count.

alos.5    hs      0

	  clhi	  r6,(ubufSizCon-3)
	  iff(ge)       		:if already full,
            lr    r2,RTSATSider10
            la    r3,belbuf
            LHI   R1,$07F               :set mask = 7bit    
            jal   r5,OCSMS              :beep him.
          orelse                        :else ubufer has room...
            CHI   R3,CR                 : if cr/semi/esc then
            JE    ALOS.8              
            CHI   R3,ESCAPE   
            JE    ALOS.8
            CHI   R3,SEMICOLON
            JN    ALOS.9
ALOS.8
              TBT     R10,LGWAIT
              IFF(N,SHORT)               : if login process waiting
                RBT   RTSATSIDER10,LGWAIT  :  wakeup login process
                LH    R3,HOSTSIDE,RUCB
                SBT   R3,LOGONPORT
              ENDIF
ALOS.9              
  	    stb     r0,(ubufer),rUCB,r6     :accum his type-in.
	    stb     r9,(ubufer+1),rUCB,r6   :keep double-z on the end.
	    stb     r9,(ubufer+2),rUCB,r6
	    ais	    r6,(1)
            stb     r6,LGFILL,rUCB          :save the index
          endif

          DO        :do while a yellow ball outstanding
    	    JALR        R5,R11
            L           R4,YBTIMER,RUCB
            CL          R4,SLOWC,,
            IFF(L,SHORT)       :if timeout then collecting data again
              LIS       R4,0
              ST        R4,YBTIMER,RUCB
            ENDIF
            LR          R4,R4
          ENDDO(WHILE,N)
	enddo                         :forever.

:--------------------------------
: BGUSER - Beginning of the User Process for the Tymsat.
:   The process begins here after the Needle, as soon as the user has been
:   validated.
:   This is the beginning of the TSAT co-process and RRETTOchartsupR11 is set.
:   No character has been consumed yet.  When we are ready to accept a char,
:   we will call via the coroutine link using ..
:       jalr    r5,r11
:
:   The routine asks for password, sends echo message to Tsat, does pause,
:   then does auto login or jumps to CMDMODE.
:
: In- R11 - Co-Link return to get another character.
:     R12 - after we call once for a character, is the remaining size of
:     the current ISIS packet, including the current char.
: R6, r7, r9 are preserved through the coroutine call.
:
:   No Echo-On has been sent to the Sat yet.  Thus if we read a password,
:   the Sat will not echo it.

BGUSER  HS      0
        lis     r12,0                   :initial condition, no characters.
	lb	r9,(relativeHost),rUCB

	tbt	r9,(npawBA)
        iff(e)                          :if not "no pause",
          jal     r6,prHit		  :"mash a button to continue"
          jalr    rAddOfEntryR5,rRetToCharSupR11  :call for a char.
        endif

	jal	  r6,PrME		:Display the menu, if any.

    : ASKFORselbkthruco is where various branches of the command process
    : jump back to, to ask for the command again ...
AskForSelBkThruCo  hs  0

	lb	r9,(relativeHost),rUCB
	tbt	r9,(aselBA)

        iff(n)      	       		:if host is auto select...
          lis     r6,0
          sth     r6,UTRIES,rUCB          :zero how many login tries.
	  slls	  r9,(3)		  :host * 8,
	  l	  r9,(CT),r9,             :point at the 1st command entry,
	  l	  r9,(0c),r9		  :12 past is address of commands.
          st      r9,UCMPTR,rUCB          :remember code, for retry.
	  jr	  r9                      :Go do the commands.
        endif                           :endif autoselect

	jal	  r6,PrSE		:"pick your poison"

        jalr    rAddOfEntryR5,rRetToCharSupR11  :call for a char.
        j       CMNDMOde                        :go use it.

        SUBTTL MAIN HOST DATA HANDLER CO-ROUTINES (MHOHAN.S30)
:(MENUDEV:39)MHOHAN.S30
: Enhanced from MHOHAN.S30 for new feature in MSV3.00
:       for katakana - match/send 7bit or 8bit depends on TSAT mode
:       for multipassword - add an password opcode

:(J.BURKE)MHOHAN.S20
: Extrated from  MSHAND.S13 and MSICM.S13.    JSB,01/13/87.
:    Fix Match-String feature so it no longers depends on ISIS packet
:    boundaries.
:
: Host-circuit Data Handler.

:------------------------------
: BEGHOS - beginning of the Host Process after B6 is rcvd.
:   It performs the host-login phase, sends data
:   immediately from ubufer until a match string, reads through
:   co-link to do the match then sends more if any or a password 
:   command, gets the required psw from password array and sends to 
:   host. If the psw is not ready, this process is suspended until
:   the complete psw is received. At the end of the ubufer,
:   it goes out to HOSTTOTSAT which handles the transparent
:   connection betwen host and user.
:   R13, R10, R12, R6 are preserved. Others are destroyed. 
:
:In-  R12- ISIS message count.
:     R0 - next character.
:     R10- the port number of the TSAT side.
:     R13- the ucb base for this port
:Exit through Co-routine link:
:     R12- Remaining character count plus 1.  Thus, you don't decrement
:          the count for a single character, but only when you call GETCH
:          to consume additional characters.
:
: Co-link:  We call for more characters with:
:          jalr   RADDOFentryr5,RRETTOcharsupr11   

BEGHOS  hs      0

        :Loop while there is stuff in UBFFER, acting on what's in it
        : (sending, matching, etc...)
        DO(FOREVER)
           lb   r9,(loginEmptyIndex),rUCB
           lb   r0,(ubufer),r9,rUCB         :(get the char in the ubufer)
                
           IFF(N,THEN)  :(whether it is the end, the action code or the data)

                :Current byte is nonzero. It is data to be sent up the circuit
                :to the host. This would be data from a c.string macro , or 
                :c.username, or c.password(if these are used to go through a 
                :gateway), or the user's typeahead...
                        
              jal       r7,sendData     :(put out char until the 00 terminator
                                        : or the maximum char count is reached)
                        :(after sending data, it goes to check the next char in
                        : the ubufer)

           ORELSE       :it's 'zero something' -is an action or 00,00(end mark)

              lb        r0,(ubufer+1),r9,rUCB  :where to investigate next
                
              IFF(E,SHORT)              :(00 means now buffer is empty)        
                        :Automatic login process is now complete. Set the user
                        :up for transparent transmission between host and user.
                        :then back to host handling routine in the main loop.

                 jal    r7,LODONE

                 jalr   r5,r11          :(return to caller)
                 j      HostToTsat

              ORELSE                    :Is 00,Code - Code in r0
                
                 stb    r0,CURCMD,rUCB  :(save the action code)
                 ais    r9,(2)          :(advance index to the match string)
                 stb    r9,(loginEmptyIndex),rUCB      :(save the index)

                 LR     R4,R0
                 CASE(R4)               :case of command
                   WHEN(OPSEEI)           : see including
                   ORWHEN(OPSEEU)         : seeupto
                   ORWHEN(OPTOSI)         : tossincluding
                   ORWHEN(OPTOSU)         : tossupto

                     JAL R6,MHSTR               :do match/send

                   WHEN(OPINFO)           : send information
                     JAL  R8,SNDINF             :in R9 - where to get the addr

                   WHEN(OPPSW)            : password

                     LB   R3,UBUFER,R9,RUCB     :get the pwindex
                     SLHLS R3,8
                     LB   R7,UBUFER+1,R9,RUCB
                     OR   R3,R7

                     AIS  R9,2                  :position after PW stuff
                     STB  R9,LOGINEMPTYINDEX,RUCB

                     STH  R3,CURPW,RUCB         :save the pwindex(offset)
                     LB   R7,PWARRY,R3,rucb         :1st byte in psw array
                     IFF(E)                     :if psw is not there
                       JAL      R7,INSPW        
                                :INSPW might suspend this process
                                :IN - R11 co-routine return addr
                                :     R13 rucb
                                : REG only R11,R13 preserved
                     ENDIF

                     LHI      R0,PWLEN+3      :request max room pwlen+3
                     LHL      R1,HOSTSIDE,RUCB

                     JAL      R4,SLOR         :we'll used ELODR

                     LHI      R8,PWLEN        :the max count will be
                     LH       R7,CURPW,RUCB   :load the offset

                     DO               :put char out
                       LB     R0,PWARRY,R7,rucb    
                       EXITDO(E,SHORT)        :quit when char = null
                       JAL    R4,PUTCH
                       AIS    R7,1
                       SIS    R8,1
                     ENDDO(WHILE,G)   :enddo while still room

                     JAL      R4,ELODR

                   OTHERWISE            :otherwise unknown op code
                     LH       R0,ERHCON,,     :set the error count
                     AIS      R0,1
                     STH      R0,ERHCON,,

                     LA       R3,ZMCON,,
                     LHI      R1,$07F
                     JAL      R5,SHIPTOTSAT
                 ENDCASE

              ENDIF                     :(test of buffer empty or command)
           ENDIF                        :(test current character- data or cmd)
        ENDDO                           :(end of loop while there is stuff in
                                        : UBUFFER)
        
:--------------------
: SNDINF subroutine -  send the string to the user
: LINK  R8
: IN    R9 - where to get the string address 
:       R13- rucb
:       R10- Tsat port#
SNDINF  HS      0
        ST      R8,SCRA2

        LB      R7,UBUFER,R9,RUCB       :get the address of the string
        SLLS    R7,8
        LB      R3,UBUFER+1,R9,RUCB
        OR      R7,R3
        SLLS    R7,8
        LB      R3,UBUFER+2,R9,RUCB
        OR      R7,R3
        SLLS    R7,8
        LB      R3,UBUFER+3,R9,RUCB
        OR      R7,R3

        AIS     R9,4                    :advance the index
        STB     R9,LOGINEMPTY,RUCB

        JAL     R6,PX1,,
                :In r7-point to the begining of the string
                :destroy r0-r8
        L       R8,SCRA2
        JR      R8
:--------------------
: MHSTR subroutine - match a host string.
:       It performs co-call for host data
: LINK  R6
: IN    R11 - co-routine return address
:       R13 - rucb
:       R10 - Tsat side port #
:
MHSTR
        ST     R6,RTNAD1,RUCB
        lis    r8,(0)
        stb    r8,(matchIndex),rUCB    :(initial match index)


        DO(FOREVER)                  :(now looking for a match)
          
          jalr  r5,r11                :(call through host co-link)
                :R12 has the IRCOUNT  R0 contains the character

          lr  r7,r0           :(save the char)        

          lhi r0,$09D+3       :(ask for max room in ORING)
          lr  r1,rTsatSideR10
          jal r4,SLOR
          sth r15,SAVEOX      :(save the oring index)

          lb  r9,(loginEmptyIndex),rUCB
          lb  r3,(matchIndex),rUCB
          ar  r9,r3          :(setup the index)

          lr  r0,r7           :(get the current input char)


          DO(FOREVER) : loop on isis packet
                      :In this loop - the Oring will remain opened 
                      :until a match is successful. All registers
                      :  are been used
                      :R0 - the char form the Iring
                      :R3 - the index of the matched string
                      :R9 - the index of the ubufer
                      :R11- the co-link register
                      :R12- the iring count
                      :R14- the iring pointer
                      :R15- the oring pointer

             lb       r1,(ubufer),r9,rUCB     :(get the match char)

             LH       R8,TSATSIDE,RUCB        :get sat port#
             TBT      R8,ETMOUT               :check SAT mode
             IFF(LE,SHORT)                    :if not in transparent
               xr       r1,r0                   :(do a 7 bit 
               nhi      r1,$07F                 :    match)
             ORELSE(SHORT)                    :else transparent
               XR       R1,R0                   :do a 8bit match
             ENDIF

             LR       R1,R1
             IFF(E,SHORT)                     :(if this char matched)
                stb   r0,MCHOLD,r3,rUCB       :(save matched char)
                ais   r3,(1)                  :(advance the index of
                                              : the match string)
                ais   r9,(1)                  :(advance the index of
                                              : the Ubufer )
                lb    r1,(ubufer),r9,rUCB     :(get next match char)

                je    xGotMatch               :(match was sucessful)
                :(xGotMatch puts characters at MCHOLD if action code 
                : is SEEINC or TOSUP and then call ELODR if there is
                : character in the oring)      

             ORELSE                           :(does not match)
                lb  r8,CURCMD,rUCB            :(get the current cmd)
                lr  r3,r3                     :(check match index)

                IFF(G)                        :(yes, there are some
                                              : saved characters.)
                   chi r8,OPSEEU              :(is TOSSxxx or SEExxx)

                   IFF(LE)                    :(if command is seexxx)
                      lis     r8,0
                      lr      r7,r0           :(save the unmatched
                                              : character)
                      DO(COUNT,r3,SHORT)      :send the saved char 
                                              : to terminal)
                         lb   r0,MCHOLD,r8,rUCB
                         jal  r4,PUTCH
                         ais  r8,(1)
                      ENDDO

                      lr      r0,r7           :(the unmatched char)
                      jal     r4,PUTCH
                   ENDIF

                   lb r9,(loginEmptyIndex),rUCB      :(reset index)
                   lis     r3,(0)             :(match index = 0)
                ORELSE(SHORT)                 :no match char on hold
                   chi     r8,OPSEEU 
                   IFF(LE,SHORT)              :If command is SEExxx
                      jal  r4,PUTCH           :put the unmatched one
                   ENDIF
               ENDIF                         :(whether char matches)

             ENDIF    :(whether the char matches.)  

             chi      R12,(1)         :(check the IRing count)

             EXITDO(LE)               :(get the next input packet)

             jalr     r5,r11          :(the co-routine supplies
                      : the next input char and decrement the 
                      : IRCOUNT. R0-R5,R14 is used
                      : R12 - the ircount
                      : R14- the iring index
          ENDDO       :(forever,end loop in isis packet)

          stb   r3,matchindex,rUCB    :(save the current 
                                      : match index)
          ch    r15,SAVEOX  
          IFF(N,SHORT)                :(if something in the ORING)
             jal   r4,ELODR
          ENDIF 
       ENDDO                  :(forever,end looking for a match)


xGotMatch        hs      0

       :xGoMatch is called when match was successful. It handles the
       : characters in MCHOLD and closes the output message if there
       : is character(s) in the ORING.

       lb      r8,CURCMD,rUCB  :(get the current command)
       chi     r8,OPSEEU       :(check the current action code)
       je      xGot1           :(jump if the action code is Seeupto)
       chi     r8,OPTOSI 
       je      xGot1           :(jump if the action code is tossinc)
       lis     r8,(0)
                               :the action code is seeinc or tossupto
       DO(COUNT,r3,SHORT)      :put the characters in MCHOLD to Oring
          lb   r0,MCHOLD,r8,rUCB
          jal  r4,PUTCH
          ais  r8,(1)        
       ENDDO

xGot1            hs     0
       ch      r15,SAVEOX      :(compare the current oring index 
                               :   with the original index)
       IFF(N,SHORT)            :(yes, we got some)
          jal  r4,ELODR
       ENDIF

       ais     r9,(1)        :skip the ending'00', to the next one
       stb     r9,LoginEmptyIndex,rUCB

       L       R6,RTNAD1,RUCB
       JR      R6


:SendData Subroutine -- 
:     It puts out char from ubufer until the 00 terminator or we make an ISIS
:     packet of size $09D.
:     (Note: backpressure from host is not respected here.)
:     input: r7 is the link register
:     R0,R1,R3,R4,R8 are destroyed.
:     R9 (input and output ) carries the index where to investigate next in
:     the Ubufer. EXIT - points to the 00 terminator.
      
  
sendData        hs      0

        lhi     r0,$09D+3               :ask for max room in ORING
        lhl     r1,(hostSide),rUCB      :load the port number

        jal     r4,SLOR                 :in here we will use ELODR.

        lhi     r8,$09D                 :init,can put max count
        do
           lb   r0,(ubufer),r9,rUCB
           exitdo(e,short)              :EXITDO if char is zero.

           jal  r4,PUTCH
           ais  r9,1                   :bump source
           sis  r8,1                    :decrement room in packet
        enddo(while,g)                  :ENDDO while still room.

        jal     r4,ELODR                :finish the packet.

        stb     r9,(loginEmptyIndex),rUCB      :where to investigate next
        jr      R7


:LODONE Subroutine --
:     It is called when the ubufer is empty
:     It sets the user up for transparent transmission between host and user
:     then get the Sat and the Host into agreement on Echo...
:     Destroys R0-R5 and R8.
:Link register - R7
:IN - R10 contains the port number of the TSAT side

LODONE  hs      0
        la      r0,Send2Host            :set transparent send to host
        st      r0,TsatDataHandler,rUCB : to be the handler

        lhl     r8,(hostSide),rUCB
        st      r8,(saveR6),rUCB        :send2host expects r6 to have host port

        lis     r0,(0)
        st      r0,(saveR7),rUCB        :send2host expects r7 to have 0 init
        stb     r0,ZRZN,rUCB            :reset the zap reason                

        lhi     r0,cstco                :put Sat in T_COnnected State.
        stb     r0,cstate,RTSATSider10

        l       r0,slowc,,
        st      r0,HTOLAC,rUCB          :start to count the host timeout

        :get the Sat and the host into agreement on Echo...
        :If the host has turned on echo, then the host needs DEM, and
        :this has to come from the Sat. An Echo_off then on will force
        :the DEM up.  After that, we will get into exchange of echo if the 
        :host has turned echo on. We will pass on the Echo_on, then
        :Sat will start up with Greenball, etc...

        lr      r2,RTSATSider10         :sat port.
        la      r3,ECHOOFfbu            :do Echo_off in any case.
        jal     r5,OCM
        rbt     r2,green                :forget any greenie from Sat
        rbt     r2,DEM                  :we will not echo here for Sat
        tbt     r8,ECHO
        iff(n,short)                    :if host has sent Echo_on
                                        :then the off/on will force DEM
           lr   r2,RTSATSider10         :Sat port.
           la   r3,ECHOONbuf            :now turn it on like host says
           jal  r5,OCM
        endif

        jr      r7


:--------------------
: HOSTTOTSAT - Host process entry point.
:     HOSTTOtsat is the processor for the host data after the host login
:     procedure is completed and the user is connected to the host.
:     It passes an entire ISIS data packet (or the tail end) from the host
:     to the user. It returns to the colink when done with that input isis
:     message.
:
:     It is also used some of the time during Host Login, notably when
:     waiting for the user to enter a password.
:
: IN - R0  the input char
:      R12 the input count
:      R10 the Tsat port number
: LINK - R11
:        R5 handlering routine address( preserved )
: register destoryed - R0 through R4, R8


HOSTTOtsat      hs      0
        lr      r8,r0                   :save the input char
        lr      r1,rTsatSideR10         :the port number
        lhi     r0,(3),R12              :the size required
        jal     r4,SLOR

        lr      r0,r8                   :get the char back
        jal     r4,PUTCH                :put it.

        sis     r12,1                   :count 1 off
        DO(WHILE,G,SHORT)               :do while still has input ...
           jal  r4,GETCH                  :get the next input char
           jal  r4,PUTCH                  :pass the input char to Tsat
           sis  r12,1
        ENDDO
	jal	r4,ELODR                :close the packet.
        ais     r12,1                   :re-adjust count for exit.

        jr      r11                     :go back to the co-routine, wait
                                        :next input message from host.
:(menudev)mscman.s32 by JH, 02/29/88
:change those instructions which refer to CT table into RX3

:(J.BURKE)MSCMAN.S13
:   Split out from MC.R12 by JSB, 11/5/86.
 
        subttl logic to decode and execute a command (MSCMAN.Sxx)
 
: eat until timeout or an orange ball appears
: get here from zap logic or after the user types a bad command
 
Eat
          jalr    rAddOfEntryR5,rRetToCharSupR11
 
        l       r4,(YBtimer),rUCB
        jebs    Eat                     :if 0, means dead circuit
 
        cl      r4,(SlowC),,
        jgbs    Eat                     :Yellow-Orange balls being timed
 
: timed out, Yellow or Orange ball must have gotten lost
 
        lis     r4,(0)
        st      r4,(YBtimer),rUCB
        j       CmndMode
 
 
: - - - - - - - - - - - - - - - -
: CMNDMOde - This is the handler which has control for the Sat port
:   after the menu is displayed and the user is typing his/her selection.
:   Calls GETTOKen to collect the user's entry.  GETTOKen calls through the
:   coroutine linkage to receive the characters.
:
: GETTOKen exits to TOOMANy if the user types more than our limit,
:          exits to ASKFORsel<Etc.> if the user hits the ESC key.
 
CmndMode
        lcs     R6,(0c)                 :-12, our limit is 12 characters,
        la      R7,(ubufer+0c),rUCB     :point at end of where to put it,
        jal     r9,GetToken             :collect it.
 
        chi     R6,(-0c)
        je      JustCR                  :if nothing was entered
 
rBegTabAddrR6   eq      6               :address of the beginning of the table
rStrAddrR7      eq      7               :address of the string to find a match of
rEndTabAddrR9   eq      9               :address of the end of the table
rSizeOf1entryR2 eq      2               :size of one table entry
 
LookItUp
        lb      r8,(relativeHost),rUCB
        slls    r8,(3)                  :mult * 8 (that's 2 words worth)
 
        l       rBegTabAddrR6,(CT),r8,  :point to Command Table,
        la      rStrAddrR7,(ubufer),rUCB  :string to match,
        l       rEndTabAddrR9,(CT+4),r8,  :end of table,
        lhi     rSizeOf1entryR2,(10)    :size of a table entry,
 
        do                              :DO over Cmd Table ..
          jal     r4,MTCH
            jfs     cmo7                    :+0 exit, no match yet
                                          :+2 exit, match, go on.
        : Found the command in the table,
        : R6= table entry...
cmo5        lis     r9,0
            stb     r9,TOARRAy,RTSATSider10  :turn off menu inact. T.O.
            sth     r9,UTRIES,rUCB          :zero how many login tries.
            l       r5,(0c),r6              :pick up the process,
            st      r5,UCMPTR,rUCB          :remember code, for retry.
 
            jr      r5                      :Go do the guy's command.
 
cmo7      ar      rBegTabAddrR6,rSizeOf1entryR2
          cr      rBegTabAddrR6,rEndTabAddrR9
        enddo(while,l)                  :enddo, while pointer under the end.
 
        jal     r6,prIS                 :"Invalid selection please try again"
        jfs     yb
JustCR
        jal     r6,PrME                 :"menu"
        jal     r6,PrSE                 :"pick your poison"
        jfs     yb
TooMany
        jal     r6,prTM                 :"Too many characters, please try again"
yb
        lr      r2,rTsatSideR10
        la      r3,(YellowBuf)
        jal     r5,OCM                  :send a YELLOW BALL
 
        l       r0,(SlowC),,
        ais     r0,(0a)
        st      r0,(YBtimer),rUCB
 
        j       Eat
 
 
:---------
: MTCH subroutine - Compare two strings with zero-byte delimiters.
:In - R4 link.
:     R6=RBEGTAbaddrr6 points to 1st string, "The Table Entry".
:           Case is ignored in this string (made uppercase for compare).
:     R7=RSTRADdrr7 points to the 2nd string, "The String".  This string
:           must be uppercase or alpha will not match.
:
: Exit jump to +0 = Failure,
:              +2 = Success.
: Destroys r5, r8.
 
MTCH    hs      0
        lcs     r5,(1)                  : index, init to -1,
        DO                              :DO over the Table Entry ..
MAS1      ais     r5,(1)                  :bump index.
          lb      r8,(0),RBEGTAbaddrr6,r5 :next char of Table Entry,
          jn      MAS6                    :IF hit its delimiter, THEN..
MAS3      lb      r8,(0),RSTRADdrr7,r5
 
          jnr     r4                        :EXIT +0, fail, string is longer.
          j       2,r4                      :EXIT +2, finished the string.
 
                : r8 is char from the table entry ...
MAS6      chi     r8,(61+80)              :"a" 80 ALWAYS on cuz of assembler
          jlfs    MAS8
          chi     r8,(7a+80)              :"z"
          jgfs    MAS8
 
            shi     r8,(20)                 :convert Table Entry to uppercase.
MAS8      hs      0
          LB     r0,(0),rStrAddrR7,r5
          XR     R8,R0
          NHI    R8,$07F                  :only 7bit. in cmd match both string
                                          :have 8bit set. in MA match username
                                          :only has 7bit.
        ENDDO(WHILE,E)                  :ENDDO, while chars match (if String
                                        : byte=0, will not match.)
 
        jr      r4                      :EXIT +0, failure.
 
: GETTOKen subroutine: accumulate token which the user is typing.
: Calls through the coroutine linkage to get characters.
: Converts the alpha to uppercase and OR's each character with $080.
: Puts a zero after the last accumulated character.
 
: EXIT to TOOMANy if the user types too many characters.
: EXIT to ASKFORselbkthruco if the user types ESC.
 
: R7 - points to last loc of place to accumulate.  The terminating zero
:      can go at 0,R7.
: R6 - is neg., is the index downward from R7, where to put next char.
:      Thus R6 is neg of how many characters, not including the terminating
:      zero.
: R9 - link.
: R11 - carrying coroutine linkage.
: R13=rUCB.
: R14 reserved for IRING.
:
: R0 thru R5, R8, R10, R12, R15 - destroyed.
 
gt0       jalr    rAddOfEntryR5,rRetToCharSupR11
 
GetToken  jal     r5,ECHOchar           :in: r0-char r10-port, out: r8-stripped
 
          lb      r1,(relativeHost),rUCB
          lb      r0,(tixTab),r1
          stb     r0,(ToArray),rTsatSideR10 :pump up inactivity timer
 
          ohi     r8,(80)
          clhi    r8,(CR)+$080
          jer     r9                    :got a "command", see what to do now
 
          clhi    r8,(Escape)+$080
          je      AskForSelBkThruCo
 
          chi     r8,(61+80)            :"a"
          jlfs    gt1
 
          chi     r8,(7a+80)            :"z"
          jgfs    gt1
 
            shi     r8,(20)             :convert WHAT TYPED IN to UPPER CASE
gt1
          stb     r8,(0),R7,R6 :put it in the buffer
 
          lis     r5,(0)
          stb     r5,(1),R7,R6 :put a "0" right after it
 
        ais     R6,(1)
        jle     gt0                     :loop until rIndexR6 = (+1)
 
        j       TooMany
 
	subttl Define Macros, do the Actions from Menu. (MACTIO.Sxx)

:(j.hsu)mactio.s33 06/15/88
:       string terminor should be "bc 0,0"

:(J.HSU)MACTIO.S30
:   from s20 JWH, 9/30/87
:   V3 R1. change for support katakana

:(J.BURKE)MACTIO.S20
:   from S13.  JSB, 1/12/87.
:   V2 R1.  Fix crash upon auto-sel plus pw.

:(J.BURKE)MACTIO.S13
:   Split out from MC.R13 by JSB, 11/5/86.

: This file contains all the code which sets up the steps of the users'
: login procedures.



: BLDCMDta Macro(command,address) - Build an entry in the Command Table.
: An entry is aligned to 4 bytes and has:
:     13 bytes - command string with 00 terminator.
:     3 bytes - address of the code to execute the command.

BldCmdTa macro (TEXT,ADDR)[
loc     ws      0
        ac      /TEXT/          
        bc      0               :assure one zero when .LT. 12 chars.
        org     (loc+0c)        :field is exactly 12 chars.
        wc      ADDR
        org     .-4
        bc      0               :assure zero when 12 chars.
        bnd     4
        kill    loc
]
        SEG     A.RDAT

KodeHandLogIn   hs  0    
        lhl     r2,(TsatSide),rUCB
        rbt     r2,(ECHO)		:turn off ECHO in tymsat side's par. tab. 
	sbt	r2,(handBA)		:when pn arrives we won't jump the gunb

        la      r3,(ECHOoffBuf),,
        jal     r5,OCM,,		:send ECHO OFF message (to "tymsat side")

	la	r3,(plimsg),,
        lhi     r1,$07F                 :set mask = 7bit
	jal	r5,shipToTsat,,		:say "[ms] please log in: "

	jal	r6,ReqPn

        la	rAddOfEntryR5,(HandLogIn),,
	jr	rRetToCharSupR11


: CDEINIt macro - This is the first code executed for every COMMANd, before
:   executing the series of action macroes.

CDEINIt macro  [
        if      .gt.(NRT|rhn||cmd|,$00ffff)!.lt.(NRT|rhn||cmd|,0)
          REMARK % *** a LOGINRETRIES value is out of range. %
        ei

        lhi     r7,NRT|rhn||cmd|
        sth     r7,UNRT,rUCB            :set the N-Retries value.

        if      LTO|rhn||cmd|           :if has login timeout
QL        eq    LTO|rhn||cmd|+TOINAC-1  :round up above integral TOINAC value
        else
QL        eq    0
        ei

        if      .gt.(QL,$00ffff)!.lt.(QL,0)
          REMARK % *** a LOGTIMEOUT value is out of range. %
        ei

        lhi     r7,QL
        sth     r7,ULTO,rUCB            :set the Login Timeout value.

        if      CTO|rhn||cmd|           :if has HOST timeout
QL        eq    CTO|rhn||cmd|+TOINAC-1  :round up above integral TOINAC value
        else
QL        eq    0
        ei

        if      .gt.(CTO|rhn||cmd|,$00ffff)!.lt.(CTO|rhn||cmd|,0)
          REMARK % *** a HOST TIMEOUT value is out of range. %
        ei

        lhi     r7,QL                   :get the current Host timeout
        sth     r7,UHTIVL,rUCB          :set the initial host timeout
        lhi     r0,zczap                :pre-set "circuit zapped"
        stb     r0,zrzn,rUCB            :as the zap reason.

	la      r7,HostToTsat,,         :initially, HOSTTOsat is
        st      r7,HSHAND,rUCB          :  the host data handler.
        la      r7,SAVETYpeahead,,      :and for the TSat, save the keystrokes
        st      r7,TSATDAtahand,rUCB    :   as type-ahead.
	lis	r8,2                    :Reset pointer to UBUFER.

	if     \(TPC|rhn|)
	  jal     r6,putTPC,,
	ei
   ]


: CDEROTor macro - select an entry from the rotor.
:   H|host||cmd|ENtryavailable bit array - This bit array has one's for
:           unused rotor entries.  On success, we clear the bit we find.
:           Must be in SEG 0.
:   H|host||cmd|COunt - How many bits in the bit array.
:   BABASE[UCB] (hw) will point to the bit array.
:   BABIT[UCB] (hw) will have the bit number which we found in the array.
:   The string from the rotor entry will be in the UBUFER.
:
:   On failure, BABIT[UCB] will be zero.  This code will display the NR
:   message (from the NR.String macroes). Then,
:   If the host is Auto-Select, log the user off.
:   Otherwise, go back to the menu.

CdeRotor macro[
	kill	cr1,cr2,sol,cr2.2
	lis	r1,(0)
cr1
	  lhl	  r2,(H|rhn||cmd|EntryAvailabilityBitArray),r1,
	  JFFOH	  r2,cr2                :jump, got one.

	ais	r1,(2)
	chi	r1,((H|rhn||cmd|CountOfElements+0f)/10)*2
	jlbs	cr1
	jfs	sol

cr2	j	cr2.2                   :(steppingstone, okay.)

sol	jal	r6,prNR,,       	:"no rotor entrys left"

	lb	r9,(relativeHost),rUCB
	tbt	r9,aselBA,,
        iff(n)           		:if auto select...
	  jal	  r6,PrLO,,               :"bye bye",

	  lhl	  r2,(TsatSide),rUCB
	  la	  r3,(DetachBuf),,
	  jal	  r5,OCM,,                :zap him.

        orelse                          :else
	  jal	r6,PrSE,,		  :"select an entry".
        endif                           :
        jalr	RADDOFentryr5,RRETTOcharsupr11  :wait for data.
        j       CMNDMOde,,

    : Got a rotor entry.
cr2.2   hs      0
	slhls	r1,(3)                  :group*8.
	ar	r3,r1                   :plus bit.

	rbt	r3,(H|rhn||cmd|EntryAvailabilityBitArray),,

	sth	r3,(BAbit),rUCB         :remember which bit he got.

	la	r4,(H|rhn||cmd|EntryAvailabilityBitArray),,
	sth	r4,(BAbase),rUCB        :remember which array.

	slhls	r3,5                    :entry index * 32.
	la	r7,(H|rhn||cmd|BaseOfRotorEntrys),r3,

        LB      R0,,R7                  :get the string type
        IFF(N,SHORT)                    :if it is 8bit string
          LHI   R3,$00FF
        ORELSE                          :else it is 7bit string
          LHI   R3,$07F
        ENDIF
        AIS     R7,1                    :pass the string type. point to data

	jal	r6,Mov2ubuf             :Copy entry to UBUFER.

	kill	cr1,cr2,sol,cr2.2
]

	if	\(unameUsed)
KodeUname         hs  0
          lr      r7,rUCB
          ai      r7,(userName)
          LHI     R3,$00FF              :mask for mov2ubuf
          jal     r6,Mov2ubuf,,
	  jr	  r0
	ei


:----------------
: CDEFIN macro - generate the final code after all the Action Macroes.
:   Login setup has been completed in UBUFER and we can now initiate the
:   actual logon process..

cdefin	macro    [
						:R8 points after UBUFER data,
            stb     r8,STYPEA,rUCB		:remember where Ty-ahead is.
	    jal     r7,KODFIN,,                 :prep done.  Start Login.
            jalr    rAddOfEntryR5,rRetToCharSupR11  :if any data comes in now,
            j       SaveTypeAhead,,                 :we will save type-ahead.
  ] 

:--------------------------------
: KODFIN subroutine - have finished the login-action macroes and all the
:   stuff is now in UBUFER.  Get Moving.
:   Called also to restart a failed login process.
:   The login-action macroes have deposited their data and commands in
:   UBUFER.
:   We issue the response to pseudo-needle.
:
:In - R7 -link.
:     R8 - current pointer into UBUFER, points after the last data.
:     rUCB.
:Destroys R0 through R6.

KODFIN  hs      0
        lis     r1,(0)
        stb     r1,(ubufer),r8,rUCB	:put two zeroes at end of UBUFER.
        stb     r1,(ubufer+1),r8,rUCB
	stb	r8,LGFILL,rUCB	        :point to where to put type-ins.

        lis     r0,(2)
        stb	r0,(loginEmptyIndex),rUCB  :initialize where to put/get string

	jal     r6,ReqPn		:ask for a Psuedo-Needle.
        lh      r6,ULTO,rUCB
        sth     r6,ULCLK,rUCB           :Begin countdown on the Login Timeout.
        jr      r7                    :EXIT.


:--------------------------------
: REQPN subroutine - issue the Request-for-Psneedle.
:   Note that we use the UCB pointer as the local key!
: In - RUCB, UCB pointer.
: Link - R6.
: Destroys R0 through R5.

ReqPn   hs      0
	sth	rUCB,(PnLkey)		:local key

	lhl	r2,(IIX),rUCB		:smarts (from needle)
	ohi	r2,$2 0100000000000000	:request Extended login-status
	sth	r2,(PnDial)

	lb	r2,(relativeHost),rUCB
	lhl	r2,(HOSTS),r2,r2
	sth	r2,(PnHost)		:host (lifted from needle)

	lb	r2,(NID),rUCB
	stb	r2,(PnNID)		:NID (from needle)

	lis	r2,(0)			:send to PORT 0
	la	r3,(PnReqBuf)
	jal	r5,OCM,,		:send a REQUEST PSEUDO NEEDLE msg

	jr	r6


:----------------
: CDESTR macro(text,STRTYP) - do a C.STRIng macro. Moves the string to UBUFER
:   a mask is setup for mov2ubuf in order to purduce the following results.
:   FOR AN 8BIT STRING THEN MOVES ALL 8BITS OF A CHARACTER.
:   FOR A 7BIT STRING, CLEARS THE PARITY BIT THEN MOVES THE CHAR.
CdeStr	macro   (TEXT,STRTYP)[

        SEG     A.TEXT
        IF  STRTYP
TAG        XC   TEXT
        ELSE
tag	   ac   ~TEXT~                  :00 terminator is not moved to UBUFER.
        EI
        BC      0

        SEG     A.RDAT
	la      r7,(TAG),,
        kill    tag

        IF STRTYP
           LHI  R3,$00FF                :FOR 8BIT STRING MOVE AS IT IS
        ELSE                            :CLEAR 8TH BIT FOR 7BIT STRING
           LHI  R3,$07F                 :SET UP THE MASK
        EI
	jal     r6,Mov2ubuf,,		:move the string into UBUFER 
]

:----------------
: CDEMATch macro(kind,text,STRTYP) - used for all match-string macroes.
:   Calls MATCHCommon which inserts
:       00,kind,string ... ,00
:   into UBUFER.  The first 00 byte indicates an op-code follows.  "kind"
:   is the opcode in Ascii, and should be one byte, not hex 00.
:   A mask is setup for MATCHCOMMON in order to move the right value
:   into ubuffer.
:   The final 00 byte terminates the string.
CdeMatch macro   (KIND,TEXT,STRTYP)[

        SEG     A.TEXT
tag
        IF STRTYP                       :IF IT IS AN 8BIT STRING
           XC   TEXT                    :8BIT STRING SHOULD BE IN HEX
        ELSE
   	   ac	~TEXT~
        EI
	bc	0			:Terminator for Mov2ubuf,
                                        :  does not get moved to UBUFER.
        SEG     A.RDAT
	la      r7,(TAG),,
        kill    tag

        IF STRTYP
           LHI  R3,$00FF
        ELSE
           LHI  R3,$07F
        EI

        LHI     R4,KIND
	jal	r0,Matchcommon,,
]

:----------------
: MATCHCommon subroutine - move 00,data,00 into UBUFER.
:
: link r0.
: R3 - the  mask used by mov2ubuf.
: R4 - the op code
Matchcommon     hs  0
	jal	r6,putAzero,,

        STB     R4,UBUFER,R8,RUCB       :put the opcode
        AIS     R8,1

	jal     r6,Mov2ubuf,,
	jal	r6,putAzero
	jr	r0

putAzero        hs  0
	lis	r1,(0)
	stb	r1,(ubufer),r8,rUCB
	ais	r8,(1)
	jr	r6


:----------------
: CDEINFO macro(TEXT,STRTYP)- used for sending information to the user
:       moves "00,op-info,string-addr" to UBUFER. 
:       text - the string sent to the user
:       strtyp - the type of the string 8bits/7bits

CDEINFO MACRO(TEXT,STRTYP)[
        SEG     A.TEXT
INF.S
                IF STRTYP       :if defined an 8bit string
                   BC   1       :set 8bit flag
                   BS   1       :for length byte
QA                 XC   TEXT
LTH                EQ   .-QA
                   ORG  QA-1
                   BC   LTH
                   ORG  .+LTH
                   IF .GT.(LTH,9D)
                      REMARK %**** THE FOLLOWING STRING IS OVER THE
                      REMARK MAX OF THE ISIS DATA PACKET - 157 BYTES ****%
                   EI
                   BC   0,0       :terminator
                   KILL QA,LTH
                ELSE            :else defined a 7bit string
                   BC   0       :set 7bit flag
q                  eq   .       
                   sc   ~TEXT~
                   if q+$09d+1-.        :one string is limited to one ISIS PKT
                   else
                      REMARK % *** THE FOLLOWING STRING IS TOO BIG. 
                      REMARK LIMIT IS 156 CHARS:
                      REMARK :         'X'
                      REMARK % *** EXCESS WILL BE IGNORED.%
                   ei
                   BC   0,0       :terminator
                   kill q   
                EI

        SEG     A.RDAT
        HS      0

        JAL     R6,PUTAZERO,,
        LHI     R1,OPINFO               :the op-info
        STB     R1,UBUFER,R8,RUCB
        AIS     R8,1

        LA      R1,INF.S,,
        STB     R1,UBUFER+3,R8,RUCB
        SRLS    R1,8        
        STB     R1,UBUFER+2,R8,RUCB
        SRLS    R1,8        
        STB     R1,UBUFER+1,R8,RUCB
        SRLS    R1,8        
        STB     R1,UBUFER,R8,RUCB
        AIS     R8,4
        KILL    INF.S
]

:--------------------
: CDEPSW macro(pswidx) - used for c.password macro.
:       moves "00,pswcmd,pswidx" to UBUFER. pswcmd is op-code for 
:       password. pswidx is the offset from PWARRY.

CDEPSW  MACRO(PSWIDX)[
        SEG     A.RDAT
        HS      0     
    
        JAL     R6,PUTAZERO,,
        LHI     R1,OPPSW                :put the opcode
        STB     R1,UBUFER,R8,RUCB
        AIS     R8,1

        LHI     R1,PSWIDX               :put the offset
        STB     R1,UBUFER+1,R8,RUCB
        SRLS    R1,8
        STB     R1,UBUFER,R8,RUCB
        AIS     R8,2

        LHL     R2,TSATSIDE,RUCB        :to make sure the SAT in DEM
        LA      R3,ECHOOFFBUF,,
        JAL     R5,OCM,,
]


: PUTTPC subroutine -  gets called first thing, if the PASS.Tpc macro was
:   used (pass the user's Throughput Class along)...

putTPC  hs      0
	lb	r1,(TPC),rUCB
        nhi     r1,$083                 :only codes 0 through 3 are supported,
        iff(n)                          :if used,
	  ais	r1,(1)                    :make it ctl-A through ctl-D.
	  stb	r1,(ubufer),r8,rUCB
	  ais	r8,(1)
        endif
	jr	r6


:--------------------
: MOV2UBuf subroutine - move an AC string into UBUFER. It masks out the 
:   specified bit(s) before moving character into ubufer.
:   Stop at a zero terminator and do not move it.
: Link - r6.
: R3 - the mask
: R7 points to string.
: R8 - index to UBUFER.  Updated to next available location.

Mov2ubuf  hs    0
        lis     r1,(0)
mov1
          lb      r2,(0),r7,r1		:source = r7
          jer     r6              	:return when "0" found in "source"

          nr      r2,r3                 :mask the bit out
          stb     r2,(ubufer),r8,rUCB	:destination = r8
          ais     r8,(1)
          ais     r1,(1)

        jbs     mov1


:----------------
: KODEQUit - jump here for a QUIT command: log the user out.

KodeQuit        hs  0
	jal	r6,PrLO,,		:"bye bye"

	lhl	r2,(TsatSide),rUCB
	la	r3,(DetachBuf),,
	jal	r5,OCM,,		:send a DETACH message

	jal	r8,FreeUpUCB,,

	do(foreve)                      :sit here if any data.
	  jalr	  r5,rRetToCharSupR11
        enddo



: CDETXTbl macro - executed for a C.TEXT, display the text and give another
:   prompt ...

CdeTxtBl macro[
        SEG     A.TEXT
tag
w       eq      (H|rhn||cmd|F)
        re      (H|rhn||cmd|S)
          Str|w|
w	  eq      w+1
	er
        bc      0,0			:arnold

        SEG     A.RDAT
     	la      r7,(TAG),,
        kill    tag

        jal     r6,px1,,		:speak piece
	j	AskForSelBkThruCo,,
]

: - - - - - - - - - -
: Build the Command Tables...
:
:   Generate the label H|host|BCT for every host, generate the command
:   table, put the label H|host|ECT at the last+1 location.
:   First generate out every command from all the COMMAND macroes: each
:   of these is a macro CT|host||cmd|.
:   Then generate all the fixed commands which everyone always has.
:   Each entry is:
:           13 bytes command ending with 00, 3 bytes exec address.
:   The exec address is LH|host||cmd| for each command.  Jump to there to
:   begin performing the login sequence.

    : fist, define all the default commands ...

DFLCMS  MACRO  [
          BldCmdTa(VERSION,PrVerHst)
          BldCmdTa(VERSIO,PrVerHst)
          BldCmdTa(VERSI,PrVerHst)
          BldCmdTa(VERS,PrVerHst)
          BldCmdTa(VER,PrVerHst)
          BldCmdTa(VE,PrVerHst)
          BldCmdTa(HELP,PrHelp)
          BldCmdTa(HEL,PrHelp)
          BldCmdTa(HE,PrHelp)
          BldCmdTa(H,PrHelp)
	  BldCmdTa(TIME,PrDatTim)
	  BldCmdTa(TIM,PrDatTim)
	  BldCmdTa(TI,PrDatTim)
  ]

        SEG     A.TEXT
	nolist
	bnd	4
loc	eq	(.)
rhn	eq	0
	re	(h+1)           :DO for every host ..
H|rhn|BCT eq	  (.)
cmd	  eq      10			:STARTS AT 10!!!!
          re      (H|rhn|Ccnt)      :DO for every command under this host ...
            ct|rhn||cmd|(rhn,cmd)	:gen the command entry.
cmd	    eq      cmd+1
          er
          DFLCMS                        :gen the default commands.

H|rhn|ECT eq	  (.)
rhn	  eq	  rhn+1
	er

:
: Now the pointers to each host's command table.
: CT+8*h contains the 1st and last+1 addresses of the table for host h...

CT	eq	(.)
rhn	eq	0
	re	(h+1)
	  wc	  (H|rhn|BCT)
	  wc	  (H|rhn|ECT)
rhn	  eq	  rhn+1
	er
        SEG     A.RDAT
        HS      0

:----------------
: generate code sequences that perform network and host logon for each
: command.
: LH|host||cmd| is the label of the code to execute for each command,
: and this is what the Command table points to.
: We generate the code for each command by calling the macroes ..
:       Hhccmm
:   h - which host.
:   cc - which command.
:   m or mm - which Action Macro under the command.
:
: The Action macroes under a command each define one of these macroes.
: Generally each of these macroes puts some stuff in UBUFER: the required
: string, and perhaps a couple of code bytes.
:
: Note that the Command index 'cmd' always starts at hex 10, so that in the 
: name Hhccmm, the "cc" is always two characters, so you can tell the cc from
: the m or mm.

rhn	eq	0
	re	(h+1)
cmd	  eq      10			:STARTS AT 10!!!!
          HS      0
          re      (H|rhn|Ccnt)		:for the num of cmds per host
LH|rhn||cmd|
            CdeInit			    :Do initial set up for the command.

mac         eq      0
            re      (H|rhn||cmd|HowManyMacros)  :for every action under cmd..
              H|rhn||cmd||mac|			    :gen the code for
						    : the action.
mac           eq      mac+1
            er

	    cdefin

cmd         eq      cmd+1
          er
rhn	  eq	  rhn+1
	er

        SEG     A.TEXT

	subttl General stuff (MACTIO.Sxx)

: these are little lists (# of hosts in length) of pointers to the
: timeout, welcome etc. strings.

	bnd	4
TItab
rhn	eq	0
	re	(h+1)
	  if	  \(TI|rhn|)
	    wc	  (TI|rhn|)
	  else
	    wc    0
	  ei
rhn	  eq	  rhn+1
	er
WEtab
rhn	eq	0
	re	(h+1)
	  if	  \(WE|rhn|)
	    wc	  (WE|rhn|)
	  else
	    wc    0
	  ei
rhn	  eq	  rhn+1
	er
PAtab
rhn	eq	0
	re	(h+1)
	  if	  \(PA|rhn|)
	    wc	  (PA|rhn|)
	  else
	    wc    0
	  ei
rhn	  eq	  rhn+1
	er


:--------
: HOMPTS(mess) macro - Generate Host Message Pointers.
:   Generate a word array indexed by host ord, pointing to messages.
:   pointer is zero if the message is not already defined.
:   mess|host| must be the label of each message.

HOMPTS  macro(MESS)  [
MESS`TAB  ws    0
rhn	eq	0
	re	(h+1)
	  if	  \(MESS`|rhn|)
	    wc	  (MESS`|rhn|)
	  else
	    wc    0
	  ei
rhn	  eq	  rhn+1
	er
   ]

        HOMPTS(SE)                      :"Make your selection" messages.
        HOMPTS(ME)                      :The Menus.
        HOMPTS(HTO)                     :Host Timeout messages.
        HOMPTS(LTO)                     :Login Timeout messages.

	list

        SEG     A.CODE
PrHelp
	jal	r6,PrME			:"menu"
	j	AskForSelBkThruCo

: this batch has strings defined one way or another ([ms] or user defined)

: there is no PrNP (see needle processing)

PrHit					:after welcome
	lb	r1,(relativeHost),rUCB
	slls	r1,(2)
	l       r7,(Hittab),r1,
	j	px1
PrNR					:no rotor entries left
	lb	r1,(relativeHost),rUCB
	slls	r1,(2)
	l       r7,(NRtab),r1,
	j	px1
PrIS					:invalid selection
	lb	r1,(relativeHost),rUCB
	slls	r1,(2)
	l       r7,(IStab),r1,
	j	px1
PrTM					:too many characters
	lb	r1,(relativeHost),rUCB
	slls	r1,(2)
	l       r7,(TMtab),r1,
	j	px1
PrZap					:circuit went bye-bye
	lb	r1,(relativeHost),rUCB
	slls	r1,(2)
	l       r7,(Zaptab),r1,
	j	px1

: you might have a timeout specified, but no timeout string

PrTI					:timeout
	lb	r1,(relativeHost),rUCB
	slls	r1,(2)
	l       r7,(TItab),r1,
	jer	r6			
	j	px1

PrLO					:logoff
	lb	r1,(relativeHost),rUCB
	slls	r1,(2)
	l       r7,(LOtab),r1,
	jer	r6			:if no logoff string defined
	j	px1

PrWE					:welcome
	lb	r1,(relativeHost),rUCB
	slls	r1,(2)
	l       r7,(WEtab),r1,
	jer	r6
	j	px1
PrPA					:password
	lb	r1,(relativeHost),rUCB
	slls	r1,(2)
	l       r7,(PAtab),r1,
	jer	r6
	j	px1
PrSE					:"type your selection".
	lb	r1,(relativeHost),rUCB
	slls	r1,(2)
	l       r7,(SEtab),r1,
	jer	r6
	j  	px1
PrME					:menu
        LHL     R10,TSATSIDE,RUCB
        TBT     R10,ETMOUT
        IFF(E)
          LB    R1,RELATIVEHOST,RUCB
          LB    R3,MENU8,R1,
          IFF(N)
            LR  R2,R10
            LA  R3,ETMBUF
            JAL R5,OCM

            SBT R10,ETMOUT
            LB  R3,MSVETM,R10
            AIS R3,1
            STB R3,MSVETM,R10
          ENDIF
        ENDIF

        LB      R1,RELATIVEHOST,RUCB
        TBT     R1,CURTKL
        IFF(N)                          :if do have a tickler
          TBT  R10,ETMOUT         :check the mode?
          IFF(E)                  :if sat in non-transparent mode
            LB   R3,TKL8,R1,
            IFF(N)                :if 8bit tickler
              SBT  R10,ETMOUT
              LB   R3,MSVETM,R10
              AIS  R3,1
              STB  R3,MSVETM,R10

              LR   R2,R10
              LA   R3,ETMBUF      :send an ETM out
              JAL  R5,OCM

            ENDIF                 :endif 8bit tickler
          ENDIF                   :endif sat in non-trans mode
  
          LH    R2,TKLPNT,R1,R1         :the offset
          LA    R3,TKLMSC,R2,           :where is the msg
          JAL   R5,TKLD1                :destroy r0~r5
        ENDIF

	lb	r1,(relativeHost),rUCB
	slls	r1,(2)
	l       r7,(MEtab),r1,
	jer	r6
        jfs     px1

: PHOMSG subroutine: print the right message for the host.
:In - r6 link.
:     r7 points to the desired message pointers table (fullwords).
:     rUCB.
:   Prints the series of SC strings at where the host's pointer points,
:   a zero byte terminates it.

PHOMSG	lb	r1,(relativeHost),rUCB
	slls	r1,(2)                  :host*4,
	l       r7,0,r1,r7              :pick up this host's msg pointer,
        jer     r6                      :EXIT IF no message for this host.

        : preceding routines enter here at px1 ...
:PX1 - routine sends the message out.
: Message consists of string(s). Each string has the format as following
:       string-type/length/data...
: LINK ON R6
: R7 - point to begining of the string
: R0 - R0 ~ R8 are destroyed.

PX1       hs    0
          LIS   R8,0
          LB    R0,(1),R7               :get the string length
          DO(WHILE,N)     		:do while length <> 0 (not the end)
            LB  R0,0,R7                   :the string type        
            IFF(N)                        :if it is 8bit then
              LH    R10,TSATSIDE,RUCB       :TSAT port
              TBT   R10,ETMOUT
              IFF(LE)                       :if not in trnasparent mode
                LR      R2,R10
                LA      R3,ETMBUF
                JAL     R5,OCM                :send ETM
                
                SBT     R10,ETMOUT            :update the ETM flag
                LB      R3,MSVETM,R10
                AIS     R3,1
                STB     R3,MSVETM,R10

                LIS     R8,1                  :set the flag
              ENDIF                         :endif (not in trans)
              LHI     R1,$00FF              :set the 8bit mask
            ORELSE                        :else (7bits)
              LHI       R1,$07F               :set the 7BIT mask
            ENDIF                         :endif (8bits)

            LR      R3,R7
            AIS     R3,1          :point to the sc format
            JAL     R5,SHIPTOTSAT

            LB      R0,1,R7
            AR      R7,R0         :add the length
            AIS     R7,2          :idx = idx + length + 2 (2bytes overhead)
            LB      R0,1,R7       :get the length of next string    
          ENDDO                 :End do while(length not 0)

        LR      R8,R8
        IFF(N,SHORT)            :if sat mode has been changed
          LR    R2,R10
          LA    R3,LTMBUF
          JAL   R5,OCM          :send LTM to TSAT
          RBT   R10,ETMOUT      :update the ETM flag
          LB    R3,MSVLTM,R10
          AIS   R3,1
          STB   R3,MSVLTM,R10
        ENDIF

        JR      R6


: version command - print version/host message

PrVerHst
	la	r3,(where)
        lhi     r1,$07F                 :set mask = 7bit
	jal	r5,shipToTsat		:send "little" message

	lr	r8,rRetToCharSupR11	:sort of push

	lb	r9,(relativeHost),rUCB
	lis	r10,(1)
	la	r11,(rhnum)
	jal	r4,BinDec

	lr	rRetToCharSupR11,r8	:sort of pop

	slls	r9,(2)
	l	r3,(HnumTxtTab),r9
        lhi     r1,$07F                 :set mask = 7bit
	jal	r5,shipToTsat

	la	r3,(rhtxt)		:rh
        lhi     r1,$07F                 :set mask = 7bit
	jal	r5,shipToTsat

	la	r3,(whenTxt)
        lhi     r1,$07F                 :set mask = 7bit
	jal	r5,shipToTsat

	la	r3,(itxt)
        lhi     r1,$07F                 :set mask = 7bit
	jal	r5,shipToTsat

	la	r3,(rtxt)
        lhi     r1,$07F                 :set mask = 7bit
	jal	r5,shipToTsat

	if	\ttxt
	  la	  r3,(ttxt)
          lhi     r1,$07F                 :set mask = 7bit
	  jal	  r5,shipToTsat
	ei
        j       ASKFORselbkthruco


: time command - print date and time

PrDatTim
	lis	r4,($a13)		:store length in OCS format
	stb	r4,(ubufer+1),rUCB	:no seconds

	l	r3,(GMT),,		:time of day in ticks since...
	la	r5,(ubufer+2),rUCB	:put it here
	jal	r6,DaTime

	la	r3,(ubufer+1),rUCB
        lhi     r1,$07F                 :set mask = 7bit
	jal	r5,shipToTsat	

	j	AskForSelBkThruCo


:--------------------------------
: UNTESTED CODE ...
: 
: PrGrMes hs      0
: 	lb	r0,(GreetBuf),,
: 	je	AskForSelBkThruCo
: 
: 	la	r3,(GreetBuf),,		:say what's new
: 	jal	r5,shipToTsat
: 
: 	j	AskForSelBkThruCo
: 
: 
: : greeting command - set greeting message
: 
: SetGrBuf
: 	la	r7,(GreetBuf+1),,	:stick it here
: sgm1
: 	  la	  r6,(GrBufEnd),, 
: 	  sr	  r6,r7
: 	  jlefs	  sgm2
: 
: 	  jal	  r9,Str2Buf		:GET A LINE OF GREETING
: 	  lr	  r6,r6
: 	  jefs	  sgm2
: 
: 	  ar	  r7,r6
: 
: 	  lis	  r0,(LF)
: 	  stb	  r0,(1),r7
: 
: 	  ais	  r7,(2)
: 	j	sgm1
: 
: sgm2
: 	si	r7,(GreetBuf+1)
: 	stb	r7,(GreetBuf),,
: 
: 	la	r4,(UCBbase+flagBits)
: sgm3
: 	  lhl	  r7,(0),r4
: 	  ohi	  r7,(fMsgPr)
: 	  sth	  r7,(0),r4
: 
: 	ahi	r4,(UCBlength)
: 	chi	r4,(pastTheEnd)
: 	jlbs	sgm3
: 
: 	j	AskForSelBkThruCo
: 
: : Str2Buf - GET A STRING, PLACE IN BUFFER used by "set greeting message"
: :
: :	R6 - IN: maximim allowed length of string
: :	     OUT: length of string
: :
: :	R7 - where to stick string
: :	R9 - LINK
: :	R10- tymsat side
: :	rRetToCharSupR11- where character supplier routine is to be entered
: :	rUCB- USER BASE REGISTER
: 
: Str2Buf
: 	sth	r6,(strSiz),rUCB 
: sb1
: 	lis	r6,(0)
: sb2
: 	  jalr	  rAddOfEntryR5,rRetToCharSupR11
: 	  jal	  r5,ECHOchar
: 
: 	lbr	r8,r8			:null?
: 	jebs	sb2
: 
: 	clhi	r8,(ctlQ)
: 	jefs	sb4
: 
: 	clhi	r8,(ctlH)
: 	jefs	sb3
: 
: 	clhi	r8,(ctlA)
: 	jnfs	sb5
: 
: 	la	r3,(BKSPbuf)
: 	jal	r5,shipToTsat
: sb3
: 	sis	r6,(1)
: 	jg	sb2			:get PREVIOUS characters
: 
: sb4
: 	la	r3,(UPCURbuf)		:"^",<CR>,<LF>
: 	jal	r5,shipToTsat
: 	j	sb1
: 
: sb5
:         clhi    r8,(CR)
:         jefs	sb6
: 
: 	stb	r8,(0),r7,r6
: 
: 	ais	r6,(1)
: 	clh	r6,(strSiz),rUCB
: 	jl	sb2			:(fall thru if too long)
: 
: 	la	r3,(CRLFbuf)
: 	jal	r5,shipToTsat
: 
: 	lis	r8,(CR)
: sb6
: 	sth	r6,(strSiz),rUCB
: 
: 	stb	r8,(0),r7,r6		:uncounted
: 
: 	jr	r9
:--------------------------------
	subttl  MSICM.Sxx, Menu, handle ISIS non-data message types.

: msicm.s32 jwh 04/07/88,
:   menstp pass b1 to host only if it has a true circuit

:(menudev:39)MSICM.S30 JWH, 09/24/87, V2 R1
:   MSV keeps track of ETM/LTM messages and then pass those on.
:   B4 - change are made to allow user to re-enter password.
:   B6 - send B7 message for host accounting.

:(J.BURKE)MSICM.S20
: JSB, 01/12/87, V2 R1.
:   Remove the host auto-logon process which follows after receiving
:   successful login (B6), to MHOHAN.

:(J.BURKE)MSICM.S13
:
: JSB,11/5/86:
:   Correct errors in echo handling: introduce different tables for
:   ISIS messages for host, menu state, and terml connected state.
:   Pass through all echo-related functions when the user is connected
:   to a host.
:
: Split out from MC.R12, JSB, 11/5/86.

: ICMAND - Tymnet handling (for circuits we have already).
:   This is where the IRING interpreter jumps upon non-data messages,
:   except for Needle and B2 (psneedle).  Port is already checked for
:   validity.
:
:   There are different command tables for the ports in different states:
:       MENTBL: table for user (Tsat) ports while the user is in menu mode.
:       HOTTBL: table for circuits to hosts.
:       TCOTBL: table for user connected to a host.  This table is set up
:               for a Tsat circuit after its auto-logon procedures are
:               finished and we make the transparent connection between
:               user and host.
:
:   R1 - port it came on.
:   R2 - message type.
:   R10 (RTSATSider10) - Tsat port from UCB.
:   R13 (RUCB) - UCB address, is valid.

    : first, catastrophic fault (e.g. IRING garbaged) ..
WRONGO  hs      0
	jal	r10,CRASH
	bc	0,0,(rMsgTypeR2*4),(bumType)

ICMAND
        clh     RMSGTYper2,MAXMSG,,     :Every msg ISIS knows ..
	jgbs	WRONGO                  :jump, bigger than ISIS max,
                                        :  IRING is garbaged.
        clhi    RMSGTYper2,icmmax
        jg      consume                 :jump, consume, we don't know it.

        lb      r4,cstate,r1            :port's state,
        lhl     r3,cmpoi,r4             :point to the correct commands table
                                        :for this port's state,
        la      r4,0,rMsgTypeR2,rMsgTypeR2   :(command*2)
        lhl     r3,cmdbas,r3,r4              :pick up handler [port,command],
	j	cmdbas,r3                    :jump there.

:      - - - -
: Command Table pointers and definition of the Circuit States used in
:   CSTATE.
:   The order of these state values is significant.  Do not change the order,
:   and add new states in the correct section of the definitions.
:   Every state is either Host or Sat, never both.

cmpoi   hs      0
csmenu  eq      .-cmpoi         :Menu State.
        hc      mentbl-cmdbas
cshost  eq      .-cmpoi         :Host.
        hc      hottbl-cmdbas
	    : CSTCO is for transparent connection ...
cstco   eq      .-cmpoi         :Sat Terminal-COnnected State.
        hc      tcotbl-cmdbas
            : CSMALG is for MA login
CSMALG  EQ      .-CMPOI         :user is M.A.
        HC      MENTBL-CMDBAS

: MENTBL - table used for user (Tsat) circuit while at the menu, kept up
:       until an automatic logon procedure completes ...

        hs      0
MENTBL  eq      .-2*09e
	hc	Consume-cmdbas	:9e - detach (odd that we don't allow this)
	hc	ZapIn-cmdbas    :9f - disconnect (zapper)
        hc	PassOn-cmdbas	:a0 - apply backpressure 
	hc	PassOn-cmdbas	:a1 - release backpressure
	hc	PassOn-cmdbas	:a2 - flush output (this dir) (gobbler) 
	hc	Consume-cmdbas	:a3 - flush input (PWD says: show me one)
	hc	BlkIn-cmdbas	:a4 - data lost in this dir (BLACK ball)
	hc	GryIn-cmdbas	:a5 - data lost in opposite dir (GRAY ball)
	hc	MENEDM-cmdbas	:a6 - enter DEM
	hc	MENLDM-cmdbas	:a7 - leave DEM
	hc	SNDETM-cmdbas	:a8 - enter transparency mode
	hc	SNDLTM-cmdbas	:a9 - leave transparency mode 
	hc	MENGRN-cmdbas	:aa - GREEN ball
	hc	MENRED-cmdbas	:ab - RED ball
	hc	MENYEL-cmdbas	:ac - YELLOW ball
	hc	MENORN-cmdbas	:ad - ORANGE ball
	hc	BrkIn-cmdbas	:ae - <BREAK> begin
	hc	Consume-cmdbas	:af - 'hang up'
	hc	Consume-cmdbas	:b0 - query term param n, n in byte 4
	hc	MENSTP-cmdbas	:b1 - set term par n, n in byte 4, val in byte 5
	hc	WRONGO-cmdbas	:b2 - psuedo needle
	hc	WRONGO-cmdbas	:b3 - logon character
	hc	Consume-cmdbas	:b4 - normal logon status
	hc	Consume-cmdbas	:b5 - logon failure
	hc	Consume-cmdbas	:b6 - sucessful logon
	hc	WRONGO-cmdbas	:b7 - addendum to accounting
	hc	Consume-cmdbas	:b8 - SUPER-HANG UP /IGNORE FOR SUP
	hc	Consume-cmdbas	:b9 - set transmit limit
	hc	Consume-cmdbas	:ba - <BREAK> end
	hc	Consume-cmdbas	:bb - zap acknowledge
	hc	PassOn-cmdbas	:bc - enter alt out dev mode
	hc	PassOn-cmdbas	:bd - leave alt out dev mode
	hc	ZWRin-cmdbas	:be - ZAP with reason  (needs fiddling with)
	hc	PassOn-cmdbas	:bf - start IIX exchange
	hc	PassOn-cmdbas   :c0 - terminate IIX exchange
icmmax  eq      (.-2-mentbl)/2     :max ISIS msg we know.


: HOTTBL - table for host circuits ...

        hs      0
HOTTBL  eq      .-2*9e
	hc	WRONGO-cmdbas	:9e - detach (odd that we don't allow this)
	hc	ZapIn-cmdbas	:9f - disconnect (zapper)
        hc	PassOn-cmdbas	:a0 - apply backpressure 
	hc	PassOn-cmdbas	:a1 - release backpressure
	hc	PassOn-cmdbas	:a2 - flush output (this dir) (gobbler) 
	hc	PassOn-cmdbas	:a3 - flush input.
	hc	HBlkIn-cmdbas	:a4 - data lost in this dir (BLACK ball)
	hc	HGryIn-cmdbas	:a5 - data lost in opposite dir (GRAY ball)
	hc	Consume-cmdbas	:a6 - enter DEM - should not happen.
	hc	Consume-cmdbas	:a7 - leave DEM - should not happen.
	hc	SNDETM-cmdbas	:a8 - enter transparency mode
	hc	SNDLTM-cmdbas	:a9 - leave transparency mode
	hc	HGrnIn-cmdbas	:aa - GREEN ball
	hc	HRedIn-cmdbas	:ab - RED ball
	hc	HYELIN-cmdbas	:ac - YELLOW ball
	hc	PassOn-cmdbas	:ad - ORANGE ball
	hc	PassOn-cmdbas	:ae - <BREAK> begin. Not likely, but let 'em.
	hc	HHngIn-cmdbas	:af - 'hang up'
	hc	PassOn-cmdbas	:b0 - query term param n, n in byte 4
	hc	HOTSTP-cmdbas	:b1 - set term par n, n in byte 4, val in byte 5
	hc	WRONGO-cmdbas	:b2 - psuedo needle
	hc	WRONGO-cmdbas	:b3 - logon character
	hc	NLSin-cmdbas	:b4 - normal logon status
	hc	LOFin-cmdbas	:b5 - logon failure
	hc	SLOin-cmdbas	:b6 - sucessful logon
	hc	WRONGO-cmdbas	:b7 - addendum to accounting
	hc	Consume-cmdbas	:b8 - SUPER-HANG UP /IGNORE FOR SUP
	hc	Consume-cmdbas	:b9 - set transmit limit
	hc	PassOn-cmdbas	:ba - <BREAK> end: unlikely but let 'em.
	hc	Consume-cmdbas	:bb - zap acknowledge
	hc	PassOn-cmdbas	:bc - enter alt out dev mode
	hc	PassOn-cmdbas	:bd - leave alt out dev mode
	hc	ZWRin-cmdbas	:be - ZAP with reason  (needs fiddling with)
	hc	PassOn-cmdbas	:bf - start IIX exchange
	hc	PassOn-cmdbas   :c0 - terminate IIX exchange
        if      .NE.(icmmax,(.-2-hottbl)/2)      
          remark %*** PROGRAMMER HAS MESSED UP ISIS COMMAND TABLES AT HEX (
          number $0.
          remark ).%*** BAD ASSEMBLY.%
        ei


: TCOTBL - Table for a user circuit which is now transparently connected
:       to a host circuit ...

        hs      0
TCOTBL  eq      .-2*9e
	hc	WRONGO-cmdbas	:9e - detach (odd that we don't allow this)
	hc	ZapIn-cmdbas		:9f - disconnect (zapper)
        hc	PassOn-cmdbas	:a0 - apply backpressure 
	hc	PassOn-cmdbas	:a1 - release backpressure
	hc	PassOn-cmdbas	:a2 - flush output (this dir) (gobbler) 
	hc	PassOn-cmdbas	:a3 - flush input
	hc	BlkIn-cmdbas	:a4 - data lost in this dir (BLACK ball)
	hc	GryIn-cmdbas	:a5 - data lost in opposite dir (GRAY ball)
	hc	TCOEDM-cmdbas	:a6 - enter DEM
	hc	TCOLDM-cmdbas	:a7 - leave DEM
	hc	SNDETM-cmdbas	:a8 - enter transparency mode (x.25)
	hc	SNDLTM-cmdbas	:a9 - leave transparency mode (was PassOn)
	hc	TCOGRN-cmdbas	:aa - GREEN ball
	hc	TCORED-cmdbas	:ab - RED ball
	hc	PassOn-cmdbas	:ac - YELLOW ball
	hc	TCOORN-cmdbas	:ad - ORANGE ball
	hc	PassOn-cmdbas	:ae - <BREAK> begin
	hc	Consume-cmdbas	:af - 'hang up'
	hc	Consume-cmdbas	:b0 - query term param n, n in byte 4
	hc	TCOSTP-cmdbas	:b1 - set term par n, n in byte 4, val in byte 5
	hc	WRONGO-cmdbas	:b2 - psuedo needle
	hc	WRONGO-cmdbas	:b3 - logon character
	hc	Consume-cmdbas	:b4 - normal logon status
	hc	Consume-cmdbas	:b5 - logon failure
	hc	Consume-cmdbas	:b6 - sucessful logon
	hc	WRONGO-cmdbas	:b7 - addendum to accounting
	hc	Consume-cmdbas	:b8 - SUPER-HANG UP /IGNORE FOR SUP
	hc	Consume-cmdbas	:b9 - set transmit limit
	hc	PassOn-cmdbas	:ba - <BREAK> end
	hc	Consume-cmdbas	:bb - zap acknowledge
	hc	PassOn-cmdbas	:bc - enter alt out dev mode
	hc	PassOn-cmdbas	:bd - leave alt out dev mode
	hc	ZWRin-cmdbas	:be - ZAP with reason  (needs fiddling with)
	hc	PassOn-cmdbas	:bf - start IIX exchange
        hc      PassOn-cmdbas   :c0 - terminate IIX exchange
        bc      0
        if      .NE.(icmmax,(.-2-tcotbl)/2)
          remark %*** PROGRAMMER HAS MESSED UP ISIS COMMAND TABLES AT HEX (
          number $0.
          remark ).%*** BAD ASSEMBLY.%
        ei


:--------------------------
: b1 Set Terminal Parameter.  This from a Sat is the reflection back from
:   a Set or a Query-Term-Parm (B0).  Record the value.  But first, if
:   the user is connected up, pass this on up.
:   (B1 from a host is passed on down.)

    : From user in Menu state.
    : If we get Echo-Off, we should set DEM here, because it means NOT
    : that we should not echo but the echo has been forced up from the
    : Sat.  Some Sats will send EDEM before Echo-Off, but others do not.

: changes are made for passing the B1 message( except ECHO ) to HOST.
: At the stage when MSV already has the host circuit but does not
: finish the ubufer yet.  msv 3.xx.

MENSTP  hs      0
        lr      r8,r1                   :(save port)
        lhl     r1,Hostside,RUCB
	lis	r0,(6)                  :(size 6),
	jal	r4,SLOR                 :begin B1 toward host,
	jal	r4,GetCH		:discard "b1"
	jal	r4,GetCH		
	lbr	r9,r0			:r9 parameter number
        jal     r4,putch                :copy parm number,
	jal	r4,GetCH
	lbr	r5,r0			:r5 value
        jal     r4,putch                :copy parm value.
	jal	r4,ELIR

	lbr	r9,r9
        iff(e,short)                    :IF this is ECHO ..
          lbr     r5,r5
          iff(e,short)                    :IF it is ECHO Off ..
            sbt     r8,dem                  :then DEM is here.
          endif
        orelse
          LR      R1,R1                   :r1 is the host circuit
          IFF(N,SHORT)                    :if it has the host circuit
            TBT R1, DOINGLOGON              : true circuit?
            IFF(E,SHORT)                    : if it is
              TBT     R9,TCNOTINYETBA,RUCB    :has the host circuit. B1 to MSV?
              IFF(E,SHORT)                    :iff not for MSV
                JAL     R4,ELOR                 :let it through
              ENDIF                           :endif not for msv
            ENDIF                           :endif not for msv
          ENDIF                           :endif has the host circuit
        endif

        j       STP3                    :go join with Connected Terml.

    : B1 from a Connected Terminal ...
TCOSTP  hs      0
    : get parm number and value, pass on to Host ...
    : When this is an Echo message and changes state, then DEM is at the
    : host.  However if it is a redundant Echo-On, the host's DEM state
    : must not change (example, the response to a Query).

        lr      r8,r1                   :(save port)
        lhl     r1,Hostside,RUCB
	lis	r0,(6)                  :(size 6),
	jal	r4,SLOR                 :begin B1 toward host,
	jal	r4,GetCH		:discard "b1"
	jal	r4,GetCH		
	lbr	r9,r0			:r9 parameter number
        jal     r4,putch                :copy parm number,
	jal	r4,GetCH
	lbr	r5,r0			:r5 value
        jal     r4,putch                :copy parm value.
	jal	r4,ELIR
        jal     r4,ELOR

        lbr     r9,r9                   :if it is Set Echo ..
        iff(e)
          lbr     r5,r5
          iff(e,short)                    :if it is Echo Off ..
            tbt     r8,echo
            iff(n,short)                    :if echo just went off,
              sbt     r1,dem                  :DEM is at host.
            endif
          orelse(short)                   :else is Echo On ..
            tbt     r8,echo
            iff(e,short)                    :if echo just came on,
              sbt     r1,dem                  :DEM is at host.
            endif
          endif                           :end whether Off or On.
        endif                           :end, is Set Echo.

        lr      r1,r8                   :(restore terml port.)


    : Common reception of Set-Term-Parm from Sat: record the value.
    : R9 = parm number, R5 = parm value ...
STP3    hs      0
	clhi    r9,(nTrmCh)
	jge     Idle			:forget it, we don't know number.
        rbt     r9,(TcNotInYetBA),rUCB
        iff(n,short)                    :if hadn't got before,
          stb     r5,(origTcForTsatSide),rUCB,r9    :this is the original.
        endif

        jal     r8,PutTpar		:put the parameter in memory
        j       Idle

    : from host ...
        : If it is Echo, we record it in ECHO[host].  This is used when
        : we first connect the user to the host, to send the host's
        : setting to the terminal at that time.
        : Also, if the terminal is still in Menu state, i.e. it is in the
        : automatic log-in process, we will not send it an Echo setting
        : from the host.  We take care of this later, when the automatic
        : process completes - then we send Echo off or on according to
        : ECHO[host].

HOTSTP	hs	0
    : get parm number and value, pass on to terminal ...
        lr      r8,r1                   :(save port)
        lr      r1,rTsatSideR10
	lis	r0,(6)
	jal	r4,SLOR                 :begin B1 toward terml,
	jal	r4,GetCH		:discard "b1"
	jal	r4,GetCH		
	lbr	r9,r0			:r9 parameter number
        jal     r4,putch                :copy parm number,
	jal	r4,GetCH
	lbr	r5,r0			:r5 value
        jal     r4,putch                :copy parm value.
	jal	r4,ELIR

        lbr     r9,r9
        iff(n,short)                    :if not Set Echo ..

          jal     r4,ELOR                 :pass it on down.
        orelse                          :else it is Set Echo ..
          lb      r6,cstate,RTSATSider10
          chi     r6,csmenu               :if terminal is not
          iff(n,short)                    :in Menu State ..
            jal     r4,ELOR                 :pass it down.
                                            :(if no ELOR, it's pitched.)
          endif

          lbr     r5,r5
          iff(e,short)                    :if it is Echo Off ..
            rbt     r8,echo                 :clear,
          orelse(short)                   :else
            sbt     r8,echo                 :set.
          endif
        endif

        j       idle                    :done.


: ----------------------
: b4 Normal Logon Status (from host only) ..

NLSin   hs      0
	sth	rIncomingR1,(hostSide),rUCB

	jal	r4,GetH	                :B4/status.
        jal	r4,ELIR

	lhi	r12,$2 00011111		:zip off b4 and the upper 3 bits
	nr	r12,r0
	jnfs  	nlsin1			:if NOT zero

          LHI     R4,OPTYPW
          STB     R4,CURCMD,RUCB           :set the password flag
          
	  sbt	  rIncomingR1,(LogOnPorts) :make SeeIfLogonCharsNeedSent work
          sbt     RTSATSider10,DOINGPw     :Indicate, are now in password.
	  j	  Idle

nlsin1  chi     r12,nlsmax
        iff(g)                          :if above the max,
          lhi     r12,nlsmax              :use "not-known".
        endif
        la      r8,nlsrzn,r12		:adjust code to get Zap Reason,

	clhi	r12,5                   :if nls code byte > 5 (failure),
        iff(g)
	  slls	  r12,2
    	  l	  r3,(NLStab),r12
          lhi     r1,$07F                 :set mask = 7bit string
	  jal	  r5,shipToTsat  	  :display text to user.

          LH      R2,CURPW,RUCB
          IFF(N)                          :if psw opcode
            CHI   R12,($00A^2)              :if status = access deny,bad host
            IFF(GE)                         :  no host,mud error
              LIS   R1,0
              STB   R1,PWARRY,R2,rucb             :clear the current psw entry
            ENDIF                           :endif status = access deny
          ENDIF                           :endif psw opcode

          stb     r8,zrzn,rucb            :store the Zap Reason 
          jal     r9,ZHOST                :get rid of host port.
          j       IDLE
        endif

	lr	r0,rTsatSideR10         :if tymsat side "disappeared",
        iff(e)
          stb     r8,zrzn,rucb            :store the Zap Reason 
          jal     r9,ZHOST                :get rid of host port.
          j       IDLE
        endif


: user should be BEGINNING a username/(hostnumber) string now

          tbt     rTsatSideR10,HANDBA
          iff(n,then)                   :if hand login then
    	    slls  r12,2         
	    l	  r3,(NLStab),r12
            lhi   r1,$07F               :set mask = 7bit string
	    jal   r5,shipToTsat		:display text to user.

            clhi  r12,(5^2)
            je    nlsinPW		: if text was: password:
            clhi  r12,(3^2)
            je    nlsinPW               :if text was:error, type password

            rbt   rTsatSideR10,doingPW
      	    la	  r0,(HandLogIn)  
	    st	  r0,(TsatDataHandler),rUCB :start hand login from the
                                          :beginning
          orelse                        :it is auto logoin
            CLHI        R12,5           :status = psw
            IFF(E)                      :if text was password
              LHI       R1,OPTYPW
              STB       R1,CURCMD,RUCB    :set the password flag

              LH        R1,HOSTSIDE,RUCB
              SBT       R1,LOGONPORTS     :make SNDLGC work
            ORELSE                      :else something else
    	      SLLS      R12,2
              L         R3,NLSTAB,R12
              LHI       R1,$07F         :set mask = 7bit string
              JAL       R5,SHIPTOTSAT   :display text to user.

              LH      R2,CURPW,RUCB   : opcode or data?
              IFF(E)                  :if it is canned string then
                LA    R3,BDCON,,       
                LHI   R1,$07F         :7bit message
                JAL   R5,SHIPTOTSAT   :send bad configuration message

                jal   r6,prlo               :send a logoff msg to user

                lhl   r2,tsatside,rUCB     
                la    r3,detachbuf
                jal   r5,ocm                :send a detach

                jal   r8,freeupucb
              ORELSE                        :else psw opcode
                LHL   R1,HOSTSIDE,RUCB
                SBT   R1,LOGONPORTS

                LB    R1,PWPOSI,RUCB
                STB   R1,LOGINEMPTY,RUCB      :re-do it again

                LIS   R1,0
                STB   R1,PWARRY,R2,rucb           :clear the current psw entry
              ENDIF           :endif 'can psw' or not
            ENDIF       :end if 'password'
          endif         :endif handlg or auto login
        j       Idle

: user is going to enter a pw now, quit sending characters back

nlsinPW
	sbt	rTsatSideR10,(doingPW)	

	la	r0,(hli0)
	st	r0,(TsatDataHandler),rUCB

	rbt	rTsatSideR10,(ECHO)

	lr	r2,rTsatSideR10
	la	r3,(ECHOoffBuf)
	jal	r5,OCM

	j	Idle


: ----------------
: b5 Logon Failure

LOFin   hs      0
	sth	rIncomingR1,(hostSide),rUCB

	jal	r4,GetCH                :discard "b5",
	jal	r4,GetCH                :get error code.
	clhi	r0,(PnRjMax)
	jlefs	lof1
	  lis	  r0,(PnRjMax)		:error number out of range - force max
lof1    lr      r2,r0                   :(save)

	jal	r4,ELIR

        la      r3,pnrrzn,r2		:adjust code to get Zap Reason,
        stb     r3,zrzn,rucb            :store the Zap Reason.

	slhls	r2,(2)                  :code*4,
	l	r3,(PnRjTab),r2
        lhi     r1,$07F                 :set mask = 7bit string
	jal	r5,shipToTsat		:send text explaining problem

	lhl	rTsatSideR10,(TsatSide),rUCB :for STPs in ZapHost

        jal     r9,ZHOST                :get rid of circuit,
	j	IDLE                    :go be idle.


: b6 Sucessful Logon
: ------------------
SLOin
	lis	r0,(8)			:contains iix, invoice #, orig. host
	jal	r4,Flush		: but we don't care

	rbt	rTsatSideR10,(doingPW)	
	rbt	rTsatSideR10,(HandBA)
	rbt	rIncomingR1,(doingLogon)

: copy the terminal parameters from the tymsat side port 
: to the newly logged in circuit's 

	lr	r6,rIncomingR1 
	lis	r9,(1)
slo1
	  lr	  r1,rTsatSideR10
	  jal	  r8,GetTpar

	  lr	  r1,r6
	  jal	  r8,PutTpar
				
	ais	r9,(1)
	clhi	r9,(nTrmCh)
	jlbs	slo1

: set xmit limit to the MAXIMUM for better throughput

	lr	r2,r6
	la	r3,(SetXlimBuf)
	jal	r5,OCM			:send a SET TRANSMIT LIMIT msg

	lis	r0,(0)
	stb	r0,(ToArray),rTsatSideR10 :turn OFF inactivity timer

        TBT     RTSATSIDER10,ETMOUT     :Check the sat mode
        IFF(N,SHORT)                    :if sat in transparent mode
          LR    R2,RTSATSIDER10
          LA    R3,LTMBUF
          JAL   R5,OCM                    :send ltm out

          RBT   RTSATSIDER10,ETMOUT       :restore the sat mode
          LB    R3,MSVLTM,R10
          AIS   R3,1
          STB   R3,MSVLTM,R10
        ENDIF

        JAL     R8,HACCNT               :send B7 message. r0-r5 destroyed

        lis     r2,0                    :(with char count =0),
        jal     RRETTOcharsupr11,BEGHOS :begin the host-side co-process.
                                        :(it returns when it wants data.)
        st      r5,HSHAND,rUCB          :save process address.
        j       idle


: HACCNT subroutine - send a B7 message out
:       B7 message format
:       :--------------------------------
:       :   HOSTPORT     |  B7   |  XX  |
:       :--------------------------------
:       : 0E | 0A |     INVOICE#        |
:       :--------------------------------
: LINK  - R8
: IN    - UCB
:       - RUCB(R13)
: REG   - R0 ~ R5 are destroyed

HACCNT  HS      0
        LHL     R2,HOSTSIDE,RUCB

        L       R1,INVOCE,RUCB          :put the invoice# of the first session
        ST      R1,ACCBUF+B7INV

        LHI     R1,ACCTYP       
        STB     R1,ACCBUF+B7TYPE        :put the account msg type

        LA      R3,ACCBUF
        JAL     R5,OCM

        JR      R8

:---------------
: ad Orange Ball

    : from Sat ...
: tymsat side sent Orange Ball because Menu Server first sent Yellow Ball to
: tymsat side and set state to eat all "type ahead" data, sent by tymsat side 
: until operator sees the 'error' we reported (from command decoder) 
: But now orange ball is here, so have at it

MENORN  hs      0
	l	  r0,(YBtimer),rUCB
        IFF(E)		:if (got an unsolicited orange ball!)
          LHL   R1,HOSTSIDE,RUCB
          JE    CONSUME         :if no host then consume
            RBT   R1,HYBOUT     :else reset YB flag
            TBT   R1,DOINGLOGON :check the host circuit
            JN    CONSUME       :not a true circuit then ignore the msg
              J     REFLECT     :a true circuit,  pass the msg to host
        ORELSE(SHORT)   :else (an outstanding YB)
          lis   r0,(0)
          st    r0,(YBtimer),rUCB       :reset the menu yb timer

          :the YB is out either when type too many chars in command mode or
          :while entering a password. 
          LHL   R1,HOSTSIDE,RUCB
          IFF(E,SHORT)          :if hasn't got host circuit yet 
	    la	  r0,(CmndMode)	        :instead of "Eat"
	    st	  r0,(TsatDataHandler),rUCB   :go and get command again
          ENDIF                 :endif hasn't got host circuit yet
        ENDIF           :endif (got an unsolicit OB)

Consume
	lb	r0,LENGTH,RMSGTYper2,   :get length from ISIS.
	jal	r4,Flush		
	j	Idle

    : Orange from Connected Terminal ...
TCOORN  hs      0
	lis	r0,(0)
	st	r0,(YBtimer),rUCB
        j       PassOn


: be Zap with reason
: ------------------
ZWRin
	ais	r14,(1)

: 9f Zap (disconnect)
:-------
ZAPin
	lis	r0,(1)
	jal	r4,Flush

	cr	rIncomingR1,rTsatSideR10
	jefs	zapFromTsatSide
          jal     r9,FOGHOS               :host side, forget him.
	  j	  IDLE

zapFromTsatSide
	jal	r8,FreeUpUCB            :Clean it all out.
	j	Idle

: af Hang-Up
:-----------
    : from host ...
HHNGin  hs      0
	sth	rIncomingR1,(hostSide),rUCB

	lis	r0,(1)
	jal	r4,Flush

        jal     r9,ZHOST                :get rid of that host.
	j	IDLE


:--------------
: a4 Black Ball

    : from host ...
HBLKIN  lis     r6,1
        ahm     r6,ERHBLK               :count one,
        lhl     r7,TSATSIde,RUCB
          JE      CONSUMe               :quit, no TSAT.

        la      r3,HBLKTX,,             :point at message,
        jfs     blk1                    :go send it.

    : from Tsat ...
BLKin   hs      0
        lis     r6,1
        ahm     r6,ERTBLK               :count one,
	la	r3,BlackBallTxt,,       :point at message,
blk1
	lis	r0,(1)
	jal	r4,Flush

        lhi     r1,$07F                 :set mask = 7bit string
	jal	r5,shipToTsat		:send dreaded message to "tymsat side"

	j	Idle

:-------------
: a5 Gray Ball

    : from host ...
HGRYIN  lis     r6,1
        ahm     r6,ERHGRY               :count one,
        lhl     r7,TSATSIde,RUCB
          JE      CONSUMe               :quit, no TSAT.

        la      r3,HGRYTX,,             :point at the message,
        j       blk1                    :go send it.

    : from Tsat ...
GRYin
        lis     r6,1
        ahm     r6,ERTGRY               :count one,
	la	r3,GreyBallTxt,,        :point at the message,
        j       blk1                    :go send it.

: ae <BREAK> (send gobbler)
:-----------
BRKin
	lhi	rMsgTypeR2,(GOBBLER)	:eat data headed toward <BREAK> emitter
	lis	r0,(3)
	jal	r4,SLOR
	jal	r4,ELOR


        lhi     rMsgTypeR2,(BREAKdetected)

        clh     rIncomingR1,(TsatSide),rUCB	 
        jn      PassOn			:send break to tymsat side if from Host

          lhl     r1,(hostSide),rUCB
          je      Consume		:if not con. to host 
	    tbt	r1,(doingLogon)
            jn	Consume

            j       Reflect		:send break to host (clever)

: a6 Enter Deferred Echo Mode
:----------------------------

    : user in Menu state ...
MENEDM  hs      0
	sbt	rIncomingR1,(dem)
	j	Consume

    : user transparently connected to host ...
TCOEDM  hs      0
        lhl     r1,hostside,rUCB
        sbt     r1,dem                  :indicate DEM is at the host,
        j       Reflect                 :pass to host (R1).

: a7 Leave Deferred Echo Mode
:----------------------------

    : user in Menu state ...
MENLDM  hs      0
	rbt	rIncomingR1,(dem)       :indicate we should not echo.
	j	Consume

    : user transparently connected to host ...
TCOLDM  hs      0
	rbt	rIncomingR1,(dem)       :indicate we should not echo.
        lhl     r1,hostside,rUCB
        rbt     r1,dem                  :indicate DEM not at the host,
        j       Reflect                 :pass to host (R1).


:--------------
: aa Green Ball.  A few words about Green/Red ball logic.  What is a Green
:   Ball?  It is a request from the Sat to the host, for the Sat to resume
:   echo after it has sent EDEM.  The Sat has just sent something to the
:   host unechoed.  The host should send back the Green Ball after it has
:   sent all the echoes - if the Sat gets a clean Green Ball, it will send
:   LDEM and resume local echoing.
:
:   If the Sat sends us Red Ball it wants us to forget the Green Ball.  
:
:   When we have a Host circuit, the variables GREEN and NBO (No Ball Out)
:   describe the host's state.  We Talk of the host as being GREEN or RED
:   or NBO (No Ball Out).  We call it RED if NBO is 0 - it has a Ball -
:   and GREEN is 0.  It is GREEN when GREEN is set.
:
:   When GREEN(host) is set, NBO(host) MUST be clear!
:
:   GREEN(Sat) means Sat has sent up green and reply is due.
:   NBO(Sat) is not used.

    : green from user in menu state ...
MENGRN  hs      0
        lhl     r6,hostside,rUCB
        iff(e,short)                    :if haven't begun to log in a host,
          rbt     rIncomingR1,green       :(just in case),
          j       Reflect                 :just give it back.

        orelse(short)                   :else we are in the automatic log-in
                                        :    process to a host.  Hang on to
                                        :    the GB till we send all strings.
          sbt     rIncomingR1,green       :remember that we have it.
        endif                           :
        j       Consume

    : from user connected to host ...
            : If host has a Ball (NBO is clear), Sat should not have sent
            : this one, so forget it and Sat will time it out and send RB.
TCOGRN  hs      0
        sbt     r1,green                :remember Sat has put one out.
        lhl     r1,hostSide,rUCB
        rbt     r1,nbo                  :Ball is out at host now.
        iff(e,short)                    :If it was already ..
            lis     r6,1
            ahm     r6,ERRBGB               :count bad green ball.
            sth     r1,ERRBGP               :record what port.
            j       consume                 :forget green, let Sat wait
                                            :for timeout.
        endif
        sbt     r1,green                :Set that we expect GB from host.
        j       Reflect                 :Send it on to host (r1).

    : from Host port ...
                : if there is a Red Ball at the host, it becomes
                : irrelevant now that the green ball has come back.
HGRNIN
        sbt	rIncomingR1,nbo         :say no ball out now.
                                        :  (if a red it doesn't matter.)
        iff(n,short)                    :if there was No Ball Out to host,
            lis     r6,1                    :record anomaly.
            ahm     r6,ERRHGB
            sth     rIncomingR1,ERRHGP      :remember last port it happened on.
        endif
        rbt	rIncomingR1,green       :No green out to host any more.
        lr      r1,rTsatSideR10
          JE      CONSUMe                 :quit, no Sat.

        rbt     r1,green                :is not outstanding to Sat any more.
        j       Reflect                 :Send it on to Sat (r1).


:------------
: ab Red Ball - The purpose of Red Ball is to bust out a Green Ball which
:   the host may be hanging on to.  When either the Green or the Red comes
:   back the Sat can send another Green.  Before this we say the host "is
:   RED": GREEN=0 and NBO=0.

    : from user in Menu state ...
MENRED
        rbt     rIncomingR1,green       :forget any green,
        j       Reflect                 :give the red back to him.

    : from host ...
    :     DO NOT clear green(Sat) here, it can be a new one!
HRedin
        tbt     rIncomingR1,green       :if host is GREEN,
                                          :this RB is old, there's still
                                          :a GB up there.
        iff(e,short)                    :if host not GREEN,
            sbt     rIncomingR1,(nbo)	    :Ball is no longer out.
            rbt     RTSATSider10,green      :set, Sat not expecting neither.
        endif
        lr      RTSATSider10,RTSATSider10
          JE      CONSUMe                 :quit, no Sat.

        j       PassOn                  :always pass the RB down.


    : from user connected to host ...
                : Notice, we can get RB from the Sat when no ball is out to
                : the host, if we have just passed GB (or RB) down to the
                : Sat but the Sat hasn't got it yet.
                : Sat stays Green if it is at present, waiting for the reply.
                : If host is NBO, it stays that way.  We really don't care
                : about that.
TCORED  hs      0
        lhl     rIncomingR1,hostSide,rUCB
	rbt	rIncomingR1,green       :make host not Green.  If it's not
                                        :  NBO, then it's RED.
	j	Reflect			:Give host (r1) the RB.


:------------------------
: SNDLTM - Jump here to keep track of the LTM sent to CONSAT.
:       r1 = port
:       r2 = isis msg type.
:       r10= TSAT port.
:       r13( rUCB ) = UCB pointer.

SNDLTM
        CR      RINCOMINGR1,RTSATSIDER10
        JE      SNDLT1          :if not from sat then
          LR    R1,R10
          JE    CONSUME
            RBT   R1,ETMOUT
            J     REFLECT       :send to sat
SNDLT1
        LB      R6,MSVLTM,R10
        IFF(N)                  :if LTM is out from msv
          SIS   R6,1
          STB   R6,MSVLTM,R10
          J     CONSUME
        ORELSE
          LHL   R1,HOSTSIDE,RUCB
          JE    CONSUME         :no host port throw it away
            TBT R1,DOINGLOGON
            JN  CONSUME         :not connectted yet throw it away
                J   REFLECT       :pass it on
        ENDIF                   :endif LTM is out from msv


:------------------------
: SNDETM - Jump here to keep track of the ETM sent to CONSAT.
:       r1 = port
:       r2 = isis msg type.
:       r10= TSAT port.
:       r13( rUCB ) = UCB pointer.

SNDETM
        CR      RINCOMINGR1,RTSATSIDER10
        JE      SNDET1          :if not from sat then
          LR    R1,R10
          JE    CONSUME
            RBT   R1,ETMOUT
            J     REFLECT       :send to sat
SNDET1
        LB      R6,MSVETM,R10
        IFF(N)                  :if etm is out from msv
          SIS   R6,1
          STB   R6,MSVETM,R10
          J     CONSUME
        ORELSE
          LHL   R1,HOSTSIDE,RUCB
          JE    CONSUME         :no host port throw it away
            TBT R1,DOINGLOGON
            JN  CONSUME         :not connectted yet throw it away
                J   REFLECT       :pass it on
        ENDIF                   :endif etm is out from msv


: -----------------------
: PASSON - Jump here to pass this ISIS message on, from Sat to Host or
:   from Host to Sat.  Checks which side this is, pitches the message if
:   the other side is not there.
:   Conditions are as on exit from LOOK, 
:       R1 = port
:       R2 = ISIS msg type.
: plus: RUCB (R13) = UCB pointer.
:       RTSATSider10 has TSAT port.

PassOn
	cr	rIncomingR1,rTsatSideR10
	jefs	pasFromTsatSide

	  lr	  r1,rTsatSideR10	:was from host, send to tymsat side
	  jn	  Reflect
	    j	    Consume		:no tymsat

pasFromTsatSide
	lhl	r1,(hostSide),rUCB
	je	Consume			:no host
	tbt	r1,(doingLogon)
	jn	Consume
	j  	Reflect

: ac Yellow Ball
:---------------
    : from Sat ...
MENYEL  hs      0
	ais	rMsgTypeR2,(1)		:change YELLOW to ORANGE, bounce
        j       reflect

    : from Host ...
HYELIN  hs      0
        lr      RTSATSider10,RTSATSider10
        IFF(N)          :if sat is there
          SBT     R1,HYBOUT
          LR      R1,R10        : go pass it on,
          J       REFLECT
        ORELSE(SHORT)   :else sat is gone
          ais     RMSGTYper2,1                :otherwise bounce Orange back
          jfs     reflect                     :from here.
        ENDIF           :endif ( sat is there)
: ------------------------
: REFLECt - jump here to send out the message which is in IRING (not data).
: Registers as they are direct from LOOK:
: R1 - port to send on (caller may change to send where he wants)
: R2 - Message Type.

Reflect hs      0
        lb      r6,LENGTH,r2,
	la 	r0,3,r6                 :make output the same size,
	jal	r4,SLOR			:send msg type in r2,
        jal     r4,GETCH                :eat type from IRING,
        sis     r6,1                    :count it off.
        do(count,r6,short)              :pass on whatever's left ..
          jal     r4,GETCH
          jal     r4,PUTCH
        enddo
        jal     r4,ELIR                 :finish it.
	jal	r4,ELOR

	j	Idle			

	subttl Zap/disconnection handling. (MSDISC.Sxx)

:msdisc.s32
:   02/29/88  JH  
:   change instructs which refer to LTOTAB, HTOTAB into RX3
:   cause by rearranging the code

:MSDISC.S30
:   9/30/87  GWH  V3 R0.

:MSDISC.S20
:   01/20/87 JSB  V2 R1.  Login Retries, Host Timeout: make zap/forget host
:                 into subroutines.

:(J.BURKE)MSDISC.S13
::  11/6/86  JSB  Fix echo logic: pass all echo-related functions
::                to and from host.  Restore Echo state for menu upon
::                host zap.
::
:: Split out from MC.R12, JSB, 11/5/86.

: ZHOST subroutine, zap host, and
: FOGHOS entry point, get rid of host (already zapped).
:   Calling either one of these gets rid of a currently held host and cleans
:   everything up.
:
:   If you call from the user-circuit data handler or from the host-circuit
:   data handler, you must consume the current ISIS packet before calling,
:   and afterwards jump to IDLE.  This routine sets the process address
:   as required.  You must not return through the coroutine linkage.
:
:In - R9 = Link.  These routines have no process waits and so may use
:         simple variables for storage like the return address.
:     RTSATSider10 - Sat circuit, =0 if none.  (note, there is no Hostside
:         when we get a Pseudo-Needle Reject from port 0.)
:     R11 - preserved.  May contain the process coroutine link if we get
:         called by a port process.  However, note the caution in the general
:         description above: the caller should not return through R11 if
:         the caller is the TSat process, but must jump to IDLE.
:     RUCB (R13) - UCB pointer.
:
:Out- TSATDAtahandler[UCB] is set to EAT if the login is abandoned (but not
:         if we still get more login retries).
:
:   MAY NOT be called from the Action Macroes and subroutines, because of
:   possible recursion loop.
:
:   Is called from the user process at other times, and also called when
:   not in the user process.

ZHOST   hs      0
	lhl	r2,(hostSide),rUCB
        iff(n)                          :if there is a host circuit,
          la      r3,(ZapBuf)
          jal     r5,OCM                  :send a ZAPPER
        endif

: (FOGHOS entry point ... )

FOGHOS  hs      0
        st      r9,ZFSV9                :(save return.)
        st      r11,ZFSV11

	lhl	r2,(hostSide),rUCB
        lh      RTSATSider10,TSATSIde,rUCB
        iff(e)                          :if Sat is gone,
          jal     r3,REFURBucb            :Clean Host up and quit.
          J       FOGH9

        endif
        lr      r2,r2
        iff(n)                          :if host is still there,
          tbt     r2,nbo
          jefs    fogh2                   :IF ball out to host,
          tbt     RTSATSider10,green
          iff(n,short)                    :OR ball out from Sat,
fogh2       hs      0
            lr      r2,RTSATSider10         :(sat port)
            rbt     r2,green                :Sat green no more.
            la      r3,greenbuf
            jal     r5,ocm                  :throw green back to sat.
          endif				  :end, Ball out.
        endif

        TBT       R10,ETMOUT              :check the sat mode
        IFF(N)
           LR     R2,RTSATSIDER10         :port#
           LA     R3,LTMBUF               :A9
           JAL    R5,OCM                  :send LTM
           RBT    R10,ETMOUT              :reset it
           LB     R3,MSVLTM,R10
           AIS    R3,1
           STB    R3,MSVLTM,R10
        ENDIF
           
        lhi     r6,csmenu               :Sat is now in Menu State.
        stb     r6,cstate,RTSATSider10
	jal	r3,RefurbUCB

: since we are making a connection from the menu server to some host go away,
: we'd like to get the terminal parameters on the tymsat back to the way they
: were before the host (possibly) changed them.

: when the needle FIRST came in, we sent a barrage (19) of QTPs to the tymsat.
: (all TPs except ECHO... i.e. 1 thru 19)
:  MSV3.00 always forces SAT in DEM.
: the tymsat SHOULD have sent a STP in reply to EACH of these
: (I've seen tymsats send back STPs not coresponding to the QTPs sent!)
: so now the tymsat'l be in good shape for talking (however breifly) with
: the menu server code in the exchange to select the next host to connect up to

        LR      R2,R10                  :SAT port#
        LA      R3,ECHOOFFBUF,,         :force SAT in DEM
        JAL     R5,OCM

	lr	r1,rTsatSideR10
 	lis	r9,(0)
kh1
	  tbt	  r9,(TcNotInYetBA),rUCB
	  jnfs	  kh2

	    jal	    r8,GetTpar		:in: r1-port,r9-param# out: r5-value

	    clb	    r5,(origTcForTsatSide),rUCB,r9
	    jefs    kh2			:if not different
	      lb      r5,(origTcForTsatSide),rUCB,r9
	      jal     r8,setTsatSideParmeters :get the tymsat back the way it was
kh2
	ais	r9,(1)
	clhi	r9,(nTrmCh) 
	jl	kh1

    : Check on Retries ...
        lb      r6,zrzn,rUCB
        je      FOGH4                   :IF Reason does not show Connected,
        tbt     r6,NORETS
        jn      FOGH4                   :AND Retries okay for this Reason,

        lh      r0,UTRIES,rUCB
        ais     r0,1                    :    (bump retries)
        sth     r0,UTRIES,rUCB
        ch      r0,UNRT,rUCB
        iff(l)                          :AND retries not exhausted ..
          ci      r0,1
          iff(e,short)                  :is it the first try?
            la    r3,RETMS1,,           : send the first msg
          orelse(short)                 :else not the first time
            la    r3,RETMS2,,
            ai    r0,$030,              :convert to ascii char
            stb   r0,8,r3               :update the count
          endif 

          lhi     r1,$07F               :set mask = 7bit string
          jal     r5,shiptoTsat
          l       r5,UCMPTR,rUCB          
          jalr    RRETTOcharsupr11,r5       :go jump into the code again.
          st      r5,TSATDAtahandler,rUCB   :Remember process address.

        orelse                          :else this selection is zilched ...
          la    r3,RETMS3,,
          ai    r0,$030,
          stb   r0,8,r3                 :update the count
          lhi   r1,$07F                 :set mask = 7bit string
          jal   r5,shipToTsat

FOGH4     hs    0
          lb    r6,relativeHost,rUCB
     	  lb	r0,(tixTab),r6		  :dig out value to count down from
	  stb	r0,(ToArray),rTsatSideR10   :turn INACTIVITY TIMER back ON
          lis   r0,0
          sth   r0,ULCLK,rUCB             :turn off the login timeout.

	  jal	r6,prZap		  :"circuit cleared to menu server"

	  lb	r6,(relativeHost),rUCB
	  tbt	r6,(alogBA)
          iff(n)  			  :IF AUTO LOGOFF ...

	    jal	  r6,PrLO		    :"bye bye"

	    lhl	  r2,(TsatSide),rUCB
	    la	  r3,(DetachBuf)
	    jal	  r5,OCM		    :zap the user.

	    jal	  r8,FreeUpUCB
          orelse                            :else not auto-logoff ...

	    lr	r2,rTsatSideR10
	    la	r3,(YellowBuf)
	    jal	r5,OCM			    :send a YELLOW BALL,

	    l	r0,(SlowC),,
	    ais	r0,(0a)
	    st	r0,(YBtimer),rUCB

	    la	r0,(Eat)                    :set up to eat till orange.
	    st	r0,(TsatDataHandler),rUCB

	    tbt	r6,(arBA)		    :auto redisplay the menu
	    jefs	FOGH7
	      jal	  r6,PrME		    :"menu"
FOGH7
	    jal	r6,PrSE			    :"pick your poison"

	    :: jal     r5,ZEROUBufer           :(disabled pending ZEROUB fix).
          endif                           :end whether auto-logoff.
        endif                           :end whether login retries done.

FOGH9   l       r9,ZFSV9                :(restore return)
        l       r11,ZFSV11
        jr      r9                      :EXIT.


:-----------
: REFURBucb subroutine: clean host info out from the UCB, other places.
:   (note Hostside is zero if we get Pseudo-Needle Reject from port 0,
:   and the rest of this stuff is still necessary.)
:   R3 - link.
:   RUCB (R13) ucb pointer.
: Destroys r0 through r5.

RefurbUcb       hs   0
	lhl	r1,(TsatSide),rUCB
        rbt     r1,handBA
        rbt     r1,DOINGPw
	lis	r0,0                    :handy goose-egg.
        sth     r0,ULCLK,rUCB           :stop the Login Timeout.
	lhl	r1,(hostSide),rUCB
        iff(n)                  :if we have the port
	  sth	r0,(PortToUCBmap),r1,r1
	  sth	r0,(hostSide),rUCB

	  rbt	r1,(LogOnPorts)		:for "SeeIfLogonCharsNeedSent"
	  rbt	r1,ECHO
	  rbt	r1,dem
	  rbt	r1,green
	  Sbt	r1,nbo
        endif

	lhl	r4,(BAbase),rUCB
	jer	r3			:if no rotor entry to release
	  lhl	  r5,(BAbit),rUCB
	  sbt	  r5,(0),r4		:rotor entry we used is available again

	  lis	  r0,(0)
	  sth	  r0,(BAbase),rUCB	:address served as flag, turn off now
	  jr	  r3


:--------------------------------
: ZEROUBufer subroutine - don't use this till you fix it.  Presently it
: doesn't stop unless it finds the two zeroes, which might not be there.

ZeroUbufer
        lis     r2,(2)
	lhi	r0,(77)
zu1
          lb      r1,(ubufer),r2,rUCB
	  jnfs	  zu2
            stb     r0,(ubufer),r2,rUCB
	    ais	    r2,(1)
            lb      r1,(ubufer),r2,rUCB
            jer	    r5			:done if 0,0
zu2
          stb     r0,(ubufer),r2,rUCB
          ais     r2,(1)
        j       zu1
:--------------------------------
: FREEUPucb subroutine - clean up for user going away.
: called from KodeQuit macro and zapFromTsatSide... timeout too.
: Clean up host circuit if any, and any stuff left over from a host selection.
:In - R8 link.
:     rUCB.

FreeUpUCB
        lhl	r1,(hostSide),rUCB
        jefs    ag1			:jump, no host port there.
	  lr	  r2,r1
	  la	  r3,(ZapBuf)
	  jal	  r5,OCM		:send a ZAPPER on host port.

ag1     hs      0
        jal	r3,RefurbUCB            :stop red, green balls, free rotors,
                                        :needed even when host=0, for Pnrj.
        JAL     R5,RSETPW               :clear the password entry
      
	lhl	r1,(TsatSide),rUCB
        TBT     R1,MAUSER
        IFF(N,SHORT)                    :if it is M.A.
          LB    R0,RELATIVE,RUCB         
          RBT   R0,MALGIN                 :clear the exclusive flag
          RBT   R1,MAUSER
        ENDIF                           :endif it's M.A.

	lis	r0,(0)
	sth	r0,(PortToUCBmap),r1,r1
	stb	r0,(ToArray),r1		:STOP INACTIVITY TIMEOUT!
	sth	r0,(TsatSide),rUCB

	lb	r6,(relativeHost),rUCB
	lis	r7,(1)
	jal	r9,ChangeRemainingQuota

	lr	r0,rUCB
	shi	r0,(UCBbase)
	lhi	r1,(UCBlength)
	dhr	r0,r1
	sbt	r1,(UCBinUse)		:allow this UCB to be used again

	jr	r8


: RSETPW subroutine - clear the password array for security reason.
: LINK  - R5
: IN    - R13(RUCB)
: REG   - R0 ~ R5 destroyed

RSETPW
        LIS	R0,0     		:clear the contains

        LHI     R1,PWENTL
        LHI     R2,PS.IDX               :how many entries, set condition code
        MHR     R2,R1                   
        DO(WHILE,G)                     :do (all entries) zero all entries
          STH   R0,PWARRY+PWENTL-2,R2,rucb     :start from last halfword
          SIS   R2,2
        ENDDO                           :enddo (all entries)

        JR      R5

: - - - - - - -
: INACTIvitytimeouttester - Timeout routine to check login and inactivity
:   timeouts.
:   This routine checks Menu Timeout and Login Timeout by reducing the
:   appropriate countdown clock by the increment TOINAC, which is the
:   period at which this routine runs.  Therefore it is important that
:   1) this routine should run very close to the interval, and
:   2) whoever sets the timeout should ROUND IT UP to the interval
:   TOINAC plus another whole tick!  This routine occasionally runs
:   immediately after someone's timeout gets set up, dinging that poor
:   user for a whole tick in virtually zero time.
:   The routine also checks Host timeout if the user is transparently
:   connected to the host. 
:   Note: the routine works only if the values for the CSTATE keep in order,
:         such that the CSCTO has the highest value.


InactivityTimeoutTester  hs  0

      ai      r1,RATE*TOINAC        :Repeat at the rate defined.
      jal	r5,TOPUT

      lhi     r12,0                 :loop over all UCB's,
      lhi     rUCB,UCBBASe
      do                            :DO
        tbt     r12,UCBINUse          :(=1 really means NOT in use.)
        iff(e)                        :IF there is a good UCB,

              : Check for Menu Timeout ...
          lh      r1,TSATSIde,rUCB
    	  lb	  r0,(ToArray),r1
	  iff(n)          		:IF menu being timed out ..
   	    sis	    r0,(1)                :count off a tick.
            iff(le)                       :IF he has timed out,
	      jal       r6,PrTI		        :"save you some bucks"
              lh        r2,TSATSIde,rUCB
	      la        r3,(DetachBuf)
	      jal       r5,OCM		        :send a DETACH

 	      jal       r8,FreeUpUcb

            orelse                        :else
              stb	r0,(ToArray),r1     :tick.
            endif                         :end, whether menu timed out.
          endif                         :end, a Sat, menu being timed.

          tbt     r12,UCBINUse
          iff(e)                        :IF UCB not gone now,

              : Check for Login Timeout ...
              lb      r9,cstate,r1
              chi     r9,cstco
              iff(l)                        :IF not in connected state,
                lh      r9,ULCLK,rUCB
                iff(g)                        :IF login being timed ..

                  shi     r9,TOINAC             :knock his clock down.
                  sth     r9,ULCLK,rUCB
                  iff(le)                       :if we nailed him,
                    lhi     r7,ZCLTO
                    stb     r7,ZRZN,ruCB          :store the zap reason,
                    la      r7,LTOTAB,,
                    jal     r6,PHOMSG             :LTO message,
                    jal     r9,ZHOST              :Get rid of the host.
                  endif                         :end, nailed.

                endif                         :end, login timed.
              orelse                        :else connected, check host timeout
                lh      r9,UHTIVL,RUCB        :get the host timeout value
                iff(g)                        :if host timeout is applied then
                  a     r9,HTOLAC,RUCB        :plus the last active time
                  l     r7,slowc,,            :get the current clock value
                  sr    r7,r9                 :slowc-uhtivl-htolac
                  iff(ge)                     :if inactive too long...
                    LB    R9,CSTATE,R1
                    CHI   R9,CSMALG
                    IFF(L)                      :if host connected state
                      lis   r9,0
                      stb   r9,ZRZN,RUCB          :set the zap reason code
                      la    r7,HTOTAB,,
                      jal   r6,PHOMSG             :display te HTO message.
                      jal   r9,ZHOST              :get rid of the host.
                    ORELSE(E)                   :else it is MA 
                      LA    R7,HTOTAB,,
                      JAL   R6,PHOMSG             :dispLay hosttimeout msg

                      LHL   R2,TSATSIDE,RUCB
                      LA    R3,DETACHBUF
                      JAL   R5,OCM

                      JAL   R8,FREEUPUCB
                    ENDIF                       :endif host connected state
                  endif                       :end if inactive too ling.
                endif                       :end if host timeout applied.    
              endif                       :end, whether connected.
          endif                         :end UCB hadn't gone away.

        endif                         :end, UCB was in use at start.

        ahi     rUCB,UCBLENgth
        ais     r12,1
        chi     r12,nusers
      enddo(while,l)                    :ENDDO (WHILE more UCB's)

      j	TORET

	subttl Menu Server Terminal-Related subroutines (MSTSUB.S30)

:(MENUDEV:39)MSTSUB.S30
: from MSTSUB.S20 for MSV3.00
: change echochar and shiptosat for 8bit support
: add two routines: OCSMS, OBSMS and change on two routines ECHOCH,SHIPTO

:(J.BURKE)MSTSUB.S20
: from MSTSUB.S13 by JSB 12/12/86.
:
:: 11/6/86 JSB  Split out from MC.R12.

: - - - - - - - - - - - - -
: ECHOCHar - Echo a character.
:   Call ECHOCHar when Menu Server may have to echo the character which
:   just came in - this occurs only while the user is making a menu
:   selection or M.A. logs in never after the user begins typing to the host.
:   Checks DEM(SAT), echoes only if it is set.
:   Echoes CR with CRLF.
:   Decides whether anything should be echoed for this character by
:   consulting bit array FILTER. For 7bit ascii code, it echoes only
:   printable character. For 8bit code, it echoes every char in the upper
:   half and does the same thing on the lower half as 7bit ascii code.
:
: In: R0 - character.
:     RTSATSider10 - Sat port.
: Out:R8 - character with parity stripped.
: Link R5.
: Destroys R0, 1, 2, 3, 4, 15.

ECHOchar  hs    0
	lbr	r8,r0 			:save original char,

	tbt	rTsatSideR10,(dem)
        IFF(E)                          :if SAT not in dem
          TBT   R10,ETMOUT
          IFF(E,SHORT)                    :if not in transparent
            NHI   R8,$07F                   :strip the parity
          ENDIF                           :endif not in trans
          JR    R5
        ENDIF                           :endif SAT not in DEM

        TBT     RTSATSIDER10,ETMOUT
        IFF(E)                        :if not in transparent mode
          nhi	r0,$07F			:on 7 bits,
        ENDIF
        tbt	r0,(Filter)
        jer	r5			:return if unprintable

	lis	r0,(5)
	lr	r1,rTsatSideR10
	jal	r4,SLOR

	lbr	r0,r8			:original unstripped char,
	jal	r4,PUTCH                :echo that.

        TBT     RTSATSIDER10,ETMOUT
        IFF(E,SHORT)                    :if in non-transparent mode
  	  nhi	r8,$07F                 :check 7 bits ...
        ENDIF

	clhi	r8,(CR)
	jnfs	ec2

	  lis	  r0,(LF)		:is <cr> so send <lf> too
	  jal	  r4,PutCH	
ec2
	jal	r4,ELODR
	jr	r5

    : FILTER - bit array for chars we can echo (128 chars) ...
Filter	ws	0
	wc	$2 00000001111001000000000000000000 :bel, bs, ht, lf, cr
	wc	$2 11111111111111111111111111111111 
	wc	$2 11111111111111111111111111111111
	wc	$2 11111111111111111111111111111110 :NOT del.
	wc	$2 11111111111111111111111111111111 :for 8bit code echo 
	wc	$2 11111111111111111111111111111111 :every char rcvd.
	wc	$2 11111111111111111111111111111111
	wc	$2 11111111111111111111111111111111


:--------------------------------
: SHIPTOsat subroutine: Get port from TSATSIde[ucb], put out a string
:   as an ISIS data message (SC format). However it masks each char
:   before put out.
:   Check whether Sat port exists - exit if zero.
:   Check whether strings exceeds $09d, chop the end off if so.
:
: R5 link.
: R3 - string in SC format.
: R1 - the mask.
: destroys R0 through R4.

shipToTsat  hs  0
        st      r6,SHIPR6               :save r6
        lr      r6,r1                   :save the mask
        st      r5,SHIPR5

	lhl	r1,(TsatSide),rUCB      :SLOR port,
	jer	r5			:if no tymsat side port
        lb      r2,0,r3                 :SLOR Message Type = size byte,
        chi     r2,$09D
        iff(g)                          :if string too big,
          lhi     r2,$09D                 :cut off the excess.
        endif
        lr      r5,r3                   :(save string pointer)
        la      r0,3,r2                 :SLOR room needed =size+3,
        jal     r4,SLOR
        la      r3,1,r5                 :point to data,
        lr      r1,r6
        jal     r5,OBSMS                :put string out.
        jal     r4,ELODR

        l       r6,SHIPR6              
        l       r5,SHIPR5
        jr      r5


: - - - - - - - - - - - - - - - -
: GetTpar subroutine - Get a Terminal Parameter.
: Returns the last value which we recorded for the parameter, on the port.
:
: Note: values are generally recorded when we get a B1 from the terminal.
: No values are recorded for a B1 from the host, except for ECHO[host].
: Don't change this arrangement until you really understand it.

: r1 port number
: r9 which parameter to get (Parameter number as used in a B0 or B1 ISIS msg)
: r5 returned value (a boolean or a 4 bit entity)
:    -1 returned on error - error is parameter number too big.

: stomps r3

: link on r8

gtperr
	lcs	r5,(1)			:-1 ==> error
	jr	r8			
GetTpar
	clhi	r9,(tabSiz/2)-1
	jgbs	gtperr			:if parameter number too big

	lhl	r3,(PntrsToTPbaseAddresses),r9,r9
	lhl	r5,(getTProutines),r9,r9
	j	(seg|a.code|),r5
	
: return in r5, the boolean value of the r1th bit in the bit 
: array starting at the address in r3

getBit
	lis	r5,(0)

	tbt	r1,(0),r3
	jer	r8			:return with r5 = 0 if bit OFF

	lis	r5,(1)
	jr	r8			:return with r5 = 1 if bit ON

: return in r5 a 4 bit parameter which was stored in the left-hand
: part of a byte in a table, the base of which is pointed to by r3
: and is furthur indexed by r1 (a port number) 

getLeftNibble
	lb	r5,(0),r3,r1
	srhls	r5,(4)			:but shift it right 4 and drop junk
	jr	r8

: do the same for a right-handed one

getRightNibble
	lb	r5,(0),r3,r1
	nhi	r5,$2 00001111	:but mask off junk first
	jr	r8

x	eq	(seg|a.code|)

getTProutines
	hc	getBit-x	:0 - ECHO
	hc	getBit-x	:1 - echo tab
	hc	getBit-x	:2 - echo <LF> with <CR>
	hc	getBit-x	:3 - echo <CR> with <LF>
	hc	getBit-x	:4 - <CR> delay
	hc	getLeftNibble-x	:5 - input baud rate
	hc	getRightNibble-x :6 - output baud rate
	hc	getBit-x	:7 - parity
	hc	getBit-x	:8 - half duplex
	hc	getLeftNibble-x	:9 - parameter A
	hc	getRightNibble-x :10 - parameter B
	hc	getLeftNibble-x	:11 - parameter C
	hc	getBit-x	:12 - X enable
	hc	getBit-x	:13 - echo <CTL> H (backspace)
	hc	getBit-x	:14 - reverse X enable
	hc	getRightNibble-x :15 - parameter D
	hc	getBit-x	:16 - katakana
	hc	getBit-x	:17 - term out on <break>
	hc	getBit-x	:18 - echo <escape>
	hc	getBit-x	:19 - 'Q' - mode

tabSiz	eq	(.)-(getTProutines)

: parameter address table    this table is used by both the "get" and "put"
: terminal parameter routines.

PntrsToTPbaseAddresses
	hc	ECHO	: 0
	hc	EctlI	: 1
	hc	Elfcr	: 2
	hc	Ecrlf	: 3
	hc	CRde	: 4 
	hc	Brate	: 5	left - input baud rate
	hc	Brate	: 6	right - output baud rate
	hc	Parity	: 7
	hc	HafDux	: 8 
	hc	pAB	: 9	left - parameter a
	hc	pAB	: 10	right - parameter b
	hc	pCD	: 11	left - parameter c
	hc	XonEna	: 12
	hc	EctlH	: 13
	hc	YonEna	: 14
	hc	pCD	: 15	right - parameter d
	hc	KATA	: 16
	hc	T.Brk	: 17
	hc	Ec.Esc	: 18
	hc	Q.Mod	: 19

	bnd	2

: setTsatSideParmeters - Send them thru ISIS,
: then fall thru and set them in memory

: r10 tymsat side port
: r9 which parameter (0 - ECHO dosen't get here)
: r5 value to which the parameter is to be set

: stomps r3, r4
: puts r10 into r1
: link on r8

setTsatSideParmeters
	clhi	r9,(5)
	jer	r8			:i won't change input baud rate

	clhi	r9,(6)
	jer	r8			:i won't change output baud rate

	lbr	r6,r5

	stb	r9,STPpar
	stb	r5,STPval

	lr	r2,rTsatSideR10
	la	r3,(STPbuf)
	jal	r5,OCM			:send a SET TERMINAL PARAMETERS msg

	lbr	r5,r6
	lr	r1,rTsatSideR10

: PutTpar - Put a Terminal Parameter in memory

: r1 port number
: r9 which parameter
: r5 what to put there

: stomps r3, r4

: link on r8

PutTpar
	clhi	r9,(tabSiz/2)-1
	jgr	r8			:if parameter too big

	lhl	r3,(PntrsToTPbaseAddresses),r9,r9

	lhl	r4,(putTProutines),r9,r9
	j	x,r4			:to selected fanout table entry

: set or clear a bit (for port in r1) depending upon
: whether r5 was a 0 or a 1.

putBit
	rbt	r1,(0),r3		:reset bit r1 at 0 (r3)

	thi	r5,(1)
	jer	r8			:return if request was to reset bit 

	sbt	r1,(0),r3
	jr	r8

: put the 4-bit parameter found in r5 into the left-handed part of the
: table referenced by r3, and indexed furthur by r1.

putLeftNibble
	lb	r4,(0),r3,r1
	nhi	r4,$2 00001111		:keep "old" "right" parameter value

	lbr	r2,r5			:r2 := "new" "left" parameter
	slhls	r2,(4)			:parameter bits shifted for "oring"

	jfs	combine

: put the 4-bit paramater found in r5 into the right-hand part of the
: table referenced by r3, and indexed furthur by r1.

putRightNibble
	lb	r4,(0),r3,r1
	nhi	r4,$2 11110000		:clear "old" "right" parameter value

	lbr	r2,r5			:r2 := "new" "right" parameter
combine
	or	r4,r2			:merge the "new" and unrelated nibbles 
	stb	r4,(0),r3,r1

	jr	r8

putTProutines
	hc	putBit-x	:0 - ECHO
	hc	putBit-x	:1 - echo tab
	hc	putBit-x	:2 - add <LF> to each <CR>
	hc	putBit-x	:3 - add <CR> to each <LF>
	hc	putBit-x	:4 - <CR> delay
	hc	putLeftNibble-x	:5 - INPUT baud rate
	hc	putRightNibble-x :6 - OUTPUT baud rate
	hc	putBit-x	:7 - parity
	hc	putBit-x	:8 - half duplex
	hc	putLeftNibble-x	:9 - parameter A
	hc	putRightNibble-x :10 - parameter B
	hc	putLeftNibble-x	:11 - parameter C
	hc	putBit-x	:12 - X enable
	hc	putBit-x	:13 - echo <CTL> H
	hc	putBit-x	:14 - reverse X enable
	hc	putRightNibble-x:15 - parameter D
	hc	putBit-x	:16 - katakana
	hc	putBit-x	:17 - term out on <BREAK>
	hc	putBit-x	:18 - echo <ESCAPE>
	hc	putBit-x	:19 - 'Q' - mode


:ROUTINE OCSMS
:       OUTPUT "CANNED" STRING - BUT DO A MASK BEFORE PUT CHARACTER INTO ORING.
:       LINK ON R5
:       R1 = THE MASK (FOR MSV3.00 THIS IS FOR RESETTING THE PARITY BIT)
:       R2 = PORT#
:       R3 = POINTER TO TEXT STRING( FORMAT N\B1\B2\...\BN )
OCSMS   hs      0
        STH     R1,STMASK               :save the mask

	lb	r0,(0),r3
	ais	r0,(6)
	nhi	r0,(0fffc)
	jal	r4,Room

	if	\(seqring)
	  l	  r4,(Csnum),,
	  st	  r4,(ORsnum+ORsize),r15,
	ei

	lr	r0,r2
	jal	r4,PutH			:port number

	lb	r2,(0),r3		:length into count-down register

	lr	r0,r2			:length is also message type
	jal	r4,PutCH
OCSMS1
	  ais	  r3,(1)
	  lb	  r0,(0),r3		:dig out a character
          NH      R0,STMASK             :mask out the specified bit(s)
	  jal	  r4,PutCH

	sis	r2,(1)			:count down till all sent
	jgbs	OCSMS1

	jal	r4,ELOR

	jr	r5




:ROUTINE OBSMS: OUTPUT A BYTE STRING
:       THE DIFFERENCE BETWEEN OBSMS AND OBS IS OBSMS ALWAYS MASKS
:       THE CHARACTER BEFORE PUT IT TO OUT RING.
:       FOR MENU SERVER 3.00 THAT IS FOR RESETTING THE PARITY BIT WHEN
:       IT IS NECESSARY.
:       R5 = LINK REGISTER
:       R3 = POINTER TO STRING
:       R2 = NUMBER OF CHARACTERS TO OUTPUT FROM STRING
:       R1 = THE MASK
OBSMS1
        AIS     R3,1
OBSMS
        LB      R0,0,R3
        NR      R0,R1           :MASK OUT THE SPECIFIED BIT(S)
        JAL     R4,PUTCH

        SIS     R2,1
        JGBS    OBSMS1

        JR      R5

        SUBTTL  MSVTKL.Sxx - routines for tickler function

: (MNEUDEV)MSVTKL.S30   GWH     9/30/87
: MSVTKL.Sxx - this file is created for tickler display in MSV 3.00
:       It contains the routines for tickler process.


: TKLCMD routine - this is the main routine of the tickler process. 
:       It disables the menu timeout, sets consat in proper mode and 
:       then processes the M.A.'s request.
: LINK  R11
: IN    R1      - the sat port#
:       R13     - RUCB, addr to UCB
: REG   no reg preserved

TKLCMD
        LIS     R0,0
        LHL     R1,TSATSIDE,RUCB        :get the sat port#

        STB     R0,TOARRAY,RINCOMINGR1  :stop the menu timeout
        LHI     R0,CSMALG               :set state to MA login
        STB     R0,CSTATE,R1

        LR      RTSATSIDER10,RINCOMINGR1
        LB      R6,RELATIVEHOST,RUCB
        LHL     R0,TKLHTO,R6,R6
        STH     R0,UHTIVL,RUCB          :enable the host timeout

        TBT     R6,MALGIN               :someone else login?
        IFF(N)                          :someone else login as a MA
          LA    R3,TM2MA,,
          LHI   R1,$07F
          JAL   R5,SHIPTOTSAT           :display 2 MA login msg

          J     TKLQIT                  :force this guy quit
        ORELSE
          SBT   R6,MALGIN               :lock the M.A. access
          SBT   R10,MAUSER              :flag this port is M.A.
        ENDIF

        TBT     R6,CURTKL               :do we have tickler on display?
        IFF(N,SHORT)                   
          LA    R3,TMDIS,,              :show "tickler on display" msg
        ORELSE(SHORT)
          LA    R3,TMNDIS,,             :show "no tickler on display" msg
        ENDIF

        LHI   R1,$07F
        JAL   R5,SHIPTOTSAT


        TBT     R6,NXTTKL               :do we have another tickler standby?
        IFF(N)                          :if (next tickler)
          LH    R3,TKLSTM,R6,R6
          IFF(GE)                       :if (not display now)
            LA    R3,TMTIME+1,,           :addr of where to put the schedule
            JAL   R5,FILLTM               :fill the schedule in the msg

            LA    R3,TMNXTT,,             :show "next tickler schedule"
            LHI   R1,$07F
            JAL   R5,SHIPTOTSAT
  
            LA    R3,TMTIME,,
            LHI   R1,$07F
            JAL   R5,SHIPTOTSAT
          ORELSE(SHORT)                 :else(display now)
            LA    R3,TMUPDT,,
            LHI   R1,$07F
            JAL   R5,SHIPTOTSAT
          ENDIF                         :endif(not display now)
        ENDIF                           :endif(next tickler)

        LB   R1,RELATIVEHOST,RUCB
        LB   R2,TKL8,R1,
        IFF(N)                          :if an 8bit tickler then
          SBT  R10,ETMOUT

          LR   R2,R10
          LA   R3,ETMBUF                :send an ETM out
          JAL  R5,OCM
        ENDIF

        DO(FOREVER)                     :Do( selected command until quit )

          LA    R3,TMCMND,,             :display the available command
          LHI   R1,$07F
          JAL   R5,SHIPTOTSAT

          JALR  R5,R11                  :get a char through the co-routine

          JAL   R5,ECHOCHAR
                :IN - R0 the input char
                :OUT- R8 the true input char
                :    ( no parity bit if in non-tranparent mode )
                :REG- R0~R5,R8

          CASE(R8)                      :case of command
            WHEN(TCNEW)
                JAL     R6,NEWTKL       :edit tickler

            WHEN(TCDIS)                 :display the tickler
                JAL     R6,TKLDIS

            WHEN(TCSCH)                 :set the schedule
                LB      R1,RELATIVEHOST,RUCB
                TBT     R1,NXTTKL               :do we have another tickler standby?
                IFF(N)                          :if (next tickler)
                  LH    R3,TKLSTM,R1,R1
                  IFF(GE)                       :if (not display now)
                    LA    R3,TMTIME+1,,           :addr of where to put the schedule
                    JAL   R5,FILLTM               :fill the schedule in the msg
        
                    LA    R3,TMNXTT,,             :show "next tickler schedule"
                    LHI   R1,$07F
                    JAL   R5,SHIPTOTSAT
  
                    LA    R3,TMTIME,,
                    LHI   R1,$07F
                    JAL   R5,SHIPTOTSAT
                  ORELSE(SHORT)                 :else(display now)
                    LA    R3,TMDNOW,,
                    LHI   R1,$07F
                    JAL   R5,SHIPTOTSAT
                  ENDIF                         :endif(not display now)

                  LB   R1,RELATIVEHOST,RUCB
                  LH   R2,TKLPNT,R1,R1            :the offset
                  LA   R3,TKLMSS,R2,              :the begining addr
                  JAL  R5,TKLD1
                ENDIF                           :endif(next tickler)

                JAL     R6,SETSCH

            WHEN(TCQUIT)
                J       TKLQIT          :logoff

            OTHERWISE
                LA      R3,TMERCM,,     :command error message
                LHI     R1,$07F
                JAL     R5,SHIPTOTSAT

          ENDCASE       :end case of command
        ENDDO   :end do forever unless quit


: TKLQIT - zap the M.A.
TKLQIT  HS      0
        LB      R0,RELATIVEHOST,RUCB

        LH      R10,TSATSIDE,RUCB
        TBT     R10,MAUSER
        IFF(N,SHORT)            :if it is M.A.
          RBT   R10,MAUSER
          RBT   R0,MALGIN       :release the lock to allow MA login
        ENDIF

        TBT     R10,ETMOUT
        IFF(N,SHORT)            :if sat is in trnasparent mode
          LR      R2,RTSATSIDER10
          LA      R3,LTMBUF,,
          JAL     R5,OCM,,

          RBT     R10,ETMOUT
        ENDIF

        LA      R3,TMBYE,,
        LHI     R1,$07F
        JAL     R5,SHIPTOTSAT

        LR      R2,RTSATSIDER10
        LA      R3,DETACHBUF,,
        JAL     R5,OCM,,

        DO(FOREVER)             :ignore the rest of the data
          JALR  R5,R11          :wait until the circuit fail
        ENDDO


: MSKBYT routine - this routine mask out the parity bit if it is 
:       in non-transparent mode.
: LINK  R5
: IN    R0      - the input char
:       R10     - the sat port#
: OUT   R0      - the true value of the char
: REG   all reg preserved except R0

MSKBYT  hs      0
        TBT  R10,ETMOUT
        IFF(E,SHORT)            :if in nontransparent mode
          NHI  R0,$07F
        ENDIF

        JR   R5
        

: NEWTKL routine - this routine makes up a new tickler message.
:       That includes collecting the text, displaying the message and 
:       setting schedule.
: LINK  R6
: IN    
: REG   
NEWTKL  HS      0
        LB      R1,RELATIVEHOST,RUCB
        TBT     R1,NXTTKL
        IFF(N)                          :there is a tickler standby
          LA    R3,TMABOT,,             :msg ask for ok to abort scheduled tkl
          LHI   R1,$07F
          JAL   R5,SHIPTOSAT

          JALR  R5,R11                  :get the response through co-routine
          JAL   R5,ECHOCHAR

          CASE(R8)                      :case of confirm
            WHEN(ASCUPY)                :when CR/Y/y, continue
            ORWHEN(ASCLWY)
            ORWHEN(CR)
              J    NEW1
            OTHERWISE                   :other char means no
              JR        R6              :return to the command selection
          ENDCASE
        ENDIF

NEW1
        ST      R6,RTNAD1,RUCB          :save the return addr

        LA      R3,TMENTR,,             :display "please enter"
        LHI     R1,$07F                 
        JAL     R5,SHIPTOTSAT
        
        LA      R3,TMPRMP,,             :display promp for text
        LHI     R1,$07F
        JAL     R5,SHIPTOTSAT

        JALR    R5,R11                  :get the char through co-routine

        LB      R1,RELATIVEHOST,RUCB    
        RBT     R1,NXTTKL               :abort the previous tickler

        LIS     R6,0
        STH     R6,TKLTIC,R1,R1         :reset the schedule

        LH      R9,TKLPNT,R1,R1         :the begining point of this host
        STH     R6,TKLMSS,R9,           :set to empty msg
        LH      R7,TKLSIZ,R1,R1
        AR      R7,R9                   :the maximum for this tkl
        AIS     R9,1                    :sc format
        
        LBR     R8,R0                   :save the original char
        JAL     R5,MSKBYT               :R0 = char without parity

        CLHI    R0,CTLD
        DO(WHILE,N)                     :Do while char <> cntlD
                :In this loop
                :R6 - the length of the line
                :R7 - the max of this tkl
                :R9 - line index, point to first byte of the text
                :     In sc format, it's the SECOND byte.
          
          LR    R1,R0                   :case destroyed reg
          CASE(R1)                      :case of get a char
            WHEN(CR)                    :??HOW ABOUT NL/LF, start a new line
              LR    R1,R9
              AR    R1,R6
              CR    R1,R7              
              IFF(L)                    :not over the size yet
                STB   R0,TKLMSS,R6,R9   
                LIS   R0,LF
                STB   R0,TKLMSS+1,R6,R9 :put cr/lf

                AIS   R6,2
                STB   R6,TKLMSS-1,R9,   :update the string length,SC format
                LIS   R6,0              :start from the begining of the line

                AHI   R9,TKLNLE

                LR    R0,R8             :restore the original char
                JAL   R5,ECHOCHAR

                LA   R3,TMPRMP,,        :display promp
                LHI  R1,$07F
                JAL  R5,SHIPTOTSAT

              ORELSE(SHORT)             :else over the max size
                LA    R3,TMFULL,,       :tickler buffer is full
                LHI   R1,$07F
                JAL   R5,SHIPTOTSAT
              ENDIF                     :endif over size

            WHEN(CTLA)                  : (char = ^a)
              LR  R6,R6
              IFF(LE)                   :if (the line is empty)
                LA   R3,BELBUF,,
                LHI  R1,$07F
                JAL  R5,SHIPTOTSAT
              ORELSE
                LA   R3,BKSPAC,,        :bs/sp/bs
                LHI  R1,$07F
                JAL  R5,SHIPTOTSAT
                SIS  R6,1
              ENDIF                     :endif (the line is empty)

            WHEN(CTLQ)                  : (char = ^q)
              LIS  R6,0                 :ignore this line of text

              LA   R3,UPCURBUF,,        : send a new line( cr/lf )
              LHI  R1,$07F
              JAL  R5,SHIPTOTSAT
          
            OTHERWISE                   : other chars
              LR   R1,R9
              AR   R1,R6
              CR   R1,R7
              IFF(L)                    :iff not oversize, go ahead
                CLHI R6,TKLNLE-1-2      : -1 is because of SC format
                                        : -2 cause cr is stored as cr/lf
                IFF(L,SHORT)            :if (not over the line length)
                  STB  R0,TKLMSS,R6,R9  :put it in
                  AIS  R6,1             :advance the index
                  LR   R0,R8
                  JAL  R5,ECHOCHAR
                ORELSE(SHORT)           :else (over the line length)
                  LA   R3,TMTOLN,,      :line too long
                  LHI  R1,$07F
                  JAL  R5,SHIPTOTSAT
                ENDIF                   :endif (not over the line lengh)
              ORELSE(SHORT)             :else over the max size
                LA    R3,TMFULL,,       :tickler buffer is full
                LHI   R1,$07F
                JAL   R5,SHIPTOTSAT
              ENDIF                     :endif not oversize
          ENDCASE                       :endcase (get the char)

          ST   R6,SAVER6,RUCB
          ST   R7,SAVER7,RUCB
          ST   R9,SAVER9,RUCB

          JALR R5,R11                   :get the char through co-routine

          L    R6,SAVER6,RUCB
          L    R7,SAVER7,RUCB
          L    R9,SAVER9,RUCB

          LR   R8,R0                    :save the original char for echo
          JAL  R5,MSKBYT
          CLHI R0,CTLD
        ENDDO                           :enddo (not quit char<>^d)          
        
        LIS  R1,0
        LB   R0,TKLMSS,R6,R9            :last char 
        CLHI R0,CR
        IFF(E)                          :CHAR = CR
          STB  R1,TKLMSS+TKLNLE-1,R9,   :terminator at offset r9+tklnle-1 
        ORELSE
          STB  R6,TKLMSS-1,R9,          :length of last line
          STB  R1,TKLMSS-1+TKLNLE,R9,   :terminator at offset r9+tklnle-1
        ENDIF

        LA   R3,TMNEWM,,                :new  message 
        LHI  R1,$07F
        JAL  R5,SHIPTOTSAT

        LB   R1,RELATIVEHOST,RUCB
        LH   R2,TKLPNT,R1,R1            :the offset
        LA   R3,TKLMSS,R2,              :the begining addr
        JAL  R5,TKLD1

        LB   R1,RELATIVEHOST,RUCB
        SBT  R1,NXTTKL                  :set in order to set schedule
        JAL  R6,SETSCH

        L    R6,RTNAD1,RUCB
        JR   R6


: SETSCH routine - this routine collects and validates the schedule.
: LINK  R6
: IN    RUCB - R13 addr of the ucb
: OUT   
: REG   no reg preserved
SETSCH  HS      0
        ST   R6,RTNAD2,RUCB

        LB   R1,RELATIVEHOST,RUCB
        TBT  R1,NXTTKL
        IFF(E)          :if we dont have nxt tickler
          LA   R3,TMNNX,,       :no next tickler msg
          LHI  R1,$07F
          JAL  R5,SHIPTOTSAT
        ORELSE          :got a nxt tickler
          LB   R1,RELATIVEHOST,RUCB
          RBT  R1,NXTTKL                :initial to invalid schedule
                                        :to prevent timeout rtn jump on fire
          LA   R3,TMESCH,,              :display 'enter schedule' msg
          LHI  R1,$07F
          JAL  R5,SHIPTOTSAT

          DO                            :do until done
            :in this loop R0 is used as the check flag

            JAL  R5,GETTIM
                 :all reg destroyed
                 :R4 = return flag(valid/invalid/abort)

            CASE(R4)    :case  of valid/inval/abort

              WHEN(VALID)                 :if we got a valid time(flag=0)
                LB   R1,RELATIVEHOST,RUCB
                SLHLS R1,2
                LB   R2,TKLSCH+TKHOUR,R1
                CLHI R2,CR
                IFF(E)                    :only 'cr'
                  LA   R3,TMEFF,,         :display 'effect now' msg
                ORELSE
                  LA   R3,TMTM+1,,        :SC format
                  JAL  R5,FILLTM

                  LA   R3,TMSCH,,         :display schedule
                  LHI  R1,$07F
                  JAL  R5,SHIPTOTSAT
  
                  LA   R3,TMTM,,
                  LHI  R1,$07F
                  JAL  R5,SHIPTOTSAT
  
                  LA   R3,TMCFM,,         :ask for confirmation
                ENDIF

                LHI  R1,$07F
                JAL  R5,SHIPTOTSAT
              
                DO                          :do until comfirmed
                  :in this loop R1 is used as check flag
                  JALR R5,R11               :get the char through co-routine

                  JAL  R5,ECHOCHAR

                  CASE(R8)                  :case of decision
                    WHEN(ASCUPY)
                    ORWHEN(ASCLWY)
                      JAL  R4,TM2TIC

                      LB   R1,RELATIVEHOST,RUCB
                      SBT  R1,NXTTKL
                      LIS  R0,1             
                      LIS  R1,1

                    WHEN(ASCUPN)
                    ORWHEN(ASCLWN)
                      LA   R3,TMESCH,,
                      LHI  R1,$07F
                      JAL  R5,SHIPTOTSAT

                      LIS  R0,0
                      LIS  R1,1

                    WHEN(ESCAPE)
                      LA   R3,TMABRT,,
                      LHI  R1,$07F
                      JAL  R5,SHIPTOTSAT

                      LIS  R0,1
                      LIS  R1,1

                    OTHERWISE
                      LA   R3,TMCFM,,               :ask for confirmation
                      LHI  R1,$07F
                      JAL  R5,SHIPTOTSAT

                      LIS  R1,0
                  ENDCASE                           :end case of decision

                  LR   R1,R1                        :check the flag
                ENDDO(WHILE,E)                      :enddo until confirmed
            
              WHEN(ABORT)                           :user quit
                LA   R3,TMABRT,,
                LHI  R1,$07F
                JAL  R5,SHIPTOTSAT

                LIS  R0,1

              OTHERWISE                             :inval
                LA   R3,TMERS,,
                LHI  R1,$07F
                JAL  R5,SHIPTOTSAT

                LIS  R0,0
            ENDCASE                     :endcase of return flag

            LR   R0,R0
          ENDDO(WHILE,E)                :enddo until done

          L    R6,RTNAD2,RUCB           :restore the return addr
        ENDIF           :endif we don't have nxt tickler

        JR   R6

: GETTIM routine - this routine collects and validates the schedule.
: LINK  R5
: IN    RUCB - addr of the UCB
: OUT   R4 - the error flag : valid, inval or abort
: REG   no reg preserved

GETTIM  HS      0
        ST   R5,RTNAD3,RUCB             :store the return addr        
        LIS  R7,0

        DO(FOREVER)
          ST   R7,SAVER7,RUCB           :save the index
          JALR R5,R11                   :call co-routine to get char
          L    R7,SAVER7,RUCB

          LR   R8,R0                    :save the original char
          JAL  R5,MSKBYT

          LR   R1,R0                    :case destroyed reg
          CASE(R1)                      :case of input char
            WHEN(CR)
              LR   R7,R7
              IFF(E)                    :if only CR
                LB   R3,RELATIVEHOST,RUCB
                SLHLS R3,1
                STB  R0,TKLSCH+TKHOUR,R3,R3
                LCS  R4,1               :set the sechedule time is now
                STH  R4,TKLSTM,R3
                LIS  R4,VALID
              ORELSE
                CHI  R7,MXTIDX
                IFF(N,SHORT)            :if not HHMM
                  LIS  R4,INVAL
                ORELSE(SHORT)           :format is right check contains
                  JAL  R5,CKSCH
                       :R0~R5 destroyed
                       :R4 - returned error flag( valid/inval )
                ENDIF
              ENDIF        
              EXITDO

            WHEN(ESCAPE)
              LIS  R4,ABORT
              EXITDO

            WHEN(CTLA)
              LR   R7,R7
              IFF(E,SHORT)              :if it is empty
                LA   R3,BELBUF,,
              ORELSE(SHORT)
                SIS  R7,1
                LA   R3,BKSPAC,,
              ENDIF
              LHI  R1,$07F
              JAL  R5,SHIPTOTSAT

            OTHERWISE
              AIS  R7,1
              CHI  R7,MXTIDX
              IFF(G,SHORT)              :if more then HHMM
                SIS  R7,1               :ignore the char
                LA   R3,BELBUF,,        :beep user
                LHI  R1,$07F
                JAL  R5,SHIPTOTSAT
              ORELSE
                LB   R3,RELATIVEHOST,RUCB
                SLHLS R3,2
                STB  R0,TKLSCH-1,R7,R3          :because R7 increament first

                LR   R0,R8
                JAL  R5,ECHOCHAR                :echo the original char
              ENDIF                     :endif (more then HHMM)
            ENDCASE             :endcase (input)
        ENDDO           :enddo (forever)

        L    R5,RTNAD3,RUCB
        JR   R5

: CKSCH routine - this routine validates the schedule user types.
: LINK  R5
: IN    TKLSCH[host] contains HHMM in ascii
: OUT   R4 the error flag (inval/valid)
: REG   R0~R5 destroyed

CKSCH   HS      0
        ST   R5,TKSCR1

        LB   R1,RELATIVEHOST,RUCB
        SLHLS R1,2                   :fullword for each host

        LA   R3,TKLSCH+TKHOUR,R1
        LIS  R2,2
        JAL  R5,ASCBIN
             :R0~R5 destroyed
             :R0 the binary value, 0 if error occured
             :R4 return flag (valid/inval)

        CHI  R4,VALID
        IFF(E)                          :if (input is valid)
          LB   R1,RELATIVEHOST,RUCB
          SLHLS R1,1                      :half word for each host
          STH  R0,TKLSTM,R1

          CHI  R0,MXHOUR
          IFF(GE,SHORT)                   :iff (not a valid hour)
            LIS  R4,INVAL
          ORELSE
            SLHLS R1,1                    :fullword array
            LA   R3,TKLSCH+TKMIN,R1
            LIS  R2,2
            JAL  R5,ASCBIN

            CHI  R4,VALID
            IFF(E)                          :if (not  digit)
              CHI  R0,MXMIN
              IFF(GE,SHORT)                 :if (not a valid minute)
                LIS  R4,INVAL
              ORELSE                        :else (valid minute)
                LB   R1,RELATIVEHOST,RUCB
                LH   R2,TKLSTM,R1,R1
                LHI  R3,$A60                :convert hour into min
                MHR  R3,R2
                AR   R3,R0                  :the schedule time in mins        
                STH  R3,TKLSTM,R1,R1        :store the time difference in mins
              ENDIF                         :endif (not a valid minute)
            ENDIF                           :endif (not digit)
          ENDIF                           :endif (not a valid hour)
        ENDIF                           :endif (input is valid)

        L    R5,TKSCR1
        JR   R5


: ASCBIN routine - this routine converts ascii digits into it's binary value
:       it can only recognize 0~9 not include space or sign.
:       note: only limit to fullword value, doesn't check overflow.
: LINK  R5
: IN    R3 address to the ASCII string
:       R2 how many digits
: OUT   R4 the error flag. VALID or INVAL
:       R0 the binary value, 0 if error occured
: REG   R0 ~ R4 destoryed

ASCBIN  HS      0
        ST   R5,TKSCR2

        LIS  R5,$A10
        LIS  R0,0
        LIS  R4,VALID           :init to valid time

        LR   R2,R2
        DO(WHILE,N)             :do while (not the end)
          LB   R1,0,R3
          SHI  R1,ASC0
          IFF(L,SHORT)                  :if ( <0 invalid digit )
            LIS  R4,INVAL
            LIS  R0,0
            EXITDO
          ORELSE
            CHI  R1,9
            IFF(G,SHORT)                :if (>9 invalid digit)
              LIS  R4,INVAL
              LIS  R0,0
              EXITDO
            ORELSE
              MHR  R0,R5
              AR   R0,R1
              AIS  R3,1
            ENDIF                       :endif (great then 9)
          ENDIF                         :endif (less then 0)
          SIS  R2,1
        ENDDO                           :enddo while( not the end )

        L    R5,TKSCR2
        JR   R5


: TKLDIS routine - this routine displays the tickler.
: LINK  R6
: IN    RUCB - addr to the ucb
: REG   R0~R5 destroyed

TKLDIS  HS      0
        LB   R1,RELATIVEHOST,RUCB
        TBT  R1,CURTKL
        IFF(N)                  :if we have the current tickler
          LA   R3,TMHDC,,       :display the header
          LHI  R1,$07F
          JAL  R5,SHIPTOTSAT

          LB   R1,RELATIVEHOST,RUCB
          LH   R2,TKLPNT,R1,R1
          LA   R3,TKLMSC,R2,
          JAL  R5,TKLD1
        ORELSE(SHORT)           :else no tickler 
          LA    R3,TMNDIS,,     :show "no tickler on display" msg
          LHI   R1,$07F
          JAL   R5,SHIPTOTSAT
        ENDIF                   :endif we have the current tickler

        LB   R1,RELATIVEHOST,RUCB
        TBT  R1,NXTTKL
        IFF(N)                  :if we have the tickler
          LH   R3,TKLSTM,R1,R1
          IFF(GE)               :if (not display now)
            LA   R3,TMTIME+1,,
            JAL  R5,FILLTM

            LA   R3,TMNXTT,,
            LHI  R1,$07F
            JAL  R5,SHIPTOTSAT

            LA   R3,TMTIME,,
            LHI  R1,$07F
            JAL  R5,SHIPTOTSAT
          ORELSE(SHORT)         :else (display now)
            LA   R3,TMNOW,,
            LHI  R1,$07F
            JAL  R5,SHIPTOTSAT
          ENDIF                 :endif (not dispaly now)

          LB   R1,RELATIVEHOST,RUCB
          LH   R2,TKLPNT,R1,R1
          LA   R3,TKLMSS,R2,
          JAL  R5,TKLD1
        ORELSE(SHORT)           :else no nxt tickler
          LA   R3,TMNNX,,       :no next tickler msg
          LHI  R1,$07F
          JAL  R5,SHIPTOTSAT
        ENDIF                   :endif we have the tickler

        JR   R6


: TKLTMO routine - this timeout routine counts down the ticks of the 
:       scheduled tickler.  It updates the tickler when the time is up.
: LINK  TORET
: IN
: REG

TKLTMO  hs      0
        AI   R1,RATE*$A60       :run per min
        JAL  R5,TOPUT           :put it back
        
        LIS  R5,0               :initial the host index
        LHI  R4,H+1
        DO(COUNT,R4)            :do (over all host)
          TBT  R5,NXTTKL        :any standby tickler?
          IFF(N)                :if we do have one
            LH   R0,TKLTIC,R5,R5
            IFF(LE)             :if being timeout then
              LCS  R1,1         :set the empty flag
              LH   R3,TKLPNT,R5,R5      :get the offset of this host
              LB   R2,TKLMSS,R3,
              DO(WHILE,N)       :do while (not end of message)
                LIS  R1,0
                AIS  R2,1       :because of the SC format
                DO(COUNT,R2)    :copy the line over
                  LB   R0,TKLMSS,R1,R3
                  STB  R0,TKLMSC,R1,R3
                  AIS  R1,1
                ENDDO           :enddo count(copy line over)

                AHI  R3,TKLNLE
                LB   R2,TKLMSS,R3,      :check next line
              ENDDO             :enddo while (not end of message)

              STB  R2,TKLMSC,R3, :put terminator 

              LR   R1,R1        :check the empty flag
              IFF(GE,SHORT)          :if not empty
                SBT  R5,CURTKL            :enable the tickler display
              ENDIF                  :endif empty
              RBT  R5,NXTTKL    :clear the next tkl flag
            ORELSE              :else (not timeout yet)
              LH   R2,TKLTIC,R5,R5
              SIS  R2,1
              STH  R2,TKLTIC,R5,R5
            ENDIF               :endif (being timeout)
          ENDIF                 :endif (we have a standby tickler)

          AIS  R5,1             :next host
        ENDDO                   :enddo (over all host)

        J    TORET

: TKLD1 routine - send a message to Tsat. The message consists of
:       the SC format strings.
: LINK  R5
: IN    R3 the addr of the message. 
: REG   R0~R5 destoryed

TKLD1   hs      0
        ST   R5,TKSCR2
        ST   R8,TKSCR3

        LR   R8,R3

        LB   R0,0,R8            :Is tickler empty?
        IFF(N)                  :if we do have a tickler
          LA   R3,CRLFBUF,,     :send a cr/lf
          LHI  R1,$07F
          JAL  R5,SHIPTOTSAT

          DO                    :do while (not end of message)
            LR   R3,R8          :display this line
            LHI  R1,$00FF
            JAL  R5,SHIPTOTSAT

            AHI  R8,TKLNLE
            LB   R0,0,R8
          ENDDO(WHILE,N)        :enddo while (not end of message)

          LA   R3,CRLFBUF,,     :send a cr/lf
          LHI  R1,$07F
          JAL  R5,SHIPTOTSAT
        ORELSE                  :else empty tickler
          LHL  R10,TSATSIDE,RUCB
          TBT  R10,MAUSER
          IFF(N,SHORT)          :if display to M.A.
            LA   R3,TMEMPT,,
            LHI  R1,$07F
            JAL  R5,SHIPTOTSAT
          ENDIF
        ENDIF                   :endif we have a tickler

        L    R5,TKSCR2
        L    R8,TKSCR3
        JR   R5



: FILLTM routine - fill the schedule in the message
: LINK  R5
: IN    R3 - addr of where to put the schedule
: REG   R0~R5 destroyed

FILLTM  hs     0
        LB   R2,RELATIVEHOST,RUCB
        LH   R0,TKLSTM,R2,R2    :the schedule in mins

        CHI  R0,NOON            :noon = 60*12
        IFF(GE,SHORT)           :if it is P.M
          LI   R1,P.M
        ORELSE(SHORT)
          LI   R1,A.M
        ENDIF
        STB  R1,SCHMRK,R3       :put it in

        LHI  R4,$A60
        DHR  R0,R4              :quotient in R1 - hour
        LB   R0,HRMAP,R1,R1     :get the corresponding value
        STB  R0,SCHTMH,R3       :fill the hour
        LB   R0,HRMAP+1,R1,R1     
        STB  R0,SCHTMH+1,R3       

        SLHLS R2,2              :fullword in ascii time array
        LB   R1,TKLSCH+TKMIN,R2
        STB  R1,SCHTMM,R3       :fill the minute
        LB   R1,TKLSCH+TKMIN+1,R2
        STB  R1,SCHTMM+1,R3 

        JR   R5


: TM2TIC routine - this routine conmverts the schedule into ticks
:       for the timeout routine to count down
: LINK  R4
: IN    RUCB
: REG   R0~R4 destroyed

TM2TIC  hs      0
        LB   R1,RELATIVEHOST,RUCB
        LH   R0,TKLSTM,R1,R1            :schedule time specified in mins
        IFF(L)                          :if effect now
          LIS   R0,0
        ORELSE
          L    R3,GMT,,
          SR   R2,R2
          LI   R1,$A 60*60*24           :get how many seconds
          DR   R2,R1
          LR   R3,R2
          SR   R2,R2
          LHI  R1,$A 60
          DR   R2,R1                    :get how many mins in today

          AHI  R3,$A 60*TIMZON          :adjust to the local time
          IFF(L)                        :if it is the previous day
            AHI  R3,$A1440
          ORELSE
            CHI  R3,$A1440
            IFF(GE,SHORT)               :the next day
              SHI  R3,$A1440
            ENDIF
          ENDIF

          SR   R0,R3                    :schedule time - current time
          IFF(L,SHORT)
            AHI  R0,$A1440              :it is on the next day
          ENDIF
        ENDIF                           :endif effect now

        LB   R1,RELATIVEHOST,RUCB
        STH  R0,TKLTIC,R1,R1

        JR   R4
        

	subttl host cost and host port availability reports (MSCOST.Sxx)

:(J.BURKE)MSCOST.S20
: from (J.BURKE)MSCOST.S13 by JSB, 12/12/86.
:
:  Split out from MC.R12, JSB, 11/5/86.

: PERHAPssendreports - 
:   Timeout Routine to check to see if one of these reports should be sent
:----------------------------------------------------------------------

rRHNr6	eq	r6

PerhapsSendReports
	ai	r1,(RATE*($a15))
	jal	r5,TOPUT		:re-execute 15 seconds in future

	lhi	rRHNr6,(h+1)
psrLoop
	sis	rRHNr6,(1)
	jl	TORET

	  if	CostMacroInvoked
	    lb	    r5,(CostInReality),rRHNr6,
	    clb	    r5,(CostAsSupBelievesIt),rRHNr6,
	    jefs    z1                          :jump, no change.
	      stb     r5,(CostAsSupBelievesIt),rRHNr6,
                                                 :with R5 = cost,
	      jal     r9,SendHostCostReport      :send report to Sup.
z1
	  ei

: here's where we see if the sup knows this host's HPA status correctly

	  tbt	  rRHNr6,(HpaInReality)
	  jnfs	  z2			:if ports are available

	    tbt	    rRHNr6,(HpaAsSupBelievesIt)
	    je	    psrLoop		:if agreement
	    lis	    r5,(0)
	    jfs	    z3
z2
	    tbt	    rRHNr6,(HpaAsSupBelievesIt)
	    jn	    psrLoop		:if agreement
	    lis	    r5,(1)
z3
	  jal	  r9,SendHPAreport
	  cbt	  rRHNr6,(HpaAsSupBelievesIt)  :sup sees things differently now
	j	psrLoop

SendHPAreport
	lhl	r0,(HOSTS),rRHNr6,rRHNr6
	sth	r0,(hpaHst)

	sth	r5,(hpaPrt)		:a 0 or a 1

	sth	rRHNr6,(hpaRhn)		:relative host number

	lis	r2,(0)			:send to SUP
	la	r3,(hpaBuf)
	jal	r5,OCM			:send a REPORT HOST PORT AVAILABILITY msg

	jr	r9


      if      CostMacroInvoked
: SENDHOstcostreport subroutine - Actual transmission of the message.
:   R5 - cost.
:   R9 - link.

SendHostCostReport
	lhl	r0,(HOSTS),rRHNr6,rRHNr6
	sth	r0,(hcoHst)

	sth	r5,(hcoCst)		:cost

	sth	rRHNr6,(hcoRhn)		:relative host number

	lis	r2,(0)			:send to SUP
	la	r3,(hcoBuf)
	jal	r5,OCM			:send a REPORT HOST COST msg

	jr	r9
      ei

ChangeRemainingQuota
:-------------------
: link on r9
: load r7 with -1 or +1
: load r6 with RHN

: ink or deck both the remaining quota for THIS host !"#
: and the number of server ports remaining

	ahm	r7,(RemainingQuotaTab),rRHNr6,rRHNr6	:can't be 0
	ahm	r7,(ServerPortsRemaining)		:can't be 0

	lhi	r7,(h)
loopy
	  jal	  r2,refigger
	sis	r7,(1)
	jgebs	loopy

	jr	r9

: select the lower of the two for hpa and hco determinations

refigger
	lh	r4,(RemainingQuotaTab),r7,r7
	clh	r4,(ServerPortsRemaining)
	jlefs	crq1			:if RemainingQuotaTab is the lower one

	  lh	  r4,(ServerPortsRemaining)
crq1

	clh	r4,(ubTab),r7,r7
	jgefs	crq2			:if greater than "ub" value

	  rbt	  r7,(HpaInReality)	:fallen below "ub"
	  jfs	  calcHoCo
crq2
	clh	r4,(aaTab),r7,r7
	jlefs	calcHoCo		:yet less than "aa" (somewhere between)

	  sbt	  r7,(HpaInReality)	:risen above "aa"

calcHoCo
      if      CostMacroInvoked
	lb	r3,(MxCsTab),r7
	jer	r2			:if MxCs = free (not multi-based)

	clh	r4,(LoAvTab),r7,r7
	jgfs	hco1			:if more ports than "lowest availability"

	  jer	  r2			:if the same, so what?

	  stb	  r3,(CostInReality),r7 :is less... make it most costly
	  jr	  r2
hco1
	clh	r4,(HiAvTab),r7,r7
	jlfs	SomewhereBetween	:if less ports than "highest"

	  jer	  r2			:if the same, so what?

	  lb	  r5,(MnCsTab),r7
	  stb	  r5,(CostInReality),r7 :is more... make it most cheap
	  jr	  r2

SomewhereBetween
	sh	r4,(LoAvTab),r7,r7
	dh	r4,(noppciTab),r7,r7	:num of paths per cost interval

: remainder = r4  
: quotient  = r5 = interval minus 1

	lr	r4,r4
	jnr	r2			:if between steps (there's a remainder)

	  ais	  r5,(1)
	  ah	  r5,(TableFinder),r7,r7
	  lb	  r5,(CostTable),r5	:dig HOST COST out of table
	  stb	  r5,(CostInReality),r7
      ei
	jr	r2


 subttl	status.lib - driver to process arbitrary commands under "?stat"
:
:	This program is the sole property and confidential
:	information of Tymshare, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.
:
:	STATUS - User Command Handler
:
:	Version history:
:
:	13.3  07/11/84  The following changes were made by Romolo Raffo.
:		Network Console protocol was added. This allowed Network
:		Console to communicate with Extended DDT Operations Managers.
:		The new features are controled by the assemble switch DB.NTC.
:		The default for this switch is off, so any program can use
:		this version of STATUS.LIB without change. Network Console
:		protocol is invoked by a command composed of four unprintable
:		characters. This is so hopefully no one will inadvertently
:		enter Network Console mode. If Network Console mode, the prompt
:		is no longer output, and the request for a "\" to be typed
:		after an error is removed. All commands received in this mode
:		begin with hex 8080 followed by a halfword ID. The command
:		following this header is unchanged. The response begins with
:		a hex 8081 followed by the commands halfword ID. The response
:		following this header is also unchanged, consisting of multiple
:		lines, each ending with a carriage return and a linefeed. After
:		the response, a trailer of hex 8082, the command ID and an
:		empty line is sent. All of this is handled by STATUS.LIB,
:		WITHOUT ANY CHANGE to the program using this package.
:
:		To use Network Console protocol, the following CHANGES MUST BE
:		MADE.
:			1) The variable DB.NTC must be set to one. This will
:			   cause the code to handle Network Console protocol
:			   to be assembled.
:
:			2) All jumps to label DSTART should be replaced by
:			   jumps to DS.NXT . The label DSTART is where DDT
:			   enters from the ?STAT command. It is now used to
:			   initialize the code to NOT using Network Console
:			   protocol.
:
:			3) Commands which have indefinite and possibly unending
:			   response, and need a way to abort the command,
:			   must call ds.Chk to check if the response should
:			   should end. If Network Console protocol, this call
:			   checks for a command end message from Network
:			   Console. Otherwise, it checks if any character has
:			   been entered. In either case, it does a normal
:			   return if no termination was received, and a skip-4
:			   return if termination was found.
:
:		Note that with these changes, users will still be able to use
:		the ?STAT command directly from DDT without any change.
:
:	13.2  01/27/81  <BAB>Added RADIX=0 at start of mod.  Added jump
:		following 'QUIT' SVC to allow DDT "P" (proceede) command
:		to return the user to ":>" prompt.
:
:	13.1  11/17/81	<BAB>Added DNEXTK support, DS.DLM (last delimeter),
:		and fixed backspace for > 4 character entry, added the
:		command thought to be invalid to invalid command message.
:
:	13	08/81	<JK>Maintenance assumed by BAB from John Kopf
:
:	The Status package is intended to provide an extension to DDT,
:	invokable via the "?STAT" command in DDT.  Once invoked you may re-
:	activate it (provided you have not issued any DDT "G" (go) commands)
:	by typing "P ".
:
:		There is limited editing control built into the package:
:
:	ESC	aborts back to command level,
:	^W	discards partial 'token' already input (word or number),
:	^A	discards last char of token (backspace).
:	^H	discards last char of token (backspace).
:
:	Delimiters may occur in multiple (e.g. ", " is OK).  Valid
:	delimiters are:
:
:	C/R	L/F	H/T	","	and BLANK.
:
:		Entry Points:
:
:	dStart	Initialize STATUS.LIB on new circuit.
:	ds.Nxt	Place to exit on completion of command.
:	dNexTk  Get next token with out prompt.
:	ds.Ill	Place to exit on illegal command -- types "Illegal command"
:	ds.Err	Place to exit on command error -- types "type '\' "
:	ds.Exi	Place to exit machine.
:	ds.Qui	Place to exit back to DDT.
:
:	ds.gCh	Get a character...Link on R1, char (with high-order bit forced)
:		in R0...normal return if detected ^W, skip-4 if detect
:		~A, aborts back to ds.Nxt if detects ESC.
:
:	ds.Del	Check for delimiter...Link on R2, Character in R0.  Skip-4
:		return unless this is a delimiter, then normal return.
:
:	ds.cuc	Convert to upper case...Link on R1, Character in R0.
:
:	ds.Tok	Get a string token...Link on R4, TOKEN returned in R3...
:		inputs up to 4 characters, returns them (in uppercase)
:		left justified, 0 fill
:
:	ds.Num	Get a number...Link on R5, expects Radix in R4...
:		number returned in R0.  May ABORT if any character is
:		input other than valid digit or delimiter.
:
:	ds.Chk	Check if command termination entered...Link on R4. Skip-4
:		if termination entered, otherwise takes normal return.
:
:	ds.Dlm  Location of last delimeter entered (1 byte)
:
:	There are two built-in commands:
:
:	Quit	exit back to DDT.
:	EXIt	exit machine.
:
:	additional commands may be defined via the ds.Cmd macro:
:
:	 ds.Cmd(TEXT,ADDR)
:
:	Where:	TEXT	The (UPPERCASE) target command string.
:		ADDR	The virtual address to transfer to, to service that
:				command.
:	ds.Cmd generates a 3-word discriptor for this command, at the point
:	assembly where it is invoked.  This discriptor is on a WORD boundary.
	if	\(db.sta)		:default debug/status to on
	else
db.sta	  eq	  1
	ei

      if      db.sta			:assemble only with debug status on

	mo	(.),status

	ra	$0 0

	gl	db.ntc
db.ntc	eq	1			:<--------<< i put this in - jce

	if	\(db.ntc)
	else
db.ntc	  eq	  0			:default Network Console protocol to off
	ei

	gl	dStart,ds.ell,ds.Ill,ds.Err,ds.Dlm
	gl	ds.Tok,ds.Num,ds.Exi,ds.Qui,ds.gCh,ds.cuc,ds.Del

	if	db.ntc
	  gl	  ds.Nxt,ds.Chk		:<--------<<
	ei

OUT	eq	0b			:output svc
IN	eq	0a			:input svc
ds.ell	eq	0			:null pointer for end of linked list

	seg	a.data

ds.Dlm	bs	1			:last delimeter encountered

	if	db.ntc
responseEndFlag bs 1
networkConsoleFlag bs 1

: Force nc.ID data (two bytes after length) to begin on a halfword
: boundry. This is needed for compares and stores from hdr.ID

:::	  org	  .-1
:::	  bnd	  1			:say what?
:::	  org	  .+1

	  bnd	  2
	  bs	  1
nc.ID	  sc	  /00/			: Current NTCN command ID
hdr.ID	  hs	  1			: Last message header ID
	ei

r4sav	ws	1			:save area for r4 in ds.Tok
badStr	sc	/'xxxx'"8d"8a/		:place to put bad command

	seg	a.code

c.Next	eq	0			:pointer to next entry
c.Addr	eq	c.Next+4		:pointer to command handler
c.Str	eq	c.Addr+4		:relative position of string

ds.Cmd	macro(STR,ADDR)[		:type STR to run ADDR
	if	ds.ell
x	  ws	  0
	  org	  ds.ell
	  wc	  x
	  org	  x
	ei
ds.ell	wc	0
	wc	ADDR
	ac	/STR/
	bnd	4
]
	nolist	

cmdLst	ws	0			:force to word boundary
	ds.cmd(Q,ds.Qui)
	ds.cmd(QUIT,ds.Qui)
ds.Qui
	svc	KIO,(1)			:return to ddt
	j	ds.Nxt			:if operator typed "p", get next command

	ds.cmd(EXIT,ds.Exi)
	ds.cmd(EXI,ds.Exi)
ds.Exi
	svc	KIO,(0)			:disconnect

	if	db.ntc
	  ds.cmd("80"82"84"86,ds.ntc)	: Enter Network Console Protocol
ds.ntc
	  lis	  r1,(1)
	  stb	  r1,(networkConsoleFlag),,
	  stb	  r1,(responseEndFlag),,
	  j	  ds.Nxt

begRsp	  sc	  /"80"81/
endRsp	  sc	  /"80"82/
crlf	  sc	  /"8d"8a/
errMes	  sc	  /"80"84"00/
	ei

tErr	sc	/Illegal command /
ttErr	sc	/type '\'"8d"8a/
prompt	sc	/"8d"8a:>/
bkSpac	sc	/"88 "88/
	list

	subttl	command scanner, verifier, and bitcher

DoIt	l	r0,(c.Addr),r1		:go service this command
	jalr	r0,r0

dStart
	if	db.ntc
	  lis	  r0,(0)
	  stb	  r0,(networkConsoleFlag),,
	ei
ds.Nxt
	if	db.ntc
	  lb	  r1,(networkConsoleFlag),,
	  je	  dsnxt3		: if not network console operation

	  jal	  r3,nc.End		: Send end of response message
dsnxt1
	    jal	    r1,nc.gCh
	  clhi    r0,(80)
	  jnbs    dsnxt1		: ignore all chars before header

	  jal	  r2,nc.Hdr
	  clhi	  r3,(85)
	  jn	  dsnxt2		: if msg hdr not cmd termination

	    lh	    r3,(hdr.ID),,
	    clh	    r3,(nc.ID)+1,,
	    jn	    ncpEr0		: if ID not same as last command

	    jal	    r1,nc.gCh		: Get first character of command header
	    jal	    r2,nc.Hdr		: Get rest of command header
dsnxt2
	  clhi	  r3,(80)
	  jn	  ncpEr1		: if not cmd hdr

	  lh	  r3,(hdr.ID),,
	  sth	  r3,(nc.ID+1),,	: save ID for response

	  svc	  out,(begRsp)
	  svc	  out,(nc.ID),,

	  lis	  r0,(0)
	  stb	  r0,(responseEndFlag),,

	  jfs	  dNexTk
dsnxt3
	ei

	svc	OUT,(prompt)		:issue prompt
dNexTk
	jal	r4,ds.Tok		:get command token
	la	r1,(cmdLst)
dStar1
	  cl	  r3,(c.Str),r1
	  je	  DoIt			:if match found

	l	r1,(c.Next),r1
	jgbs	dStar1
ds.Ill
	svc	out,(tErr)		:"illegal command"

	st	r3,(badStr+2),,		:"xxxx"<cr>
	svc	out,(badStr),,
ds.Err
	if	db.ntc
	  lb	  r1,(networkConsoleFlag),,
	  jn	  ds.Nxt		:if ncp in use, don't bitch
	ei

	svc	OUT,(ttErr)		:tell user to type "\"
bitch
	jal	r1,ds.gCh

	jbs	bitch			:^w...ignore
	hs	1

	jbs	bitch			:^a...ignore
	hs	1

	clhi	r0,(0dc)
	jnbs	bitch			:if not a "\" yet
	j	ds.Nxt


	subttl	u t i l i t i e s

: get a command token...up to 4 chars long
: skips over extra characters to next delimiter
: link on r4
: token returned in r3, left justified

ds.Tok
	st	r4,(r4sav),,		:save r4
tokenstart
	jal	r1,ds.gCh
	jbs	tokenstart		:^w...ignore
	hs	1
	jbs	tokenstart		:^a...ignore
	hs	1
	jal	r2,ds.Del
	jbs	tokenstart		:ignore leading delimiters
	hs	1
	jal	r1,ds.cuc		:convert to upper case
	chi	r0,(0dc)
	je	ds.Nxt			:if "\", print prompt, get next command

	lbr	r3,r0			:set up string accumulator (000000cc)
	lis	r4,(1)			:1 char. found so far

tokenloop
	  jal	  r1,ds.gCh		:get another char
	  j	  tokenstart		:^w...start over
	  j	  toss			:^a...toss last char
	  jal	  r1,ds.cuc		:convert to upper case
	  jal	  r2,ds.Del
	  j	  wrapup		:is delimiter... left justify, bug out
	  chi	  r0,(0dc)
	  je	  ds.ill		:if "\", treat as illegal

	ais	r4,(1)			:count one more character
	chi	r4,(4)
	jg	tokenloop		:if > 4 chars already, ignore this one

	slls	r3,(8)			:slide previous ones left 8, and
	stbr	r0,r3			:stick this one in the rightmost byte
	j	tokenloop

wrapup
	l	r4,(r4sav),,		:restore r4, because exiting soon
wu1
	  ti	  r3,(0ff000000)
	  jnr	  r4			:if char in leftmost, done, exit

	  slls	  r3,(8)		:slide all characters left 8 bits
	jbs	wu1

toss
	sis	r4,(1)			:one less char
	chi	r4,(4)
	jge	tokenloop		:if haven't backed into 1st 4 chars

	srls	r3,(8)			:slide the last char off the right
	j	tokenloop

: utility routine to read a number
: uses r0-r3
: expects radix in r4
: link on r5
: aborts if first non-delimiter is not digit
: else returns number in r0

rRadix	eq	4

ds.Num
	jal	r1,ds.gCh		:get first char
	jbs	ds.Num			:^w...ignore
	hs	1
	jbs	ds.Num			:^a...ignore
	hs	1
	jal	r2,ds.Del		:delimiter?
	jbs	ds.Num			:is
	hs	1
	jal	r2,ds.Dig		:isn't -  digit?
	j	ds.Ill			:isn't - give error message
	clr	r0,rRadix		:is
	jge	ds.Ill			:if digit is bigger than radix...abort

	lr	r3,r0			:put first digit into accumulator
number
	  jal	  r1,ds.gCh		:read next char
	  j	  ds.Num		:^w...start over
	  j	  divide		:^a...toss last digit
	  jal	  r2,ds.Del		:delimiter?
	  lr	  r0,r3
	  jr	  r5			:is
	  jal	  r2,ds.Dig		:isn't - digit?
	  j	  ds.Ill		:isn't... abort
	  clr	  r0,rRadix		:is
	  jge	  ds.Ill		:if radix error...bitch

	  mr	  r2,rRadix		:r2, r3 = r3 * rRadix (r4) 
	  ar	  r3,r0			:add new digit
	j	number
divide
	lis	r2,(0)
	dr	r2,rRadix		:r2 rem, r3 quot of r2, r3 / rRadix
	j	number

: digit test
: check character read...skip return if digit
: then r0=binary value of hex digit
: uses r1, link on r2

ds.Dig
	jal	r1,ds.cuc		:convert to upper case
	lr	r1,r0
	shi	r1,(0b0)
	jlr	r2			:if less than "0" not dig, nrml ret

	sis	r1,(0b9-0b0)
	jlefs	digit			:if <= "9" it's a digit

	  sis	  r1,(0c1-0b9)
	  jlr	  r2			:if < "A" not a  digit, normal return

	  sis	  r1,(0c6-0c1)
	  jgr	  r2			:if > "F" not a digit, normal return

	    sis	    r0,(7)		:subtract diff between "9" and "A"
digit
	shi	r0,(0b0)		:subtract away the ascii flotsam
	j	4,r2			:skip return

: check for delimiter
: link	r2
: uses	r0,r1
: skip-4 return unless (r0) is a delimiter character

ds.Del
	lhi	r1,(dLen-1)		:loop up to this many times
	stb	r0,(ds.Dlm),,		:save this char as last delimiter
delim
	  clb	  r0,(dList),r1
	  jer	  r2			:if byte in r0 is in dList

	sis	r1,(1)
	jgebs	delim

	j	4,r2			:if not in list of delimiters, skip return

dList	bc	8d,8a,89		:cr,lf,ht
	ac	'.! ,'			:new are "." and "!" 

dLen	eq	(.)-dList
	bnd	2

: input a character
: link	r1
: normal return:  ^w input...flush entry
: skip-4 return:  ^a OR ^h input...flush last char
: skip-8 return: char in r0 (high-bit on)
: aborts to command scanner on "esc"

escape	eq	80+1b
ctlW	eq	80+17
ctlA	eq	80+1
ctlH	eq	80+8

ds.gCh
	svc	IN,(00)			:<-----<< get the char
	jbs	ds.gCh
	hs	1
	ohi	r0,$2 10000000		:ALWAYS SET HIGH-ORDER BIT

	clhi	r0,(escape)
	je	ds.Nxt			:abort, proceed with prompt if so

	clhi	r0,(ctlW)
	jer	r1			:normal return

	clhi	r0,(ctlA)
	je	4,r1			:skip-4 return

	clhi	r0,(ctlH)
	jn	8,r1			:if normal, skip-8 return, char in r0

	svc	OUT,(bkSpac)		:"backspace, space, backspace"
	j	4,r1			:skip-4 return for ctlH

: convert char in (r0) to upper case
: link on r1

ds.cuc
	clhi	r0,(80+61)		: "a"
	jlr	r1			:if too low to be lowercase

	clhi	r0,(80+7a)		: "z"
	jgr	r1			:if too high to be lowercase

	shi	r0,(20)			:convert to uppercase
	jr	r1


	if	db.Ntc

: Check for command termination
: Link	R4
: Uses	R0, R1, R2, R3
: Normal return:	Termination not found
: Skip-4 return:	Command termination received

ds.Chk
	  lb	  r0,(networkConsoleFlag),,
	  jnfs	  dsChk1		: if protocol active, check for message.

	    svc	    IN,(00)
	    jr	    r4			: key not struck
	    hs	    1
	    j	    4,r4		: key struck
dsChk1
	  svc	  IN,(00)
	  jr	  r4			: key not struck
 	  hs	  1
	  jal	  r2,nc.Hdr		: "key" (?) struck
	  clhi	  r3,(85)
	  jn	  ncper2		: if mes hdr not cmd term

	  lh	  r3,(hdr.ID),,
	  clh	  r3,(nc.ID+1),,
	  jn	  ncper0		: if not correct ID

	  j	  4,r4

: Read a Network Console message header. First character passed in R0.
: First byte must be a hex 80.
: Link	R2
: Uses	R0, R1, R3
: Returns	second byte of header in R3 and message ID in hdr.ID.

nc.Hdr
	  clhi	  r0,(80)
	  jn	  ncper3		: if msg hdr not = 80

	  jal	  r1,nc.Gch
	  lr	  r3,r0			: save second char in r3

	  jal	  r1,nc.Gch
	  stb	  r0,(hdr.ID),,		:save first...

	  jal	  r1,nc.Gch
	  stb	  r0,(hdr.ID+1),,	:and second byte of ID

	  jr	  r2

: Input a character, waiting until one is received. Return character in R0.
: Link	R1

nc.Gch
	  svc	  IN,(0f)
	  jbs	  nc.Gch
	  hs	  1
	  jr	  r1

: Send an protocol error message to Network Console
:
: Code	Meaning
: ----	-------
: 0	The ID in a command end message (type 85) does not match the
:	ID in the command message.
:
: 1	Expected a command message and did not receive one.
:
: 2	Received a message other than command end in ds.Chk call.
:	A call to ds.Chk should only be done for commands which
:	need termination, i.e. which have not sent end of response.
:	These commands can only receive command end.
:
: 3	Message header does not begin with a hex 80.

ncper0
	  lis	  r0,(0)
	  jfs	  nc.Err
ncper1
	  lis	  r0,(1)
	  jfs	  nc.Err
ncper2
	  lis	  r0,(2)
	  jfs	  nc.Err
ncper3
	  lis	  r0,(3)

nc.Err	  jal	  r3,nc.End		: Send response end, if needed

	  svc	  OUT,(ErrMes)		: Send error message header
	  svc	  KIO,(0e)
	  j	  ds.Nxt

: Send end of response message, if not already sent
: and set flag that it has been sent.
: Link	R3
: Uses	R1

nc.End
	  lb	  r1,(responseEndFlag),,
	  jnr	  r3			: No need to send, already sent

	  svc	  OUT,(crlf)		: Insure response has at least one line
	  svc	  OUT,(EndRsp)		: End previous response
	  svc	  OUT,(nc.ID),,		: Include command ID
	  svc	  OUT,(crlf)		: and blank line

	  lis	  r1,(1)
	  stb	  r1,(responseEndFlag),,

	  jr	  r3
	ei
      ei
      em
	subttl	extended ddt modules - extddt.f01

:	This program is the sole property and confidential
:	information of Tymshare, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.
:
:	** Revision History **
:
:	original design and code - Pat Driscoll
:	fiddled with - Jon Ericson

	mo	(.),status
	lo	crash
        lo      main
	seg	a.code

	nolist
	ds.cmd(CB,ds.Qui)
	ds.cmd(CA,ds.Qui)
	ds.cmd(ZZ,ds.Exi)
	ds.cmd(HELP,HelpDisplay)
	ds.cmd(?,HelpDisplay)
	ds.cmd(SYM,SymbolDisplay)
	ds.cmd(V,WhosOnFirst)
	list

HelpDisplay	
	la	r1,(HelpData)
d1
	  lb	  r0,(0),r1
	  je	  ds.Nxt		:exit

	  svc	  OUT,(0),r1

	  ar	  r1,r0
	  ais	  r1,(1)
	jbs	d1

	nolist
HelpData
 sc /      Menu Server"8d"8a/
crlf sc	/"8d"8a/
 sc /--- Syntax ---   --- Action ---------------------------------------"8d"8a/
 sc /DIR    <arg>     Display Dispatcher Input Ring"8d"8a/
 sc /                   From address <arg> or start"8d"8a/
 sc /DOR    <arg>     Display Dispatcher Output Ring"8d"8a/
 sc /                   From address <arg> or start"8d"8a/
 sc /DR               Display both Rings continuously"8d"8a/
 sc /NADR<.prt#>      Display Rings in correct sequence"8d"8a/
 sc /                 Type "AF to terminate Display"8d"8a/
 sc /EXI              Log off"8d"8a/
 sc /V                Version"8d"8a/
 sc /HELP or ?        Print this list"8d"8a/
 sc /SYM              Print a list of symbol addresses"8d"8a/
 sc /Q                Back to DDT"8d"8a/
 sc /ZZ               Log off"8d"8a/
 sc /"8a/
 bc	0
	bnd	2
	list

WhosOnFirst
	svc	OUT,(whenTxt)
	svc	OUT,(itxt)
	svc	OUT,(rtxt)

	if	\(ttxt)
	  svc	  OUT,(ttxt)
	ei

	j	ds.Nxt


space2	sc	/  /

rName	eq	2
rAddress eq	3

	bnd	2
SymbolDisplay
        la      rName,(SymNam)
        la      rAddress,(SymAdr)
d3
          l       r0,(0),rAddress
	  je	  ds.Nxt		:exit

          svc     OUT,(crlf)

          lhi     r1,(500+40+10)	:5 wide, 0 fill, base 16
          svc     KIO,(0a)

          svc     OUT,(space2)

          svc     OUT,(0),rName		:display the name

          lb      r0,(0),rName
          ar      rName,r0		:add length of name
          ais     rName,(1)		: plus 1 (for length byte)

          ais     rAddress,(4)		:add length of address
        j       d3

SymGen  macro	(SYMBOL) [
        if      \(SymNam)
	else
SymNam    eq      (.)
x	  eq      0
        ei
        sc      /SYMBOL/
SyAd|x| eq      SYMBOL
x	eq	x+1
			]

SymEnd  macro [
y       eq      0
SymAdr  ws      0
        re      x
          wc      (SyAd|y|)
y         eq      y+1
        er
        wc      0		       :terminate list
]
	nolist
        SymGen(Iring)
        SymGen(Oring)
        SymGen(crat)
	SymGen(UCBbase)
	SymGen(UCBlength)
	SymGen(TsatDataHandler)
	SymGen(HSHAND)
	SymGen(PortToUCBmap)
	SymGen(TsatSide)
	SymGen(HostSide)
	SymGen(ubufer)
        SymEnd
	list
	bnd	2
        fo      CRASH
        em
	subttl	UNIVAC isis ring interpreter

: 06/17/88 CHANGE (SPECIAL)LBR RPORT,RPORT TO LR RPORT,RPORT

: short course:
:
: type ::adr.2c.45.33<cr>	 both rings, ports 0, 2c, 45 and 33
: or   ::adir,20944<cr>		 I ring starting at 20944
: or   ::ador<cr>		 O ring starting at lowest ring address
: or   ::adir.00<cr>		 I ring port 0 only
: or   ::adir.c.d.e.f,20aaa<cr>	 I ring listed ports, starting at 20aaa
:
: port list is first, followed by ring address.
:
: the thing to remember is: put a dot ahead of each port number,
:			    put a comma ahead of ring address.
:
: "adr" and "dr" do not allow ring address to be specified. 

        mo	(.),status
	ra	$0 0

	if	\(seqring)
	  seg	  a.ring
Csnum	  ws	  1
LsnumD	  ws	  1
ORsnum	  bs	  ORsize
IRsnum	  bs	  IRsize
	ei

YES	eq	1
NO	eq	0

: assembler options

oldEbcdic eq	YES		:traditional format, ebcdic translation
newEbcdic eq	YES		:new format, ebcdic translation

Aspirin	  eq	NO		:hex in uppercase

	lo	main
	if	\REVTAB
CHAREV	  eq	  REVTAB

uts	  eq	  YES
	else
uts	  eq	  NO
	ei
	fo	main

EbcBit	    eq	1
NewBit	    eq	2

NoRightBit  eq	4
PlayDeadBit eq	8
unk	    eq  10
ReverseBit  eq  20

Isynch      eq  40
Osynch      eq  80

QuestionMark 	eq 3f+80
CarriageReturn  eq 0d+80
DOT		eq 2e+80
Blank		eq 20+80

tty		eq KIO
ttyChar		eq 0e
ttyNumber	eq $a10

ttyTxt		eq 0b

LENGTH	eq	0f0028
LP0LST	eq	0f0026
nPorts	eq	0e0082

:		r0
:		r1		:rFineIndex
rMsgCode     eq	r2
rMsgIndex    eq	r3		:aka rHoriz
rPort	     eq	r4		:aka rCoarseIndex
rChar	     eq	r5
rMsgLength   eq	r6
rSixteenIndex eq r7
rRingBase    eq	r8
rRingLength  eq	r9
rFlags       eq	r10
rRingIndex   eq	r11
: 		r12		:link
:		r13		:link (ShowOneMessage)
:		r14		:link (PrntOring, PrntIring)
rIorO	     eq	r15		:2 for input or 0 for output

	seg	a.code

	nolist
	ds.Cmd(DIR,DIR)
	ds.Cmd(DOR,DOR)
	ds.Cmd(DR,DR)
DIR
	lis	  r0,(0)
	j	  DirCode
DOR
	lis	  r0,(0)
	j	  DorCode
DR
	lis	  r0,(0)
	j	  DrCode

	if	oldEbcdic
	  ds.Cmd(EIR,EIR)
	  ds.Cmd(EOR,EOR)
	  ds.Cmd(ER,ER)
EIR
	  lis	  r0,(EbcBit)
	  j	  DirCode
EOR
	  lis	  r0,(EbcBit)
	  j	  DorCode
ER
	  lis	  r0,(EbcBit)
	  j	  DrCode
	ei

	ds.Cmd(ADIR,ADIR)
	ds.Cmd(ADOR,ADOR)
	ds.Cmd(ADR,ADR)
ADIR
	lis	r0,(NewBit)
	j	DirCode
ADOR
	lis	r0,(NewBit)
	j	DorCode
ADR
	lis	r0,(NewBit)
	j	DrCode

	if	\(seqring)
	  ds.Cmd(NADR,NADR)
NADR
	  lis	  r0,(NewBit)
	  j	  NADRcode
	ei

	if	newEbcdic
	  ds.Cmd(EDIR,EDIR)
	  ds.Cmd(EDOR,EDOR)
	  ds.Cmd(EDR,EDR)
EDIR
	  lis	  r0,(NewBit!EbcBit)
	  j	  DirCode
EDOR
	  lis	  r0,(NewBit!EbcBit)
	  j	  DorCode
EDR
	  lis	  r0,(NewBit!EbcBit)
	  j	  DrCode
	ei

	list
DirCode
	sth	r0,(OutputFormat),,

	jal	r8,GetPortList

	la	r6,(Iring+4),,		:lowest allowable address
	la	r7,(Iring+4+IRsize),,	:highest
	jal	r8,GetRingAddress
        sth     r0,(SaveIringIndex),,	:results - where to start

	svc	ttyTxt,(pIring)
	jal	r8,Show3
dir2
          svc     FastD,(0)

	  jal	  r4,ds.Chk
	  jfs	  dir3			:1 key not struck
	  hs	  1
	    j	  ds.Nxt		:2 key struck
dir3
	  jal	  r14,PrntIring
	  lh	  r0,(OutputFormat),,
	  ohi	  r0,(Isynch)
	  sth	  r0,(OutputFormat),,
        j	dir2

DorCode
	sth	r0,(OutputFormat),,

	jal	r8,GetPortList

	la	r6,(Oring+4),,		:lowest allowable address
	la	r7,(Oring+4+ORsize),,	:highest
	jal	r8,GetRingAddress
        sth     r0,(SaveOringIndex),,	:results - where to start

	svc	ttyTxt,(pOring)
	jal	r8,Show3
dor2
          svc     FastD,(0)

	  jal	  r4,ds.Chk
	  jfs	  dor3
	  hs	  1
	    j	    ds.Nxt
dor3
	  jal	  r14,PrntOring
	  lh	  r0,(OutputFormat),,
	  ohi	  r0,(Osynch)
	  sth	  r0,(OutputFormat),,
	j	dor2

DrCode
	sth	r0,(OutputFormat),,

	jal	r8,GetPortList

	lis	r0,(0)
        sth     r0,(SaveIringIndex),,
        sth     r0,(SaveOringIndex),,

	svc	ttyTxt,(pIring)

	la	r6,(Iring+4),,		:wotta kludge
	jal	r8,Show3

	svc	ttyTxt,(pOring)

	la	r6,(Oring+4),,		:wotta kludge
	jal	r8,Show3

dr1
          svc     FastD,(0)

	  jal	  r4,ds.Chk
	  jfs	  dr2
	  hs	  1
	    j	ds.Nxt
dr2
          jal     r14,PrntOring
          jal     r14,PrntIring

	  lh	  r0,(OutputFormat),,
	  ohi	  r0,(Isynch+Osynch)
	  sth	  r0,(OutputFormat),,
        j	dr1

    if    \(seqring)

NADRcode
	sth	r0,(OutputFormat),,

	jal	r8,GetPortList

	lh	r0,(Iring+0),,
        sth     r0,(SaveIringIndex),,

	lh	r0,(Oring+0),,
        sth     r0,(SaveOringIndex),,

	l	r0,(Csnum),,
	sis	r0,(1)
	st	r0,(LsnumD),,

	svc	ttyTxt,(pIring)

	la	r6,(Iring+4),,		:wotta kludge
	jal	r8,Show3

	svc	ttyTxt,(pOring)

	la	r6,(Oring+4),,		:wotta kludge
	jal	r8,Show3
nadr1
          svc     FastD,(0)

	  jal	  r4,ds.Chk
	  jfs	  nadr2
	  hs	  1
	    j	    ds.Nxt
nadr2
	  lhl	  r1,(SaveOringIndex),,
	  l	  r1,(ORsnum),r1,
	  sis	  r1,(1)

	  cl	  r1,(LsnumD),,
 	  jnfs	  notO

            jal	    r14,PrntOring

	    lh	    r0,(OutputFormat),,
	    ohi	    r0,(Osynch)
	    sth	    r0,(OutputFormat),,
notO
	  lhl	  r1,(SaveIringIndex),,
	  l	  r1,(IRsnum),r1,
	  sis	  r1,(1)

	  cl	  r1,(LsnumD),,
	  jnfs	  notI

            jal	    r14,PrntIring

	    lh	    r0,(OutputFormat),,
	    ohi	    r0,(Isynch)
	    sth	    r0,(OutputFormat),,
notI
        j	nadr1
    ei

GetPortList
	lis	r6,(0)
gpl1
	  lb	  r1,(ds.Dlm),,
	  clhi	  r1,(DOT)
	  jefs	  gpl2			:if delimiter was a DOT
	    sth	    r6,(NumOfSpecPorts),, :remember how many ports were spec'd
	    jr	    r8
gpl2
	  lhi	  r4,(10)		:radix hex
	  jal	  r5,ds.Num		:puts # in r0, delimiter in ds.Dlm

	  ch	  r0,(nPorts),,
	  jlefs	  gpl3			:if port number OK
            svc     ttyTxt,(BadPortTxt)
            j       ds.Err
gpl3
	  sth	  r0,(buf),r6,r6	:remember this port number
	  ais	  r6,(1)
	j	gpl1

GetRingAddress
	lb	r1,(ds.Dlm),,
	clhi	r1,(CarriageReturn)
	jnfs	gra1
	  lis	  r0,(0)		:no address specified - start at beg.
	  jr	  r8
gra1
	lhi	r4,(10)
	jal	r5,ds.Num

        clr     r0,r6
        jgefs	gra2
          svc     ttyTxt,(TooLowTxt)
          j       ds.Err
gra2
        clr     r0,r7
        jlefs	gra3
          svc     ttyTxt,(TooHighTxt)
          j       ds.Err
gra3
        sr      r0,r6			:subtract off the base address
        nhi     r0,(0fffc)		: round it down, mod 4
	jr	r8

Show3
	lhi	r1,(600+20+10)		:6 wide, leading blanks, hex

	sis	r6,(4)

	lr	r2,r6			:i or o ring base data address
	lr	r0,r2
	svc	tty,ttyNumber		:print address of ring structure
	:-------
	svc	ttyTxt,(stuff)

	ah	r2,(0),r2		:add data in NMFI field
	la	r0,(4),r2
	svc	tty,ttyNumber		:print where to stuff next message
	:-------
	svc	ttyTxt,(yank)

	lr	r2,r6			:i or o ring base data address
	ah	r2,(2),r2		:add data in CEI field
	la	r0,(4),r2
	svc	tty,ttyNumber		:print where to yank next message
	:-------
	lhi	r1,(500+20+10)		:6 wide, leading blanks, hex

	svc	ttyTxt,(nfmitxt)
	lhl	r0,(0),r6
	svc	tty,ttyNumber
	:-------
	svc	ttyTxt,(ceitxt)
	lhl	r0,(2),r6
	svc	tty,ttyNumber
	:-------
	svc	ttyTxt,(endtxt)

	jr	r8

nfmitxt sc	-  (NFMI is-
ceitxt	sc	- CEI is-
endtxt	sc	-)"0d"0a-
pIring	sc	-Iring- 
pOring	sc	-Oring-
stuff	sc	- stuff into-
yank	sc	- yank from-
	bnd	2

PrntIring
        lh      rRingIndex,(SaveIringIndex),,
        la	rRingBase,(Iring),,
        clh	rRingIndex,(0),rRingBase,  :NFMI
	jer	r14

	lhi	rRingLength,(IRsize)

        lhi     r0,(3e)			:">"
::        lhi     r0,(49)		:"I"
        stb     r0,(IorOspace+1),,

        jal     r13,ShowImessage

        sth     rRingIndex,(SaveIringIndex),,
	jr	r14

PrntOring
        lh      rRingIndex,(SaveOringIndex),,
        la	rRingBase,(Oring),,
        clh	rRingIndex,(0),rRingBase,
	jer	r14			:if display is caught up

	lhi	rRingLength,(ORsize)

        lhi     r0,(3c)			:"<"
::        lhi     r0,(6f)		:"o"
        stb     r0,(IorOspace+1),,

	jal     r13,ShowOmessage

        sth     rRingIndex,(SaveOringIndex),,
	jr	r14
ShowImessage	
	lh	rFlags,(OutputFormat),,
sim1
	  lb	  rMsgCode,(4+2),rRingBase,rRingIndex

	  lhl	  rPort,(4),rRingBase,rRingIndex
	  je	  Port0message

	  clh	  rPort,(nPorts),,
	  jle	  RegularPortMessage

	  thi	  rFlags,(Isynch)
	  jn	  cua

	  ais	  rRingIndex,(4)	
	j	sim1

ShowOmessage	
	lh	rFlags,(OutputFormat),,
som1
	  lb	  rMsgCode,(4+2),rRingBase,rRingIndex

	  lhl	  rPort,(4),rRingBase,rRingIndex
	  jefs	  Port0message

	  clh	  rPort,(nPorts),,
	  jle	  RegularPortMessage

	  thi	  rFlags,(Osynch)
	  jn	  cua

	  ais	  rRingIndex,(4)	
	j	som1

Port0message 
	jal	r12,PrntAddr

	clhi	rMsgCode,(10)
	jg	comUnk

	if	\(seqring)
	  ci	  rRingBase,Oring
	  jefs	  pzm1
	    l	    r0,(IRsnum),rRingIndex,
	    jfs	    pzm2
pzm1
	    l	    r0,(ORsnum),rRingIndex,
pzm2
	    st	    r0,(LsnumD),,
	ei

	lbr	r1,rMsgCode
	slls	r1,(3)
	svc	ttyTxt,(PortZeroTxt),r1
	svc	ttyTxt,(beepspace1)	:port 0 messages beep at you
		
	tbt	rMsgCode,(WordWithBits8andEon)
	jnfs	pz1			:if 1 down text or aux ckt req

	  lhl	  r1,(LP0LST),,
	  lb	  rMsgLength,(0f0000),rMsgCode,r1 :get byte at f000 + msg code + offset
	  ais	  rMsgLength,(2)	      :add port number length

	  ohi	  rFlags,(NoRightBit)
	  j	  DoBody
pz1
	clhi	rMsgCode,(0e)
	jefs	pz2			:if 1 down
	  lis	  rMsgLength,(0b)
	  la	  r1,(0a),rRingIndex	:r1 = index of aux ckt req "size" byte
	  jfs	  pz3
pz2
	  lis	  rMsgLength,(6)
	  la	  r1,(5),rRingIndex	:r1 = index of 1 down "size" byte
pz3
	  cr	  r1,rRingLength
	  jlfs	  pz4
	    sr	    r1,rRingLength	:adjust r1 in case of wring rap
pz4
	  lb	  r0,(4),rRingBase,r1	:r0 = "size" byte
	  ar	  rMsgLength,r0		:add "size" byte to fixed length
	j	DoBody

RegularPortMessage
	lh	r1,(NumOfSpecPorts),,
	jefs	rpm2			:if all ports are to be displayed
rpm1
	  clh	  rPort,(buf-2),r1,r1
	  jefs	  rpm2			:if this port found in list

	sis	r1,(1)
	jnbs	rpm1

	ohi	rFlags,(PlayDeadBit)	:not in list
	j	rpm5
rpm2
	if	\(seqring)
	  ci	  rRingBase,Oring
	  jefs	  rpm3
	    l	    r0,(IRsnum),rRingIndex,
	    jfs	    rpm4
rpm3
	    l	    r0,(ORsnum),rRingIndex,
rpm4
	    st	    r0,(LsnumD),,
	ei
rpm5
	lbr	rMsgCode,rMsgCode	
	jn	CtlOrData
:Needle
	lb	rMsgLength,(4+3),rRingBase,rRingIndex :get variable length
	ais	rMsgLength,(4)  :!"# :yow	    :add fixed - sort of *

	jal	r12,TestPlayDead

	jal	r12,PrntAddr

	svc	ttyTxt,(NDLtxt)
	j	DoBody
CtlOrData
	clhi	rMsgCode,(9e)
	jge	ControlMsg
:DataMsg
	la	rMsgLength,(3),rMsgCode

	jal	r12,TestPlayDead

	jal	r12,PrntAddr

	svc	ttyTxt,(DATtxt)

	j	DoBody

unknown	sc	-YIKES!!!-
	bnd	2

ControlMsg
	clhi	rMsgCode,(0c1)		:normal people don't issue c1's
	jl	cm2
cua
	  jal	  r12,PrntAddr
comUnk
	  svc	  ttyTxt,(unknown)
	  ohi	  rFlags,(unk)

	  lhl	  rMsgLength,(0),rRingBase,,
	  sh	  rMsgLength,(2),rRingBase,,
	  jg	  DoBody

	  ar	  rMsgLength,rRingLength
	  j	  DoBody
cm2
	lb	rMsgLength,(LENGTH),rMsgCode, :message length from table (in seg f)
	ais	rMsgLength,(2)

	jal	r12,TestPlayDead

	jal	r12,PrntAddr

	lhi	r1,(-9e),rMsgCode
	slls	r1,(3)
	svc	ttyTxt,(CtlTxt),r1

	svc	ttyTxt,(space1)

	st	rRingIndex,(savekludge),,

	clhi	rMsgCode,(0b3)		 :normal logon character
	jefs	DoBody

	ohi	rFlags,(NoRightBit)
	jfs	DoBody
LongerThan16
	svc	ttyTxt,(Zot),,
	svc	ttyTxt,(space8)
	svc	ttyTxt,(space8)
	jfs	db
DoBody
	lis	rMsgIndex,(0)
db
	lis	rSixteenIndex,(0)
Loop
	lb	r1,(4),rRingBase,rRingIndex
	lbr	rChar,r1

	if	oldEbcdic
	  thi	  rFlags,(EbcBit)
	  jefs	  store			:if EBCDIC not requested

	  lr	  rPort,rPort
	  jefs	  store			:if aux ckt req or 1 down text

	  lbr	  rMsgCode,rMsgCode
	  jefs	  store			:if needle

	  shi	  r1,(40)
	  jlefs	  storeDot		:if under 40 - unprintable

	  lb	  r1,(EtoAxlateTable),r1
	  jfs	  storeR1
store
	ei

	nhi	r1,$2 01111111

	tbt	r1,(Ok2print)
	jnfs	storeR1			:if in "Ok2print" table
storeDot
	lhi	r1,(DOT)
storeR1
	stb	r1,(Zot+3),rSixteenIndex,,

	jal	r12,PrintCharInHex

	ais	rSixteenIndex,(1)
	ais	rMsgIndex,(1)

	sis	rMsgLength,(1)
	je	TailEnd			:if no more chars to process

	jal	r12,IncrRingIndex

	thi	rSixteenIndex,(0f)
	je	LongerThan16		:if at end of line (but more data)

	chi	rMsgIndex,(2)
	jefs	x1			:if port # just printed

	chi	rMsgIndex,(3)
	jefs	x2			:if message type just printed

	thi	rSixteenIndex,(3)
	jn	Loop			:if NOT just printed clump of 4
x1
	svc	ttyTxt,(space1)
	j	Loop

x2
	svc	ttyTxt,(space2)

	lhi	r0,(Blank)
	stb	r0,(Zot+6),,

	lis	rMsgIndex,(4)
	lis	rSixteenIndex,(4)

	thi	rFlags,(unk)
	jn	Loop

	thi	rFlags,(NewBit)
	jn	Special		:if new format asked for 

	j	Loop

:------------------------
:------------------------

TailEnd
	thi	rFlags,(NoRightBit)
	jn	CrLfExit		:if NOT showing chars on the right

	lhi	r0,(Blank)
te1
	  nhi	  rSixteenIndex,(0f)
	  jefs	  te3			:if = 10h, no (more) spacing

	    stb	    r0,(Zot+3),rSixteenIndex,,
	    svc	    ttyTxt,(space2)	:for hex that wasn't printed

	    thi	    rSixteenIndex,(3)
	    jnfs    te2			:if not mod 4 (chunks of 4 test)
	      svc     ttyTxt,(space1)
te2
	  ais	  rSixteenIndex,(1)
	jbs	te1	
te3
	svc	ttyTxt,(Zot),,
	jfs	Exit
CrLfExit
        svc     ttyTxt,(CrLf)
Exit
	thi	rFlags,(unk)
	jefs	exit1			:if not the crash message
	  lhl	  rRingIndex,(0),rRingBase  :so ring display stops
	  jr	  r13
exit1
	ais     rRingIndex,(1+3)
        nhi     rRingIndex,(0fffc)	:round up, mod 4

        cr      rRingIndex,rRingLength
        jlr	r13

        sr      rRingIndex,rRingLength	:fell off the end, wrap it
	jr	r13

PrntAddr
        svc     ttyTxt,(IorOspace),,

	la	r0,(4),rRingBase,rRingIndex
	lhi	r1,(530)		:width 5, blank fill, base 16
	svc	tty,ttyNumber

	svc	ttyTxt,(space1)
	jr	r12			:example: "I 20844 "

PrintCharInHex
	lbr	r1,rChar
	srhls	r1,(4)
	lb	0,(Zero2f),r1
	svc	tty,ttyChar

	nhi	rChar,(0f)
	lb	0,(Zero2f),rChar
	svc	tty,ttyChar
	jr	r12

IncBy3
	ais	rRingIndex,(2)
IncrRingIndex
	ais	rRingIndex,(1)
	cr	rRingIndex,rRingLength
	jlr	r12

	sr	rRingIndex,rRingLength
	jr	r12

TestPlayDead
	thi	rFlags,(PlayDeadBit)
	jer	r12			:return and continue

	ar	rRingIndex,rMsgLength
	sis	rRingIndex,(1)		:because of code at "exit"
	j	Exit			:don't return, jump to exit

	nolist

	seg	a.data

nGrp	       eq (nPort+0f)/10
iixBitFlags    hs nGrp

savelink       ws 1
NumOfSpecPorts hs 1
SaveOringIndex hs 1
SaveIringIndex hs 1
OutputFormat   hs 1
buf	       hs 10
Zot	       sc '  xxxxxxxxxxxxxxxx"8d"8a'
IorOspace      sc 'x '
savekludge     ws 1

	seg	a.code

	if	Aspirin
Zero2f    ac	  '0123456789ABCDEF'
	else
Zero2f	  ac	  'o123456789abcdef'
	ei

BadPortTxt sc	'Port number too high"8d"8a'
TooLowTxt  sc	'Address too low"8d"8a'
TooHighTxt sc	'Address too high"8d"8a'
CrLf	   sc	'"8d"8a'
beepspace1 sc	'"07 '
space1	   sc	' '
space2	   sc	'  '
space3	   sc	'   '
space8	   sc	'        '

WordWithBits8andEon wc $2 00000000100000100000000000000000
Ok2print   	    wc 0,0ffffffff,0ffffffff,0fffffffe     :"~" ok, not <Del>

	if	oldEbcdic+newEbcdic 	:assemble if either or both true
EtoAxlateTable
 ac \ ...........<(+|&.........!$*)"3b.-/........|,%_>?.........':#@'="22\
 ac '.abcdefghi.......jklmnopqr.......~stuvwxyz......................'
 ac '{ABCDEFGHI......}JKLMNOPQR......\.STUVWXYZ......0123456789|.....'
	ei

NDLtxt	sc	' NEEDLE '	: 0 
DATtxt	sc	'   data '	: 1 thru 9d

CtlTxt	sc	'DETATCH'	: 9e
	sc	'    ZAP'	: 9f disconnect

	sc	'bkp  ON'	: a0 apply back-pressure (no send)
	sc	'bkp OFF'    	: a1 release "      "     (send)

	sc	'gobbler'	: a2 flush output (gobbler)
	sc	'backGob'	: a3 flush input (back gobbler)

	sc	'!BLACK!'	: a4 data lost in this direction (black ball)
	sc	'!GRAY!!'	: a5 data lost in opposite direction (grey ball)

	sc	'DEM  ON'	: a6 enter defered echo
	sc	'DEM OFF'	: a7 leave    "      "

	sc	'xpr  ON'	: a8 enter transparency mode
	sc	'xpr OFF'	: a9 leave       "        "

	sc	'  GREEN'	: aa
	sc	'    RED'	: ab
	sc	' YELLOW'	: ac
	sc	' ORANGE'	: ad

	sc	'strtBRK'	: ae break detected
	sc	'HANG UP'	: af 

	sc	' Ask TP'	: b0 query terminal parameter
	sc	' Set TP'	: b1   set     "        "

	sc	'psNeedl'	: b2 pseudo needle
	sc	'logChar'	: b3 logon char
	sc	'logSTAT'	: b4 logon status
	sc	'logFAIL'	: b5 logon failure
	sc	'logSUCC'	: b6 circuit complete

	sc	'add2acc'	: b7 addendum to accounting
	sc	'suHngUp'	: b8 super-hang up
	sc	'setXmtL'	: b9 set transmit limit
	sc	'end BRK'	: ba end of break
	sc	'ZAP ACK'	: bb

	sc	'aod  ON'	: bc enter alternate output device mode
	sc	'aod OFF'	: bd leave     "        "      "     "

	sc	'ZAPwRea'	: be zap with reason

	sc	'iix  ON'	: bf start interface information exchange
	sc	'iix OFF'	: c0 terminate "          "          "

PortZeroTxt sc	'-rstReq'	: 0 restart request
	sc	'-rstIfc'	: 1 restart interface
	sc	'-ndBnTO'	: 2 node has been taken over
	sc	'-reSuLg'	: 3 report to supervisor's log
	sc	'?reHoSt'	: 4 report host status (obsolete)
	sc	'-reAcct'	: 5 report accounting
	sc	'-GMTtim'	: 6 GMT time
	sc	'-rqNrPn'	: 7 request for NORMAL pseudo-needle
	sc	'-rqAxPn'	: 8 request for AUX pseudo-needle
	sc	'-pn rej'	: 9 pseudo-needle rejected
	sc	'-hoPtAv'	: a host port availability
	sc	'-h nACC'	: b host not acceptable
	sc	'-repHo$'	: c report host cost
	sc	'-noSupr'	: d no supervisor
	sc	'-1dnTxt'	: e 1-down text
	sc	'-reAllH'	: f report all hosts
	sc	'-hoStRe'	: 10 host status report
	
e0	sc	'ECHO'
e1	sc	'echo <ctl> I'
e2	sc	'echo <cr> <del> on <lf>'
e3	sc	'echo <lf> on <cr>'
e4	sc	'<cr> delay'
e5	sc	'input baud rate'
e6	sc	'output baud rate'
e7	sc	'parity'
e8	sc	'half-duplex'
e9	sc	'parameter A'
ea	sc	'parameter B'
eb	sc	'parameter C'
ec	sc	'X-ON enable'
ee	sc	'echo <ctl> H'
ed	sc	'reverse X-ON enable'
ef	sc	'parameter D'
e10	sc	'Katakana'
e11	sc	'stop output on BREAK'
e12	sc	'echo <esc>'
e13	sc	'q-mode DEM on <cr>'

x	eq	seg|(a.code)|

etab	hc	(e0-x),(e1-x),(e2-x),(e3-x),(e4-x),(e5-x),(e6-x),(e7-x)
	hc	(e8-x),(e9-x),(ea-x),(eb-x),(ec-x),(ed-x),(ee-x),(ef-x)
	hc	(e10-x),(e11-x),(e12-x),(e13-x)

u0	sc	'Slot 0 refuses'
u1	sc	'Format error'
u2	sc	'Bad User Name'
u3	sc	'Bad Mud'
u4	sc	'System Unavailable'
u5	sc	'Down-line load or dial-out req fail'
u6	sc	'Timeout'
u7	sc	'Access not permitted'
u8	sc	'Out of origination ports'
u9	sc	'Sup refuses'

utab	hc	(u0-x),(u1-x),(u2-x),(u3-x),(u4-x)
	hc	(u5-x),(u6-x),(u7-x),(u8-x),(u9-x)

h0	sc	'host table full (in node code)'
h1	sc	'impostor, rejected by Sup'
h2	sc	'impostor, rejected by node'
h3	sc	'illegal host on restricted node'

htab	hc	(h0-x),(h1-x),(h2-x),(h3-x)
	

z0	sc	'continue'
z1	sc	'please log in'
z2	sc	'error, type username'
z3	sc	'error, type password'
z4	sc	'username'
z5	sc	'password'

z8	sc	'please see your rep...'
z9	sc	'bad mud'
za	sc	'circuits busy'
zb	sc	'host not avail...'
zc	sc	'host out of ports'
zd	sc	'host down'
ze	sc	'host shut'
zf	sc	'try again in 2 minutes'
z10	sc	'access not permitted'
z11	sc	'no host specified'
z12	sc	'bad host number'
z13	sc	'mud error'

ztab	hc	(z0-x),(z1-x),(z2-x),(z3-x),(z4-x),(z5-x),0,0,(z8-x)
	hc	(z9-x),(za-x),(zb-x),(zc-x),(zd-x),(ze-x),(zf-x),(z10-x)
	hc	(z11-x),(z12-x),(z13-x)

y0	sc	'ISIS unable to complete request'
y1	sc	'format error'
y2	sc	'bad user name'
y3	sc	'bad mud'
y4	sc	'system unavailable'
y5	sc	'down-line load or dial-out failure'
y6	sc	'timeout'
y7	sc	'access not permitted'
y8	sc	'out of origination ports'
y9	sc	'try again later'
ya	sc	'bad requesting-host number'
yb	sc	'req-host not up on req node'

ytab	hc	(y0-x),(y1-x),(y2-x),(y3-x),(y4-x),(y5-x),(y6-x)
	hc	(y7-x),(y8-x),(y9-x),(ya-x),(yb-x)

: IIX STUFF FOLLOWS

: global messages

gm0	sc	'Select Dialect Command'		:8080
gm1	sc	'Selected Dialect Response'		:8081
gm2	sc	'Gateway reached smart host'		:8082
gm3	sc	'Gateway reached dumb host'		:8083
gm4	sc	'Gateway normal logon status'		:8084
gm5	sc	'Resynchronize interface exchange'	:8085
gm6	sc	'Product ID and version'		:8086
gm7	sc	'request product ID and version'	:8087

GmTxtTab hc    (gm0-x),(gm1-x),(gm2-x),(gm3-x),(gm4-x),(gm5-x),(gm6-x),(gm7-x)
:!"#
GmOkTab	 hc    8080,8081,8082,8083,8084,8085,8086,8087,  0

gm0l	bc	2,2		:list of 16 bit dialect values
gm1l	bc	2,2		:single dialect value
gm2l	bc	2		:(smart)
gm3l	bc	2		:(dumb)
gm4l	bc	2,1		:8 bit normal logon status
gm5l	bc	2		:(resynchronize)
gm6l	bc	2,2,1,1		:product ID, version, revision
gm7l	bc	2,2,2		:eh?

GmLenTab hc	(gm0l-x),(gm1l-x),(gm2l-x),(gm3l-x),(gm4l-x),(gm5l-x),(gm7l-x)

: dialect values

dv0	sc	'all dialects were rejected'		:8080
dv1	sc	'ASCII data'				:8081
dv2	sc	'TymNet/TymNet gateway'			:8082
dv3	sc	'X.25/X.75 interface'			:8083
dv4	sc	'3270 DSP'				:8084
dv5	sc	'IBM SDLC'				:8085
dv6	sc	'IBM SNA'				:8086
dv7	sc	'UTS 4000'				:8087
dv8	sc	'Univac NTR'				:8088
dv9	sc	'TINET'					:8089
dva	sc	'Outdial'				:808a
dvb	sc	'2780'					:808b
dvc	sc	'HASP'					:808c
dvd	sc	'Circuit Redirect'			:808d
dve	sc	'UBM'					:808e
dvf	sc	'3870'					:808f
dv10	sc	'NETWORK CONSOLE'			:8090

DvTxtTab hc    (dv0-x),(dv1-x),(dv2-x),(dv3-x),(dv4-x),(dv5-x),(dv6-x),(dv7-x)
	hc     (dv8-x),(dv9-x),(dva-x),(dvb-x),(dvc-x),(dvd-x),(dve-x),(dvf-x)
	hc     (dv10-x)

DvOkTab	hc     8080,8081,8082,8083,8084,8085,8086,8087,8088,8089,808a,808b
	hc     808c,808d,808e,808f,8090,  0

: dialect dependent

dd87	sc	'callED address'			:c087
dd88	sc	'callING address'			:c088
dd89	sc	'call user data'			:c089
dd8a	sc	'interrupt'				:c08a
dd8b	sc	'interrupt confirmation'		:c08b
dd8c	sc	'network utility'			:c08c
dd8d	sc	'facility'				:co8d

dd91	sc	'reset confirmation'			:co91
dd92	sc	'call accept'				:c092
dd93	sc	'dialect level'				:c093
dd94	sc	'UTS protocol packet'			:c094 ***
dd95	sc	'clear indication'			:c095
dd96	sc	'reset indication'			:c096

DdTxtTab hc	(dd87-x),(dd88-x),(dd89-x),(dd8a-x),(dd8b-x),(dd8c-x),(dd8d-x)
	hc	(dd91-x),(dd92-x),(dd93-x),(dd94-x),(dd95-x),(dd96-x)

DdOkTab	hc	0c087,0c088,0c089,0c08a,0c08b,0c08c,0c08d,  0c091,0c092,0c093
	hc	0c094,0c095,0c096,  0

dd87l	bc	2,1,1,88	:"co87", len, cty, | rid, sid, reserved (4)
dd88l	bc	2,1,1,88	:"co88", ditto
dd89l	bc	2,1,1,1,1,1,88	:"co89", len, pid, cty, tty, line, | rid, sid
dd8al	bc	50
dd8bl	bc	50
dd8cl	bc	50
dd8dl	bc	50
:!"#
dd91l	bc	50
dd92l	bc	50
dd93l	bc	2,2
dd94l	bc	2,1,2,1,88	:"co94" fg leng re (back after reserved byte)
dd95l	bc	50
dd96l	bc	50

DdLenTab hc	(dd87l-x),(dd88l-x),(dd89l-x),(dd8al-x),(dd8bl-x),(dd8cl-x)
	hc	(dd8dl-x),(dd91l-x),(dd92l-x),(dd93l-x),(dd94l-x),(dd95l-x)
	hc	(dd96l-x)

:			       Q	  vv vv  vvvvvvvvvvvvvvvvvvv
:I 20048    data ooo7 88  co94 oo leng re ty s#  UTS protocol packet
:			  <Soh>!Qa<Stx>...data...<Etx>bcc
:
:			       Q	  vv  vvvvvvvvvvvvvvvvvvvvvvvvvvv
:I 20048    data pppp ll  co94 8o leng re ty  UTS status command/response
:			  ?Q or > or nothing  
:
:I 20048    data ooo7 o4  co93 ooo1  dialect level - ASCII data
:
:I 20048    data ooo7 13  co89 1o 59 ct tt ln  call user data
:			  !Q<Nul><Nul><Nul><Nul><Nul><Nul><Nul><Nul>
:			  <Nul><Nul>

: type field

ty01	sc	'invitation to clear'			:01

ty10	sc	'command/response undelivered'		:10
ty11	sc	'command/response aborted'		:11
ty12	sc	'UTS disconnect command/response'	:12
ty13	sc	'UTS select command/response'		:13
ty14	sc	'UTS status command/response'		:14
ty15	sc	'UTS program attention key'		:15
ty16	sc	'UTS message wait message'		:16

ty20	sc	'circuit enabled'			:20
ty21	sc	'circuit reset'				:21
ty22	sc	'circuit request'			:22

ty24	sc	'circuit disconnect'			:24

TyTxtTab hc	(ty01-x),  (ty10-x),(ty11-x),(ty12-x),(ty13-x),(ty14-x)
	hc	(ty15-x),(ty16-x),  (ty20-x),(ty21-x),(ty22-x),  (ty24-x)

TyOkTab	bc	1,  10,11,12,13,14,15,16,  20,21,22,  24,  0

	list
rFineIndex   eq	  1  
rCoarseIndex eq   2
rHoriz	     eq	  3
RightAngle   sc	  '>'
LeftAngle    sc	  '<'
	bnd	2
	
	if	newEbcdic
PrntNumber
	  svc	  ttyTxt,(LeftParen)	:(
	  jal	  r12,PrintCharInHex	:nn
	  svc	  ttyTxt,(RightParen)	:)
	  ais	  rHoriz,(4)
	  j	  ExitTest
PrntEo					:"<Eo>"
	  lhi	  rFineIndex,(40*3)
	  jfs	  pc1
	ei

PrntDel					:"<Del>"
	lhi	rFineIndex,(20*3)
	jfs	pc1
PrntCtl					:"<   >"
	lbr	rFineIndex,rChar	:these three instructions take the
	slls	rFineIndex,(1)		: value in "rChar", multiply it * 3,
	ar	rFineIndex,rChar	:  and put the result in "rFineIndex"
pc1
	lb	r0,(0),rCoarseIndex,rFineIndex

	if	newEbcdic	
	  chi     r0,(Blank)		
	  je	  PrntNumber		:if 1st character was a blank
	ei

	svc	ttyTxt,(LeftAngle)
	svc	tty,ttyChar

	lb	r0,(1),rCoarseIndex,rFineIndex
	svc	tty,ttyChar

	lb	r0,(2),rCoarseIndex,rFineIndex
	chi	r0,(Blank)		
	jefs	pc2			:if 3rd character was a blank
	  svc	  tty,ttyChar
	  ais	  rHoriz,(1)
pc2
	svc	ttyTxt,(RightAngle)
	ais	rHoriz,(4)
	jfs	ExitTest
PrntDot
	lhi	r0,(DOT)
	jfs	puntR0
PrntChar
	lbr	r0,rChar
puntR0
	svc	tty,ttyChar
	ais	rHoriz,(1)
ExitTest
	sis	rMsgLength,(1)
	je	CrLfExit		:<----<< EXIT here

	jal	r12,IncrRingIndex

	clhi	rHoriz,$a 68
	jlfs	j1			:if no imminent peril of beeping
sideDoor
	svc	ttyTxt,(CrLf)
	svc	ttyTxt,(space8)
	svc	ttyTxt,(space8)
	svc	ttyTxt,(space8)
	svc	ttyTxt,(space1)
JumpInPoint
	lhi	rHoriz,$a 26
j1
	lb	rChar,(4),rRingBase,rRingIndex

	if	uts
	  thi	  rFlags,(ReverseBit)
	  jefs	  j2
	    lb	    rChar,(REVTAB),rChar,
j2
	ei

	if	newEbcdic
	  thi	  rFlags,(EbcBit)
	  jn      EbcXlate
	ei


	nhi	  rChar,$2 01111111	:remove "parity" bit

	clhi	rChar,(20)
	jl	PrntCtl			:if <20, control char - display "<   >"
	je	PrntDot			:if =20, BLANK - display "."

	clhi	rChar,(7f)
	jn	PrntChar		:if <>7f, regular char - display it
	j	PrntDel			:if =7f,  display "<Del>"

	if	newEbcdic
EbcXlate
	  chi	  rChar,(40)
	  jl	  PrntCtl		:if <40, control char - display "<   >"
	  je	  PrntDot		:if =40, ebcdic space - display "."

	  chi	  rChar,(4b)
	  je	  PrntDot		:if =4b, ebcdic dot - display "."

	  chi	  rChar,(0ff)
	  je	  PrntEo		:if =ff, display "<Eo>"

	  lbr	  r1,rChar
	  shi	  r1,(40)
	  lb	  r0,(EtoAxlateTable),r1 :r0 gets dot or translation

	  chi	  r0,(DOT)
	  jn	  puntR0		:if NOT Dot, display char (translation)
	  j	  PrntNumber		:if dot, display "(  )"

	  nolist

LeftParen sc	  '('
RightParen sc	  ')'

EtxtTab	  ac	  'NulSohStxEtxPf Ht Lc DelGe RlfSmmVt Ff Cr So Si '
	  ac	  'DleDc1Dc2Tm ResNl Bs Il CanEm Cc Cu1IfsIgsIrsIus'
	  ac	  'Ds SosFs    BypLf EtbEsc      Sm Cu2   EnqAckBel'
	  ac	  '      Syn   Pn Rs Uc Eot         Cu3Dc4Nak   Sub'
	  ac	  'Eo '
	ei

AtxtTab	ac	'NulSohStxEtxEotEnqAckBelBs Ht Lf Vt Ff Cr So Si '
	ac	'DleDc1Dc2Dc3Dc4NakSynEtbCanEm SubEscFs Gs Rs Us '
	ac	'Del'

CtlTxt	sc	-<Ctl -

	list

	bnd	2
isNLC
	lb	rChar,(4),rRingBase,rRingIndex
	nhi	rChar,$2 01111111

	clhi	rChar,(20)
	jge	JumpInPoint

	clhi	rChar,(CarriageReturn-80)
	je	NewFormat

	ahi	rChar,(40)		:!!!
	lbr	r0,rChar

	svc	ttyTxt,(CtlTxt)
	svc	tty,ttyChar
	svc	ttyTxt,(RightAngle)

	j	CrLfExit

r	bc	1,4,2,2,2,2,3,1,2,1,1,80
s	bc	1,1,3
t	bc	1,2,1,1,1
u	bc	1,2,2,2,1,80
v	bc	1,1,1,80
w	bc	1,2,2,2,1,1,1,1
unable	bc	1,2,82
hostun	bc	1,2,84
qtp	bc	86
stp	bc	1,86


x	eq	(seg|a.code|)

ptab	hc	(qtp-x),(stp-x),(t-x),0,0,0,(r-x),(s-x)

itab	hc	(r-x),(r-x),(r-x),(t-x),(w-x),(r-x),(r-x),(w-x),(u-x)
	hc	(unable-x),(w-x),(hostun-x),(w-x),(r-x),(v-x),(r-x),(w-x)

Special
	lr	rPort,rPort
	je	isIntranode		:if port 0 message 

	lbr	rMsgCode,rMsgCode
	je	isNeedle		:if NEEDLE

	clhi	rMsgCode,(9d)
	jle	IixCheck		:if a DATA message

	clhi	rMsgCode,(0b0)
	jl	Loop

	clhi	rMsgCode,(0b7)
	jg	Loop

	clhi	rMsgCode,(0b3)
	je	isNLC			:if normal logon CHARACTER

	clhi	rMsgCode,(0b4)
	je	isNLS			:if normal logon STATUS

	clhi	rMsgCode,(0b5)
	je	isLogFail		:if Logon Failure

	shi	rMsgCode,(0b0)
	slls	rMsgCode,(1)
	la	r7,(ptab),rMsgCode	:r7 is address of entry in address table
	jal	r15,VarSpPrnt
	j	CrLfExit

isNeedle
	lhi	r7,(r-x)
	jfs	vsp2

isIntranode
	slls	rMsgCode,1
	la	r7,(itab),rMsgCode
	jal	r15,VarSpPrnt
	j	CrLfExit

VarSpPrnt
	lhl	r7,(0),r7		:r7 is partial address of byte table
vsp2
	lis	r4,(0)
	st	r0,(savelink),,
vsp3
	lb	r3,(x),r7,r4		:r3 gets entry from byte table
	thi	r3,(80)
	jefs	vsp4			:if not > 80h
	  nhi	  r3,(7f)		:r3 is now 0 2 4 ... and so on
	  lhl	  r3,(jtab),r3
	  j	  (x),r3,
vsp4
	  lb	  rChar,(4),rRingBase,rRingIndex
	  jal	  r12,PrintCharInHex

	  sis	  rMsgLength,(1)
	  jer	  r15			:exit when no more msg length left

	  jal	  r12,IncrRingIndex

	sis	r3,(1)
	jn	vsp4

	svc	ttyTxt,(space1)
	ais	r4,(1)
	j	vsp3

jtab	hc	(doText-x)	:80
	hc	(isUN-x)	:82
	hc	(isHO-x)	:84
	hc	(isQorS-x)	:86
	hc	(DdCode-x)	:88


IixCheck
	lhl	r0,(4),rRingBase,rRingIndex
	 
: global message?

	lis	r2,(0)
gmloop
	  lhl	  r1,(GmOkTab),r2
	  je	  gmnotfound

	  cr	  r0,r1
	  jefs	  gmfound
:!"#
	  ais	  r2,(2)
	jbs	gmloop

gmfound
	la	r7,(GmLenTab),r2
	jal	r15,VarSpPrnt

	svc	ttyTxt,(space2)

	lhl	r7,(GmTxtTab),r2
	svc	ttyTxt,(x),r7,

	j	CrLfExit

:I 20048    data ooo7 o4  8o8o 8o85  Select Dialect Command - IBM SDLC

gmnotfound

: dialect dependent?

	lis	r2,(0)
ddloop
	  lhl	  r1,(DdOkTab),r2
	  je	  NewFormat		:neither.  is gateway? cmt-type?

	  cr	  r0,r1
	  je	  ddfound

	  ais	  r2,(2)
	jbs	ddloop

ddfound
	la	r7,(DdLenTab),r2
	jal	r15,VarSpPrnt

	svc	ttyTxt,(space2)		:all data has been output to screen

	lhl	r7,(DdTxtTab),r2	:say what this iix data was
	svc	ttyTxt,(x),r7,

	j	CrLfExit

: here if some more processing needs to be done (weird VarSpPrnt linkage)

DdCode
	svc	ttyTxt,(space1)

	lb	r3,(4),rRingBase,rRingIndex

	lbr	rChar,r3
	jal	r12,PrintCharInHex	:display "type" (in hex)
	sis	rMsgLength,(1)
	jal	r12,IncrRingIndex

	lbr	r0,r3
	jn	notdatatype

	svc	ttyTxt,(space1)

	lb	rChar,(4),rRingBase,rRingIndex
	jal	r12,PrintCharInHex	:display line number in hex
	sis	rMsgLength,(1)
	jal	r12,IncrRingIndex

	svc	ttyTxt,(space1)

	lhl	r7,(DdTxtTab),r2	:say "UTS protocol packet"
	svc	ttyTxt,(x),r7,

	j	doUtsText		:display the rest in ascii (on new line)

:I 20048    data ooo7 88  co94 8o leng re ty  UTS status command/response
:			  ?Q or > or nothing  
:
: type is not data type (type 0).  say what type it is.

notdatatype
	svc	ttyTxt,(space2)
	lis	r2,(0)
tyloop
	  lhl	  r1,(TyOkTab),r2
	  je	  tynotfound

	  cr	  r0,r1
	  jefs	  tyfound

	  ais	  r2,(2)
	jbs	tyloop

tyfound
	lhl	r7,(TyTxtTab),r2
	svc	ttyTxt,(x),r7,
	j	doUtsText

tynotfound
	svc	ttyTxt,(unktypetext)
	j	doUtsText

unktypetext sc	'UNKNOWN TYPE!'		:you hose-head
	bnd	2

:I 20048    data ooo7 88  co94 oo leng re ty s#  UTS protocol packet
:	wait b		  <Soh>!Qa<Stx>...data...<Etx>bcc
:
:I 20048    data ooo7 o4  co93 ooo1  dialect level - ASCII data

:I 20048    data ooo7 13  co89 1o 59 ct tt ln  call user data
:	wait a		  !Q<Nul><Nul><Nul><Nul><Nul><Nul><Nul><Nul>
:			  <Nul><Nul>

doUtsText
	ohi	rFlags,(ReverseBit)
doText
	la	rCoarseIndex,(AtxtTab)
	j	sideDoor
isUN
	la	r7,(utab)
	jfs	is
isHO
	la	r7,(htab)
	jfs	is
isNLS
	la	r7,(ztab)
	jfs	is
isLogFail
	la	r7,(ytab)
is
	lb	rChar,(4),rRingBase,rRingIndex
	lbr	r6,rChar
	jal	r12,PrintCharInHex

	svc	ttyTxt,(space2)

	nhi	r6,$2 00011111
isShare
	slls	r6,(1)
	lhl	r6,(0),r6,r7
	svc	ttyTxT,(seg|a.code|),r6,

	j	CrLfExit
isQorS
	lb	rChar,(4),rRingBase,rRingIndex
	jal	r12,PrintCharInHex

	svc	ttyTxt,(space2)

	lr	rMsgCode,rMsgCode
	jnfs	isS
	  svc	  ttyTxt,(space3)
isS
	la	r7,(etab)

	l	r6,(savekludge),,	:<---- the kludge, used
	lb	r6,(4+3),rRingBase,r6

	j	isShare

NewFormat				:<----<< ENTER here
	if	newEbcdic
	  thi	  rFlags,(EbcBit)
	  jnfs	  nf1			:if ebcdic translation requested
	ei

	la	rCoarseIndex,(AtxtTab)
	j	JumpInPoint

	if	newEbcdic
nf1
	  la	  rCoarseIndex,(EtxtTab)
	  j	  JumpInPoint
	ei
	
        em
	SUBTTL	PATCH AREA DEFINITIONS
:**********************************************************************
:
:	This program is the sole property and confidential
:	information of TYMSHARE, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.
:
:**********************************************************************
	RA	0		:	PATCH.LIB

:	This library defines symbols, macros and areas used for patching
:	released code and keeping a history of patches in Engine memory.

:	A file containing the actual patches to the code should be
:	assembled as the last file before saving the NIB file.

:	Patches are added by ORGing to the area to patch,
:	zeroing memory for the length of the patch, writing new
:	code starting at that area.
:	Three macros have been defined to do this.
:	Each patch should start with a PATCH macro and if the
:	patch is for more than one area it should be continued
:	with a CONPATCH macro.  The patch should be ended with
:	an ENDPATCH macro.
:
:	Using these macros will cause the patch number, author
:	area patched, and reason for patch to be output during assembly.
:	Also, a history table starting at PATHIS will be created with
:	16 (10hex) byte entries.
:	Each entry will contain the date and time of patch and the author.
:	Also, the ?VERNO DDT command will indicate that patches are
:	installed by reporting a version biased by 100 octal.
:	For example, if the version is 1.13, ?VERNO will report 101.13.
:
:	If a patch must be temporarily added by hand, the
:	history area and the version (cell VERREV) should be updated.
:
:	The following symbols may be defined before assemply of PATCH.LIB.
:	If not defined they will take the default listed.
:
:	VERSION release version number, will be ORed with octal 100.
:		default: 00
:	VERREV	area in seg 0E which contains a one byte version and
:		a one byte revision.  Defined by FINISH.LIB.
:		default: none, symbol must be defined.
:	A.ERR	defines segment to use for patch history area
:		default: seg 0
:	PATHIS	defines the start of the patch history area,
:		each entry will be 16 bytes as follows,
:		19yy/mmdd/hhmm/uname(10 chars 0 filled)
:		where 19yy, mmdd and hhmm are in bcd (4 bits per decimal
:		digit) and uname is in ASCII.
:		default: an area will be defined by this library
:	PHSIZE defines the length in bytes of the PATHIS area.
:		default: 140 hex
:	PATCH0	defines the start of a Segment 0 patch area.
:		default: an area will be defined by this library
:	P0SIZE defines the length in bytes of the PATCH0 area.
:		default: 200 hex
:	PATCH1	defines the start of a code segment  patch area.
:		default: an area will be defined by this library
:	P1SIZE defines the length in bytes of the PATCH1 area.
:		default: 400 hex
:	SEGn,SnSIZE	Must be defined for the area being patched when
:		the patch is made.
:
:	The following symbols are used by the patch macros.
:	They may be read by, but should not be modified by, a patch.
:
:	PAHPTR	pointer to the next available entry in PATHIS
:	PA0PTR	This symbol may be used to place a patch at the next
:		available address in the PATCH0 area.  It starts out
:		equal to PATCH0 and is moved up after each patch in
:		the PATCH0 area.  Use of the symbol assumes that all
:		patches from PATCH0 to PATCH0+P0SIZE will be done in order.
:	PA1PTR	This symbol may be used to place a patch at the next
:		available address in the PATCH1 area.  It starts out
:		equal to PATCH1 and is moved up after each patch in
:		the PATCH1 area.  Use of the symbol assumes that all
:		patches from PATCH1 to PATCH1+P0SIZE will be done in order.
:	QPATS	current patch segment number
:	QPATB	starting address of current patch
:	QPATL	length of current patch
:	QPATA	0 IF PATCH IS IN PATCH0 AREA, 1 IF IN PATCH1, ELSE -1
:	PATACT	> 0 if when a patch is active.



::	PATCH(yymmdd,hhmm,uname,fba,lba1,len)	grab a patch area
:
:		yymmdd	Date patch written, if patch is modified in ANY
:		way this must be updated.
:		hhmm	Time patch written, current Cupertino time.
:		If patch is modified this also must be updated.
:		uname	ONTYME username of person who authored patch.
:		Personal name, not NETMID or NET3 or such.
:	fba	adress of start of patch
:	lba1	address of next byte after end of patch
:	len	length (default hex) of patch in bytes if lba1 is missing
:
:	CONPATCH(fba,lba1,len)	continue a patch in a new area
:		Similar to PATCH but moves to a new area, must be
:		preceeded by a PATCH statement.
:
:	ENDPATCH(comment)	End a PATCH started with PATCH call.
:
:		comment	Description of patch to be output during
:			assembly.  Commas should be preceeded by `.
:
:	Example:
:	:	PATCH TO FIX HDLC ROOM CHECKING ROUTINE
:	  IF	HDLC&(LAPB!LAP)
:	PATCH(811009,1422,FRED,XROOM,,2)
:		LIS	R4,7
:	ENDPATCH(fix hdlc room checking routine)
:	  EI
:
:	:	PATCH TO FIX TRANSMITER BUG
:	PATCH(811009,1630,DDM,XSEND,XSE010)
:	  IF	FINACT	:IF INTERFRAME FILL TIMER ENABLED
:		J	PA1PTR
:	  EI
:	PATRTN	LR	R6,RSIO
:		AHI	R6,OUTSCT,RSIP
:
:	CONPATCH(PA1PTR,,0C)
:		SBT	RL,FRMTMT,,	:INDICATE FRAME TRANSMITTED
:		JNR	R7		:IF ALREADY TRANSMITTED
:		J	PATRTN		:RETURN TO PATCHED AREA
:	ENDPATCH(fix transmitter bug)

	GL	VERSIO,VERREV,A.ERR,PATHIS,PHSIZE,PATCH0,P0SIZE,PATCH1,P1SIZE
	GL	PAHPTR,PA0PTR,PA1PTR,QPATS,QPATB,QPATL,QPATA,PATACT

:	FIRST DEFINE SOME MACROS
	GL	.35.
.35.	EQ	$A 35
	KILL	.NE.
.NE.	MACRO(P1,P2)[(((P1)-(P2))!((P2)-(P1)))^-.35.]
	KILL	.GT.
.GT.	MACRO(P1,P2)[((P2)-(P1))^-.35.]

:	NEXT DEFINE SOME DEFAULTS
  IF	1-\A.ERR
A.ERR	EQ	0
  EI
  IF	1-\PHSIZE
PHSIZE	EQ	140
  ELSE
PHSIZE	EQ	(PHSIZE+0F)/10*10
  EI
  IF	1-\P0SIZE
P0SIZE	EQ	200
  EI
  IF	1-\P1SIZE
P1SIZE	EQ	400
  EI
  IF	1-\PATHIS
	SEG	A.ERR
PATHIS	HS	PHSIZE/2
  EI
  IF	1-\PATCH0
	SEG	0
PATCH0	HS	P0SIZE/2
  EI
  IF	1-\PATCH1
	SEG	A.CODE
PATCH1	HS	P1SIZE/2
  EI

PAHPTR	EQ	PATHIS	:INIT HISTORY POINTER TO START OF AREA
PA0PTR	EQ	PATCH0	:INIT PTR TO START OF AREA
PA1PTR	EQ	PATCH1	:INIT PTR TO START OF AREA
PATACT	EQ	0	:FLAG NO PATCH ACTIVE
QPATA	EQ	-1	:CLEAR PATCH AREA FLAG
QPATS	EQ	-1
QPATB	EQ	-1
QPATL	EQ	-1

	KILL	PATCH
PATCH	macro(day,tim,usr,fba,lba1,len)[
  IF	\VERSION
VERSION EQ	VERSION!$8100
  ELSE
VERSION EQ	$8100
  EI
	SEG	0E
	ORG	VERREV
	BC	VERSION
	SEG	A.CODE
  IF	PATACT
 REMARK %>>>> ERROR **** Previous PATCH not ended with ENDPATCH <<<<%
  ELSE
PATACT	EQ	1
  EI
 REMARK %%PATCH added on day at tim by usr`.
	SEG	A.ERR
	ORG	PAHPTR
   IF	(PAHPTR+1)-(PATHIS+PHSIZE)
 REMARK %>>>> ERROR **** Too many PATCHs, increase PHSIZE beyond ; NUMBER $0PHSIZE
 REMARK x and reassemble <<<<%
   EI
	WC	$0 day!19000000
	HC	$0 tim
Q	AC	\usr\
Q1	HS
	ORG	Q+$a10	:skip to next history area
PAHPTR	HS
  IF	Q1-.	:IF UNAME>10 CHARARACTERS, CLEAR OVERFLOW
	RE	Q1-.
	BC	0
	ER
  EI

QPATS	EQ	((fba)&$00FF0000)^-$010
QPATB	EQ	fba
QPATC	EQ	lba1
  IF	lba1 0
QPATL	EQ	(lba1)-(fba)
  ELSE
QPATL	EQ	len 2
  EI
  IF	(.NE.(QPATC,0))&(.GT.(QPATB-QPATC+2,0))
 REMARK %>>>> ERROR **** Address of patch end < address of patch start <<<<%
  EI
  IF	(QPATB+1)-(PATCH1)	:IF PATCHING IN PATCH1,
   IF	(PATCH1+P1SIZE)-QPATB	: BUT NOT OUTSIDE IT,
QPATA	EQ	1	:PATCHING PATCH1 AREA
    IF	(QPATB+QPATL)-(PATCH1+P1SIZE)	:BUT NO PATCH AREA LEFT
 REMARK %>>>> ERROR  **** PATCH1 area overflow <<<<%
    EI
   EI
  EI
  IF	(QPATB+1)-(PATCH0)	:IF PATCHING IN PATCH0,
   IF	(PATCH0+P0SIZE)-QPATB	: BUT NOT OUTSIDE IT,
QPATA	EQ	0	:PATCHING PATCH0 AREA
    IF	(QPATB+QPATL)-(PATCH0+P0SIZE)	:BUT NO PATCH AREA LEFT
 REMARK %>>>> ERROR  **** PATCH0 area overflow <<<<%
    EI
   EI
  EI
  IF	QPATA+1		:IF PATCHING IN PATCH0 OR PATCH1 AREA
 REMARK %	Starts at PATCH; NUMBER $0QPATA; REMARK +
 NUMBER	$0PA|QPATA|PTR-PATCH|QPATA|
 REMARK  and is ; NUMBER $0QPATL; REMARK x bytes long%
  ELSE
 REMARK %     Starts at fba and is 
 NUMBER $0 QPATL
 REMARK x bytes long%
  EI

	SEG	QPATS
	ORG	QPATB
	RE	QPATL
	BC	0
	ER
  IF	(.+1)-(S|QPATS|SIZE+SEG|QPATS|)
 REMARK %>>>> ERROR **** PATCH causes SEG; NUMBER $0qpats
 REMARK  overflow <<<<%
  EI
	ORG	QPATB

::	CONPAT(fba,lba1,len)	CONTINUE A PATCH
	KILL	CONPAT
CONPAT	MACRO(cfba,clba1,clen)[
PATACT	EQ	PATACT+1
  IF	2-PATACT
REMARK %>>>> ERROR **** CONPAT not preceded by a PATCH <<<<%
  EI
  IF	QPATA+1		:IF PATCH WAS IN A PATCH AREA
PA|QPATA|PTR	EQ	.
  EI
QPATA	EQ	-1	:CLEAR FLAG
QPATS	EQ	((cfba)&$00FF0000)^-$010
QPATB	EQ	cfba
QPATC	EQ	clba1
  IF	clba1 0
QPATL	EQ	(clba1)-(cfba)
  ELSE
QPATL	EQ	clen 2
  EI
  IF	(.NE.(QPATC,0))&(.GT.(QPATB-QPATC+2,0))
 REMARK %>>>> ERROR **** Address of conpatch end < address of conpatch start <<<<%
  EI
  IF	(QPATB+1)-(PATCH1)	:IF PATCHING IN PATCH1,
   IF	(PATCH1+P1SIZE)-QPATB	: BUT NOT OUTSIDE IT,
QPATA	EQ	1	:PATCHING PATCH1 AREA
QPATA	EQ	1	:PATCHING PATCH1 AREA
    IF	(QPATB+QPATL)-(PATCH1+P1SIZE)	:BUT NO PATCH AREA LEFT
 REMARK %>>>> ERROR  **** PATCH1 area overflow <<<<%
    EI
   EI
  EI
  IF	(QPATB+1)-(PATCH0)	:IF PATCHING IN PATCH0,
   IF	(PATCH0+P0SIZE)-QPATB	: BUT NOT OUTSIDE IT,
QPATA	EQ	0	:PATCHING PATCH0 AREA
    IF	(QPATB+QPATL)-(PATCH0+P0SIZE)	:BUT NO PATCH AREA LEFT
 REMARK %>>>> ERROR  **** PATCH0 area overflow <<<<%
    EI
   EI
  EI
  IF	QPATA+1		:IF PATCHING IN PATCH0 OR PATCH1 AREA
 REMARK 	Continues at PATCH; NUMBER $0QPATA; REMARK +
 NUMBER	$0PA|QPATA|PTR-PATCH|QPATA|
 REMARK  and is ; NUMBER $0QPATL; REMARK x bytes long%
  ELSE
 REMARK 	Continues at cfba and is 
 NUMBER $0 QPATL
 REMARK x bytes long%
  EI
	SEG	QPATS
	ORG	QPATB
	RE	QPATL
	BC	0
	ER
  IF	.-(S|QPATS|SIZE+SEG|QPATS|)
 REMARK %>>>> ERROR **** PATCH causes SEG; NUMBER $0qpats
 REMARK overflow <<<<$
  EI
	ORG	QPATB

::	ENDPATCH(com)	End a patch - does error checking, outputs comment
	KILL	ENDPATCH
ENDPATCH	macro(c1,c2,c3,c4,c5)[
PATACT	EQ	0
  IF	.-(QPATB+QPATL)
 REMARK %>>>> ERROR **** BAD CONPATCH(cfba,clba1,clen) <<<<%
  EI
  IF	QPATA+1		:IF PATCH WAS IN A PATCH AREA
PA|QPATA|PTR	EQ	.
  EI
QPATA	EQ	-1	:CLEAR FLAG
	SEG	A.CODE
 REMARK <<< c1````c2````c3````c4````c5 >>>
]
]

	KILL	ENDPATCH
ENDPATCH	macro(c1,c2,c3,c4,c5)[
PATACT	EQ	0
  IF	.-(QPATB+QPATL)
 REMARK %>>>> ERROR **** BAD PATCH(day,tim,usr,fba,lba1,len) <<<<%
  EI
  IF	QPATA+1		:IF PATCH WAS IN A PATCH AREA
PA|QPATA|PTR	EQ	.
  EI
QPATA	EQ	-1	:CLEAR FLAG
	SEG	A.CODE
 REMARK <<< c1``c2``c3``c4``c5 >>>
]
]
        subttl  Control Table Allocation and Diagnostics - Finish.Lib
 
:       This program is the sole property and confidential            
:       information of Tymshare, Inc., and may not be copied          
:       in whole or in part or disclosed to any third party           
:       without the prior written consent of Tymshare.                

: This file SHOULD ALWAYS be assembled LAST!

	ra	$0 0		

	if	\(Fpanel)
  	else
	  seg	  a.data
Fpanel    hs      1
	ei

	if	\(FrISIS)
	else
	  seg	  0
FrISIS	  hs	  (MaxPrt+0f)/10
	ei

	if	\(ToISIS)
	else
	  seg	  0
ToISIS	  hs	  (MaxPrt+0f)/10
	ei

S	eq	0
	nolist
 	re	$a 15			:repeat for all EXCEPT seg F
seg|S|	  eq	  (seg|S|)&(7fffffff)
	  if	  (seg|S|)%(S*10000)
	    remark %"seg
	    number S
	    remark " has been redefined
	  ei

	  if	  \(Patch0)
	  else
	    seg	    0
Patch0	    ws	    $a 32		:segment zero patch area
	  ei

	  if	  \(Patch1)
	  else
	    seg	    1
Patch1	    ws	    $a 32		:segment one patch area
	  ei

	  if	  \(Patch2)
	  else
	    seg	    2
Patch2	    ws	    $a 32		:segment two patch area
	  ei

	  seg	  S
s|S|size  eq	  (.)-(seg|S|)
S	  eq	  S+1
	er

S	eq	0
	re	$a 15
	  if	  (s|S|size)-10000
	    remark %Segment 
	    number S
	    remark - overflow, exceeded by 
	    number ($0(s|S|size)-10000)$a
	    remark d bytes
	  ei
S	  eq	  S+1
	er
	list

	if	\(Xmemry)
        else
Xmemry    eq      0
        ei

: set up CTA table

	if	sEsize
	  remark %Segment E is reserved for CTA. Remove other allocations.%%
	else
	  seg	  0e
          if        Xmemry
CTA         wc        CNTRL+$0 1000
          else
CTA	    wc	      CNTRL
      	  ei

	  wc	  CTAsiz		:size of CTA area

Areas
S	  eq	  0
	  re	  $a 14			:repeat for all except E and F
	    wc	    (s|S|size)		:size of area
S	    eq	    S+1

	  er

	  hc	  $a 14			:number of protection bytes

 	  if	  \(Aprot0)
	    bc	    Aprot0		:set area 0 protection
 	  else
	    remark %default area protections assumed.%
	    bc	    6			:default - execution protected
 	  ei

 	  if	  \(Aprot1)
	    bc	    Aprot1		:set area 1 protection
 	  else
	    bc	    5			:default - write protected
 	  ei	

S	  eq	  2
	  re	  $a 12			:repeat 12 times for 2 thru D (13)
	    if	    \(Aprot|S|)
	      bc      Aprot|S|
	    else
	      bc      6			:default - execution protected
	    ei
S	    eq	    S+1

	  er

	  wc	  ENTRY			:entry point address

	  if	  \(DSTART)
	    wc	    DSTART		:ddt start address
	  else
	    wc	    0			:no user ddt code
	  ei

	  wc	  Fpanel		:address of front panel display cell
	  wc	  Hosts			:defined in this module
	  wc	  Ports			:defined in this module
	  wc	  Ptable		:permuter table address - defined in this module
	  wc	  Iring			:defined elsewhere - user code
	  wc	  Oring			:ditto
	  wc	  FrISIS		:possibly defined in this module
	  wc	  ToISIS		:ditto

	  if	  \(PcTtbl)
	    wc	    PcTtbl		:project code termination table
	  else
	    wc	    0			:null table
	  ei

CoreSt	  ws	  1			:absolute core address of start of slot

	  hc	  MaxHst

	  remark %MaxHst value is 
	  number  MaxHst
	  remark h (
	  number MaxHst$a
	  remark d)

	  hc	  MaxPrt

	  remark %MaxPrt value is 
	  number  MaxPrt
	  remark h (
	  number MaxPrt$a
	  remark d)

	  hc	  IRsize
	  hc	  ORsize

SlotNo	  hs	  1			:slot number (supplied by isis)

	  if	  \(Version)
VerRev	    bc	    Version
	  else
VerRev	    bc	    0
	  ei

	  if	  \(RevLev)
	    bc	    RevLev
	  else
	    bc	    0
	  ei

	  remark %this is Version 
	  number  $8 Version
	  remark .
	  number  $8 RevLev

 	  if	  \(QStart)
	    wc	    QStart		:ddt query start address
 	  else
	    wc	    0			:no user code
 	  ei

          hc      (EmMac0-CTA)

  	  if      \(nMacSS)
            hc      nMacSS      	:Number of MAC Register Sets
    	  else
            hc      0           	:No extended MAC sets
    	  ei

          hc      0             	:Segments to be saved

	  if	  \(ProdID)
	  else
	    if	    \(HID0)
ProdID        eq      HID0      	:Define ProdID as alias
            ei
          ei

	  if	  \(ProdID)
            if	    (ProdID-$a255)
              remark  %ProdID is too large%
              quit    1
            ei
            if      (ProdID-$a48)
            else
              remark  %ProdID is too small%
              quit    1
            ei
          else
            remark  %ProdID - Slot Product ID must be defined%
            quit    1
          ei

          hc      ProdID	        :slot Product ID

	  remark %ProdID is 
	  number  ProdID

	  ws	  10			:reserved for future expansion

Hosts					:host table
H	  eq	  0
	  re	  MaxHst
	    if	    \(Host|H|)

	      hc      (Host|H|)

	      remark %Host
	      number H
	      remark  is 
	      number (Host|H|)$a
    	    else
	      hc      10
	      remark %Host
	      number H
	      remark  has no assembled in host number
            ei
H	    eq	    H+1
	  er

Ports	  hs	  0			:port table
H	  eq	  0
	  re	  MaxHst
	    if	    \(Hprt|H|)

	      hc      (Hprt|H|)

	      remark %Host
	      number H
	      remark  has 
	      number (Hprt|H|)
	      remark h (
	      number (Hprt|H|)$a
	      remark d) ports
            else
	      hc      0
	      remark %Host
	      number H
	      remark  does not have an assembled in number of ports
            ei
H	    eq	    H+1
	  er

Ptable	  hs	  MaxPrt+1		:permuter table

EmMac0    ws      0             	:Extended Memory MAC Register sets
          if	  Xmemry
            if	    \(nMacSS)
              ExpMac
              remark %Using Extended Memory Option%
              number $a nMacSS
              remark  MAC Register sets allocated%
              number $a eMemR3
              remark  k allocated on non-zero meg
            else
              remark  %nMacSS must be specified with extended memory%
              quit    1
            ei
          ei

CTAsiz    eq	  (.)-CTA		:CTA area size

sEsize	  eq	  (.)-CTA		:seg E size

        ei


: tell memory requirements

TOTAL	eq	0			:this accumulates memory requirements
S	eq	0			:this clicks thru the segments
	re	$a 15
	  if	  (s|S|size)
	    remark  %Segment 
	    number  S
	    remark  - length 
	    number  (s|S|size)$a
	    remark d (
	    number  (s|S|size)
	    remark h),
	    remark  requires 
	    number  ((s|S|size)+0ff)&(@0ff)
	    remark h bytes of core.
TOTAL	    eq	    TOTAL+((s|S|size)+0ff)&(@0ff)
	  ei
S	  eq	  S+1
	er

	remark	%%
	number	(TOTAL+3ff)/400$a
	remark d (
	number  (TOTAL+3ff)/400
	remark h)
	remark  K-bytes of core%

	un				:spew out all undefined symbols
  N[Uj