C
C*****************************
C
C       PAP2.FTF
C
C****************************
C
C
C       SUBROUTINE TO CHECK IF STATUS IS TYPED CORRECTLY
C
        SUBROUTINE CSTAT(INFO,GARBAGE,Z,TNUM)
C
        INTEGER INFO(64),K,J,GARBAGE,Z
C
        CALL TINFO(INFO)
        TYPE 100,TNUM
100     FORMAT(/1X'IS THE STATUS CORRECT ? FOR TICKET #',I8,/,
     1  'A C.R. WILL WRITE IT TO THE DATA BASE, ANYTHING ELSE,',/
     2  2X,'WILL CAUSE YOU TO START OVER AGAIN : ',$)
        ACCEPT 110,GARBAGE
110     FORMAT(A1)
        RETURN
        END
C
C       SUBROUTINE TO TYPE OUT STATUS
C
        SUBROUTINE TINFO(INFO)
C
        INTEGER INFO(64),ILIN,N,J
C
        DO 50 ILIN=1,4
        N=(ILIN*16)-15
        IF (INFO(N).EQ.'.    ') GOTO 40
        TYPE 30,(INFO(J),J=N,N+15)
30      FORMAT(1X,16A5)
        GOTO 50
40      ILIN=4
50      CONTINUE
        RETURN
        END
C
C       SUB-ROUTINE TO DETERMINE ALL ELM'S
C
        SUBROUTINE TOTELM(DOIT,ELM,HOUR,D)
C
        INTEGER I,L,A,DOIT
        REAL STDV,MEDM,E,D,C,B,ELM
C       ENCODE(5,10,L)DOIT
10      FORMAT(I5)
        HOUR=0
        ELM=0
        DO 200 A=1,DOIT
        CALL DBGREC($200,A)
        CALL DBVAL('ELM',B)
        ELM=ELM+B
200     CONTINUE
        ELM=ELM/DOIT
c       STDV=SQRT((E-C*C/DOIT)/(DOIT-1))
c       TYPE 205,STDV
205     FORMAT(/1X,'STANDARD DEV.   ',F40.20,/)
        HOUR=ELM/60
        RETURN
        END
C
C       SUBROUTINE TO DETERMINE SPLIT OF MTTR
C
        SUBROUTINE MTRAVE(D,ELD,ELH,RLM)
C
        INTEGER D,ELD,ELH,RLM
C
        IF (D.GT.1439) GOTO 100
        ELD=0
        ELH=D/60
        RLM=D-(ELH*60)
        RETURN
100     ELD=D/1440
        ELH=(D-(ELD*1440))/60
        RLM=D-((ELD*1440)+(ELH*60))
        RETURN
        END
C
C       SUBROUTINE TO TAKE NORMAL DATE AND CHANGE TO 1022
C
        SUBROUTINE CDDWN
C
        INTEGER DAT,SM,SD,SY
C
        TYPE 100
100     FORMAT(1X,'ENTER DATE MM/DD/YY : ',$)
        ACCEPT 105,SM,SD,SY
105     FORMAT(I2,1X,I2,1X,I4)
        CALL CDAT(SY)
        CALL DBDATN(DAT,SM,SD,SY)
        TYPE 110,DAT
110     FORMAT(1X,'THE 1022 FORMAT IS  ',I9)
        RETURN
        END
C
C       ROUTINE TO CHECK YEAR AND MAKE YEAR 4 PLACES.
C       IF IS 4 THEN MAKE TWO IF IS 2 THEN MAKE 4
C
        SUBROUTINE CDAT(SY)
C
        INTEGER SY
C
        IF (SY.GT.1800) SY=SY-1900
        IF (SY.LT.100) SY=SY+1900
        RETURN
        END
C
C       SUBROUTINE TO CHANGE TUP IF BAD
C
        SUBROUTINE CHATIM(SDAT,TIM1,DUP,TUP,NUMBER,I)
C
        INTEGER SDAT,TIM1,DUP,TUP,NUMBER,I,C
C
        TYPE 100
100     FORMAT(1X,'YOU CAN DO ONE OF THREE',/3X,'1= LEAVE ALONE',
     1  /3X'2= CHANGE',/3X,'3= EXIT PROGRAM')
        ACCEPT 105,C
105     FORMAT(I1)
        IF (C.EQ.1) RETURN
        IF (C.EQ.2) GOTO 200
        I=NUMBER
        RETURN
200     TYPE 205,SDAT,TIM1,DUP,TUP
205     FORMAT(1X,I9,2X,A5,5X,I9,2X,A5)
        ACCEPT 210,TUP
210     FORMAT(A5)
        ENCODE(11,215,TUP)TUP
215     FORMAT(I11)
        CALL DBCHNG(20,TUP)
        RETURN
        END
C
C       SUBROUTINE TO FIND BEGINNING PERIOD AND END PERIOD
C
        SUBROUTINE PERIOD(NDAT,NDUP,SM,SD,SY,EM,ED,EY)
C
        INTEGER NDAT,NDUP,SY,SM,SD,EY,EM,ED
C
        TYPE 100
100     FORMAT(1X,'ENTER START DATE : MM/DD/YYYY ? = ',$)
        ACCEPT 110,SM,SD,SY
110     FORMAT(I2,1X,I2,1X,I4)
        TYPE 120
120     FORMAT('+ENTER END DATE   : MM/DD/YYYY ? = ',$)
        ACCEPT 110,EM,ED,EY
        IF (EM.EQ.0) EY=2010
        CALL DBDATN(NDAT,SM,SD,SY)
        CALL DBDATN(NDUP,EM,ED,EY)
        SY=SY-1900
        EY=EY-1900
        RETURN
        END
C
C       SUBROUTINE TO MOVE BASE1 TO BASE4
C
        SUBROUTINE MOOPEN(TOT1)
C
        INTEGER TOT1,ANS,I,TNUM,SDAT,TIM1,NDAT,NTIM,RS,STAT
        INTEGER MAINT,NET(2),SVER,PROD,WHO,TOT2
        INTEGER DISC(169),SCON(4),SITP(4),NODE,SLOT,HOST,CKT(4)
        INTEGER TRB(4),DUP,TUP,MAINT,SVER,HN,COC(2),CBY
        INTEGER RFON(4),RNAM(4),PRO,T40,F2,CCOD,HQCC,ONUM(2),SRGN
        INTEGER HRGN,LOC(4),KHST,COV,COMMNT(4),CDAT,TCLSD,STH,EHR
        INTEGER PORT,CNAM(3),TECH(3),VER,V5,V6,V1,V2,V3,V4
        INTEGER BILL,ESC,F1,NT,HN
        REAL ELM
C
40      TYPE 45
45      FORMAT(/1X,'MOVING BASE1 TO BASE4... STANDBY',/)
50      CALL DBERR($190,IERT,IERC,0)
        TOT2=TOT1
100     DO 200 I=1,TOT1
        TYPE 105,I
105     FORMAT('+',1X,I4,$)
        CALL DBGREC($200,I)
        CALL DBVAL(1,TNUM,2,PRO,3,T40,4,F2,5,SDAT,6,TIM1,7,RNAM,8,RFON,
     1  9,NET,10,WHO,11,RS,12,SCON,13,SITP,14,PROD,15,STAT,16,DISC,17,
     2  CCOD,18,HQCC,19,ONUM,20,SRGN,21,HRGN,22,
     3  LOC,23,KHST,24,COV,25,COMMNT,26,CDAT,27,TCLSD,28,STH,29,EHR,
     4  30,PORT,31,CNAM,32,TECH,33,VER,34,V5,35,V6,36,V1,37,V2,38,V3,
     5  39,V4,40,NODE,41,SLOT,42,HOST,43,CKT,44,TRB,45,BILL,46,ESC,47,
     6  F1,48,NT,49,DUP,50,TUP,51,MAINT,52,SVER,53,HN,54,ELM,55,COC,
     7  56,CBY)
        CALL DBSET(2)
        CALL DBADD(1,TNUM,2,PRO,3,T40,4,F2,5,SDAT,6,TIM1,7,RNAM,8,RFON,
     1  9,NET,10,WHO,11,RS,12,SCON,13,SITP,14,PROD,15,STAT,16,DISC,17,
     2  CCOD,18,HQCC,19,ONUM,20,SRGN,21,HRGN,22,
     3  LOC,23,KHST,24,COV,25,COMMNT,26,CDAT,27,TCLSD,28,STH,29,EHR,
     4  30,PORT,31,CNAM,32,TECH,33,VER,34,V5,35,V6,36,V1,37,V2,38,V3,
     5  39,V4,40,NODE,41,SLOT,42,HOST,43,CKT,44,TRB,45,BILL,46,ESC,47,
     6  F1,48,NT,49,DUP,50,TUP,51,MAINT,52,SVER,53,HN,54,ELM,55,COC,
     7  56,CBY)
        CALL DBSET(1)
        CALL DBFIND('RS','GE',8)
        GOTO 200
190     IF (IERT.EQ.7) GOTO 197
        IF (IERT.NE.3) RETURN
        CALL DBSET(1)
        CALL DBFIND(1,1,TNUM)
        CALL DBCHNG('RS',4)
        TOT2=TOT1-1
        CALL DBFIND('RS','GE',8)
        GOTO 200
197     TYPE 198
198     FORMAT(1X,'STANDBY.. FOR BUSY')
        CALL WAIT(8.0)
        GOTO 100
200     CONTINUE
        CALL DBSET(1)
        CALL DBFIND('RS','GE',8)
        DO 220 I=1,TOT2
        CALL DBGREC($220,I)
        CALL DBDEL
220     CONTINUE
        RETURN
        END
