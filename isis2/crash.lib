	SUBTTL	ISIS STARTUP AND CRASH LIBRARY	- CRASH.LIB
:******************************************************************
:
:	This program is the sole property and confidential
:	information of Tymshare, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.
:
:*******************************************************************
	RA	0		:	CRASH.LIB	MFR 07/14/81

:	ENTRY2 (restart service) changed to clear input and output
:	rings PRIOR to issuing Restart SVC to prevent crash-loop if
:	Dispatcher has crashed. June 17, 1982 MDS.

  IF	ISIS2
:			ISIS - II Version
:
	GL	CRASH,CRASHC,CPOINT,CFROM,CRREG,ENTRY,START,CRAT,CRSHCT,CRSTOP
	MO	.,CRASH


:	Generalized crash package.
:	Handles both software and hardware crashes.  On any crash, the
:	registers are saved in CRREG, and CRSHCT is incremented.
:	Software crashes occur via  JAL R10,CRASH .  CRASH saves (R10) in cell
:	CPOINT.  Software crashes may be "good" or "bad"...if "good", the
:	calling sequence is:

:		JAL	R10,CRASH
:						from a bad one
:		HC	0		:this key distinguishes a good crash
:		BC	4*L,Y		:first byte is 4*register linked to
:						routine, Y is the reason
:	then register (L) is saved in CFROM, and Y is saved in CRASHC

:	in the event of a hardware failure, CPOINT contains the instruction
:	address at the time of failure, CRASHC contains the failure reason,
:	and CFROM is set =-1.

:	On completion of crash, transfers to label START, defined
:	in the user code.
:
:	The symbol CRSTOP may be set to 0 or 1.  If 1 the crash routine will
:	be executed only once.  the second time through the crash area will
:	be set up as specified above and then registers will be restored to
:	their entry value and the slot will be frozen. If it is thawed it
:	will restart.
:
:	Entering :RCRAT,4B in NAD will dump the crash table.
:

  IF	\CRSTOP
  ELSE
CRSTOP	EQ	0
  EI

	SEG	A.DATA
CRAT	HS	0		:START OF CRASH TABLE AREA
CRSHCT	HC	0		:CRASH COUNT...HOW MANY TIMES CRASHED
CRASHC	HC	1		:CRASH CODE (INIT'ED TO MANUAL RESTART)
CPOINT	HC	0,0		:WHERE CRASH OCCURED
CFROM	HC	-1,-1		:WHERE CRASH WAS CALLED FROM
CRREG	HS	20		:CRASH REGISTER SAVE AREA
FGNDFL	HS	1		:FOREGROUND FLAG


	SEG	A.CODE		:CODE AREA
CRSHCD	BC	1	:MANUAL RESTART
	BC	0	:POWER FAILURE
	BC	0E	:PARITY ERROR
	BC	10	:DISPATCHER CRASH
	BC	11	:ILLEGAL INSTRUCTION
	BC	12	:ILLEGAL SVC
	BC	13	:SYSTEM CRASH
	BC	14	:PROTECTION VIOLATION
	BC	15	:NON-RECOVERABLE DEVICE CHECK

	RA	0
:	GENERAL MACHINE FAILURE
FAIL	HS	4		:PSD SAVED HERE
	HS	4		:R0,R1 SAVED HERE
	LB	R0,CRSHCD,R1	:CONVERT CRASH REASON
	CLHI	R0,12		:TEST IF ILLEGAL SVC
	JNFS	FAIL1		:NO...SKIP
	LHL	R0,FGNDFL	:DID FOREGROUND CAUSE THE CRASH?
	JN	ENTRY2		:YES....JUMP OVER
FAIL1	STM	R2,CRREG+8	:SAVE THE REGISTERS
	STH	R0,CRASHC	:SAVE CRASH CODE
	LM	R12,FAIL	:GET THE REST
	STM	R14,CRREG	:SAVE R0 & R1
	ST	R13,CPOINT	:SAVE FAILURE ADDRESS
	LCS	R1,1
	ST	R1,CFROM	:FLUSH PLACE CALLED FROM
	J	ENTRY1		:AND SKIP TO START UP AGAIN



:	CRASH ROUTINE AND GENERAL INITIALIZER
:	IF "GOOD" CALL TO CRASH, HAS HALFWORD 0'S FOLLOWING,
:	THEN BYTE WITH 4*LINK REGISTER, THEN BYTE WITH CRASH REASON

CRASH	STM	R0,CRREG	:SAVE REGISTERS AND
	ST	R10,CPOINT
	LIS	R0,$A10		:FAKE UNKNOWN CRASH
	LCS	R1,1		:FROM NOWHERE
	LHL	R2,0,R10	:CHECK WHERE CALLED FROM
	JNFS	CRASH1		:NOT KNOWN...USE DEFAULT
	LB	R0,3,R10	:GET CRASH CONDITION
	LB	R2,2,R10	:GET CALLING REGISTER
	L	R1,CRREG,R2	:GET CONTENTS OF REGISTER
CRASH1	STH	R0,CRASHC	:SAVE CRASH CODE
	ST	R1,CFROM	:SAVE PLACE CRASHED FROM
	JFS	ENTRY1

:	ENTER HERE WITH RESTART
ENTRY	LIS	R0,1		:LOAD CRASH CODE REGISTER
	STH	R0,CRASHC	:STORE IT
ENTRY1	LIS	R1,1
	AHM	R1,CRSHCT	:SAVE INTERESTING DATA

  IF	CRSTOP		:IF STOPPING ON CONSECUTIVE CRASHES
	CLHI	R0,1
	JLE	ENTRY2		:IF POWER FAILURE OR MANUAL RESTART
	OHI	R0,0CC00	:CRASH INDICATOR FOR FRONT PANEL
	STH	R0,FPANEL,,	:SET PANEL TO BAD CRASH
	LM	R0,CRREG	:RESTORE REGISTERS
	SVC	SYS,HALT.	:HALT THE SLOT
  EI	CRSTOP

	LIS	R0,1		:WANT SECOND WORD OF PSD
	SVC	SYS,RFPSD.	:READ FOREGROUND PSD
	CLI	R0,.		:TEST IF FOREGROUND IS EXECUTING THIS INSTRUCTION
	JNFS	ENTRY2		:SKIP IF NOT
	STH	R0,FGNDFL	:SET THE FOREGROUND FLAG

ENTRY2		: NOW RESET OUTPUT RING, REPORT CRASH
	LIS	R0,0
	ST	R0,ORING,,	:EMPTY OUTPUT RING
	ST	R0,IRING,,	:EMPTY INPUT RING

	LA	R0,FAIL		:LOAD TRAP AREA ADDRESS
	SVC	SYS,RSTRT.	:RESTART SVC
	JAL	R10,CRASH	:NON-SKIP RETURN...CRASH


	LIS	R0,0
	STH	R0,FGNDFL	:CLEAR THE FOREGROUND FLAG

	JAL	R4,SPACE,,	:SET UP FOR DIAGNOSTIC
	LHI	R0,0300;	JAL	R4,PUTW,,	:PORT 0 + DIAGNOSTIC MESSAGE + PAD
	LHL	R0,CRSHCT;	JAL	R4,PUTH,,	:HW4 = CRASH COUNT
	LHL	R0,CRASHC;	JAL	R4,PUTH,,	:HW3 = CRASH CODE
	LIS	R0,1;		JAL	R4,PUTCH,,	:HW2 IS DIAGNOSTIC 1
	JAL	R4,ELOR,,		:END LOGICAL OUTPUT RECORD
	J	START,,		:NOW GO TO INITIALIZATION CODE
	EM

  ELSE		:ISIS2
:			ISIS - I Version
:
	GL	CRASH,CRASHC,CPOINT,CFROM,CRREG,ENTRY,START,CRAT,CRSHCT,CRSTOP
	MO	.,CRASH


:	Generalized crash package.
:	Handles both software and hardware crashes.  On any crash, the
:	registers are saved in CRREG, and CRSHCT is incremented.
:	Software crashes occur via  JAL R10,CRASH .  CRASH saves (R10) in cell
:	CPOINT.  Software crashes may be "good" or "bad"...if "good", the
:	calling sequence is:

:		JAL	R10,CRASH
:						from a bad one
:		HC	0		:this key distinguishes a good crash
:		BC	4*L,Y		:first byte is 4*register linked to
:						routine, Y is the reason
:	then register (L) is saved in CFROM, and Y is saved in CRASHC

:	in the event of a hardware failure, CPOINT contains the instruction
:	address at the time of failure, CRASHC contains the failure reason,
:	and CFROM is set =-1.

:	On completion of crash, transfers to label START, defined
:	in the user code.
:
:	The symbol CRSTOP may be set to 0 or 1.  If 1 the crash routine will
:	be executed only once.  the second time through the crash area will
:	be set up as specified above and then registers will be restored to
:	their entry value and CRASH will sit in a loop calling DISMISS.
:	This is less load on the CPU than sitting in a self loop.
:	In order to start the code again CRSHCT must be set to 0.
:
:	Entering :RCRAT,4B in NAD will dump the crash table.

	SEG	A.DATA
CRAT	HS	0		:START OF CRASH TABLE AREA
CRSHCT	HC	0		:CRASH COUNT...HOW MANY TIMES CRASHED
CRASHC	HC	1		:CRASH CODE (INIT'ED TO MANUAL RESTART)
CPOINT	HC	0,0		:WHERE CRASH OCCURED
CFROM	HC	-1,-1		:WHERE CRASH WAS CALLED FROM
CRREG	HS	20		:CRASH REGISTER SAVE AREA


	SEG	A.CODE		:NOW ADVANCE TO SEGMENT 1
:	GENERAL MACHINE FAILURE
FAIL	HS	4		:PSD SAVED HERE
	HS	4		:R0,R1 SAVED HERE
	LHI	R0,$8 01;	J	FAIL0		:MANUAL RESTART
	LHI	R0,$8 00;	J	FAIL0		:POWER FAILURE
	LHI	R0,$8 14;	J	FAIL1		:PARITY ERROR
	LHI	R0,$8 20;	J	FAIL1		:DISPATCHER CRASH
	LHI	R0,$8 21;	J	FAIL1		:ILLEGAL INSTRUCTION
	LHI	R0,$8 22;	J	FAIL1		:ILLEGAL SVC
	LHI	R0,$8 23;	J	FAIL1		:PRIVILEGE VIOLATION
	LHI	R0,$8 24;	J	FAIL1		:PROTECTION VIOLATION
	LHI	R0,$8 25;	J	FAIL1		:ARITHMETIC FAULT

FAIL0	SVC	DISMISS,10	:POWER FAILURE OR MANUAL RESTART...
				:SLEEP FOR A WHILE
FAIL1	STM	R1,CRREG+4	:SAVE THE REGISTERS
	STH	R0,CRASHC	:SAVE CRASH CODE
	LM	R13,FAIL	:GET THE REST
	ST	R15,CRREG	:SAVE R0
	ST	R14,CPOINT	:SAVE FAILURE ADDRESS
	LCS	R1,1
	ST	R1,CFROM	:FLUSH PLACE CALLED FROM
	J	ENTRY1		:AND SKIP TO START UP AGAIN



:	CRASH ROUTINE AND GENERAL INITIALIZER
:	IF "GOOD" CALL TO CRASH, HAS HALFWORD 0'S FOLLOWING,
:	THEN BYTE WITH 4*LINK REGISTER, THEN BYTE WITH CRASH REASON

CRASH	STM	R0,CRREG	:SAVE REGISTERS AND
	ST	R10,CPOINT
	LIS	R0,$A10		:FAKE UNKNOWN CRASH
	LCS	R1,1		:FROM NOWHERE
	LHL	R2,0,R10	:CHECK WHERE CALLED FROM
	JNFS	CRASH1		:NOT KNOWN...USE DEFAULT
	LB	R0,3,R10	:GET CRASH CONDITION
	LB	R2,2,R10	:GET CALLING REGISTER
	L	R1,CRREG,R2	:GET CONTENTS OF REGISTER
CRASH1	STH	R0,CRASHC	:SAVE CRASH CODE
	ST	R1,CFROM	:SAVE PLACE CRASHED FROM
	JFS	ENTRY1

:	ENTER HERE WITH RESTART
ENTRY	LIS	R0,1		:LOAD CRASH CODE REGISTER
	STH	R0,CRASHC	:STORE IT
ENTRY1	LIS	R1,1
	AHM	R1,CRSHCT	:SAVE INTERESTING DATA

  IF	\CRSTOP		:IF STOPPING ON CONSECUTIVE CRASHES
    IF	CRSTOP
	CLH	R1,CRSHCT	:TEST IF FIRST TIME
	JE	ENTRY0		:IF FIRST TIME IN
	SIS	R0,1
	JLE	ENTRY0		:IF POWER FAILURE OR MANUAL RESTART
	LHL	R0,UPDOWN	:SET HOST DOWN
	OHI	R0,4000
	STH	R0,UPDOWN
	LHI	R0,0BADC
	STH	R0,FPANEL	:SET PANEL TO BAD CRASH
	LM	R0,CRREG	:RESTORE REGISTERS
	SVC	DISMISS,$A 900	:SLEEP FOR 15 MINUTES
	JBS	.-4		:CONTINUE DISMISSING FOREVER
    EI	CRSTOP
  EI	\CRSTOP


ENTRY0	SVC	1,FAIL		:INITIALIZE RESTART
	JAL	R10,CRASH	:NON-SKIP RETURN...CRASH

:	NOW RESET OUTPUT RING, REPORT CRASH
	LIS	R0,0
	ST	R0,ORING,,	:EMPTY OUTPUT RING
	ST	R0,IRING,,	:EMPTY INPUT RING
	JAL	R4,SPACE	:SET UP FOR DIAGNOSTIC
	LHI	R0,0300;	JAL	R4,PUTW,,	:PORT 0 + DIAGNOSTIC MESSAGE + PAD
	LHL	R0,CRSHCT;	JAL	R4,PUTH,,	:HW4 = CRASH COUNT
	LHL	R0,CRASHC;	JAL	R4,PUTH,,	:HW3 = CRASH CODE
	LIS	R0,1;		JAL	R4,PUTCH,,	:HW2 IS DIAGNOSTIC 1
	JAL	R4,ELOR,,	:END LOGICAL OUTPUT RECORD
	J	START,,		:NOW GO TO INITIALIZATION CODE
	EM

  EI		:ISIS2
 