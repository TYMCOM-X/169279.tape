::					Last updated by SCY, 04/04/85


:	******************************************************
:	*****        PATCH FILE FOR VERSION 02.02        *****
:	******************************************************

:	Refer to (NETMID:39)PATCH.DOC for details on implemen-
:	ting patches with PATCH.LIB.


:	>>>>>     START PATCHES HERE     <<<<<

  IF	TPIDS
PATCH(831018,1730,SCY,PCR500+6,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,14)
	L	R6,TEMP1,,	:Reload ring char count
	LIS	R0,0
	STB	R0,TEMP1,,	:Initially set no TID to use
	J	PCR500+0C,,
CONPATCH(PCR560-26,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,1C)
	LHL	R4,IPORT
	RBT	R4,TPAR2,,	:Reset bit for real mode
	LB	R0,TEMP1,,
	JE	PCR560+12,,	:Get CC to use as TID
	J	PCR560-16,,	:Else mask with C0
ENDPATCH(Fix a hang when the link has TPID set, but no protocol ID)
ENDPATCH(is received in the CUD)
 EI	TPIDS

PATCH(831024,0932,GML,PCR370-2E,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,12)
	STH	R0,TEMP2,,
	LHL	R1,FACBUF,,
	J	PCR370-28,,
ENDPATCH(Get facbuf pointer to process TC when no facilities in call request)

PATCH(831026,1200,SCY,ADDTC+0C,,0C)
	TBT	RL,TCN.F,,
	JER	R9		:IF NOT SUBSCRIBED TO TC NEGOTIATION
	AIS	R9,4
	JR	R9
ENDPATCH(Always sent throughput class if negotiation set)

PATCH(831028,0940,GML,NDLST2+52,,4)
	LHL	R1,EPORT
ENDPATCH(Correct port calculation for port availability check)

PATCH(831024,1830,JPM,ESC050+02C,,4)
	JN	ESC110
CONPATCH(ESD010+01C,,4)
	JN	ESD012
CONPATCH(PFRA00+08,,4)
	JN	PFAC52
ENDPATCH( Correct tests for passing national options to link )

   IF  DTARS
PATCH(831019,1200,JPM,CON050+01E,,06)
	J	PA1PTR,,
CONPATCH(PA1PTR,,012)
	OI	R7,AA.TCU!AA.DTC
	JAL	R9,GENRPT,,
	J	CON060,,
ENDPATCH( Correct masking for DATAPAC Tariff Class accounting report )
   EI  DTARS


PATCH(831019,1201,JPM,PCAN10+026,,04)
  IF	X.75
	JE	PCAN12-012
  ELSE	X.25
	JN	RTECA0
  EI	
ENDPATCH( Set RVCHRG bit for collect calls )

PATCH(831020,1130,JPM,CON010-024,,06)
	J	PA1PTR,,
CONPATCH(PA1PTR,,01C)
	TBT	RL,RCNA.F,,
	JE	CON010,,
	LHI	R0,AA.ERR
	STH	R0,TERMCD,,
	J	CON010-01A,,
ENDPATCH( Test Reverse Charge Acceptance before clearing collect call )

PATCH(830614,1240,SKW,CLD040+18,,6)
	J       PA1PTR,,
CONPATCH(PA1PTR,,2A)
	LHL     R1,DPORT
	LB      R0,ORGTID,R1,   :TEST FOR HALF DUPLEX TERMINAL
	THI     R0,20
	JE      CLD045          :IF NOT
	J       CLD050-2,,      :RETURN FOR HALF DUPLEX TERMINAL
CLD045  TBT     6,DETBL,,
	JE      CLD050-2,,      :TEST FOR ECHOABLE
	J       CLD040+20,,
ENDPATCH(Do not echo Called Address to Half Duplex Terminal)
          
PATCH(830614,1250,SKW,NERR20+0A,,6)
	J       PA1PTR,,
CONPATCH(PA1PTR,,2A)
	LHL     R1,DPORT
	LB      R0,ORGTID,R1,   :TEST FOR HALF DUPLEX TERMINAL
	THI     R0,20
	JE      NERR21          :IF NOT
	J       NERR20+2C,,     :RETURN FOR HALF DUPLEX TERMINAL
NERR21  TBT     R6,DETBL,,      :TEST IF ECHOABLE
	JE      NERR20+2C,,
	J       NERR20+12,,
ENDPATCH(Do not echo Invalid Called Address to Half Duplex Terminal )
          
PATCH(830614,1300,SKW,CGTU10+14,,6)
	J       PA1PTR,,
CONPATCH(PA1PTR,,2A)
	LHL     R1,DPORT
	LB      R0,ORGTID,R1,   :TEST FOR HALF DUPLEX TERMINAL
	THI     R0,20
	JE      CGTU15          :IF NOT
	J       CGTU10+36,,     :RETURN FOR HALF DUPLEX TERMINAL
CGTU15  TBT     R6,DETBL,,      :TEST IF ECHOABLE
	JE      CGTU10+36,,
	J       CGTU10+1C,,
ENDPATCH(Do not echo Call User Data to Half Duplex Terminal)

  IF	XOM
PATCH(831108,1707,GML,XOMNA0+6,,20)
	XOMTAP(NAC.F)		
	XOMTAP(NAP.F)
CONPATCH(XOMUN0+6,,20)
	XOMTAP(UNC.F)		
	XOMTAP(UNP.F)
CONPATCH(XOMBC0+6,,20)
	XOMTAP(BCC.F)		
	XOMTAP(BCP.F)
CONPATCH(XMCNAT,,0C)
	LA	R7,NAC.F,,	
	LA	R8,NAP.F,,
CONPATCH(XMCUNK,,0C)
	LA	R7,UNC.F,,	
	LA	R8,UNP.F,,
  IF	X.75
CONPATCH(XMCTRA,,0C)
	LA	R7,TRC.F,,	
	LA	R8,TRP.F,,
  EI
CONPATCH(XMCBCU,,0C)
	LA	R7,BCC.F,,	
	LA	R8,BCP.F,,
ENDPATCH(Reverse XOM handling of NATIONAL`, UNKNOWN`, TRAFFICLASS`, BCUG)
  EI	XOM

PATCH(831109,1653,GML,PSUBDA-12,,6)
	STB	R0,PSDIAS+1,,	:STORE DIAGNOSTIC
ENDPATCH(Store diagnostic in correct byte of PSDIAS)


PATCH(831102,1540,LLIN,ESP14,,20)
	RBT	R7,WTFLGB,,	:WHAT WE ARE DOING IS TO MOVE
	JN	ESD010		: AIS R5,1  DOWN AFTER WE HAVE
	RBT	R7,WTCNT1,,	:HAD THE FLAG AND LEN BYTES
	JN	ESD020		:SO WE CAN CALL ESD100 TO
	RBT	R7,WTCNT2,,	:COPY THE REST OF ISIS MESSAGE
	JN	ESD030		
	AIS	R5,1		:READY FOR ESD100 ROUTINE
CONPATCH(ESP14+34,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,20)
	SIS	R5,1		:IF NOT FOR ESD100 READJUST R5
	TBT	R7,QDSCD,,
	JN	ESD070,,
	RBT	R7,WTQMSG,,
	JN	ESD040,,
	J	ESP14+3E,,
CONPATCH(ESC325-4,,4)
	J	ESC310		:WE HAVE TO RESET WTCNT2
CONPATCH(ESC330+6,,4)
	JE	ESC350+0C	:WE DO NOT FETCH ISIS CHAR, AVOID TO
                                :SUBTRACTING 1 FROM R5
ENDPATCH(FIX TYPE 94 ESCAPED MESSAGE LENGTH COUNTER)

  IF	DDTDIA
PATCH(831111,1525,GML,FBSAM+6,,4)
	CLHI	R5,L.FSAM*2	:RANGE CHECK
ENDPATCH(Correct range check for diagnostic frame trace)
  EI	DDTDIA

PATCH(831121,1451,GML,PCR466+0C,,4)
	LHI	R0,$A11+X.25		:DO NOT INCLUDE PREFIX LENGTH IN BYTE COUNT YET
CONPATCH(PCR472+4,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,18)
	L	R12,BE,R1,		:GET POSITION OF BYTE COUNT
	ST	R12,TEMP7,,		:SAVE POSITION FOR LATER
	LHL	R12,IPORT,,
	J	PCR472+0A,,
CONPATCH(PCR472+18,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,60)
	LIS	R8,0			:INIT COUNTER FOR NETUSERPREFIX 
	LB	R0,LIP.LT,RL2,RL2 	:FIRST CHARACTER
	JE	PCR475			:BRANCH IF NULL CHARACTER
	JAL	R4,WCI,,
	AIS	R8,1			:BUMP PREFIX COUNT
	LB	R0,LIP.LT+1,RL2,RL2	:SECOND CHARACTER
	JE	PCR475			:BRANCH IF NULL CHARACTER
	JAL	R4,WCI,,
	AIS	R8,1			:BUMP PREFIX COUNT
	LB	R0,LIP.LT+2,RL2,RL2	:THIRD CHARACTER
	JE	PCR475			:BRANCH IF NULL CHARACTER
	JAL	R4,WCI,,
	AIS	R8,1			:BUMP PREFIX COUNT
	LB	R0,LIP.LT+3,RL2,RL2	:FOURTH CHARACTER
	JE	PCR475			:BRANCH IF NULL CHARACTER
	JAL	R4,WCI,,
	AIS	R8,1			:BUMP PREFIX COUNT
PCR475	L	R2,TEMP7,,		:GET POSITION OF BYTE COUNT
	LB	R0,,R2			:GET BYTE COUNT
	AR	R0,R8			:ADD IN PREFIX COUNT
	STB	R0,,R2			:UPDATE BYTE COUNT
	J	PCR473,,
ENDPATCH(Adjust username length when NETUSERPREFIX less than 4 digits)

PATCH(831122,1015,SCY,CRQ308,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,18)
	LIS	R7,0		:SIGNAL CALL REQUEST PACKET
	JAL	R9,ADPSWS,,	:ADD PS/WS FACILITY
	LHL	R9,IPORT	:RESTORE IPORT
	TBT	RL,TCN.F,,
	J	CRQ308+6,,
ENDPATCH(Add ps/ws facility in call request packet if subscribed to)
ENDPATCH(ps/ws negotiation)

PATCH(831122,1030,SCY,PCBA32-4,,4)
	J	PCBC34
ENDPATCH(Correct an illegal jump if WI = 1 & WR = 2)

  IF	X.75
PATCH(831122,1035,SCY,ADPSWS+1C,,16)
	J	ADPS10
	HC	0,0,0,0,0,0,0,0,0	:REPLACE WITH NOP
CONPATCH(ADPS30+18,,10)
	J	ADPS40
	HC	0,0,0,0,0,0	:REPLACE WITH NOP
ENDPATCH(Always send ps/ws if negotiation is set)
  EI	X.75

  IF	X.75
PATCH(831128,1030,SCY,CRF090+6,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,16)
	LHL	R2,IPORT
	TBT	R2,TCRCV,,	:TEST IF RCVD TPUT CLASS
	JN	CRF092,,
	J	CRF090+10,,
ENDPATCH(Avoid sending TCLTR twice into network utility field (8C))
  EI	X.75

PATCH(831129,1630,SCY,PCBN23+0A,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,10)
	LHL	R2,IPORT
	STH	R4,PSRCV,R2,R2	:STORE INTO POSITION
	J	PCBN23+10,,
ENDPATCH(Restore R2 from IPORT)

PATCH(831212,1419,GML,PCR520+0E,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,018)
	TBT	R2,GATWAY,,
	JN	PCR550,,	:IF GATEWAY CALL, DON'T ADD TERMINATOR
	TBT	R2,NTNCAL,,
	J	PCR520+14,,
CONPATCH(PCR525+08,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,18)
	SBT	R2,CUDUSD,,
	TBT	R2,GATWAY,,
	JN	PCR530,,	:IF GATEWAY CALL, DON'T ADD TERMINATOR
	J	PCR525+0E,,
CONPATCH(PCR578+6,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,18)
	TBT	R2,GATWAY,,
	JN	PCR620,,	:IF GATEWAY CALL, DON'T ADD TERMINATOR
	TBT	R2,NTNCAL,,
	J	PCR578+0C,,
CONPATCH(PCR620+2,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,18)
	TBT	R2,GATWAY,,
	JN	PCR640,,	:IF GATEWAY CALL, DON'T ADD TERMINATOR
	TBT	R2,NTNCAL,,
	J	PCR620+08,,
ENDPATCH( Correct tests for login usage to include GATEWAY option )

PATCH(840130,1400,LLIN,ESD049+6,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,0C)
	GL	ESD115		:END OF ISIS DATA MESSAGE SHALL
	SIS	R5,1		:JUMP TO ESD115 INSTEAD OF ESD120
	JE	ESD115		:R5 IS LENGTH OF ISIS DATA MSG.
	J	ESD050,,	:END OF DATA PACKET SHALL JUMP
CONPATCH(ESD050+16,,6)		:TO ESD120
	J	PA1PTR,,	:R6 IS LENGTH OF DATA PACKET
CONPATCH(PA1PTR,,0C)
	SIS	R5,1
	JE	ESD115
	J	ESD060,,
CONPATCH(ESD060+4,,12)
	JAL	R4,WCI,,	:MAKE SURE WE HAVE MORE DATA FOR
	SIS	R6,1		:THIS PACKET TO SET WTQPAR FLAG
	JLE	ESD120
	J	PA1PTR,,
CONPATCH(PA1PTR,,12)
	SBT	R7,WTQPAR,,	:WE HAVE MORE DATA FOR THIS PACKET
	SIS	R5,1
	JG	ESD050,,
	J	ESD115
CONPATCH(ESD100+6,,0C)
	JG	PA1PTR,,
	J	ESD115,,
CONPATCH(PA1PTR,,26)
	JAL	R4,GETCH,,		:GET CHAR. IN IRING
	JAL	R4,WCI,,		:WRITE IT IN DIBUFFER
	SIS	R6,1			:DECREMENT THE COUNTER
	J	ESD100,,
ESD115	STH	R6,DNCNT,R7,R7		:STORE THE COUNT OF REMAINING
	JAL	R4,ELIR,,		:DATA PACKET
	J	MMFRA,,			:GET THE REST OF ISIS MSG.
ENDPATCH(FIX BUG IN PROCESSING END OF ISIS DATA MESSAGE TYPE 94)

PATCH(840103,1500,ISW,PCA300,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,1C)
	LHL	R1,DPORT
	TBT	R1,TURKEY,,
	JN	PCA310+0C,,	:IF TURKEY, DON'T BOTHER WITH TPAD PARAMETERS
	LB	R0,TREF3,RL,	:OTHERWASE, SAME AS BEFORE
	J	PCA300+0A,,	:AND CONTINUE
ENDPATCH(FIX THE PREMATURE M-BIT DATA PACKET FORWARDING BUG)

  IF	X.25
PATCH(840118,1845,SCY,PCR370-28,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,12)
	LR 	R6,R6
	JN	PCR370-22,,	:GO TO GET FACILITY LENGTH
	LIS	R0,0		:MARK FACILITY LENGTH = 0
	LR	R7,R0		:COPY
	J	PCR370-6,,	:GO TO PROCESS FACILITY
ENDPATCH(Handle call request packets that contain no facility length)
  EI	X.25

PATCH(840111,0900,GML,CONTRK+3C,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,48)
	RBT	R2,INPROG,,
	JN	CONTRK+46,,
	CLHI	R9,3
	JLE	CON025,,	:IF NOT ENOUGH CHARACTERS TO CONTAIN A CUD
	LHL	R4,IPORT
	TBT	R4,GATWAY,,
	JE	CON025,,	:IF NOT GATEWAY CALL
	JAL	R4,GCI,,	:DISCARD GOUGING CHARACTER COUNT
	JAL	R4,GCI,,	:DISCARD GOUGING CHARACTER
	JAL	R4,GCI,,	:GET CUD LENGTH
	LR	R5,R0
	SIS	R9,3		:ADJUST CHARACTER COUNT BY CHARACTERS READ
	SR	R9,R5		:REDUCE CHARACTER COUNT BY CUD LENGTH
	JGE	CON015,,	:GO COPY CUD
	TRAP(R1,DB)		:CUD LENGTH GREATER THAN CONTENTS OF BUFFER
ENDPATCH(Pass CUD of GATEWAY call to non-turkeys)

	IF	TPIDS
PATCH(831220,1500,STUTZMAN,PCR550+4,,16)
	LHI	R4,TIDHST	:All we are doing is moving the test and jump
	TBT	R1,ITICAL,,	:of TPID.F below the test and jump of ITICAL.
	JEFS	PCR552		:This is necessary to make sure that TEMP1 is
	TBT	RL,TPID.F,,	:not garbage if a call was placed with a non-
	JNFS	PCR553		:CCITT protocol ID on a link with TPID set.
	NOPR	R4,R4		:Note that the Telenet protocol ID has the
				:first byte set specifying that it is CCITT
				:even though it is an aberration. Thus, ITICAL
				:will normally be set on Telenet PAD calls.
				:Also note that the symptom of this problem
				:is the sending of a request for psuedo needle
				:with TID of C0 (aux circuit?).  Without ISIS
				:aux circuit status, the dispatcher zaps us.
ENDPATCH(Fix call clear if receive non-CCITT protocol ID on Telenet PID link)
	EI

PATCH(840207,1556,DRE,ICRB+12,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,10)
	LHL	R4,IPORT
	TBT	R4,EXTCAL,,	:SEE IF EXTERNAL CALL
	J	ICRB+18,,
ENDPATCH(Index into EXTCAL by IPORT)

  IF	HDLC&(LAPB!LAP)
PATCH(840209,1146,GML,XROOM6,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,0C)
	LB	RSIP,PREPAG,RL,		:GET POINTER
	SLLS	RSIP,4
	J	4,R5
ENDPATCH(Initialize pointer into frame transmit table)
  EI	HDLC&(LAPB!LAP)

 IF	HCO.MX
PATCH(831108,1324,PSD,HCOST5+0E,,4)
        JN      HCOST0,0
ENDPATCH(Fix HOSTCOST when NUMSTEPS equals DPORTS)
 EI	HCO.MX

PATCH(840210,1602,GML,T1S300+10,T1S300+34)
	LB	RL,IL.MT,R2,
	CLHI	R2,NLINKS
	JL	T1S370
	LH	R1,ID.MT,R2,R2
	STH	R1,DPORT
	JLE	T1S310
	CLHI	R0,PSCALR
	JE	T1S430
ENDPATCH(Test for restart timeout before login and clear confirmation timeouts)
PATCH(840206,0940,GML,PA0PTR,,2*NDGRPS)
W.FCI	HS	NDGRPS		:FLAGS INDICATING WAITING TO FINISH INITIALIZATION
CONPATCH(LIM600+1E,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,12)
	SBT	R1,W.FCI,,	:INDICATE NEED TO GO THROUGH NDLST3
	TBT	R1,W.ITP,,
	J	LIM600+24,,
CONPATCH(NDLST3+4,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,18)
	LHL	R2,DPORT
	RBT	R2,W.FCI,,
	JER	R0		:IF ALL DONE WITH INITIALIZATION
	LHL	R1,BF,R1,
	J	NDLST3+0A,,
ENDPATCH(Fix PERR7 caused by indication of break received from host)

PATCH(830601,1520,JMC,PCBC40+6,,4)
        JAL     R13,PACKCH              :GET NEXT CHAR OF RPOA FACILITY
ENDPATCH(Correct wild branch during RPOA Facility decode)

PATCH(830601,1521,JMC,PCBC40+0E,,6)
        STB     R0,RPOA.R,R8,R8         :SAVE RPOA GATEWAY THIS IPORT
CONPATCH(PCBC40+1C,,6)
        STB     R0,RPOA.R+1,R8,R8       :SAVE 2ND BYTE RPOA GATEWAY NO.
ENDPATCH(Index into RPOA table by halfword)

        IF      FSTSLT
PATCH(830908,2050,JMC,PCAN13+4,,2)
        JEFS    PCAN13+0C
ENDPATCH(ALLOW FAST SELECT CALLS WITHOUT RESTRICTION)

PATCH(840214,1605,GML,REVFST,REVFST+0A)
	LHL	R4,IPORT	:GET IPORT FIRST
	THI	R0,RF.RC
	JEFS	REVF10
ENDPATCH(Get IPORT before checking incoming call for fast select)
        EI      FSTSLT

PATCH(840214,1412,GML,PA0PTR,,4)
RMBLBC	WS	1
CONPATCH(PSUB7C+3C,,6)
	L	R0,RMBLBC,,	:GET BYTE COUNT FROM RMKBLD
CONPATCH(RMBL10,,6)
	ST	R9,RMBLBC,,	:SAVE BYTE COUNT
ENDPATCH(Save byte count from RMKBLD without destroying BUFADR)

  IF	FSTSLT
    IF	X.25
PATCH(840216,1503,GML,TCLR22-0E,,2)
	JFS	TCLR22	:ACCEPT DATA IN CLEAR
    ELSE	X.75
PATCH(840216,1503,GML,TCLR25-0C,,4)
	NOP	,	:ACCEPT DATA IN CLEAR
    EI
ENDPATCH(Allow call accept with data to be followed by clear with data)
  EI	FSTSLT

  IF	HDLC&LAPB
PATCH(840216,1708,DRE,SDSINF+8,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,14)
	LIS	R5,0
	STB	R5,XPSTAT,RL,
	RBT	RL,BCKFLG,,	:LET BACKGROUND BACK IN
	J	SDSINF+0E,,
ENDPATCH(Let background bring packet level up after getting a DISC)
  EI	HDLC&LAPB

  IF	X.25
PATCH(840223,1113,GML,ESP176-4,,4)
	JE	ESP176+14	:GO ADJUST LENGTH
CONPATCH(ESP176+1A,,2)
	NOPR	,		:DO NOT INCLUDE UTILITY LENGTH FIELD
ENDPATCH(Calculate correct buffer byte count after processing extended clear) 
  EI	X.25

PATCH(840224,1200,LLIN,TRSE10+26,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,68)
	TBT	R7,CHLOGN,,	:SEE IF IN LOGIN MODE
	JN	RESESC		:IF IN LOGIN MODE
	SBT	R7,DFLUSH,,	:CONTINUNE FLUSHING FROM NET
	J	TRSE10+2C,,
RESESC	LHL	R1,DPORT	:WE WANT TO OUTPUT AN ESC TO
	LIS	R0,4		:GET THE PLEASE LOG IN PROMPT.
	LHL	R7,IPORT
	TBT	R7,NEWLOG,,	:SEE IF TALKING TO OUR SUP.
	JN	NLCESC		:IF SO OUTPUT AN ESC IN NLC.
DATESC	LIS	R2,1		:ELSE OUTPUT AN ESC AS DATA MSG
	JAL	R4,SLOR,,	:SO IT CAN PASS THE GATEWAY.
	LHI	R0,1B		:PUT ESC FOR OUTPUT
	JAL	R4,PUTCH,,
	JAL	R4,ELODR,,
	J	RTD020,,
NLCESC	LHI	R2,0B3		:OUTPUT AN ESC AS NLC TO GET 
	JAL	R4,SLOR,,	:PLEASE LOGIN PROMPT
	LHI	R0,1B
	JAL	R4,PUTCH,,
	JAL	R4,ELOR,,
	J	RTD020,,
ENDPATCH(SEND AN ESC WHEN ENCOUNTER RESET BEFORE LOGON COMPLETE)

:PATCH(840301,1655,GML,NEDCLR+12,,12)
:	J	PA1PTR,,
:	JAL	R4,LOOK,,
:	J	NEDCLX
:	NOPR	,
:CONPATCH(PA1PTR,,12)
:NEDLOJ	LHL	R0,NEDLO1,R7,R7
:	JE	NEDCL2,,
:	J	NEDCLR+18,,
:ENDPATCH(When clearing needle check first for needle already flushed)

PATCH(840306,1610,SCY,PCBC40,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,14)
	SIS	R7,2
	JL	RTECAL,,
	JAL	R4,WCI,,		:COPY RPOA PARAMETER CODE
	J	PCBC40+6,,
ENDPATCH(Put RPOA code "44" into facbuf before RPOA dnic)

PATCH(840306,1620,SCY,ESP18+0E,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,1A)
	JAL	R1,RPOLNK,,
	J	ESP18B		:HERE IF NO LINKS FOUND
	J	ESP18A,,	:HERE IF LINKS FOUND
ESP18B	LHI	R12,CNETCG^8!DIA179	:RCVD UNKNOWN RPOA
	J	ESPCLR,,		:CLEAR THE CALL
ENDPATCH(Clear the call if no link set for this RPOA rcvd)

 IF	LAPB
PATCH(840222,1146,DRE,SDSINF,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,10)
	RBT	RL,BCKFLG
	LIS	R5,XMSUAM
	STB	R5,XSSTAT,RL
	J	SDSINF+8,,
ENDPATCH(Make foreground wait until background has finished to accept SABM)
 EI	LAPB

 IF	LAP
PATCH(840222,1130,DRE,SSBARM,,10)
	RBT	RL,STARM	:RESET SEC TRYING TO ARM
	JE	RFG200		:IF NOT TRYING
	LHI	R5,XMSUA	:GET XMT UA INDEX
	STB	R5,XSSTAT,RL
ENDPATCH(Fix LAP responding to SARM too soon)
 EI	LAP

  IF	XOM
PATCH(840425,1100,GML,XMCH22,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,0E)
	JAL	R5,CHSTAT,,
	LIS	R12,3		:SET HOST TO GONE
	J	XMCH22+6,,
ENDPATCH(Declare host removed from HOSTS gone)

    IF	BSC!FML
    ELSE
PATCH(840509,1528,GML,XOMTRP-10,,6)
	LA	R1,LIDLTH,RL,RL	:INDEX BY HALFWORDS
ENDPATCH(Place XOM IDLELINE threshold change into array correctly)
    EI	BSC!FML
  EI	XOM

PATCH(840413,1030,DRE,GETC10+4,,8)
	SR	R4,RL
	LB	R0,TCT.LT-1,R3,R4
ENDPATCH(Compensate for incorrect dimension of TCT.LT table)

   IF XOM
     IF \XMCHC1
     PATCH(840403,1150,PSD,XMCHC1-4E,,6)
             J         PA1PTR,,
     CONPATCH(PA1PTR,,16)
             LIS       R0,7
             LIS       R1,0
             JAL       R9,XSUCCH,,
             LHL       R5,XOMPAR+6,,
             J         XMCHC1-40,,
     ENDPATCH(Allows changing hostcost in any state)
     EI \XMCHC1

     PATCH(840412,1616,PSD,XMCHPO,,6)
             J         PA1PTR,,
     CONPATCH(PA1PTR,,16)
             LIS       R0,4
             LIS       R1,0
             JAL       R9,XSUCCH,
             LIS       R3,2
             LHL       R5,XOMPAR+4,,
             J         XMCHPO+0E,,

     CONPATCH(XMCICN,,6)
             J         PA1PTR,,
     CONPATCH(PA1PTR,,0E)
             LIS       R0,4
             LIS       R1,0
             JAL       R9,XSUCCS,
             J         XMCICN+0A,,

     CONPATCH(XMCTCN,,6)
             J         PA1PTR,,
     CONPATCH(PA1PTR,,0E)
             LIS       R0,4
             LIS       R1,0
             JAL       R9,XSUCCS,
             J         XMCTCN+0A,,

     CONPATCH(XMCOCN,,6)
             J         PA1PTR,,
     CONPATCH(PA1PTR,,0E)
             LIS       R0,4
             LIS       R1,0
             JAL       R9,XSUCCS,
             J         XMCOCN+0A,,
     ENDPATCH(Allows changing hostportavailability, ICNL, TCNL & OCNL) 
     ENDPATCH(in any state)

      IF HCO.MX
PATCH(840613,1055,GML,XOMHS5+0E,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,10)
	LR	R7,RL
	SRLS	R7,1		:CONVERT TO BYTE INDEX
	LB	R0,CSO.HT,R7,
        J	XOMHS5+14,,
ENDPATCH(Corrects XOM display of host cost)
    HCO.MX
    EI XOM 

  IF	XOM&.GT.(DNI.MX,0)
PATCH(840612,1351,GML,XMCD10-0A,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,2E)
	CLB	R4,XOMNPS,,
	JG	CSEXOM,,
	LHL	R1,XOMPAR+6,,	:GET NEXT PARAMETER
	JE	MNEXOM,,	:DO NOT ALLOW ADDITION OF NODE 0
	J	XMCD10,,
CONPATCH(XMCD64-6,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,24)
	CR	R2,R4
	JN	XMCD64,,
	LHL	R4,NODTAB+2,R8,R8	:GET NEXT ENTRY
	JE	.+0E		:IF TERMINATOR
	THI	R4,8000
	JE	XMCD64,,	:IF DNIC 
	SIS	R1,2
	J	XMCD64,,
ENDPATCH(XOM DNICNODES modify does not allow addition of node 0 to list)
ENDPATCH(Also correct test for solitary node number removal)
  EI

PATCH(840709,1233,GML,PCBN22+8,,8)
	JAL	R8,PA1PTR,,
	NOPR	,
CONPATCH(PCBN23+2,,8)
	JAL	R8,PA1PTR,,
	NOPR	,
CONPATCH(PA1PTR,,38)
	LHI	R12,DIA066
	CLHI	R0,PSMAX
	JG	RTECA0,,
	CLHI	R0,PSMIN
	JL	RTECA0,,
	LR	R3,R0
	POWER2(R3,R4)
	LHL	R3,MST.LT,RL,RL
	LR	R2,R2
	JEFS	.+8
	LHL	R3,MSR.LT,RL,RL
	CR	R4,R3
	JLR	R8
	LR	R4,R3		:NEGOTIATE DOWN TO MAX PS
	JR	R8
ENDPATCH(Negotiate packet size down to max PS when call request received)

PATCH(840413,1230,DRE,PCAA22-4,,4)
	NOP	0,0
ENDPATCH(Use call request value of TC if negotation not set)

  IF	CUD.MX!XOM
PATCH(840717,1822,GML,CUDGTT+4,,6)
	LB	R2,CUD.LT+1,R1,	:INDEX INTO CUDSTRING TABLE BY LINE
ENDPATCH(Index into CUDSTRING table by line x 4)
  EI	CUD.MX!XOM

  IF	XOM
PATCH(840717,1825,GML,XMCCS2,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,28)
	LHL	R0,XOMPAR+4,,
	JN	CSEXOM,,
	LIS	R3,2
	JAL	R4,XMROTM,,
XMCCS9	LIS	R0,1		:SET CUD.FL ARRAY
XMCCS3	LA	R1,CUD.FL,,
	LR	R2,RL
	SRLS	R2,4		:GET LINE NUMBER BACK
	LIS	R3,0
	J	XMCCS4,,
CONPATCH(XMCCST+22,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,10)
	LHI	R0,CUD.UI
	JAL	R4,XMROTM,,
	LIS	R0,0		:RESET CUD.FL ARRAY
	J	XMCCS3
CONPATCH(XMCCS8+10,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,0A)
	JG	XMCCS8,,
	J	XMCCS9		:SET CUD.FL ARRAY
ENDPATCH(Set CUD.FL array accordingly when XOM changes CUDSTRING)
  EI	XOM

PATCH(840803,1312,GML,PA0PTR,,2*NDGRPS)
WIBMCA  HS      NDGRPS          :SPECIAL FLAG TO INDICATE WAITING FOR CALL ACCEPT
CONPATCH(DDONE+6,,6)
        J       PA1PTR,,
CONPATCH(PA1PTR,,12)
        ST      R9,DDRET,,
        RBT     R1,WIBMCA,,     :NOT WAITING FOR IBM CALL ACCEPT
        J       DDONE+0C,,
CONPATCH(TER040-0A,,6)
        J       PA1PTR,,
CONPATCH(PA1PTR,,12)
        SBT     R1,HLFDUP,,
        SBT     R1,WIBMCA,,     :WAITING FOR CALL ACCEPT
        J       TER050,,
CONPATCH(IGB020-8,,6)
        J PA1PTR,,
CONPATCH(PA1PTR,,1E)
        TBT     R1,WIBMCA,,     :SEE IF CALL ACCEPT RECEIVED YET
        JN      IGB020,,        :IF NOT, JUST SET GREEN BALL FLAG
        TBT     R1,IBMLOK,,
        JE      IGB030,,
        J       IGB020,,
CONPATCH(PCA310+6E,,6)
        J       PA1PTR,,
CONPATCH(PA1PTR,,36)
        LHL     R1,DPORT
        RBT     R1,WIBMCA,,     :NO LONGER WAITING FOR CALL ACCEPT
        RBT     R1,GRNBAL,,
        JE      IBMPAT          :IF NO GREEN BALL OUTSTANDING
        CTLMSG(GB)              :SEND GREEN BALL
IBMPAT  RBT     R7,TPAR2,,
        J       PCA310+74,,
ENDPATCH(Do not bounce green ball to 2741 until after Call Accept is sent)

PATCH(840820,1600,BPC,NST122+10,,4)
	NOP	0,0
ENDPATCH(save username for dialect 8081 ASCII data)

PATCH(840727,1730,BPC,GMEXP1+18,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,1C)
	CLHI	R0,ID.ASC&0FF
	JN	GMEXP1+20,,
	LHL	R0,LO7,,	:GET BYTE COUNT OF LEFTOVER MESSAGE
	JAL	R4,FLUSH,,	:TRASH REST OF MESSAGE
	J	GMEXP8,,	:CONTINUE ON
ENDPATCH(If ASCII dialect selection message has extra data, trash it)

PATCH(840509,2300,BPC,DAT130,,6)
        J       PA1PTR,,
CONPATCH(PA1PTR,,26)
        LB      R9,IL.MT,R9,    :GET LINK #
        CLHI    R9,0FF          :SEE IF LINK # ASSIGNED YET
        JE      CLR050,,        :NOT, CLEAR THE CALL
        J       DAT130+6,,      :RETURN
CLR050  LHI     R0,AA.NCA       
        LA      R9,NOCHAN,,
        J       NEDCLR,,
ENDPATCH(make sure link # assigned before see if in DEM)

PATCH(840605,1500,BPC,PA0PTR,,NDPORT*2)
        GL      NEDLO1
NEDLO1  HS      NDPORT
CONPATCH(NMPNR+14,,6)
        STH     R0,NEDLO1,,
CONPATCH(NDLSAV+14,,6)
        STH     R0,NEDLO1,R1,R1
CONPATCH(ESC350-0C,,6)
        STH     R4,NEDLO1,R7,R7
CONPATCH(ESC365-6,,6)
        STH     R4,NEDLO1,R7,R7
CONPATCH(NEDCLR+12,,12)
	J	PA1PTR,,
	JAL	R4,LOOK,,
	J	NEDCLX
	NOPR	,
CONPATCH(PA1PTR,,12)
	LHL	R0,NEDLO1,R7,R7
	JE	NEDCL2,,
	J	NEDCLR+18,,
ENDPATCH(cc=14 fix due to LO1 wiped out)
ENDPATCH(When clearing needle check first for needle already flushed)

PATCH(841112,1200,STF,LNKS10+0A,,0A)
	JFFO	R3,LNKS10+12	:look for higher links
	J	PA1PTR,,	:continue in patch area
	AIS	R4,1		:adjust selected link #
CONPATCH(PA1PTR,,18)
	L	R3,LNKSET,R1,R1	:if none, reload link flags
	JFFO	R3,LNKS13	:look for lowest link #
	L	R1,LIMSAV,,	:return for no link available
	J	0,R1
LNKS13	J	LNKS14,,	:back to normal code
ENDPATCH(Adjust selected link # when link rotation is in effect)

: This patch will obviate (not correct) a problem with all released interfaces
: prior to 3.01. For the interface to properly work  both this patch AND a
: modification to the slot command file is required.
: The variable PMPCNT defaults to 4, when this patch is applied the PMPCNT
: variable must be modified in the command file to 2x the expected value.
: Therefore if the default setting is desired then specify after the Ixx file,
:    8[PMPCNT:               
PATCH(850116,1500,FAK,GETPPA+6,,04)
	XHI	R2,0AAAA	:NEVER USE AN EVEN BLOCK 
  IF	8-PMPCNT
  WARN(Block allocation too low reassemble with 8[PMPCNT in COM file)
  EI
ENDPATCH(Force ODD block usage of PMP due to alignment problems)

  IF	X.25&CUGENA
PATCH(841115,1800,DRE,PCR372+14,,20)
	TBT	RL,CUO.F,,
	JN	PCR400		:IF OUTGOING CALLS ALLOWED, SEND ORDINARY CALL
	LB	R4,CUP.LT,RL,	:GET PREFERENTIAL CUG INDEX
	LR	R2,RL
	SLLS	R2,CUG.SC	:FORM INDEX INTO OUTGOING ACCESS ARRAY
	TBT	R4,OCB.F,R2,
	JEFS	PCR380		:IF OUTGOING ACCESS NOT BARRED
	LHI	R12,DIA182	:'OUTGOING ACCESS BARRED'
ENDPATCH(Make outgoing access apply if no CUG supplied)
  EI

PATCH(850208,1800,FAK,TER090-0A,,6)
	TBT	R2,DETBL,R1,
ENDPATCH(CORRECT LOGIC REGARDING THE ECHO OF ASCII ESC CHARACTERS)

PATCH(850227,1400,DRE,MCL050+28,,6)
	STB	R4,RTRYCN,R7,
ENDPATCH(fix wild store into x29 timers during clear)

PATCH(030485,1500,SCY,NDLST1,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,18)
	ST	R0,LIMSAV,,	:Resume original logic
	LHL	R1,DPORT	
	LIS 	R4,0
	STB	R4,DMSGLN,R1,	:Set byte count remaining in data msg to zero
	J	NDLST1+0A,,	:Return
ENDPATCH(Set up an initial value of zero in DMSGLN)

PATCH(850331,1800,DRE,CON040+4,,2)
	JFS	CON040+0E
  IF	CENALX
CONPATCH(CON042,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,1A)
	LHL	R1,DPORT
	TBT	R1,TURKEY	:TURKEY CALL ?
	JN	CON050,,	:YES, SKIP CANNED Q-BIT MESSAGES
	LHL	R1,IEDBUF
	LR	R5,R7
	J	CON042+6,,
  EI
ENDPATCH(Restore X3 parms on all calls, but don't do L1ENABLE stuff if turkey)

PATCH(850321,1800,DRE,CON040+18,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,1E)
	LB	R0,WFR.NO,R5,	:ARE THERE ANY REMAINING COMANDS OUT THERE
	JN	CON041+50,,	:YES, SKIP THIS PROCESSING
	TBT	R1,ITP.4,,	:is the original state off
	JE	CON041,,	:yes, skip this message
	J	CON040+22,,	:CONTINUE NORMAL PROCESSING
ENDPATCH(Don't not try to restore PAD params after TKSUP if none were received)


PATCH(840413,1230,DRE,ESC050+26,,0A)
:	this patch and the one at esd010+16 wil normally skip around
:	this code to strip national pad parameters.  It does not work
:	at all if the pad parameters come in as M-bit iix
:	messages. A much larger fix is needed.  If someone really needs
:	this code then the BCUG(CLEAR) statement (which is not used now)
:	will turn on this code.
	TBT	RL,BCC.F,,
	JE	ESC110
ENDPATCH(Eliminate bad test against call processing national facility flag)


PATCH(840413,1230,DRE,ESD010+16,,0A)
	TBT	RL,BCC.F,,
	JE	ESD012
ENDPATCH(Eliminate bad test against call processing national facility flag)

::	PATCH TO GIVE DIAGNOSTIC FIELD IN ALL RESTART INDICATION PACKETS
::	FOR ALL LINKS DECLARED AS DCE [ psadr(03,01) ] IN X.25 AS WELL
::	AS X.75 SLOTS.

	IF	X.25
PATCH(850128,1630,PMJ,PSUBB+4,,6)
	J	PA1PTR,,		: JUMP TO PATCH AREA
CONPATCH(PA1PTR,,22)			: 22 OCTETS LONG
	SBT	RL,RMCAUS,,		: INDICATE CAUSE FIELD PRESENCE
	LB	R9,PADRT,RL,		: GET FRAME ADDR. FOR LINK
	CHI	R9,1			: SEE IF L.O.G DECLARED AS DTE
	JE	PSUBB+0A,,		: IF DTE, GIVE NO DIAGNOSTIC
	SBT	RL,RMDIAG,,		: L.O.G=DCE,GIVE DIAGNOSTIC
	J	PSUBB+0A,,		: JUMP BACK TO SOURCE
ENDPATCH(Give a diagnostic in Restart Ind. for X.25 as well as X.75)
	EI 	X.25

:	The problem of of incorrect calling address in accounting record
:	was due to the LO4 & LO5 being destroyed by the second needle
:	received before the 1st circuit was established.
:	This patch is to allocate two new storage array, LO4TMP & LO5TMP,
:	to store the orig. node # & orig. port # indexed by its DPORT.
:	A permenant fix will redefine LO4 & LO5 to be multiple storage array
:	instead of single storage and be put into next beta release of 3.02
:	and beyond.

PATCH(850402,1500,SCY,PA0PTR,,NDPORT*4)
LO4TMP	HS	NDPORT		:DEFINE NEW MULTIPLE STORAGE FOR ORIG. NODE #
LO5TMP	HS	NDPORT		:DEFINE NEW MULTIPLE STORAGE FOR ORIG. PORT #
CONPATCH(NDLSAV+38,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,12)
	STH	R0,LO4,,
	STH	R0,LO4TMP,R1,R1 :SAVE ORIGINATING NODE # INDEX BY ITS DPORT
	J	NDLSAV+3E,,
CONPATCH(NSAV04+10,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,12)
	STH	R0,LO5,,
	STH	R0,LO5TMP,R1,R1 :SAVE ORIGINATION PORT # INDEX BY IT DPORT
	J	NSAV04+16,,
CONPATCH(BCLG40+0A,,6)
	J	PA1PTR,,
CONPATCH(PA1PTR,,10)
	LHL	R6,DPORT
	LHL	R0,LO4TMP,R6,R6	:GET ORIGINATING NODE #
	J	BCLG40+10,,
CONPATCH(BCLG40+1C,,6)
	LHL	R0,LO5TMP,R6,R6	:GET ORIG. PORT #
ENDPATCH(Fixed the problem of wrong calling address in accounting record)
:**** end of patch area*****************************************************

 PATCHREPORT			:REPORT BYTES OF PATCH AREAS USED
 FINPATCH			:MAKE FINAL REPORT ON SEGMENT USAGE
\@yÈ