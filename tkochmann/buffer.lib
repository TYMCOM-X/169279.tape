	SUBTTL	GCI/WCI Buffer Package
:************************************************************************
:
:	This program is the sole property and confidential
:	information of TYMSHARE, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of TYMSHARE.
:
:************************************************************************
	RA	0		:	BUFFER.LIB

:	This package contains all code and storage allocation needed for
:	bufferlet usage.
:	If the symbol BUFTRC is defined and has a value greater than 0,
:	then a trace of all GCI and WCI calls will be included and
:	HISX will be a halfword pointer into a table HISTAB.
:	HISTAB will contain 100 one word entries.  Each entry contains
:	a one byte character, one byte of buffer number, and a halfword
:	address of the caller of GCI/WCI.  The table is circular.

:	the following parameters MUST be defined before assembly:
:	NBUF	the number of buffers to create
:	NBFLET	the number of bufferlets to create
:
:	THE FOLLOWING SYMBOL MAY BE DEFINED. IF IT IS NOT THE DEFAULT
:	IS FALSE.
:	UABUFF	IF TRUE (>1) THEN THE USER WILL ALLOCATE THE BUFFERLET
:		POOL BUFER.

:	uses routines in TIMOUT.LIB - - - requires one timeout list entry

:	may JAL R10,CRASH on certain conditions

:	Each routine is called with:
:	Link on R4
:	R0 = argument
:	R1 = buffer index (buffer number*2)

:	routines:
:	IZBF	link on R5, used to initialize buffers
:	GCI	get a character from buffer
:	WCI	write a character into buffer
:	WCD	back up a buffer to restore last character
:	EMPTY	empty (flush) buffer

:	buffer index may be used to index into the following halfword arrays
:	from external routines:
:	BF	buffer flags
:	BB	buffer start address
:	BE	buffer end address
:	BCT	buffer counts

:	the following should also be defined externally:
:	FLAGS	a bit array of length corresponding to max buffer flag value
:
:	If the macro ZAPBUF is defined then the code in the macro will
:	be executed whenever CKBZ is forced to zap a buffer. The code
:	will be executed immediately following the call to EMPTY
:	(R1 will contain the buffer index).  The first line of the macro
:	must be "ZAPBUF MACRO [.X" (where X may be a carriage return
:	or semicolon).


	GL	NBUF,NBFLET,BUFTRC,UABUFF
  IF	\BUFTRC
  ELSE
BUFTRC	EQ	0
	REMARK	%*** Define BUFTRC EQ 1 if debug trace desired
  EI

 IF	\UABUFF
 ELSE
UABUFF	EQ	0	:BUFFERLET POOL IS NOT USER ALLOCATED
 EI

	MO	.,BUFFER
	GL	FASTC,TORET,TOPUT,RATE,FLAGS,CRASH
	GL	BF,BCT,BB,BE
	GL	IZBF,GCI,WCI,WCD,EMPTY,GCPEEK,GCSCAN,MCI

:	THE DATA FOR THESE ROUTINES
	SEG	A.DATA		:PLACE IN DATA AREA
REBL	HC	0		:FREE LIST POINTER FOR RESERVE STORAGE LIST
REBC1	HC	0		:COUNTS TIMES BUFFER STORAGE WAS MOVED TO MAIN FREE LIST
REBC2	HC	0		:COUNTS TOTAL NUMBER OF BUFFER ZAPS
BFZ	HC	-1		:LAST BUFFER ZAPPED

BF	HS	NBUF		:BUFFER FLAGS
BCT	HS	NBUF		:BUFFER COUNTS
BB	HS	NBUF		:BUFFER START ADDRESS
BE	HS	NBUF		:BUFFER END ADDRESS

  IF	BUFTRC
	GL	HISX,HISTAB
HISX	HC	0		:INDEX FOR HISTORY
HISTAB	HS	200		:HISTORY DATA...400 BYTES...100 HISTORY ENTRIES
  EI



:	CODE SECTION
	SEG	A.CODE		:PLACE IN CODE ARAEA

:	INITIALIZE BUFFERS
IZBF	LIS	R0,0		:SET A CONSTANT
	LHI	R1,NBUF*2-2	:FOR ALL BUFFERS
IZBF1	STH	R0,BCT,R1	:SET EMPTY
	LHL	R2,BF,R1
	RBT	R2,FLAGS	:TURN OFF FLAG BIT
	SIS	R1,2
	JGEBS	IZBF1
	LHI	R1,NBFLET*8	:FOR ALL BUFERLETS
	STH	R0,BUFERS,R1,	:TERMINATE LIST
IZBF2	STH	R1,BUFERS-8,R1,	:LINK LAST TO THIS
	STH	R0,BUFERS-6,R1,	:CLEAR DATA AREA
	ST	R0,BUFERS-4,R1,
	SIS	R1,8
	JGBS	IZBF2		:REPEAT FOR ALL BUFFERLETS
	STH	R0,REBL		:SET SPARE TANK EMPTY
	L	R1,FASTC,,
	LHI	R1,RATE/$A25,R1	:CALL EVERY 40 MS.
	LA	R0,CKBZ		:PUT BUFFER CHECKING LOGIN ON QUEUE
	J	TOPUT		:EXIT VIA TIMEOUT LIST ENTRY
:	CHARACTER HANDLERS. THESE ROUTINES PASS BFR CHR IN R0,
:	R1 FOR TWICE THE BUFFER NUMBER, R2,R3 FOR WORKING REGISTERS,
:	R4 IS LINK REGISTER.

:	GET CHAR FROM BUFFER AND INCREMENT FORWARD THRU THE BUFFER.
GCICRA	JAL	R10,CRASH;	BC	0,0,4*R4,3	:FLAG--LINK R4, TYPE 3
GCI	CLHI	R1,2*NBUF	:RANGE CHECK ON BUFFER NUMBER
	JGEBS	GCICRA		:BUFFER NUMBER OUT OF RANGE...CRASH
	LHL	R2,BB,R1	:GOOD BUFFER...GET INDEX TO CHARACTER
	LB	R0,BUFERS,R2,	:PICK UP CHAR
	LHL	R3,BCT,R1
	SIS	R3,1      	:REDUCE COUNT OF CHARS IN BUFFER
        STH     R3,BCT,R1
	JLE	GCILAS		:SKIP IF NO CHARACTERS LEFT
	AIS	R2,1		:ELSE INCREMENT BB VALUE
	THI	R2,7		:TEST IF AT END OF BUFFERLET
	JEFS	GCI1		:RETURN BUFFERLET TO FREE LIST IF SO
	STH	R2,BB,R1	:ELSE UPDATE BB
  IF	BUFTRC
	J	HIST		:AND RETURN WITH THE CHAR
  ELSE
	JR	R4		:AND RETURN WITH THE CHAR
  EI

GCI1	LHL	R3,BUFERS,R2,	:BUFFERLET EXHAUSTED
	SIS	R3,6		:CHAIN TO NEXT BUFFERLET
	STH	R3,BB,R1	:SET BB TO START OF NEXT BUFFERLET
	LHL	R3,BUFERS,,	:GET POINTER TO FREE LIST
	STH	R3,BUFERS,R2,	:LINK LAST BUFFERLET TO FREE LIST
	STH	R2,BUFERS,,	:AND PUT AT THE HEAD OF THE FREE LIST
  IF	BUFTRC
	J	HIST		:THEN EXIT
  ELSE
	JR	R4		:THEN EXIT
  EI

GCILAS	JL	GCICRA		:CRASH IF BUFFER WAS EMPTY
	LHL	R3,BF,R1	:OK...GET POINTER TO FLAG BIT
	RBT	R3,FLAGS	:RESET ATTENTION FLAG
	AIS	R2,6		:BUMP CHARACTER POINTER PAST END OF BUFFERLET
	NHI	R2,-8		:MAKE CHAIN A MULTIPLE OF 8
	LHL	R3,BUFERS,,
	STH	R3,BUFERS,R2,
	STH	R2,BUFERS,,	:UPDATE FREE LIST
  IF	BUFTRC
	J	HIST
  ELSE
	JR	R4
  EI

:	PUT A CHARACTER INTO THE BUFFER
WCI	CLHI	R1,2*NBUF	:RANGE CHECK ON BUFFER NUMBER
	JLFS	WCI1		:SKIP IF OK
WCICRA	JAL	R10,CRASH	:ELSE CRASH
	BC	0,0,4*R4,5	:FLAG--LINK R4, TYPE 5 CRASH

WCI1	LHL	R2,BCT,R1	:CHECK COUNT
	JE	WCIFRS		:IF NEW BUFFER, SET UP ATTENTION FLAGS
	AIS	R2,1		:ELSE UPDATE COUNT
	STH	R2,BCT,R1
	LHL	R2,BE,R1	:GET POINTER TO LAST CHARACTER POSITION
	AIS	R2,1		:BUMP POINTER
	THI	R2,7		:TEST IF BUFFERLET FULL
	JEFS	WCINXB		:END OF BUFFERLET
	STH	R2,BE,R1	:ELSE UPDATE BE
	STB	R0,BUFERS,R2,	:AND SAVE CHAR IN BUFFER
  IF	BUFTRC
	J	HIST
  ELSE
	JR	R4
  EI

WCINXB	LHL	R3,BUFERS,,	:NEED A NEW BUFFERLET
	JNFS	WCINXC		:SKIP IF THERE IS ANOTHER
	JAL	R2,WRE		:(OPEN THE RESERVE TANK)
	LHL	R2,BE,R1	:RESTORE R2
	AIS	R2,1
WCINXC	STH	R3,BUFERS,R2,	:LINK NEW BUFFERLET TO LAST ONE
	LHL	R2,BUFERS,R3,	:AND REMOVE FROM FREE LIST
	STH	R2,BUFERS,,
	SIS	R3,6		:BACK UP NEW BUFFERLET
	STH	R3,BE,R1	:SAVE AS NEW BE
	STB	R0,BUFERS,R3,	:PUT THE CHARACTER THERE
  IF	BUFTRC
	J	HIST
  ELSE
	JR	R4
  EI

WCIFRS	LH	R2,BF,R1	:THE BUFFER WAS EMPTY
  IF	BUFTRC
	JE	HIST		:TOSS CHAR, DONT WASTE SPACE ON UNASSIGNED BFR
  ELSE
	JER	R4		:TOSS CHAR, DONT WASTE SPACE ON UNASSIGNED BFR
  EI
	SBT	R2,FLAGS	:ATTENTION BIT ON TO ALERT SOME PROCESS OF DATA WAITING
	LIS	R2,1
	STH	R2,BCT,R1	:SET COUNT = 1
	LHL	R3,BUFERS,,	:POP A BUFFERLET OFF FREE LIST
	JGFS	.+6		:SKIP IF THERE WAS ONE
	JAL	R2,WRE		:ELSE OPEN THE RESERVE TANK
	LHL	R2,BUFERS,R3,
	STH	R2,BUFERS,,	:UPDATE FREE LIST
	SIS	R3,6		:POINT IT AT FIRST CHARACTER
	STH	R3,BB,R1	:SET UP BB
	STH	R3,BE,R1	:AND BE
	STB	R0,BUFERS,R3,	:PUT THE CHARACTER THERE
  IF	BUFTRC
	J	HIST
  ELSE
	JR	R4
  EI

:	MOVE RESERVE STORAGE SUPPLY TO MAIN FREE LIST
WRE	LHL	R3,REBL		:GET POINTER TO RESERVE BUFFERLETS
	EXHR	R3,R3
	STH	R3,REBL		:SET RESERVE BUFFERLETS EMPTY (=0)
	EXHR	R3,R3
	JNR	R2		:IF IT WASN'T EMPTY, RETURN
	JAL	R10,CRASH	:BUG, UNREASONABLY FAST STORAGE DRAIN
	BC	0,0,4*R4,6	:FLAG--LINK R4, TYPE 6

  IF	BUFTRC
:	UPDATE HISTORY (TRACE) AFTER EVERY BUFFER OPERATION
HIST	LH	R3,HISX		:GET HISTORY RING INDEX
	AIS	R3,4		:BUMP TO NEXT ENTRY
	NHI	R3,3FF		:ACCOUNT FOR FOLDING
	STH	R3,HISX		:SAVE IT AGAIN
	STB	R0,HISTAB,R3	:ENTRY (0) = CHARACTER
	LR	R2,R1
	SRHLS	R2,1		:COMPUTE BUFFER #
	STB	R2,HISTAB+1,R3	:ENTRY (1) = PORT #
	STH	R4,HISTAB+2,R3	:ENTRY (2, 3) = LOCATION WHERE CHAR PLACED
	JR	R4
  EI	(BUFTRC)

:	PEEK AT FIRST CHAR OF BUFFER
GCPCRA	JAL	R10,CRASH;	BC	0,0,4*R4,6	:CRASH TYPE 6
GCPEEK	CLHI	R1,2*NBUF	:RANGE CHECK
	JGEBS	GCPCRA
	LHL	R2,BB,R1	:GET POINTER TO START OF BUFFER DATA
	LHL	R3,BCT,R1	:GET COUNT OF CHARS THERE
	JFS	GCS		:AND SKIP

:	SCAN SUCESSIVE CHARACTERS IN BUFFER
GCSCAN	CLHI	R1,2*NBUF	:RANGE CHECK
	JGEBS	GCPCRA
GCS	SIS	R3,1
	JL	GCPCRA		:CRASH IF NO MORE CHARACTERS THERE
	LB	R0,BUFERS,R2,	:ELSE GET CHAR
	AIS	R2,1		:BUMP POINTER FOR NEXT TIME
	THI	R2,7
	JNR	R4		:EXIT IF NOT AT END OF BUFFERLET
	LHL	R2,BUFERS,R2,	:ELSE ADVANCE TO NEXT BUFFERLET
	SIS	R2,6		:POINT AT START
	JR	R4

:	MCI - MOVE ALL CHARACTERS FROM SOURCE TO DESTINATION BUFFER
:	R5 = SOURCE BUFFER INDEX
:	R6 = DESTINATION BUFFER INDEX
:	R7 = LINK
MCICRA	JAL	R10,CRASH
	BC	0,0,4*R7,4	:FLAG--LINK R7, TYPE 4
MCI	CLHI	R5,2*NBUF
	JGBS	MCICRA		:RANGE CHECK ON SOURCE
	CLHI	R6,2*NBUF
	JGBS	MCICRA		:RANGE CHECK ON DESTINATION
	LHL	R0,BCT,R5	:CHECK SOURCE
	JER	R7		:EXIT IF EMPTY
	LHL	R1,BF,R6	:SET DESTINATION FLAG
	JNFS	MCI1		:FLAG = 0 IS BIT BUCKET
	LR	R1,R5		:THEN JUST EMPTY BUFFERS
	LR	R4,R7
	J	EMPTY
MCI1	SBT	R1,FLAGS	:SET THE FLAG
	JNFS	MCI2		:NOT EMPTY...GO APPEND
	LHL	R0,BB,R5	:EMPTY...COPY BUFFER START
	STH	R0,BB,R6
	J	MCI4		:AND SKIP TO FINISH TRANSFER OF DATA
MCI2	LHL	R1,BE,R6	:CHECK DESTINATION
	AIS	R1,1		:IS IT AT END OF BUFFERLET?
	THI	R1,7
	JNFS	MCI3		:SKIP IF NOT
	LHL	R2,BB,R5	:YES...IS SOURCE ON BUFFERLET BOUNDARY?
	AIS	R2,6
	THI	R2,7
	JNFS	MCI3		:SKIP IF NOT
	STH	R2,BUFERS,R1,	:ELSE APPEND SOURCE TO DESTINATION
	JFS	MCI4		:AND SKIP
MCI3	LR	R1,R5		:MOVE A CHAR
	JAL	R4,GCI
	LR	R1,R6
	JAL	R4,WCI
	LHL	R0,BCT,R5	:CHECK SOURCE
	JG	MCI2		:LOOP IF NOT EMPTY
	JR	R7		:ELSE RETURN
MCI4	LHL	R0,BE,R5
	STH	R0,BE,R6	:UPDATE BUFFER END
	LHL	R0,BCT,R5
        LHL     R1,BCT,R6
        AR      R0,R1
	STH	R0,BCT,R6	:UPDATE COUNT
	LIS	R0,0
	STH	R0,BCT,R5	:CLEAR SOURCE BUFFER
	LHL	R1,BF,R5
	RBT	R1,FLAGS	:TURN OFF SOURCE FLAG
	JR	R7		:AND EXIT

:	BACK UP A BUFFER TO RESTORE LAST CHAR
WCD	LHL	R2,BCT,R1	:PICK UP COUNT
	JE	WCDZ		:BFR IS EMPTY BUT OLD CHAR IS STILL AROUND
	AIS	R2,1		:ELSE UPDATE COUNT
	STH	R2,BCT,R1
	LHL	R2,BB,R1	:BACK UP BB
	SIS	R2,1
	STH	R2,BB,R1
	AIS	R2,7		:TEST IF BACKED OVER BEGINNING OF BUFFERLET
	THI	R2,7
	JNR	R4		:EXIT IF NOT
	LHL	R3,BUFERS,,	:ELSE GET LAST ENTRY FROM FREE LIST
	LHL	R0,BUFERS,R3,
	STH	R0,BUFERS,,
	STH	R2,BUFERS,R3,	:LINK NEW FIRST ENTRY TO OLD FIRST
	SIS	R3,1
	STH	R3,BB,R1	:SET NEW ENTRY INTO BB
	JR	R4

WCDZ	LHL	R2,BUFERS,,	:HERE WITH BUFFER EMPTY (BB IS OK)
	LHL	R3,BUFERS,R2,
	STH	R3,BUFERS,,	:FIXUP FREE LIST
	LHL	R2,BF,R1
	SBT	R2,FLAGS	:SET NONEMPTY BFR ATTENTION FLAG
	LIS	R2,1
	STH	R2,BCT,R1	:SET COUNT = 1 CHARACTER
	JR	R4

:	RETURN ALL THE SPACE USED BY THE BUFFER
EMPTY	CLHI	R1,2*NBUF	:RANGE CHECK ON BUFFER NUMBER
	JLFS	C1		:BFR ARGUMENT ACCEPTED
	JAL	R10,CRASH	:BFR ARG OUT OF RANGE
	BC	0,0,4*R4,0D	:FLAG--LINK R4, TYPE 13d

C1	LHL	R2,BCT,R1	:CHECK CONTENTS
	JER	R4		:EXIT...BUFFER EMPTY
	LIS	R2,0
	STH	R2,BCT,R1	:NOT EMPTY...SET COUNT = 0
	LHL	R2,BB,R1	:POINTER TO FIRST CHAR IN BUFFER
	AIS	R2,6
	NHI	R2,-8
	LHL	R3,BUFERS,,	:GET POINTER TO FREE LIST
	STH	R2,BUFERS,,	:PUT THE BUFFERS BUFFERLETS ONTO FREE LIST
	LHL	R2,BE,R1	:GET POINTER TO LAST CHARACTER IN BUFFER
	AIS	R2,6		:LOCATE THE POINTER IN THIS BUFFERLET
	NHI	R2,-8
	STH	R3,BUFERS,R2,	:CHAIN PREVIOUS FREE LIST TO THIS BUFFERLET
	LH	R2,BF,R1
	RBT	R2,FLAGS	:SET FLAGS TO EMPTY BUFFER
	JR	R4		:AND RETURN

:	SEE IF WE MUST ZAP BFRS BECAUSE BFR STORAGE RUNNING LOW
CKBZ	LHI	R1,RATE/$A25,R1	:SET TIMER FOR NEXT CALL
	JAL	R5,TOPUT	:RUN 25 TIMES PER SECOND
	LH	R1,REBL		:ARE WE ON THE RESERVE TANK?
	JN	TORET		:PLENTY OF BFR STORAGE. DONT ZAP BFRS

:	WCI GRABBED RESERVE BFR FREE LIST AND MOVED IT TO MAIN FREE LIST.
:	REFILL FREE LIST WITH 1/8 OF TOTAL BFR STORAGE. ZAP BFRS IF NECESSARY.
	LIS	R0,1
	AHM	R0,REBC1	:STATISTIC
REB1	LIS	R2,0		:INITIAL POINTER IS TO START OF FREE LIST
	LA	R1,NBFLET/8	:SCAN MAIN FREE LIST FOR 1/8 FREE STORAGE

REB2	LHL	R2,BUFERS,R2,	:GET NEXT BUFFER ON FREE LIST
	JE	REBZ		:NOT ENOUGH SPARE SPACE. ZAP A BFR
	SIS	R1,1		:GOT ANOTHER...COUNT IT
	JGBS	REB2		:GO UNTIL WE'VE GOT ENOUGH
	LHL	R3,BUFERS,,	:DONE...SEPERATE FREE LIST INTO TWO PARTS
	STH	R3,REBL		:BEGINNING OF THE RESERVE LIST
	LHL	R4,BUFERS,R2,,
	STH	R4,BUFERS,,	:BEGINNING OF MAIN LIST
	STH	R1,BUFERS,R2,,	:DEATH'S BRIGHT ANGEL AT END OF SPARE LIST (=0)
	J	TORET

:	ZAP A BFR IN ORDER TO GET RESERVE TANK UP TO 1/8 OF TOTAL BFR STORAGE
REBZ	LHI	R1,NBUF*2-2	:BCT INDEX
	LIS	R7,0		:BCT CONTENTS OF LARGEST BFR
REBZ1	LHL	R0,BCT,R1
	CLR	R7,R0
	JGEFS	.+6
	LR	R7,R0
	LR	R8,R1
	SIS	R1,2
	JGEBS	REBZ1
	LIS	R0,1
	AHM	R0,REBC2
	STH	R8,BFZ		:STATISTICS
	LR	R1,R8		:ZAP BIGGEST BUFFER FOUND
	JAL	R4,EMPTY	:RETRIEVE STORAGE
  IF	\ZAPBUF : ZAPBUF WILL EXPAND INTO MACRO CALL IF DEFINED,
  EI		:ELSE THIS IS A NOOP
	LIS	R0,9
	JAL	R4,ROOM		:WE WANT TO SEND A 9-BYTE MESSAGE
	LHI	R0,0300		:SPECIAL MESSAGE TYPE 3...
	JAL	R4,PUTW		:SEND DIAGNOSTIC TO SUP
	LR	R0,R7
	JAL	R4,PUTH		:HW4 = CHAR COUNT
	LR	R0,R8
	SRHLS	R0,1
	JAL	R4,PUTH		:HW3 = BUFFER NUMBER
	LIS	R0,0
	JAL	R4,PUTCH	:HW2 = 0
	JAL	R4,ELOR		:END LOGICAL OUTPUT RECORD
	J	REB1		:TRY AGAIN TO FILL RESERVE STORAGE LIST


 IF	UABUFF
 ELSE
:	BUFFER SEGMENT
	SEG	A.BUFF		:BUFFERLETS IN BUFFER AREA
BUFERS	HS	4*NBFLET+1	:THE STORAGE FOR THE BUFFERLETS
 EI
	EM
   