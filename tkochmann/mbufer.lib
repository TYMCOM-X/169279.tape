	SUBTTL	GCI/WCI Buffer Package - Microcode version
        REMARK %MBUFER 08-23-84, AWT
:************************************************************************
:
:	This program is the sole property and confidential
:	information of TYMSHARE, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of TYMSHARE.
:
:************************************************************************
	RA	0		:	MBUFER.LIB
:
:	Version 0.02 Changed the supervisor's log message to report 
:		the PRODID.  Sep 20 '82 SCY
:	Version 0.01 Delete WCD routine as suggested by J Kopf and
:		M Rude. In general this cannot work with the microcode
:		bufferlets. Jan 21 '81 M D Stimac

:	Note that due to register usage, this library package is
:	incompatible with the CBCT machine instruction. This is not
:	a problem, though, because it is not necessary to use CBCT
:	if you are using MBUFER.LIB .

:	This package contains all code and storage allocation needed for
:	bufferlet usage.
:	If the symbol BUFTRC is defined and has a value greater than 0,
:	then a trace of all GCI and WCI calls will be included and
:	HISX will be a halfword pointer into a table HISTAB.
:	HISTAB will contain 100 one word entries.  Each entry contains
:	a one byte character, one byte of buffer number, and a halfword
:	address of the caller of GCI/WCI.  The table is circular.

:	the following parameters MUST be defined before assembly:
:	NBUF	the number of buffers to create
:	NBFLET	the number of bufferlets to create
:
:	The following symbol may be defined. If it is not defined the
:	default is FALSE.
:		UABUFF  If TRUE (>0) then the user will allocate the
:			bufferlet pool.

:	uses routines in TIMOUT.LIB - - - requires one timeout list entry

:	may JAL R10,CRASH on certain conditions

:	Each routine is called with:
:	Link on R4
:	R0 = argument
:	R1 = buffer index (buffer number*4)

:	routines:
:	IZBF	link on R5, used to initialize buffers
:	GCI	get a character from buffer
:	WCI	write a character into buffer
:	EMPTY	empty (flush) buffer

:	buffer index may be used to index into the following fullword arrays
:	from external routines:
:	BF	buffer flags
:	BB	buffer start address
:	BE	buffer end address
:	BCT	buffer counts

:	Note: The BCT array consists of halfwords stored on
:		fullword boundaries.  (This was done because
:		halfword instructions are faster.)

:	the following should also be defined externally:
:	FLAGS	a bit array of length corresponding to max buffer flag value
:
:	If the macro ZAPBUF is defined then the code in the macro will
:	be executed whenever CKBZ is forced to zap a buffer. The code
:	will be executed immediately following the call to EMPTY
:	(R1 will contain the buffer index).  The first line of the macro
:	must be "ZAPBUF MACRO [.X" (where X may be a carriage return
:	or semicolon).


	GL	NBUF,NBFLET,BUFTRC,UABUFF
  IF	\BUFTRC
  ELSE
BUFTRC	EQ	0
	REMARK	%*** Define BUFTRC EQ 1 if debug trace desired
  EI

 IF	\UABUFF
 ELSE
UABUFF	EQ	0	:BUFFERLET POOL IS NOT USER ALLOCATED
 EI

	MO	.,BUFFER
	GL	FASTC,TORET,TOPUT,RATE,FLAGS,CRASH
	IF	\DCTFLG
	GL	DCT
	EI
	GL	BF,BCT,BB,BE,REBL
	GL	IZBF,GCI,WCI,EMPTY,GCPEEK,GCSCAN,MCI
	GL	MBUFER

MBUFER	EQ	1		:FULLWORD ADDRESSING FLAG FOR OTHER MODULES

:	THE DATA FOR THESE ROUTINES
	SEG	A.DATA		:PLACE IN DATA AREA
REBL	HC	0		:FREE LIST POINTER FOR RESERVE STORAGE LIST
REBC1	HC	0		:COUNTS TIMES BUFFER STORAGE WAS MOVED TO MAIN FREE LIST
REBC2	HC	0		:COUNTS TOTAL NUMBER OF BUFFER ZAPS
BFZ	HC	-1		:LAST BUFFER ZAPPED

BF	WS	NBUF		:BUFFER FLAGS
BCT	WS	NBUF		:BUFFER COUNTS
BB	WS	NBUF		:BUFFER START ADDRESS
BE	WS	NBUF		:BUFFER END ADDRESS

  IF	BUFTRC
	GL	HISX,HISTAB
HISX	HC	0		:INDEX FOR HISTORY
HISTAB	HS	200		:HISTORY DATA...400 BYTES...100 HISTORY ENTRIES
  EI



:	CODE SECTION
	SEG	A.CODE		:PLACE IN CODE ARAEA

:	INITIALIZE BUFFERS
IZBF	LIS	R0,0		:SET A CONSTANT
	LHI	R1,NBUF*4-4	:FOR ALL BUFFERS
IZBF1	ST	R0,BCT,R1	:SET EMPTY
	IF	\DCTFLG
        ST      R0,DCT,R1,      :set DCT empty
	EI
	ST	R0,BB,R1	:CLEAR START POINTER
	ST	R0,BE,R1	:CLEAR END POINTER
	L	R2,BF,R1
        RBT     R2,FLAGS,,      :TURN OFF FLAG BIT
	SIS	R1,4
	JGEBS	IZBF1
	LHI	R2,NBFLET	:FOR ALL BUFFERLETS
	LHI	R1,NBFLET*10	:BUFFERLET POINTER ADDRESS
	STH	R0,BUFERS,R1,	:TERMINATE LIST
IZBF2	STH	R2,BUFERS-10,R1,	:LINK LAST TO THIS
	ST	R0,BUFERS-0E,R1,	:CLEAR DATA AREA
	ST	R0,BUFERS-0A,R1,
	ST	R0,BUFERS-06,R1,
	STH	R0,BUFERS-02,R1,
	SHI	R1,10
	SIS	R2,1		:DECREMENT BUFFER #
	JG	IZBF2		:REPEAT FOR ALL BUFFERLETS
	STH	R0,REBL		:SET SPARE TANK EMPTY
	L	R1,FASTC,,
	LHI	R1,RATE/$A25,R1	:CALL EVERY 40 MS.
	LA	R0,CKBZ		:PUT BUFFER CHECKING LOGIN ON QUEUE
	J	TOPUT		:EXIT VIA TIMEOUT LIST ENTRY
:	CHARACTER HANDLERS. THESE ROUTINES PASS BFR CHR IN R0,
:	R1 FOR TWICE THE BUFFER NUMBER, R2,R3 FOR WORKING REGISTERS,
:	R4 IS LINK REGISTER.

:	GET CHAR FROM BUFFER AND INCREMENT FORWARD THRU THE BUFFER.

GCI     LHL     R3,BCT,R1
        SIS     R3,1            :REDUCE COUNT OF CHARS IN  BUFFER
        STH     R3,BCT,R1

GCI1	HC	3801		:**GCI R0,R1
	HC	BE-BB		:SIZE OF BB STORAGE
	HC	GCICRA-GCI1	:ERROR ROUTINE OFFSET
	HC	BB/4		:ADDRESS OF BB STORAGE
	HC	GCINXT-GCI1	:GET NEXT BUFFERLET ROUTINE OFFSET
	HC	GCILAS-GCI1	:BUFFER EMPTY ROUTINE OFFSET

  IF	BUFTRC
	J	HIST		:AND RETURN WITH THE CHAR
  ELSE
	JR	R4		:AND RETURN WITH THE CHAR
  EI

GCINXT	LHL	R2,0,R3		:BUFFERLET EXHAUSTED - GET NEXT BFLT #
	SLLS	R2,4		:CONVERT TO BUFFERLET POINTER
	AI	R2,BUFERS-0E	:GET ADDRESS OF FIRST CHARACTER
	ST	R2,BB,R1	:SET BB TO START OF NEXT BUFFERLET
	LHL	R2,BUFERS,,	:GET POINTER TO FREE LIST
	STH	R2,0,R3		:LINK LAST BUFFERLET TO FREE LIST
	SI	R3,BUFERS	:COMPUTE OFFSET FROM BUFERS
	SRLS	R3,4		:CONVERT TO BUFFER NUMBER (DIV BY 16)
	STH	R3,BUFERS,,	:AND PUT AT THE HEAD OF THE FREE LIST
  IF	BUFTRC
	J	HIST		:THEN EXIT
  ELSE
	JR	R4		:THEN EXIT
  EI

GCILAS	L	R2,BF,R1	:OK...GET POINTER TO FLAG BIT
        RBT     R2,FLAGS,,      :RESET ATTENTION FLAG
	AIS	R3,0E		:BUMP CHARACTER POINTER PAST END OF BUFFERLET
	NHI	R3,-10		:MAKE CHAIN A MULTIPLE OF 16
	LHL	R2,BUFERS,,
	STH	R2,0,R3
	SI	R3,BUFERS	:CONVERT TO OFFSET FROM BUFERS
	SRLS	R3,4		:CONVERT TO BUFFER NUMBER
	STH	R3,BUFERS,,	:UPDATE FREE LIST
	LIS	R2,0
	ST	R2,BB,R1	:CLEAR BB
	ST	R2,BE,R1	:AND BE
  IF	BUFTRC
	J	HIST
  ELSE
	JR	R4
  EI

GCICRA	JAL	R10,CRASH;	BC	0,0,4*R4,3	:FLAG--LINK R4, TYPE 3
:	PUT A CHARACTER INTO THE BUFFER
WCI	HC	3901		:**WCI R0,R1
	HC	BE-BB		:SIZE OF BB STORAGE
	HC	WCICRA-WCI	:ERROR ROUTINE OFFSET 
	HC	BE/4		:ADDRESS OF BE STORAGE
	HC	WCINXT-WCI	:GET NEXT BUFFERLET ROUTINE
	HC	WCIFRS-WCI	:GET FIRST BUFFERLET ROUTINE

        LHL     R2,BCT,R1
        AIS     R2,1
        STH     R2,BCT,R1
  IF	BUFTRC
	J	HIST
  ELSE
	JR	R4
  EI

WCICRA	JAL	R10,CRASH	:ELSE CRASH
	BC	0,0,4*R4,5	:FLAG--LINK R4, TYPE 5 CRASH

WCINXT	LHL	R3,BUFERS,,	:NEED A NEW BUFFERLET
	JNFS	WCINXC		:SKIP IF THERE IS ANOTHER
	JAL	R2,WRE		:(OPEN THE RESERVE TANK)
WCINXC	L	R2,BE,R1	:GET END POINTER
	AIS	R2,1		:POINT TO LINK FIELD
	STH	R3,0,R2		:LINK NEW BUFFERLET TO LAST ONE
	SLLS	R3,4		:CONVERT TO BUFFER POINTER
	AI	R3,BUFERS	:MAKE ABSOLUTE ADDRESS
	LHL	R2,0,R3		:REMOVE FROM FREE LIST
	STH	R2,BUFERS,,
	SIS	R3,0E		:BACK UP NEW BUFFERLET
	ST	R3,BE,R1	:SAVE AS NEW BE
	STB	R0,0,R3		:PUT THE CHARACTER THERE
        LHL     R2,BCT,R1
        AIS     R2,1
        STH     R2,BCT,R1
  IF	BUFTRC
	J	HIST
  ELSE
	JR	R4
  EI

WCIFRS	L	R2,BF,R1	:THE BUFFER WAS EMPTY
  IF	BUFTRC
	JE	HIST		:TOSS CHAR, DONT WASTE SPACE ON UNASSIGNED BFR
  ELSE
	JER	R4		:TOSS CHAR, DONT WASTE SPACE ON UNASSIGNED BFR
  EI
        SBT     R2,FLAGS,,      :ATTENTION BIT ON, DATA WAITING
	LIS	R2,1
	STH	R2,BCT,R1	:SET COUNT = 1
	LHL	R3,BUFERS,,	:POP A BUFFERLET OFF FREE LIST
	JGFS	WCIFR1		:SKIP IF THERE WAS ONE
	JAL	R2,WRE		:ELSE OPEN THE RESERVE TANK
WCIFR1	SLLS	R3,4		:CONVERT TO BUFFERLET POINTER
	AI	R3,BUFERS	:COMPUTE ABSOLUTE ADDRESS
	LHL	R2,0,R3		:GET ITS SUCCESSOR
	STH	R2,BUFERS,,	:UPDATE FREE LIST
	SIS	R3,0E		:POINT IT AT FIRST CHARACTER
	ST	R3,BB,R1	:SET UP BB
	ST	R3,BE,R1	:AND BE
	STB	R0,0,R3		:PUT THE CHARACTER THERE
  IF	BUFTRC
	J	HIST
  ELSE
	JR	R4
  EI

:	MOVE RESERVE STORAGE SUPPLY TO MAIN FREE LIST
WRE	LHL	R3,REBL		:GET POINTER TO RESERVE BUFFERLETS
	EXHR	R3,R3
	STH	R3,REBL		:SET RESERVE BUFFERLETS EMPTY (=0)
	EXHR	R3,R3
	JNR	R2		:IF IT WASN'T EMPTY, RETURN
	JAL	R10,CRASH	:BUG, UNREASONABLY FAST STORAGE DRAIN
	BC	0,0,4*R4,6	:FLAG--LINK R4, TYPE 6

  IF	BUFTRC
:	UPDATE HISTORY (TRACE) AFTER EVERY BUFFER OPERATION
HIST	LH	R3,HISX		:GET HISTORY RING INDEX
	AIS	R3,4		:BUMP TO NEXT ENTRY
	NHI	R3,3FF		:ACCOUNT FOR FOLDING
	STH	R3,HISX		:SAVE IT AGAIN
	STB	R0,HISTAB,R3	:ENTRY (0) = CHARACTER
	LR	R2,R1
	SRHLS	R2,2		:COMPUTE BUFFER #
	STB	R2,HISTAB+1,R3	:ENTRY (1) = PORT #
	STH	R4,HISTAB+2,R3	:ENTRY (2, 3) = LOCATION WHERE CHAR PLACED
	JR	R4
  EI	(BUFTRC)
:	PEEK AT FIRST CHAR OF BUFFER
GCPCRA	JAL	R10,CRASH;	BC	0,0,4*R4,6	:CRASH TYPE 6
GCPEEK	CLHI	R1,4*NBUF	:RANGE CHECK
	JGEBS	GCPCRA
	L	R2,BB,R1	:GET POINTER TO START OF BUFFER DATA
	LHL	R3,BCT,R1	:GET COUNT OF CHARS THERE
	JFS	GCS		:AND SKIP

:	SCAN SUCESSIVE CHARACTERS IN BUFFER
GCSCAN	CLHI	R1,4*NBUF	:RANGE CHECK
	JGEBS	GCPCRA
GCS	SIS	R3,1
	JL	GCPCRA		:CRASH IF NO MORE CHARACTERS THERE
	LB	R0,0,R2		:ELSE GET CHAR
	AIS	R2,1		:BUMP POINTER FOR NEXT TIME
	THI	R2,0F
	JNR	R4		:EXIT IF NOT AT END OF BUFFERLET
	LHL	R2,0,R2		:ELSE ADVANCE TO NEXT BUFFERLET
	SLLS	R2,4		:CONVERT TO POINTER
	AI	R2,BUFERS-0E	:COMPUTE ABSOLUTE ADDRESS OF START
	JR	R4
:	MCI - MOVE ALL CHARACTERS FROM SOURCE TO DESTINATION BUFFER
:	R5 = SOURCE BUFFER INDEX
:	R6 = DESTINATION BUFFER INDEX
:	R7 = LINK
MCICRA	JAL	R10,CRASH
	BC	0,0,4*R7,4	:FLAG--LINK R7, TYPE 4
MCI	CLHI	R5,4*NBUF
	JGBS	MCICRA		:RANGE CHECK ON SOURCE
	CLHI	R6,4*NBUF
	JGBS	MCICRA		:RANGE CHECK ON DESTINATION
	LHL	R0,BCT,R5	:CHECK SOURCE
	JER	R7		:EXIT IF EMPTY
	L	R1,BF,R6	:SET DESTINATION FLAG
	JNFS	MCI1		:FLAG = 0 IS BIT BUCKET
	LR	R1,R5		:THEN JUST EMPTY BUFFERS
	LR	R4,R7
	J	EMPTY
MCI1    SBT     R1,FLAGS,,
	JNFS	MCI2		:NOT EMPTY...GO APPEND
	L	R0,BB,R5	:EMPTY...COPY BUFFER START
	ST	R0,BB,R6
	J	MCI4		:AND SKIP TO FINISH TRANSFER OF DATA
MCI2	L	R1,BE,R6	:CHECK DESTINATION
	AIS	R1,1		:IS IT AT END OF BUFFERLET?
	THI	R1,0F
	JNFS	MCI3		:SKIP IF NOT
	L	R2,BB,R5	:YES...IS SOURCE ON BUFFERLET BOUNDARY?
	AIS	R2,0E
	THI	R2,0F
	JNFS	MCI3		:SKIP IF NOT
	SI	R2,BUFERS	:CONVERT TO RELATIVE POINTER
	SRLS	R2,4		:CONVERT TO BUFFERLET NUMBER
	STH	R2,0,R1		:APPEND SOURCE TO DESTINATION
	JFS	MCI4		:AND SKIP
MCI3	LR	R1,R5		:MOVE A CHAR
	JAL	R4,GCI
	LR	R1,R6
	JAL	R4,WCI
	LHL	R0,BCT,R5	:CHECK SOURCE
	JG	MCI2		:LOOP IF NOT EMPTY
	JR	R7		:ELSE RETURN
MCI4	L	R0,BE,R5
	ST	R0,BE,R6	:UPDATE BUFFER END
	LHL	R0,BCT,R5
        LHL     R1,BCT,R6
        AR      R0,R1
        STH     R0,BCT,R6
	LIS	R0,0
	STH	R0,BCT,R5	:CLEAR SOURCE BUFFER
	ST	R0,BB,R5
	ST	R0,BE,R5
	L	R1,BF,R5
        RBT     R1,FLAGS,,      :TURN OFF SOURCE FLAG
	JR	R7		:AND EXIT
:	RETURN ALL THE SPACE USED BY THE BUFFER
EMPTY	CLHI	R1,4*NBUF	:RANGE CHECK ON BUFFER NUMBER
	JLFS	C1		:BFR ARGUMENT ACCEPTED
	JAL	R10,CRASH	:BFR ARG OUT OF RANGE
	BC	0,0,4*R4,0D	:FLAG--LINK R4, TYPE 13d

C1	LHL	R2,BCT,R1	:CHECK CONTENTS
	JER	R4		:EXIT...BUFFER EMPTY
	L	R2,BB,R1	:POINTER TO FIRST CHAR IN BUFFER
	SI	R2,BUFERS-0E	:GET RELATIVE ADDR, INSURE ROUNDING UP
	SRLS	R2,4		:CONVERT TO BUFFER #
	LHL	R3,BUFERS,,	:GET POINTER TO FREE LIST
	STH	R2,BUFERS,,	:PUT THE BUFFERS BUFFERLETS ONTO FREE LIST
	L	R2,BE,R1	:GET POINTER TO LAST CHARACTER IN BUFFER
	AIS	R2,0E		:LOCATE THE POINTER IN THIS BUFFERLET
	NHI	R2,-10
	STH	R3,0,R2		:CHAIN PREVIOUS FREE LIST TO THIS BUFFERLET
	L	R2,BF,R1
        RBT     R2,FLAGS,,      :SET FLAGS TO EMPTY BUFFER
	LIS	R2,0
	STH	R2,BCT,R1	:SET COUNT = 0
	IF	\DCTFLG
        STH     R2,DCT,R1,
	EI
	ST	R2,BB,R1	:CLEAR BB
	ST	R2,BE,R1	:AND BE
	JR	R4		:AND RETURN
:	SEE IF WE MUST ZAP BFRS BECAUSE BFR STORAGE RUNNING LOW
CKBZ	LHI	R1,RATE/$A25,R1	:SET TIMER FOR NEXT CALL
	JAL	R5,TOPUT	:RUN 25 TIMES PER SECOND
	LH	R1,REBL		:ARE WE ON THE RESERVE TANK?
	JN	TORET		:PLENTY OF BFR STORAGE. DONT ZAP BFRS

:	WCI GRABBED RESERVE BFR FREE LIST AND MOVED IT TO MAIN FREE LIST.
:	REFILL FREE LIST WITH 1/8 OF TOTAL BFR STORAGE. ZAP BFRS IF NECESSARY.
	LIS	R0,1
	AHM	R0,REBC1	:STATISTIC
REB1	LIS	R2,0		:INITIAL POINTER IS TO START OF FREE LIST
	LHI	R1,NBFLET/8	:SCAN MAIN FREE LIST FOR 1/8 FREE STORAGE

REB2	LHL	R2,BUFERS,R2,	:GET NEXT BUFFER ON FREE LIST
	JE	REBZ		:NOT ENOUGH SPARE SPACE. ZAP A BFR
	SLLS	R2,4		:CONVERT BUFFER # TO POINTER
	SIS	R1,1		:GOT ANOTHER...COUNT IT
	JGBS	REB2		:GO UNTIL WE'VE GOT ENOUGH
	LHL	R3,BUFERS,,	:DONE...SEPERATE FREE LIST INTO TWO PARTS
	STH	R3,REBL		:BEGINNING OF THE RESERVE LIST
	LHL	R4,BUFERS,R2,,
	STH	R4,BUFERS,,	:BEGINNING OF MAIN LIST
	STH	R1,BUFERS,R2,,	:DEATH'S BRIGHT ANGEL AT END OF SPARE LIST (=0)
	J	TORET

:	ZAP A BFR IN ORDER TO GET RESERVE TANK UP TO 1/8 OF TOTAL BFR STORAGE
REBZ	LHI	R1,NBUF*4-4	:BCT INDEX
	LIS	R7,0		:R7 WILL CONTAIN SIZE OF LARGEST BUFER
REBZ1	LHL	R0,BCT,R1	:R0 - SIZE OF THIS BUFER
	CLR	R7,R0		:COMPARE BIGGEST SO FAR TO THIS ONE
	JGEFS	.+6
	LR	R7,R0		:MAKE R7 CONTAIN THE BIGGEST
	LR	R8,R1		:R8 WILL REMEMBER WHICH BUFFER IS BIGGEST
	SIS	R1,4		:POINT TO NEXT BUFFER ENTRY IN BCT TABLE
	CLHI	R1,8
	JGEBS	REBZ1		:DO NEXT BCT ENTRY
	LIS	R0,1
	AHM	R0,REBC2	:INCREMENT COUNTER
	STH	R8,BFZ		:STATISTICS
	LR	R1,R8		:ZAP BIGGEST BUFFER FOUND
	JAL	R4,EMPTY	:RETRIEVE STORAGE
  IF	\ZAPBUF : ZAPBUF WILL EXPAND INTO MACRO CALL IF DEFINED,
  EI		:ELSE THIS IS A NOOP
	LIS	R0,9
	JAL	R4,ROOM,,	:WE WANT TO SEND A 9-BYTE MESSAGE
	LHI	R0,0300		:SPECIAL MESSAGE TYPE 3...
	JAL	R4,PUTW,,	:SEND DIAGNOSTIC TO SUP
	LR	R0,R8
	JAL	R4,PUTH,,	:HW4 = BUFFER NUMBER
	LIS	R0,0
	JAL	R4,PUTCH,,	:REPORT TYPE = 0
	LR	R0,R7		:LOAD CHAR COUNT
	SRHLS	R0,0A		:DIVIDED BY 1024
	JAL	R4,PUTCH,,	:HW3 HIGH = CHAR COUNT
	LHI	R0,PRODID	:GET PRODUCT ID
	JAL	R4,PUTCH,,	:HW2 LOW = PRODID
	JAL	R4,ELOR,,	:END LOGICAL OUTPUT RECORD
	J	REB1		:TRY AGAIN TO FILL RESERVE STORAGE LIST

 IF	UABUFF
 ELSE
:	BUFFER SEGMENT
	SEG	A.BUFF		:BUFFERLETS IN BUFFER AREA
	BND	10		:Must start on a multiple of 16d bytes.
BUFERS	HS	1		:Free list pointer
	HS	8*NBFLET	:STORAGE FOR THE BUFFERLETS (16 bytes each.)
 EI
	EM
  