
: ******************************************************************
: **                  PROPRIETARY INFORMATION                     **
: **                                                              **
: **  This  source  code  listing  constitutes  the proprietary   **
: **  property of MDC-TYMNET.  The recipient, by receiving this   **
: **  program listing, agrees that neither this listing nor the   **
: **  information disclosed herein nor any part thereof shall be  **
: **  reproduced or transferred to other documents or used or dis-**
: **  closed to others for manufacturing or for any other purpose **
: **  except as specifically authorized in writing by MDC-TYMNET. **
: ******************************************************************
: **                   PROGRAM IDENTIFICATION                     **
: **                                                              **
: **  Version Number     :               Release Date : 09/23/87  **
: **                                                              **
: **  File Name          :               MUX05.R00                **
: **                                                              **
: **  File Description   :                                        **
: **                                                              **
: **  File Abstract      :                                        **
: **                                                              **
: ******************************************************************
::	MULTIPLEXER OPTIONS SETUP

ENGINE	EQ	1		:ENGINE ONLY
ISIS2   EQ      1               :ISIS2 VERSION
NUSERS	EQ	USR		:NUMBER OF USERS
MAXHST  EQ      1               :MAX NO. OF HOSTS
MAXPRT  EQ      NPORT-1         :MAX NO. OF PORTS
HOST0	EQ	HOSTNO		:HOST NMBR
HPRT0	EQ	NPORT/4		:1/4 OF PORTS FOR INPUT
CNTRL	EQ	0		:ISIS STATE WORD
NTOUT	EQ	2		:TIMEOUT LIST LENGTH

	SUBTTL	ISIS Assembly Switch Definitions	- START.LIB
:******************************************************************
:
:	This program is the sole property and confidential
:	information of Tymshare, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.
:
:*******************************************************************

	REMARK %Start.Lib Version 
SREV	EQ	0;	NUMBER SREV; REMARK .0
SLEV	EQ	05;	NUMBER SLEV

: Version 0.05 01/19/83 MDS
:	Delete Remark regarding incompatibility with ISIS 5.00
: Version 0.04 03/12/82  MDS
:	Add new fields to SYS SVC Sub-operand definitions,
:	per ISIS2 v.5.01
: Version 0.03 03/08/82  MDS
:	Add new fields to Seg F table per ISIS 5.01
:	(note - Start.lib ** NOT ** compatible with ISIS 5.00
:	because SLCNT and LCX were reversed in 5.00 )
: Version 0.02  12/08/81  MDS
:	Add QSTART remark, add I/O sub-ops for mother board.
:	Delete ISIS (one) code - force ISIS2
: Version 0.01  01/08/81  MDS
:	Correct relative addresses of local clock index and values.

	RA	0		:	START.LIB

:	this file should always be assembled IMMEDIATELY AFTER the *.TYM file


ISIS2	EQ	1	:Force ISIS2 for other library routines
			:Note - ISIS 1 is no longer supported

:			ISIS - II Version
:
:	The following parameters should be defined in the *.TYM file:
:	MAXHST	maximum number of hosts associated with this interface slot
:	MAXPRT	number of highest port associated with this interface slot
:			(number of ports - 1)
:	IRSIZE	 number of bytes to provide for input ring, from dispatcher
:	ORSIZE	 number of bytes to provide for output ring, to dispatcher
:	CNTRL	dispatcher control bits
:	ENGINE	set to 1 if executing on a Tymnet Engine

:	the following symbols MUST be defined SOMEWHERE in the assembly:
:	IRING	the start of the input ring, from dispatcher
:	ORING	the start of the output ring, to dispatcher
:	ENTRY	the location of the first instruction to be executed

:	the following symbols are defined for convenience:
:	RATE	the rate of the fast clock (ticks/second)
:	NRATE	word containing the value of RATE
:	FASTC	word containing  realtime fast clock
:	SLOWC	word containing  realtime slow clock (1-second)
:	GMT	word containing GMT clock
:	TEMPER	byte containing machine temperature
:	VOLTS	byte containing machine voltage
:	VERNO	halfword containing ISIS version number
:	WWVBT	word containing WWVB time
:	HOSTX	halfword containing kernel host number
:	NODEX	halfword containing kernel node number
:	LCX	halfword, offset of local clocks within seg F
:	SLCNT	halfword, number of slots known to ISIS dispatcher
:	LCT	halfword, pointer to crash table
:	MAXP0	halfword, highest port 0 msg. #
:	MAXMSG	halfword, highest msg # for all other ports
:	LP0LST	halfword, length table for port 0 msgs.
:	LENGTH	length table for msgs. all other ports
:	R0-R15	symbolic names for the registers
:	SEGn	the start address of segment n (0-0E)
:	HOSTS	halfword array of host numbers as known by the dispatcher (R/O)
:	PORTS	halfword array of ports/host as known by dispatcher (R/O)
:
:	the following symbols MAY be defined. defaults used otherwise
:	APROTn	protection byte for area n. default area 1 write protected,
:		other areas execution protected.
:	HOSTn	host number for host position n. default none.
:	HPRTn	number of ports for host position n. default none.
:	DSTART	user DDT execution start address. default none.
:	QSTART  user DDT query handler start address, default none.
:	FPANEL	halfword cell for front panel display. default cell allocated
:	FRISIS	bit array for input backpressure (1=no backpressure) default
:			array allocated.
:	TOISIS	bit array for output backpressure (1=no backpressure) default
:			array allocated.
:	VERSION	version number for slot code (default zero)
:	PCTTBL	bit array for indicating terminating character for project
:			code. (default none)
:	REVLEV	revision level for slot code (default zero)
:	A.DATA	segment number for data area. Default 0
:	A.CODE	segment number for code area. Default 1
:	A.BDAT	segment number for based data. Default 2.
:	A.RING	segment number for rings. Default 2.
:	A.BUFF	segment numberfor buffer(let)s. Default 2.
:
:	in addition most SVC calls have been assigned symbolic names.

	GL	FASTC,SLOWC,RATE,NRATE,GMT,TEMPER,VOLTS,VERNO,HOSTX,NODEX,SLOTNO
	GL	R0,R1,R2,R3,R4,R5,R6,R7,R8,R9,R10,R11,R12,R13,R14,R15
	GL	IRSIZE,ORSIZE,CNTRL
	GL	ENTRY,IRING,ORING,ENGINE,LCX
	GL	VERREV,COREST,FPANEL,HOSTS,PORTS,FRISIS,TOISIS

:	DEFINE SEG 15d LOCATIONS
RATE	EQ	$A 600		:clock rate, ticks per second
NRATE	EQ	0F0000		:word, contains RATE
FASTC	EQ	0F0004		:word, contains fast clock (ticks)
SLOWC	EQ	0F0008		:word, contains slow clock (seconds)
GMT	EQ	0F000C		:word, contains GMT (seconds since 1/1/72)
TEMPER	EQ	0F0010		:byte, contains machine temperature
VOLTS	EQ	0F0011		:byte, contains machine voltage
VERNO	EQ	0F0012		:halfword, ISIS version number
WWVBT	EQ	0F0014		:word, WWVB time (format ??)
HOSTX	EQ	0F0018		:halfword, kernel host number
NODEX	EQ	0F001A		:halfword, kernel node number

: Local clocks displacements

LCX	EQ	0F001C	:1/2 word, contains offset of LOCLKS within seg F
: LOCLKX and LOCLKS must be referenced by the pointer in LCX
:LOCLKX	EQ	LOCLKS-2 :1/2 word, index to current clock from LOCLKX
:LOCLKS	EQ	Seg F + contents of LCX
			:clocks for slots, array of word entries per slot
			:1st halfword is user ticks, 2nd is sys ticks for slot

SLCNT	EQ	0F001E		:halfword, number of dispatcher slots
LCT	EQ	0F0020		:halfword, pointer to crash table
MAXP0	EQ	0F0022		:halfword, max. msg. # for port 0
MAXMSG	EQ	0F0024		:halfword, max. msg #, all non-0 ports
LP0LST	EQ	0F0026		:halfword, offset to port 0 msg length table
LENGTH	EQ	0F0028		:byte table, lengths of non-0 port msgs

:	Define Registers
R0	EQ	0
R1	EQ	1
R2	EQ	2
R3	EQ	3
R4	EQ	4
R5	EQ	5
R6	EQ	6
R7	EQ	7
R8	EQ	8
R9	EQ	9
R10	EQ	$A 10
R11	EQ	$A 11
R12	EQ	$A 12
R13	EQ	$A 13
R14	EQ	$A 14
R15	EQ	$A 15

:	AREA DEFINITIONS
	GL	A.DATA,A.CODE,A.BDAT,A.RING,A.BUFF
:
  IF	\A.DATA
  ELSE
A.DATA	EQ	0	:DEFAULT DATA AREA
  EI

  IF	\A.CODE
  ELSE
A.CODE	EQ	1	:DEFAULT CODE AREA
  EI

  IF	\A.BDAT
  ELSE
A.BDAT	EQ	2	:DEFAULT BASED DATA AREA
  EI

  IF	\A.RING
  ELSE
A.RING	EQ	2	:DEFAULT RING AREA
  EI

  IF	\A.BUFF
  ELSE
A.BUFF	EQ	2	:DEFAULT BUFFER AREA
  EI

:	SVC DEFINITIONS
:
	GL	DISMIS,FASTD,SYS,RSTRT.,CFGND.,DBGON.,DBGOF.,TSTDB.
	GL	FREEZ.,THAW.,TFREZ.,RDDTR.,RDDTP.,RBREG.,RBPSD.
	GL	RFREG.,RFPSD.,RDMAC.,RBMAC.,RFMAC.,SET1P.,SETP.,SETBE.
	GL	SETFE.,IO,IOQRY.,CSYNI.,CSYNO.,FSYNO.,TIISC.
	GL	CSUPF.,CSUPR.,FREZS.,THAWS.,ALARM.,RSCLK.,SSCLK.,SUDIA.
	GL	SFREZ.,HALT.,SHALT.
	GL	TIISI.,CASYN.,CPRT.,FPRT.,CSIO.,CMBRD.,FMBIN.,FMBOT.
	GL	SHARE,K.IN,K.OUT,KIO,BDISC,SDISC
:
DISMIS	EQ	0	:DISMISS SVC
FASTD	EQ	1	:FAST DISMISS SVC
:
SYS	EQ	2	:SYS SVC

:	SYS SVC SUBOPERANDS
RSTRT.	EQ	0	:Restart syscall
CFGND.	EQ	1	:Connect foreground syscall
DBGON.	EQ	2	:Debug mode ON syscall
DBGOF.	EQ	3	:Debug mode OFF syscall
TSTDB.	EQ	4	:Test debug mode syscall
FREEZ.	EQ	5	:Freeze slot syscall
THAW.	EQ	6	:Thaw slot syscall
TFREZ.	EQ	7	:Test freeze syscall
RDDTR.	EQ	8	:Read DDT register syscall
RDDTP.	EQ	9	:Read DDT PSD syscall
RBREG.	EQ	0A	:Read background register syscall
RBPSD.	EQ	0B	:Read background PSD syscall
RFREG.	EQ	0C	:Read foreground register syscall
RFPSD.	EQ	0D	:Read foreground PSD syscall
RDMAC.	EQ	0E	:Read DDT MAC register syscall
RBMAC.	EQ	0F	:Read background MAC register syscall
RFMAC.	EQ	10	:Read foreground MAC register syscall
SET1P.	EQ	11	:Set 1 protect syscall
SETP.	EQ	12	:Set protection syscall
SETBE.	EQ	13	:Set background execution addr syscall
SETFE.	EQ	14	:Set foreground execution addr syscall
LMAC.	EQ	15	:Set up MAC from CTA (DDT only)
CSUPF.	EQ	16	:Check SUP freeze state
CSUPR.	EQ	17	:Check SUP run Q state
FREZS.	EQ	18	:Freeze the SUP
THAWS.	EQ	19	:Thaw the SUP
ALARM.	EQ	1A	:Set/Clear alarm
RSCLK.	EQ	1B	:Read the super-clock
SSCLK.	EQ	1C	:Set the super-clock
SUDIA.	EQ	1D	:Set user diagnostic
UCORE.	EQ	1E	:Get slot physical addr & size (DDT only)
SFREZ.	EQ	1F	:Super-freeze slot
HALT.	EQ	20	:Halt the slot
SHALT.	EQ	21	:Super-halt the slot
SVSPY.	EQ	22	:Start/Stop SPY
DISCO.	EQ	23	:Disconnect Logical Unit

IO	EQ	3	:I/O SVC
:	I/O SUBOPERANDS
IOQRY.	EQ	8000	:Query I/O attributes
CSYNI.	EQ	0	:Connect SYNC input
CSYNO.	EQ	1	:Connect SYNC output
FSYNO.	EQ	2	:Force SYNC output
CASYN.	EQ	3	:Connect ASYNC
CPRT.	EQ	4	:Connect Printer
FPRT.	EQ	5	:Force Printer
TIISC.	EQ	6	:T-II SYNC Connect
TIISI.	EQ	7	:T-II SYNC Idle test
CSIO.	EQ	8	:Connect SIO
CMBRD.	EQ	9	:Connect SIO mother board
FMBIN.	EQ	0A	:Force mother board input
FMBOT.	EQ	0B	:Force mother board output
SHARE	EQ	04	:Shared device SVC
K.IN	EQ	0A	:Kernel Input SVC
K.OUT	EQ	0B	:Kernel Output SVC
KIO	EQ	0D	:Kernel-I/O (general) SVC
BDISC	EQ	0E	:Big disc SVC (obsolete)
SDISC	EQ	0F	:Small disc SVC (obsolete)

	IF	IRSIZE&3;	REMARK	%IRSIZE should be multiple of 4
IRSIZE	EQ	(IRSIZE!3)+1;	EI
	IF	ORSIZE&3;	REMARK	%ORSIZE should be multiple of 4
ORSIZE	EQ	(ORSIZE!3)+1;	EI

  IF	\MAXPRT
  ELSE
	REMARK	%PLEASE DEFINE MAXPRT. NPORTT ASSUMED.
MAXPRT	EQ	NPORTT-1
HPRT0	EQ	MAXPRT
  EI

  IF	\MAXHST
  ELSE
	REMARK	%PLEASE DEFINE MAXHST. 1 ASSUMED.
MAXHST	EQ	1
HOST0	EQ	HOSTNO
  EI


:	DEFINE START OF SEGMENTS
Q	EQ	0
	NOLIST
	RE	0F
  IF	\SEG|Q|
	GL	SEG|Q|
  ELSE
	SEG	Q
	GL	SEG|Q|
SEG|Q|
  EI
Q	EQ	Q+1
	ER
	LIST

:GENERATE DIAGNOSTICS
Q	EQ	0
	NOLIST
QQ	EQ	0;	RE	0F
	IF	((Q*10000)%SEG|Q|)&7FFFFFFF
QQ	EQ	1;	REMARK	%SYMBOL SEG
	NUMBER	Q
	REMARK	 IS NOT DEFINED PROPERLY. VALUE IS 
	NUMBER	SEG|Q|
	EI
Q	EQ	Q+1;	ER
	LIST

	IF	QQ;
	REMARK	%START.LIB **MUST** be assembled FIRST!!%;
	EI
	SUBTTL	STATUS.LIB . . . .DRIVER TO PROCESS ARBITRARY COMMANDS UNDER "?STAT"
:******************************************************************
:
:	This program is the sole property and confidential
:	information of Tymshare, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.
:
:*******************************************************************

  IF	1-\DB.STA			:DEFAULT DEBUG/STATUS TO ON
DB.STA	EQ	1
  EI

  IF	DB.STA				:ASSEMBLE ONLY WITH DEBUG STATUS ON

	SEG	A.CODE
	MO	.,STATUS
	RA	$00
	GL	DSTART,DS.ELL,DS.ILL,DS.ERR,DS.DLM,DS.CIR
	GL	DS.TOK,DS.NUM,DS.EXI,DS.QUI,DS.GCH,DS.CUC,DS.DEL

:	STATUS - User Command Handler
:
:	Version history:
:	13.2  01/27/81  <BAB>Added RADIX=0 at start of mod.  Added jump
:		following 'QUIT' SVC to allow DDT "P" (proceede) command
:		to return the user to ":>" prompt.
:	13.1  11/17/81	<BAB>Added DNEXTK support, DS.DLM (last delimeter),
:		and fixed backspace for > 4 character entry, added the
:		command thought to be invalid to invalid command message.
:	13	08/81	<JK>Maintenance assumed by BAB from John Kopf
:
:		The Status package is intended to provide an extension to DDT,
:	invokable via the "?STAT" command in DDT.  Once invoked you may re-
:	activate it (provided you have not issued any DDT "G" (go) commands)
:	by typing "P ".
:
:		There is limited editing control built into the package:
:	ESC	aborts back to command level,
:	^W	discards partial 'token' already input (word or number),
:	^A	discards last char of token (backspace).
:	^H	discards last char of token (backspace).

:		Delimiters may occur in multiple (e.g. ", " is OK).  Valid
:	delimiters are:
:	C/R	L/F	H/T	","	and BLANK.

:		Entry Points:
:	DSTART	Place to exit on completion of command.
:	DNEXTK  Get next token with out prompt.
:	DS.ILL	Place to exit on illegal command -- types "Illegal command"
:	DS.ERR	Place to exit on command error -- types "type '\' "
:	DS.EXI	Place to exit machine.
:	DS.QUI	Place to exit back to DDT.
:	DS.GCH	Get a character...Link on R1, char (with high-order bit forced)
:			in R0...normal return if detected ^W, skip-4 if detect
:			~A, aborts back to DSTART if detects ESC.
:	DS.DEL	Check for delimiter...Link on R2, Character in R0.  Skip-4
:			return unless this is a delimiter, then normal return.
:	DS.CUC	Convert to upper case...Link on R1, Character in R0.
:	DS.TOK	Get a string token...Link on R4, TOKEN returned in R3...
:			inputs up to 4 characters, returns them (in uppercase)
:			left justified, 0 fill
:	DS.NUM	Get a number...Link on R5, expects Radix in R4...
:			number returned in R0.  May ABORT if any character is
:			input other than valid digit or delimiter.
:	DS.DLM  Location of last delimeter entered (1 byte)

:		There are two built-in commands:
:	Quit	exit back to DDT.
:	EXIt	exit machine.

:		additional commands may be defined via the DS.CMD macro:
:	 DS.CMD(TEXT,ADDR)
:	Where:	TEXT	The (UPPERCASE) target command string.
:		ADDR	The virtual address to transfer to, to service that
:				command.
:	DS.CMD generates a 12-byte discriptor for this command, at the point
:	assembly where it is invoked.  This discriptor is on a WORD boundary.



OUT	EQ	0B			:OUTPUT SVC
IN	EQ	0A			:INPUT SVC

DS.ELL	EQ	0			:NULL POINTER FOR END OF LINKED LIST

	SEG	A.DATA
DS.DLM	BS	1			:LAST DELIMETER ENCOUNTERED
R4SAV	WS	1			:SAVE AREA FOR R4 IN DS.TOK
BADSTR	SC	/'xxxx'"8D"8A/		:PLACE TO PUT BAD COMMAND
	SEG	A.CODE

:	DEFINE ELEMENTS FOR COMMAND BLOCK
C.NEXT	EQ	0			:POINTER TO NEXT ENTRY
C.ADDR	EQ	C.NEXT+4		:POINTER TO COMMAND HANDLER
C.STR	EQ	C.ADDR+4		:RELATIVE POSITION OF STRING

:	DEFINE MACRO TO GENERATE THIS COMMAND BLOCK
DS.CMD	MACRO(STR,ADDR)[
   IF	DS.ELL
Q	WS	0
	ORG	DS.ELL
	WC	Q
	ORG	Q
   EI
DS.ELL	WC	0,ADDR
	AC	/STR/
	BND	4
]


:	TABLE OF COMMANDS, AND TARGET ROUTINES.
CMDLST	WS	0			:FORCE TO WORD BOUNDARY
	DS.CMD(Q,DS.QUI)		:EXIT BACK TO DDT
	DS.CMD(QUIT,DS.QUI)		:EXIT BACK TO DDT
	DS.CMD(EXIT,DS.EXI)		:EXIT 
	DS.CMD(EXI,DS.EXI)		:EXIT 
	DS.CMD(C,DS.CIR)                :LIST PORTS W/ CIRCUITS
	DS.CMD(CI,DS.CIR)                :LIST PORTS W/ CIRCUITS
	DS.CMD(CIR,DS.CIR)              :LIST PORTS W/ CIRCUITS




:	DIAGNOSTIC MESSAGES
TERR	SC	/Illegal command /
TTERR	SC	/type '\'"8D"8A/
PROMPT	SC	/"8D"8A:>/		:"CR|LF:>"
BKSPAC	SC	/"88 "88/		:BACK SPACE
	SUBTTL	COMMAND SCANNER, VERIFIER, AND BITCHER

:	COMMAND INPUT HANDLER
DOIT	L	R0,C.ADDR,R1		:GO SERVICE THIS COMMAND
	JALR	R0,R0

:	NEXT COMMAND
DSTART	SVC	K.OUT,PROMPT		:ISSUE PROMPT
DNEXTK	JAL	R4,DS.TOK		:GET COMMAND TOKEN
	LA	R1,CMDLST		:SEARCH FOR STRING MATCH
DSTAR1	CL	R3,C.STR,R1
	JE	DOIT			:PROCEED IF FIND A MATCH
	L	R1,C.NEXT,R1		:ELSE CONTINUE SCAN
	JGBS	DSTAR1
DS.ILL	SVC	K.OUT,TERR		:"ILLEGAL COMMAND"
	ST	R3,BADSTR+2,,		:"XXX"<CR>
	SVC	K.OUT,BADSTR,,
DS.ERR	SVC	K.OUT,TTERR		:TELL USER TO TYPE FLUSH CHAR
BITCH	JAL	R1,DS.GCH		:FLUSH INPUT
	JBS	BITCH;	 NOPR	0			:^W...IGNOR
	JBS	BITCH;	 NOPR	0			:^A...IGNOR
	CLHI	R0,0DC			:READ UNTIL "\" IS FOUND
	JNBS	BITCH
	J	DSTART			:THEN EXIT


:	BUILT-IN COMMANDS

:		Command EXIt
:		===========-
DS.EXI	SVC	KIO,0			:DISCONNECT


:		Command Quit (exit back to DDT)
:		=========---
DS.QUI	SVC	KIO,1			:RETURN TO DDT
	J	DSTART			:IF OPERATOR TYPED "P", GET NEXT COMMAND
	SUBTTL	U T I L I T I E S

:	GET A COMMAND TOKEN...UP TO 4 CHARS LONG
:		SKIPS OVER EXTRA CHARACTERS TO NEXT DELIMITER
:	LINK ON R4
:	TOKEN RETURNED IN R3, LEFT JUSTIFIED
DS.TOK	HS	0
	ST	R4,R4SAV,,		:SAVE R4
TOKEN0	JAL	R1,DS.GCH		:GET NEXT CHAR
	JBS	TOKEN0;	 NOPR	0			:^W...IGNORE
	JBS	TOKEN0;	 NOPR	0			:^A...IGNORE
	JAL	R2,DS.DEL		:SKIP OVER DELIMITERS
	J	TOKEN0
	JAL	R1,DS.CUC		:CONVERT TO UPPER CASE
	CHI	R0,00DC			:= "\" ?
	JE	DSTART			:YES, PRINT PROMPT, GET NEXT COMMAND
	LBR	R3,R0			:SET UP STRING ACCUMULATOR (000000CC)
	LIS	R4,1			:1 CHAR. FOUND SO FAR
TOKEN	JAL	R1,DS.GCH		:GET ANOTHER CHAR
	J	TOKEN0			:^W...START OVER
	J	TOKEN3			:^A...TOSS LAST CHAR
	JAL	R1,DS.CUC		:CONVERT TO UPPER CASE
	JAL	R2,DS.DEL		:CHECK FOR DELIMITER
	J	TOKEN1			:GOT ONE...SKIP TO LEFT JUSTIFY IT
	CHI	R0,00DC			:= "\" ?
	JE	DS.ILL			:YES, TREAT AS ILLEGAL
	AIS	R4,1			:ONE MORE CHARACTER
	CHI	R4,4			:IF => 4 CHARS, DO NOT USE THIS ONE
	JG	TOKEN			:YES...SCAN FOR DELIMITER
	SLLS	R3,8			:NO...ACCUMULATE CHARS
	STBR	R0,R3
	J	TOKEN			:AND GET ANOTHER CHAR
TOKEN1	HS	0
	L	R4,R4SAV,,		:RESTORE R4
TOKEN2	TI	R3,0000		:HAVE WE 4 CHARS ALREADY?
	JNR	R4			:YES...RETURN TOKEN IN R3
	SLLS	R3,8			:NO...JUSTIFY IT
	JBS	TOKEN2			:AND REPEAT

TOKEN3	HS	0			:HANDLE BACKSPACE IN TOKEN
	SIS	R4,1			:ONE LESS CHAR
	CHI	R4,4			:IF AFTER BACKSPACE TOKEN IS => 4
	JGE	TOKEN			: JUST DECRIMENT COUNTER
	SRLS	R3,8			:ELSE... DROP 1 CHARACTER
	J	TOKEN			:AND GET NEXT CHAR.

:	UTILITY ROUTINE TO READ A NUMBER
:	USES R0-R3
:	EXPECTS RADIX IN R4
:	LINK ON R5
:	ABORTS IF FIRST NON-DELIMITER IS NOT DIGIT
:	ELSE RETURNS NUMBER IN R0
DS.NUM	JAL	R1,DS.GCH		:GET NEXT CHAR
	JBS	DS.NUM;	 NOPR	0			:^W...IGNORE
	JBS	DS.NUM;	 NOPR	0			:^A...IGNORE
	JAL	R2,DS.DEL		:CHECK FOR DELIMITER CHAR
	J	DS.NUM
	JAL	R2,DS.DIG		:TEST IF CHAR IS DIGIT
	J	DS.ILL			:NOT A DIGIT - GIVE ERROR MESSAGE
	CLR	R0,R4
	JGE	DS.ILL			:DIGIT IS BIGGER THAN RADIX...ABORT
	LR	R3,R0			:PUT FIRST DIGIT INTO ACCUMULATOR
NUMBER	JAL	R1,DS.GCH		:READ NEXT CHAR
	J	DS.NUM			:^W...START OVER
	J	DIVIDE			:^A...TOSS LAST DIGIT
	JAL	R2,DS.DEL		:CHECK FOR DELIMITER
	LR	R0,R3;	 JR	R5	  :YES
	JAL	R2,DS.DIG		:SKIP IF DIGIT
	J	DS.ILL			:NO...ABORT
	CLR	R0,R4
	JGE	DS.ILL			:RADIX ERROR...BITCH
	MR	R2,R4			:BUILD NUMBER
	AR	R3,R0			:ADD NEW DIGIT
	J	NUMBER			:GET NEXT DIGIT
DIVIDE	LIS	R2,0			:GOT A ^A...MAKE DOUBLE-PRECISION ARG.
	DR	R2,R4			:QUOTENT INTO R3, WHERE WE WANT IT
	J	NUMBER			:NOW GO BACK FOR MORE DIGITS

:	DIGIT TEST
:	CHECK CHARACTER READ...SKIP RETURN IF DIGIT
:	THEN R0=BINARY VALUE OF HEX DIGIT
:	USES R1, LINK ON R2
DS.DIG	JAL	R1,DS.CUC		:CONVERT TO UPPER CASE
	LR	R1,R0			:COPY CHAR
	SHI	R1,0B0			:IS IT "0"?
	JLR	R2			:RETURN IF LESS THAN "0"
	SIS	R1,0B9-0B0		:IS IF "9"
	JLEFS	DIGIT			:LESS THAN "9" THEN A GOOD DIGIT
	SIS	R1,0C1-0B9		:IS IT "A"?
	JLR	R2			:RETURN IF LESS THAN "A"
	SIS	R1,0C6-0C1		:IS IF "F"?
	JGR	R2			:RETURN IF GREATER THAN "F"
	SIS	R0,7			:0A - "A" (PARTIAL CONVERSION)
DIGIT	SHI	R0,0B0			:"0"
	J	4,R2			:SKIP RETURN

:	CHECK FOR DELIMITER
:	LINK	R2
:	USES	R0,R1
:	SKIP-4 RETURN UNLESS (R0) IS A DELIMITER CHARACTER
DS.DEL	LHI	R1,DLEN-1		:NUMBER OF DELIMITER CHARS
	STB	R0,DS.DLM,,		:SAVE DELIMITER
DELIM	CLB	R0,DLIST,R1		:COMPARE TO A DELIMITER
	JER	R2			:RETURN IF DELIMITER
	SIS	R1,1			:CHECK NEXT DELIMITER
	JGEBS	DELIM			:LOOP IF ANY MORE DELIMITERS
	J	4,R2			:SKIP RETURN
:	LIST OF DELIMITER CHARS
DLIST	AC	' ,'			:BLANK,","
	BC	8D,8A,89		:CR,LF,HT
DLEN	EQ	.-DLIST			:NUMBER OF DELIMITER CHARS

:	INPUT A CHARACTER
:	LINK	R1
:	NORMAL RETURN:  ^W INPUT...FLUSH ENTRY
:	SKIP-4 RETURN:  ^A or ^H INPUT...FLUSH LAST CHAR
:	SKIP-8 RETURN: CHAR IN R0 (HIGH-BIT ON)
:	ABORTS TO COMMAND SCANNER ON "ESC"
DS.GCH	SVC	IN,0F			:GET THE CHAR
	J	DS.GCH
	OHI	R0,80			:SET HIGH-ORDER BIT
	CLHI	R0,9B			:CHECK FOR ESCAPE
	 JE	DSTART			:ABORT, PROCEED WITH PROMPT IF SO
	CLHI	R0,97			:CHECK FOR ^W
	 JER	R1			:NORMAL RETURN
	CLHI	R0,81			:CHECK FOR ^A
	 JE	4,R1			:SKIP-4 RETURN
	CLHI	R0,88			:CHECK FOR ^H
	 JN	8,R1			:NO, SKIP-8 RETURN, CHAR IN R0

	SVC	K.OUT,BKSPAC		:BACK SPACE
	J	4,R1			:SKIP-4 RETURN FOR ^H

:	CONVERT CHAR IN (R0) TO UPPER CASE
:	LINK ON R1
DS.CUC	CLHI	R0,0E1			:COMPARE WITH "a"
	JLR	R1			:EXIT IF IT CAN'T BE LOWERCASE
	CLHI	R0,0FA			:COMPARE WITH "z"
	JGR	R1			:NOT LOWER CASE...JUST RETURN
	SHI	R0,20			:LOWER CASE...CONVERT TO UPPER
	JR	R1			:AND RETURN

	EM

  EI	:(DB.STA)
	SUBTTL	ISIS Ring Handling Routines	- FRING.LIB
:******************************************************************
:
:	This program is the sole property and confidential
:	information of Tymshare, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.
:
:*******************************************************************
	RA	0		:	FRING.LIB

:	ISIS RING HANDLERS

:	This package is the fast, efficient ring handler set
:	The following CONSTRAINTS apply:
:	1.  Once started, register 14 or 15 is dedicated to that
:		operation, until it is "ended".
:	2.  If a new operation is started before the previous operation is
:		"ended", the previous operation is aborted, and the
:		appropriate ring is effectively left unchanged.
:
:	This package now permits simultaneous input and output!!!
:		R15 is used for output operations
:		R14 is used for input operations

:*: NOTE: ISIS II will soon use negative indexing, like this ring package.
:*:	To convert this package, remove all lines with ':*:' in them,
:*:	and change all occurrences of 'LHL R15/R14' to 'LH R15/R14'.

:	The package contains both utility and primitive routines:

:	utility routines are called with link R5,
:	they preserve registers R6--R14.
:	OCS	Output Canned String
:		R2 = port #, R3 = pointer to string (SC format)
:		OCS will output string as a data message to the specified
:		port. OCS goes to completion, and "ends the operation.
:	OCM	Output Canned Message
:		R2 = port #, R3 = pointer to string (SC format)
:		OCM will output the string as a message to the specified port
:		OCM goes to completion, and "ends the operation.
:	OBS	Output Byte String
:		R2 = number of characters, R3 = pointer to string
:		OBS will output specified string into the current message
:		message must have already been "started", and is NOT "ended".

:	primitive input routines.  All link on R4, & preserve R1-R3, R5-R13, R15:
:	LOOK	Determine if an input message exists...normal return if not
:		skip (4) return if so, and then:
:		R1 = port number
:		R2 = message type code (peek)
:		On skip return, condition codes are set such that JE will
:		succeed on port 0.  The port number will have been removed
:		from the message but the message code will not have been
:		removed (you get a peek at it).
:	GETCH	Get a character, returned in R0.
:	GETH	Get a halfword, returned in R0.  An even number of bytes 
:		should have been removed previously for expected results.
:	GETW	Get a word, returned in R0.  An even number of halfwords 
:		should have been removed previously for expected results.
:	FLUSH	Flush away ("end") remainder of input message.  R0 is number
:		of bytes remaining to flush.
:	ELIR	End-Logical-Input-Record.  "Ends" current message, sets
:		up pointers for next message.

:	Primative output routines.  All link on R4, preserve R1-R3, R5-R14,
:	unless used for arguments, or otherwise specified:
:	SPACE	Returns R0 = number of characters of space available in	
:		output ring. Sets up R15 for "start" of message.
:	ROOM	R0 = number of characters required for next message,
:		returns when that much room is available in output ring.
:		MAY DISMISS.
:		sets up R15 for "start" of message. SMASHES R1.
:	SLOR	Start Logical Output Record.
:		R0 = number of bytes required.
:		R1 = port #
:		R2 = message type code.
:		Provides function of ROOM, PUTH, and PUTCH for first 3 chars
:		of message. MAY DISMISS. SMASHES R3.
:	PUTCH	places character in R0 in next position of ring.
:	PUTH	places halfword in R0 in next position of ring.  Even number
:		of bytes have been output previously in this message.
:	PUTW	places word in R0 in next position of ring.  Even number of
:		halfwords should have been output previously in this message.
:	ELODR	End Logical Output Data Record
:		places byte count into message type to make data message,
:		then "ends" message.  Smashes R0, R1.
:	ELOR	End Logical Output Record
:		"ends" message.

:	CONVENTIONS:
:	ROUTINES USE DEDICATED REGISTERS:
:	R15	OUTPUT RING INDEX
:	R14	INPUT RING INDEX
:
:	NOTE....
:		IRSIZE AND ORSIZE MUST EACH BE LESS THAN 32K.

	GL	IRING,ORING,IRSIZE,ORSIZE
	GL	OCS,OCM,OBS
	GL	LOOK,GETCH,GETH,GETW,FLUSH,ELIR
	GL	SPACE,ROOM,SLOR,PUTCH,PUTH,PUTW,ELODR,ELOR

	MO	.,RING
NFMI	EQ	0		:RELATIVE INDEX OF NEXT-FILL-MESSAGE-INDEX
CEI	EQ	2		:RELATIVE INDEX OF CURRENT-EMPTY-INDEX
RING	EQ	4		:RELATIVE INDEX OF START OF RING DATA

:	DEFINE DATA AREA
	SEG	A.RING		:RINGS IN RING AREA

:	THE DISPATCHER OUTPUT RING
ORING	HS	0		:OUTPUT BLOCK START ADDRESS
	HC	0		:OUTPUT NEXT FILL MESSAGE INDEX
	HC	0		:OUTPUT CURRENT ENTRY INDEX
	BS	ORSIZE		:THE OUTPUT RING

:	THE DISPATCHER INPUT RING
IRING	HS	0		:INPUT BLOCK START ADDRESS
	HC	0		:INPUT NEXT FILL MESSAGE INDEX
	HC	0		:INPUT CURRENT EMPTY INDEX
	BS	IRSIZE		:THE INPUT RING

:	CODE AREA
	SEG	A.CODE
:	INPUT ROUTINES

:	LOOK AT A RING ENTRY
:	NORMAL RETURN IF RING EMPTY
:	ELSE SKIP RETURN, PORT RETURNED IN R1
:	MESSAGE TYPE RETURNED IN R2
:	ALL REGISTERS SET UP FOR TRANSFER
:	POSITION IS ADVANCED PAST PORT#
	IF	\LOOK;.LOOK.	 HS	0;	ELSE;LOOK	 HS	0;	EI
	LHL	R14,CEI+IRING,,	:GET CURRENT EMPTY INDEX
	CLH	R14,NFMI+IRING,,	:TEST IF CAUGHT UP
	JER	R4		:EMPTY...NORMAL RETURN
	SHI	R14,IRSIZE	:*: CONVERT TO NEGATIVE INDEX
	LHL	R1,IRING+RING+IRSIZE,R14,	:GET PORT #
	AIS	R14,2		:BUMP POINTER PAST PORT #
	LB	R2,IRING+RING+IRSIZE,R14,	:GET MESSAGE TYPE
	LR	R1,R1		:SET CONDITION CODES
	J	4,R4		:THEN SKIP RETURN

:	GET A CHARACTER FROM THE INPUT RING
:	CHARACTER RETURNED IN R0
GETCH	LB	R0,IRING+RING+IRSIZE,R14,	:GET THE CHAR
	AIS	R14,1		:BUMP INDEX
	JLR	R4		:RETURN IF NOT
	LHI	R14,-IRSIZE	:ELSE FOLD IT
	JR	R4		:AND EXIT

:	GET A HALF-WORD FROM THE INPUT RING
:	ASSUME HAVE REMOVED AN INTEGRAL NUMBER OF HALF-WORDS FROM RECORD
:	HALF-WORD RETURNED IN R0
GETH	LHL	R0,IRING+RING+IRSIZE,R14,	:GET THE DATA
	AIS	R14,2		:BUMP INDEX
	JLR	R4		:RETURN IF NOT
	LHI	R14,-IRSIZE	:ELSE FOLD IT
	JR	R4		:AND EXIT

:	GET A WORD FROM THE INPUT RING
:	ASSUME HAVE REMOVED AN INTEGRAL NUMBER OF WORDS FROM RECORD
:	WORD RETURNED IN R0
GETW	L	R0,IRING+RING+IRSIZE,R14,	:GET THE DATA
	AIS	R14,4		:BUMP INDEX
	JLR	R4		:RETURN IF NOT
	LHI	R14,-IRSIZE	:ELSE FOLD IT
	JR	R4		:AND EXIT

:	FLUSH AN INPUT RECORD
:	NUMBER OF CHARS TO FLUSH IN R0
FLUSH	AR	R14,R0		:ADVANCE RING AND FALL THROUGH

:	END LOGICAL INPUT RECORD
ELIR	AIS	R14,3		:FORCE TO NEXT WORD
	NHI	R14,-4
	JLFS	ELIR2		:NO
	SHI	R14,IRSIZE	:YES
ELIR2
	AHI	R14,IRSIZE	:*: CONVERT TO POSITIVE INDEX
	STH	R14,CEI+IRING,,
	JR	R4		:AND EXIT

:	OUTPUT ROUTINES

:	OUTPUT "CANNED" MESSAGE
:	LINK ON R5
:	R2 = PORT #
:	R3 = POINTER TO STRING (FORMAT: n\B1\...\Bn)
OCM	LB	R0,0,R3		:GET COUNT n
	AIS	R0,5		:COMPUTE SPACE REQUIREMENTS
	NHI	R0,-4
	JAL	R4,ROOM		:INSURE THERE IS ROOM
	LR	R0,R2		:COPY PORT #
	JAL	R4,PUTH		:PLACE PORT NUMBER
	LB	R2,0,R3		:GET COUNT AGAIN
	J	OCS1		:SKIP TO PLACE THE STRING

:	OUTPUT "CANNED" STRING
:	LINK ON R5
:	R2 = PORT #
:	R3 = POINTER TO TEXT STRING (FORMAT n\B1\...\Bn)
OCS	LB	R0,0,R3		GET COUNT n
	AIS	R0,6		:COMPUTE SPACE REQUIREMENTS
	NHI	R0,-4
	JAL	R4,ROOM		:INSURE THERE IS ROOM
	LR	R0,R2
	JAL	R4,PUTH		:PLACE PORT NUMBER
	LB	R2,0,R3
	LR	R0,R2		:GET THE COUNT n
	JAL	R4,PUTCH	:PLACE IT...MESSAGE TYPE 1-7D
OCS1	AIS	R3,1		:BUMP SOURCE CHARACTER POINTER
	LB	R0,0,R3		:GET THE NEXT CHARACTER
	JAL	R4,PUTCH	:PLACE IT INTO RING
	SIS	R2,1		:REDUCE COUNT
	JGBS	OCS1		:REPEAT UNTIL ALL CHARACTERS PLACED
	JAL	R4,ELOR		:END LOGICAL OUTPUT RECORD
	JR	R5		:THEN EXIT

:	OUTPUT A BYTE STRING
:	LINK ON R5
:	R3 = POINTER TO STRING
:	R2 = NUMBER OF CHARACTERS TO OUTPUT FROM STRING
OBS1	AIS	R3,1		:BUMP CHARACTER POINTER
OBS	LB	R0,0,R3		:GET THE NEXT CHARACTER
	JAL	R4,PUTCH	:PLACE IT INTO RING
	SIS	R2,1		:REDUCE COUNT
	JGBS	OBS1		:REPEAT UNTIL ALL CHARACTERS PLACED
	JR	R5		:THEN EXIT

:	FIND SPACE IN THE RING (HOW BIG A MESSAGE IT WILL TAKE)
:	RETURNS R0 = NUMBER OF CHARS OF SPACE
SPACE	LCS	R0,4		:SET MASK
	LHL	R15,NFMI+ORING,,
	NH	R0,CEI+ORING,,	:FORCE EMPTIER TO WORD BOUNDARY
	SR	R0,R15		:SPACE BETWEEN US AND EMPTIER
	JGFS	SPACE1		:SKIP IF NO WRAP-AROUND
	AHI	R0,ORSIZE	:ELSE CORRECT FOR WRAP
SPACE1	SIS	R0,4		:CORRECT FOR POSSIBLE OVERFLOW
	SHI	R15,ORSIZE	:*: CONVERT TO NEGATIVE INDEX
	JR	R4		:AND RETURN

:	INSURE THERE IS ROOM IN THE RING (DISMISS IF NECESSARY)
:	EXPECTS R0 = NUMBER OF CHARACTERS OF SPACE
ROOM	LHL	R15,NFMI+ORING,,
	SHI	R15,ORSIZE	:*: CONVERT TO NEG. INDEX
ROOM1	LCS	R1,4		:SET MASK
	NH	R1,CEI+ORING,,	:FORCE HIM TO WORD BOUNDARY
	SHI	R1,ORSIZE	:*:
	SR	R1,R15		:CHECK RELATIVE POSITIONS
	JGFS	ROOM2		:SKIP IF HE'S AHEAD OF US
	JER	R4		:EQUAL...HE'S EMPTY...GO DO IT
	AHI	R1,ORSIZE		:HE'S BEHIND US
ROOM2	SIS	R1,4		:ALLOW FOR POTENTIAL OVERFLOW
	CR	R0,R1
	JLER	R4		:ROOM EXISTS...GO DO IT
	SVC	DISMISS,0
	J	ROOM1		:AND GO TRY AGAIN

:	START LOGICAL OUTPUT RECORD
:	PROVIDES FUNCTION OF ROOM, PUTH, & PUTCH FOR FIRST 3 CHARS OF MESSAGE
:	R0 = NUMBER OF CHARACTERS OF SPACE REQUIRED
:	R1 = PORT #
:	R2 = MESSAGE CHARACTER CODE
SLOR	LHL	R15,NFMI+ORING,,
	SHI	R15,ORSIZE	:*: CONVERT TO NEG. INDEX
SLOR1	LCS	R3,4		:SET A MASK
	NH	R3,CEI+ORING,,	:FORCE RECEIVER TO WORD BOUNDARY
	SHI	R3,ORSIZE	:*:
	SR	R3,R15
	JGFS	SLOR2
	AHI	R3,ORSIZE	:ACCOUNT FOR POSSIBLE RING FOLDING
SLOR2	SIS	R3,4		:ALLOW FOR POTENTIAL OVERFLOW
	CR	R3,R0
	JGEFS	SLOR3		:SKIP IF WE CAN GO
	SVC	DISMISS,0
	JBS	SLOR1
SLOR3	STH	R1,ORING+RING+ORSIZE,R15,	:OK...PLACE MESSAGE
	STB	R2,2+ORING+RING+ORSIZE,R15,
	AIS	R15,3		:BUMP PAST THESE CHARACTERS
	JR	R4		:AND EXIT

:	PUT A CHARACTER INTO THE RING
:	R0 = CHARACTER
PUTCH	STB	R0,ORING+RING+ORSIZE,R15,	:PLACE THE CHARACTER
	AIS	R15,1		:BUMP INDEX
	JLR	R4		:SKIP IF NOT
	LHI	R15,-ORSIZE	:ELSE WRAP AROUND
	JR	R4		:AND EXIT

:	PUT A HALF-WORD INTO THE RING
:	R0 = HALF-WORD
PUTH	STH	R0,ORING+RING+ORSIZE,R15,	:PLACE THE HALF-WORD
	AIS	R15,2		:BUMP INDEX
	JLR	R4		:EXIT IF NOT
	LHI	R15,-ORSIZE	:ELSE WRAP AROUND
	JR	R4		:AND EXIT

:	PUT A WORD INTO THE RING
:	R0 = WORD
PUTW	ST	R0,ORING+RING+ORSIZE,R15,	:PLACE THE WORD
	AIS	R15,4		:BUMP INDEX
	JLR	R4		:SKIP IF NOT
	LHI	R15,-ORSIZE	:ELSE WRAP AROUND
	JR	R4		:AND EXIT

:	END LOGICAL OUTPUT DATA RECORD
ELODR	LHL	R1,NFMI+ORING,,	:GET START OF THIS MESSAGE
	SHI	R1,ORSIZE	:*: CONVERT TO NEG. INDEX
	LR	R0,R15		:COPY MESSAGE END
	SR	R0,R1		:COMPUTE SIZE OF THIS MESSAGE
	JGEFS	ELODR2		:SKIP IF NO WRAP-AROUND
	AHI	R0,ORSIZE		:ELSE CORRECT FOR WRAP
ELODR2	SIS	R0,3		:MAKE ALLOWANCE FOR HEADER
	JER	R4		:EXIT IF ZERO LENGTH MESSAGE
	STB	R0,2+ORING+RING+ORSIZE,R1,	:INSERT MESSAGE TYPE INTO MESSAGE
				:AND FALL THROUGH

:	END LOGICAL OUTPUT RECORD
ELOR	AIS	R15,3
	NHI	R15,-4
	JLFS	ELOR2
	LHI	R15,-ORSIZE	:FOLD IF NECESSARY
ELOR2
	AHI	R15,ORSIZE	:*: CONVERT BACK
	STH	R15,NFMI+ORING,,	:NOW ADVANCE POINTER TO NEXT MESSAGE
	JR	R4		:AND EXIT
	EM
	SUBTTL	ISIS STARTUP AND CRASH LIBRARY	- CRASH.LIB
        REMARK  %CRASH.LIB    VERSION 1.00        06-10-86 AWT
	REMARK	%THIS VERSION USES RX3 INSTRUCTION FORMAT

:******************************************************************
:
:	This program is the sole property and confidential
:	information of Tymshare, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.
:
:*******************************************************************
	RA	0		:	CRASH.LIB	MFR 07/14/81

:       Set UPSW to turn off tracing.
:       Added CTIME and CRTIME to save crash times in GMT.
:       Added a NCRSAV option to keep old copies of crash tables.
:         April 13, 1983 AWT
:
:	Changed the supervisor's log message to report the PRODID.
:	Sep. 20, 1982 SCY.
:	ENTRY2 (restart service) changed to clear input and output
:	rings PRIOR to issuing Restart SVC to prevent crash-loop if
:	Dispatcher has crashed. June 17, 1982 MDS.

:			ISIS - II Version
:
	GL	CRASH,CRASHC,CPOINT,CFROM,CRREG,ENTRY,START,CRAT,CRSHCT,CRSTOP
        GL      PRODID,NCRSAV,CTIME,CRTIME,EXCRSH
	MO	.,CRASH


:	Generalized crash package.
:	Handles both software and hardware crashes.  On any crash, the
:	registers are saved in CRXREG, and CRSHCT is incremented.
:	Software crashes occur via  JAL R10,CRASH .  CRASH saves (R10) in cell
:	CPOINT.  Software crashes may be "good" or "bad"...if "good", the
:	calling sequence is:

:		JAL	R10,CRASH
:						from a bad one
:		HC	0		:this key distinguishes a good crash
:		BC	4*L,Y		:first byte is 4*register linked to
:						routine, Y is the reason
:	then register (L) is saved in CFROM, and Y is saved in CRASHC

:	in the event of a hardware failure, CPOINT contains the instruction
:	address at the time of failure, CRASHC contains the failure reason,
:	and CFROM is set =-1.

:	On completion of crash, transfers to label START, defined
:	in the user code.
:
:	The symbol CRSTOP may be set to 0 or 1.  If 1 the crash routine will
:	be executed only once.  the second time through the crash area will
:	be set up as specified above and then registers will be restored to
:	their entry value and the slot will be frozen. If it is thawed it
:	will restart.
:
:       The symbol NCRSAV defines the number of crash tables to be saved.
:       It will be set to 1 by default. (In TYMFIL CRSHTB macro is used
:       to define NCRSAV)
:
:       Entering :R CRAT,CRTSIZ (or 4C) will dump the last 
:       crash table, CRAT+CRTLEN (or 50),CRTSIZ will dump the    
:       previous crash table and so on.
:
:       CTIME,4 gives the last crash time (in GMT), CTIME+CRTLEN,4
:       gives the previous crash time and so on.
:
:	The symbol EXCRSH, if set to 1, allows a JAL to label
:	CRSH.P out of the crash routine for extended crash processing.
:	The link is R5.  EXCRSH is defaulted to 0.
:
:

  IF	\CRSTOP
  ELSE
CRSTOP	EQ	0
  EI
  
  IF    \NCRSAV                 :# OF CRASH TABLES TO SAVE
  ELSE                          :IT MAY BE DEFINED IN TYMFIL
NCRSAV  EQ      1               :OTHERWISE IT IS 1 BY DEFAULT
  EI

  IF	\EXCRSH			:DEFAULT TO NO EXTENDED CRASH HANDLING
  ELSE
EXCRSH	EQ	0
  EI


CRTENT  EQ      .               :CRASH TABLE ENTRY
        ORG     0
CRSHCT	HS	1		:CRASH COUNT...HOW MANY TIMES CRASHED
CRASHC	HS	1		:CRASH CODE (INIT'ED TO MANUAL RESTART)
CPOINT	HS	2		:WHERE CRASH OCCURED
CFROM	HS	2    		:WHERE CRASH WAS CALLED FROM
CRXREG	HS	20		:CRASH REGISTER SAVE AREA
CRTSIZ  WS      0               :SIZE OF CRASH TABLE WITHOUT CRTIME
CRTIME  WS      1               :REAL TIME OF CRASH (GMT)
CRTLEN  WS      0               :LENGTH OF CRASH TABLE WITH CRTIME
        ORG     CRTENT  

        SEG     A.DATA
        HS      0
CTIME   WS      1               :STORAGE FOR CRASH TIME OF LAST CRASH
CRAT    BS      CRTLEN*NCRSAV   :STORAGE FOR CRASH TABLE(S)
CRREG   EQ      CRAT+CRXREG
RGSTOR  WS      10              :TEMPORARY STORAGE FOR REGISTERS
FGNDFL	HS	1		:FOREGROUND FLAG

TRBOFF  WC      0,FAIL0         :TRACE BIT OFF, GO TO FAIL0
TRCOFF  WC      0,CRASH0        :TRACE BIT OFF, GO TO CRASH0
PSWSAV  WC      0,START         :RESTORE PSW,  GO TO INITIALIZATION CODE
CHFLAG  WC      0               :USED FOR ANY CHANGES ON PSW


	SEG	A.CODE		:CODE AREA
CRSHCD	BC	1	:MANUAL RESTART
	BC	0	:POWER FAILURE
	BC	0E	:PARITY ERROR
	BC	10	:DISPATCHER CRASH
	BC	11	:ILLEGAL INSTRUCTION
	BC	12	:ILLEGAL SVC
	BC	13	:SYSTEM CRASH
	BC	14	:PROTECTION VIOLATION
	BC	15	:NON-RECOVERABLE DEVICE CHECK
	BC	16	:WATCH FROG TIMER - - TIME OUT

	RA	0
:	GENERAL MACHINE FAILURE
FAIL	HS	4		:PSD SAVED HERE
	HS	4		:R0,R1 SAVED HERE
        ST      R0,RGSTOR,,     :SAVE R0
        ST      R2,RGSTOR+4,,   :SAVE R2
        JAL     R2,SAVPSW       :SAVE CURRENT PSW
        L       R0,RGSTOR,,     :RESTORE R0
        L       R2,RGSTOR+4,,   :RESTORE R2
        UPSW    TRBOFF,,        :TRACE BIT OFF AND CONTINUE
FAIL0   LB      R0,CRSHCD,R1    :CONVERT CRASH REASON
	CLHI	R0,12		:TEST IF ILLEGAL SVC
	JNFS	FAIL1		:NO...SKIP
	LHL	R0,FGNDFL,,	:DID FOREGROUND CAUSE THE CRASH?
	JN	ENTRY2		:YES....JUMP OVER
FAIL1   STM     R0,RGSTOR,,     :SAVE REGISTERS
        JAL     R2,PSHTBS       :PUSH DOWN CRASH TABLES
        L       R1,GMT,,        :GET GMT CLOCK
        ST      R1,CTIME,,      :SAVE IT AS THE CRASH TIME
        LM      R0,RGSTOR,,     :RESTORE REGISTERS
        STM     R2,CRAT+CRXREG+8,, :SAVE THE REGISTERS
        STH     R0,CRAT+CRASHC,,  :SAVE CRASH CODE
        LM      R12,FAIL          :GET THE REST
        STM     R14,CRAT+CRXREG,,  :SAVE R0 & R1
        ST      R13,CRAT+CPOINT,, :SAVE FAILURE ADDRESS
	LCS	R1,1
        ST      R1,CRAT+CFROM,,   :FLUSH PLACE CALLED FROM
        J       ENTRY1            :AND SKIP TO START UP AGAIN



:	CRASH ROUTINE AND GENERAL INITIALIZER
:	IF "GOOD" CALL TO CRASH, HAS HALFWORD 0'S FOLLOWING,
:	THEN BYTE WITH 4*LINK REGISTER, THEN BYTE WITH CRASH REASON

CRASH   ST      R0,RGSTOR,,     :SAVE R0
        ST      R2,RGSTOR+4,,   :SAVE R2         
        JAL     R2,SAVPSW       :SAVE CURRENT PSW
        L       R0,RGSTOR,,     :RESTORE R0
        L       R2,RGSTOR+4,,   :RESTORE R2
        UPSW    TRCOFF,,        :TRACE BIT OFF AND CONTINUE
CRASH0  STM     R0,RGSTOR,,     :SAVE REGISTERS
        JAL     R2,PSHTBS       :PUSH DOWN THE CRASH TABLES
        L       R1,GMT,,        :GET GMT CLOCK
        ST      R1,CTIME,,      :SAVE IT AS THE CRASH TIME
        LM      R0,RGSTOR,,     :RESTORE REGISTERS
        STM     R0,CRAT+CRXREG,, :SAVE REGISTERS AND
        ST      R10,CRAT+CPOINT,,                    
	LIS	R0,$A10		:FAKE UNKNOWN CRASH
	LCS	R1,1		:FROM NOWHERE
	LHL	R2,0,R10	:CHECK WHERE CALLED FROM
	JNFS	CRASH1		:NOT KNOWN...USE DEFAULT
	LB	R0,3,R10	:GET CRASH CONDITION
	LB	R2,2,R10	:GET CALLING REGISTER
        L       R1,CRAT+CRXREG,R2,, :GET CONTENTS OF REGISTER
        
CRASH1  STH     R0,CRAT+CRASHC,, :SAVE CRASH CODE
        ST      R1,CRAT+CFROM,,  :SAVE PLACE CRASHED FROM
	JFS	ENTRY1

:	ENTER HERE WITH RESTART
ENTRY	LIS	R0,1		:LOAD CRASH CODE REGISTER
        STH     R0,CRAT+CRASHC,, :STORE IT
ENTRY1	LIS	R1,1
        AHM     R1,CRAT+CRSHCT,, :SAVE INTERESTING DATA

  IF	CRSTOP		:IF STOPPING ON CONSECUTIVE CRASHES
	CLHI	R0,1
	JLE	ENTRY2		:IF POWER FAILURE OR MANUAL RESTART
	OHI	R0,0CC00	:CRASH INDICATOR FOR FRONT PANEL
	STH	R0,FPANEL,,	:SET PANEL TO BAD CRASH
   IF	EXCRSH
	JAL	R5,CRSH.P,,	:GO DO EXTENDED CRASH PROCESSING
   EI	EXCRSH
        LM      R0,CRAT+CRXREG,, :RESTORE REGISTERS
	SVC	SYS,HALT.	:HALT THE SLOT
  EI	CRSTOP

	LIS	R0,1		:WANT SECOND WORD OF PSD
	SVC	SYS,RFPSD.	:READ FOREGROUND PSD
	CLI	R0,.		:TEST IF FOREGROUND IS EXECUTING THIS INSTRUCTION
	JNFS	ENTRY2		:SKIP IF NOT
	STH	R0,FGNDFL,,	:SET THE FOREGROUND FLAG

ENTRY2		: NOW RESET OUTPUT RING, REPORT CRASH
  IF	CRSTOP
  ELSE
   IF	EXCRSH
	JAL	R5,CRSH.P,,	:GO DO EXTENDED CRASH PROCESSING
   EI	EXCRSH
  EI	CRSTOP
	LIS	R0,0
	ST	R0,ORING,,	:EMPTY OUTPUT RING
	ST	R0,IRING,,	:EMPTY INPUT RING

	LA	R0,FAIL		:LOAD TRAP AREA ADDRESS
	SVC	SYS,RSTRT.	:RESTART SVC
	JAL	R10,CRASH	:NON-SKIP RETURN...CRASH


	LIS	R0,0
	STH	R0,FGNDFL,,	:CLEAR THE FOREGROUND FLAG

	JAL	R4,SPACE,,	:SET UP FOR DIAGNOSTIC
	LHI	R0,0300
	JAL	R4,PUTW,,	:PORT 0 + DIAGNOSTIC MESSAGE + PAD
	LHL	R0,CRAT+CRSHCT,,
	JAL	R4,PUTCH,,	:HW4 LOW = CRASH COUNT
	LIS	R0,0
	JAL	R4,PUTCH,,	:RESERVED BYTE
	LIS	R0,1
	JAL	R4,PUTCH,,	:REPORT TYPE = 1
	LHL	R0,CRAT+CRASHC,,
	JAL	R4,PUTCH,,	:HW3 HIGH = CRASH CODE
	LHI	R0,PRODID
	JAL	R4,PUTCH,,	:HW2 LOW IS PRODUCT ID
	JAL	R4,ELOR,,	:END LOGICAL OUTPUT RECORD
        L       R1,CHFLAG,,     :SEE IF PSW HAS BEEN CHANGED
        CLHI    R1,1
        JNFS    CURPSW          :NO CHANGE, GO TO USE CURRENT PSW
        LIS     R1,0
        ST      R1,CHFLAG,,     :RESET CHFLAG FOR FUTURE PSW CHANGE
        UPSW    PSWSAV,,          :INITIALIZE WITH RESTORED PSW
CURPSW  J       START,,         :INITIALIZE WITH CURRENT PSW

SAVPSW  LIS     R0,1            :GET PC OF BACKGROUND PSD
        ST      R0,CHFLAG,,     :ALSO INDICATE PSW WILL BE MODIFIED
        SVC     SYS,RBPSD.      :READ BACKGROUND PSD
        CLI     R0,.            :IS IT RUNNING?
        JNFS    ISFGND          :NO, IT MUST BE FOREGROUND JOB
        LIS     R0,0            :GET PSW OF BACKGROUND JOB
        SVC     SYS,RBPSD.
        ST      R0,PSWSAV,,     :SAVE IT
        JR      R2              :RETURN
ISFGND  LIS     R0,0            :GET PSW OF FORGROUND JOB
        SVC     SYS,RFPSD.
        ST      R0,PSWSAV,,     :SAVE IT
        JR      R2              :RETURN


PSHTBS  LHI     R1,CRTLEN*NCRSAV-CRTLEN*2
        JLR     R2              :IF ONLY 1 CRASH TABLE, SKIP AND RETURN
PUSHIT  LM      R6,CRAT,R1,,    :PUSH DOWN THE CRASH TABLE
        STM     R6,CRAT+CRTLEN,R1,,
        LM      R6,CRAT+CRTLEN/2,R1,,
        STM     R6,CRAT+CRTLEN+CRTLEN/2,R1,
        SHI     R1,CRTLEN
        JGEBS   PUSHIT
        L       R1,CTIME,,
        ST      R1,CRAT+CRTSIZ,,
        JR      R2              :RETURN
         
	EM

	SUBTTL	Standard Timeout Routine Library	- TIMOUT.LIB
:******************************************************************
:
:	This program is the sole property and confidential
:	information of Tymshare, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.
:
:*******************************************************************
	RA	0		:	TIMOUT.LIB

:	This package contains the standard timeout routines
:	The following parameters MUST be defined on entry:
:	NTOUT	number of timeout entries which may be active at any one time

:	expects to JAL R10,CRASH if list overflows

:	six symbols are declared:
:	IZT	called at initilization, link on R0
:	TIMOUT	to be called periodicaly, link on on R0
:		will in turn jump to any routines which should be serviced:
:		R0 = routine address
:		R1 = current fast-clock time.
:	TORET	routines called by TIMOUT should exit to here
:	TOPUT	any code may call this to place an entry on timeout list:
:		link on R5...R6--R15 preserved
:		R0 = address to transfer to
:		R1 = next time to call routine
:	TOGET	called to delete an entry already on timout list
:		link on R5...R6--R15 preserved
:		R0 = routine address...entry with this address will be deleted
:	TONOW	called to flush an entry, and execute it NOW!
:		link on R5...NO registers preserved! NOW!
:		routine address in R0
:	NOTE...when a routine is called from timeout list, it is removed from list,
:	and must call TOPUT to be called again.
:	ALSO...TOGET and TONOW both do normal returns, even if no entry is found.

	GL	IZT,TIMOUT,TORET,TOPUT,CRASH,TOGET,TONOW,NTOUT
	MO	.,TIMOUT

	SEG	A.DATA		:PLACE IN DATA AREA

  IF	6-.
	BS	6-.		:UNUSED 
  EI
TO9	HS	2		:link for timeout processor
LSIZ	EQ	$A 10		:number of bytes in list entry
TLIST	BS	(NTOUT+1)*LSIZ	:timeout list
:				active list entry = halfword chain pointer
:				word routine address
:				word time of next activiation

:		free list pointer is at TLIST
:		active list chain pointer is at TLIST+2
:	CODE SEGMENT
	SEG	A.CODE

TORET	L	R0,TO9		:TIMEOUT ROUTINES EXIT HERE
:	CALL NEXT TIME OUT ROUTINE (IF ANY) THAT HAS BECOME DUE
TIMOUT	LHL	R2,TLIST+2	:GET ACTIVE LIST POINTER
	JER	R0		:EXIT IF NO ACTIVE ENTRIES
	L	R1,FASTC,,	:GET CURRENT CLOCK TIME
	CL	R1,TLIST+6,R2	:IS 1ST ACTIVE LIST TIMEOUT DUE
	JLR	R0		:NO TIMEOUTS DUE TO PROCESS
	ST	R0,TO9		:ROUTINE MUST TERMINATE BY JUMPING TO TORET
	LHL	R3,TLIST,R2
	STH	R3,TLIST+2	:SHORTEN ACTIVE LIST
	LHL	R4,TLIST
	STH	R4,TLIST,R2	:SPLICE INTO HEAD OF FREE CHAIN
	STH	R2,TLIST
	L	R0,TLIST+2,R2
	JR	R0		:FETCH ADRS AND ENTER TIMED OUT ROUTINE

:	PUT ADRS R0 TO EXECUTE AT TIME R1 ON ACTIVE TIMEOUT LIST. LINK=R5.
TOPUT	LIS	R2,2		:FIND ACTIVE LIST ENTRY BETWEEN EARLIER, LATER TIMEOUT.
TPT1	LR	R3,R2
	LHL	R2,TLIST,R2	:CHECK NEXT TIMEOUT ENTRY
	JEFS	TPT2		:ACTIVE LIST IS EMPTY
	CL	R1,TLIST+6,R2	:IS IT EARLIER THAN ARGUMENT DUE TIME
	JGBS	TPT1		:YES, CONTINUE TIL R3 IS EARLIER AND R2 IS EQUAL OR LATER
TPT2	LHL	R4,TLIST
	JGFS	TPT3
	JAL	R10,CRASH,,	:FREE LIST EXHAUSTED
	BC	0,0,4*R5,0F	:FLAG--LINK R5, TYPE 15d CRASH
TPT3	STH	R4,TLIST,R3	:MAKE EARLIER ACTIVE LIST ENTRY POINT TO NEW ENTRY
	LHL	R3,TLIST,R4
	STH	R3,TLIST	:SHORTEN FREE LIST
	STH	R2,TLIST,R4	:HAVE NEW ENTRY POINT TO NEXT GREATER TIMEOUT ENTRY
	ST	R0,TLIST+2,R4
	ST	R1,TLIST+6,R4
	JR	R5		:STORE ARGUMENTS AND RETURN

TONOW	LIS	R1,2		:SEARCH ACTIVE LIST
TONOW1	LR	R2,R1		:COPY CURRENT ENTRY POINTER
	LHL	R1,TLIST,R2	:GET NEXT ENTRY
	JER	R5		:LIST EXHAUSTED...EXIT
	CL	R0,TLIST+2,R1	:CHECK THIS ENTRY
	JNBS	TONOW1		:LOOP IF NOT MATCH
	LHL	R3,TLIST,R1	:WE GOT A MATCH
	STH	R3,TLIST,R2	:UNLINK THIS ENTRY
	LHL	R3,TLIST	:GET START OF FREE LIST
	STH	R3,TLIST,R1	:LINK THIS ENTRY TO FREE LIST
	STH	R1,TLIST	:PLACE ON FREE LIST
	ST	R5,TO9		:SAVE RETURN ADDRESS
	JR	R0		:AND GO TO ROUTINE

TOGET	LIS	R1,2		:SEARCH ACTIVE LIST
TOGET1	LR	R2,R1		:COPY CURRENT ENTRY POINTER
	LHL	R1,TLIST,R2	:GET NEXT ENTRY
	JER	R5		:LIST EXHAUSTED...EXIT
	CL	R0,TLIST+2,R1	:CHECK THIS ENTRY
	JNBS	TOGET1		:LOOP IF NOT MATCH
	LHL	R3,TLIST,R1	:WE GOT A MATCH
	STH	R3,TLIST,R2	:UNLINK THIS ENTRY
	LHL	R3,TLIST	:GET START OF FREE LIST
	STH	R3,TLIST,R1	:LINK THIS ENTRY TO FREE LIST
	STH	R1,TLIST	:PLACE ON FREE LIST
	JR	R5		:AND EXIT

IZT	LHI	R1,NTOUT*LSIZ	:INITIALIZE TIMEOUT FREE LIST
	LIS	R2,0		:0 TERMINATES LIST
	STH	R2,TLIST+2	:ACTIVE LIST IS EMPTY
	STH	R2,TLIST,R1	:TERMINATE FREE LIST
	STH	R1,TLIST-LSIZ,R1
	SIS	R1,LSIZ
	JGBS	.-6
	JR	R0
	EM
	SUBTTL	Data Conversion Routines	- CONVRT.LIB
:******************************************************************
:
:	This program is the sole property and confidential
:	information of Tymshare, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.
:
:*******************************************************************
:
	RA	0
:
	MO	.,CONVRT
:
	GL	BINDEC
:
:*****************************************************************
:
:	BINDEC IS A ROUTINE TO CONVERT INTERNAL BINARY REPRESENTATION OF
:	DATA TO ASCII DECIMAL CHARACTERS.
:
:	ARGUMENTS: R9 CONTAINS THE BINARY NUMBER
:	           R10 CONTAINS NUMBER OF DIGITS OF OUTPUT
:	           R11 POINTS TO OUTPUT AREA
:	LINK ON R4
:
:****************************************************************
:
	SEG	A.DATA
:
RSAVE	HS	10	:REGISTER SAVE AREA
:
	SEG	A.CODE
:
DIGIT	AC	/0123456789ABCDEF/
:
:	FIRST CHECK FOR A NEGATIVE NUMBER
:		IF FOUND, PUT A LEADING '-' (MINUS SIGN) IN FIELD
BINDEC	STM	R8,RSAVE	:PRESERVE REGISTERS
	LR	R9,R9		: TEST FOR NEGATIVE NUMBER
	JGEFS	NOTNEG		:JUMP IF NOT NEGATIVE
	LHI	R12,$0 00AD	:'ASCII '-'
	STB	R12,0,R11
	SIS	R10,1		: ROOM FOR ONE LESS DIGIT
	AIS	R11,1		: DITTO
	JLE	RTRN		:NO ROOM FOR DIGIT AFTER MINUS SINE
:	COMPLEMENT THE NUMBER TO POSITIVE
	XI	R9,-1
	AIS	R9,1
NOTNEG	SIS	R11,1
	LIS	R12,$A 10	: DIVISOR
DIVIDE	SR	R8,R8		: CLEAR HI ORDER BITS OF DIVIDEND
	DR	R8,R12		:GET LOW DIGIT IN R9
	LB	R13,DIGIT,R8	:GET ASCII EQUIVALENT OF DEC NUMBER
	STB	R13,0,R10,R11	:STORE IN REVERSE ORDER
	SIS	R10,1		:DECREMENT COUNTER
	JGBS	DIVIDE		: KEEP LOOPING
RTRN	LM	R8,RSAVE	:RESTORE THE REGISTERS
	JR	R4		:AND RETURN

	EM
:
	SUBTTL	GMT Clock Conversion Routines	- DATIME.LIB
:******************************************************************
:
:	This program is the sole property and confidential
:	information of Tymshare, Inc., and may not be copied
:	in whole or in part or disclosed to any third party
:	without the prior written consent of Tymshare.
:
:*******************************************************************
:
	RA	$0 0A
:
	MO	.,DATIME
:
	GL	DATIME,TMSTMP,DATE
:
:***************************************************************
:
:	THIS PROCEDURE CONVERTS THE GMT CLOCK
:	RELATIVE TO 1/1/74 FROM SECONDS TO
:	DDMMMYY HH:MM (GMT) OR
:	DDMMMYY HH:MM:SS (GMT)
:
:	PARMS
:		R3 = # OF SECONDS SINCE 1/1/74 (BEYOND1/1/76)
:		R4 = CHARACTERS OF OUTPUT (13 OR 16)
:		R5 = ADDRESS OF OUTPUT STRING
:		R6 = LINK REGISTER
:	ALL REGISTERS ARE PRESERVED
:
:**************************************************************
:
	SEG	A.DATA
:
RSAVE	HS	$020	:REGISTER SAVE AREA
:
	SEG	A.CODE
DATIME	STM	R0,RSAVE	:PRESERVE THE REGISTERS
	S	R3,SEC745	
:	MAKE TIME RELATIVE TO 1/1/76 - THE START OF
:	A 'QUAD-YEAR'.  'QUAD-YEAR' = 1 LEAP
:	YEAR + 3 REGULAR YEARS.  THERE ARE
:	24 QUADS PLUS 4 REG YEARS IN A CENTURY
:
	SR	R2,R2		: CLEAR HI ORDER BYTES
	D	R2,SECDAY	:QUOTIENT IS # OF DAYS
:				:REMAINDER IS TIME
	LR	R14,R2		:COPY TIME OF DAY
	SR	R2,R2		:CLEAR HI ORDER BYTES
	D	R2,QUADAY	:DIVIDE BY DAYS IN A QUAD
:
:	QUOTIENT(R3) IS NUMB. OF QUAD YEARS
:	REMAINDER(R2) IS # OF DAYS INTO QUAD-YEAR
:
	LHI	R8,76		:BASE YEAR
	SLLS	R3,2		:QUAD YEAR * 4
	AR	R8,R3		:ADD TO BASE YEAR
	LA	R7,LEPYEA	:POINT TO DAYS IN MONTH
	C	R2,W366		:IS IT IN CURRENT YEAR?
	JL	MONTHD		:JUMP IF SO
	S	R2,W366		:SUBTRACT DAYS IN YEAR
	AIS	R8,1		:ADD 1 TO YEAR
	LR	R11,R2		:GET REMAIN DAYS IN QUAD
	SR	R10,R10
	D	R10,W365	:AND DIVIDE BY REGYEAR
:	R11 HAS ADDTL YEARS
:	R10 HAS DAYS IN YEAR
	LR	R2,10
	AR	R8,R11
	LI	R7,REGYER	:POINT TO DAYS IN MONTHS
:
:	DAYS IN R2
:	YEAR IN R8
MONTHD	SR	R6,R6		:MONTH COUNTER
	AIS	R2,1		:MAKE 1/1/76 = DAY 1
MONLOP	LR	R9,R2		:SAVE DAYS
	LB	R3,0,R6,R7	:GET DAYS IN MONTH
	SR	R2,R3		:AND SUBTRACT FROM DAYS IN YEAR
	JLEFS	DAZE		:IF MINUS OR ZERO WE'RE IN THE MONTH
	AIS	R6,1		:INCREMENT INDEX
	JBS	MONLOP
:
:	DAYS IN R3
:	MONTH NUMBER - 1 IN R6
:	YEAR IN R8
:
:	SAVE R4 AND R5
DAZE	SIS	R4,8		:SUBTRACT OUT DATE LENGTH
	LR	R13,R4		:PRESERVE IT
	LR	R11,R5		:COPY OUPUT AREA POINTER
:
:	CONVERT DAY
	LIS	R10,2		:# OF OUTPUT CHARACTERS
	JAL	R4,BINDEC	:CONVERT TO DECIMAL ASCII
:
:	MOVE IN MONTH
	AIS	R11,2
	SLHLS	R6,2		:MULTIPLY MONTH NUMBER BY 4
	L	R4,MONTHS,R6	:GET THE NAME IN R4
	STB	R4,2,R11
	SRLS	R4,8
	STB	R4,1,R11
	SRLS	R4,8
	STB	R4,0,R11
	AIS	R11,3
:
:	CONVERT YEAR
	LR	R9,R8
	LIS	R10,2
	JAL	R4,BINDEC	:CONVERT TO CHARACTERS
	LHI	R3,$00A0	:ASCII SPACE
	STB	R3,2,R11	:PUT IT AFTER DATE
	LHI	R5,3,R11	:SET UP OUTPUT POINTER
	LR	R4,R13		:COPY LENGTH ARGUEMENT
	LR	R3,R14		:COPY TIME OF DAY
	JFS	TIME1		:JUMP
:*************************************************************
:
:	GET THE TIME STAMP
:
:	TIME STAMP ROUTINE
:		THIS ROUTINE CONVERTS THE FULLWORD GMT TIME OF DAY
:	TO HH:MM OR HH:MM:SS
:
:	PARAMETERS:
:		R3 = FULLWORD TIME OF DAY (GMT CLOCK)
:		R4 = 5 OR 8 (# OF CHARACTERS TO OUTPUT)
:		R5 = FULLWORD ADDRESS OF OUTPUT
:		R6 = LINK REGISTER
:
:	DIVIDE TIME BY SECONDS PER DAY.  THE REMAINDER
:	IS THE SECONDS IN THIS DAY, WHICH IS WHAT THIS
:	ROUTINE IS ALL ABOUT
:
:****************************************************************
TMSTMP	STM	R0,RSAVE	:PRESERVE THE REGISTERS
  IF \TIMZON
	AHI	R3,TIMZON*$A3600	:TIME ZONE CONVERSION
  EI
TIME1	SR	R8,R8		:INDEX FOR OUTPUT AREA
:
	SR	R2,R2		:CLEAR HI-ORDER BITS
	D	R2,SECDAY
:		SECONDS NOW IN R2
	LR	R3,R2		:GET READY FOR
	SR	R2,R2		:ANOTHER DIVIDE
	D	R2,TENOUR	:GET TENS OF HOURS
	JAL	R6,ASCOUT	:PRINT IT OUT IN ASCII
	DH	R2,OURS		:GET HOURS
:		R2 HAS REMAINDER, R3 HAS QUOTIENT
	JAL	R6,ASCOUT	:PRINT IT OUT
	LHI	R3,$00BA	:COLON
	JAL	R6,PRTOUT
	DH	R2,TENMIN
	JAL	R6,ASCOUT
	DH	R2,MIN
	JAL	R6,ASCOUT
:	THE CONDITION CODE HAS BEEN SET -
:	SET IF ANY MORE CHARACTER WANTED
	JE	RETRN		:JUMP IF ONLY 5 CHAR
:
:	PUT IN COLON BEFORE SECONDS
	LHI	R3,$00BA
	JAL	R6,PRTOUT
	DH	R2,TENSEC
	JAL	R6,ASCOUT
	LR	R3,R2		:GET SECONDS IN R3
	JAL	R6,ASCOUT
RETRN	LM	R0,RSAVE	:RESTORE THE REGISTERS
	JR	R6		:RETURN
:
:
ASCOUT	AHI	R3,$00B0
PRTOUT	STB	R3,0,R8,R5
	AIS	R8,1	: UPDATE INDEX
	SIS	R4,1
	JR	R6
:
:****************************************************************
:
:	THIS ROUTINE RETURNS A FULLWORD REPRESENTATION OF THE DATE
:	AND TIME. THE FORMAT OF THE RESULT IS MMDDHHMM WHERE
:	MM, DD, HH, & MM REPRESENT MONTH, DAY, HOUR, & MINUTES RESPECTIVELY
:	ALL IN DECIMAL FORMAT. I.E. DEC 12 13:41 WOULD BE 12121341.
:
:	IF THE SYMBOL TIMEZON IS DEFINED IT SHOULD BE THE TIME-ZONE
:	CORRECTION FACTOR FROM CUT (COORDINATED UNIVERSAL TIME)
:	I.E. PST IS -8.
:
:	PARMS
:		R3 = GMT CLOCK VALUE
:		R6 = RESULT FULLWORD
:
:	LINKS R5
:
:	PRESERVES REGISTERS R7 - R15
:
:******************************************************************
DATE	STM	R7,RSAVE	:PRESERVE THE REGISTERS
	S	R3,SEC745
:	MAKE TIME RELATIVE TO 1/1/76 - THE START OF
:	A 'QUAD-YEAR'.  'QUAD-YEAR' = 1 LEAP
:	YEAR + 3 REGULAR YEARS.  THERE ARE
:	24 QUADS PLUS 4 REG YEARS IN A CENTURY
:
	SR	R2,R2		: CLEAR HI ORDER BYTES
	D	R2,SECDAY	:QUOTIENT IS # OF DAYS
:				:REMAINDER IS TIME
	LR	R14,R2		:COPY TIME OF DAY
	SR	R2,R2		:CLEAR HI ORDER BYTES
	D	R2,QUADAY	:DIVIDE BY DAYS IN A QUAD
:
:	QUOTIENT(R3) IS NUMB. OF QUAD YEARS
:	REMAINDER(R2) IS # OF DAYS INTO QUAD-YEAR
:
	LHI	R8,76		:BASE YEAR
	SLLS	R3,2		:QUAD YEAR * 4
	AR	R8,R3		:ADD TO BASE YEAR
	LA	R7,LEPYEA	:POINT TO DAYS IN MONTH
	C	R2,W366		:IS IT IN CURRENT YEAR?
	JL	MNTHD		:JUMP IF SO
	S	R2,W366		:SUBTRACT DAYS IN YEAR
	AIS	R8,1		:ADD 1 TO YEAR
	LR	R11,R2		:GET REMAIN DAYS IN QUAD
	SR	R10,R10
	D	R10,W365	:AND DIVIDE BY REGYEAR
:	R11 HAS ADDTL YEARS
:	R10 HAS DAYS IN YEAR
	LR	R2,10
	AR	R8,R11
	LI	R7,REGYER	:POINT TO DAYS IN MONTHS
:
:	DAYS IN R2
:	YEAR IN R8
MNTHD	SR	R6,R6		:MONTH COUNTER
	AIS	R2,1		:MAKE 1/1/76 = DAY 1
MLOOP	LR	R9,R2		:SAVE DAYS
	LB	R3,0,R6,R7	:GET DAYS IN MONTH
	SR	R2,R3		:AND SUBTRACT FROM DAYS IN YEAR
	JLEFS	DAZE1		:IF MINUS OR ZERO WE'RE IN THE MONTH
	AIS	R6,1		:INCREMENT INDEX
	JBS	MLOOP
:
:	DAYS IN R9
:	MONTH NUMBER - 1 IN R6
:	YEAR IN R8
:
DAZE1	AIS	R6,1		:CONVERT TO MONTH NUMBER
	LB	R6,DECMAL,R6	:CONVERT TO DECIMAL REPRESENTATION
	SLLS	R6,8		:MOVE IT OVER
	LB	R9,DECMAL,R9	:CONVERT DAY TO DECIMAL
	OR	R6,R9		:OR IT IN
	SLLS	R6,8		:SHIFT IT OVER
	LR	R2,R14		:COPY SECONDS IN THE DAY
	DH	R2,OURS		:R3 HAS NUMBER OF HOURS
	LB	R3,DECMAL,R3	:CONVERT TO DECIMAL
	OR	R6,R3		:OR IT IN
	SLLS	R6,4		:SHIFT IT OVER
	DH	R2,TENMIN	:R3 HAS TENS OF MINUTES
	OR	R6,R3		:OR IT IN
	SLLS	R6,4		:SHIFT IT OVER
	DH	R2,MIN		:R3 HAS MINUTES
	OR	R6,R3		:OR IT IN
:
	LM	R7,RSAVE	:RESTORE REGISTERS
	JR	R5		:RETURN
:
DECMAL	XC	0001020304050607080910111213141516171819202122232425262728293031
SECDAY	WC	24*60*60	:SECONDS IN A DAY
TENOUR	WC	10*60*60	:TENS OF HOURS
OURS	HC	60*60		:HOURS
TENMIN	HC	10*60		:TENS OF MINS
MIN	HC	60		:MIN
TENSEC	HC	10		:TENS OF SECS
  IF	\TIMZON
SEC745	WC	24*60*60*365*2-TIMZON*60*60	:SECONDS IN 74 & 75 PLUS 
						:TIME-ZONE CORRECTION
  ELSE
SEC745	WC	24*60*60*365*2	:SECONDS IN 74 AND 75
  EI
W365	WC	365
W366	WC	366
QUADAY	WC	4*365+1
LEPYEA	BC	31,29,31,30,31,30,31,31,30,31,30,31
REGYER	BC	31,28,31,30,31,30,31,31,30,31,30,31
	WS	0
MONTHS	AC	/ Jan/
	AC	/ Feb/
	AC	/ Mar/
	AC	/ Apr/
	AC	/ May/
	AC	/ Jun/
	AC	/ Jul/
	AC	/ Aug/
	AC	/ Sep/
	AC	/ Oct/
	AC	/ Nov/
	AC	/ Dec/
	EM
	RA	0
	SUBTTL	DATA SECTION
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::			E Q U A T E S			    ::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

NGRP	EQ	(NPORT+0F)/10		:NUMBER OF PORT GROUPS
LGINSZ	EQ	$A 40			:MAX SIZE FOR THE LOGON STRING
SBUFSZ	EQ	0A0			:SAVE BUFFER SIZE
CBUFSZ	EQ	$A 80			:COMMAND BUFFER SIZE
TBUFSZ  EQ      CBUFSZ                  :TALK BUFFER
NMLMAX  EQ      0C                      :MAX LENGTH OF A USER NAME
NLEN    EQ      10                      :LENGTH OF A PORT LABEL NAME
STRLEN  EQ      1A                      :26 CHARS/LOGIN STRING TBLE ENTRY
NLENS	EQ	4			:SHIFT AMT FOR NAME (NLEN=2**NLENS)
NTRMCH	EQ	14			:NMBR OF TERM CHARS SUPPORTED
TPRVAL  EQ      0F                      :MAX VAL. SENT W/ TERM PARAM (B1 MSG)
PSNTIM	EQ	4			:NMBR OF SECS TO WAIT FOR PSEUDO-NDL

:	CRASH CODES:	MEANING		 	CFROM VALUE

CCINDT	EQ	0F0	ILLEGAL ISIS MSG TYPE	MSG TYPE
CCMXPT	EQ	0F1	ISIS PORT NO. TOO BIG	ISIS PORT NUMBER
CCINOD	EQ	0F2	ILLEGAL INTRA-NODE MSG	INTRA-NODE MSG TYPE
CCHANG	EQ	0F3	HANG NON-CONNECT PORT	ISIS PORT NUMBER
CCDUPT	EQ	0F4	NEEDLE ON CON'D PORT	ISIS PORT NUMBER
CCBADZ	EQ	0F5	BAD PORT CHAIN ON ZAP	ISIS PORT NUMBER

:	INTERFACE MSG DATA TYPES

FIRST	EQ	09E			:FIRST MESSAGE IN LIST

DETMSG	EQ	09E			:DETACH MESSAGE
ZAPMSG	EQ	09F			:DISCONNECT MESSAGE
NOSMSG	EQ	0A0			:APPLY BACK-PRESSURE
SNDMSG	EQ	0A1			:RELEASE BACK-PRESSURE
GOBMSG	EQ	0A2			:FLUSH OUTPUT
BKGMSG	EQ	0A3			:FLUSH INPUT
BLKMSG	EQ	0A4			:DATA LOST IN THIS DIRECTION
GRYMSG	EQ	0A5			:DATA LOST IN OPPOSITE DIRECTION
EDMMSG	EQ	0A6			:ENTER DEFERED ECHO MESSAGE
LDMMSG	EQ	0A7			:LEAVE DEFERED ECHO MESSAGE
ETMMSG	EQ	0A8			:ENTER TRANSPARENCY MODE
LTMMSG	EQ	0A9			:LEAVE TRANSPARENCY MODE
GBMSG	EQ	0AA			:GREEN BALL
RBMSG	EQ	0AB			:RED BALL
YBMSG	EQ	0AC			:YELLOW BALL
OBMSG	EQ	0AD			:ORANGE BALL
BRKMSG	EQ	0AE			:BREAK DETECTED
HNGMSG	EQ	0AF			:HANG UP
QTPMSG	EQ	0B0			:QUERY TERMINAL PARAMETER
STPMSG	EQ	0B1			:SET TERMINAL PARAMETER
APNMSG	EQ	0B2			:AUX PSEUDO NEEDLE
NLOGCH	EQ	0B3			:NORMAL LOGON CHAR
NLOGST	EQ	0B4			:NORMAL LOGON STATUS
LGFAIL	EQ	0B5			:LOGON FAILURE
NLOGOK	EQ	0B6			:SUCCESSFUL LOGON
SHGMSG	EQ	0B8			:SUPER-HANG UP
SXMLMT	EQ	0B9			:SET TRANSMIT LIMIT
BREMSG	EQ	0BA			:BREAK END
ZAPACK	EQ	0BB			:ZAP ACK
EAODM	EQ	0BC			:ENTER ALT DEV. MODE
LAODM	EQ	0BD			:LEAVE ALT DEV. MODE
ZAPREA	EQ	0BE			:ZAP WITH REASON
SIIXM	EQ	0BF			:SIIX
TIIXM	EQ	0C0			:TIIX

NRMTYP	EQ	7			:NORMAL CKT PSEUDO-NEEDLE REQUEST
AUXTYP	EQ	8			:AUX CKT PSEUDO-NEEDLE REQUEST
PNRTYP	EQ	9			:PSEUDO-NEEDLE REJECT

: IMMEDIATE COMMANDS

AT.SC	EQ	5A			:<ESC>-Z SELECT COMMAND MODE
AT.NM	EQ	4E			:<ESC>-N SEND USER NAME 
AT.LC	EQ	43			:<ESC>-C LABEL CIRCUIT
AT.EN	EQ	45			:<ESC>-E ENABLE & NEXT
AT.FL	EQ	46			:<ESC>-F FLUSH & NEXT
AT.BP	EQ	42			:<ESC>-B BACKPRESSURE & NEXT
AT.GO	EQ	47			:<ESC>-G GO TO NEXT
AT.DS	EQ	44			:<ESC>-D DISPLAY CIRCUIT

::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::              V A R I A B L E     S T O R A G E               ::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

	SEG	0

START0	HS	0			:BEGINNING OF AREA TO ZERO ON START-UP
NTBLE   HS      NLEN*NPORT/2            :USER DEFINABLE PORT NAME
PTBLE	HS	NPORT			:DEST FOR GIVEN PORT, 0 IF INACTIVE
BTBLE	HS	NPORT			:USER-BLOCK BASE ADDRESS FOR PORT 
CTBLE	HS	NPORT			:LINK TO NEXT PORT ON THIS BOSS
SUPTBL  BS      NPORT
STRTBL  HS      STRLEN*NPORT/2          :TABLE OF LOGIN STRINGS
INVNUM	WS	NPORT			:INVOICE NUMBER
CCT	BS	NPORT			:CIRCUIT CHAR TYPE
TPC	BS	NPORT			:THRUPUT CLASS
PSNEDL	HS	NGRP			:PSEUDO NEEDLE RECEIVED
BOSPRT	HS	NGRP			:ARRAY FOR BOSS PORTS
LOGINS  HS      NGRP                    :BIT SET UPON DEFINITIN OF LOGIN STRING
LSTRHN  HS      NGRP                    :IN LST CMD--TEST IF SENDING NUMBERS
                                        :ONLY IN HOST # FIELD OF LOGIN STRING
APORT	HS	NGRP			:ARRAY FOR PORTS THAT ARE ACTIVE
DUMP	HS	NGRP			:USERS MAY HAVE PORTS FLUSHED
TYMSAT	HS	NGRP			:SET IF CIRCUIT CAME FROM NEEDLE
STOPPD	HS	NGRP			:BACKPRESSURED PORT ARRAY
ECHO	HS	NGRP			:ECHO ARRAY(ECHO BACK TO BOSS PORT)
DEM	HS	NGRP			:IF ECHO AND CANT ECHO THEN DEM
NBO	HS	NGRP			:NO BALLS OUT FOR THIS PORT
EXPECT	HS	NGRP			:EXPECTING A RETURNED BALL
ECTLI	HS	NGRP			:ECHO CONTROL-I
ELFCR	HS	NGRP			:ECHO LF W/CR
ECRLF	HS	NGRP			:ECHO CR W/LF
CRDE	HS	NGRP			:CR DELAY
PARITY	HS	NGRP			:BIT FOR PARITY
HAFDUX	HS	NGRP			:HALF DUPLEX PORTS
XONENA	HS	NGRP			:X ON-ENABLE
ECTLH	HS	NGRP			:ECHO CONTROL-H
YONENA	HS	NGRP			:REVERSE X-ENABLE
TBOA	HS	NGRP			:THESE ARE TIMEOUT FLAGS, BALL LOGIC
TBOB	HS	NGRP			:THESE ARE PROBABLY USELESS
KATA	HS	NGRP			:KATAKANA
T.BRK	HS	NGRP			:TERMINATE OUTPUT ON BREAK
EC.ESC	HS	NGRP			:ECHO ESCAPE
Q.MOD	HS	NGRP			:'Q' -MODE, DEM ON CR
BRATE	BS	NPORT			:IO BAUD RATES
PAB	BS	NPORT			:PARAMETERS A,B
PCD	BS	NPORT			:PARAMETERS C,D
NLIFLG  BS      1                       :FLG USER BY DS.CIR ROUTINE

CHRCNT  BS      1
TRGTPT  HS      1
USRADR  WS      1
ORGR13  WS      1
B3PNTR  WS      1                       :START OF B3MODE CHAIN
PNTPTR  WS      1                       :START OF PSDNDL TIMER CHAIN
DFMADR  WS      1                       :FOR ADDR OF DEFAULT SETTING MSG
NEWBLK  WS      1
PTBITM  WS      1                       :SAVE AREA FOR ADDR OF PTBLE ITEM
ZAPSAV	WS	1			:SEE ZAP
NXTSAV	WS	1			:SEE NXTPT SAVE FOR LINK
TEMP	WS	10			:GENERAL SAVE AREA
TEMP1   HS      1
CNKTMP	WS	1			:SAVE AREA FOR CONNECT RTN.
SVNRM1	WS	1			:SAVE FOR USER NAME LOGIN
CSAVE	WS	2			:SPACE TO SAVE RING REGISTERS
END0	WS	0			:END OF AREA TO ZERO AT STARTUP

SBUFER	HS	SBUFSZ/2		:SAVE BUFFER
TEMP3	WS	2
TEMP2	WS	1
CHRSAV	BS	1			:SAVE CHARACTER FOR USER
BYTCNT  BS      1

: MODIFYABLE MESSAGES

NLCHAR	BC	2,NLOGCH,0		:NORMAL LOGON CHAR MSG

:	QUERY TERMINAL PARAMETERS

	HS	0
QUMSG	BC	2
	BC	$0 0B0
QUERX	BS	1

:	SET TERMINAL PARAMETERS

	BND	2			:SO ONE CAN 'STH'
SETMSG	BC	3			:MESSAGE LENGTH(AFTER PORTNUMBER)
	BC	$0 0B1			:MESSAGE TYPE
TERPAR	BS	1			:PARAMETER TO BE SET
TERVAL	BS	1			:VALUE TO SET TO

:	PSEUDO-NEEDLE REQUEST
		
	BND	2
	BS	1			:FILLER TO ALIGN HALFWORDS
PNREQ	BC	9			:MSG LENGTH (SC FORMAT)
PNTYP	BC	7			:MSG TYPE
PNKEY	BC	0			:KEY
PNLKEY	HS	1			:LOCAL KEY
PNDIAL  HC      4000                    :DIALECT--REQUEST EXTENDED LOGIN STAT
PNHOST	HS	1			:ORIG HOST
PNTID	BS	1			:TID

:	EXTENDED HOST STATUS

	BND	2
	BS	1			:FILLER TO ALIGN HW'S
ANSMSG	BC	$A 12			:LENGTH OF MESSAGE
	BC	10,0			:MSG TYPE / KEY
ANSHST	HS	1			:HOST #
ANSPRT	HS	1			:# PORTS
ANSRHN	HC	0			:RELATIVE HOST 
	HC	0			:HOST STATUS = ANSWERED
	HC	PRODID			:PRODUCT ID

:	ACCOUNTING ADDENDUM

	BND	2
	BS	1			:FILLER
ACCTAD	BC	6			:MSG LENGTH
	BC	0B7,0			:MSG TYPE, KEY
ACCTNG	HS	2			:ACCOUNTING MESSAGE

: GREETING MESSAGE BUFFER

GRETMG	BC	0,8D,8A,0		:256 BYTES OF GREETING MESSAGE
	BS	$A 256			:INITIALIZED TO CR/LF/NULL
GRETME	EQ	.-2
GRETSA	AC	/ Says:"8D"8A/		:'USERNAME Says:' FOR GREET MESSAGE

: NOTIFY MESSAGE BUFFER

NOTYMG	BC	0,8D,8A,0		:NOTIFY BUFFER
	BS	$A 128			:BYTES OF STORAGE
NOTYME	EQ	.-2

: These two are put here to get them past the above, other-wise, I
: would need to make a lot of intructions RX3.

START1	HS	0			:SEND BLOCK TO CLEAR AT START-UP
TQPORT	WS	NPORT			:HOLDS TIME-TO-ZAP FOR INACTIVITY
TPORT	HS	NGRP			:INACTIVITY ARRAY FOR EACH PORT
END1	HS	0			:END BLOCK TO CLEAR


::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::		    B U F F E R   S T O R A G E			  ::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

: USER BLOCK LAYOUT

UBLSEG  EQ      30000                   :SEG 3 DEDICATED TO USR BLKS
ENUBLS  EQ      UBLSEG+10000

        SEG     3                       :SEG 3 DEDICATED TO USR BLCKS

:NEED TO START USER BLOCKS ON A NON-ZERO ADDRESS IN ORDER TO USE
:HALFWORD BTBLE ENTRIES
UBSTRT  WS      1                       :START OF USRBLK ADDRESSES
BLCKS	WS	0			:START OF USER BLOCK STORAGE
	ORG	0			:LAYOUT OF USER BLOCKS
NAME    BS      NMLMAX+2                :USER NAME (NMLMAX = 0C)
ATCHAR	BS	1			:USERS ATTEN CHAR
ASMBLD  BS      1                       :1 IF ASMBLD-IN OR ADD-ON(IF WLDCRD)
ADDON   BS      1                       :1 IF ADDED-ON
SUPLIC	BS	1			:IF SET TO 0, NO SUPER LICENSE
INACT   WS      1                       :INACTIVITY TIME BEFORE ZAP
LSTLOG  WS      1                       :TIME OF LAST LOG-IN BY USER
B3NEXT  WS      1                       :PTR TO NEXT IN B3MODE CHAIN
B3PREV  WS      1                       :PTR TO PREVIOUS IN B3 CHAIN
PNTNXT  WS      1                       :PTR TO NEXT IN PSDNDL TIMER CHAIN
PNTPRV  WS      1                       :PTR TO PREVIOUS IN PSDNDL TIMER CHAIN
SUPUSR  WS      1                       :SUPLIC USR WHO MAY HAVE CHNGD THIS BLK
LPORT	HS	1			:PORT CURRENTLY IN LOGON FOR THIS USER
BOSSP	HS	1			:BOSS PORT FOR THIS USER
SPORT	HS	1			:PORT CURRENTLY IN COMMUNICATION
XPORT	HS	1			:LAST PORT LABEL PRINTED
FPORT	HS	1			:FIRST PORT IN CHAIN
TLKBLK  HS      1                       :USR BLK ADDR OR PORT USR IS TLKIN TO
UFLAG	HS	1			:FLAGS INDICATING CONDITION OF BOSS
CMNDR6	HS	2
CMNDR7	HS	2
CMNDR8	HS	2
CMNDR9	HS	2
CMNDAD	HS	2			:CMND PROCESSOR LAST CALL REGISTER
ESCAPE	HS	1
UTEMP   HS      2
CYBTIM	HS	2
SETN	HS	1			:TERMINAL PARAMETER NUMBER TO SET
PSNTMR	HS	2			:PSEUDO-NDL WAIT TIMER
LGINEM	HS	1			:CURRENT EMPTY INDEX FOR LOGIN
LGINFL	HS	1			:CURRENT FILL INDEX FOR LOGIN
STRSIZ	HS	1			:SIZE OF STRING ON INPUT
UPRMT	HS	2			:CUR PROMPT STRING ADDR
UTKPRM  HS      2                       :CUR TALK PROMPT STRING ADDR
STRPOS	HS	1			:CMD LINE PARSE POSITION
TOKSTR	HS	1			:CUR TOKEN START POSITION
TOKLEN	HS	1			:CUR TOKEN LENGTH
TOKDLM	HS	1			:CUR TOKEN DELIMITER
ITCFLG	HS	(NTRMCH+0F)/10		:INITIAL TERM CHARS NOT IN YET
ITCVAL	BS	NTRMCH			:INITIAL VAL OF TERM CHARS FOR BOSS
PRTNUM  BS      4
UBUFER	HS	LGINSZ/2		:GENERAL USER STORAGE
CBUFER	HS	CBUFSZ/2		:COMMAND LINE BUFFER
TLKBUF  HS      TBUFSZ/2                :TALK BUFFER

:	FLAG EQUATES (FOR UFLAG, 1 BIT EACH)

FFRZ	EQ	8000			:INDICATES BOSS IS FROZEN
FSEND	EQ	4000			:INDICATES BOSS IN SEND MODE
FLAB	EQ	2000			:SET IF USER WANTS LABELING
FMSGPR	EQ	1000			:SET IF MESSAGE NOT YET PRINTED
FLOG	EQ	800			:SET IF USER IS LOGGING
FHEAR	EQ	HEAR			:(400) SET IF HEARING TALK
FCMD	EQ	200			:SET IF TO GO TO CMD MODE
FPASEC	EQ	40			:PASSWORD ECHO BIT (MUST BE 40)

ENDBLK	WS	0			:MARKS START OF NEXT USER BLOCK

        IF      (ENDBLK*NUSERS)-10000
MAXUSB  EQ      10000/ENDBLK-1
        RA      $0 0A
        REMARK  %***YOU HAVE REQUESTED THE VALDATION OF 
        NUMBER  NUSERS
        REMARK  USERS***
        REMARK  %***THE MAXIMUM NUMBER OF USERS ALLOWED IS 
        NUMBER  MAXUSB
        REMARK  ***
        REMARK  %***HALTING ASSEMBLY***
        RA      0
        QUIT
        EI

: GENERATE USER BLOCKS
:FOR THE INACTIVITY TIME (U|USR|TMT), IT IS CHECKED TO BE LESS THEN
:1440 MINUTES. IF NOT, IT IS BROUGHT TO THE HIGH LIMIT. THE SAME IS DONE ON
:THE EXTRA USER BLOCKS. (THE ACTUAL VALUES ARE IN HEX SECONDS,
:IT GOES BY SLOWC).
:IF THE LIMIT IS SET TO ZERO (0), THE TIMEOUT FEATURE IS DISABLED.
:
:

	ORG	BLCKS
USR	EQ	0

	RE	NUSERS
	BND	4
USER|USR| HS	0
	ORG	USER|USR|+NAME
	U|USR|NAM
	ORG	USER|USR|+ATCHAR
	BC	U|USR|ATT
	ORG	USER|USR|+ASMBLD	:ASSEMBLED IN
	BC	1			:SET TO 1
	ORG	USER|USR|+SUPLIC	:FF IF USR GIVEN SUP LIC POWER
	BC	U|USR|LIC		:OTHERWISE INIT'D TO 0
	ORG	USER|USR|+UFLAG
	HC	U|USR|UFG
	IF	(U|USR|TMT-015180)
U|USR|TMT	EQ	015180
	EI
	ORG	USER|USR|+INACT
	WC	U|USR|TMT
	ORG	USER|USR|+ENDBLK
H	KILL	U|USR|NAM,U|USR|ATT,U|USR|UFG,U|USR|LIC,U|USR|TMT
USR	EQ	USR+1
	ER

LSTASB	WS	0                       :LAST ASSEMBLED-IN USER BLOCK

XBLMAX  EQ      (((UBLSEG+10000)-LSTASB)/ENDBLK)-1

:IF XTRBLK > 0 THEN GENERATE XTRBLK EXTRA USER BLOCKS
:IF XTRBLK > XBLMAX THEN GENERATE XBLMAX NMBR OF EXTRA BLOCKS

        IF      XTRBLK
        RA      $0 0A
        IF      XTRBLK-XBLMAX           :REQUEST FOR XTRUSRS > MAX XTRBLKS?
        REMARK  %***REQUEST FOR 
        NUMBER  XTRBLK 
        REMARK  POTENTIAL ADD-ON OR WILD CARD USERS***
        REMARK  %***EXCEEDS THE MAXIMUM ALLOWABLE NUMBER***
XBLCNT  EQ      XBLMAX
        ELSE
XBLCNT  EQ      XTRBLK
        EI
        REMARK  %***ALLOWS UP TO 
        NUMBER  XBLCNT
        IF      WCUSOK
        REMARK  ADD-ON OR WILD CARD USERS***
        ELSE
        REMARK  ADD-ON USERS***
        EI
        REMARK  %
        RA      0
USR     EQ      0
        RE      XBLCNT
	BND	4
XTUSR|USR| HS   0
	ORG	XTUSR|USR|+NAME
	HC	0100
	ORG	XTUSR|USR|+ATCHAR
	BC	XTATTN
	ORG	XTUSR|USR|+ASMBLD
	BC	0			:NOT AN ASSEMBLED IN USER	
	ORG	XTUSR|USR|+SUPLIC
	BC	XTLIC
	ORG	XTUSR|USR|+UFLAG
	HC	XTUFLG
	IF	(XTTMT-015180)
XTTMT	EQ	015180
	EI
	ORG	XTUSR|USR|+INACT
	WC	XTTMT
	ORG	XTUSR|USR|+ENDBLK
USR	EQ	USR+1
	ER
LSTBLK  WS      0
        ELSE
        IF      WCUSOK
        REMARK  %***EXTRA USER BLOCKS NOT REQUESTED***
        REMARK  %***WILD CARD USERS CAN BE ALLOWED IF ASSEMBLED-IN USERS
        REMARK  %***ARE EFFECTIVELY DELETED BY DELETE COMMAND***
        ELSE
        REMARK  %***NOT ALLOWING WILD CARD USERS***
        REMARK  %
        EI
LSTBLK  EQ      LSTASB                  :NO XTRA BLKS--LSTBLK = LSTASMBLD BLK
        EI



::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::		U N M O D I F I E D   D A T A			::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

	SEG	1
PROMPT	BC	03,8D,8A,(HOST0&3)+23	:LEN,CR,LF,<#,$,%,&>
TLKPR2  SC      /"8D"8A<TALK>/
TLKPRM  SC      /<TALK>/
GRTPRM	SC	/<GREET>/
NOTPRM  SC      /<NOTIFY>/
CRLFMG	BC	02,8D,8A		:2, CR, LF
DBGMSG  BC      03,00,8D,8A
UPCRMG	BC	03,5E,0D,0A		:3, ^, CR, LF
BKSPMG	BC	01,08			:1, BS (BACK SPACE)
STARMG	BC	04,0A0,0AA,8D,8A	:4, ' ',':',CR,LF

SETXMT	BC	2,SXMLMT,09D		:SET TRANSMIT LIMIT
ECHON	BC	3,STPMSG,0,1		:SET ECHO ON
ECHOF	BC	3,STPMSG,0,0		:SET ECHO OFF
EBSOFF	BC	3,STPMSG,0D,0		:SET ECHO-CTL-H OFF
IBPON	BC	1,NOSMSG		:BACKPRESSURE ON
IBPOFF	BC	1,SNDMSG		:BACKPRESSURE OFF

DLMARY	WC	00440000,80080010,00000000,00000000  :TOKEN DELIMITERS
EOCARY	WC	00040000,00000010,00000000,00000000  :END OF CMD DELIMITERS
CRPOLA	WC	00040000,-1,-1,-4

CRCHD0  SC      /   ISIS Ports with circuits"8D"8A"8D"8A/
CRCHD1  SC      /Port  User          Port  Label"8D"8A"8D"8A/
CRCDIV  SC      /==============================="8D"8A/
CRCTAB  SC      /                    /
SPACE3  SC      /   /
NLIPRT  SC      /NLI*  /
NLIMSG  SC      /"8D"8A*NLI = User Not Logged In"8D"8A/

NOMSG	SC	/< /
ZAPPED	SC	/ Zapped< /
GREY	SC	/ Grey ball< /
BLACK	SC	/ Black ball< /

BMSG1	SC	/? Bad port label/              :port label not valid
BMSG2	SC	/? Bad command/      		:command not valid
BMSG3	SC	/? Bad username/      		:user not entered
BMSG4	SC	/? Line too long/      
BMSG5	SC	/? Bad number/      		:number invalid
BMSG7	SC	/? Not a tymsat/      		:can not switch boss
BMSG8	SC	/? Bad option/      		:switch option not valid
BMSG9   SC      /? User hearing off/            :user's fhear flag set to 1
BMSG0A  SC      /? User not logged in/          :boss port of user block was 0
BMSG0B  SC      /? No port specified/           
BMSG0C  SC      /? Number out of range/         :if NOT (termparm IN [0..19])
BMSG0D  SC      /? No username specified/       
BMSG0E  SC      /You do not have license to use this command/
BMSG0F  SC      /? Option and username not entered/
BMSG10  SC      /? Cannot change your own license/
BMSG11  SC      /? Cannot give super license to a wild-card user/
BMSG12  SC      /? Command not entered/
BMSG13  SC      /? Cannot delete your own username/
BMSG14 SC /? Cannot delete a user with circuits--zap circuits with USER cmnd/
BMSG15 SC /? Cannot delete a user that is logged-in/
BMSG16 SC /? Cannot issue this command as a parameter to the USER command/
BMSG17 SC /? Did not enter item to send/
BMSG18 SC /? This username already exists/
BMSG19 SC /No room for another user/

NPRTMS	SC	/No ports"8D"8A/
PRTMS	SC	/Port list:"8D"8A/
NMCRCS  SC      / Cir/
WCBTAG  SC      / #/
ARROW	AC	/ --> /
CCTMSG	SC	/Circuit Char Type: /
TPCMSG	SC	/"8D"8AThroughput Class:  /
SCHMSG	SC	/Attention char: /
SFRMSG	SC	/Boss freeze: /
SHRMSG	SC	/Hearing: /
SLBMSG	SC	/Labeling: /
OFFMSG	SC	/OFF"8D"8A/
ONMSG	SC	/ON"8D"8A/

: ON/OFF OPTION TBLE

ONOFFT  BC      2,4F,4E,0               :"ON"
        BC      1,4E,0,0                :"N"
        BC      3,4F,46,46              :"OFF"
        BC      2,4F,46,0               :"0F"
        BC      1,46,0,0                :"F"

: SWITCH OPTION TABLE

CONOFF	BC	1,1,0C6,0,0		:"F"
	BC	2,3,0CF,0C6,0C6		:"OF" OR "OFF"
CONOFN	BC	1,1,0CE,0,0		:"N"
	BC	2,2,0CF,0CE,0		:"ON"

CNFEN	EQ	.
CNFSZ	EQ	5
 
STA3O5  HC      1400                    :BIT ARRAY USED IN B4 MSG ROUTINE

: LOGON MESSAGES

NLSTYP	WC	NULL
	WC	PLIMSG
	WC	NLS2
	WC	NLS3
	WC	NLS4
	WC	NLS5
	WC	NLSILL
	WC	NLSILL
	WC	NLSSYR                  :STAT MSG 8
	WC	NLSBMD                  :STAT MSG 9
	WC	NLSCBY                  :STAT MSG 10
	WC	NLSHNA                  :STAT MSG 11
	WC	NLSHOP                  :STAT MSG 12
	WC	NLSHDN                  :STAT MSG 13
	WC	NLSHSH                  :STAT MSG 14
	WC	NLST2M                  :STAT MSG 15
	WC	NLSANP                  :STAT MSG 16
	WC	NLSNHS                  :STAT MSG 17
	WC	NLSBHN                  :STAT MSG 18
	WC	NLSMER                  :STAT MSG 19    X13

NULL	SC	//
PLIMSG	SC	/"8D"8Aplease log in: /
NLS2	SC	/"8D"8Aerror, type username: /
NLS3	SC	/"8D"8Aerror, type password: /
NLS4	SC	/"8D"8Ausername: /
NLS5	SC	/"8D"8Apassword: /
NLSILL	SC	/"8D"8ABAD LOGON STATUS!"8D"8A/
NLSSYR  BC      48
        AC      /"8D"8Aplease see your representative"8D"8A/
        AC      /if you are having trouble logging in"8D"8A/
NLSBMD	SC	/"8D"8Abad mud"8D"8A/
NLSCBY	SC	/"8D"8Acircuits busy"8D"8A/
NLSHNA	SC	/"8D"8Ahost not available"8D"8A/
NLSHOP	SC	/"8D"8Ahost out of ports"8D"8A/
NLSHDN	SC	/"8D"8Ahost down"8D"8A/
NLSHSH	SC	/"8D"8Ahost shut"8D"8A/
NLST2M	SC	/"8D"8Atry again in 2 minutes"8D"8A/
NLSANP	SC	/"8D"8Aaccess not permitted"8D"8A/
NLSNHS	SC	/"8D"8Ano host specified"8D"8A/
NLSBHN	SC	/"8D"8Abad host number"8D"8A/
NLSMER	SC	/"8D"8Amud error"8D"8A/
IPLIMS	SC	/please log in: /
DELUMG  SC      / Deleted"8D"8A/
ADDUMG  SC      / Added"8D"8A/

: PSEUDO-NEEDLE REJECT MESSAGES

ARJTYP	WC	ARJ0
	WC	ARJ1
	WC	ARJ2
	WC	ARJ3
	WC	ARJ4
	WC	ARJ5
	WC	ARJ6
	WC	ARJ7
	WC	ARJ8
	WC	ARJ9
	WC	ARJA

ARJ0	SC	/? ISIS unable to complete request"8D"8A/
ARJ1	SC	/? Format error"8D"8A/
ARJ2	SC	/? Bad user name"8D"8A/
ARJ3	SC	/? Bad MUD"8D"8A/
ARJ4	SC	/? System unavailable"8D"8A/
ARJ5	SC	/? Down-line load or dial-out failure"8D"8A/
ARJ6	SC	/? Timeout"8D"8A/
ARJ7	SC	/? Access not permitted."8D"8A/
ARJ8	SC	/? Out of origination ports"8D"8A/
ARJ9	SC	/? Try again later"8D"8A/
ARJA	SC	/? Bad logon error code"8D"8A/
ARJMAX  EQ      $0 0A                   :LAST VALID #
BDNDCD	SC	/? Node code timeout"8D"8A/

: "NO ROOM" MSG TO WOULD-BE WILD CARD USER WHO CANNOT BE GIVEN
: A USER BLOCK BECAUSE ALL WLD CRD USR BLKS HAVE CIRCUITS
SORRY   EQ      .
        NRMMSG

: TELL USER HE IS NOT VALID ON THIS MUX
BADUSR  EQ      .
        BDMSG

: SYSTEM DEFAULTS SET MSG
SDMSG   EQ      .
        SDFMSG

: USER DEFAULTS SET MSG
UDMSG   EQ      .
        UDFMSG

: INVALID USER MESSAGE

BADGY   EQ      .
        BDMSG

: HELP MESSAGES

MSGH	SC	/MUX Command-Mode commands:"8D"8A/
	SC	/  Backpr <pl>  Backpressure port output    LAbel <N\F>  Label output on\off"8D"8A/
	SC	/  CCt <n1,n2>  Set\display CCT & TPC       Make <pl>    Make a new circuit"8D"8A/
	SC	/  CHar <hex>   Set\display attn char       MEssage      Print greeting msg"8D"8A/
	SC	/  COnn <p1,p2> Connect output of 1st       QUit         Zap all circuits"8D"8A/
	SC	/               port to input of 2nd        Send <pl>    Send to port"8D"8A/
	SC	/  ENable <pl>  Enable port output          Talk <user>  Talk to another user"8D"8A/
	SC	/  EXit [<pl>]  Leave MUX [and transfer]    TIme         Print date & time"8D"8A/
	SC	/  Flush <pl>   Flush port output           TPar <n1,n2> Set boss term param"8D"8A/
	SC	/  FReeze <N\F> Freeze boss on\off          TRans <pl>   Transfer boss"8D"8A/
	SC	/  HEAr <N\F>   Incoming talk on\off        Version      Print MUX version"8D"8A/
	SC	/  Help         Print this list             Who          List active users"8D"8A/
	SC	/  List         List ports                  Zap <pl>     Zap a port"8D"8A/
	SC	/"8D"8A/
	SC	/MUX Immediate commands:"8D"8A/
	SC	/  <attn>-B     Backpressure & goto next    <attn>-F     Flush & goto next"8D"8A/
	SC	/  <attn>-C     Rename current circuit      <attn>-G     Go to next circuit"8D"8A/
	SC	/  <attn>-D     Display current circuit     <attn>-N     Send username"8D"8A/
	SC	/  <attn>-E     Enable & goto next          <attn>-Z     Select command mode"8D"8A/
	SC	/"8D"8A/
	HPMSG
	BC	0
HLPSUP  SC      /"8D"8A"8D"8AMUX Super-license commands"8D"8A/
        SC      /  ADd    <username>              Add a username"8D"8A/
        SC      /  ALl                            List all usernames"8D"8A/
        SC      /  Delete <username>              Delete a username"8D"8A/
        SC      /  Greeting                       Create greeting message"8D"8A/
        SC      /  NOTify                         Send message to users"8D"8A/
        SC      /  Power  [N|F|W] <username>      Give, take or ask who has sup.lic. power"8D"8A/
        SC      /  User   <usrnam> <cmd> <params> Execute a cmd thru another username"8D"8A/
        BC      0
:
: HEADER/VERSION/HOST MESSAGE
:
:	COMPUTE HOST NUMBER DIGITS

QH	EQ	HOST0			:HOST #
MAXDIG	EQ	6
QN	EQ	MAXDIG			:MAX # ALLOWED
QQ	EQ	1			:DEFAULT TO 1

  RE	MAXDIG
Q|QN|	EQ	QH-(QH/$A10)*10		:ASSIGN NEXT DIGIT
QH	EQ	QH/$A10			:SET 'HOST #' TO HOST #/ 10d
   IF	Q|QN|				:IF # WAS NOT ZERO
QQ	EQ	QN			:SET QQ TO HIGHEST SIG BYTE SO FAR
   EI	
QN	EQ	QN-1
  ER

:	DEFINE MESSAGE

	HC	MSGVLN			:FAKE SC FORMAT
MSGVER	EQ	.-1
	AC	/"8D"8A"8A>>> MUX V/
	BC	0B0+VERSION
	AC	/./
	BC	0B0+REVLEV/8
	BC	0B0+REVLEV-((REVLEV)/8)*8)
	AC	/ - Host /

  RE	MAXDIG-QQ+1
	BC	Q|QQ|+0B0
QQ	EQ	QQ+1
  ER

	AC	/ <<<"8D"8A/
MSGVLN	EQ	.-MSGVER-1
	SUBTTL	INITIALIZATION
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::              I N I T I A L I Z A T I O N                     ::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:
:       		BRING HOST UP
:

:ZERO OUT SOME VARIABLES IN THE USER BLOCK

START   LA      R1,USER0,,              :START OF USER BLOCKS
	LIS     R0,0                    :GET A NULL
START2	STH	R0,BOSSP,R1		:ZERO THE BOSSP
	STH	R0,LPORT,R1		:ZERO THE LOGGING-ON PORT
	STH	R0,SPORT,R1		:ZERO THE SEND PORT
	STH	R0,FPORT,R1		:CLEAR PORT CHAIN
	ST	R0,PSNTMR,R1		:PSEUDO-NDL WAIT TIMER
	AI	R1,ENDBLK		:NEXT USER
	CLI	R1,LSTBLK		:ALL DONE?
	JL      START2

:ZERO OUT MOST OF THE VARIABLE STORAGE, FROM START0-TO-END0.
        LIS     R0,0
        LHI     R1,END0-START0-4
STA010  ST      R0,START0,R1            :INIT TO ZERO
        SIS     R1,4
        JGEBS   STA010                  :ZERO ENTIRE AREA

:ZERO OUT MOST OF THE VARIABLE STORAGE, FROM START1-TO-END1.
        LIS     R0,0
        LHI     R1,END1-START1-4
STA011  ST      R0,START1,R1,		:INIT TO ZERO
	SIS	R1,4
	JGEBS	STA011			:ZERO ENTIRE AREA

:SEND HOST-UP TO ALL VALID HOSTS ON THIS SLOT
	LIS	R12,MAXHST-1
STA005  LHL	R0,HOSTS,R12,R12	:GET HOST 
	STH	R0,ANSHST		:PUT IT IN MSG
	LHL	R0,PORTS,,		:GET # OF PORTS
	NHI	R0,1FF			:EXTRACT # PORTS
	STH	R0,ANSPRT		:PUT IT IN MSG
	STH	R12,ANSRHN		:SAVE RELATIVE HOST NUMBER
	LIS	R2,0			:SEND TO PORT 0
	LA	R3,ANSMSG		:ADDR OF MSG
	JAL	R5,OCM			:OUTPUT MSG
	SIS	R12,1
	JGE	STA005

:       SET UP TIMEOUT LIST

        LCS     R0,1
        JAL     R0,IZT                  :INITIALIZE TIMEOUT LIST
        L       R7,FASTC,,              :GET REFERENCE TIME
        LHI     R1,RATE/4,R7            :TIME FOR QSEC LOGIC
        LA      R0,QSEC
        JAL     R5,TOPUT
        LHI     R1,RATE*8
        LA      R0,SEC8                 :RUNS EVERY EIGHT SECONDS
        JAL     R5,TOPUT

	SUBTTL	INPUT FROM ISIS DISPATCHER
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::              I N P U T      F R O M      I S I S             ::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

INPUT	JAL	R0,TIMOUT		:PROCESS PERIODIC LOGIC
	JAL	R4,LOOK			:ANYTHING FROM ISIS?
	J	OUTPUT			:SEND ANY MESSAGES TO BOSS
	JN	INEEDL			:JUMP NOT INTRA-NODE COMMUNICATION

:	INTRA-NODE COM - EAT IF ALLOWED, ELSE CRASH

	CLHI	R2,PNRTYP		:PSEUDO NEEDLE REJECT?
	JE	PSNRJT			:IF SO
	CLH	R2,MAXP0,,		:CHECK FOR MAX SUBTYPE
	JGFS	IIND10			:CRASH IF ILLEGAL SUBTYPE
	LHL	R4,LP0LST,,		:LENGTH LIST ADDR
	LB	R0,0F0000,R2,R4		:ALLOWED TO EAT?
	JEFS	IIND10			:NOPE, CRASH
	JAL	R4,FLUSH		:EAT
	J	INPUT			:CHECK INPUT AGAIN

IIND10	JAL	R10,CRASH		:CRASH, CFROM GIVES MSG TYPE
	BC	0,0,R2*4,CCINOD

: (Non-Rport0) DATA & NEEDLE PROCESSING
:	CRASH IF ALREADY CONNECTED, ELSE ASSIGN
:	AS A TYMSAT PORT TO BOSS OR SLAVE

INEEDL	CLHI	R1,NPORT		:TOO MANY PORTS ASSIGNED ?
	JLFS	INED05			:JUMP IF NOT
	JAL	R10,CRASH		:CRASH, CFORON GIVES ISIS PORT NUMBER
	BC	0,0,R1*4,CCMXPT

INED05	LR	R2,R2			:NEEDLE (0) ?
	JN	IDATA			:JUMP IF NOT
	JAL	R4,GETH	 		:GET ADDITIONAL LENGTH
	LR	R3,R0			:SAVE
	JAL	R4,GETW	 		:GET INVOICE NMBR
	LR	R10,R1
	SLLS	R10,2			:MAKE INDEX
	ST	R0,INVNUM,R10		:SAVE INVOICE NMBR
	JAL	R4,GETW	 		:EAT DEST HOST / ORIG NODE
	JAL	R4,GETW	 		:EAT ORIG HOST / ORIG PORT
        JAL     R4,GETW 		:GET XXXX & TPC
	NHI	R0,3
	STB	R0,TPC,R1		:SAVE THRUPUT CLASS
	JAL	R4,GETH	 		:EAT ORIG PORT (DIALECT CODE IN ISIS-2)
	JAL	R4,GETCH		:GET CCT
	NHI	R0,3F			:STRIP HIGH BITS
	JNFS	INED10			:BR UNLESS AUX CIRCUIT
	LIS	R0,0E			:BUILD GATEWAY AUX CIRS INSTEAD
INED10	STB	R0,CCT,R1		:SAVE CCT
	LHL	R0,BTBLE,R1,R1		:DOES IT HAVE A BOSS
	JEFS	INED20			:JUMP WAS'NT ACTIVE

	JAL	R10,CRASH		:CRASH, CFROM GIVES ISIS PORT NUMBER
	BC	0,0,R1*4,CCDUPT

INED20	JAL	R4,GETCH		:GET THE SIZE OF THE USERNAME
	LR	R3,R0			:SAVE IT
	LCS	R5,1			:MAKE AN INDEX
INED21	JAL	R4,GETCH
	OHI	R0,80			:SET MSB
	CLHI	R0,0A1			:DID THE SUP MESS THE NAME
	JE	INED2A			:YES,TOSS THIS
	STB	R0,SBUFER+1,R5
	AIS	R5,1
INED2A	SIS	R3,1
	JG	INED21  		:KEEP LOOKING.
	STH	R5,TEMP
	JAL	R4,ELIR


: FIND THE USER BLOCK WITH THE NAME THAT MATCHES INPUTED USER NAME.
: ALSO KEEP TRACK, IN R8, OF THE LAST EXTRA BLOCK FOUND THAT IS
: UNUSED--DETERMINED BY A NAME LENGTH OF 0. (THERE MAY NOT BE ONE).
: KEEP TRACK, IN R7, OF THE ADDR OF THE "OLDEST" EXTRA BLOCK.
: (EXTRA BLOCKS MAY NOT HAVE BEEN GENERATED).
: IF INPUTED NAME DOES NOT MATCH NAME IN ANY BLOCKS, THEN THE USER
: IS A POTENTIAL "WILD CARD" USER.  IF WILD CARD USERS ARE ALLOWED, 
: THIS USER WILL BE GIVEN EITHER THE EMPTY EXTRA BLOCK (IF ONE WAS FOUND)
: OR THE "OLDEST" EXTRA WILD CARD BLOCK THAT HAS NO CIRCUITS.
: AN EXTRA BLOCK THAT IS ALSO A "WILD CARD" BLOCK HAS THE "ASMBLD" LABEL
: DECLARED AS A BYTE CONSTANT OF 0

        LIS     R8,0                    :R8 WILL HOLD ADDR OF EMPTY
                                        :EXTRA BLOCK, IF ANY
        LIS     R5,0                    :INIT R5--WILL HOLD LSTLOG VAL OF
                                        :"OLDEST" "EXTRA" BLOCK--IF ANY
        LIS     R7,0                    :R7 WILL HOLD ADDR OF OLDEST 
                                        :"EXTRA BLOCK"--IF ANY
	LA	R6,USER0,,		:FIRST ENTRY
INED2D	LB	R4,NAME+1,R6		:GET LENGTH BYTE OF NAME
        JE      MPTXTB                  :IF 0 IT'S AN "EMPTY" XTRA BLK
	CLH	R4,TEMP
	JN	INED2C			:BR IF THEY ARENT
INED2B	LB	R0,NAME+1,R6,R4		:SEE IF NAME MATCHES
	CLB	R0,SBUFER-1,R4
        JN      INED2C
	SIS	R4,1
	JGBS	INED2B
        L       R4,LSTLOG,R6            :IF = 0, USER HAS NOT YET LOGGED-IN
        JE      GETDFM                  
        LA      R4,CRLFMG               :ELSE JUST SEND CR AND LF 
        ST      R4,DFMADR               :WHEN DFMADR IS SENT OUT
        J       DORTHY                  
GETDFM  LB      R4,ADDON,R6             :WAS THIS AN "ADD-ON" USER?
        JE      SNDUDM                  :NO--THIS USER WAS REALLY ASMBLD-IN
        LA      R4,SDMSG                :IT'S AN ADD-ON, SO SEND THE
        ST      R4,DFMADR               :"SYSTEM DEFAULTS SET" MSG
        J       DORTHY
SNDUDM  LA      R4,UDMSG                :PUT USER'S DEFLTS SET MSG
        ST      R4,DFMADR               :IN DFMADR
        J       DORTHY                  

INED2C  LB      R4,ASMBLD,R6            :ASSEMBLD-IN BLOCK? IF YES, YOU
        JN      INED2E                  :DON'T CARE IF "EMPTY" OR "OLDEST"
        LHL     R4,BOSSP,R6             :LOGGED IN?
        JN      INED2E                  :YES--CAN'T TAKE OVER THIS EXTRA BLK
        LHL     R4,FPORT,R6             :GET FPORT OF THIS EXTRA BLOCK
        JN      INED2E                  :IT'S GOT CIRCUITS--CAN'T USE
        L       R4,LSTLOG,R6            :TIME LAST LOGGED-IN IN R4
        LR      R7,R7                   :GOT AN "OLD" EXTRA BLOCK YET?
        JE      OLDXTB                  :NO, THIS IS THE 1ST FOUND
        CR      R4,R5                   :THIS BLK OLDER THAN CURRENT OLD BLK?
        JG      INED2E                  :NO, CHECK NXT BLK
OLDXTB  LR      R5,R4                   :SAVE CURRENT LASTLOG VALUE IN R5
        LR      R7,R6                   :SAVE CURRENT "OLD" XTRA BLK ADDR IN R7
        J       INED2E                  :GET NEXT BLK
MPTXTB  LR      R8,R6                   :SAVE EMPTY BLOCK ADDR IN R8
INED2E  AI      R6,ENDBLK
        CLI     R6,LSTBLK               :NO MORE BLOCKS?
        JL      INED2D                  :NO, CHECK NEXT BLK

: INPUTED NAME DOES NOT MATCH ANY USER BLOCK NAME
        LHI     R4,WCUSOK               :ALLOWING WILD CARD USERS?
        JE      WCUNAL                  :NO--THIS IS AN INVALID USER
        LR      R6,R8                   :DID YOU FIND AN EMPTY EXTRA BLK?
        JN      INEDXB                  :YES--SET-UP THIS NEW WILD-CARD BLOCK
        LR      R6,R7                   :IS THERE AND OLD XTRA BLOCK AVAILABLE?
        JE      NOROOM                  :NO--TELL USER ABOUT IT 

INEDXB  EQ      .                       :SET-UP EXTRA BLOCK FOR WLDCRD USER
        LH      R4,TEMP                 :CHECK LENGTH OF XTUSR NAME
        CLHI    R4,NMLMAX               :IF > NMLMAX, TRUNCATE
        JLE     INEDX1                  :ELSE JUMP
        LHI     R4,NMLMAX               :TRUNCATE--LENGTH IS NMLMAX
        STH     R4,TEMP                 :SAVE IN TEMP
INEDX1  STB     R4,NAME+1,R6            :SAVE LENGTH
        LIS     R5,0                    :INIT COUNTER
INEDX2  LB      R4,SBUFER,R5            :GET USER NAME BYTE
        STB     R4,NAME+2,R6,R5         :SAVE IN XTRUSR BLK NAME FIELD
        AIS     R5,1                    :INCREMENT
        CLH     R5,TEMP                 :END OF USR NAME?
        JL      INEDX2          
        LA      R4,SDMSG                :GET ADDR OF SYSTEM DEFLTS SET MSG
        ST      R4,DFMADR               :SAVE IN DFMADR
        J       DORTHY

WCUNAL  EQ      .       :WILD-CARD USERS NOT ALLOWED--TELL WOULD-BE
                        :USER ABOUT IT AND KICK HIM OFF
        LR      R2,R1                   
        LR      R6,R1                   :SAVE THE PORT NUMBER
        LA      R3,BADUSR               :INVALID USER MESSAGE
        JAL     R5,OCS
        LIS     R0,3                    :#BYTES IN MESSAGE
        LR      R1,R6                   :RECOVER THE PORT NUMBER
        LHI     R2,DETMSG               :MESSAGE TYPE
        JAL     R4,SLOR                 :SEND IT
        JAL     R4,ELOR
	J	INPUT

NOROOM  EQ      .
        LR      R2,R1
        LR      R6,R1
        LA      R3,SORRY                :"NO ROOM FOR ANOTHER WILD-CARD USER"
        JAL     R5,OCS
        LIS     R0,3
        LR      R1,R6
        LHI     R2,DETMSG                       :DETACH MSG
        JAL     R4,SLOR
        JAL     R4,ELOR
        J       INPUT
        
:	USERNAME IS VALID


DORTHY	SBT	R1,DEM			:TYMSATS START IN DEM
	SBT	R1,APORT		:SET ACTIVE PORT
	SBT	R1,TYMSAT		:SET THIS BIT

	LR	R10,R1			:SAVE PORT NMBR
	SLLS	R1,NLENS		:PNT TO NAME BFR
	LHI	R0,0107			:INIT NAME AS IF A SLAVE
	STH	R0,NTBLE,R1		:*AS "SLV." & PORT NMBR
	LI	R0,0D3CCD6AE
	ST	R0,NTBLE+2,R1
	LA	R14,NTBLE+6,R1
	LR	R1,R10
	LIS	R4,0A
	LIS	R15,3
	JAL	R5,CBA			:CONVERT ISIS PORT NMBR

	LA	R3,SETXMT		:SET XMIT LIMIT TO MAX
	LR	R2,R10			:PORT #
	JAL	R5,OCM

	SBT	R10,NBO			:NO BALLS OUT
	RBT	R10,EXPECT
	RBT	R10,DUMP		:NOT FLUSHING
	RBT	R10,STOPPD		:OR BACKPRESSURED

	LHL	R1,BOSSP,R6		:GET THE BOSS PORT FOR THIS BLOCK
	JE	INEDYY			:NO BOSS YET, SET THIS ONE UP
	LHI	R0,FFRZ			:FREEZE FLAG
	NH	R0,UFLAG,R6		:IS IT SET
	JE	INEDXX			:NO, SET UP NEW BOSS

:	THIS NEEDLE BECOMES A SLAVE PORT

	STH	R1,PTBLE,R10,R10	:INITIALIZE DESTINATION
	STH	R6,BTBLE,R10,R10	:SET UP BOSS BASE
	LHL	R2,FPORT,R6		:LINK INTO BOSS'S PORT CHAIN
	STH	R10,FPORT,R6
	STH	R2,CTBLE,R10,R10

	LHI	R8,NTRMCH-1
INED23	STB	R8,QUERX		:QUERY ALL TERM PARAMS
	LA	R3,QUMSG
	LR	R2,R10
	JAL	R5,OCM
	SIS	R8,1
	JGBS	INED23
	J	INPUT			:CONTINUE

:	DOWN-GRADE OLD BOSS TO SLAVE

INEDXX	STH	R10,PTBLE,R1,R1		:SET THE DESTINATION
	STH	R6,BTBLE,R1,R1		:SAVE THE CONTROL BASE
	LHL	R2,FPORT,R6		:LINK INTO BOSS'S PORT CHAIN
	STH	R1,FPORT,R6		:(NAME ALREADY SET AS IF SLAVE)
	STH	R2,CTBLE,R1,R1
        RBT     R1,BOSPRT               :THIS PORT NO LONGER A BOSS

:	SET UP NEW BOSS PORT

INEDYY	LR	R13,R6			:SET UP USER REGISTER
	STH	R10,BOSSP,R13		:SAVE ISIS PORT NUMBER
        SBT     R10,BOSPRT              :THIS PORT IS A BOSS
	STH	R13,BTBLE,R10,R10	:SAVE USR BLK ADDR IN BTBLE
	LHL	R2,UFLAG,R13
	NHI	R2,@FSEND&@FLOG		:CLEAR SEND MODE
	STH	R2,UFLAG,R13
        L       R2,GMT,,                :GET GMT AND SAVE AS
        ST      R2,LSTLOG,R13           :TIME OF LOG-IN

	LHI	R8,NTRMCH-1		:QUERY ALL TERM PARAMS
INED40	CLHI	R8,0D			:EXCEPT ECHO & ECTLH
	JEFS	INED41
	STB	R8,QUERX
	LA	R3,QUMSG
	LR	R2,R10
	JAL	R5,OCM
INED41	SIS	R8,1
	JGBS	INED40
	LI	R2,7FFBFFFF		:INDICATE NO INITIAL TERM CHARS IN
	ST	R2,ITCFLG,R13		:*EXCEPT ECHO & ECTLH
	LR	R2,R10
	LA	R3,ECHON		:TURN ECHO ON
	JAL	R5,OCM
	SBT	R10,ECHO
	LIS	R2,1
	STB	R2,ITCVAL,R13
	LR	R2,R10
	LA	R3,EBSOFF		:TURN ECHO-CTL-H OFF
	JAL	R5,OCM
	RBT	R10,ECTLH
	LIS	R2,0
	STB	R2,ITCVAL+0D,R13

        LR      R2,R10                  :PRINT MUX SIGN-ON
        LA      R3,MSGVER
        JAL     R5,OCS

	LHL	R2,UFLAG,R13		:GET USERS FLAG
	NHI	R2,FMSGPR		:TEST FOR MESSAGE TO SEND?
	JE	INED30			:BIT NOT SET, SKIP MESSAGE
	LB	R0,GRETMG,,		:SEE IF ANY GREETING MSG
	JEFS	INED31			:BR IF NOT
	LR	R2,R10			:GET PORT #
	LA	R3,GRETMG,,		:GET AND PRINT A GREETING MESSAGE
	JAL	R5,OCS			:PRINT IT TO BOSS
INED31	LHL	R2,UFLAG,R13		:GET USER FLAG
	NHI	R2,@FMSGPR		:TURN OFF BIT
	STH	R2,UFLAG,R13		:STORE USER'S FLAG

INED30  LR      R2,R10
        L       R3,DFMADR               :GET ADDR OF DFLTS SETTING MSG
        JAL     R5,OCS                  :SEND IT

        LHL     R3,FPORT,R13            :ANY PORTS ALREADY EXIST?
	JEFS	INED28			:BR IF NOT
	LH	R0,SPORT,R13		:CHECK FOR PORT ASSIGNED
	JNFS	INED27			:YES, SKIP ASSIGNMENT
	STH	R3,SPORT,R13		:NO, ASSIGN IT
INED27	STH	R10,PTBLE,R3,R3		:PNT EACH PORT TO NEW BOSS
	LHL	R3,CTBLE,R3,R3
	JNBS	INED27

INED28	JAL	R11,CLIST		:PRINT LIST OF CIRCUITS

	LA	R3,PROMPT
	LR	R2,R10			:GET THE BOSS PORT
	JAL	R5,OCS
	LA	R3,CGETW		:SET NEW BOSS TO START IN CMD MODE
	ST	R3,CMNDAD,R13
	J	INPUT			:CHECK INPUT AGAIN

: DATA MSG - GIVE TO INPUT COMMAND PROCESSOR IF BOSS
:		ELSE OUTPUT ON CRQ.
:
:	THE INPUT COMMAND PROCESSOR DOES A 'JALR R5,R11'
:	TO GET EACH CHARACTER AS IT COMES IN.  A NEEDLE INITIALIZES
:	US TO RETURN TO THE COMMAND PROCESSOR THE 1ST CHARACTER.
:	REG CONVENTIONS ARE:
:		R0	CHARACTER INPUT TO CMND PROCESSOR
:		R1	ISIS PORT NUMBER
:		R2-R5	UNSAVED CMND PROCESSOR REGS
:		R6-R7	CMDN PROCESSOR REGS SAVED BETWEEN CHAR CALLS
:		R8-R10  UNSAVED COMND PROCESSOR REGS
:		R11	CHAR INPUT RET ADDR USED BY COMMAND PROCESSOR
:		R12	CHARACTERS REMAINING IN RECORD (INCLUDING CURRENT CHAR)
:		R13-R15 UNSAVED CMND PROCESSOR REGS

IDATA	CLHI	R2,FIRST		:DATA MSG?
	JGE	INDATA			:JUMP IF NOT
	TBT	R1,APORT		:PORT ACTIVE?
	JE	IDATA2			:JUMP IF NOT

	SBT	R1,TPORT,,		:SET BIT TO SHOW PORT ACTIVITY

        LB      R4,SUPTBL,R1            :RESPONSE TO SUPER USER SEND CMD?
        JE      IDNORM                  :NO, "NORMAL" DATA--JUMP
        LHL     R13,BTBLE,R4,R4         :GET USR BLK FOR PORT
        AI      R13,UBLSEG              :MAKE IT A FULL WORD ADDR
        LIS     R5,0
        STB     R5,SUPTBL,R1            :0 OUT TBLE
        LR      R1,R4                   :R4 IS DESTINATION PORT
        J       SKPLAB                  :SKIP LABELING STUFF
IDNORM  EQ      .
	LHL	R13,BTBLE,R1,R1		:GET THE USER BASE FOR THE PORT
        AI      R13,UBLSEG              :USERBLOCKS IN SEG 3
        TBT     R1,BOSPRT               :IS THIS A BOSS PORT?
        JN      IDAT05                  :JUMP IF A BOSS

	LHL	R0,UFLAG,R13
	CLH	R1,SPORT,R13		:IS THIS THE CURRENT SEND PORT?
	JNFS	IDAT30
	THI	R0,FSEND
	JNFS	IDAT40			:NEVER FLUSH IF SO
IDAT30	TBT	R1,DUMP			:FLUSHING FOR THIS PORT?
	JN	IDATA2			:YES
IDAT40	LR	R8,R1			:COPY PORT NO.

:	CHECK IF USER WANTS CIRCUITS LABELED

	THI	R0,FLAB			:IS 'LABEL' FLAG SET
	JE	NOLAB			:NO, SKIP IT.
        CLH     R1,XPORT,R13            :HAVE WE PRINTED THIS LBL?
	JE	NOLAB			:YES, SKIP IT
	LHL	R10,BOSSP,R13		:GET BOSS PORT
	JE	NOLAB			:NO BOSS, SKIP IT.
	LR	R3,R1			:GET PORT #
	ST	R14,TEMP3		:SAVE R14
	ST	R2,TEMP3+4		:AND R2
	STH	R3,XPORT,R13		:SAVE LAST PRINTED
	LA	R7,NOMSG
	JAL	R9,CRQPRI		:PRINT LABEL TO USER
	LR	R1,R3			:SET UP TO CONTINUE
	L	R14,TEMP3		:RESTORE R14
	L	R2,TEMP3+4		:AND R2

:	SEND MESSAGE TO DESTINATION

NOLAB	LHL	R1,PTBLE,R1,R1		:GET DESTINATION, OTHERWISE FLUSH IT
	JE	IDATA2			:DEST SHOULD BE HERE
SKPLAB  SBT     R1,TPORT,,              :FLAG AS AN ACTIVE PORT
        LHI     R0,3,R2                 :COMPUTE MSG BYTE COUNT
	JAL	R4,SLOR			:START OUTPUT RECORD
	JAL	R4,GETCH		:FLUSH MSG TYPE

IDATA0	JAL	R4,GETCH		:GET CHAR FROM IRING
	JAL	R4,PUTCH		:PUT IT IN ORING
	SIS	R2,1			:DEC BYTE COUNT
	JG	IDATA0			:COPY ALL CHARS IN MSG

	JAL	R4,ELIR			:END INPUT
	JAL	R4,ELOR			:END OUTPUT
	J	INPUT			:GO CHECK INPUT AGAIN

IDATA2	LHI	R0,1,R2			:MAKE BYTE COUNT TO FLUSH
	JAL	R4,FLUSH		:FLUSH
	J	INPUT			:GO CHECK INPUT AGAIN

:	THIS IS DATA FROM THE BOSS, GIVE IT TO THE COMMAND PROCESSOR

IDAT05  EQ      .
	LR	R10,R1			:R10 WILL KEEP THE BOSSP
	JAL	R4,GETCH		:READ PAST MSG TYPE (CNT)
	LR	R12,R2			:COPY CHAR COUNT
        STB     R12,CHRCNT
	L	R5,CMNDAD,R13		:GET ADDR LAST CALL FOR CHAR
	L	R6,CMNDR6,R13		:RESTORE SAVED REGISTERS
	L	R7,CMNDR7,R13
	L	R8,CMNDR8,R13
	L	R9,CMNDR9,R13

IDAT10	JAL	R4,GETCH		:GET A CHAR
	LH	R4,ESCAPE,R13
	JL	SPECIA
        LR      R3,R0
        NHI     R3,7F
	CLB	R3,ATCHAR,R13		:USER'S ATTENTION CHARACTER?
	JNFS	IDAT15
	TS	ESCAPE,R13		:SET FOR RESPONSE TO NEXT CHAR
	JFS	IDAT20
IDAT15	STM	R14,CSAVE		:SAVE REGS
	JR	R5			:GIVE CHAR TO USER PROCESS

:	ENTRY FROM COMMAND PROCESSOR TO GET A CHAR
:		R5 = LINK

GDAT	LM	R14,CSAVE		:RESTORE RING REGISTERS
IDAT20	SIS	R12,1			:DEC COUNT FOR THIS RECORD
	JN	IDAT10			:JUMP MORE IN RECORD

	JAL	R4,ELIR			:END INPUT RECORD
	ST	R5,CMNDAD,R13		:SAVE LAST CALL FOR CHAR ADDR
	ST	R6,CMNDR6,R13		:SAVE REGS
	ST	R7,CMNDR7,R13
	ST	R8,CMNDR8,R13		:SAVE REG
	ST	R9,CMNDR9,R13
	J	INPUT			:CHECK INPUT AGAIN

:	THIS CHAR WAS ESCAPED BY USER'S ATTENTION CHAR

SPECIA	LIS	R3,0
	STH	R3,ESCAPE,R13
	LR	R3,R0			:GET THE CHARACTER
	NHI	R3,5F			:REMOVE THESE BITS
	CLHI	R3,AT.SC		:SELECT CMD MODE?
	JE	SPEC1			:SKIP IF SO
	STM	R14,CSAVE		:SAVE THE RING REGISTERS
	J	4,R5			:SKIP RETURN IF ESCAPED CHARACTER

SPEC1	L	R1,PSNTMR,R13		:SEE IF WAITING FOR PSEUDO-NDL
	JEFS	SPEC2			:NOPE, GO AHEAD
	LHL	R1,UFLAG,R13		:YEP, CAN'T GO TO CMD MODE
	OHI	R1,FCMD			:*JUST YET, SET FLAG SO WE
	STH	R1,UFLAG,R13		:*WILL LATER
	J	IDAT20

SPEC2	JAL	R6,CMODE		:SET FOR COMMAND MODE
	J	IDAT20			:GO DIRECTLY TO COMMAND MODE

: NON-DATA MSG ( ON PORT # >0)  - FAN OUT BY TYPE
:		R1 - PORT #
:		R2 - MESSAGE TYPE

INDATA	CLHI	R2,APNMSG		:PSEUDO-NEEDLE?
	JE	INDAPN			:BR IF SO
	TBT	R1,APORT		:ACTIVE?
	JE	INDEAT			:NOI
	CLH	R2,MAXMSG,,		:TYPE LEGAL?
	JG	INDCRH			:JUMP TO CRASH IF NOT
        LHL     R13,BTBLE,R1,R1         :GET BOSS BASE
	JE	CRASH			:MUST HAVE A BOSS
        AI      R13,UBLSEG              :USERBLOCK SEGMENT IS 3
	CLHI	R2,MAXTYP		:TYPE IN OUR TABLE?
	JGE	INDPAS			:BR IF NOT
	LH	R10,BOSSP,R13		:GET THE BOSS PORT
	LHL	R3,INDFAN-FIRST*2,R2,R2
	J	SEG1,R3	 		:FAN OUT

:	NON-DATA UNKNOWN - CRASH

INDCRH	JAL	R10,CRASH		:CRASH, CFROM HAS MSG TYPE
	BC	0,0,R2*4,CCINDT

: NON-DATA MESSAGE TYPE FAN-OUT TABLE

INDFAN	HC	INDCRH-SEG1		:9E - DETACH(YELLOW BALL & ZAP)
	HC	INDZAP-SEG1		:9F - DISCONNECT(ZAPPER)
	HC	INDBKP-SEG1		:A0 - APPLY BACKPRESSURE
	HC	INDBKP-SEG1		:A1 - REELEASE BACKPREESSURE
	HC	INDPAS-SEG1		:A2 - FLUSH OUTPUT (GOBBLE)
	HC	INDEAT-SEG1		:A3 - FLUSH INPUT
	HC	INDBLK-SEG1		:A4 - DATA LOST IN THIS DIRECTION
	HC	INDGRY-SEG1		:A5 - DATA LOST IN OTHER DIRECTION
	HC	INDEDM-SEG1		:A6 - ENTER DEFFERED ECHO MODE
	HC	INDLDM-SEG1		:A7 - LEAVE DEFERED ECHO MODE
	HC	INDEAT-SEG1		:A8 - ENTER TRANSPERENCY  &&X.25 FIX&&
	HC	INDEAT-SEG1		:A9 - LEAVE TRANSEPERENCY &&WAS PAS &&
	HC	INDGRN-SEG1		:AA - GREEN BALL
	HC	INDRED-SEG1		:AB - RED BALL
	HC	INDYEL-SEG1		:AC - YELLOW BALL
	HC	INDORN-SEG1		:AD - ORANGE BALL
	HC	INDBRK-SEG1		:AE - BREAK DETECTED
	HC	INDHNG-SEG1		:AF - HANG UP
	HC	QPARAM-SEG1		:B0 - QUERY TERMINAL PARAMETER
	HC	SPARAM-SEG1		:B1 - SET TERMINAL PARAMETER
	HC	INDCRH-SEG1		:B2 - AUX PSEUDO NEEDLE
	HC	INDCRH-SEG1		:B3 - NORMAL LOGON CHAR
	HC	INDNLS-SEG1		:B4 - NORMAL LOGON STATUS
	HC	INDLOF-SEG1		:B5 - LOGON FAILURE
	HC	INDLON-SEG1		:B6 - SUCCESSFUL LOGON
	HC	INDCRH-SEG1		:B7 - ADDENDUM TO ACCOUNTING
	HC	INDEAT-SEG1		:B8 - SUPER-HANG UP /IGNORE FOR SUP
	HC	INDEAT-SEG1		:B9 - TRANSMIT LIMIT
	HC	INDEAT-SEG1		:BA - 'BREAK' END
	HC	INDCRH-SEG1		:BB - ZAP ACK
	HC	INDPAS-SEG1		:BC - LEAVE ALTERNATE DEVICE
	HC	INDPAS-SEG1		:BD - ENTER ALTERNATE DEVICE
	HC	INDZAP-SEG1		:BE - ZAP WITH REASON
MAXTYP	EQ	(.-INDFAN)/2+FIRST	:MAX TYPE IN TABLE

: QUERY TERMINAL PARAMETER (B0)

QPARAM	JAL	R4,GETCH		:READ PAST MESSAGE TYPE
	JAL	R4,GETCH		:GET THE PARAMETER NUMBER
	LR	R9,R0			:SAVE IT
	JAL	R4,ELIR			:END THE INPUT
QPARM1	TBT	R1,TYMSAT		:DONT RESPOND TO TYMSATS
	JN	INPUT			:IF SO RETURN TO INPUT
	LR	R9,R9			:SEE IF ECHO
	JEFS	QECHO			:GO HANDLE SPECIALLY IF SO
	JAL	R8,QTPAR		:GET TERM PARAM
	JFS	QRESP

QECHO	LIS	R5,1			:PREPARE FOR ECHO ON RESULT
	TBT	R1,ECHO			:ECHO ON?
	JNFS	QRESP			:YES
	TBT	R1,DEM			:ABOUT TO GO ON
	JNFS	QRESP			:YES,RETURN AS ON
	LIS	R5,0

QRESP   TBT     R1,PSNEDL
        JN      INPUT
     	LHI	R2,STPMSG		:RESPONSE IS 'SET TERMINAL MESSAGE'
	LIS	R0,5
	JAL	R4,SLOR
	LR	R0,R9
	JAL	R4,PUTCH		:PUT THE PARAMETER NUMBER
	LR	R0,R5			:PLACE THE VALUE
	JAL	R4,PUTCH
	JAL	R4,ELOR			:END IT
	J	INPUT

: SET TERMINAL PARAMETER (B1)

SPARAM	JAL	R4,GETCH		:READ PAST MESSAGE TYPE
	JAL	R4,GETCH		:GET THE PARAMETER NUMBER
	LR	R9,R0
	JAL	R4,GETCH
	JAL	R4,ELIR			:END THE MESSAGE
	LR	R5,R0			:SAVE VALUE
:	SET TERM PARAM FROM BOSS
	CR	R1,R10			:SEE IF BOSS
	JN	SPAR3			:BR IF NOT
	CLHI	R9,NTRMCH		:SEE IF WE KNOW ABOUT TERM PARAM
	JGE	QPARM1			:BR IF NOT
	RBT	R9,ITCFLG,R13		:SEE IF NEED INITIAL VALUE
	JE	QPARM1			:BR IF NOT
	STB	R5,ITCVAL,R13,R9	:SAVE INITIAL VALUE
	JAL	R8,STPAR		:SET BOSS VALUE
	TBT	R9,INITIT		:SEE IF TO PASS TO ALL PORTS
	JE	QPARM1			:BR IF NOT
	LHL	R1,FPORT,R13
	JEFS	SPAR2
SPAR4   TBT     R1,PSNEDL               :A SEND PORT IN LOGIN MODE?
        JNFS    SPAR7                   :YES, SKIP IT
     	JAL	R8,STPAR		:SET ON ALL PORTS FOR THIS BOSS
SPAR7   LHL     R1,CTBLE,R1,R1          :GET NEXT IN CHAIN
	JNBS	SPAR4			:BR UNLESS DONE
SPAR2	LR	R1,R10			:GET PORT BACK
	J	QPARM1
:	SET ECHO ON
SPAR3	LR	R9,R9
	JN	SPAR6			:BR IF NOT ECHO
	NHI	R0,1
	JEFS	SECHO1
	TBT	R1,ECHO			:SET THE ECHO
	JN	SPAR5			:ALREADY ON ACKNOWLEDGE
	SBT	R1,DEM			:OFF, LET USUAL MECHANISM DO IT
	J	SPAR5
:	SET ECHO OFF
SECHO1	RBT	R1,ECHO			:RESET ECHO
	JEFS	SECHO2			:MAKE SURE IT STAYS OFF
	LIS	R0,3			:PREPARE ENTER DEF ECHO MSG
	LHI	R2,EDMMSG		:MESSAGE TYPE
	JAL	R4,SLOR			:START RECORD,R1 HAS PORT
	JAL	R4,ELOR			:END IT
SECHO2	RBT	R1,DEM			:DISARM GREEN BALLSTUFF
	RBT	R1,EXPECT		:DONT EXPECT ANY BALLS
	JEFS	SPAR5			:REPORT BACK IF NONE WERE OUT
	LIS	R0,3			:MSG SIZE
	LHI	R2,RBMSG		:CANCEL BALL THATS OUT
	JAL	R4,SLOR
	JAL	R4,ELOR			:SEND TO THE RING
	RBT	R1,TBOA			:RESET THE RED BALL TIMEOUTS
	RBT	R1,TBOB
	JFS	SPAR5			:GO ACKNOWLEDGE
:	SET TERM PARAM
SPAR6	JAL	R8,STPAR		:SET TERM PARAM
SPAR5	LHL	R2,UFLAG,R13
	THI	R2,FSEND		:SEE IF THIS IS CURRENT SEND PORT
	JE	QPARM1			:BR IF NOT
	CLH	R1,SPORT,R13
	JN	QPARM1			:BR IF NOT
	ST	R1,TEMP
	JAL	R8,SBPAR		:SEND TO BOSS NOW
	L	R1,TEMP
	J	QPARM1			:GO SEND RESPONSE

INITIT	WC	$2 00001111111110010000000000000000 :TERM PARAMS TO PASS TO
						:*ALL CIRCUITS IF BOSS CHANGES
: ORANGE BALL (AD)
:	IF YELLOW BALL OUT CONNECT INPUT AGAIN

INDORN  TBT     R1,BOSPRT               :IS THIS PORT A BOSS?
        JE      INDEAT                  :THIS ISN'T A BOSS--GO EAT
        LHL     R13,BTBLE,R1,R1         :GET USER BLCK ADDR
        AI      R13,UBLSEG              :USER BLOCKS IN SEG 3
	L	R0,CYBTIM,R13		:YELLOW BALL OUT
	JEFS	INDEAT			:NOPE, EAT
	LIS	R0,0			:RESET YELLOW BALL OUT
	ST	R0,CYBTIM,R13
	LA	R0,CGETW		:CONNECT INPUT PROCESS
	ST	R0,CMNDAD,R13

: NON-DATA DON'T CARE - EAT REMAINDER OF MESSAGE

INDEAT	LB	R0,LENGTH,R2,		:GET MSG SIZE
	JAL	R4,FLUSH		:EAT IT
	J	INPUT			:CHECK INPUT AGAIN

: PSEUDO-NEEDLE REJECT (0000,09)

PSNRJT	JAL	R4,GETH 		:SUBTYPE / KEY
	JAL	R4,GETH			:LOCAL KEY
	LR	R13,R0			:SAVE KEY AS INDEX
        AI      R13,UBLSEG              :USER BLKS IN SEG 3
	LIS	R0,0
	STH	R0,LGINFL,R13 		:MARK LOGIN STRING STORAGE AS UNUSED
	ST	R0,PSNTMR,R13		:CLEAR PSEUDO-NDL TIMER
        JAL     R3,RUPNTC               :REMOVE USRBLK FROM PSNDL TIMER CHAIN
	JAL	R4,GETCH		:TYPE OF ERROR
PSNRJ0	JAL	R4,ELIR
PSNRJ1	CLHI	R0,ARJMAX		:CHECK ERR #
	JLEFS	PSNRJ4			:SKIP IF OK
	LIS	R0,ARJMAX		:OUT OF RANGE - FORCE 7
PSNRJ4	SLHLS	R0,2			:MAKE WORD INDEX
	LR	R2,R0
	L	R3,ARJTYP,R2		:GET REJECT MSG TYPE
	JAL	R5,OMSG			:OUTPUT TO RING
	LHL	R10,BOSSP,R13		:BOSS PORT NMBR
	JAL	R6,CMODE		:GO TO COMMAND MODE
	ST	R5,CMNDAD,R13		:SET CMD LINK ADDR
	J	INPUT

: NORMAL LOGON STATUS (B4)

INDNLS	JAL	R4,GETH	 		:GET STATUS
	JAL	R4,ELIR
        LHI     R12,1F                  :MASK ERROR TYPE
	NR	R12,R0
	JE  	INDNL5			:IF ZERO (CONTINUE) SKIP MESSAGE
        TBT     R12,STA3O5              :IF STAT MSG <> 3 OR 5, DON'T
        JN      IND3O5                  :SAVE LOGIN STRING
        RBT     R1,LOGINS               :RE-SET LOGIN STRING DEFINED BIT
        LR      R6,R1
        LIS     R5,0
        LHI     R4,STRLEN
        MR      R5,R4                   :GET LOGIN STRING TBLE ENTRY ADDR
        LIS     R5,0
        STH     R5,STRTBL,R6            :0 OUT LENGTH FIELD AND DELIM FLAG
:	SEND 'ERROR' MESSAGE TO BOSS (ERROR, TYPE PASSWD,...)
IND3O5  EQ      .
	SLLS	R12,2			:CREATE WORD INDEX
	LHL	R2,BOSSP,R13		:GET BOSS PORT FOR MESSAGE
	JEFS	INDNL5			:SKIP OUTPUT IF NO BOSS
	L	R3,NLSTYP,R12		:GET ADDR OF MESSAGE
	LR	R6,R1			:SAVE PORT NUMBER
	LR	R7,R0			:SAVE REG 0 (FOR ECHO/EMPTY INFO)
	JAL	R5,OCS			:PRINT STRING
	LR	R1,R6			:RESTORE PORT #
	LR	R0,R7			:RESTORE REG 0

INDNL5	HS	0
	THI	R0,$210100000		:EMPTY BUFFER (EITHER) ?
	JEFS	INDNL6			:NO, SKIP
	LIS	R6,0
	STH	R6,LGINFL,R13		:SET FILL POINTER AND
	STH	R6,LGINEM,R13		:EMPTY POINTER TO ZERO
INDNL6	HS	0
:	SET ECHO ON/OFF BASED ON SUP FLAG
	NHI	R0,FPASEC		:ISOLATE PASWORD ECHO BIT
	LHL	R2,UFLAG,R13		:GET USER FLAGS
	NHI	R2,@FPASEC		:ZERO PASSWORD BIT
	OR	R0,R2			:SUM THEM
	STH	R0,UFLAG,R13		:SAVE IT BACK
	STH	R1,LPORT,R13		:START SENDING MORE B3'S
        JAL     R5,PUBB3Q               :PUT USER BLOCK ON B3 QUEUE
	J	INPUT			:CONTUINUE

: LOGON FAILURE	(B5)

INDLOF	JAL	R4,GETH	 		:GET MSG / ERR #
	JAL	R4,ELIR
	LBR	R0,R0			:ISOLATE ERROR CODE
	LR	R10,R1			:SAVE PORT NMBR
	CLHI	R0,ARJMAX		:CHECK ERR #
	JLEFS	INDL10			:SKIP IF OK
	LIS	R0,ARJMAX		:OUT OF RANGE - FORCE 7
INDL10	SLHLS	R0,2			:MAKE WORD INDEX
	LR	R2,R0
	L	R3,ARJTYP,R2		:GET REJECT MSG TYPE
	JAL	R5,OMSG			:OUTPUT TO RING
	LR	R1,R10			:PORT NMBR TO ZAP
	LHL	R10,BOSSP,R13		:BOSS PORT
	JAL	R6,ZAP			:ZAP PORT
	J	INPUT

: PSEUDO-NEEDLE RECEIVED (B2)

INDAPN	JAL	R4,GETH			:SKIP TYPE AND KEY
	JAL	R4,GETH	 		:LOCAL KEY
	LR	R13,R0                  :LOCAL KEY CONTAINS USR BLCK ADDR
        AI      R13,UBLSEG              :USER BLOCKS IN SEG 3
	JAL	R4,ELIR
	SBT	R1,PSNEDL		:INDICATE PSEUDO NEEDLE RECEIVED
	JN	INDCRH			:THIS SHOULD BE ZERO
	SBT	R1,APORT		:SET ACTIVE PORT

	SBT	R1,TPORT,,		:SET FOR INACTIVITY TIMER, GOT DATA	
	STH	R1,LPORT,R13		:PORT CURRENTLY IN LOGON
        JAL     R5,PUBB3Q               :PUT USER BLOCK ON B3 MODE QUEUE
APN02   STH     R1,SPORT,R13            :CURRENT PORT
	RBT	R1,DEM			:RESET DEM MODE
	RBT	R1,EXPECT
	STH	R13,BTBLE,R1,R1
	LHL	R4,FPORT,R13		:PUT ON CHAIN FOR THIS BOSS
	STH	R1,FPORT,R13
	STH	R4,CTBLE,R1,R1

	RBT	R1,DUMP			:NOT FLUSHING DATA ON THIS PORT
	RBT	R1,STOPPD		:OR BACKPRESSURING THIS PORT
	LHL	R10,BOSSP,R13		:OUTPUT GOES TO BOSS
	STH	R10,PTBLE,R1,R1		:/

        LR      R6,R1
        SLLS    R6,NLENS		:INDEX INTO NAME TABLE
	LHL	R4,TOKLEN,R13
	JN	APN40			:BR IF NAME SPECIFIED
	LHI	R0,0104
	STH	R0,NTBLE,R6
	LHI	R0,0AE			:DEFAULT NAME IS "." & PORT NMBR
	STB	R0,NTBLE+2,R6
        LA      R14,NTBLE+3,R6
        LIS     R4,0A
        LIS     R15,3
        JAL     R5,CBA			:CONVERT ISIS PORT NMBR
	LR	R3,R1
	LA	R7,NOMSG
	JAL	R9,CRQPRI		:PRINT CIRCUIT NAME
	J	APN50

APN40	CLHI	R4,$A 14		:TRUNCATE NAME TO 14 CHARS
	JLEFS	APN41
	LIS	R4,$A 14
APN41	STB	R4,NTBLE+1,R6		:SAVE NAME LENGTH
	LHL	R5,TOKSTR,R13
        AI      R5,UBLSEG               :USER BLOCKS IN SEG 3
	LIS	R7,0
APN45	LB	R0,0,R5			:MOVE NAME FROM CMD LINE TO TABLE
	OHI	R0,80
	STB	R0,NTBLE+2,R7,R6
	AIS	R7,1
	AIS	R5,1
	SIS	R4,1
	JGBS	APN45
	LIS	R1,1
	STB	R1,NTBLE,R6

APN50	LIS	R12,0
	STH	R12,LGINEM,R13		:INITIAL LOGIN INDEX (EMPTY)
	ST	R12,PSNTMR,R13		:RESET PSEUDO-NDL TIMER
        JAL     R3,RUPNTC               :REMOVE USRBLK FROM PSNDL TIMER CHAIN
	LA	R3,IPLIMS		:PRINT "please log in: '
	JAL	R5,OMSG

	LHL	R3,BOSSP,R13		:BOSS PORT NMBR
	LHL	R2,LPORT,R13		:THIS PORT NMBR
	LB	R1,CCT,R3		:SAVE CCT FROM BOSS
	STB	R1,CCT,R2
	LB	R1,TPC,R3		:SEND THRUPUT CLASS
	STB	R1,TPC,R2
	AHI	R1,81
	STB	R1,NLCHAR+2
	LA	R3,NLCHAR
	JAL	R5,OCM

	LHL	R1,UFLAG,R13		:SEE IF USER TRIED TO GO TO CMD
	THI	R1,FCMD			:*MODE WHILE WE WERE WAITING
	JE	INPUT			:NOPE, ALL DONE
	NHI	R1,@FCMD
	STH	R1,UFLAG,R13		:YEP, RESET FLAG
	JAL	R6,CMODE		:GO TO COMMAND MODE
	ST	R5,CMNDAD,R13
	J	INPUT

: SUCCESSFUL LOGON (B6)

INDLON	JAL	R4,GETH			:SKIP TYPE AND IIX
	JAL	R4,GETW			:GET INVOICE NMBR
	LR	R4,R1
	SLLS	R4,2			:MAKE INDEX FROM PORT NMBR
	ST	R0,INVNUM,R4		:SAVE INVOICE NMBR (JFG)
	JAL	R4,GETH			:SKIP ORIG HOST
	JAL	R4,ELIR			:END OF MSG
	RBT	R1,ECHO			:START MODE FOR TYMSAT SIDE
	SBT	R1,NBO			:NO BALLS OUT FOR THIS PORT
	RBT	R1,TYMSAT
	RBT	R1,PSNEDL		:INDICATE LOGON COMPLETE
	JE	INDCRH			:CRASH IF NOT ALREADY SET
	STH	R1,SPORT,R13		:SEND BOSS RIGHT INTO TRANSPERENCY
	ST	R1,CMNDR6,R13		:SET UP THE COMMAND REGISTERS
	STH	R10,PTBLE,R1,R1		:SET DESTINATION
	LIS	R2,0
	STH	R2,LPORT,R13		:REMOVE PORT FROM LOGON MODE
	STH	R2,B3NEXT,R13
	ST	R2,CMNDR7,R13		:INITIATE COMMAND REGISTER
	LA	R5,CSN040		:PUT BOSS IN SEND MODE
	ST	R5,CMNDAD,R13		:NEEDLE TO COMMAND PROCESSOR
	LHI	R0,FSEND
	OH	R0,UFLAG,R13		:SET SEND FLAG
	NHI	R0,@FLOG		:TURN OFF LOG
	STH	R0,UFLAG,R13

	LR	R6,R1			:SAVE PORT #
	LIS	R9,1
INL10	LR	R1,R10			:GET CURRENT BOSS TERM PARAM
	JAL	R8,QTPAR
	LR	R1,R6
	JAL	R8,STPAR		:SET NEW CIRCUIT TERM PARAMS
	AIS	R9,1			:*TO BOSS'S INITIAL VALUES
	CLHI	R9,NTRMCH
	JL	INL10

	LR	R2,R6			:PORT FOR OCM
	LA	R3,SETXMT		:SET XMIT LIMIT MESSAGE
	JAL	R5,OCM

	LR	R2,R10
	SLLS	R2,2			:MAKE INDEX FROM BOSS PORT NMBR
	L	R2,INVNUM,R2		:SEND BOSS CIRCUIT INVOICE
	OI	R2,0EA000000		:*NMBR AS SERVER
	ST	R2,ACCTNG,,
	LR	R2,R6
	LA	R3,ACCTAD
	JAL	R5,OCM			:SEND ACCOUTING ADDENDUM

:	COPY LOGIN BUFFER OUT TO PORT FOR 'TYPE AHEAD'

	LR	R1,R6			:RESTORE PORT # (WIPED BY OCM)
	LH	R12,LGINEM,R13		:R12=EMPTY INX.GET EMPTY INDEX
	LH	R12,LGINFL,R13		:R12=FILL INX.COMPARE TO FILL POINTER
	SH	R12,LGINEM,R13		:R12=LENGTH
	JLE	INPUT			:CAUGHT UP, NO DATA TO SEND

	LHI	R0,3,R12		:R00=LEN+3 :COMPUTE RECORD SIZE
	LR	R2,R12			:R02=LENGTH :GET MSG NMBR (BYTE LEN)
	JAL	R4,SLOR			:START OUTPUT
	LH	R12,LGINEM,R13		:R12=EMPTY INX.
	LA	R3,UBUFER,R12,R13	:R03=STRING ADDRESS
	JAL	R5,OBS			:OUTPUT STRING
	JAL	R4,ELOR			:CLOSE OFF RECORD
	J	INPUT

: NON-DATA BACKPRESSURE (A0/A1)
:	APPLY THE MESSAGE (A0,A1)TO ALL PORTS WITH THIS AS DEST

INDBKP	LR	R5,R1			:SAVE THE PORT
	LIS	R0,3			:SENDING 3 BYTES
	LHL	R1,FPORT,R13		:GET FIRST PORT
BKP0	JE	INDEAT			:BR IF NO MORE PORTS TO CHK
	CH	R5,PTBLE,R1,R1		:DO THIS ONE?
	JN	BKP1
	CLH	R1,SPORT,R13		:SEE IF CURRENT SEND PORT
	JNFS	BKP2			:NOPE
	LHL	R4,UFLAG,R13
	THI	R4,FSEND
	JNFS	BKP3			:YES, SEND BKPR MSG ON ANYWAY
BKP2	TBT	R1,STOPPD		:UNLESS REQUESTED BY BOSS
	JNFS	BKP1
BKP3    TBT     R1,PSNEDL               : A SEND PORT IN LOGIN MODE?
        JNFS    BKP1                    :YES, SKIPT IT
    	JAL	R4,SLOR			:SEND MESSAGE IN R2
	JAL	R4,ELOR
BKP1	LHL	R1,CTBLE,R1,R1		:GET NEXT PORT TO CHECK
	J	BKP0

: CIRCUIT ZAPPER/HANG (9F/AF)

INDZAP	LIS	R0,1			:EAT ZAPPER AND CLOSE RECORD
	JAL	R4,FLUSH
	JAL	R6,ZAP1			:PROCESS PORT ZAP
	J	INPUT

INDHNG	LIS	R0,1			:EAT HANG AND CLOSE RECORD
	JAL	R4,FLUSH
	JAL	R6,ZAP		
	J	INPUT

: BLACK/GRAY BALL (A4/A5)

INDGRY	LA	R7,GREY			:GRAY BALL MSG
	JFS	INDB10

INDBLK	LA	R7,BLACK		:BLACK BALL MSG
INDB10	CLH	R1,SPORT,R13
	JNFS	INDB20
	LHL	R2,UFLAG,R13		:SEND IT IF CURRENT PORT
	THI	R2,FSEND
	JEFS	INDB20
	TBT	R1,DUMP
	JNFS	INDB30			:DON'T SEND IF TRASHING DATA ANYWAY
INDB20  TBT     R1,PSNEDL               :A SEND PORT IN LOGIN MODE?
        JNFS    INDB30                  :YES, SKIPT IT
      	LR	R3,R1
	JAL	R9,CRQPRI
INDB30	LIS	R0,1
	JAL	R4,FLUSH		:EAT MSG
	J	INPUT

: BREAK DETECTED (AE)
:	SEND GOBBLER DOWN THE LINE

INDBRK  TBT     R1,PSNEDL
        JN      INDEAT
      	LHI	R2,GOBMSG
	LIS	R0,3
	JAL	R4,SLOR
	JAL	R4,ELOR
        LHI     R2,BRKMSG
        CLH     R1,BOSSP,R13            :IS IT THE BOSS?
        JN      INDPAS                  :NOPE.  JUST PASS IT.
        LHL     R1,SPORT,R13            :YEP, SEND BREAK ON OUR CURRENT PORT
        JE      INDEAT                  :UNLESS WE DON'T HAVE ONE
        J       INDBNC

: ENTER OR LEAVE DEFFERED ECHO MODE (A6/A7)

INDEDM	SBT	R1,DEM
	J	INDEAT

INDLDM	RBT	R1,DEM			:RESET IT
	J	INDEAT

: GREEN BALL (AA)
:	IF FROM BOSS TREAT AS IF THIS WERE BASE
:	IF FROM BASE, TREAT AS IF THIS WERE TYMSAT

INDGRN	CR	R1,R10			:IS THIS THE BOSS?
	JE	BOSGRN			:IF SO HANDLE DIFFERENT
	RBT	R1,EXPECT		:WERE WE EXPECTING?
	JE	INDEAT			:NO
	SBT	R1,NBO			:NO MORE BALLS OUT
	SBT	R1,ECHO			:RESTORE ECHO
	RBT	R1,DEM			:AND EMIT NO MORE(IN ECHO MODE NO MORE)
	JE	INDEAT			:IF OFF ALREADY DONT SEND LDMMSG
	LIS	R0,1			:EAT REMAINDER OF INPUT
	JAL	R4,FLUSH		:FLUSH IT(R0 HAS BYTES TO FLUSH)
        TBT     R1,PSNEDL               :THIS PORT IN LOGIN MODE?
        JNFS    INDGR1                  :YES, DON'T SEND LDM MSG
	LIS	R0,3			:PREPARE NEW MESSAGE
	LHI	R2,LDMMSG		:TELLING BASE"LEAVE DEFFERED ECHO"
	JAL	R4,SLOR			:START IT
	JAL	R4,ELOR			:END IT
INDGR1  LR      R1,R10                  :GET BOSS PORT
	JE	INPUT
	RBT	R1,EXPECT		:SEE IF BOSS WAITING TO END DEM
	JE	INPUT			:BR IF NOT
        TBT     R1,PSNEDL               :THIS PORT IN LOGIN MODE?
        JN      INPUT                   :YES, DON'T SEND GB MSG
	LIS	R0,3
	LHI	R2,GBMSG		:SEND GREEN BALL ON TO BOSS
	JAL	R4,SLOR
	JAL	R4,ELOR
	J	INPUT

BOSGRN	LHI	R0,FSEND		:IN SEND MODE?
	NH	R0,UFLAG,R13
	JE	INDBNC			:GO BOUNCE GB IF NOT
	LH	R0,SPORT,R13		:GET CURRENT SEND PORT
	JE	INDEAT
	TBT	R0,DEM			:SEND PORT IN DEM?
	JE	INDBNC			:GO BOUNCE GB IF NOT
	SBT	R1,EXPECT		:WAIT FOR SEND PORT TO LEAVE DEM
	J	INDEAT

: RED BALL (AB)
:	LIKE GREEN, THE RED HAS TWO MODES, BASE AND TYMSAT

INDRED  TBT     R1,BOSPRT               :IS PORT A BOSS?
        JNFS    INRED2                  :JUMP IF FROM BOSS
	SBT	R1,NBO			:ELSE, JUST NOTE ITS RETURN
	J	INDEAT

INRED2	RBT	R1,EXPECT		:BOSS NOT WAITING FOR GRN BALL NOW
	JFS	INDBNC			:GO BOUNCE RED BALL

: YELLOW BALL (AC)

INDYEL	AIS	R2,1			:CONVERT TO ORANGE

: BOUNCE NON-DATA MSG - SEND MSG JUST RECEIVED BACK TO SENDER
:			R2 HAS MSG TYPE, ASSUMED TO BE LENGTH 3
INDBNC	LIS	R0,1			:EAT REMAINDER OF INPUT
INDBN2	JAL	R4,FLUSH
        TBT     R1,PSNEDL
        JN      INPUT
	LIS	R0,3			:MSG LENGTH 3
	JAL	R4,SLOR			:SEND MSG TYPE IN R2
	JAL	R4,ELOR
	J	INPUT			:CHECK INPUT AGAIN

: SEND NON-DATA MESSAGE ALONG TO DESTINATION
:		R1 = INPUT PORT #
:		R2 = MESSAGE TYPE

INDPAS	LHL	R1,PTBLE,R1,R1		:GET DESTINATION PORT #
	JE	INDEAT			:SKIP IF PORT NOT ASSIGNED
	LB	R0,LENGTH,R2,		:GET LENGTH OF MSG
	J	INDBN2			:GO SEND DATA ON
	SUBTTL	LOGIN CHAR SENDER
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::              L O G I N  C H A R  S E N D E R                 ::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

OUTPUT  L       R13,B3PNTR              :PTR TO 1ST USRBLK IN B3MODE CHAIN
        JE      OUTP3                   :NONE IN B3CHAIN--CHECK PSNDL TMR CHAIN
OUTP2	LHL	R9,LPORT,R13            :GET PORT THAT IS DESTINATION OF B3DATA
        LR      R6,R9
        LIS     R5,0                    :SET UP R5 FOR MR OP
        LHI     R4,STRLEN               :MULTIPLY PORT BY LENGTH OF
        MR      R5,R4                   :ENTRY TO LOGIN STRING TBLE
                                        :R6=ADDR OF THIS TABLE ENTRY
	LHL	R12,LGINEM,R13		:GET LOGIN CHARACTER INDEX
LGG0	CLH	R12,LGINFL,R13		:IS THE BUFFER EMPTY
	JGE	LGG2			:YES WAIT TIL USER ADD CHAR
	LB	R8,UBUFER,R12,R13	:GET LOGIN CHAR
	OHI	R8,80			:SET MSB FOR SUP
	STB	R8,NLCHAR+2		:PUT CHAR IN MSG
	LA	R3,NLCHAR		:ADDR OF MSG
	LR	R2,R9			:PORT#
	JAL	R5,OCM			:OUTPUT LOGIN CHAR
	AIS	R12,1			:INC CHAR INDEX
        TBT     R9,LOGINS               :LOG-IN STRING DEFINED?
        JE      LGG4                    :NO, STUFF BYT IN STRTBL
        CLHI    R8,8D                   :CR?
        JE      LGG3                    :YES, TAKE OF OF CHAIN
        CLHI    R8,0BB                  :LF?
        JE      LGG3                    :YES, TAKE OFF OF CHAIN
        J       LGG2                    :ELSE STILL IN B3 MODE
LGG4    EQ      .
        STB     R8,STRTBL+1,R6,R12      :SAVE CHAR IN LOGINSTRING TBLE
	CLHI	R8,0BB			:SEMI-COLON?
	JE	LGG1			:YES
	CLHI	R8,8D			:<CR>?
	JE	LGG1A
        CLHI    R12,STRLEN-2            :REACHED MAX CHAR LIM FOR TABLE?
        JL      LGG0                    :NO, KEEP GOING
        STB     R12,STRTBL+1,R6         :SAVE LEN
        SBT     R9,LOGINS               :SET BIT FOR LOGIN STRING DEFINED FLAG
        J       LGG0                    :GET NEXT CHAR
LGG1    EQ      .
        CLHI    R12,1                   :IF 1ST BYT = SEMICOL THEN DON'T
        JE      LGG3                    :SET LENGTH OR LOGINS BIT
        STB     R8,STRTBL,R6            :SAVE SEMICOL BYT IN BYTE 0 OF
        J       LGG1B                   :ARRAY TO FLAG THAT SEMI WAS REC'D
LGG1A   EQ      .
        LB      R5,STRTBL,R6            :GET SEMICOL FLAG BYTE
        LR      R5,R5                   :IF NOT 0 THEN DON'T UPDATE LENGTH
        JN      LGG3                    :AND DON'T SET LOGINS BIT
        CLHI    R12,1                   :IF FIRST CHAR IS CR, DON'T SAVE
        JE      LGG3                    :LENGTH AND DON'T SET LOGINS BIT
LGG1B   STB     R12,STRTBL+1,R6         :SAVE LENGTH OF STRING 
        SBT     R9,LOGINS               :SET LOGIN STRING DEFINED BIT
LGG3    EQ      .                       :TAKE AWAY FROM B3MODE CHAIN
        L       R4,B3PNTR               :THIS USRBLK = START OF CHAIN?
        CR      R4,R13
        JN      OUTP2A                  :JUMP IF NOT 1ST IN CHAIN
        L       R6,B3NEXT,R13           :IS IT ALSO LAST IN CHAIN?
        JE      OUTP2B                  :YES, IT'S THE ONLY USRBLK IN CHAIN
        ST      R6,B3PNTR               :NXT IN OLD CHN BECOMES NEW 1ST IN CHN
        LIS     R4,0
        ST      R4,B3PREV,R6            :0 OUT B3PREV OF NEW 1ST IN CHAIN
        ST      R4,B3PREV,R13           :0 OUT PTRS IN BLK REMOVED FROM CHN
        ST      R4,B3NEXT,R13           :0 OUT PTRS IN BLK REMOVED FROM CHN
        STH     R12,LGINEM,R13          :UPDATE LGINEM
        LR      R13,R6                  :POINT TO NEXT BLK IN CHAIN
        J       OUTP2                   :CHECK NEXT IN CHAIN
OUTP2B  LIS     R4,0                    :NO MORE IN CHAIN
        ST      R4,B3PNTR               :0 OUT PTR TO FIRST IN B3MODE CHAIN
        STH     R12,LGINEM,R13          :UPDATE LGINEM
        J       OUTP3                   :CHECK PNTPTR
OUTP2A  L       R6,B3NEXT,R13           :IF 0, IT'S AT END OF CHAIN
        JN      OUTP2C                  :ELSE IT'S IN MIDDLE OF CHAIN
        L       R6,B3PREV,R13           :GET PTR TO PREVIOUS BLK 
        LIS     R4,0                    :0 OUT NEXT PTR OF THAT BLK
        ST      R4,B3NEXT,R6
        ST      R4,B3PREV,R13           :0 OUT PREV PTR OF CURRENT BLK
        STH     R12,LGINEM,R13          :UPDATE LGINEM
        J       OUTP3                   :UPDATE LGINEM AND CHECK PNTPTR
OUTP2C  L       R4,B3PREV,R13           :B3PREV OF NEXT USRBLK BECOMES
        ST      R4,B3PREV,R6            :B3PREV OF CURRENT USRBLK
        ST      R6,B3NEXT,R4            :PRV BLK POINTS TO NXT BLK
        LIS     R4,0                    : 0 OUT PTRS OF REMOVED BLK
        ST      R4,B3NEXT,R13
        ST      R4,B3PREV,R13
        STH     R12,LGINEM,R13          :UPDATE LGINEM
        LR      R13,R6                  :NEXT IN CHAIN BECOMES CURRENT
        J       OUTP2                   :CHECK IT
LGG2	STH	R12,LGINEM,R13		:SAVE LOGIN CHAR INDEX
        L       R13,B3NEXT,R13          :GET NEXT IN B3MODE CHAIN
        JN      OUTP2                   :IF 0, DON'T LOOP BACK

OUTP3   EQ      .                       :CHECK PSNDL TIMER CHAIN
        L       R13,PNTPTR              :CHECK 1ST IN PSNDL TIMER CHAIN
        JE      OUTP4                   :GET OUT OF OUTPUT LOOP IF NONE
OUTP3A  L       R1,PSNTMR,R13           :GET PSNDL TMR FOR BLK
        CL      R1,SLOWC,,              :IS TIMER EXPIRED?
        JG      OUTP3B                  :JUMP IF NOT
        LHL     R2,BOSSP,R13
	LA	R3,BDNDCD		:TELL USER ABOUT TIMEOUT
	JAL	R5,OCS
	JAL	R6,CMODE		:GO TO COMMAND MODE
	ST	R5,CMNDAD,R13
	LHL	R0,UFLAG,R13		:RESET CMD MODE FLAG
	NHI	R0,@FCMD
	STH	R0,UFLAG,R13
	LIS	R0,0
	ST	R0,PSNTMR,R13		:RESET PSEUDO-NDL TMR
        JAL     R3,RUPNTC               :REMOVE USRBLK FROM PSDNDL TIMER CHAIN
OUTP3B  L       R6,PNTNXT,R13           :CHECK NXT IN CHAIN
        JE      OUTP4                   :IF END OF CHAIN, GET OUT
        LR      R13,R6                  :ELSE R13 WILL POINT TO NXT BLK
        J       OUTP3A                  :JUMP AND CHECK IT

OUTP4   SVC     FASTD,0
	J	INPUT
	SUBTTL	COMMAND PROCESSOR
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::              C O M M A N D     P R O C E S S O R               ::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

: EAT ALL INPUT - WATCH YELLOW BALL OUT TIMER

CEAT    EQ      .
        L       R1,SUPUSR,R13           :WAS THIS BLK CHANGED BY SUPLIC USER?
        JE      CEAT0                   :IF SO, SUPUSR=ADDR OF THIS USER
        LIS     R4,0                    :0 IT OUT
        ST      R4,SUPUSR,R13
        LR      R13,R1                  :GET BACK TO ORIGINAL R13 VALUE
        LA      R1,CBUFER,R13
        STH     R1,STRPOS,R13
        LA      R3,PROMPT
        LR      R2,R10
        JAL     R5,OCS
CEAT2   LM      R14,CSAVE
        SIS     R12,1
        JE      CEAT3
        JAL     R4,GETCH        
        L       R2,CYBTIM,R13
        JE      CEAT2
        CL      R2,SLOWC,,      
        JG      CEAT2
        LIS     R2,0
        ST      R2,CYBTIM,R13
        J       CEAT4
CEAT3   JAL     R4,ELIR
CEAT4   LA      R4,CGETW
        ST      R4,CMNDAD,R13
        J       INPUT
CEAT0   EQ      .
        LA      R3,PROMPT
	JAL	R5,OMSG			:OUTPUT PROMPT STRING

CEAT1	JAL	R5,GDAT			:GET ANOTHER INPUT CHAR
	L	R2,CYBTIM,R13		:YELLOW BALL OUT?
	JEBS	CEAT1			:NOPE,EAT INPUT
	CL	R2,SLOWC,,		:YEP,IS TIMEOUT UP?
	JGBS	CEAT1			:NOPE, EAT INPUT
	LIS	R2,0
	ST	R2,CYBTIM,R13		:RESET YELLOW BALL OUT

: GET AND PROCESS A COMMAND, STARTING WITH CHAR IN R0

CGETW	LHI	R6,CBUFSZ
	STH	R6,STRSIZ,R13		:SET UP LENGTH
	LA	R6,PROMPT
	ST	R6,UPRMT,R13		:SET UP PROMPT ADDR
        LA      R6,TLKPRM               :SET UP TALK PROMPT ADDR
        ST      R6,UTKPRM,R13
	LIS	R6,0
	LA	R7,CBUFER,R13
        LA      R9,SRCH                 :WHERE TO GO WHEN DONE
	J	CSTART

: GET NEXT COMMAND

CPRMPT  EQ      .
        L       R1,SUPUSR,R13           :WAS THIS BLK CHANGED BY SUPLIC USER?
        JE      CPRMP0                  :IF SO, SUPUSR=ADDR OF THIS USER
CPRMP3  LIS     R4,0
        ST      R4,SUPUSR,R13           :0 IT OUT
        LR      R13,R1                  :GET BACK TO ORIGINAL R13 VALUE
        LA      R1,CBUFER,R13           :RE-SET STRPOS
        STH     R1,STRPOS,R13
        LA      R3,PROMPT
        LR      R2,R10
        JAL     R5,OCS
CPRMP1  LM      R14,CSAVE
        SIS     R12,1                   :IF ANY OTHER INPUT, GET RID OF IT
        JE      CPRMP2
        JAL     R4,GETCH
        J       CPRMP1
CPRMP2  JAL     R4,ELIR                 :END INPUT RECORD
        LA      R4,CGETW
        ST      R4,CMNDAD,R13
        J       INPUT
CPRMP0  EQ      .
      	LHL	R1,TOKDLM,R13		:SKIP TO LAST CMD'S DELIMITER
	TBT	R1,EOCARY
	JNFS	CPR10
	JAL	R9,CGETOK
        J       CPRMP0

CPR10	LHL	R6,STRPOS,R13		:CUR PARSE POSITION
	AIS	R6,1
	CLHI	R1,3B			:SEE IF LAST CMD ENDED WITH SEMI
	JE	SRCH4			:BR IF SO

	LHI	R6,CBUFSZ		:INPUT COMMAND
	LA	R7,CBUFER,R13
	LA	R8,PROMPT
        JAL     R9,CSTRNG

:	SEARCH THE COMMAND LIST FOR THE COMMAND

SRCH	LA	R6,CBUFER,R13
SRCH4	STH	R6,STRPOS,R13		:INIT CMD PARSER
	JAL	R9,CGETOK		:GET CMD TOKEN
	LHL	R0,TOKLEN,R13
	JE	CPRMPT			:BR IF NULL CMD

	LA	R7,CFAN			:COMMAND FAN-OUT TABLE ADDR
SRCH2	JAL	R4,MTCH			:CHECK AN ENTRY
	J	SRCH3			:BR IF A MATCH
	AHI	R7,CMDLEN		:BUMP TO NEXT ENTRY
	CLI	R7,CEND			:SEE IF END OF TABLE
	JLBS	SRCH2			:LOOP IF NOT
CBTCH2	LA	R3,BMSG2		:BAD COMMAND
	J	CBITCH

SRCH3	LHL	R5,CMDTLN,R7
	J	SEG1,R5			:BR TO HANDLE COMMAND

:	BITCH LIST

CBTCH1	LA	R3,BMSG1
	J	CBITCH
CBTCH3	LA	R3,BMSG3
        J       CBITCH
CBTCH4	LA	R3,BMSG4
        J       CBITCH
CBTCH5	LA	R3,BMSG5
        J       CBITCH
CBTCH7	LA	R3,BMSG7
        J       CBITCH
CBTCH8  LA      R3,BMSG8
        J       CBITCH
CBTCH9  LA      R3,BMSG9
        J       CBITCH
CBTCHA  LA      R3,BMSG0A
        J       CBITCH
CBTCHB  LA      R3,BMSG0B
        J       CBITCH
CBTCHC  LA      R3,BMSG0C
        J       CBITCH
CBTCHD  LA      R3,BMSG0D
        J       CBITCH
CBTCHE  LA      R3,BMSG0E
        J       CBITCH
CBTCHF  LA      R3,BMSG0F               :"DID NOT ENTER OPTION OR USRNAM"
        J       CBITCH
CBCH10  LA      R3,BMSG10
        J       CBITCH
CBCH11  LA      R3,BMSG11               :"CANNOT GIVE LICENSE A USER NOT 
        J       CBITCH
CBCH12  LA      R3,BMSG12
        J       CBITCH
CBCH13  LA      R3,BMSG13               :"CAN'T DELET YER OWN USRNAM"
        J       CBITCH
CBCH14  LA      R3,BMSG14               :"CAN'T DELET A USERNAME W/ CIRCUITS"
        J       CBITCH
CBCH15  LA      R3,BMSG15               :"CAN'T DELETE A USER THAT'S LOGD-IN
        J       CBITCH
CBCH16  LA      R3,BMSG16
        JFS     CBITCH
CBCH17  LA      R3,BMSG17
        JFS     CBITCH
CBCH18  LA      R3,BMSG18
        JFS     CBITCH
CBCH19  LA      R3,BMSG19
        
CBITCH	LR	R2,R10			:GET PORT NUMBER
	JAL	R5,OCS			:SEND BITCH MSG

	LIS	R0,3			:TAG YELLOW BALL TO OUTPUT
	LR	R1,R10			:SO TYPE AHEAD CAN BE DISCARDED
	LHI	R2,YBMSG		:TILL ORANGE BALL IS BOUNCED
	JAL	R4,SLOR
	JAL	R4,ELOR
	L	R2,SLOWC,,		:SET YELLOW BALL OUT TIMER
	AIS	R2,0A			:10 SECONDS
	ST	R2,CYBTIM,R13
	J	CEAT			:EAT TILL ORANGE OR TIMEOUT

: COMMAND TABLE MACRO

CMDTLN  EQ      0E                      :THE LENGTH OF TEXT IN A COMMAND
CMDLEN  EQ      CMDTLN+2                :THE LENGTH OF A COMMAND ENTRY
CMD.DEF	MACRO(MINL,TEXT,ADDR)[
	BC	MINL
	SC	'TEXT'
        ORG     Q+CMDTLN
	HC	ADDR-SEG1
Q	EQ	Q+CMDLEN
]

: COMMAND PROCESS FAN OUT TABLE

	BND	4
Q	EQ	.		:REQUIRED BY CMD.DEF MACRO!
CFAN	HS	0
	NOLIST
        CMD.DEF(2,ADD,CADD)
        CMD.DEF(2,ALL,CALL)
	CMD.DEF(1,BACKPRESSURE,CBKPR)
	CMD.DEF(2,CCT,CCCT)
	CMD.DEF(2,CHARACTER,CCHAR)
	CMD.DEF(2,CONNECT,CCNKT)
	CMD.DEF(1,DELETE,CDELET)
	CMD.DEF(2,ENABLE,CENAB)
	CMD.DEF(2,EXIT,CEXI)
	CMD.DEF(1,FLUSH,CFLSH)
	CMD.DEF(2,FREEZE,CFRZ)
	CMD.DEF(2,GREETING,CGREET)
        CMD.DEF(1,HELP,CHELP)
        CMD.DEF(3,HEAR,CHEAR)
        CMD.DEF(1,LIST,CLISPT)
        CMD.DEF(2,LABEL,CLAB)
	CMD.DEF(1,MAKE,CNORM)
	CMD.DEF(2,MESSAGE,CMSG)
        CMD.DEF(3,NOTIFY,CNOTY)
	CMD.DEF(1,POWER,CPOWR)
        CMD.DEF(2,QUIT,CQUI)
        CMD.DEF(1,SEND,CSEND)
        CMD.DEF(1,TALK,CTALK)
	CMD.DEF(2,TIME,CTIM)
	CMD.DEF(2,TPARAMETER,CTPAR)
        CMD.DEF(2,TRANSFER,CTRANS)
        CMD.DEF(1,USER,CUSER)
        CMD.DEF(1,VERSION,CVERS)
        CMD.DEF(1,WHO,CWHO)
	CMD.DEF(1,ZAP,CZAP)
	LIST
CEND	HS	0
CSIZE	EQ	CFAN-CEND

: TABLE OF COMMANDS NOT USABLE AS A PARAMETER TO THE "USER" COMMAND
        
        SEG     A.DATA
NUSABL  WC      CGREET
        WC      CTALK
        WC      CPOWR
        WC      CNORM
        WC      CNOTY
: NDNUSA = NUMBER OF NUSABL ITEMS--CHANGE IT AFTER CHANGING NUSABL
NDNUSA  EQ      5
        SEG     A.CODE

: TALK COMMAND - TALK TO ANOTHER USER

CTALK   JAL     R9,CGETOK               :GET A TOKEN
	LA	R7,USER0,,		:LOOK FOR USERNAME
CTALK2	JAL	R4,MTCH			:*IN USER BLOCKS
	J	CTALK1
	AI 	R7,ENDBLK
	CLI 	R7,LSTBLK
	JLBS	CTALK2
	J	CBTCH3
 
CTALK1  EQ      .
        LHL     R5,UFLAG,R7             :SEE IF THE USER WANTS TO LISTEN
        THI     R5,FHEAR
        JE      CBTCH9                  :"? USER HEARING OFF"
        LHL     R6,BOSSP,R7             :NAME IS VALID, AND DEST DOESN'T CARE
	JE	CBTCHA			:"? USER NOT LOGGED IN"
        STH     R7,TLKBLK,R13           :SAVE USR BLK ADDR OF PRT YER TALKN TO

        LR      R2,R10                  :GET BOSS PORT
        LA      R3,TLKPRM               :GET USER'S TALK PROMPT
        JAL     R5,OCS                  :DISPLAY TALK PROMPT
        LB      R9,NAME+1,R13           :GET NAME LENGTH
        LIS     R7,0
NXTUID  LB      R0,NAME+2,R7,R13        :GET USER ID BYTE
        STB     R0,TLKBUF+1,R7,R13      :SAVE IN TALK BUF
        AIS     R7,1
        CR      R7,R9
        JL      NXTUID                  
        LHI     R0,3A                   :PUT : AFTER USERNAME
        STB     R0,TLKBUF+1,R7,R13
        AIS     R7,1
        STB     R7,TLKBUF,R13           :SAVE NAME LENGTH
 
CTALK0  EQ      .
        JAL     R5,GDAT
        NOP
        JAL     R5,CECHOC               :ECHO
        TBT     R8,PASSIT               :PRINTABLE?
        JE      SKIPIT
        OHI     R8,80                   :RESET LEFT-MOST BIT
        STB     R8,TLKBUF+1,R7,R13      :PUT CHAR IN TALK BUF
        AIS     R7,1
SKIPIT  EQ      .
        CLHI    R7,48                   :CUT OFF LINE AT 72 CHARS
        JE      CRNTLK                  :IF SO, PUT IN CR,LF AND TALK
        CLHI    R8,8D                   :CR?
        JN      CTALK0
        LHI     R8,8A
        STB     R8,TLKBUF+1,R7,R13        :LF IN TALK BUF
        AIS     R7,1
        STB     R7,TLKBUF,R13           :SAVE LEN
        LHL     R8,TLKBLK,R13           :GET USR BLK ADDR OF PORT YER TALKN TO
        AI      R8,UBLSEG               :USER BLKS IN SEG 3
        LH      R5,UFLAG,R8             :DOES USER STILL WANT TO LISTEN?
        THI     R5,FHEAR
        JE      CBTCH9                  :JUMP IT NOT
        LH      R6,BOSSP,R8             :IS USR STILL THERE?
        JE      CBTCHA                  :JUMP IF NOT
        LA      R3,TLKBUF,R13           :GET ADDR OF TALK BUF
        LR      R2,R6                   :GET DESTINATION PORT
        JAL     R5,OCS                  :SEND STRING
        LR      R2,R10                  :GET BOSS PORT
        LA      R3,TLKPRM               :GET USER'S TALK MODE PROMPT
NXTLIN  JAL     R5,OCS                  :PRINT PROMPT
        LB      R7,NAME+1,R13           :GET NAME LENGTH
        AIS     R7,1                    :INIT R7 AS TALK BUF POINTER
        J       CTALK0
CRNTLK  EQ      .
        LHI     R8,8D
        STB     R8,TLKBUF+1,R7,R13
        AIS     R7,1
        LHI     R8,8A
        STB     R8,TLKBUF+1,R7,R13
        AIS     R7,1
        STB     R7,TLKBUF,R13
        LHL     R8,TLKBLK,R13           :GET USR BLK ADDR OF PORT YER TALKN TO
        AI      R8,UBLSEG               :USER BLKS INSG 3
        LH      R5,UFLAG,R8             :DOES USER STILL WANT TO LISTEN?
        THI     R5,FHEAR                :CHECK HEAR VALUE
        JE      CBTCH9                  :JUMP IT NOT
        LH      R6,BOSSP,R8             :IS USR STILL THERE?
        JE      CBTCHA                  :JUMP IF NOT
        LA      R3,TLKBUF,R13
        LR      R2,R6
        JAL     R5,OCS
        LR      R2,R10
        LA      R3,TLKPR2
        J       NXTLIN


: TPAR COMMAND - SET TERMINAL PARAMETER OF BOSS
:	SYNTAX:  TPAR 06 08<CR>  (SET'S OUTPUT BAUD RATE TO 300BAUD, 10CPS)

CTPAR	LIS	R7,0A
	JAL	R9,CGETOK
	JAL	R9,CNUM			:PUT # IN REG 6
	STH	R6,SETN,R13		:SAVE "N" FOR SET COMMAND
	JAL	R9,CGETOK
	JAL	R9,CNUM			:PUT 2ND # IN R6
        CLHI    R6,TPRVAL               :2ND PARAM TO TP CMD MUST BE < 16
        JG      CBTCHC                  :"NUMBER OUT OF RANGE" IF > 15
	LHL	R9,SETN,R13		:GET PARAMETER TO BE SET
	ST	R5,TEMP
	CLHI	R9,NTRMCH		:MAKE SURE PARAM NUM OKAY
	JGE	CBTCHC			:"? NUMBER OUT OF RANGE"
	RBT	R9,ITCFLG,R13		:INDIC INITIAL VALUE SET
	STB	R6,ITCVAL,R13,R9	:SET INITIAL VALUE
	LR	R5,R6			:GET PARAMETER VALUE
	JAL	R8,SBPAR		:SEND TO BOSS
        LH      R1,FPORT,R13            :DO EACH PORT OWN'D BY THE BOSS
        JE      CTPAR0
        TBT     R9,INITIT
        JEFS    CTPAR0
CTPAR1  TBT     R1,PSNEDL
        JNFS    CTPAR2
        JAL     R8,STPAR
CTPAR2  LH      R1,CTBLE,R1,R1
        JNBS    CTPAR1
CTPAR0  L       R5,TEMP
	J	CPRMPT			:EXIT TO PROMPT

: MESSAGE COMMAND - REQUEST GREETING MESSAGE BE PRINTED

CMSG	HS	0
	LB	R0,GRETMG,,		:SEE IF ANY GREET MSG
	JE	CPRMPT			:BR IF NOT
	LR	R2,R10			:GET PORT #
	LA	R3,GRETMG,,		:GET ADDR OF MESSAGE
	JAL	R5,OCS			:PRINT IT TO BOSS
	J	CPRMPT

: HELP COMMAND - PRINT HELP MESSAGE

CHELP	LA	R6,MSGH			:ADDRESS OF HELP MSGS
CHEL2	LR	R3,R6
	LB	R0,0,R6			:SEE IF DONE
	JE	CHEL3
	AR	R6,R0			:BUMP TO NEXT MSG
	AIS	R6,1
	LR	R2,R10			:GET THE BOSS PORT
	JAL	R5,OCS			:SEND MSG
	JBS	CHEL2			:LOOK FOR MORE MSGS
CHEL3   LIS     R3,0
        CLB     R3,SUPLIC,R13           :THIS USER  HAVE SUPLIC POWER?
        JE      CPRMPT                  :NO
CHEL4   LA      R6,HLPSUP               :ADDR OF SUPER LIC HLP MSGS
CHEL5   LR      R3,R6
        LB      R0,0,R6         :END OF LIST?
        JE      CPRMPT
        AR      R6,R0                   :GET NXT MSG
        AIS     R6,1
        LR      R2,R10
        JAL     R5,OCS
        JBS     CHEL5

: VERSION COMMAND - PRINT VERSION/HOST MESSAGE

CVERS	LA	R3,MSGVER		:ADDR. OF VERSION MSG.
	LR	R2,R10			:GET THE BOSS PORT
	JAL	R5,OCS			:SEND DATA
	J	CPRMPT			:LOOK FOR MORE INPUT

: LIST COMMAND - PRINT LIST OF PORTS

CLISPT	JAL	R11,CLIST		:PROCESS PORT LIST
	J	CPRMPT

:	SUBR TO PRINT PORT LIST

CLIST	LHL	R6,FPORT,R13		:GET FIRST PORT IN CHAIN
	JN	CLS10			:BR UNLESS NO PORTS
	LA	R3,NPRTMS
        L       R6,SUPUSR,R13           :WAS CMND ISSUED VIA USER COMMAND?
        JN      CLIST0                  :YES
	JAL	R5,OMSG			:TELL USER NO PORTS
	JR	R11			:RETURN

CLIST0  LR      R2,R10                  :GET PORT OF ISSUER OF USER CMND
        JAL     R5,OCS                  :PRINT "No ports"
	JR	R11			:RETURN

CLIST1	LR	R2,R10			:GET PORT OF USER WHO ISSUED CMD
	LA	R3,PRTMS
	JAL	R5,OCS			:SEND IT
	JFS	CLS12

CLS10	L	R6,SUPUSR,R13		:ISSUED BY A SUP USER?
	JN	CLIST1			:YES
	LA	R3,PRTMS		:PRINT PORT LIST HEADER
	JAL	R5,OMSG

CLS12	LHL	R6,FPORT,R13		:GET FIRST PORT IN CHAIN

CLS15	LHI	R0,NLEN+6+5+(NLEN*2)    :PRTLBL+OPTS+ARROW+CNNCKTPRT+LOGINSTRNG
	LR	R1,R10
	JAL	R4,SLOR			:START PORT LIST LINE
        LHI     R0,20
	CLH	R6,SPORT,R13		:SEE IF CURRENT PORT
	JNFS	CLS20
	LHI	R0,2A			:YES, PRINT "*"
CLS20	JAL	R4,PUTCH
	LHI	R0,20
	JAL	R4,PUTCH

	JAL	R9,PUTNAM		:PUTCH THE CIRCUIT NAME
        LHI     R0,20                   :SEND BLANK
        JAL     R4,PUTCH
        LHI     R0,20
        JAL     R4,PUTCH
        LIS     R8,0                    :SET UP R8 FOR MR OP
        LR      R9,R6                   :PORT # IN R9
        LHI     R4,STRLEN               :LOGIN STRNG TBLE ENTRY LEN IN R4
        MR      R8,R4                   :MULT LEN BY PORT # TO GET ADDR OF
                                        :LOGIN STRNG TBLE ENTRY (IN R9)
        LB      R7,STRTBL+1,R9          :GET LENGTH OF STRING
        LR      R7,R7                   :LENGTH = 0?
        JE      CLS43                   :IF 0, DON'T PRINT STRING TBLE ENTRY
        LIS     R8,0                    :INIT PTR INTO STRING
CLS41   LB      R0,STRTBL+2,R8,R9       :GET BYTE
        CLHI    R0,8D                   :IGNORE CR AND SEMICOLON
        JE      CLS44
        CLHI    R0,0BB  
        JE      CLS44
        TBT     R1,LSTRHN               :IN HOST NUMBER FIELD OF STRING?
        JN      CLS45                   :IF YES, PRINT ONLY NUMBERS
        NHI     R0,7F
        TBT     R0,PABLE                :SEND ONLY PRINTABLE CHARS
        JNFS    CLS46
        OHI     R0,80
        JAL     R4,PUTCH                :PRINT CHAR
CLS46   OHI     R0,80
        CLHI    R0,0BA                  :COLON?
        JN      CLS44                   :JUMP IF NOT
        SBT     R1,LSTRHN               :ELSE YOU'RE IN HOST NUMBR FIELD SO
        J       CLS44                   :SET BIT AND JUMP
CLS45   CLHI    R0,0B0                  :< HEX 30?
        JL      CLS44                   :YES--NOT A NMBR SO DON'T PRINT
        CLHI    R0,0B9                  :> HEX 39?
        JG      CLS44                   :YES--NOT A NMBR SO DON'T PRINT
        JAL     R4,PUTCH                :PRINT NUMBER
CLS44   AIS     R8,1                    :INCREMNT PTR
        CR      R8,R7                   :END OF STRING?
        JL      CLS41
        RBT     R1,LSTRHN               :RESET BIT

CLS43   EQ      .
	LIS	R5,0
	LHI	R7,54
	TBT	R6,TYMSAT		:PRINT TYMSAT OPTION
	JAL	R9,PROPT
	LHI	R7,46
	TBT	R6,DUMP			:PRINT FLUSH OPTION
	JAL	R9,PROPT
	LHI	R7,42
	TBT	R6,STOPPD		:PRINT BACKPR OPTION
	JAL	R9,PROPT
	LR	R5,R5
	JEFS	CLS30
	LHI	R0,29			:FINISH OPT LIST WITH ")"
	JAL	R4,PUTCH

CLS30	LHL	R7,PTBLE,R6,R6		:SEE IF CONNECTED TO SOMETHING
	CR	R7,R10			:*OTHER THAN THE BOSS
        JE	CLS40			:BR IF NOT
        LR      R7,R7                   :PTBLE ENTRY = 0?
        JE      CLS40                   :BR IF SO
	LIS	R2,5
	LA	R3,ARROW		:OUTPUT " --> "
	JAL	R5,OBS
	STH	R6,TEMP
	LR	R6,R7
	JAL	R9,PUTNAM		:OUTPUT NAME CONNECTED TO
	LHL	R6,TEMP
 
CLS40   EQ      .                       :OUTPUT LOGIN STRING
     	LIS	R0,0D			:OUTPUT CRLF
	JAL	R4,PUTCH
	LIS	R0,0A
	JAL	R4,PUTCH
        JAL     R4,ELODR                :END LINE
	LHL	R6,CTBLE,R6,R6		:GET NEXT PORT
	JN	CLS15			:BR UNLESS NO MORE
	JR	R11

:	SUBR TO PRINT AN OPTION WITH LEADING "("

PROPT	JER	R9			:RTRN IF OPTION OFF
	LR	R5,R5			:NEED A "("?
	JNFS	PROPT2			:NOPE
        LHI     R0,20
        JAL     R4,PUTCH
	LHI	R0,28			:"("
	JAL	R4,PUTCH
	LIS	R5,1
PROPT2	LR	R0,R7
	JAL	R4,PUTCH		:PRINT OPTION LETTER
	JR	R9

: GIVE TO OR TAKE FROM A USER SUPER LICENSE POWER

CPOWR   EQ      .
        LB      R7,SUPLIC,R13           :DOES THIS USER HAVE POWER TO USER CMD?
        JG      CPOWR0                  :YES, JUMP
        J       CBTCHE                  :ELSE "YOU DON'T HAVE POWER TO USE CMD"
CPOWR0  JAL     R9,CGETOK               :GET 1ST PARAM ("ON" OR "OFF")
        LHL     R5,TOKLEN,R13           :GET TOKLEN
        JE      CBTCHF                  :"DID NOT ENTER OPTION OR USRNAM"
        JAL     R3,CHKOPT               :VALID OPTION ENTERED?
        J       CBTCH8                  :"BAD OPTION
        JAL     R9,CGETOK               :GET USERNAME
        LHL     R5,TOKLEN,R13           :GET TOKEN LENGTH
        JE      CBTCHD                  :"NO USERNAME SPECIFIED"
        LA      R7,USER0,,              :GET ADDR OF USRBLK
CPOWR2  JAL     R3,MTCHUN               :MATCH INPUT WITH THIS USERNAME
        J       CPOWR1                  :IT'S A HIT--JUMP AND SET LICENSE
        AHI     R7,ENDBLK               :GET NXT USERBLK
        CLI     R7,LSTBLK               :END OF BLOCKS?
        JE      CBTCH3                  :YES, NO HIT, PRINT "BAD USERNAME"
        J       CPOWR2                  :CHECK NEXT USERBLK
CPOWR1  CR      R7,R13                  :CHECK IF THE IS USER'S OWN BLOCK
        JE      CBCH10                 :CAN'T TURN OFF YOUR OWN LICENSE
        LB      R4,ASMBLD,R7            :IS THIS A WILD CARD USER?
        JE      CBCH11                 :YES--CANNOT GIVE LIC. TO WLDCRD
        STB     R2,SUPLIC,R7            :R2 = 1 OR 0
        J       CPRMPT                  :GET OUT

PWRWHO  LA      R7,USER0,,              :GET 1ST BLOCK ADDR
PWRWH1  LB      R6,SUPLIC,R7            :THIS BLK HAVE LICENSE?
        JE      PWRWH2                   :NO, CHECK NEXT
        LA      R3,NAME+1,R7            :GET ADDR OF NAME STRING
        LR      R2,R10                  :SET UP OCS CALL
        JAL     R5,OCS                  :PRINT NAME
        LR      R2,R10
        LA      R3,CRLFMG               :CR AND LF
        JAL     R5,OCS                  :SEND IT
PWRWH2  AHI     R7,ENDBLK               :GET NXT BLK
        CLI     R7,LSTBLK               :NO MORE BLKS?
        JE      CPRMPT                  :IT'S 0, NO MORE BLOCKS
        J       PWRWH1                  :CHECK LIC OF THIS BLK

: QUIT COMMAND - ZAP ALL PORTS AND EXIT

CQUI	LIS	R1,0			:NO MORE CURR SEND PORT
        STH     R1,SPORT,R13            
CQUI0	LHL	R1,FPORT,R13		:GET NEXT PORT FOR THIS BOSS
	JEFS	CQUI1			:BR IF NONE
	JAL	R6,ZAP			:ZAP A PORT (NO PRINTING)
	JBS	CQUI0			:GO GET MORE

CQUI1	LHL	R1,BOSSP,R13		:ALSO ZAP BOSS PORT
        JE      CEAT
	JAL	R6,ZAP
	J	CEAT

: CONNECT COMMAND - CONNECT OUTPUT OF 1ST PORT TO INPUT OF 2ND

CCNKT	HS	0
	JAL	R9,CGETOK
        LH      R6,TOKLEN,R13           :TOKLEN = 0?
        LR      R6,R6                   :SET CC
        JE      CBTCHB                  :IF 0, "NO PORT SPECIFIED"
        JAL     R1,CPORT
        J       CBTCH1
	ST	R3,CNKTMP		:SAVE PORT #
	JAL	R9,CGETOK
	LH	R14,TOKLEN,R13
	JNFS	CCNKT0
        LR      R3,R10
	JFS	CCNKT1
CCNKT0  JAL     R1,CPORT
        J       CBTCH1
CCNKT1	L	R2,CNKTMP		:RESTORE PORT #
	STH	R3,PTBLE,R2,R2		:SET DESTINATION
	J	CPRMPT	      		:LOOK FOR MORE INPUT

: EXIT COMMAND - EXIT BUT LEAVE PORTS INTACT (AND MAYBE TRANSFER BOSS)

CEXI	LH	R0,TOKDLM,R13		:SEE IF NEW BOSS SPECIFIED
	TBT	R0,EOCARY
	JE	CEXI10			:BR IF SO
	LHL	R1,BOSSP,R13		:GET BOSS PORT
        JE      CEAT
	JAL	R6,ZAP			:JUST ZAP HIM
	J	CEAT

CEXI10	JAL	R9,CGETOK		:GET PORT
	JAL	R1,CPORT
	J	CBTCH1			:BAD PORT
	TBT	R3,TYMSAT		:MUST BE TYMSAT PORT
	JE	CBTCH7
	STH	R3,TEMP1		:SAVE NEW BOSS PORT
	LHL	R1,BOSSP,R13		:ZAP THE CURRENT BOSS
	JAL	R6,ZAP
	LHL	R3,TEMP1		:RESTORE NEW BOSS PORT
	J	XFERX			:GO TRANSFER TO SPECIFIED PORT

: ENABLE COMMAND - ENABLE OUTPUT FROM PORT

CENAB	LA	R11,CEN00		:POINT TO ENABLE ROUTINE
	J	CPRTL			:GO PROCESS PORT LIST

CEN00	RBT	R3,DUMP			:NO FLUSHING
	JFS	CFL10

: FLUSH COMMAND - FLUSH OUTPUT FROM PORT

CFLSH	LA	R11,CFL00		:POINT TO FLUSH ROUTINE
	J	CPRTL			:GO PROCESS PORT LIST

CFL00   TBT     R3,PSNEDL
        JN      CPLRET
     	SBT	R3,DUMP			:FLUSH DATA
CFL10	RBT	R3,STOPPD		:NO BACKPRESSURING
	JE	CPLRET			:DONE IF NOT BACKPRESSURING BEFORE
	LR	R2,R3
	LA	R3,IBPOFF
	JAL	R5,OCM			:SEND BKPR OFF MSG
	J	CPLRET

: BACKPRESSURE COMMAND - BACKPRESSURE OUTPUT FROM PORT

CBKPR	LA	R11,CBK00		:POINT TO BKPR ROUTINE
	J	CPRTL			:GO PROCESS PORT LIST

CBK00   TBT     R3,PSNEDL
        JN      CPLRET
     	RBT	R3,DUMP			:NO FLUSHING
	SBT	R3,STOPPD		:BACKPRESSURE DATA
	LR	R2,R3
	LA	R3,IBPON
	JAL	R5,OCM			:SEND BKPR MSG
	J	CPLRET

: ZAP COMMAND - ZAP A PORT

CZAP	LA	R11,CZP00		:POINT TO ZAP ROUTINE
	J	CPRTL			:GO PROCESS PORT LIST

CZP00	LHL	R14,BTBLE,R3,R3		:GET THE USER FOR THE PORT
	JE	CPLRET			:NOTHING TO DO
        AI      R14,UBLSEG              :USER BLOCKS IN SEG 3
	CR	R14,R13			:DOES THIS USER OWN THE PORT
	JN	CPLRET			:NO
	LR	R1,R3			:GET PORT NUMBER
	JAL	R6,ZAP			:GO PROCESS THE ZAP
        L       R1,SUPUSR,R13           :THIS BLK CHANGED BY SUPLIC USER?
        JN      CPRMP3                  :YES
        LHL     R2,BOSSP,R13
        JE      INPUT                   :BOSS ZAPPED HIMSELF
	J	CPLRET

:	PARSE A PORT LIST, NO LIST DEFAULTS TO CURRENT PORT

CPRTL   LHL     R6,TOKDLM,R13           :SEE IF ANY PORT SPECIFIED
	TBT	R6,EOCARY
        JE      CPL0
	LHL	R3,SPORT,R13		:GET CURRENT PORT
	JE	CBTCHB			:BR IF NONE
	JR	R11			:GO DO SOMETHING TO PORT

CPLRET  LHL     R14,TOKDLM,R13           :HERE WHEN PORT PROCESSING DONE
	TBT	R14,EOCARY
	JN	CPRMPT			:LOOK FOR MORE INPUT
CPL0	JAL	R9,CGETOK    
	JAL     R1,CPORT                :GET THE FIRST PORT
        J       CBTCH1
	JR	R11			:GO DO SOMETHING TO PORT

: TIME COMMAND - PRINT DATE AND TIME

CTIM	LIS	R4,0D			:DONT DO SECONDS
	STB	R4,SBUFER+1		:NUMBER OF BYTES(OCS)
	L	R3,0F000C,,		:GET GMT
	LA	R5,SBUFER+2		:WHERE TO PLACCE
	JAL	R6,DATIME		:GO DO IT
	LR	R2,R10			:GET BOSS PORT
	LA	R3,SBUFER+1		:AND STRING
	JAL	R5,OCS			:OUT IT
	J	CPRMPT			:QUIT

: TRANSFER COMMAND - SWITCH TO A NEW BOSS

CTRANS	HS	0
	JAL	R9,CGETOK
        LH      R6,TOKLEN,R13           :TOKLEN = 0?
        LR      R6,R6                   :SET CC
        JE      CBTCHB                  :IF 0, "NO PORT SPECIFIED"
        JAL     R1,CPORT                :GET THE SPECIFIED PORT
        J       CBTCH1
	TBT	R3,TYMSAT		:MUST BE A TYMSAT
	JE	CBTCH7

XFERX	LI	R1,FPORT-CTBLE,R13	:SEARCH THRU CHAIN FOR PORT
	SRLS	R1,1			:*SPECIFIED AS NEW BOSS
CTRAN1	CLH	R3,CTBLE,R1,R1
	JEFS	CTRAN2			:BR IF FOUND
	LHL	R1,CTBLE,R1,R1
	JNBS	CTRAN1
	JFS	CTRAN3
CTRAN2	LHL	R0,CTBLE,R3,R3		:REMOVE FROM CHAIN
	STH	R0,CTBLE,R1,R1
	LIS	R0,0
	STH	R0,CTBLE,R3,R3

CTRAN3	LR	R10,R3			:NEW BOSS IN R10
	LR	R6,R13			:SET UP ROUTINE NEEDS UB HERE
	RBT	R10,DUMP
	RBT	R10,STOPPD
	LM	R14,CSAVE		:GET RING REGISTERS
	SIS	R12,1			:PREPARE TO FLUSH HIS COMMAND INPUT
	LR	R0,R12
	JAL	R4,FLUSH
	LHL	R1,BOSSP,R13		:OLD BOSS TO R1
        JE      CTRAN4
        CLH     R10,SPORT,R6            :IF SPORT = BOSSP THEN 0 IT OUT
        JN      CTRAN6
        LIS     R0,0
        STH     R0,SPORT,R6
        J       INEDXX
CTRAN6  CLH     R1,SPORT,R6             :SPORT = OLD BOSS?
        JN      INEDXX
        LIS     R0,0
        STH     R0,SPORT,R6
        J       INEDXX
CTRAN4  CLH     R10,SPORT,R6            :IF SPORT = BOSSP AS A RESULT OF
        JN      CTRAN5                  :EXI <LABEL> COMMAND, THEN
        LIS     R0,0                    :0 OUT SPORT
        STH     R0,SPORT,R6
        J       INEDYY
CTRAN5  CLH     R1,SPORT,R6             :OLD BOSS = SPORT?
        JN      INEDYY
        LIS     R0,0
        STH     R0,SPORT,R6
        J       INEDYY

: USER COMMAND--CAN ONLY BE USED BY THOSE WITH SUPER LICENSE--
: ALLOWS USE OF COMMANDS ON ANOTHER USER BLOCK 

CUSER   HS      0
        LB      R4,SUPLIC,R13           :CAN THIS USER USE THIS COMMAND
        JG      CUSER0                  :YES IF SUPLIC > 0
        J       CBTCHE                  :"YOU DON'T HAVE LICENSE TO USE CMD"
CUSER0  JAL     R9,CGETOK               :GET CMD PARAMTER (USERNAME)
        LHL     R5,TOKLEN,R13           :USERNAME ENTERED?
        JE      CBTCHD                  :"NO USERNAME SPECIFIED"
        LA      R7,USER0,,              :GET START OF BLOCKS
CUSER2  JAL     R3,MTCHUN               :MATCH INPUT?
        J       CUSER1                  :YES
        AHI     R7,ENDBLK               :GET NXT BLK
        CLI     R7,LSTBLK               :END OF BLOCKS?
        JE      CBTCH3                  :"BAD USERNAME"
        J       CUSER2                  :CHECK NXT BLK
CUSER1  ST      R7,USRADR               :SAVE USRBLK ADDR TO ACT ON
        JAL     R9,CGETOK               :GET 2ND PARAM--THE COMMAND
        LHL     R5,TOKLEN,R13           :WAS IT EVEN ENTERED?
        JE      CBCH12                 :"? COMMAND NOT ENTERED"
        LA      R7,CFAN                 :COMMAND FAN-OUT TABLE ADDR
CUSRCH  JAL     R4,MTCH                 :CHECK IT
        J       CUSRC3                  :IT'S A MATCH
        AHI     R7,CMDLEN               :GET NEXT CMND IN TBLE
        CLI     R7,CEND                 :END OF LIST?
        JLBS    CUSRCH                  :NO, CHECK NEXT
        J       CBTCH2                  :"BAD COMMAND"
CUSRC3  LHL     R5,CMDTLN,R7            
        LI      R2,SEG1
        AR      R2,R5
        LIS     R4,0                    :WITH USER COMMAND
CUSRC4  CL      R2,NUSABL,R4,           :CHECK WITH NOT USABLE TABLE ENTRY
        JE      CBCH16                  :"Cannot issue this cmnd with USER CMD"
        AIS     R4,4                    :POINT TO NEXT IN TABLE
        CLHI    R4,NDNUSA*4             :END OF TABLE?
        JN      CUSRC4                  :NO, CHECK NEXT
        LR      R4,R13                  :SAVE ORIGINAL R13 VALUE
        L       R13,USRADR              :GET ADDR OF USRBLK TO MANIPULATE
        ST      R4,SUPUSR,R13           :SAVE CALLER ADDR IN "TARGET" BLOCK
        LHL     R3,STRPOS,R4
        STH     R3,STRPOS,R13           :GIVE INPUT STRING PARAMTERS TO
        LHL     R3,TOKSTR,R4            :THE USER BLOCK YOU'RE TARGETING
        STH     R3,TOKSTR,R13           :ETC...
        LHL     R3,TOKLEN,R4
        STH     R3,TOKLEN,R13
        LHL     R3,TOKDLM,R4
        STH     R3,TOKDLM,R13
        CLI     R2,CSEND                :SEND CMD?
        JN      SEG1,R5                 :NO,GO AHEAD, EXCUTE CMD ON TARGET BLK
        ST      R13,USRADR              :SAVE TARGET BLOCK ADDR
        LR      R13,R4                  :GET ORIG R13 VAL
        JAL     R9,CGETOK               :GET POORT LABEL TO SEND TO
        ST      R13,ORGR13               :SAVE ORIG. R13
        L       R13,USRADR              :GET TARGET BLOCK ADDR
        LHL     R3,FPORT,R13            :IS THERE ANYTHING TO SEND TO?
        JE      CUSRC8          
        LHL     R2,TOKSTR,R4
        STH     R2,TOKSTR,R13
        LHL     R2,TOKLEN,R4
        JE      CUSRC8          
        STH     R2,TOKLEN,R13
        JAL     R1,CPORT1               :GET PORT NUMBER
        J       CUSRC7                  :"BAD PORT LABEL
        STH     R3,TRGTPT               :SAVE TARGET PORT
        J       CUSRC6
CUSRC7  L       R13,ORGR13              :GET ORIG. R13
        J       CBTCH1
CUSRC8  L       R13,ORGR13              :GET ORIG.R13
        J       CBTCHB                  :"NO PORT SPECIFIED
CUSRC6  ST      R13,USRADR              : SAVE TARGET BLK ADDR
        L       R13,ORGR13              :GET ORIGINAL R13
        JAL     R9,CGETOK               :GET ITEM TO SEND
        LHL     R5,TOKLEN,R13           :WAS ONE ENTERED?
        JE      CBCH17                  :"DID NOT ENTER ITEM TO SEND"
        LHL     R3,TOKSTR,R13           :GET START OF TOKEN
        AI      R3,UBLSEG               :MAKE IT A FULL WORD ADDR
        LIS     R4,0                    :INIT COUNTER
CUSRC5  LB      R2,0,R3,R4              :GET BYTE
        STB     R2,SBUFER+1,R4          :SAVE IN SEND BUFER
        AIS     R4,1                    :INCREMENT
        CR      R4,R5                   :END OF TOKEN?
        JN      CUSRC5                  :NO, GET NXT BYT
        LHI     R2,8D                   :CR
        STB     R2,SBUFER+1,R4          :CR IN SBUFER
        AIS     R5,1            
        STB     R5,SBUFER               :SAVE LENGTH
        L       R13,USRADR              :ADDR OF TARGET BLK IN R13
        LHL     R6,TRGTPT               :GET TARGET PORT
        J       CSN120

: ADD COMMAND -- ADD A USER THAT RESEMBLES AN ASSEMBLED-IN USER.
: UNLIKE A WILD-CARD USER, AN ADDED-ON USER CAN BE GIVEN SUPER LICENSE,
: IS GUARENTEED A LOG-IN, AND IS ASSURED THAT HIS USER-DEFINED 
: PARAMTERS WILL NOT BE RE-SET TO "SYSTEM" PARAMETERS

CADD    HS      0
        LB      R7,SUPLIC,R13           :DOES USER HAVE LICENSE TO USE CMD?
        JG      CADD0                   :IF SUPLIC > 0, YES
        J       CBTCHE                  :"DO NOT HAVE LICENSE TO USE CMD"
CADD0   JAL     R9,CGETOK               :GET USERNAME TO ADD
        LHL     R5,TOKLEN,R13           :WAS ONE ENTERED?
        JE      CBTCHD                  :"No username specified
        LA      R7,USER0,,              :FIRST CHECK IF USERNAME EXISTS
CADD1   JAL     R3,MTCHUN               :COMPARE
        J       CBCH18                 :"? This username already exists"
        AHI     R7,ENDBLK               :GET NXT BLK
        CLI     R7,LSTBLK               :NO MORE?
        JN      CADD1                   :CHECK IT
        LIS     R6,0                    :R6 WILL HOLD ADDR OF
                                        :OLDEST WILD CARD BLOCK
        LIS     R5,0                    :R5 HOLDS LAST LOGIN TIME
                                        :OF "OLDEST" WILD CARD, IF ANY
        LA      R7,USER0,,
CADD2   LB      R4,NAME+1,R7            :GET LENGTH BYTE
        JE      CADD3                   :IF 0 USE THIS BLOCK
        LB      R4,ASMBLD,R7            :ASMBLD-IN BLOCK?
        JN      CADD2B                  :YES, IGNORE IT
        LHL     R4,BOSSP,R7             :LOGGED_IN?
        JN      CADD2B                  :YES, CAN'T USE IT
        LHL     R4,FPORT,R7             :ANY CIRCUITS?
        JN      CADD2B                  :YES, CAN'T USE IT
        L       R4,LSTLOG,R7            :GET TIME LAST LOGGED-IN
        LR      R6,R6                   :GOT AN "OLD" BLOCK YET?
        JE      ADDOLD                  :NO, SAVE IT (1ST ONE FOUND)
        CR      R4,R5                   :OLDER THAN CURRENT OLD BLK?
        JG      CADD2B                  :NO, CHECK NXT BLK
ADDOLD  LR      R5,R4                   :SAVE CURRENT LAST LOGIN IN R5
        LR      R6,R7                   :SAVE CURRENT OLD BLK IN R6
CADD2B  AI      R7,ENDBLK
        CLI     R7,LSTBLK               :ANY MORE?
        JL      CADD2
        LR      R6,R6                   :ANY WLD CRD TO TAKE OVER?
        JE      CBCH19                  :"No room for another user
        LR      R7,R6                   :PUT BLOCK IN R6
CADD3   LIS     R4,1
        STB     R4,ADDON,R7
        STB     R4,ASMBLD,R7
        LHL     R5,TOKSTR,R13
        AI      R5,UBLSEG
        LIS     R4,0
CADD4   LB      R6,0,R5,R4
        OHI     R6,80
        STB     R6,NAME+2,R7,R4
        AIS     R4,1
        CLH     R4,TOKLEN,R13
        JN      CADD4
        STB     R4,NAME+1,R7
        LA      R3,NAME+1,R7
        LR      R2,R10
        JAL     R5,OCS
        LA      R3,ADDUMG
        LR      R2,R10
        JAL     R5,OCS
        J       CPRMPT

: ALL COMMAND -- LIST ALL ASSEMBLED-IN USERS AND ALL WILD-CARD USERS

CALL    HS      0
        LB      R7,SUPLIC,R13           :DOES USER HAVE LICENSE TO USE CMD?
        JG      CALL0                   :YES, IF SUPLIC > 0
        J       CBTCHE                  :"DON'T HAVE POWER TO USER THIS CMD"
CALL0   LA      R7,USER0,,              :USER HAS POWER--SKIP HERE--GET 1ST BLK
CALL1   EQ      .
        LB      R4,NAME+1,R7            :CHECK IF THIS IS AN EMPTY BLOCK
        JE      CALLX                   :YES (NO NAME) SKIP IT
        LR      R2,R10                  :PORT # IN R2 FOR OCS CALL
        LA      R3,NAME+1,R7            :ADDR OF STRING IN R3 FOR OCS CALL
        JAL     R5,OCS                  :PRINT USERNAME
        LB      R4,ASMBLD,R7            :WILD-CARD USER?
        JN      CALL5                   :NO
        LR      R2,R10                  :YES--PRINT WILD CARD TAG
        LA      R3,WCBTAG               : " # " SHOWS IT'S A WILD CARD
        JAL     R5,OCS
CALL5   LHI     R8,0A0A0                :GET 2 BLANKS
        LHL     R4,BOSSP,R7             :IS USER LOGGD-ON?
        JEFS    CALL2                   :NO--SO DON'T PRINT  " ^ "
        LHI     R8,0A05E                :PRINT " ^ " TO SHOW LOGGED-IN
CALL2   CLH     R10,BOSSP,R7            :IS USRBLOK THE BOSS?
        JNFS    CALL3                   :NO, GO AHEAD AND PRINT " ! "
        LHI     R8,0A0AA                :PRINT A " * " INSTEAD
CALL3   STB     R8,SBUFER+2             :STORE RIGHTMOST BYTE
        EXBR    R8,R8                   :GET OTHER BYTE
        STB     R8,SBUFER+1             :STORE IT
        LIS     R6,3
        LHI     R8,0A0
        STB     R8,SBUFER+3
        STB     R6,SBUFER
        LR      R2,R10
        LA      R3,SBUFER
        JAL     R5,OCS                  :SEND OUT "!" OR "*"
: COUNT NUMBER OF CIRCUITS BUILT BY THIS USER (IF ANY)
        LHL     R4,FPORT,R7             :CHECK START OF CHAIN
        JE      CALL4                   :NO CIRCUITS, FORGET IT
        LIS     R1,1             :      THERE'S AT LEAST ONE CIRCUIT
CALL6   LHL     R4,CTBLE,R4,R4          :COUNT # OF CTBLE ENTRIES
        JE      CALL7                   :THAT'S ALL
        AIS     R1,1                    :INCREMENT
        J       CALL6
CALL7   CLHI    R1,$A 99                :MORE THAN 99? (FAT CHANCE)
        JG      CALL7A
        CLHI    R1,$A 9                 :MORE THAN 9?
        JG      CALL7B
        LIS     R15,1                   :LESS THAN 10 CIRCUITS (1 DIGIT)
        J       CALL7C
CALL7A  LIS     R15,3
        J       CALL7C
CALL7B  LIS     R15,2
CALL7C  STB     R15,SBUFER
        LA      R14,SBUFER+1
        LIS     R4,0A
        JAL     R5,CBA
        LR      R2,R10
        LA      R3,SBUFER
        JAL     R5,OCS
        LR      R2,R10
        LA      R3,R10
        LA      R3,NMCRCS
        JAL     R5,OCS
CALL4   LIS     R8,0D
        STB     R8,SBUFER+1
        LIS     R8,0A
        STB     R8,SBUFER+2
        LIS     R6,2                    :GET LENGTH
        STB     R6,SBUFER
        LR      R2,R10                  :GET PORT # FOR OCS
        LA      R3,SBUFER               :GET ADDR OF STRING FOR OCS
        JAL     R5,OCS                  :CR AND LF
CALLX   AI      R7,ENDBLK               :POINT TO NEXT USRBLK
        CLI     R7,LSTBLK               :END OF ASSEMBLED-IN USERS?
        JL      CALL1                   :NO, CHECK NEXT
        J       CPRMPT

: WHO COMMAND - LIST ACTIVE USERS

CWHO	HS	0
	LA	R7,USER0,,
CWHO1	LHL	R6,BOSSP,R7
	JE	CWHO5			:PORT NOT ACTIVE
	LR	R2,R10
	LA	R3,NAME+1,R7
	JAL	R5,OCS			:PRINT A USERNAME
        LB      R4,SUPLIC,R13           :IF USER DOESN'T HAVE SUP. LIC.
        JE      CWHO3                   :THEN SKIP PRINTING OF WCTAG
        LB      R4,ASMBLD,R7            :WILD-CARD USER?
        JN      CWHO3                   :NO
        LR      R2,R10                  :YES--PRINT WLDCRD USER TAG
        LA      R3,WCBTAG
        JAL     R5,OCS
CWHO3   LHI     R8,0A0A0
	LHL	R4,UFLAG,R7		:SEE IF HEARING
	THI	R4,FHEAR
	JEFS	CWHO2
	LHI	R8,0A0A1		:SEND " !" TO OUTPUT IF SO
CWHO2	CR	R6,R10			:IS IT REQUESTING BOSS?
	JNFS	CWHO4			:NO, SKIP (OUTPUT THE " !")
	LHI	R8,0A0AA		:GET A " *" INSTEAD
CWHO4	STB	R8,SBUFER+2
	EXBR	R8,R8			:GET OTHER BYTE
	STB	R8,SBUFER+1		:STORE IT IN BUFFER
	LIS	R8,0D
	STB	R8,SBUFER+3
	LIS	R8,0A
	STB	R8,SBUFER+4
	LIS	R6,4
	STB	R6,SBUFER
	LR	R2,R10
	LA	R3,SBUFER
	JAL	R5,OCS			:PRINT A LINE
CWHO5	AI 	R7,ENDBLK
	CLI 	R7,LSTBLK
	JL	CWHO1			:FIND THE NEXT USER
        J       CPRMPT

: CCT COMMAND - CHANGE/DISPLAY CCT (CIRCUIT CHARACTERISTIC TYPE)
:		AND TPC (THROUGHPUT CLASS)

CCCT	HS	0
	LH	R0,TOKDLM,R13		:SEE IF ANYTHING SPECIFIED
	TBT	R0,EOCARY
	JN	CCCT20			:BR IF NOT
	CLHI	R0,20			:SEE IF 1ST PARAM SPECIFIED
	JN	CCCT10			:BR IF NOT
	JAL	R9,CGETOK		:GET 1ST PARAM
	LIS	R7,0A
	JAL	R9,CNUM			:CONVERT DECIMAL NMBR
	SIS	R6,1			:SEE IF IN RANGE (1-63)
	CLHI	R6,3F
	JC	CBTCHC			:NOPE
	AIS	R6,1
	STB	R6,CCT,R10		:SAVE CCT

CCCT10	LH	R0,TOKDLM,R13		:SEE IF 2ND PARAM SPECIFIED
	TBT	R0,EOCARY
	JN	CCCT20			:BR IF NOT
	JAL	R9,CGETOK		:GET 2ND PARAM
	LIS	R7,0A
	JAL	R9,CNUM			:CONVERT DECIMAL NMBR
	CLHI	R6,4			:SEE IF IN RANGE (0-3)
	JC	CBTCHC			:NOPE
	STB	R6,TPC,R10		:SAVE TPC

CCCT20	LR	R2,R10
	LA	R3,CCTMSG		:PRINT "CCT: "
	JAL	R5,OCS
	LIS	R0,2
	STB	R0,SBUFER		:SET UP CONVERSION BFR
	LB	R1,CCT,R10
	LIS	R4,0A
	LA	R14,SBUFER+1
	LIS	R15,2
	JAL	R5,CBA			:CONVERT CCT TO DECIMAL
	LR	R2,R10
	LA	R3,SBUFER
	JAL	R5,OCS			:PRINT CCT
	LR	R2,R10
	LA	R3,TPCMSG		:PRINT "   TPC: "
	JAL	R5,OCS
	LB	R0,TPC,R10		:GET TPC
	OHI	R0,03B0			:CONVERT TO DECIMAL
	STH	R0,SBUFER
	LHI	R0,8D8A
	STH	R0,SBUFER+2
	LR	R2,R10
	LA	R3,SBUFER
	JAL	R5,OCS			:PRINT TPC
	J	CPRMPT

: CHAR COMMAND - CHANGE/DISPLAY ATTENTION CHARACTER

CCHAR	HS	0
        LH      R0,TOKDLM,R13           :GET THE DELIMITER
	TBT	R0,EOCARY
        JN      CCHAR2                  :SKIP IF IT WAS A CR
	LHI	R7,10			:HEX
	JAL	R9,CGETOK
	JAL	R9,CNUM			:CONVERT NEW ATTN CHAR
	NHI	R6,7F			:REMOVE HI BIT
	CLHI	R6,0D			:CR NOT ALLOWED
	JE	CBTCH5
	STB	R6,ATCHAR,R13		:STORE IT
CCHAR2	LR	R2,R10
	LA	R3,SCHMSG
	JAL	R5,OCS
        LIS     R0,4
        STB     R0,SBUFER+1
        LB      R1,ATCHAR,R13
        LHI     R4,10                   :USE HEX...
        LA      R14,SBUFER+2            :USE THE BUFFER
	LIS	R15,2
        JAL     R5,CBA                  :CONVERT TO ASCII
	LIS	R0,0D
	STB	R0,SBUFER+4		:THROW IN A CRLF
	LIS	R0,0A
	STB	R0,SBUFER+5
        LR      R2,R10
        LA      R3,SBUFER+1
        JAL     R5,OCS                  :PRINT THE HEX CHAR
	J	CPRMPT			:LOOK FOR MORE INPUT

: DELETE COMMAND --

CDELET  HS      0
        LB      R4,SUPLIC,R13           :DOES USER HAVE LICENSE TO USE CMND?
        JG      CDELE0                  :IF SUPLIC > 0, YES
        J       CBTCHE                  :"YOU DO NOT HAVE LICENSE TO USE CMD"
CDELE0  EQ      .
        JAL     R9,CGETOK               :GET CMND PARAM (NAME TO DELTE)
        LHL     R5,TOKLEN,R13           :NAME ENTERED?
        JE      CBTCHD                  :"NO USERNAME SPECIFIED"
        LA      R7,USER0,,              :GET START OF BLOCKS
CDELE2  JAL     R3,MTCHUN              :MATCH INPUT?
        J       CDELE1                  :YES
        AHI     R7,ENDBLK               :GET NXT BLK
        CLI     R7,LSTBLK               :END OF BLKS?
        JE      CBTCH3                  :"BAD USERNAME"
        J       CDELE2                  :CHECK NXT BLK
CDELE1  CR      R7,R13                  :CHECK IF USER'S OWN BLOCK
        JE      CBCH13                 :"CAN'T DELETE YOUR OWN USRNAM"
        LHL     R4,FPORT,R7            :ANY CIRCUITS W/ THIS USER?
        JN      CBCH14                 :"CANNOT DELET A USER W/ CIRCUITS"
        LHL     R4,BOSSP,R7             :CAN'T DELET A USER WHO'S LGD-IN
        JN      CBCH15
        LA      R3,NAME+1,R7            :GET ADDR OF USER NAME
        LR      R2,R10                  :PRINT IT
        JAL     R5,OCS          
        LA      R3,DELUMG               :DELTE USER MSG
        LR      R2,R10
        JAL     R5,OCS                  :PRINT IT
        LIS     R4,0                    :0 OUT LENGTH FIELD OF NAME
        STB     R4,NAME+1,R7
        ST      R4,LSTLOG,R7            :0 OUT LAST LOG-IN TIME
        STB     R4,ASMBLD,R7            :0 OUT ASSMBLD-IN FLAG
        STB     R4,ADDON,R7             :0 OUT ADDED-ON FLAG
        LHI     R4,XTATTN               :PUT "SYSTEM" DEFAULTS
        STB     R4,ATCHAR,R7            :IN THIS BLOCK
        LHI     R4,XTUFLG
        STH     R4,UFLAG,R7
        J       CPRMPT

: GREETING COMMAND - SET GREETING MESSAGE

CGREET	HS	0			:ENTER A GREETING INTO BUFFER
        LB      R7,SUPLIC,R13           :FIRST SEE IF USER HAS LICENSE
        JG      CGREOK                  :TO USE THIS CMND
        J       CBTCHE                  :"DON'T HAVE POWER TO USER COMND"
CGREOK  EQ      .
:
:PATCH BY ED MOORING, 20-MAR-86, TO PUT "USERNAME SAYS:" IN FRONT
:OF THE GREETING MESSAGE.
:
	LA	R7,GRETMG+1,,		:GET START ADDR TO STORE STRING IN
	LB	R9,NAME+1,R13		:GET LENGTH OF USERNAME
	LR	R8,R9
GRETP1  LB      R0,NAME+1,R8,R13        :PUT USERNAME OF USER USING GREET
	STB     R0,GRETMG+2,R8,,	:INTO GREET BUFFER
	SIS     R8,1                    :NEXT CHAR
	JGBS    GRETP1
	AR      R7,R9			:ADD NAME LENGTH TO INDEX REG
	AIS     R7,2			:ADD IN LENGTH OF CR/LF
	LIS     R8,7			:' SAYS:"8d"8a' LENGTH-1
GRETP2  LB	R0,GRETSA,R8,		:PUT ' SAYS"8d"8a' INTO BUFFER AFTER NAME
	STB     R0,0,R7,R8
	SIS     R8,1
	JGEBS   GRETP2
	AIS     R7,8			:ADD ' SAYS:"8d"8a' LENGTH TO INDEX
:END OF PATCH
CGREE0	LA	R6,GRETME,,		:CALC REMAINING BFR LENGTH
	SR	R6,R7
	JLE	CGREE1			:BR IF NO MORE
	LA	R8,GRTPRM		: '<GREET>' PROMPT
	JAL	R9,CSTRNG		:GET A LINE OF GREETING
	LR	R6,R6			:SEE IF END OF GREETING
	JE	CGREE1			:BR IF SO
	AR	R7,R6			:BUMP TO END OF LINE
	LIS	R0,0A			:ADD IN LF CHAR
	STB	R0,1,R7
	AIS	R7,2
	J	CGREE0			:GO GET NEXT LINE

:	GOT GREETING MSG - SET FLAGS ON ALL USER'S BLOCKS

CGREE1	HS	0
        JAL     R9,TRPGUS               :TRAP NON-AUTHRIZD USER OF GR CMD
	SI	R7,GRETMG+1		:CALC TOTAL CHAR COUNT
	STB	R7,GRETMG,,		:PUT IN BFR

	LA	R2,USER0+UFLAG,,        :GET STARTING ADDRESS
CGREE2	LHL	R7,0,R2			:GET USER'S FLAGS
	OHI	R7,FMSGPR		:'OR' MESSAGE FLAG INTO USER FLAG
	STH	R7,0,R2			:SAVE IT BACK
	AI 	R2,ENDBLK		:GET NEXT USER BLOCK
	CLI 	R2,LSTBLK		:TEST FOR LAST USER
	JLBS	CGREE2			:NOT YET
	J	CPRMPT			:CONTINUE ON


: NOTIFY COMMAND - GET AND SEND A NOTIFY MESSAGE IMMEDIATELY

CNOTY   LB      R7,SUPLIC,R13           :FIRST SEE IF USER HAS LICENSE
	JLE     CBTCHE                  :"DON'T HAVE POWER TO USER COMND"
	LA	R7,NOTYMG+1,,		:GET START ADDR TO STORE STRING IN
	LB      R9,NAME+1,R13           :GET LENGTH OF USERNAME
	LR      R8,R9
CNOTY0  LB      R0,NAME+1,R8,R13        :PUT USERNAME OF USER USING NOTY
	STB     R0,NOTYMG+2,R8,,        :INTO NOTY BUFFER
	SIS     R8,1                    :NEXT CHAR
	JGBS    CNOTY0
	AR      R7,R9                   :ADD NAME LENGTH TO INDEX REG
	AIS	R7,2			:ADD IN LENGTH OF CR/LF
        LIS     R8,7                    :' SAYS:"8d"8a' LENGTH-1
CNOTY1  LB      R0,GRETSA,R8,           :PUT ' SAYS"8d"8a' INTO BUFFER AFTER NAME
	STB     R0,0,R7,R8
	SIS     R8,1
	JGEBS   CNOTY1
	AIS     R7,8                    :ADD ' SAYS:"8d"8a' LENGTH TO INDEX
CNOTY2	LA	R6,NOTYME,,		:CALC REMAINING BFR LENGTH
	SR	R6,R7
	JLE	CNOTY4			:BR IF NO MORE>>>SEND IT>>>>
	LA	R8,NOTPRM               :'<NOTIFY>' PROMPT
	JAL	R9,CSTRNG		:GET A LINE OF NOTIFY
	LR	R6,R6			:SEE IF END OF NOTIFY
	JE	CNOTY4			:BR IF SO>>>>>SEND IT>>>>>
	AR	R7,R6			:BUMP TO END OF LINE
	LIS	R0,0A			:ADD IN LF CHAR
	STB	R0,1,R7
	AIS	R7,2
	J	CNOTY2			:GO GET NEXT LINE

:HAVE THE MESSAGE, NOW LOOK FOR BOSS PORTS WITH THEIR HEARING ON.

CNOTY4  SI      R7,NOTYMG+1		:CALC LENGTH
        STB     R7,NOTYMG,,		:STORE LENGTH TO MAKE SC FORMAT
        LA      R7,USER0,,		:USER BLOCK
CNOTY5  LHL     R2,BOSSP,R7		:GET THE B PORT
        JEFS    CNOTY6			:IF ZERO, NO PORT
        LHL     R5,UFLAG,R7		:GET USER FLAG
        THI     R5,FHEAR		:HEARING ON?
        JN      CNOTY8			:WANTS THE MESSAGE
CNOTY6  AHI     R7,ENDBLK		:NEXT USER
        CLI     R7,LSTBLK		:DONE YET?
        JLBS    CNOTY5			:NOT YET, JUMP>>
        J       CPRMPT,,		:ALL DONE


:SEND NOTIFY MESSAGE

CNOTY8  LA	R3,NOTYMG,,		:GET ADDRESS OF MESSAGE
	JAL	R5,OCS			:SEND IT TO PORT IN R2
	J	CNOTY6			:CHECK FOR MORE



: FREEZE COMMAND - FREEZE/THAW/DISPLAY BOSS PORT

CFRZ	LHI	R9,FFRZ			:FREEZE BIT
	LA	R3,SFRMSG
	JFS	CSWTCH

: HEAR COMMAND - HEAR/NOHEAR/DISPLAY INCOMING TALK

CHEAR	LHI	R9,FHEAR		:HEAR BIT
	LA	R3,SHRMSG
	JFS	CSWTCH

: LABEL COMMAND - LABEL/NOLABEL/DISPLAY INCOMING DATA

CLAB	LHI	R9,FLAB			:LABEL BIT
	LA	R3,SLBMSG

CSWTCH	LHL	R2,TOKDLM,R13		:SEE IF ARG SPECIFIED
	TBT	R2,EOCARY
	JN	CSW70			:BR IF NOT
	STH	R9,UTEMP,R13
	JAL	R9,CGETOK		:GET NEW STATE
	LA	R7,CONOFF		:LOOK FOR NEW SWITCH VALUE
CSW30	JAL	R4,MTCH
	J	CSW40			:BR IF FOUND
	AIS	R7,CNFSZ
	CLI	R7,CNFEN
	JLBS	CSW30
	LA	R3,BMSG8		:BAD SWITCH VALUE
	J	CBITCH

CSW40	LHL	R9,UTEMP,R13
	CLI	R7,CONOFN		:ON OR OFF?
	JGEFS	CSW50			:BR IF ON
	XHI	R9,-1
	NH	R9,UFLAG,R13		:SET OFF
	JFS	CSW60
CSW50	OH	R9,UFLAG,R13		:SET ON
CSW60	STH	R9,UFLAG,R13
	LHL	R9,UTEMP,R13

CSW70	LR	R2,R10
	JAL	R5,OCS			:TELL WHAT IS BEING DISPLAYED
	LA	R3,OFFMSG		:ASSUME OFF
	NH	R9,UFLAG,R13		:SEE IF SWITCH ON OR OFF
	JEFS	CSW10			:BR IF OFF
	LA	R3,ONMSG		:SET ON
CSW10	LR	R2,R10
	JAL	R5,OCS			:PRINT STATE OF SWITCH
	J	CPRMPT

: MAKE COMMAND - MAKE A NEW CIRCUIT
:	ONLY ONE LOGIN ALLOWED AT A TIME

CNORM	LHL	R1,LPORT,R13		:CHECK IF ONE IN PROGRESS
	JEFS	CNORM0			:NO, CONTINUE
	JAL	R6,ZAP			:ZAP OLD ONE
CNORM0	LHI	R0,FLOG			:SET LOGGING FLAG
	OH	R0,UFLAG,R13
	STH	R0,UFLAG,R13
	LHL	R0,TOKDLM,R13		:SEE IF A NAME SPECIFIED
	TBT	R0,EOCARY
	JNFS	CNORMC			:BR IF NOT
	JAL	R9,CGETOK		:GET CIRCUIT NAME
	JFS	CNORM2
CNORMC	LIS	R0,0			:INDICATE NO NAME
	STH	R0,TOKLEN,R13

CNORM2	LR	R2,R10			:GET THE PORT NUMBER
	LA	R3,ECHOF
	JAL	R5,OCM			:TURN ECHO OFF
	RBT	R10,ECHO
	LHL	R3,HOSTS,,
	STH	R3,PNHOST		:ORIG HOST
	STH	R13,PNLKEY		:STORE THE BASE TO FIND  IT ON RETURN
	LB	R3,CCT,R10		:GET CCT FROM BOSS
	OHI	R3,0C0
	STB	R3,PNTID		:STORE TID IN REQUEST
	LIS	R2,0			:MSG TO PORT 0
	LA	R3,PNREQ		:ADDR OF MSG
	JAL	R5,OCM			:OUTPUT PSEUDO NEEDLE REQUEST
	L	R0,SLOWC,,		:SET UP PSEUDO-NDL TIMEOUT
	AHI	R0,PSNTIM
	ST	R0,PSNTMR,R13
: ADD USRBLK ON PSEUDO-NEEDLE TIMER CHAIN
        L       R6,PNTPTR               :GET PTR TO 1ST IN CHAIN
        JE      AUPNT0                  :IF 0 USRBLK IS 1ST IN CHAIN
AUPNT1  L       R4,PNTNXT,R6            :GET NEXT ON CHAIN
        JE      AUPNT2                  :IF 0 , AT END OF CHAIN
        LR      R6,R4                   :ELSE R6 := CURRENT BLK IN CHAIN
        J       AUPNT1                  :CHECK NEXT IN CHAIN
AUPNT2  ST      R13,PNTNXT,R6           :ADD USRBLK TO END OF CHAIN
        ST      R6,PNTPRV,R13           :USRBLK'S PREV PTR = R6
        J       AUPNT3
AUPNT0  ST      R13,PNTPTR
AUPNT3  EQ      .
	LIS	R6,0			:INIT LOGBFR INDEX
	LH	R7,UFLAG,R13		:INIT ECHO STATE TO ON
	OHI	R7,FPASEC		: /
	STH	R7,UFLAG,R13		:/
	J	CNORM3

CNORM6	ST	R9,SVNRM1		:SAVE R9 (USE AS INDEX)
	LIS	R9,0
	LH	R7,UFLAG,R13		:IN ECHO STATE ?
	NHI	R7,FPASEC		:/
CNORM1	LB	R0,NAME+2,R9,R13	:GET USER'S NAME
	LR	R8,R0
	LR	R7,R7			:ECHO STATE?
	JEFS	CNORMX			:NO, SKIP ECHO
	JAL	R5,CCHO1		:ECHO THIS
CNORMX	STB	R8,UBUFER,R6,R13	:STORE IT FOR THE LOGGER
	AIS	R6,1
	CLHI	R6,LGINSZ		:LOGIN STR LEN EXCEEDED?
	JGE	CBTCH4			:YES, BITCH
	AIS	R9,1			:NEXT NAME LETTER
	CLB	R9,NAME+1,R13
	JL	CNORM1
	L	R9,SVNRM1		:RESTORE R9
CNORM5  LHI     R0,3A           	:GET A COLON
	LR	R8,R0
	LR	R7,R7			:ECHO STATE?
	JEFS	CNORMB			:BR IF NOT
	JAL	R5,CCHO1		:ECHO IT TO TERMINAL
CNORMB  NHI     R8,7F
        TBT     R8,CRPOLA
        JEFS    CNORM7
        STB     R8,UBUFER,R6,R13	:SAVE IT AWAY
        AIS     R6,1            	:BUMP POINTER
CNORM3	STH	R6,LGINFL,R13		:STORE FILL INDEX FOR LOGGER

CNORM7	JAL	R5,GDAT			:GET NEXT CHARACTER
	J	CNORM4
	LIS	R7,0			:(IN CASE WE GO TO CSEND)
	LHL	R6,LPORT,R13		:CURRENT PORT NMBR
        LR      R6,R6                   :SET CC--IF 0 THEN
        JE      CNORM7                  :IGNORE IMMEDIATE COMMAND
	CLHI	R3,AT.DS		:DISPLAY NAME CMD?
	JNFS	CNORMD
	LR	R3,R6
	LA	R7,NOMSG
	JAL	R9,CRQPRI		:PRINT CIRCUIT NAME
	J  	CNORM7
CNORMD	CLHI	R3,AT.GO		:NEXT CIRCUIT CMD?
	JE	CSN050
	CLHI	R3,AT.EN		:ENABLE & NEXT CMD?
	JE	CSN065
	CLHI	R3,AT.FL		:FLUSH & NEXT CMD?
	JE	CSN070
	CLHI	R3,AT.BP		:BKPR & NEXT CMD?
	JE	CSN090
	LHL	R6,LGINFL,R13		:NEW FILL POINTER
	CLHI	R3,AT.NM		:IS IT THE USERNAME COMMAND?
	JE	CNORM6			:GO LOG HIS USERNAME
	CLB	R3,ATCHAR,R13		:EQUAL HIS ESCAPE CHAR ?
	JN	CNORM3			:NO, IGNORE
 
CNORM4	LHL	R6,LGINFL,R13		:GET NEW FILL POINTER
	LR	R8,R0			:R8 IS WORKING REGISTER
	NHI	R8,7F			:REMOVE HIGHER BIT
	STB	R8,UBUFER,R6,R13	:STORE CHARACTER IN BUFFER
	AIS	R6,1			:INC INDEX
	CLHI	R6,LGINSZ		:LOGIN STRING LENGTH EXCEEDED?
	JGE	CBTCH4			:YES
	LH	R7,UFLAG,R13		:IN ECHO STATE ?
	NHI	R7,FPASEC		:/
	JEFS	CNORM8			:NO, SKIP ECHO
	JAL	R5,CECHOC		:YES, ECHO IT
CNORM8	CLHI	R8,3B			:SEMI?
        JEFS    CNORM9                  :YES
	CLHI	R8,0D			:CARRET?
	JN	CNORM3			:NO
CNORM9	LH	R7,UFLAG,R13		:YES, GET FLAGS
	NHI	R7,@FPASEC		:REMOVE ECHO BIT FOR PASSWORD
	STH	R7,UFLAG,R13		:SAVE FLAGS BACK
	J	CNORM3			:DO ANOTHER

CNORMA	LHI	R0,FLOG			:ENTRY FROM CSEND
	OH 	R0,UFLAG,R13
	STH	R0,UFLAG,R13		:SET LOGIN FLAG
	LR	R2,R10
	LA	R3,ECHOF		:TURN ECHO OFF
	JAL	R5,OCM
	RBT	R10,ECHO
	J	CNORM7
	SUBTTL	SEND COMMAND
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
:			S E N D   C O M M A N D				:
:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

:	GET ARGUMENTS

CSEND	LHL	R0,TOKDLM,R13
	TBT	R0,EOCARY		:SEE IF A PORT SPECIFIED
        JN      CSN010			:BR IF NOT
	JAL	R9,CGETOK
        JAL     R1,CPORT                :GET THE PORT NUMBER
        J       CBTCH1
        LR      R6,R3
        JL      CBTCH1  		:BAD
        CHI     R6,NPORT		:TEST FOR LAST PORT
        JGE     CBTCH1  		:BAD, TOO BIG
        LHL     R14,BTBLE,R6,R6         :GET BTBLE FOR THIS PORT
        AI      R14,UBLSEG              :USER BLCKS IN SEG 3
        CR      R13,R14                 :DOES USER OWN THIS PORT?
	JN	CBTCH1
	STH	R6,SPORT,R13		:STORE IT
CSN010	LH	R3,SPORT,R13		:GET THE CURRENT SEND PORT
	JE	CBTCHB			:"? NO PORT SPECIFIED"
	STH	R3,XPORT,R13		:RECORD THIS PORT AS LAST PRINTED
	LA	R7,NOMSG
	JAL	R9,CRQPRI		:PRINT PORT NAME
	LH	R6,SPORT,R13
	LIS	R7,0
	J	CSN120

:	GET A CHAR & CHECK FOR IMMEDIATE COMMAND

CSN030	JAL	R5,GDAT			:GET THE NEXT CHARACTER
CSN040	J	CSN160
	LR	R3,R0			:GET CHARACTER BACK
	NHI	R3,7F			:STRIP PARITY
	CLB	R3,ATCHAR,R13		:CHECK IF ITS USERS SPECIAL
	JE	CSN160			:IF SO JUST SEND IT ALONG
	NHI	R3,5F			:SET CHARACTER TO UPPER CASE ONLY
	CLHI	R3,AT.LC		:TEST FOR GIVE CRQ A NAME
	JE	CSN230			:GO AHEAD IF SO
	CLHI	R3,AT.NM		:TEST FOR SEND USERNAME
	JE	CSN270			:YES
	CLHI	R3,AT.DS		:TEST FOR DISPLAY LABEL
	JNFS	CSN045
	JAL	R5,CSNDIT		:YES, SEND WHAT WE GOT
	LR	R3,R6
	LA	R7,NOMSG
	JAL	R9,CRQPRI		:PRINT LABEL
	LR	R6,R3
	LIS	R7,0
	J	CSN030
CSN045	CLHI	R3,AT.GO		:TEST FOR SWITCH CIRCUIT
	JNFS	CSN060
CSN050	TBT	R6,STOPPD		:SEE IF SUPPOSED TO BE BACKPRESSURED
	JN	CSN095			:YES, GO BACKPRESSURE
	J	CSN100			:NOPE
CSN060	CLHI	R3,AT.EN		:TEST FOR ENABLE & SWITCH
	JNFS	CSN067
CSN065	RBT	R6,DUMP			:YES, TURN OFF FLUSH & BKPR
	RBT	R6,STOPPD
	J	CSN100
CSN067	CLHI	R3,AT.FL		:TEST FOR FLUSH & SWITCH
	JNFS	CSN080
CSN070	SBT	R6,DUMP			:YES, SET FLUSH & RESET BKPR
	RBT	R6,STOPPD		
        J       CSN100
CSN080	CLHI	R3,AT.BP		:TEST FOR BKPR & SWITCH
	JN	CSN030
CSN090	RBT	R6,DUMP			:YES, RESET FLUSH & SET BKPR
	SBT	R6,STOPPD
CSN095  TBT     R6,PSNEDL
        JN      CSN100
      	LA	R3,IBPON		:SEND BKPR MSG
	LR	R2,R6
	JAL	R5,OCM

:	MOVE TO NEXT CIRCUIT

CSN100	LHL	R0,UFLAG,R13		:TURN OFF SEND FLAG
	NHI	R0,@FSEND&@FLOG
	STH	R0,UFLAG,R13
	JAL	R5,CSNDIT		:SEND WHAT WE GOT
	LHL	R3,CTBLE,R6,R6		:GET NEXT CIRCUIT
	JNFS	CSN110			:BR UNLESS END OF CHAIN
	LHL	R3,FPORT,R13		:WRAP TO START OF CHAIN
	JE	CPRMPT			:CMD MODE IF NO PORTS
CSN110	STH	R3,SPORT,R13		:SAVE NEW PORT
	STH	R3,XPORT,R13		:RECORD THIS PORT AS LAST PRINTED
	LA	R7,NOMSG
	JAL	R9,CRQPRI		:PRINT CIRCUIT NAME
	LIS	R7,0
CSN120  TBT     R6,PSNEDL
        JN      CSN130
      	TBT	R6,STOPPD		:SEE IF NEEDS TO BE UNBKPR
	JEFS	CSN130
	LA	R3,IBPOFF		:YES, SEND UNBACKPRESSURE MSG
	LR	R2,R6
	JAL	R5,OCM
CSN130	CLH	R6,LPORT,R13		:SEE IF IN LOGIN MODE
	JE	CNORMA			:GO TO LOGIN PROCESSOR IF SO

	LHI	R0,FSEND		:MUST SET HIS SEND FLAG
	OH	R0,UFLAG,R13		:SET IT
	STH	R0,UFLAG,R13		:RETURN IT
	LIS	R9,0
CSN140	LR	R1,R10			:GET BOSS'S CUR TERM PARAM
	JAL	R8,QTPAR
	LR	R2,R5
	LR	R1,R6			:GET NEW PORT'S TERM PARAM
	JAL	R8,QTPAR
	CR	R5,R2			:SEE IF THEY ARE THE SAME
	JEFS	CSN150			:BR IF SO
	JAL	R8,SBPAR		:SEND PORT'S TERM PARAM TO BOSS
CSN150	AIS	R9,1			:BUMP TO NEXT TERM PARAM
	CLHI	R9,NTRMCH
	JL	CSN140			:BR UNLESS DONE

:       SUPER LIC USER SENDING VIA ANOTHER USER BLOCK?

        LHL     R4,SUPUSR,R13           :IF NOT, SUPUSR = 0
        JE      CSN151                  :IT'S A NORMAL SEND--JUMP
        STB     R10,SUPTBL,R6           :SUP USR PRT IN TABLE
        LR      R2,R6                   :SEND STRING TO TARGET PORT
        LA      R3,SBUFER
        JAL     R5,OCS
        J       CPRMPT

CSN151  EQ      .
	LR	R7,R7			:HAVE WE LOADED ANY CHARACTERS
	JN	CSN220			:DONE WITH TRANSMISSION
	J	CSN030			:END THIS TRANSMISSION

:	HANDLE DEFERRED ECHO MODE

CSN160	STB	R0,CHRSAV		:SAVE CHAR SO THAT 'PARITY' IS RIGHT
	NHI	R0,7F
	LR	R8,R0
	TBT	R10,DEM			:HAS IT BEEN ECHOED ALREADY?
	JE	CECHOX			:SKIP IF SO
	TBT	R6,ECHO
	JE	QAED0
	LIS	R0,7			:WILL SEND ISIS AT LEAST 7 CHAR MESSAGE
	LR	R1,R10			:GET THE BOSSP
	JAL	R4,SLOR
	LR	R0,R8
	TBT	R0,PABLE
	JNFS	CECHO1			:SKIP IF NOT EASILY  PRINTABLE
	JAL	R4,PUTCH		:OUTPUT THE CHAR
	J	QAEND			:CLEAN UP

CECHO1	LHI	R3,-0D,R8		:UNECHOABLE CHAR
	JNFS	CECHO2			:NOT A CR
	JAL	R4,PUTCH		:OUTPUT THE CHAR
	TBT	R6,ECRLF
	JE	QAEND			:G CLEAN UP
	LIS	R0,0A
	JAL	R4,PUTCH		:OUTPUT A LINEFEED TO
	J	QAEND

CECHO2	AIS	R3,0D-0A		:IS IT A LINE FEED?
	JN	CECHO3			:NOT A LF
	JAL	R4,PUTCH		:OUTPUT THA CHAR
	TBT	R6,ELFCR
	JE	QAEND			:CLEAN UP IF NOT ECHO CR TOO
	LIS	R0,0D
	JAL	R4,PUTCH		:ECHO CR ALSO
	LHI	R0,7F			:RUBOUT
	JAL	R4,PUTCH
	J	QAEND

CECHO3	AIS	R3,0A-9
	JNFS	CECHO4			:NOT A TAB
	TBT	R6,ECTLI
	JE	QAED			:DON'T ECHO TABS
	JAL	R4,PUTCH		:ECHO IT
	JFS	QAEND			:CLEAN UP

CECHO4	SIS	R3,9-8
	JNFS	QAED			:UNPRINTABLE CHR, ENTER DEFERRED ECHO
	TBT	R6,ECTLH
	JEFS	QAED			:DON'T ECHO CONTROL-H
	JAL	R4,PUTCH		:ECHO IT

QAEND	LR	R3,R1			:SAVE PORT NUMBER
	JAL	R4,ELODR		:END WHATEVER WAS SENT
	LR	R1,R3			:RESTORE PORT NUMBER
	LR	R0,R8			:RESTORE FOR FURTHER PROCESS
	J	CECHOX

QAED	JAL	R5,CSNDIT		:SEND BUFFERED CHARS
	LIS	R0,3			:THREE CHARACTER MSG
	LR	R1,R6			:GET THE DESTINATION PORT
	LHI	R2,EDMMSG
	JAL	R4,SLOR
	JAL	R4,ELOR
	SBT	R6,DEM
	RBT	R6,ECHO

QAED0	RBT	R6,EXPECT		:WERE NOT ECHOING
	JEFS	CECHOX
	RBT	R6,TBOA
	RBT	R6,TBOB
	LIS	R0,3
	LR	R1,R6			:GET PORT # BACK
	LHI	R2,RBMSG
	JAL	R4,SLOR
	JAL	R4,ELOR

:	SAVE CHAR IN BUFFER & OUTPUT

CECHOX	CHI	R7,SBUFSZ-2		:BUFFER FULL ?
	JLEFS	CSN200			:NO, CONTINUE WITH BUFFER STUFFING
	JAL	R5,CSNDIT		:YES, SEND BUFFER
CSN200	AIS	R7,1			:INCREMENT POINTER
	LB	R8,CHRSAV		:RESTORE CHAR W/PARITY
	STB	R8,SBUFER,R7		:PUT THE CHARACTER IN  STRING FORMAT
CSN210	CHI	R12,1			:HAS THIS ISIS MESSAGE ENDED
	JN	CSN030			:GET MORE CHARACTERS
CSN220	JAL	R5,CSNDIT		:SEND BUFFER TO ISIS
	J	CSN030

:       FILL CIRCUIT NAME

CSN230	LIS	R9,0			:MAKE A POINTER
	SLLS	R6,NLENS		:MAKE A DOUBLE WORD INDEX
CSN240	JAL	R5,GDAT
	NOP
	JAL	R5,CECHOC
        TBT     R8,DLMARY               :IS THIS A DELIMITER
        JN      CSN260
        CLHI    R8,0D                   :AND RECALL THAT CR IS A DELIMITER, TOO
        JE      CSN260  
        OHI     R8,80                   :SET PARITY ON
	CLHI	R8,0E1			:SET TO UPPER CASE
	JLFS	CSN250
	CLHI	R8,0FA
	JGFS	CSN250
	SHI	R8,20
CSN250  STB     R8,NTBLE+2,R9,R6	:STORE IT
	AIS	R9,1
	CLHI	R9,NLEN-2		:IS THIS THE CHARACTER LIMIT?
	JN	CSN240			:NO DO ANOTHER
CSN260	STB	R9,NTBLE+1,R6		:SAVE SIZE 
	LIS	R9,1
	STB	R9,NTBLE,R6
	SRLS	R6,NLENS		:RESTORE R6
	J	CSN030			:AND FINISHED

:	SEND USERNAME ALONG CIRCUIT

CSN270	LIS	R9,0			:GET AN INDEX
CSN280	LB	R0,NAME+2,R9,R13	:GET ANOTHER LETTER OF NAME
	LR	R8,R0
	TBT	R6,ECHO			:IS HOST ECHOING?
	JEFS	CSN290			:YES, WE NEEDN'T
	JAL	R5,CCHO1		:ELSE DO IT
CSN290	CHI	R7,SBUFSZ-2		:BFR FULL?
	JLEFS	CSN300
	JAL	R5,CSNDIT		:YES, SEND IT
CSN300	AIS	R7,1
	STB	R8,SBUFER,R7		:STORE IT
	AIS	R9,1			:BUMP THIS
	CLB	R9,NAME+1,R13
	JL	CSN280

	LHI	R0,0BA			:GET A COLON
	LR	R8,R0
	TBT	R6,ECHO			:WILL HOST ECHO?
	JEFS	CSN310			:YES
	JAL	R5,CCHO1		:ELSE DO IT HERE
CSN310	CHI	R7,SBUFSZ-2		:BFR FULL?
	JLEFS	CSN320
	JAL	R5,CSNDIT		:YES, SEND IT
CSN320	AIS	R7,1			:SAVE POINTER
	STB	R8,SBUFER,R7		:SAVE CHAR
	J	CSN210			:EXIT

:	CSNDIT - SEND USER BUFFER TO ISIS & RESET COUNTER

CSNDIT	STB	R7,SBUFER		:STORE NUMBER OF CHARS (OCS FORMAT)
	LR	R7,R7			:SEE IF ANYTHING TO SEND
	JER	R5			:RETURN IF NOT
	LR	R2,R6			:GET CURRENT SEND PORT
        LHL     R14,BTBLE,R6,R6         :GET PORT'S USER BLOCK ADDR
        AI      R14,UBLSEG              :ADD USR BLK SEGMENT
        CR      R13,R14                 :DOES USER OWN THIS PORT?
	JN	CBTCH1			:NO
	LH	R7,PTBLE,R6,R6		:IS THE PORT ACTIVE
	JE	CBTCH1			:PROCESS
	LIS	R7,0			:RESET CNTR
	LA	R3,SBUFER
	J	OCS			:GO SEND THE CURRENT DATA

PABLE	WC	-1,0,0,3		:0 - 37,176 - 177 ARE UNPRINTABLE
	SUBTTL	UTILITY ROUTINES
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::		  U T I L I T Y   R O U T I N E S		::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

: CSTRNG - PROMPT USER AND GET A STRING
:	R6 - MAX LEN OF STRING ON INPUT
:	     LEN OF STRING ENTERED ON RETURN
:	R7 - ADDRESS OF STORAGE AREA FOR STRING
:	R8 - ADDR OF PROMPT STRING
:	R9 - LINK TO THIS ROUTINE
:	R10- BOSS PORT
:	R13- USER BASE REGISTER

CSTRNG	STH	R6,STRSIZ,R13		:SAVE MAX STRING SIZE
	ST	R8,UPRMT,R13		:SAVE PROMPT ADDR
CSTR01	L	R3,UPRMT,R13		:GET PROMPT ADDR
	LB	R0,0,R3
	JEFS	CSTR03			:BR IF NO PROMPT
	LR	R2,R10
	JAL	R5,OCS			:PRINT PROMPT
CSTR03	LIS	R6,0			:START WITH LENGTH OF 0
CSTR02	JAL	R5,GDAT			:GET A CHARACTER
	NOP				:SKIP <ESC> DETECTION FOR NOW
CSTART	NHI	R0,7F			:STRIP HIGH BIT
	LR	R0,R0			:IS IT A NULL?
	JEBS	CSTR02			:YES, IGNORE
	CLHI	R0,11			:IS IT A ^Q?
	JE	CSTR07			:YES, RESTART THIS INPUT
	CLHI	R0,01			:IS IT A ^A?
	JE	CSTR05			:YES, BACKSPACE IT
	CLHI	R0,08			:IS IT A ^H? (BACKSPACE)
	JE	CSTR05			:YES, BACKSPACE IT
	JAL	R5,CECHOC		:ECHO THE CHARACTER
        CLHI    R8,0D                   :IS IT A CR?
        JE      CSTR04                  :YES, PUT A CR/LF OUT

:	NOT A SPECIAL CHARACTER, STORE IT AWAY (EXIT IF LAST CHAR)
	STB	R8,0,R7,R6		:SAVE INTO USERS BUFFER
	AIS	R6,1			:BUMP INDEX
	CLH	R6,STRSIZ,R13		:CHECK FOR MAXIMUM
	JL	CSTR02			:GET NEXT CHARACTER
:	MAXIMUM CHAR COUNT EXCEEDED, TERMINATE STRING
	LA	R3,CRLFMG		:GET THE <CR>,<LF> MESSAGE
	LR	R2,R10			:GET BOSS PORT # FOR OUTPUT
	JAL	R5,OCS			:PRINT 'CR','LF'
	LIS	R8,0D			:FAKE A CR AT END
:	END OF STRING
CSTR04  STH	R6,STRSIZ,R13		:SAVE LENGTH
	STB	R8,0,R7,R6		:SAVE CR IN BFR (BUT UNCOUNTED)
	JR	R9			:EXIT

:	BACKSPACE
CSTR05	LR	R6,R6			:SEE IF ALREADY AT START
	JE	CSTR02			:IGNORE IF SO
	LA	R3,BKSPMG		:GET THE BACK SPACE MESSAGE
	LR	R2,R10			:GET BOSS PORT
	JAL	R5,OCS			:PRINT 'BS' MESSAGE
	SIS	R6,1			:BUMP BACK THE CHAR PTR
	J	CSTR02			:GET NEXT CHAR UNLESS AT START

:	DELETE LINE
CSTR07	LA	R3,UPCRMG		:GET "^",<CR>,<LF> MESSAGE
	LR	R2,R10			:GET BOSS
	JAL	R5,OCS			:PRINT IT
	J	CSTR01			:START WITH INDEX = 0

: CGETOK - GET THE NEXT TOKEN FROM THE COMMAND LINE
:	TOKEN PARAMETERS RETURNED IN TOKLEN, TOKSTR, TOKDLM

CGETOK	LHL	R6,STRPOS,R13		:GET POSITION IN CMD BFR
        AI      R6,UBLSEG               :USER BLKS IN SEG 3
CGETL0	LB	R8,0,R6			:SKIP LEADING BLANKS
	CLHI	R8,20
	JNFS	CGETL1
	AIS	R6,1
	JBS	CGETL0

CGETL1	STH	R6,TOKSTR,R13		:SAVE TOKEN START POSITION
CGETL2	LB	R8,0,R6
	TBT	R8,DLMARY		:SEE IF A TOKEN DELIMITER
	JN	CGETL3			:BR IF IT IS
        CHI     R8,061                  :CHECK FOR UPPER CASING
        JLFS    CGETL4
        CHI     R8,07A
        JGFS    CGETL4
        SHI     R8,20
	STB	R8,0,R6			:PUT BACK AS UPPER CASE
CGETL4	AIS	R6,1
	J	CGETL2

CGETL3	LR	R5,R6			:SAVE TOKEN END
CGETL5	CLHI	R8,20
	JNFS	CGETL6			:SKIP TRAILING BLANKS
	AIS	R6,1
	LB	R8,0,R6
	JBS	CGETL5

CGETL6	TBT	R8,DLMARY		:SEE IF CHAR AFTER SPACES IS DELIM
	JNFS	CGETL7			:BR IF SO
	SIS	R6,1
	LHI	R8,20			:USE SPACE AS TOKEN DELIMITER
CGETL7	STH	R8,TOKDLM,R13		:SAVE TOKEN DELIMITER
	TBT	R8,EOCARY		:SEE IF END OF CMD
	JNFS	CGETL8			:KEEP POINTING TO IT IF SO
	AIS	R6,1
CGETL8	STH	R6,STRPOS,R13		:SAVE NEW PARSE POSITION
	SH	R5,TOKSTR,R13
	STH	R5,TOKLEN,R13		:SAVE TOKEN LENGTH
	JR	R9

: CPORT - CONVERT CURRENT TOKEN TO PORT NUMBER

:	THIS ROUTINE SCANS THE INPUT STREAM UP TO A DELIMITER, AND, TREATING
:	THAT AS THE NAME OF A PORT, TRIES TO FIND THE PORT WITH THAT NAME
:	OWNED BY THE USER.  

:       R1 - LINK REGISTER
:       R3 - PORT NUMBER (RESULT RETURNED)
:       R4 - TRASHED
:       R7 - POINTS TO NAME TYPED
:       R13 - BASE OF USER BLOCK

CPORT	LHL	R3,TOKLEN,R13
        JE      CBTCHB                  :"NO PORT SPECIFIED
	LHL	R3,FPORT,R13		:START SEARCHING PORTS IN CHAIN
        JE      CBTCHB                  :"NO PORT SPECIFIED
CPORT1	LR	R7,R3
	SLLS	R7,NLENS
	AI	R7,NTBLE		:PNT TO NAME TABLE ENTRY
        JAL     R4,MTCH			:COMPARE
	J	4,R1			:RTRN IF FOUND, SKIP 4 RETURN
	LHL	R3,CTBLE,R3,R3		:CHAIN TO NEXT PORT FOR THIS BOSS
	JNBS	CPORT1			:GO TRY NEXT
	JR	R1			:NOT FOUND, NON-SKIP RTRN

: CNUM - CONVERT CURRENT TOKEN TO NUMBER

:	REGISTER USAGE:
:		R6 - ACCUMULATOR FOR #
:		R7 - RADIX
:		R9 - LINK FROM CALLING ROUTINE

CNUM	LIS	R6,0			:R6 IS THE ACCUMULATOR
	LHL	R4,TOKSTR,R13		:GET TOKEN POS & LEN
        AI      R4,UBLSEG               :USR BLKS IN SEG 3
	LHL	R5,TOKLEN,R13
	JE	CBTCH5			:NULL NMBR NOT ALLOWED
CNUM1	LB	R8,0,R4
	CLHI	R8,30			:TEST FOR DIGIT RANGE
	JL	CBTCH5			:JUMP NOT DIGIT
	CLHI	R8,3A			:TEST FOR "9" (+1)
	JLFS	CNUM2			:JUMP NOT DIGIT
	CLHI	R8,41			:TEST FOR "A"
	JL	CBTCH5
	SHI	R8,41-0A-30		:ADJUST FOR ALPHA
CNUM2	SHI	R8,30			:MAKE BCD VALUE
	CR	R8,R7			:TEST FOR GRTR THAN RADIX
	JGE	CBTCH5			:BR IF ERROR
	MHR	R6,R7			:PREVIOUS NUMBER * RADIX
	AR	R6,R8			:MAKE NEW NUMBER
	AIS	R4,1
	SIS	R5,1
	JG	CNUM1			:LOOP UNTIL WHOLE TOKEN DONE
	JR	R9

: MTCH - MATCH CURRENT TOKEN TO STRING
:	RUINS R5,R6,R8
:	LINK R4
:	MATCH TO STRING AT ADDRESS IN R7
:	   BYTE 0 - MIN CHARS FOR MATCH
:		1 - MAX CHARS FOR MATCH (STRING LENGTH)
:		2 - DATA...
:	NON-SKIP RTRN IF MATCH
:	SKIP RTRN IF NO MATCH

MTCH	LH	R6,TOKLEN,R13		:CUR TOKEN LENGTH
	CLB	R6,0,R7			:SEE IF MIN LEN
	JL	4,R4			:NO MATCH IF NOT
	CLB	R6,1,R7			:SEE IF MAX LEN
	JG	4,R4			:BR IF TOO LONG

	LHL	R5,TOKSTR,R13		:TOKEN START ADDR
        AI      R5,UBLSEG               :USER BLKS IN SEG 3
MTCH1	LB	R8,-1,R5,R6		:COMPARE TOKEN & STRING
	OHI	R8,80
	CLB	R8,1,R7,R6
	JN	4,R4			:NON-SKIP RTRN IF MISMATCH
	SIS	R6,1			:KEEP COMPARING
	JGBS	MTCH1
	JR	R4

: CBA - CONVERT BINARY TO ASCII.
:
:	ASCII NUMBER WILL BE OUTPUT IN REQUESTED RADIX WITH ZERO FILL
:	IN A GIVEN FIELD IN MEMORY.
:
:	ENTRY	R1	BINARY #
:		R4	RADIX (2 TO 10 HEX)
:		R5	LINK
:		R14	ADDRESS TO DEPOSIT STRING
:		R15	SIZE OF FIELD IN CHARACTERS
:
:	DESTROYS R2,3

CBA	LR	R3,R1			:GET NUMBER TO SCRATCH REGISTER
CBA010	LIS	R2,0			:CLEAR UPPER HALF
	DR	R2,R4			:DIVIDE BY RADIX
	LB	R2,CBAASC,R2		:CONVERT TO ASCII
	STB	R2,-1,R14,R15		:SAVE CHARACTER
	SIS	R15,1			:COUNT CHARACTER IN STRING
	JGBS	CBA010			:FILL UP THE FIELD
	JR	R5

: MTCHUN -- MATCH INPUT TOKEN WITH USERNAME FROM USER BLOCK
: LINK ON R3
: R5 = COUNTER
: R6 = ADDR OF TOKEN
: R7 = ADDR OF USERNAME IN BLOCK BEING CHECKED
: JUMP RETURN IF NOT FOUND

MTCHUN  EQ      .
        LB      R6,NAME+1,R7            :GET LENGTH--IF 0 (UNUSED BLOCK)
        JE      4,R3                    :NOT FOUND--SKIP RETURN
        CLH     R6,TOKLEN,R13           :CHECK FOR SAME LENGTH
        JN      4,R3                    :NOPE, JUMP RETURN
        LHL     R6,TOKSTR,R13           :GET ADDR OF 1ST BYT OF INPUT
        AI      R6,UBLSEG               :USRBLKS IN SEG 3
        LIS     R5,0                    :INIT COUNTER
MTCHU0  LB      R8,0,R6,R5              :GET INPUT BYTE
        NHI     R8,7F                   :GET RID OF PARITY BIT
        TBT     R8,DLMARY               :END OF INPUT STRING?
        JN      4,R3                    :YES, JUMP RETURN
        OHI     R8,80
        CLHI    R8,0E1                  :UPPER CASE?
        JL      MTCHU1                  :YES, JUMP
        SHI     R8,20                   :CONVER TO UPPER
MTCHU1  CLB     R8,NAME+2,R7,R5         :COMPARE W/ BYT FROM USERNAME IN BLK
        JN      4,R3                    :JUMP RETURN IF NOT =
        AIS     R5,1                    :INCREMENT
        CLB     R5,NAME+1,R7            :CHECKD ALL OF USRNAM IN BLOK?
        JER     R3                      :YES--IT'S A HIT
        J       MTCHU0

: CHKOPT -- CHECK IF TOKEN = VALID OPTION
: LINK ON R3
: R2 CONTAINS VALUE WITH WHICH TO SET SUPLIC
: USES R4,R5,R6,R8
: R13 = USER BLOCK
: JUMP RETURN IF FOUND

CHKOPT  EQ      .
        LIS     R4,0                    :INIT POINTER INTO TBL
        LHL     R6,TOKSTR,R13           :GET HLFWRD PART OF ADDR OF TOKEN
        AI      R6,UBLSEG               :AND ADD 30000 TO GET CORRECT ADDR
        JAL     R5,GETBYT               :GET TOKEN BYT
        CLHI    R8,4F                   :"O"?
        JN      CHKN                    :NO, CHECK FOR "N" OR "F"
        J       CHKOP1                  :YES, CHECK 2ND BYT
CHKN    CLHI    R8,4E                   :"N"?
        JE      TURNON                  :YES, TURN ON POWER
        CLHI    R8,46                   :"F"?
        JE      TRNOFF                  :YES, TURN OFF POWER
        CLHI    R8,57                   :"W"?--WHO OPTION--WHO HAS POWER
        JE      PWRWHO                  :YES, LIST THOSE W/ SUP LIC POWER
        JR      R3                      :ELSE IT'S BAD PARAM--JUMP AND BITCH
CHKOP1  AIS     R4,1                    :INCREMENT POINTR
        JAL     R5,GETBYT               :GET NXT BYT
        J       CHKN                    :CHECK IF "F" OR "N"
TURNON  LIS     R2,1
        J       4,R3
TRNOFF  LIS     R2,0
        J       4,R3                    :JUMP RETURN

GETBYT  EQ      .
        LB      R8,0,R6,R4
        NHI     R8,7F
        TBT     R8,DLMARY
        JNR     R3
        CLHI    R8,61
        JLR     R5
        SHI     R8,20
        JR      R5

CBAASC	AC	"0123456789ABCDEF"

: OMSG - GENERAL TRANMISSION ROUTINE
:       JUST LIKE OCS, BUT SENDS TO BOSS PORT
:
:	R5	RETURN REGISTER
:	R1	BINARY NUMBER
:	R13	CONTAINS THE BASE OF THE USER BLOCK WHICH RECEIVES THE MESSAGE
:

OMSG	LHL	R2,BOSSP,R13
	JER	R5
	J	OCS		:OCS WILL LINK ON R5

: CRQPRI - PRINT PORT LABEL & MSG PRECEDED BY ">"
:	R3 = CIRCUIT NUMBER TO PRINT NAME OF
:	R7 = MSG TO PRINT AFTER PORT LABEL
:	R9 = LINK REGISTER

CRQPRI	ST	R9,TEMP2
	LR      R6,R3
	LHI	R0,NLEN-2+4
	LR	R1,R10
        JER     R9                      :IF NO BOSS, DON'T PRINT
	JAL	R4,SLOR			:START RECORD
	LHI	R0,20			:BUILD " >"
	JAL	R4,PUTCH
	LHI	R0,3E
	JAL	R4,PUTCH
	JAL	R9,PUTNAM		:OUTPUT NAME
	LB	R2,0,R7
	LHI	R3,1,R7			:OUTPUT MSG
	JAL	R5,OBS
	JAL	R4,ELODR		:END RECORD
	LR	R3,R6
	L	R9,TEMP2
	JR	R9			:RETURN

: PUTNAM - PUT A PORT LABEL IN OUT RING
:	R6 = PORT NMBR
:	R9 = LINK REG

PUTNAM	SLLS	R6,NLENS		:PNT TO NAME TABLE ENTRY
	LIS	R8,0
PUTN2	LB	R0,NTBLE+2,R8,R6	:GET CHAR OF LABEL
        NHI     R0,7F
        TBT     R0,PABLE                :PRINTABLE?
        JNFS    PUTN3                   :NO
        OHI     R0,80
	JAL	R4,PUTCH
PUTN3   OHI     R0,80
	AIS	R8,1
	CLB	R8,NTBLE+1,R6		:SEE IF DONE
	JL  	PUTN2
	SRLS	R6,NLENS		:RESTORE REG
	JR	R9

: CMODE - GO TO COMMAND MODE
:	R13 = USER BLOCK ADDR
:       R10 = BOSS PORT 
:	R6 = LINK
:	R5 = RETURNED COMMAND LINK ADDR

CMODE	LHL	R1,BOSSP,R13		:GET BOSS PORT
	JE	CMOD3			:NO BOSS PORT
	LIS	R9,0
CMOD1	TBT	R9,ITCFLG,R13		:SEE IF WE HAVE INITIAL TC VAL
	JNFS	CMOD2			:NOPE
	JAL	R8,QTPAR		:GET BOSS'S CUR TERM PARAM
	CLB	R5,ITCVAL,R13,R9	:CMP TO INITIAL TERM PARAM
	JEFS	CMOD2			:BR IF THE SAME
	LB	R5,ITCVAL,R13,R9	:SET TO INITAL VAL
	JAL	R8,SBPAR
CMOD2	AIS	R9,1			:BUMP TO NEXT TERM PARAM
	CLHI	R9,NTRMCH		:SEE IF DONE
	JL	CMOD1			:LOOP IF NOT

	LA	R3,PROMPT		:SEND CMD PROMPT
	JAL	R5,OMSG
CMOD3	LHI	R0,@FSEND&@FLOG		:HAVE TO RESET SEND
	NH	R0,UFLAG,R13
	STH	R0,UFLAG,R13		:PUT IT BACK
	LA	R5,CGETW
	JR	R6

: CECHOC - ROUTINE TO ECHO CHAR
:	INPUT	- R0 = ASCII CHAR
:		  R1 = ISIS PORT NUMBER
:	OUTPUT  - R8 = 7 BIT ASCII CHAR
:	NOTES	- LF OUTPUT AFTER ALL CR'S
:		- REG 0,2-4 NOT SAVED
:		- LINK ON R5

CECHOC	NHI	R0,7F
	LR	R8,R0
	TBT	R10,DEM
	JER	R5
CCHO1	NHI	R0,7F
	TBT	R0,PASSIT		:PRINTABLE ?
	JER	R5			:NO, SKIP IT

CCHO2	LR	R8,R0
	LIS	R0,5			:AT LEAST 5 CHARS
	LR	R1,R10			:GET THE BOSS PORT
	JAL	R4,SLOR
	LR	R0,R8
	JAL	R4,PUTCH
	CLHI	R8,0D
	JNFS	CCHO3
	LIS	R0,0A
	JAL	R4,PUTCH
CCHO3	JAL	R4,ELODR
	JR	R5

PASSIT	WC	01E40000,-1,-1,-4	:CHARS TO PASS ON

: ZAP - PROCESS CIRCUIT ZAP
:	R1 = PORT#
:	R6 = LINK

:	ZAP IS CALLED TO PROCESS A PORT ZAP 
:	ON INPUT R1 CONTAINS THE PORT TO ZAP, LINK ON R6
:	THERE ARE THREE CASES OF ZAPPING
:	1- THE PORT IS A NORMAL SLAVE
:	2- THE PORT IS IN PSEUDONEDL STATE
:	3- THE PORT IS A BOSS
:	4- THE PORT IS THE CURRENT SEND PORT

ZAP	HS	0
	LHI	R2,ZAPMSG
	LIS	R0,3
	JAL	R4,SLOR
	JAL	R4,ELOR			:SEND A ZAPPER

:	CALL HERE TO DO ALL ZAPPING EXCEPT SENDING THE ZAPPER
ZAP1	ST	R1,ZAPSAV		:SAVE ZAP UPON THIS ENTRY
	LR	R3,R1
        CLH     R1,BOSSP,R13            :IS USER LOGGED ON?
        JEFS    ZAP1A                   :IF NOT THEN DON'T PRINT MSG
	LA	R7,ZAPPED		:NOTIFY THE BOSS
	LR	R11,R6
	JAL	R9,CRQPRI
	LR	R6,R11
	L	R1,ZAPSAV		:RECOVER PORT

:       IF PORT NOT A BOSS PORT, THEN DELETE PORT FROM PORT CHAIN
:       OF USER BLOCK TO WHICH THE PORT BELONGS
ZAP1A   TBT     R1,BOSPRT               :BOSS PORT?
        JN      ZAP9                    :YES, DON'T CHECK USER'S PRT CHAIN
ZAP1B   CLH     R1,FPORT,R13            :PORT = FIRST PORT IN CHAIN?
        JN      ZAP1C                   :IF NOT CHECK REST OF CHAIN
        LHL     R2,FPORT,R13            :IF R1 = FPORT THEN
        LHL     R3,CTBLE,R2,R2          :NEW FPORT := CTBLE ENTRY POINTED TO
        STH     R3,FPORT,R13            :BY CURRENT FPORT
        LIS     R0,0                    :0 OUT CTBLE ENTRY POINTED TO BY
        STH     R0,CTBLE,R2,R2          :OLD FPORT
        J       ZAP10                   :CHECK PTBLE
ZAP1C   LHL     R2,FPORT,R13            :GET CTBLE PORT POINTED TO BY FPORT
ZAP1D   LHL     R3,CTBLE,R2,R2          :GET NEXT PORT IN CHAIN
        CR      R1,R3                   :IS IT = TO ZAPPED PORT? IF YES,
        JE      ZAP1E                   :JUMP AND ADJUST CHAIN TBLE ELSE...
        LR      R2,R3                   :PTR TO NXT CTBL ITEM := CURRENT ITEM
        J       ZAP1D                   :JUMP AND GET NEXT PORT NMBR
ZAP1E   LHL     R4,CTBLE,R3,R3          :HLFWRD PNTD TO BY R2 BECOMES
        STH     R4,CTBLE,R2,R2          :HLFWRD PNTD TO BY  R3--HLFWRD
        LIS     R4,0                    :PNTD TO BY R3, IS ZEROD OUT
        STH     R4,CTBLE,R3,R3  

:       ZAPPED PORT IS BOSS--TEST ALL PTBLE HLFWRDS AND 0 OUT
:       ANY HLFWRD WITH ZAPPED PORT 
ZAP9    LHI     R3,NPORT                :INIT PTR
        LIS     R2,0                    
ZAP9A   SIS     R3,1                    :DECREMENT
        JE      ZAP12                   :IF 0 THAT'S ALL
        CLH     R1,PTBLE,R3,R3          :ZAPPD PORT = TO PTBLE HFLFWRD?
        JN      ZAP9A                   :IF NOT CHECK NEXT HLFWRD
        STH     R2,PTBLE,R3,R3          :ELSE 0 OUT PTLBE HLFWRD
        J       ZAP9A                   :AND CHECK NEXT PTBLE HLFWRD

:       CASE WHERE ZAPPED PORT NOT A BOSS, BUT WHERE IT MAY BE
:       A DESTINATION FOR ANOTHER PORT AS RESULT OF CCNKT CMD
ZAP10   EQ      .
        LHI     R3,NPORT                :INIT POINTER
ZAP11   SIS     R3,1                    :DECREMENT
        JE      ZAP12                   :IF 0, THAT'S ALL
        CLH     R1,PTBLE,R3,R3          :ZAPD PORT = TO PTBLE HLFWRD?
        JN      ZAP11                   :IF NOT CHECK NXT HLFWRD
        STH     R10,PTBLE,R3,R3         :ELSE SET DESTINATION TO BOSSP
        J       ZAP11                   :AND CHECK NEXT PBLE ITEM

ZAP12   LHI     R0,0
	STH	R0,PTBLE,R1,R1		:ZERO DESTINATION
	STH	R0,BTBLE,R1,R1		:ZERO BOSS INDEX
        LIS     R4,0                    :SET UP R4 FOR MR OP
        LR      R5,R1                   :PORT # IN R5
        LHI     R3,STRLEN               :LEN OF LOGIN STRNG TBL ENTRY IN R4
        MR      R4,R3                   :MULT LEN BY PORT # = ADDR OF ENTRY
        STH     R0,STRTBL,R5            :0 OUT STRTBL LENGTH & SEMICO FLAG
        RBT     R1,LOGINS               :0 THE BIT FOR LOGIN STRING DEFINED FLG
        LHL     R5,XPORT,R13            :THIS PORT LAST SEND PORT OF USER?
        CR      R1,R5                   :SET CC
        JN      ZAP13                  :IF NOT THEN DON'T ZERO OUT XPORT
        STH     R0,XPORT,R13
ZAP13  EQ      .
        TBT     R1,PSNEDL
        JN      ZAP13A

	LA	R3,IBPOFF		:MAKE SURE PORT IS UNBACKPRESSURED
	LR	R2,R1
	JAL	R5,OCM
ZAP13A  LIS     R0,0
	L	R1,ZAPSAV               :RECOVER PORT
	RBT	R1,DUMP
	RBT	R1,APORT		:RESET ACTIVE PORT
	RBT	R1,PSNEDL		:RESET PSEUDO NEEDLE STATE BIT
	JE	ZAP5			:SKIP AHEAD NOT IN LOGGIN
::	ZAPPER FOR PORT IN LOGIN MODE (SUP SENT IT)		::
        JAL     R2,CHKCHN               :TAKE OFF B3MODE AND PSNTIMER CHAIN
        LIS     R0,0
        ST      R0,PSNTMR,R13           :0 OUT PSNTMR VALUE FOR USRBLK
	STH	R0,LPORT,R13		:QUIT THE B3 PROCESS
	CLH	R1,SPORT,R13		:SEE IF CURRENT PORT
	JNR	R6			:DONE IF NOT
	LHL	R0,UFLAG,R13
	NHI	R0,FLOG			:MOVE LOGIN FLAG TO SEND FLAG
	JEFS	ZAP4
	LHI	R0,FSEND
ZAP4	OH	R0,UFLAG,R13
	STH	R0,UFLAG,R13
	J	ZAP6A			:GO TO COMMAND MODE
::	BOSS PORT
ZAP5    CLH     R1,BOSSP,R13            :IS THIS THE BOSS?
	JN	ZAP6			:BR IF NOT A BOSS
        RBT     R1,BOSPRT               :INDICATE NO BOSS
        JAL     R2,CHKCHN               :CHECK B3MODE AND PSNDL TIMER CHAINS
        LIS     R0,0
        ST      R0,PSNTMR,R13
	STH	R0,BOSSP,R13		:INDICATE NO BOSS
	STH	R0,XPORT,R13		:ZERO OUT XPORT FIELD
	ST	R0,CYBTIM,R13		:RESET YELLOW BALL TIMER
	LH	R0,UFLAG,R13
	NHI	R0,@FSEND&@FLOG		:NOT SENDING OR LOGGING
	STH	R0,UFLAG,R13		:*ANY MORE
	LA	R0,CEAT			:SET CMD PROCESSOR TO EAT INPUT
	ST	R0,CMNDAD,R13
	JR	R6
::	CURRENT SEND PORT - GO TO COMMAND MODE
ZAP6	CLH	R1,SPORT,R13		:SEE IF CURRENT PORT
	JNR	R6			:DONE IF NOT
ZAP6A	LR	R7,R6			:SAVE RTRN ADDR
	LHL	R6,SPORT,R13
	LHL	R3,CTBLE,R6,R6		:GET NEXT PORT
	JNFS	ZAP7			:BR IF LAST IN CHAIN
	LHL	R3,FPORT,R13		:WRAP TO FIRST IN CHAIN
	JNFS	ZAP7			:BR UNLESS NO PORTS
	LIS	R3,0			:NO NEW CURRENT PORT IF SO
ZAP7	STH	R3,SPORT,R13		:SET NEW CURRENT PORT
	LHL	R0,UFLAG,R13		:SEE IF IN SEND MODE
	THI	R0,FSEND
	JER	R7			:DONE IF NOT
	JAL	R6,CMODE		:SET UP FOR COMMAND MODE
	ST	R5,CMNDAD,R13
	JR	R7			:RETURN


:	PUT USER BLOCK ON B3 QUEUE
:	R13 = USER BLOCK
:	USES	R4,R6
:	LINKS ON R5

PUBB3Q	L	R6,B3PNTR		:GET FIRST BLOCK ON QUEUE
	JE	PUB3Q0			:NONE, THIS WILL BE FIRST ON QUE
PUB3Q2	CR	R6,R13			:THIS BLOCK ALREADY ON THE B3 QUEUE?
	JER	R5			:YES, EXIT 
	L	R4,B3NEXT,R6		:GET NEXT ON QUEUE
	JEFS	PUB3Q1			:JUMP IF AT END OF QUEUE
	LR	R6,R4			:COPY NEXT BLOCK
	JBS	PUB3Q2			:AND COMPARE WITH ONE TO ADD
PUB3Q1	ST	R13,B3NEXT,R6		:LINK UB ONTO END OF QUEUE
	ST	R6,B3PREV,R13		:LINK BACK
	JR	R5
PUB3Q0	ST	R13,B3PNTR
	JR	R5



: CHKCHN--CHECK IF USRBLK ON B3MODE CHAIN OR PSNDL TIMER CHAIN
: LINK ON R2
: R13 = USER BLOCK
: USES R3,R4,R5

CHKCHN  EQ      .
: IF USRBLK ON B3MODE CHAIN, TAKE IT OFF
        L       R3,B3PNTR               :GET START OF B3MODE CHAIN
        JE      CHKPTC                  :JUMP IF NO CHAIN
        CR      R3,R13                  :1ST IN CHAIN = USRBLK?
        JN      CHKBC1                  :NO, CHECK NEXT
        L       R3,B3NEXT,R13           :YES--IS IT ALSO LAST IN CHAIN?
        JE      CHKBC2                  :YES, JUMP
        ST      R3,B3PNTR               :1ST IN CHAIN := NEXT IN CHAIN
        LIS     R4,0                    :0 OUT PREV PTR OF 1ST IN 
        ST      R4,B3PREV,R3            :CHAIN AND PTRS OF USRBLK
        ST      R4,B3PREV,R13           :TO BE REMOVED
        ST      R4,B3NEXT,R13
        J       CHKPTC                  :CHECK PSDNDL TIMER CHAIN
CHKBC2  LIS     R4,0
        ST      R4,B3PNTR               :0 OUT PTR TO START OF CHAIN
        J       CHKPTC                  :CHECK PSDNDL TIMER CHAIN
CHKBC1  L       R3,B3NEXT,R3            :GET NEXT IN CHAIN
        CR      R3,R13                  : IS IT = TO USRBLK?
        JE      CHKBC3                  :YES, JUMP
        LR      R3,R3                   :AT END OF CHAIN?
        JN      CHKBC1                  :NO, CHECK NEXT IN CHAIN
        J       CHKPTC                  :YES, NOW CHECK PSDNDL TMR CHAIN
CHKBC3  L       R4,B3NEXT,R3            :IS IT LAST IN CHAIN?
        JN      CHKBC4                  :NO, IT'S IN THE MIDDLE
        L       R3,B3PREV,R13           :GET NEXT-TO LAST IN CHAIN
        LIS     R4,0                    :IT BECOMES LAST IN CHAIN--0 OUT
        ST      R4,B3NEXT,R3            :IT'S B3NEXT PTR AND THE
        ST      R4,B3PREV,R13           :B3PREV PTR OF BLK TO REMOVE
        J       CHKPTC                  :CHECK PSDNDL TIMER CHAIN
CHKBC4  L       R5,B3PREV,R3            :R4=NEXT, R5=PREV
        ST      R4,B3NEXT,R5            :R4 := NEXT OF R5
        ST      R5,B3PREV,R4            :R5 := PREV OF R4
        LIS     R4,0                    :0 OUT PTRS OF BLK TO REMOVE
        ST      R4,B3NEXT,R13
        ST      R4,B3PREV,R13

: IR USRBLK ON PSEUDO-NEEDLE TIMER CHAIN, TAKE IT OFF
CHKPTC  L       R3,PNTPTR               :IS THERE A CHAIN?
        JER     R2                      :NO, THAT'S ALL
        CR      R3,R13                  :1ST IN CHAIN = USRBLK?
        JN      CHKPC1                  :NO, CHECK NEXT
        L       R3,PNTNXT,R13           :YES--IS IT ALSO LAST IN CHAIN?
        JE      CHKPC2                  :YES, JUMP
        ST      R3,B3PNTR               :1ST IN CHAIN := NEXT IN CHAIN
        LIS     R4,0                    :0 OUT PREV PTR OF 1ST IN 
        ST      R4,PNTPRV,R3            :CHAIN AND PTRS OF USRBLK
        ST      R4,PNTPRV,R13           :TO BE REMOVED
        ST      R4,PNTNXT,R13
        JR      R2                      :GET OUT
CHKPC2  LIS     R4,0
        ST      R4,B3PNTR               :0 OUT PTR TO START OF CHAIN
        JR      R2                      :GET OUT
CHKPC1  L       R3,PNTNXT,R3            :GET NEXT IN CHAIN
        CR      R3,R13                  : IS IT = TO USRBLK?
        JE      CHKPC3                  :YES, JUMP
        LR      R3,R3                   :AT END OF CHAIN?
        JN      CHKPC1                  :NO, CHECK NEXT IN CHAIN
        JR      R2                      :GET OUT
CHKPC3  L       R4,PNTNXT,R3            :IS IT LAST IN CHAIN?
        JN      CHKPC4                  :NO, IT'S IN THE MIDDLE
        L       R3,PNTPRV,R13           :GET NEXT-TO LAST IN CHAIN
        LIS     R4,0                    :IT BECOMES LAST IN CHAIN--0 OUT
        ST      R4,PNTNXT,R3            :IT'S PNTNXT PTR AND THE
        ST      R4,PNTPRV,R13           :PNTPRV PTR OF BLK TO REMOVE
        JR      R2                      :GET OUT
CHKPC4  L       R5,PNTPRV,R3            :R4=NEXT, R5=PREV
        ST      R4,PNTNXT,R5            :R4 := NEXT OF R5
        ST      R5,PNTPRV,R4            :R5 := PREV OF R4
        LIS     R4,0                    :0 OUT PTRS OF BLK TO REMOVE
        ST      R4,PNTNXT,R13
        ST      R4,PNTPRV,R13
        JR        R2

: REMOVE USRBLK FROM PSEUDO-NEEDLE TIMER CHAIN
: R13 = USRBLK TO REMOVE FROM CHAIN
: R4,R6 CLOBBERED
: LINK ON R3
RUPNTC  EQ      .
        L       R6,PNTPTR               :PUT 1ST IN CHAIN IN R6
        CR      R13,R6                  :IS IT 1ST IN CHAIN?
        JN      RUPNT0                  :NO, JUMP
        L       R6,PNTNXT,R13           :IS IT ALSO LAST IN CHAIN?
        JE      RUPNT1                  :YES, JUMP
        ST      R6,PNTPTR               :1ST IN CHAIN := CURRENT NXT IN CHN
        LIS     R4,0                    :0 OUT THE FOLLOWING PTRS
        ST      R4,PNTPRV,R6            :1ST IN CHAIN HAS 0 IN PREV PTR
        ST      R4,PNTPRV,R13           :0 OUT PTRS OF BLK REMOVED
        ST      R4,PNTNXT,R13           :FROM PSNDL TIMER CHAIN
        JR      R3                      :AND GET OUT
RUPNT1  LIS     R4,0
        ST      R4,PNTPTR               :0 OUT START OF CHAIN
        JR      R3                      :AND GET OUT
RUPNT0  L       R6,PNTNXT,R6            :GET NEXT IN CHAIN
        CR      R6,R13                  :FOUND USRBLK?
        JN      RUPNT0                  :NO, CHECK NXT IN CHAIN
        L       R4,PNTNXT,R6            :IS IT LAST IN CHAIN?
        JN      RUPNT2                  :NO--IT'S IN THE MIDDLE
        L       R6,PNTPRV,R13           :GET NXT TO LAST IN CHAIN--
        LIS     R4,0                    :IT'S NOW THE LAST--0 OUT THE
        ST      R4,PNTNXT,R6            :NXT PTR OF LAST IN CHAIN
        ST      R4,PNTPRV,R13           :AND PREV PTR OF REMOVED BLK
        JR      R3                      :AND GET OUT
RUPNT2  L       R5,PNTPRV,R6            :NXT PTR OF PREV POINTS TO
        ST      R4,PNTNXT,R5            :NEXT BLK, AND PREV PTR OF NEXT
        ST      R5,PNTPRV,R4            :POINTS TO PREV
        LIS     R4,0                    :0 OUT 
        ST      R4,PNTNXT,R13           :PTRS OF REMOVED BLK
        ST      R4,PNTPRV,R13           
        JR      R3                      :AD GET OT

: QTPAR - QUERY A TERMINAL PARAMETER
:	R1 = PORT NMBR
:	R9 = PARAMETER NMBR
:	R8 = LINK REG
:	R5 = RETURNED VALUE (-1 IF ERROR)

QTPAR	CLHI	R9,QFANSZ/2		:SEE IF PARAM NMBR TOO BIG
	JGEFS	QTPER			:BR IF SO
	LHL	R3,QSADDR,R9,R9		:GET PARAM ADDR PTR
	LHL	R5,QFAN,R9,R9		:GET ROUTINE ADDR
        J       SEG1,R5,                :GO DO IT
QTPER	LCS	R5,1			:INDICATE ERROR
	JR	R8			:RETURN
:	QUERY A BIT
QBIT	LIS	R5,0			:EXPECT TO RETURN A ZERO
	TBT	R1,0,R3			:IS THE BIT ON?
	JER	R8			:YES
	LIS	R5,1			:YES...RETURN A ONE
	JR	R8
:	QUERY LEFT PARAMETER
QFLEFT	LB	R5,0,R3,R1		:GET PARAMETER
	SRHLS	R5,4			:AND JUSTIFY IT
	JR	R8
:	QUERY RIGHT PARAMETER
QFRITE	LB	R5,0,R3,R1		:GET IT
	NHI	R5,0F			:AND MASK IT OFF
	JR	R8

QFAN	HC	QBIT-SEG1		:0 - ECHO CONTROL
	HC	QBIT-SEG1		:1 - ECHO CONTROL-I
	HC	QBIT-SEG1		:2 - ECHO LF W/CR
	HC	QBIT-SEG1		:3 - ECHO CR W/LF
	HC	QBIT-SEG1		:4 - CR DELAY
	HC	QFLEFT-SEG1		:5 - INPUT BAUD RATE
	HC	QFRITE-SEG1		:6 - OUTPUT BAUD RATE
	HC	QBIT-SEG1		:7 - PARITY
	HC	QBIT-SEG1		:8 - HALF DUPLEX
	HC	QFLEFT-SEG1		:9 - PARAMETER A
	HC	QFRITE-SEG1		:10 - PARAMETER B
	HC	QFLEFT-SEG1		:11 - PARAMETER C
	HC	QBIT-SEG1		:12 - X-ENABLE
	HC	QBIT-SEG1		:13 - ECHO CONTROL-H
	HC	QBIT-SEG1		:14 - REVERSE X-ENABLE
	HC	QFRITE-SEG1		:15 - PARAMETER D
	HC	QBIT-SEG1		:16 - KATAKANA
	HC	QBIT-SEG1		:17 - TERM OUT ON BRK
	HC	QBIT-SEG1		:18 - ECHO ESCAPE
	HC	QBIT-SEG1		:19 - 'Q' - MODE
QFANSZ	EQ	.-QFAN

:	POINTERS TO PARAMETER TABLES

QSADDR	HC	ECHO			:0 - ECHO CONTROL
	HC	ECTLI			:1 - ECHO CONTROL-I
	HC	ELFCR			:2 - ECHO LF W/CR
	HC	ECRLF			:3 - ECHO CR W/LF
	HC	CRDE			:4 - CR DELAY
	HC	BRATE			:5 - INPUT BAUD RATE
	HC	BRATE			:6 - OUTPUT BAUD RATE
	HC	PARITY			:7 - PARITY
	HC	HAFDUX			:8 - HALF-DUPLEX
	HC	PAB			:9 - PARAMETER A
	HC	PAB			:10 - PARAMETER B
	HC	PCD			:11 - PARAMETER C
	HC	XONENA			:12 - X-ENABLE
	HC	ECTLH			:13 - ECHO CONTROL-H
	HC	YONENA			:14 - REVERSE X-ENABLE
	HC	PCD			:15 - PARAMETER D
	HC	KATA			:16 - KATAKANA
	HC	T.BRK			:17 - TERM OUT ON BRK
	HC	EC.ESC			:18 - ECHO ESCAPE
	HC	Q.MOD			:19 - 'Q' MODE

: SBPAR - SEND TERMINAL PARAMETER TO BOSS PORT
:	R5 = NEW PARAMETER VALUE
:	R9 = PARAMETER NMBR (NOT ECHO)
:	R10 = BOSS PORT NMBR

SBPAR	LR	R1,R10			:GET BOSS PORT NMBR
	JE	STPAR			:BR IF NO BOSS
	CLHI	R9,5			:DON'T SEND BAUD RATE CHANGES
	JER	R8
	CLHI	R9,6
	JER	R8
	LIS	R0,5
	LHI	R2,STPMSG		:SEND SET TERM MSG
	JAL	R4,SLOR,,
	LR	R0,R9
	JAL	R4,PUTCH,,
	LR	R0,R5
	JAL	R4,PUTCH,,
	JAL	R4,ELOR,,			:END MSG & CONTINUE

: STPAR - SET A TERMINAL PARAMETER
:	R1 = PORT NMBR
:	R5 = PARAMETER VALUE
:	R9 = PARAMETER NMBR

STPAR	CLHI	R9,SFANSZ/2		:SEE IF TOO BIG
	JGE	STPER			:BR IF SO
	LHL	R3,QSADDR,R9,R9		:GET PARAM ADDR
	LHL	R4,SFAN,R9,R9		:GET ROUTINE ADDR
	J	SEG1,R4,
:	ADJUST A BIT
SBIT	RBT	R1,0,R3			:TURN IT OFF
	THI	R5,1
	JER	R8
	SBT	R1,0,R3			:ELSE TURN IT BACK ON AGAIN
STPER	JR	R8
:	SET LEFT PARAMETER
SFLEFT	LB	R4,0,R3,R1		:REMOVE CURRENT VALUE
	NHI	R4,0F
	LR	R2,R5
	SLHLS	R2,4			:JUSTIFY VALUE
	JFS	SFIELD			:AND SKIP
:	SET RIGHT PARAMETER
SFRITE	LB	R4,0,R3,R1		:REMOVE CURRENT VALUE
	NHI	R4,0F0
	LR	R2,R5
SFIELD	OR	R4,R2			:PLACE NEW VALUE
	STB	R4,0,R3,R1		:PUT NEW VALUE CK
	JR	R8

SFAN	HC	SBIT-SEG1		:0 - SET ECHO
	HC	SBIT-SEG1		:1 - ECHO CONTROL-I
	HC	SBIT-SEG1		:2 - ECHO LF W/CR
	HC	SBIT-SEG1		:3 - ECHO CR W/LF
	HC	SBIT-SEG1		:4 - CR DELAY
	HC	SFLEFT-SEG1		:5 - INPUT BAUD RATE
	HC	SFRITE-SEG1		:6 - OUTPUT BAUD RATE
	HC	SBIT-SEG1		:7 - PARITY
	HC	SBIT-SEG1		:8 - HALF DUPLEX
	HC	SFLEFT-SEG1		:9 - PARAMETER A
	HC	SFRITE-SEG1		:10 - PARAMETER B
	HC	SFLEFT-SEG1		:11 - PARAMETER C
	HC	SBIT-SEG1		:12 - X-ENABLE
	HC	SBIT-SEG1		:13 - ECHO CONTROL-H
	HC	SBIT-SEG1		:14 - REVERSE X-ENABLE
	HC	SFRITE-SEG1		:15 - PARAMETER D
	HC	SBIT-SEG1		:16 - KATAKANA
	HC	SBIT-SEG1		:17 - TERM OUTPUT ON BRK
	HC	SBIT-SEG1		:18 - ECHO ESCAPE
	HC	SBIT-SEG1		:19 - 'Q' - MODE
SFANSZ	EQ	.-SFAN
 
DS.CIR  SVC     K.OUT,CRLFMG            :CR,LF
        SVC     K.OUT,CRCHD0            :PRNT HEADERS
        SVC     K.OUT,CRCHD1            :PRNT HEADERS
        LA      R13,USER0,,             :GET 1ST USER BLOCK
DS.C00  LHL     R1,BOSSP,R13            :BOSS PORT FOR THIS USER?
        JN      DS.C01                  :YES, PRINT BOSS PORT # AND USRNAM
        LH      R1,FPORT,R13            :THIS USR HAVE ANY CIRCUITS?
        JN      DS.C05                  :YES--PRINT THEM
DS.C04  LA      R13,ENDBLK,R13          :GET NEXT USER BLCK
        CLI     R13,LSTBLK              :LAST BLK?
        JN      DS.C00                  :NO, CHECK FOR BOSS
        LB      R1,NLIFLG,,             :CHECK IF NLIMSG NEEDED
        LR      R1,R1                   :SET CC
        JE      DSTART,,                :NO, SO GET OUT
        SVC     K.OUT,NLIMSG            :" *NLI = USER NOT LOGGED IN"
        LIS     R1,0                    :RE-SET NLIFLG
        STB     R1,NLIFLG,,
        J       DSTART,,                :THAT'S ALL
DS.C05  SVC     K.OUT,NLIPRT            :BUT NO BOSS, SO PRINT "NLI*"
        SVC     K.OUT,NAME+1,R13        :PRINT USR NAME
        SVC     K.OUT,CRLFMG            :CR,LF
        LIS     R4,1                    :SET NLIFLG
        STB     R4,NLIFLG,,
        J       DS.C02                  :NOW PRINT 1ST PORT IN CHAIN
DS.C01  LIS     R15,3                   :SET UP CBA CALL
        STB     R15,PRTNUM,R13          :PRTNUM IS STRING FOR SVC OUT CALL
        LA      R14,PRTNUM+1,R13        :STORE ADDR FOR CBA CALL
        LIS     R4,0A                   :DECIMAL RADIX FOR CBA
        JAL     R5,CBA                  :CONVERT TO ASCII
        SVC     K.OUT,PRTNUM,R13        :SEND OUT PORT NUMBER
        SVC     K.OUT,SPACE3            :SEND 3 SPACES
        SVC     K.OUT,NAME+1,R13        :SEND OUT USER NAME
        SVC     K.OUT,CRLFMG            :CR,LF
        LH      R1,FPORT,R13            :CHECK FIRST CIRCUIT IN CHAIN
        JE      DS.C03                  :JUMP IF NOT
DS.C02  SVC     K.OUT,CRCTAB            :"TAB" TO PORT COLUMN
        LIS     R15,3                   :SET UP CBA CALL
        LIS     R4,0A                   :SET UP CBA CALL
        STB     R15,PRTNUM,R13          :PRTNUM = STRNG ADDR FOR SVC OUT CALL
        LA      R14,PRTNUM+1,R13        :GET STRNG ADDR USED BY CBA CALL
        JAL     R5,CBA                  :CONVERT PORT # TO ASCII
        SVC     K.OUT,PRTNUM,R13        :SEND IT OUT
        SVC     K.OUT,SPACE3            :SEND 3 SPACES
        SLLS    R1,NLENS                :GET POINTER TO NTABLE ENTRY
        SVC     K.OUT,NTBLE+1,R1        :SEND OUT LABEL FOR THIS PORT
        SVC     K.OUT,CRLFMG            :CR,LF
        SRLS    R1,NLENS                :GET ORIGINAL VALUE IN R1
        LH      R1,CTBLE,R1,R1          :ANOTHER PORT ON CHAIN? (YES IF > 0)
        JN      DS.C02                  :IF 0, THAT'S ALL FOR THIS USER BLK
DS.C03  SVC     K.OUT,CRCDIV            :DBLE LINE SEPARATES USERS
        J       DS.C04                  :CHECK NEXT USER
 
	SUBTTL	TIME OUT ROUTINES
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
::		T I M E    O U T    R O U T I N E S             ::
::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

: QUARTER SECOND LOGIC

QSEC	AHI	R1,RATE/4
	JAL	R5,TOPUT,,		:RUN 4 TIMES A SECOND
	LHI	R7,2*NGRP-2		:THIS MANY GROUPS OF HALFWORDS
QSEC1	LCS	R0,1
	XH	R0,TYMSAT,R7		:NOT TYMSAT PORTS
        XH      R0,PSNEDL               :NOT LOGIN MODE PORTS
	NH	R0,NBO,R7		:THOSE WITH NO BALLS OUT
	NH	R0,DEM,R7		:THOSE IN DEM
	NH	R0,APORT,R7		:AND THOSE ACTIVE
	STH	R0,TEMP3
QSEC2	LH	R0,TEMP3		:ANY PORTS TO DO
	JFFOH	R0,QSEC3		:FIND FIRST BIT
	SIS	R7,2			:NONE THERE,DO NEXT GROUP
        JGE     QSEC1                   :NEXT GROUP
	J	TORET,,			:ALL DONE
QSEC3	RBT	R1,TEMP3		:DONT DO THIS PORT AGAIN
	LR	R0,R7			:COMPUTING THE PORT NUMBER
	SLHLS	R0,3			:WHICH GROUP
	AR	R1,R0			:ACTUAL PORT NUMBER
	RBT	R1,NBO			:R1 HAS THE PORT NUMBER
	RBT	R1,TBOB			:TIME OUT BITS
	RBT	R1,TBOA			:MORE TIMEOUT BITS
	SBT	R1,EXPECT		:EXPECTING RETURNS
	LHI	R2,GBMSG		:MESSAGE TYPE
	LIS	R0,3			:SIZE
	JAL	R4,SLOR,,
	JAL	R4,ELOR,,
	J	QSEC2			:ANY MORE IN THE HALFWORD GROUP?

: 8 SEC LOGIC

SEC8	AI	R1,RATE*8
	JAL	R5,TOPUT,,		:RUN AGAIN IN EIGHT SECONDS
	LHI	R7,2*NGRP-2		:THIS MANY HALFWORD GROUPS
SEC81	LH	R0,TYMSAT,R7		:NOT TYMSAT PORTS
	OH	R0,NBO,R7		:THOSE WITH BALLS OUT
	XHI	R0,-1
        XH      R0,PSNEDL,R7            :NOT LOGIN PORTS
	NH	R0,APORT,R7		:AND ACTIVE
	NH	R0,DEM,R7		:AND IN DEM MODE
	NH	R0,TBOA,R7		:AND  HAVING ACTUALLY TIMED OUT
	STH	R0,TEMP3		:SAVE THE EXAMINED WORD
SEC82	LHL	R0,TEMP3		:GET THE GROUP
	JFFOH	R0,SEC83		:FIND 1ST ONE,GO TO SEC83,ELSE CONT
	LHL	R1,TBOB,R7
	STH	R1,TBOA,R7
	LCS	R1,1
	STH	R1,TBOB,R7
	SIS	R7,2			:NONE THERE DO NEXT GROUP
	JGE	SEC81			:DO NEXT GROUP
:	J	TORET,,			:ALL DONE,EXIT
	J	SEC800			:DO INACTIVITY JOB
SEC83	RBT	R1,TEMP3		:DON'T DO THIS PORT AGAIN
	LR	R0,R7			:COMPUTING PORT NUMBER
	SLHLS	R0,3			:WHICH GROUP?
	AR	R1,R0			:ACTUAL PORT NUMBER
	RBT	R1,TBOA			:NOT SURE WHAT THIS DOES
	RBT	R1,TBOB			:SAME HERE
	RBT	R1,EXPECT		:GOING TO CANCEL OUTSTANDING BALLS
	LIS	R0,3			:MSG SIZE
	LHI	R2,RBMSG		:WHAT WE ARE SENDING
	JAL	R4,SLOR,,		:R1 CONTAINS PORT NUMBER
	JAL	R4,ELOR,,
	J	SEC82			:ANY MORE THIS GROUP?

:Check for ports that have Exceeded their Inactivity Time Period
:Will Zap any port except the BOSS port.


:Update each ports Inactivity timer if Data has been coming in.
:Will do this by setting a new port zap time (by SlowC), for
:each port that has its bit set in the TPORT array.

SEC800	L	R8,SLOWC,,		:GET THE SLOW-CLOCK
	LHI	R7,2*NGRP-2		:ADDRESSING FOR NUMBER OF HALFWORD GRPS
SEC801	LH	R0,TPORT,R7,,		:GET INACTIVITY PORT ARRAY
	OH	R0,BOSPRT,R7		:OR IN THE BOSS PORTS(ALWAYS ACTIVE)
	STH	R0,TEMP3		:SAVE BITS TO BE DONE
SEC802	LHL	R0,TEMP3		:LOAD BITS TO BE DONE
	JFFOH	R0,SEC806		:FIND FIRST SET BIT & JUMP
	SIS	R7,2			:NEXT
	JGE	SEC801			:TIL ALL ARE DONE
	J	SEC880			:GO DO THE ZAPPING

:Port has Activity bit set, update it's zap time

SEC806	RBT	R1,TEMP3   		:RESET SO NOT DONE AGAIN
	LR	R0,R7			:COMPUTE PORT NUMBER
	SLLS	R0,3			:MULTIPLY BY 8
	AR	R1,R0			:GOOD PORT NUMBER
        LHL     R13,BTBLE,R1,R1         :GET USER BLOCK ADDRESS
        AI      R13,UBLSEG              :ADD IN THE SEG ADDRESS
        L       R9,INACT,R13            :GET USER'S BEFORE INACTIVE ZAP TIME
	AR	R9,R8			:ADD IN THE PRESENT TIME
	SLLS	R1,2			:NOW INDEX INTO TQPORT ARRAY
	ST	R9,TQPORT,R1,		:SAVE NEW TIME FOR INACTIVITY(UPDATE)
	J	SEC802			:NEXT!

:Now check for ports that have exceeded their grace period. If so,
:give them the big ZAP.

SEC880	LHI	R7,4*NPORT-4		:NUMBER OF FULLWORD PORTS
SEC882	LR	R1,R7			:GET PORT NUMBER INDEX
	SRLS	R1,2			:MAKE IT A APORT INDEX(R1/4)
	TBT	R1,APORT		:IS IT ACTIVE?
	JE	SEC886			:NO, JUMP
	CL	R8,TQPORT,R7,		:SLOWC > TQPORT TIME?
	JL	SEC886			:NO NEED TO ZAP IT, UNLESS GREATER
        LHL     R13,BTBLE,R1,R1         :GET BOSS PORT, NEED R13 & R10 FOR ZAP
        AI      R13,UBLSEG              :ADD IN THE USER BLOCK SEG (SEG 3).
        L       R10,INACT,R13           :GET TIMEOUT VALUE
        JEFS    SEC886                  : IF = 0, INACTIVITY ZAP DISABLED
        LH      R10,BOSSP,R13           :GET THE BOSS PORT
	STH	R7,TEMP3,,		:SAVE R7
	JAL	R6,ZAP			:ZAP PORT!!
	LHL	R7,TEMP3,,		:RESTORE
	L	R8,SLOWC,,		:RESTORE
SEC886	SIS	R7,4			:DECREMENT TO NEXT
	JGE	SEC882			:NEXT!

:Now we need to zero out the TPORT array for the next time through.
:These bits get set as a DataMessage comes in on that port#.

	LHI	R7,2*NGRP-2		:NUMBER OF PORT GRPS
	LIS	R0,0			:ZERO R0
SEC888	STH	R0,TPORT,R7,		:ZERO TPORT GROUP
	SIS	R7,2			:DECREMENT R7
	JGEBS	SEC888			:TIL ALL ARE DONE
	J	TORET,,			:ALL DONE WITH 8 SEC ROUTINE.


:	TRAP USER BLOCK OF NON-AUTHORIZED USER OF GREET CMD
	SEG	0
	BND	4
TRPREG	WS	10
TRPTCH	WS	40
TRPPTR	HS	1
	SEG	1
TRPGUS	STM	R1,TRPREG,,
	LHL	R1,TRPPTR,,
	ST	R13,TRPTCH,R1,
	LIS	R2,0
TRPGU0	LB	R3,GRETMG+1,R2,
	STB	R3,TRPTCH+4,R2,R1
	AIS	R2,1
	CLHI	R2,0C
	JLBS	TRPGU0
	AHI	R1,10
	CLHI	R1,40
	JEFS	TRPGU1
	LIS	R1,0
TRPGU1	STH	R1,TRPPTR,,
	LM	R1,TRPREG,,
	JR	R9

        SUBTTL  Control Table Allocation and Diagnostics - FINISH.LIB
 
:**********************************************************************
:                                                                     *
:       This program is the sole property and confidential            *
:       information of Tymshare, Inc., and may not be copied          *
:       in whole or in part or disclosed to any third party           *
:       without the prior written consent of Tymshare.                *
:                                                                     *
:**********************************************************************

	RA	0		:	FINISH.LIB

:	this file should always be assembled LAST!

:ALLOCATE FPANEL IF USER HAS NOT
  IF	\FPANEL
  ELSE
	SEG	A.DATA
FPANEL  HS      1
  EI
  IF	\FRISIS
  ELSE
	SEG	0
FRISIS	HS	$A (MAXPRT+15)/16
  EI
  IF	\TOISIS
  ELSE
	SEG	0
TOISIS	HS	$A (MAXPRT+15)/16
  EI

  IF	1-(\PATCH0)
	SEG	0
PATCH0	WS	20	:SEGMENT ZERO PATCH AREA
  EI
  IF	1-(\PATCH1)
	SEG	1
PATCH1	WS	20	:SEGMENT ONE PATCH AREA
  EI
  IF	1-(\PATCH2)
	SEG	2
PATCH2	WS	20	:SEGMENT TWO PATCH AREA
  EI

	IF	\APROT0
	ELSE
APROT0	EQ	6	:EXECUTION PROTECTED
	REMARK	%DEFAULT AREA PROTECTIONS ASSUMED.%
	EI
	IF	\APROT1
	ELSE
APROT1	EQ	5	:WRITE PROTECTED
	EI
Q1	EQ	2
	RE	0C
	IF	\APROT|Q1|
	ELSE
APROT|Q1| EQ	6	:EXECUTION PROTECTED
	EI
Q1	EQ	Q1+1
	ER

:	NAD ALLOWS MORE THAN 10000X TO BE PLACED IN ONE "SEG".
:	WE MUST THEREFORE GO INTO EACH SEG AND IF > 10000X ORG BACK TO
:	10000X AND THEN ENTER THE NEXT SEG TO DEPOSIT THE REMAINDER.
:	THIS, OF COURSE, ASSUMES THAT THE NEXT SEG IS EMPTY.
:	A CHECK IS MADE TO INSURE THIS.

Q1	EQ		0
	RE		0E		:FOR Q1 = 0 TO 0E
	  SEG		Q1
Q3	  EQ		10000*(Q1+1)	:  Q3 = UPPER BOUND FOR THIS SEGMENT
	  IF		.-Q3		:  IF THIS SEGMENT OVERFLOWED
Q2	    EQ		.-Q3		:    Q2 = LENGTH OF OVERFLOW
	    ORG		Q3		:    ORG TO MAXIMUM
	    IF		0E-(Q1+1)	:    IF THE NEXT SEG IS NOT E
	      SEG	Q1+1		:      GO INTO NEXT SEG
	      IF	(.-Q3)		:      IF SEG ALREADY IN USE
	        SEG	Q1		:        RETURN TO PREVIOUS SEG
	      ELSE			:      ELSE
APROT|Q1+1|	EQ	APROT|Q1|	:        COPY PROTECTION
	      EI			:      ENDIF
	    EI				:    ENDIF
	    ORG		.+Q2		:    ADD OVERFLOW TO THE CURRENT SEG
	  EI				:  ENDIF
Q1	  EQ		Q1+1		:NEXT Q1
	ER

:GENERATE DIAGNOSTICS
Q	EQ	0
	NOLIST
	RE	0F
SEG|Q|	EQ	SEG|Q|&07FFFFFFF
	IF	SEG|Q|%(Q*10000)
	REMARK	%"SEG
	NUMBER	Q
	REMARK	" has been redefined
	EI
:	DEFINE SIZES
	SEG	Q
S|Q|SIZE EQ	.-SEG|Q|
Q	EQ	Q+1
	ER
	LIST

:	BITCH IF ANY SEGMENTS OVERFLOW
	NOLIST
Q	EQ	0;	RE	0F;	IF	S|Q|SIZE-10000;	REMARK	%Segment 
	NUMBER	Q;	REMARK	- overflow, exceeded by 
	NUMBER	($0S|Q|SIZE-10000)$A;	REMARK	d bytes%;	EI
Q	EQ	Q+1;	ER
	LIST

      IF        \XMEMRY
      ELSE
XMEMRY  EQ      0
      EI

:	SET UP CTA TABLE
  IF	SESIZE
	REMARK	%SEGMENT E IS RESERVED FOR CTA. REMOVE OTHER ALLOCATIONS.%%
  ELSE
	SEG	0E
      IF        XMEMRY
CTA     WC      CNTRL+$01000    :Control flags
      ELSE
CTA	WC	CNTRL	:CONTROL FLAGS
      EI

	WC	CTASIZ	:SIZE OF CTA AREA
AREAS
Q	EQ	0
	RE	0E
	WC	S|Q|SIZE	:AREA SIZE
Q	EQ	Q+1
	ER

	HC	0E	:NUMBER OF PROTECTION BYTES
Q	EQ	0
	RE	0E
	BC	APROT|Q|
Q	EQ	Q+1
	ER

	WC	ENTRY	:ENTRY POINT ADDRESS
    IF	\DSTART
	WC	DSTART	:DDT START ADDRESS
    ELSE
	WC	0	:NO USER DDT CODE
    EI

	WC	FPANEL	:ADDRESS OF FRONT PANEL DISPLAY CELL

	WC	HOSTS	:HOST TABLE ADDRESS
	WC	PORTS	:PORT TABLE ADDRESS
	WC	PTABLE	:PERMUTER TABLE ADDRESS
	WC	IRING	:INPUT RING ADDRESS
	WC	ORING	:OUTPUT RING ADDRESS
	WC	FRISIS	:ADDRESS TO INPUT BACKPRESSURE BIT ARRAY
	WC	TOISIS	:ADDRESS OF OUTPUT BACKPRESSURE ARRAY
  IF	\PCTTBL
	WC	PCTTBL	:PROJECT CODE TERMINATION TABLE
  ELSE
	WC	0	:NULL TABLE
  EI
COREST	WS	1	:ABSOLUTE CORE ADDRESS OF START OF SLOT
	HC	MAXHST	:MAXIMUM HOSTS FOR SLOT
	HC	MAXPRT	:HIGHEST PORT NUMBER FOR SLOT
	HC	IRSIZE	:INPUT RING SIZE
	HC	ORSIZE	:OUTPUT RING SIZE
SLOTNO	HS	1	:SLOT NUMBER (SUPPLIED BY ISIS)
VERREV	HS	0
  IF	\VERSION
	BC	VERSION	:VERSION NUMBER
  ELSE
	BC	0
  EI
  IF	\REVLEV
	BC	REVLEV	:REVISION LEVEL
  ELSE
	BC	0
  EI

    IF	\QSTART
	WC	QSTART	:DDT QUERRY START ADDRESS
    ELSE
	WC	0	:NO USER CODE
    EI
        HC      EMMAC0-CTA
    IF  \NMACSS
        HC      NMACSS          :Number of MAC Register Sets
    ELSE
        HC      0               :No extended MAC sets
    EI
        HC      0               :Segments to be saved

    IF \PRODID
    ELSE
      IF  \HID0
PRODID  EQ      HID0            :Define PRODID as alias
      ELSE
      EI  :HID0
    EI :PRODID

    IF \PRODID
      IF PRODID-$a255
        REMARK  %PRODID is too large%
        QUIT    1
      EI
      IF PRODID-$a48
      ELSE
        REMARK  %PRODID is too small%
        QUIT    1
      EI
    ELSE
        REMARK  %PRODID - Slot Product id must be defined%
        QUIT    1
    EI :PRODID
        HC      PRODID          :slot Product id

	WS	10	:RESERVED FOR FUTURE EXPANSION

HOSTS	HS	0	:BEGINNING OF HOST TABLE
Q	EQ	0
	RE	MAXHST
    IF	\HOST|Q|
	HC	HOST|Q|	:HOST NUMBER
    ELSE
	HC	0	:NO ASSEMBLED IN HOST NUMBER
    EI
Q	EQ	Q+1
	ER

PORTS	HS	0	:BEGINNING OF PORT TABLE
Q	EQ	0
	RE	MAXHST
    IF	\HPRT|Q|
	HC	HPRT|Q|
    ELSE
	HC	0	:NO ASSEMBLED IN NUMBER OF PORTS
    EI
Q	EQ	Q+1
	ER

PTABLE	HS	MAXPRT+1	:PERMUTER TABLE

EMMAC0  WS      0               :Extended Memory MAC Register sets
    IF XMEMRY
      IF \NMACSS
        EXPMAC
        REMARK  %Using Extended Memory Option%
        NUMBER  $a NMACSS
        REMARK  MAC Register sets allocated%
        NUMBER  $a EMEMR3
        REMARK k allocated on non-zero meg
      ELSE
        REMARK  %NMACSS must be specified with extended memory%
        QUIT    1
      EI        :NMACSS
    EI          :XMEMRY

CTASIZ	EQ	.-CTA	:CTA AREA SIZE
SESIZE	EQ	.-CTA	:SEG E SIZE
  EI

:	TELL MEMORY REQUIREMENTS
Q	EQ	0
QQ	EQ	0
QQQ	EQ	0
	RE	0F
	IF	S|Q|SIZE
	REMARK	%SEGMENT 
	NUMBER	Q
	REMARK	-length 
QQQ	EQ	S|Q|SIZE
	NUMBER	$A QQQ
	REMARK	d, requires 
Q3	EQ	(S|Q|SIZE+0FF)&(@0FF);	NUMBER	Q3
QQ	EQ	QQ+Q3
	REMARK	x bytes of core.
	EI
Q	EQ	Q+1
	ER

:	GIVE FINAL SIZES
	REMARK	%       
	NUMBER	(QQ+$03FF)/400$A	:FORCE TO BASE 10 FOR OUTPUT
	REMARK	d K-bytes of core

	UN		:spew out all undefined symbols

 (gq