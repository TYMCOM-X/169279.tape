:CHANGED LINE 433 FROM "AIS  R3,MUDSEC" TO "AHI  R3,MUDSEC"  RDH/MCTS 02/12/90
:
:********************************************************************
:***                  PROPRIETARY INFORMATION                     ***
:***                                                              ***
:***  This  source  code  listing  constitutes  the proprietary   ***
:***  property of MDC-TYMNET. The  recipient, by  receiving       ***
:***  this program listing, agrees that neither this listing nor  ***
:***  the   information  disclosed herein nor any  part  thereof  ***
:***  shall be  reproduced or transferred to other documents  or  ***
:***  used  or  disclosed to others for manufacturing or for any  ***
:***  other   purpose except as specifically authorized in  wri-  ***
:***  ting by  MDC-TYMNET.					  ***
:********************************************************************
:***			PROGRAM IDENTIFICATION			  ***
:***								  ***
:***  Version Number    : 07.02					  ***
:***  File Name         : UN207.R02				  ***
:***  File Description  : Supervisor system MUD Update slave code ***
:***  Release Date      :                                         ***
:***  File Abstract     :                                         ***
:***								  ***
:********************************************************************
::

	LIST
:
:	DEFINE SYMBOLS FOR SCRATCH MEMORY FOR SPLIT KERNEL DEBUG USERS
:
SCRUN2	EQ	0C0000
SCRERR	EQ	0C0000
SCRACC	EQ	0C0000
SCRMSG	EQ	0C0000
SCRPRB	EQ	0C0000
SCRSRO	EQ	0C0000
SCRSRW	EQ	0E0000
:
:**********************************************************************
:
:	DEVELOPMENT ASSEMBLY SWITCHES
:
	GLOBAL(WRS,0)
	GLOBAL(JONAS,0)
	GLOBAL(WWANG,0)
	GLOBAL(OMAR,0)
	GLOBAL(MATT,0)
	GLOBAL(SVLSUP,0)
	GLOBAL(DDTTRP,1)	:DDT TRAPS, DEFAULT TO TRUE
	GLOBAL(UN2UP1,1)	:CHECK FOR BAD MUD ENTRIES DURING UPDATE
        GLOBAL(PATLIB,0)     	:PATCH AREA SWITCH
	GLOBAL(MUDII,0)		:UN2 MODS FOR NEW MUD FORMAT

	:SUPERVISOR SLAVE FOR UPDATING/CHECKING MUD
	MO	0,UN2
	LO	SUPER
	GL	ASTIME,VERSN
: %&%& PID, VERREV INSERT FOR AUTOMATED RELEASE JOBS %&%& :
UN2VR   EQ      $A07            :VERSION #
UN2RV   EQ      $A02            :REVISION #
UN2PID	EQ	6C		:PID FOR UN2

VERSN	EQ	0A*UN2VR+UN2RV	:FULL VERSION #
: %&%& TITLE INSERT FOR AUTOMATED RELEASE JOBS %&%& :
        TITLE   MUD-UPDATE-SUPERVISOR-UN2-SLAVE VERSION 07, REVISION 02

ASTIME	CURGMT			:SET CURRENT ASSEMBLY TIME
	REMARK %ASSEMBLY FOR UN2 VERSION=
	NUMBER $AUN2VR
	REMARK , REVISION=
	NUMBER $AUN2RV
	REMARK , PID=
	NUMBER UN2PID
	REMARK (HEX)%%ASSEMBLY TIME IN GMT SECONDS SINCE 1974 IS 
	NUMBER ASTIME
	REMARK %%





	IF	(1-\SUPNKU)!(1-\.TYM3)
	:UNDEFINED IF IMPROPER INITIALIZATION
	REMARK %%*****ASSEMBLY CANCELLED DUE TO IMPROPER TYMFILE INITIALIZATION******%%
	QUIT
	EI


	:NOTE - CODE FOR THIS VERSION ASSUMES THAT IF THE
	:NON-MSC FORMAT IS USED, THAT THE LU FOR THE MUD IS 0.


:MACRO DEFINITIONS

	IF	MUDII
	ELSE	:MUDII
:CHECKSUM MACRO
:  MACRO TO ADD TO CHECKSUM IN REGISTER X, NEW BYTE IN REGISTER Y,
:  REGISTER Z USED FOR SCRATCH.  USES 940 STYLE 24 BIT
:  WORD 7 BIT LEFT ROTATE AND ADD.  LEAVES GARBAGE IN HIGH
:  BYTE OF RESULT.
:
CKSM	MACRO	(X,Y,Z)[
	EXHR	Z,X		:ISOLATE HIGH BYTE OF 24 BIT WORD
	LBR	Z,Z
	SRLS	Z,1		:MAKE HIGH 7 BITS
	SLLS	X,7		:FAKE 940 7 BIT ROTATE WITHIN 24 BIT WORD
	AR	X,Z
	AR	X,Y		:ADD IN NEW BYTE
]
	EI	:MUDII

:DEFINE SYMBOLS AND DEFAULTS



	:SVC DESIGNATORS
	IF	1-ISIS
IN	EQ	0
OUTSVC	EQ	2
TRSOUT	EQ	3
GENERAL	EQ	5
GUP	EQ	6
	IF	MSC
SHARE	EQ	0A
	ELSE
DSK1	EQ	4
DSK4	EQ	7
	EI
	ELSE
GUP	EQ	0
ISYS	EQ	2
IN	EQ	0A
OUTSVC	EQ	0B
GENERAL	EQ	0D
	IF	MSC
SHARE	EQ	4
	ELSE
DSK4	EQ	0E
DSK1	EQ	0F
	EI
	EI


	:MUD PARAMETERS - DEFINED BY MACRO TYMFILE
	IF	SVLSUP		:DEFINE DUMMY PARMS FOR CLEAN ASSEMBLY
MUDLU	EQ	0		:LOGICAL UNIT FOR MUD
MUDSTA	EQ	0		:VIRTUAL ADDRESS OF START OF MUD
MUDSEC	EQ	0		:SECTORS/MUD BLOCK (2**N)
MUDNBK	EQ	0		:NUMBER OF NORMAL BLOCKS
MUDOBK	EQ	0		:NUMBER OF OVERFLOW BLOCKS
MUDSFT	EQ	0		:SHIFT TO CONVERT BLOCK NUMBER TO SECTOR OFFSET
	ELSE	:SVLSUP
MUDLU	EQ	0		:LOGICAL UNIT FOR MUD
MUDSTA	EQ	MUDSTA		:VIRTUAL ADDRESS OF START OF MUD
MUDSEC	EQ	MUDSEC		:SECTORS/MUD BLOCK (2**N)
MUDNBK	EQ	MUDNBK		:NUMBER OF NORMAL BLOCKS
MUDOBK	EQ	MUDOBK		:NUMBER OF OVERFLOW BLOCKS
MUDSFT	EQ	MUDSFT		:SHIFT TO CONVERT BLOCK NUMBER TO SECTOR OFFSET
	EI	:SVLSUP

CNINDX	EQ	CNINDX		:0-->NO CACHE
	IF	MSC
BLKSIZ	EQ	100^MUDSFT
	ELSE
	IF	4-MUDSEC
DSK	EQ	DSK1		:USE SECTOR DISK READS
BLKSIZ	EQ	100^MUDSFT	:SIZE OF BLOCK IN BYTES
	ELSE
DSK	EQ	DSK4		:USE BLOCK DISK READS
MUDSFT	EQ	MUDSFT-2	:ADJUST SHIFT COUNT TO BLOCK READS
MUDSEC	EQ	MUDSEC/4	:CONVERT FROM SECTORS TO BLOCKS
BLKSIZ	EQ	400^MUDSFT	:SIZE OF BLOCK IN BYTES
	EI
	EI

	IF	SVLSUP	:JUST TO GET CLEAN ASSEMBLY FOR NO DISK SUP SLAVE
CONLIM	EQ	0	 :MAX LIMIT FOR CONSISTENCY
	ELSE	:SVLSUP
CONLIM	EQ	(MUDBKS-1)*MUDSEC :MAX LIMIT FOR CONSISTENCY
	EI	:SVLSUP

	IF	MUDII
MINESZ	EQ	20		:MINIMUM ENTRY SIZE IN BYTES
MBHSIZ	EQ	0C		:MUD BLOCK HEADER SIZE IN BYTES
MBHFLG	EQ	8		:OFFSET TO MUD BLOCK FLAGS IN BYTES
ENTTYP	EQ	0		:OFFSET TO BYTE CONTAINING ENTRY TYPE
ENTSIZ	EQ	2		:OFFSET TO HALFWORD CONTAINING ENTRY SIZE
	EI	:MUDII		:FROM BEGINNING OF THE ENTRY


	IF	CNINDX
	:DEFINE LAYOUT OF RWAREA AND ST6CNT

	ORG	10050		:10000 SEGMENT FOR RWAREA
MUDUP	EQ	.

	:DEFINE LAYOUT OF READ ONLY AREA

	ORG	20000		:RONLY AREA
ST6CNT	WS	1		:STATE 6 & STATE 5 COUNTS
	ORG	2003E		:DISPLACEMENT INTO RONLY AREA FOR FSLEEP
FSLEEP	HS	1
	EI	:CNINDX

	IF	MUDII
	ORG	2004C		:SUPERVISOR VERSION NUMBER
SVER	HS	1		:SVER=REVISN+VERSN*$A10+SUPMIC*$A1000
				:+DEBMON*$A10000
	EI	:MUDII

	IF	UN2UP1
	ORG	10068
BDMBLK	EQ	.		:BLOCK # CONTAINING BAD MUD ENTRY
	EI	:UN2UP1

	IF	ISIS
	:FOR ISIS DEFINE CTA TABLE VALUES
	GL	CTA,CTASIZ
CTA	SEG	0E		:DEFINE ISIS CTA TABLE
CNTRL	WC	6^18		:IDENTIFY AS UN2 SLOT
CTASZ	WC	CTASIZ		:SIZE OF CTA TABLE
AREAS	WC	UN2A0^8		:ISIS CORE ALLOCATION FOR UN2
	WS	0E-(UN2A0+0FF)^-8 :PAD TO SEG E
	BS	4A		:RESERVED 4A BYTES
SVERNO	BC	UN2VR		:UN2 VERSION @0E008A
SREVLE	BC	UN2RV		:UN2 REVISION @0E008B
	BS	0A		:10 BYTES RESERVED
PID	HC	UN2PID		:UN2 PID @0E0096
CTASIZ	EQ	.-CTA
	EI

BUN2	EQ	0		:VIRTUAL START ADDRESS FOR CODE SEGMENT



:REGISTER LABLES
R0	EQ	0
R1	EQ	1
R2	EQ	2
R3	EQ	3
R4	EQ	4
R5	EQ	5
R6	EQ	6
R7	EQ	7
R8	EQ	8
R9	EQ	9
R10	EQ	0A
R11	EQ	0B
R12	EQ	0C
R13	EQ	0D
R14	EQ	0E
R15	EQ	0F

SLOWC	EQ	0F0008


	:ASSEMBLE IN TIME AND VERSION
        IF      1-ISIS
        ORG     0               :LOCATION OF MERLIN KEYCODE
        WC      $0 00000103    
        EI      :1-ISIS
	ORG	BUN2+4
	WC	ASTIME,VERSN

	IF	DDTTRP&(1-ISIS)
	ORG	10
TRCPSW	WS	2		:UPSW TRACE INTERRUPT OLD PSW-PC
TRCADD	WC	TRPRST		:ADDRESS OF TRAP RESET ROUTINE
TRCTMP	WS	1		:TEMP STORAGE FOR UPSW TRACE INT HANDLING
				:NOW MUDUPDATE STARTS AT 20
	ELSE	:DDTTRP&(1-ISIS)
	:CODE EXECUTION STARTS AT STANDARD OFFSET OF 10
	ORG	BUN2+10
	EI	:DDTTRP&(1-ISIS)

START	LIS	R6,0		:INIT ACCUMULATOR REGISTER FOR HANDSHAKE
	STH	R0,HSTPTR	:INIT HISTORY BUF PTR
	SVC	GUP,4		:WAIT 4 SECONDS FOR 940 TO GET READY
	SVC	OUTSVC,HAND	:SEND HAND SHAKE

:  SEND SUPERVISOR VERSION NUMBER TO THE MASTER. IF SUPERVISOR VERSION
:  IS 42.1, FORM IT TO DECIMAL 421, CONVERT IT TO HEX - YIELDS 1A5
:  SEND 00 00 01 A5 TO MASTER AS THE VERSION NUMBER.
	IF	MUDII
	LHL	R0,SVER,,	:GET SUP VERSION FROM READ ONLY AREA
	SHI	R0,SUPMIC*$A1000+DEBMON*$A10000	: VERSN*$A10+REVISN
	ST	R0,OUT+4	:STORE IN THE BUFFER USED FOR CKSUM
	LIS	R0,4		:SENDING 4 CHARACTERS TO MASTER
	STB	R0,OUT+3	:PRECEDE ABOVE CHARS. BY SIZE
	SVC	OUTSVC,OUT+3	:SEND TO MASTER

:  SEND A FULLWORD OF OPTIONS TO MASTER. NO OPTIONS AT PRESENT (3/26/87)
:  SEND 00 00 00 00 FOR NOW.
	LIS	R0,0
	ST	R0,OUT+4	:STORE IN BUFFER, SIZE ALREADY IN OUT+3
	SVC	OUTSVC,OUT+3	:SEND TO MASTER
	EI	:MUDII

	IF	1-ISIS
	SVC	GENERAL,4	:SET EIGHT LEVEL MODE
	EI


	:SETUP DISK PARAMETER BLOCKS
	IF	MSC
	LI	R0,MUDLU^10	:SAVE IN MSC PARAM BLOCK
	ST	R0,DCB		:STORE LOCAL UNIT 0/NO ERROR IN MSC PARM BLK
	LHI	R4,BLKSIZ	:NUMBER OF BYTES TO TRANSFER
	ST	R4,DCBCNT	:STORE IN MSC PARM BLK
	LA	R4,BUF		:MEMORY ADDR OF DISK BUFFER
	ST	R4,DCBVMA	:STORE IN MSC PARM BLK
	ELSE
	LIS	R4,MUDSEC	:NUMBER OF BLOCKS OR SECTORS TO READ
	STH	R4,DCB+2	:SETUP TO TRANSFER 2 BLOCKS
	LA	R4,BUF		:MEMORY ADDR OF DISK BUFFER
	ST	R4,DCB+8	:COMPLETE BASIC SET UP OF DISK CONTROL BLOCK
	EI

	LIS	R0,0		:INSURE R0 IS ZERO??


	:LOOK FOR HANDSHAKE.
	:CHARACTERS WHICH ARRIVE BEFORE HANDSHAKE ARE IGNORED.
UN21	JAL	R12,GC		:READ A CHAR INTO R0
	SLLS	R6,8		:ACCUMULATE 4 CHARS IN R6
	OR	R6,R0		:ADD IN LAST CHAR
	CLI	R6,01020304	:HAS HAND SHAKE ARRIVED
	JNBS	UN21		:NO - KEEP LOOKING


	:GOT HANDSHAKE, DISPATCH ON COMMAND BYTE
	:TO REQUESTED SLAVE PROCESS.
	:NOTE - PROCESSES ARE SELF-CONTAINED FINAL
	:PROCESSES.  ONLY ONE PROCESS CAN BE ACTIVATED BY
	:A SINGLE SESSION.
	:1--> RUN CONSISTENCY
	:2--> UPDATE BLOCKS
	:3--> SEND BLOCKS
	:4--> SET START BLOCK & RUN CONSISTENCY
	:ALL OTHER COMMAND BYTES CAUSE SLAVE TO ZAP CIRCUIT
	JAL	R12,GC		:GET NEXT CHAR
	SIS	R0,1		:IS IT A ONE
	JE	CONSIS		:YES - THIS IS CONSISTANCY CHECK
	SIS	R0,1		:IS IT A TWO
	JE	UPDATE		:YES - THIS IS AN UPDATE
	SIS	R0,1		:IS IT A THREE
	JE	SENDBL		:YES - THIS IS REQUEST TO SEND A BLOCK
	SIS	R0,1
	JE	SETCON		:SET CONSISTENCY
	JAL	R10,FAIL	:INVALID REQUEST - ZAP & SHOW WHY




:**********************************************************
:
:  CONSISTENCY
:
:**********************************************************
SETCON	JAL	R11,G2C		:GET START BLOCK NUMBER
	IF	UN2UP1
	STH	R1,BLKNUM	:SAVE FOR ENTRY CHECK
	EI	:UN2UP1
	IF	MUDSFT
	SLLS	R1,MUDSFT	:CONVERT TO DISK OFFSET
	EI
	LR	R3,R1		:SET AS START DISK OFFSET
	JFS	C0		:CONTINUE


CONSIS	LIS	R3,MUDSTA	:START AT ZERO OFFSET
	IF	UN2UP1
	STH	R3,BLKNUM	:SAVE FOR ENTRY CHECK
	EI	:UN2UP1
C0	SVC	OUTSVC,ONE	:TELL MASTER SLAVE READY
	LIS	R2,0		:FLAG TO SHOW THIS IS DISK READ REQUEST

	:READ NEXT BLOCK FROM DISK
	IF	MSC
C1	ST	R3,DCBPOS	:READ FROM THIS DISK ADDR
	ELSE
C1	STH	R3,DCB+6	:READ FROM THIS DISK ADDR
	EI
	JAL	R11,DISKOP	:PERFORM DISK READ, READ THE BLOCK

	IF	MUDII
	:CHECKSUM THE BLOCK
	LIS	R6,0		:INITIALIZE CHECKSUM REGISTERS
	LIS	R7,0		:
	LI	R0,4-BLKSIZ	:-VE BYTE COUNT FOR CHECKSUM
	LA	R5,BUF		:BASE ADDRESS FOR CHECKSUM
	CKSUM	R6,R5		:CALCULATE CHECKSUM (VERT/R6 DIAG/R7)
	:TELL MASTER CHECKSUM
	LIS	R1,4		:SEND THIS MANY BYTES
	STB	R1,OUT+3	:POSITION FOR SVC
	EXHR	R6,R6		:PUT VERTICAL CHECKSUM IN HIGH HW
	OR	R6,R7		:INCLUDE DIAGONAL CHECKSUM IN LOW HW
	ST	R6,OUT+4	:PUT CHECKSUM IN OUT+4 - 00000004CKCKCKCK
	SVC	OUTSVC,OUT+3	:SEND 4-BYTES OF VERT-DIAG CHECKSUM TO MASTER

	ELSE	:MUDII

	:CHECKSUM THE BLOCK
	LIS	R5,0		:INIT INDEX TO BUF
	LIS	R6,0		:ACCUMULATE CHECKSUM IN THIS REG
	LHI	R1,BLKSIZ-4	:CHECKSUM LIMIT
C2	LB	R0,BUF,R5	:NEXT BYTE IN BUF
	CKSM(R6,R0,R7)
	AIS	R5,1		:INCR INDEX INTO BUF
	CLR	R5,R1		:IS BUFFER CHECKSUMMED?
	JLBS	C2

	:TELL MASTER CHECKSUM
	ST	R6,OUT		:SETUP TO SEND CHECKSUM TO MASTER
	LIS	R1,3		:SEND THIS MANY BYTES
	STB	R1,OUT
	SVC	OUTSVC,OUT	:SEND CHECKSUM, 03 CK CK CK
	EI	:MUDII

	:PROCESS MASTER'S RESPONSE. 01 = CKSUM MATCH, 02 = CKSUM MATCH FAIL
	JAL	R12,GC		:READ A CHAR
	SIS	R0,1		:IS IT A ONE
	JN	C5

		:CHECKSUM OK, GO TO NEXT MUD BLOCK
	IF	UN2UP1
C4	LHL	R1,BLKNUM	:GET VB#
	AIS	R1,1		:INCREMENT
	STH	R1,BLKNUM	:STORE IT
	ELSE
C4	HS	0
	EI	:UN2UP1

	AHI	R3,MUDSEC	:INCREMENT BY # OF SECTORS/BLOCK
	CLI	R3,CONLIM	:ARE WE DONE WITH MUD FILE FOR CONSISTENCY?
	JLE	C1		:NO - LOOP
	SVC	GUP,0A		:WAIT 10 SECONDS
	JAL	R10,FAIL	:TERMINATE

C5	SIS	R0,1		:IS IT TWO
	JEFS	C6		:YES - CHECKSUM FAILED
	JAL	R10,FAIL	:INVALID RESPONSE - TERMINATE & SHOW WHY

		:BAD CHECKSUM, A REPLACEMENT BLOCK FROM MASTER FOLLOWS
C6	LIS	R1,0
	JAL	R11,G2C		:GET 2 CHAR FOR DATA WORD COUNT
	LR	R8,R1		:SAVE
	SLLS	R8,2		:CHARACTER COUNT
	CLHI	R8,BLKSIZ-4	:CHECK LIMIT
	JLEFS	C7		:OK
	JAL	R10,FAIL	:INVALID SIZE -TERMINATE & SHOW WHY

	IF	MUDII
C7	LIS	R5,0		:START FROM BEGINNING OF BUFFER
	ELSE	:MUDII
C7	LIS	R6,0		:INIT CHECKSUM FOR DATA TO BE RECEIVED
	LIS	R5,0		:INIT INDEX INTO BUF
	EI	:MUDII

	LR	R8,R8		:WAS CUD BLOCK ZEROED BY MASTER?
	JE	C9		:YES, ZERO THE MUD BLOCK

	IF	MUDII
C8	JAL	R11,G4C		:GET 4 CHARACTERS (1 WORD) OF DATA FROM MASTER
	ST	R1,BUF,R5	:STORE IT IN BUFFER
	AIS	R5,4		:BUMP INDEX
	CR	R5,R8		:DONE ?
	JLBS	C8		:NOT YET, LOOP.

	ELSE	:MUDII

		:GET, CHECKSUM & SAVE DATA PORTION OF BLOCK
		:ONE WORD AT A TIME
C8	JAL	R12,GC		:GET 1ST BYTE OF WORD
	EXBR	R4,R0		:POSITION THE BYTE
	CKSM(R6,R0,R7)
	JAL	R12,GC		:GET 2ND BYTE OF WORD
	STBR	R0,R4		:ASSEMBLE INTO WORD
	EXHR	R4,R4		:POSITION 1/2 WORD
	CKSM(R6,R0,R7)
	JAL	R12,GC		:GET 3RD BYTE
	EXBR	R4,R0		:POSITION IN WORD
	CKSM(R6,R0,R7)
	JAL	R12,GC		:GET 4TH BYTE OF WORD
	STBR	R0,R4		:ASSEMBLE LAST BYTE
	CKSM(R6,R0,R7)
	ST	R4,BUF,R5	:SAVE THE WORD OF DATA
	AIS	R5,4		:INDEX NEXT DATA WORD
	CR	R5,R8		:DONE WITH DATA?
	JL	C8		:NO - LOOP
	EI	:MUDII

		:DONE WITH DATA PORTION OF BLOCK,
		:ZERO FILL IF NECESSARY.
	CLHI	R8,BLKSIZ-4	:WAS IT A FULL BLOCK?
	JE	CB		:YES - NOTHING TO DO
C9	LIS	R12,0		:ZERO IN 4 WORD GROUPS
	LIS	R13,0
	LIS	R14,0
	LIS	R15,0
	LHI	R1,BLKSIZ-4
	LHI	R4,10		:CONSTANT FOR INDEX BUMP
CA	STM	R12,BUF,R5	:STORE ZEROS
	AR	R5,R4		:BUMP INDEX
	CLR	R5,R1		:DONE?
	JLBS	CA		:NO

	IF	MUDII
	ELSE	:MUDII
		:ROTATE CHECKSUM TO PROPER POSITION
	NI	R6,0FFFFFF	:DROP POSSIBLE GARBAGE BYTE FROM CHECKSUM
	LHI	R5,BLKSIZ-4	:NUMBER OF BYTES IN BLOCK BEING CHECKSUMED
	SR	R5,R8		:NUMBER OF ZERO FILL BYTES TO FAKE IT
	LR	R4,R5
	SLLS	R4,3		:8*# OF ZERO FILL BYTES
	SR	R4,R5		:NUMBER OF BITS TO ROTATE
	LHI	R5,18		:GET MOD 24D
	DHR	R4,R5		:REMAINDER IS # TO ROTATE CHECKSUM
	LR	R5,R6		:CURRENT CHECKSUM
	SLL	R6,,R4		:POSITION UPPER PORTION
	XHI	R4,-1
	AHI	R4,19		:<R4> <-- 18 - <R4>
	SRL	R5,,R4		:POSITION RIGHT BITS
	OR	R6,R5		:ROTATE RESULT, LEFT BYTE IS GARBAGE
	EI	:MUDII

	IF	MUDII
	:GET AND COMPARE CHECKSUMS
CB	LIS	R6,0		:INIT CHECKSUM VARIABLES
	LIS	R7,0		:
	LI	R0,4-BLKSIZ	:GET NUMBER OF BYTES IN BLOCK
	LA	R5,BUF		:GET BASE ADDRESS FOR BLOCK
	CKSUM	R6,R5		:CALCULATE CHECKSUMS (VERT/R6 DIAG/R7)
	EXHR	R6,R6		:PUT VERTICAL CHECKSUM IN HIGH HW
	OR	R6,R7		:INCLUDE DIAGONAL CHECKSUM IN LOW HW
	JAL	R11,G4C		:GET 4-BYTES OF CHECKSUM FROM MASTER
	CR	R6,R1		:DO THE CHECKSUMS MATCH ?
	JN	CC		:IF NOT, JUMP

	ELSE	:MUDII

	:GET & COMPARE CHECKSUMS
CB	JAL	R11,G3C		:READ 3 CHARS INTO R1
	XR	R6,R1		:COMPARE CHECKSUM RECEIVED WITH THAT COMPUTED
	NI	R6,0FFFFFF	:DOES IT MATCH
	JN	CC		:NO
	EI	:MUDII

	IF	UN2UP1
	JAL	R11,CHKENT	:GO CHECK MUD ENTRIES FOR PROPER DISPLACEMENT
	EI	:UN2UP1. IF MUD ERROR, SKIP RETURN BY +6.
	LIS	R2,1		:FLAG TO CAUSE DISK WRITE
	JAL	R11,DISKOP	:WRITE NEW VALUES TO MUD
	SVC	OUTSVC,ONE	:SEND ONE TO SHOW MATCH
	LIS	R2,0		:RESET FLAG TO DISK READ
	J	C4		:LOOK AT NEXT MUD BLOCK

	:CHECKSUMS DON'T MATCH, LOOP AGAIN
CC	SVC	OUTSVC,THREE	:SEND 3 TO SHOW BAD CHECKSUM
	J	C6		:READ THE BLOCK AGAIN


	IF	DDTTRP&(1-ISIS)
:**********************************************************************
:
:	TRAP RESET FOR SPLIT KERNEL DDT TRAP RE-OCCURENCE,
:	TRIGGERED OFF OF THE UPSW TRACE INTERRUPT.
:
SV.RST	EQ	2		:TRAP RESET SVC 9,2
PSWTBT	EQ	$0 13		:POSITION OF UPSW TRACE BIT

TRPRST	ST	0F,TRCTMP	:SAVE 0F
	LHI	0F,PSWTBT	:UPSW TRACE BIT
	RBT	0F,TRCPSW	:RESET UPSW TRACE BIT IN USER PSW
	L	0F,TRCTMP	:AND RECOVER 0F
	SVC	9,SV.RST	:REQUEST TRAP RESET FOR ANY MUDUPDATE TRAPS
	UPSW	TRCPSW		:RETURN TO USER
	EI	:DDTTRP&(1-ISIS)



:***********************************************************
:
:	UPDATE ROUTINE
:
:**********************************************************
UPDATE	SVC	OUTSVC,ONE	:SEND ONE TO TELL MASTER SLAVE READY
	JAL	R12,GC		:READ A CHAR
	SIS	R0,1		:IS IT ONE
	JEFS	U1		:YES
	JAL	R10,FAIL	:INVALID REQUEST - TERIMATE & SHOW WHY

	IF	MUDII
U1	HS	0
	ELSE	:MUDII
U1	LIS	R6,0		:INIT CHECKSUM
	EI	:MUDII

	LIS	R1,0
	JAL	R11,G2C		:READ TWO CHARS INTO R1
	LR	R4,R1		:VIRTUAL BLOCK #
	IF	UN2UP1
	STH	R4,BLKNUM	:SAVE IT IN CASE IT HAS A BAD ENTRY
	EI	:UN2UP1

:  NEXT HALFWORD FROM MASTER SPECIFIES THE WORD OFFSET (FIRST WORD OF
:  UPDATE) FOR THE OLD MUD, WHEREAS IT SPECIFIES THE BYTE OFFSET (FIRST
:  BYTE OF UPDATE) FOR THE NEW MUD.
	JAL	R11,G2C		:BYTE/WORD OFFSET FOR NEW/OLD MUD
	LR	R5,R1		:SAVE BYTE/WORD POSITION OF UPDATE

:  NEXT HALFWORD FROM MASTER SPECIFIES THE # OF WORDS TO CHANGE FOR
:  THE OLD MUD, WHEREAS IT SPECIFIES THE # OF BYTES TO CHANGE FOR NEW MUD
	JAL	R11,G2C		:# OF BYTES/WORDS TO CHANGE
	LR	R8,R1		:SAVE # OF BYTES/WORDS TO CHANGE

	LIS	R2,0		:FLAG TO CAUSE DISK READ
	IF	MUDSFT
	SLLS	R4,MUDSFT	:GENERATE SECTOR ADDRESS
	EI
	IF	MSC
	ST	R4,DCBPOS	:STORE IN MSC PARM BLK
	ELSE
	STH	R4,DCB+6	:PLACE IN DISK CONTROL BLOCK
	EI
	JAL	R11,DISKOP	:PERFORM DISK READ

	IF	MUDII		:CONVERT TO BYTES FOR OLD MUD
	ELSE	:MUDII
	SLLS	R5,2		:BYTE POSITION FOR START OF UPDATE
	SLLS	R8,2		:# OF BYTES IN UPDATE
	EI	:MUDII

	IF	MUDII
	JAL	R11,G4C		:READ GMT FROM COMMAND STRING INTO R1
	ST	R1,BUF+4	:WRITE GMT INTO SECOND WORD OF BLOCK

	LR	R6,R5		:SAVE BYTE OFFSET INTO BLOCK FOR UPDATE
	LR	R7,R8		:SAVE NUMBER OF BYTES IN UPDATE
U2	JAL	R12,GC		:READ NEXT CHARACTER
	STB	R0,BUF,R5	:PLACE IN DISK BUFFER
	AIS	R5,1		:BUMP BUFFER INDEX
	SIS	R8,1		:DECREMENT # BYTES TO TRANSFER
	JGBS	U2		:IF NOT DONE, LOOP

	LA	R5,BUF,R6	:GET BASE ADDRESS FOR CHECKSUM
	LIS	R0,0
	SR	R0,R7		:GET -VE COUNT OF BYTES FOR CHECKSUM
	LIS	R6,0		:INIT CHECKSUM VARIABLES
	LIS	R7,0		:
	CKSUM	R6,R5		:VERTICAL/DIAGNONAL CHECKSUM THE UPDATED DATA
	EXHR	R6,R6		:POSITION VERTICAL CHECKSUM IN HIGH HW
	OR	R6,R7		:INCLUDE DIAGONAL CHECKSUM IN LOW HW
	JAL	R11,G4C		:READ 4-BYTES OF CHECKSUM INTO R1
	CR	R6,R1		:DO THE CHECKSUMS MATCH ?
	JNFS	U3		:NO, TELL MASTER
	ELSE	:MUDII

U2	JAL	R12,GC		:READ NEXT CHAR
	CKSM(R6,R0,R7)
	STB	R0,BUF,R5	:PLACE IN DISK BUF
	AIS	R5,1		:INCR BUF INDEX
	SIS	R8,1		:DECR # OF BYTES TO BE TRANSFERED
	JGBS	U2		:LOOP
	JAL	R11,G3C		:READ THREE CHARS OF CHECKSUM INTO R1
	XR	R1,R6		:ARE THEY THE SAME AS COMPUTED CHECK	NI	R1,0FFFFFF
	JNFS	U3		:NO
	EI	:MUDII

	IF	UN2UP1
	JAL	R11,CHKENT	:CHECK MUD ENTRY FOR DISPLACEMENT
	EI	:UN2UP1

	LIS	R2,1		:FLAG TO CAUSE DISK WRITE
	JAL	R11,DISKOP	:WRITE MODIFIED BUFFER TO DISK
	J	UPDATE		:PROCESS NEXT UPDATE

	:CHECKSUM FAILED...TELL MASTER
U3	SVC	OUTSVC,TWO	:SEND TWO TO SHOW BAD CHECKSUM
	J	U1		:PREPARE TO RECEIVE UPDATE AGAIN



:**********************************************************
:
:	SEND MUD BLOCK TO MASTER
:
:**********************************************************
SENDBL	SVC	OUTSVC,ONE	:TELL MASTER SLAVE IS READY
S1	JAL	R12,GC		:READ NEXT CHAR
	SIS	R0,1		:IS IT A ONE
	JEFS	S2
	JAL	R10,FAIL	:INVALID REQUEST - TERMINATE & SHOW WHY
S2	LIS	R1,0
	JAL	R11,G2C		:READ TWO CHARS INTO R1
	IF	MUDSFT
	SLLS	R1,MUDSFT	:VIRTUAL DISK ADDRESS
	EI
	IF	MSC
	ST	R1,DCBPOS	:STORE IN MSC PARM BLK
	ELSE
	STH	R1,DCB+6	:DISK ADDR TO READ
	EI
	LIS	R2,0		:FLAG TO CAUSE DISK READ
	JAL	R11,DISKOP	:PERFORM DISK READ
	IF	101-BLKSIZ	:1 SECTOR BLOCK
	LHI	R3,BLKSIZ-4	:NUMBER OF BYTES TO SEND
	ELSE
	LHI	R3,0FF		:TRANSFER THIS MANY BYTES AT A TIME
S3	STB	R3,BUF-1,R2	:PLACE COUNT BEFORE DATA FOR SVC
	SVC	OUTSVC,BUF-1,R2	:SEND DATA
	AR	R2,R3		:INCR INDEX INTO BUF
	CLHI	R2,BLKSIZ-4-0FF	:HAVE WE SENT MAX MULTIPLES OF 0FF
	JLBS	S3		:NO - LOOP
	LHI	R3,BLKSIZ-4	:TOTAL REQUIRED BYTES
	SR	R3,R2		:LESS NUMBER SENT
	EI
	STB	R3,BUF-1,R2	:SEND REMAINING REQUIRED
	SVC	OUTSVC,BUF-1,R2
	J	S1		:SET UP TO READ ANOTHER REQUEST


:**********************************************************
:
:	UTILITY ROUTINES
:
:**********************************************************


:  READ OR WRITE THE DISK
	IF	MSC
DISKOP	STB	R2,DCBRS	:R2=0 IS DISK READ, R2=1 IS DISK WRITE
	SVC	SHARE,DCB	:PERFORM DISK OPERATION
	LB	R1,DCBRS	:WAS DISK OPERATION SUCCESSFULL
	JEFS	DISKTS		:CHECK FOR TELLING SUPERVISOR
	STB	R2,DCBRS	:TRY ONE MORE TIME
	SVC	SHARE,DCB
	LB	R1,DCBRS	:WAS IT SUCCESSFULL THIS TIME
	JEFS	DISKTS		:CHECK FOR TELLING SUPERVISOR
	SVC	OUTSVC,FOUR	:NO - TELL MASTER
	SVC	GUP,10		:WAIT A WHILE FOR A ZAPPER FROM MASTER
	JAL	R10,FAIL	:NO ZAPPER FROM MASTER - ZAP BY SLAVE
	ELSE
DISKOP	STH	R2,DCB		:R2=0 IS DISK READ, R2=1 IS DISK WRITE
	SVC	DSK,DCB		:PERFORM DISK OPERATION
	LH	R1,DCB		:WAS DISK OPERATION SUCCESSFULL
	JEFS	DISKTS		:CHECK FOR TELLING SUPERVISOR
	STH	R2,DCB		:TRY ONE MORE TIME
	SVC	DSK,DCB
	LH	R1,DCB		:WAS IT SUCCESSFULL THIS TIME
	JEFS	DISKTS		:CHECK FOR TELLING SUPERVISOR
	SVC	OUTSVC,FOUR	:NO - TELL MASTER
	SVC	GUP,10		:WAIT A WHILE FOR A ZAPPER FROM MASTER
	JAL	R10,FAIL	:NO ZAPPER FROM MASTER - ZAP BY SLAVE
	EI

	:IF SUPERVISOR IS AWAKE, TELL SUP ABOUT BLOCK UPDATE
	:AND WAIT FOR ACKNOWLEDGEMENT (-1).
DISKTS	HS	0
	IF	CNINDX		:CODE ONLY IF CACHE IN USE
	LR	R2,R2		:WAS THIS A WRITE?
	JER	R11		:NO, NO INTERLOCK REQUIRED
	LH	R0,FSLEEP,,	:IS SUPERVISOR SLEEPING?
	JLR	R11		:YES, NO INTERLOCK REQUIRED
	IF	1-ISIS		:CHECK IF FROZEN
	SVC	GENERAL,7
	NHI	0,1900		:FROZEN?
	JNR	R11		:YES, NO INTERLOCK REQUIRED
	ELSE
	SVC	ISYS,$A22	:FROZEN?
	SVC	ISYS,$A23	:NOT FROZEN - ON RUN Q?
	JER	R11		:FROZEN OR ON RUN Q, NO INTERLOCK REQUIRED
	HC	0		:PAD FOR SKIP RETURN
	EI
	LHL	R0,ST6CNT,,	:ARE ANY T-II NODES TAKEN?
	JER	R11		:NO, THIS GUY IS INITIALIZING/WAKING UP
	:SUPERVISOR IS AWAKE AND NORMAL.  TELL SUP ABOUT MUD BLOCK UPDATE
	:AND WAIT FOR ACKNOWLEDGEMENT.
	IF	MSC
	L	R0,DCBPOS	:LOAD DISK ADDRESS FROM MSC PARM BLK
	ELSE
	LHL	R0,DCB+6	:THIS IS DISK ADDRESS
	EI
	IF	MUDSFT
	SRLS	R0,MUDSFT	:THIS IS MUD BLOCK NUMBER
	EI
	ST	R0,MUDUP,,	:TELL SUPERVISOR
DISKT1	SVC	GUP		:GIVEUP TIME SLICE
	LH	R0,MUDUP,,	:HAS SUP PROCESSED DATA?
	JGEBS	DISKT1		:NO
	EI
	JR	R11		:RETURN TO CALLER


:  TERMINATE & SHOW WHY
FAIL	STM	R0,RSAVE	:SAVE REGS
	SVC	GENERAL,0	:SEND ZAPPER & LOG OUT

	IF	MUDII
:READ FOUR, THREE, OR TWO CHARACTERS FROM CIRCUIT & PLACE IN R1
G4C	LIS	R1,0		:CLEAR R1
	JAL	R12,GC		:GET A CHARACTER FROM MASTER
	EXBR	R1,R0		:PUT INTO 3RD BYTE
	JFS	G3CA		:
G3C	LIS	R1,0		:CLEAR R1 (3RD BYTE IN PARTICULAR)
G3CA	JAL	R12,GC		:GET A CHARACTER FROM MASTER
	OR	R1,R0		:PUT INTO 4TH BYTE OF R1
	EXHR	R1,R1		:MAKE BYTES 3,4 BECOME BYTES 1,2

	ELSE	:MUDII

:  READ TWO OR THREE CHARS FROM CIRCUIT & PLACE IN R1
G3C	JAL	R12,GC		:READ ONE CHAR
	EXHR	R1,R0		:POSITION CHAR
	EI	:MUDII

G2C	JAL	R12,GC		:READ ONE CHAR
	EXBR	R1,R0		:POSITION CHAR
	JAL	R12,GC		:READ ONE CHAR
	OR	R1,R0		:ADD TO R1
	JR	R11		:RETURN


:  READ ONE CHAR FROM THE CIRCUIT - PLACE IN R0
GC	SVC	IN,$A60		:READ CHAR INTO R0, TIMEOUT AFTER 4 MINUTES
	JAL	R10,FAIL	:TIMEOUT - TERMINATE & SHOW WHY
	IF	1-ISIS
	CLHI	R0,8		:IS IT A NETWORK CHAR
	JGE	GC2		:NO
	LR	R0,R0		:IS IT AN ESCAPE
	JNFS	GC0		:NO
	SVC	IN,0		:SECOND HALF OF PAIR MUST BE THERE
	JAL	R10,FAIL	:CRASH IF NOT
	J	GC2
GC0	SIS	R0,1		:WAS NETWORK CHAR 1
	JNFS	GC1		:NO
	SVC	IN,0		:SECOND HALF OF PAIR MUST BE THERE
	JAL	R10,FAIL	:CRASH IF NOT
	CLHI	R0,0FF		:IS IT A YELLOW BALL
	JN	GC		:NO GET NEXT CHAR
	SVC	TRSOUT,ORANGE	:SEND AN ORANGE BALL
	J	GC		:GET NEXT CHAR
GC1	SIS	R0,2		:WAS NETWORK CHAR A ZAPPER
	JN	GC		:NO - LOOK AT NEXT CHAR
	JAL	R10,FAIL	:LOGOUT
	EI
GC2	LHL	R13,HSTPTR	:KEEP A HISTORY OF CHARS RECEIVED
	STB	R0,HSTBUF,R13
	AIS	R13,1
	NHI	R13,3F
	STH	R13,HSTPTR
	JR	R12		:RETURN


	IF	UN2UP1
:	CHECK MUD ENTRIES FOR PROPER DISPLACEMENT. SKIP RETURN IF
:	ERROR FOUND (NO DISK WRITE DONE). OTHERWISE NON SKIP RETURN.
:	MASTER STILL GETS A "1" IN EITHER CASE. IF ERROR FOUND, THE
:	BLOCK NUMBER IS PUT IN SUPS R/W AREA TO BE LOGGED FOR PROBE

	IF	MUDII

CHKENT	LA	R7,BUF		:START OF DISK BUFFER
	LR	R5,R7
	AHI	R5,BLKSIZ-4	:END OF DISK BUFFER
	LHL	R1,MBHFLG,R7	:GET MUD BLOCK FLAGS
	CLHI	R1,0C000	:BOTH 'BLOCK OVERFLOWED' & 'OVERFLOW BLOCK'
	JE	CHKEN2		:YES, FORMAT ERROR.		BITS SET?
	AIS	R7,MBHSIZ	:POINT TO THE FIRST ENTRY
	L	R1,,R7		:GET FIRST WORD OF MUD BLOCK
	JER	R11		:ASSUME REST OF THE BLOCK IS EMPTY, WRITE IT.
CHKEN0	LB	R1,ENTTYP,R7	:GET ENTRY TYPE OF THIS ENTRY
	JEFS	CHKEN1		:TYPE 0 ENTRY
	SIS	R1,1		:IS IT TYPE 1 ?
	JEFS	CHKEN1		:YES, TYPE 1 ENTRY
	JFS	CHKEN2		:ILLEGAL TYPE, FORMAT ERROR
CHKEN1	LHL	R1,ENTSIZ,R7	:GET ENTRY SIZE IN BYTES
	JLER	R11		:NO MORE ENTRIES, EVERYTHING O.K., WRITE IT.
	CLHI	R1,MINESZ	:ENTRY SHOULD BE ATLEAST THIS LONG
	JLFS	CHKEN2		:BAD ENTRY SIZE, FORMAT ERROR
	AR	R7,R1		:POINT TO NEXT ENTRY
	CLR	R7,R5		:PAST END OF BUFFER ?
	JGFS	CHKEN2		:ENTRY OVERHANGS THE MUD BLOCK, FORMAT ERROR
:	AHI	R7,MINESZ	:MINIMUM BYTES REQUIRED FOR AN ENTRY
:	CLR	R7,R5		:PAST END OF BUFFER ?
:	JGR	R11		:YES, NOT ENOUGH ROOM FOR ANOTHER ENTRY
:	SHI	R7,MINESZ	:RESTORE R7
	JBS	CHKEN0		:CHECK NEXT ENTRY
CHKEN2	LHL	R1,BLKNUM	:GET VIRTUAL BLOCK #
	STH	R1,BDMBLK,,	:LET SUP KNOW ABOUT IT
	J	6,R11		:SKIP RETURN, DO NOT WRITE THE BLOCK

	ELSE	:MUDII

CHKENT	LI	R2,0FE000000	:CONSTANT FOR TEST
	LCS	R5,1
	XR	R5,R2		:R5=01FFFFFF
	IF	CNINDX
	SIS	R5,1		:R5=01FFFFFE
	EI	:CNINDX
	LA	R7,BUF		:START ADDRESS OF DISK BUFFER
	LIS	R4,0		:INITIALIZE NUMBER OF BYTES SCANNED
CHKNTA	L	R1,,R7		:GET 1ST WORD OF MUD ENTRY
	JE	CHKNTD		:O.K. - ASSUME REST OF BLOCK IS ZERO
	THI	R1,,R2		:INSUR DISPLACEMENT NON ZERO
	JNFS	CHKNTB		:IF NOT, THEN CONTINUE WITH CHECK
	J	CHKERR		:ENTRY ERROR, REPORT TO LOG
CHKNTB	THI	R1,,R5		:NEXT TEST
	JEFS	CHKNTC		:DISPLACEMENT O.K., CHECK FOR MORE ENTRIES
	CLHI	R1,-1		:IS ENTRY AT END OF BUFFER?
	JE	CHKNTD		:YES, THIS BLOCK IS O.K. TO WRITE
	J	CHKERR		:ERROR, REPORT TO SUP
CHKNTC	EXHR	R1,R1		:GET ENTRY SIZE IN RH OF R1
	SRLS	R1,8		:POSITION IT
	AR	R4,R1		:ADD ENT SIZE TO BYTES ALREADY SCANNED
	CLHI	R4,BLKSIZ-4	:BLOCK SIZE TOO BIG?
	JG	CHKERR		:YES, REPORT IT
	AR	R7,R1		:POINT TO NEXT ENTRY
	J	CHKNTA		:GO LOOK AT THE NEXT ENTRY
CHKNTD	JR	R11		:NON SKIP RETURN - EVERYTHING O.K.

CHKERR	LHL	R4,BLKNUM	:GET VB #
	STH	R4,BDMBLK,,	:STORE IT FOR SUP TO LOG
	J	6,R11		:SKIP RET - DON'T WRITE TO DISK

	EI	:MUDII
	EI	:UN2UP1



:********************************************************
:

:	CONSTANTS
:
:**********************************************************

HAND	XC	0401020304	:HAND SHAKE STRING
ONE	XC	0101		:USED TO SEND A 01
TWO	XC	0102		:USED TO SEND A 02
THREE	XC	0103		:USED TO SEND A 03
FOUR	XC	0104		:USED TO SEND A 04
ORANGE	XC	0201FE		:ORANGE BALL

EUN2CD	EQ	.		:SIZE OF CODE AREA



:**********************************************************
:
:	DATA AREA
:
:**********************************************************

	IF	MSC
DCB	WS	0		:CONTROL BLOCK FOR MSC DISK
DCBRS	BS	1		:REQUEST/STATUS BYTE
DCBLU	BS	1		:LOCAL UNIT NUMBER
DCBSTA	BS	2		:DEVICE STATUS FIELD
DCBVMA	WS	1		:VIRTUAL MEMORY ADDRESS
DCBCNT	WS	1		:BYTE COUNT TO TRANSFER
DCBPOS	WS	1		:DISK SECTOR ADDRESS
	ELSE
DCB	WS	3		:DISK CONTROL BLOCK
	EI

	IF	MUDII
OUT	WS	2		:AREA USED TO SEND CHECKSUM
	ELSE	:MUDII
OUT	WS	1		:AREA USED TO SEND CHECKSUM
	EI	:MUDII

RSAVE	WS	10		:REGISTER SAVE AREA FOR TERMINATION
HSTPTR	HS	1		:PTR FOR HISTORY BUF
HSTBUF	BS	40		:HISTORY BUF
	HS	1		:LEAVE ROOM FOR COUNT USED IN SEND BLOCK
BUF	WS	(BLKSIZ/4)+4	:DISK BUFFER + PAD FOR STM, SEE C9


:**********************************************************************:
:                                                                      :
: THIS IS THE PATCH1 AREA IT WILL CONTAIN TWO SEPERATE SECTIONS.  THE  :
: FIRST SECTION CONTAINS A HISTORY OF ALL PATCHES MADE TO BOTH THE UN2 :
: CODE AND THE UN2 DATA AREAS, AND THE SECOND SECTION CONTAINS ACTUAL  :
: PATCHES MADE TO THE UN2 CODE.                                        :
:                                                                      :
:**********************************************************************:



:
:		PHSIZE AND P1SIZE MAY BE DEFINED IN THE TYMFILE IF 
:		DEFAULTS LISTED BELOW ARE NOT LARGE ENOUGH
:


           IF       PATLIB
 
           IF       PHSIZE 0		:IF PHSIZE SET TO A NON-ZERO
					:VALUE IN TYMFILE, ADJUST IT
PHSIZE     EQ       ((PHSIZE+0F)/10)*10 :AND USE IT.

           ELSE			
PHSIZE     EQ       140			:ELSE, SET DEFAULT VALUE.	
           EI				:PHSIZE

           IF       P1SIZE		:IF P1SIZE SET TO A NON-ZERO
					:VALUE IN TYMFILE, USE IT.
           ELSE     
P1SIZE     EQ       400			:ELSE, SET DEFAULT VALUE
           EI				:P1SIZE


:       DEFINE  CODE PATCH AND PATCH HISTORY AREAS


PATHIS     WS       PHSIZE/4		:PATCH HISORY AREA
PATCH1     HS       P1SIZE/2		:PATCH 1 AREA (CODE PATCH AREA)

:       INITIALIZE POINTERS

PAHPTR     EQ       PATHIS		:POINTER TO NEXT OPEN PATCH
                                        :HISTORY AREA
      
PA1PTR     EQ       PATCH1		:POINTER TO NEXT OPEN CODE PATCH
                                        :AREA
PATCH0     EQ       0			:NEEDED BY PATCH MACROS
           EI				:PATLIB
	
        IF	UN2UP1
BLKNUM	HS	1		:STORE BLK NUMBER BEING UPDATED
	EI	:UN2UP1


	IF	1-ISIS
	GL	RUN2,BUN2,DUN2,EUN2,NUN2
	ELSE
	GL	BUN2,DUN2,EUN2,NUN2
	EI

	:***************************************:
	:					:
	:	FINAL	DEFS & REMARKS		:
	:					:
	:***************************************:

BUN2	EQ	BUN2		:PROGRAM STARTS AT VIRTUAL ADRS 0
EUN2CD	EQ	EUN2CD		:SIZE OF CODE AREA DETERMINED ABOVE
EUN2	EQ	(.+0FF)&-100	:THIS MANY BYTES OF DATA INCLUDING ZERO PAD

	:PREDEFINED SAVE PARAMETERS
DUN2	EQ	DUN2		:BLOCK ADDRESS FOR SAVE (LU 4)
NUN2	EQ	NUN2		:SIZE IN BLOCKS



	:INSURE THAT PROGRAM REQUIREMENT IN PAGES
	:IS SUFFICIENT TO ACCEPT A BLOCK LOAD COVERING CODE AREA
EUN2CR	EQ	(EUN2CD+3FF)&-400	:ROUND UP TO BLOCK SIZE

	IF	EUN2CR-EUN2
EUN2	EQ	EUN2CR		:ROUND UP IF LOAD EXCEEDS TOTAL SIZE
	EI


	:DISPLAY DISK LAYOUT
	REMARK %          ***********************
	REMARK %          *UN2 DISK AREA LAYOUTS*
	REMARK %          ***********************
	REMARK %%SLAVE LU FOR MUD IS...........................
	NUMBER MUDLU
	REMARK %NUMBER OF NORMAL BLOCKS (HEX).................
	NUMBER MUDNBK
	REMARK %NUMBER OF OVERFLOW BLOCKS (HEX)...............
	NUMBER MUDOBK
	REMARK %SECTORS PER BLOCK.............................
	NUMBER MUDSEC
	REMARK %TOTAL SECTORS REQUIRED FOR UNIT (HEX).........
	IF	SVLSUP	:NO DISK ON SUP SPROUT SLAVE
	NUMBER 0
	ELSE	:SVLSUP
	NUMBER MUDSIZ
	EI	:SVLSUP



	:DISPLAY CONFIGURATION INFO

	REMARK %%          ***************************
	REMARK %          *MEMORY ALLOCATION PROFILE*
	REMARK %          ***************************

	REMARK %%UN2 CODE AREA SIZE (HEX BYTES).......................
	NUMBER EUN2CD

	REMARK %UN2 TOTAL CORE REQUIREMENT (HEX BYTES)...............
	NUMBER EUN2


	REMARK %CORE ALLOCATION (HEX BYTES)..........................
	NUMBER UN2A0^8

	:ERROR CHECKS
	IF	EUN2-(UN2A0^8)
	REMARK %ERROR - CORE ALLOCATION TOO SMALL!!%%
ERRCNT	EQ	ERRCNT+1
	EI

	IF	EUN2CR-400*NUN2
	REMARK %%ERROR - CODE SAVE SIZE SPECIFIED IN TYMFILE IS INSUFFICIENT%
	REMARK SAVE SIZE SPECIFIED AS 
	NUMBER NUN2
	REMARK  HEX BLOCKS SHOULD BE AT LEAST 
	NUMBER EUN2CR/400
	REMARK  HEX BLOCKS%%
ERRCNT	EQ	ERRCNT+1
	EI

	IF	400*NUN2-(UN2A0^8)
	REMARK %%WARNING - DEFINED SAVE SIZE IN BLOCKS EXCEEDS CORE ALLOCATION%
	REMARK CODE SAVE SIZE REDUCED FROM 
	NUMBER NUN2
	REMARK  TO 
NUN2	EQ	UN2A0/4
	NUMBER NUN2
	REMARK  HEX BLOCKS%
	EI

	IF	ERRCNT
	REMARK %%************ASSEMBLY CANCELED DUE TO FATAL ERRORS************

	REMARK%            
	NUMBER ERRCNT
	REMARK  FATAL ERRORS
	REMARK %%
	QUIT
	EI

	REMARK %%          **************************
	REMARK %          *MANUAL LOAD INSTRUCTIONS*
	REMARK %          **************************
	REMARK %
	IF	1-ISIS
	REMARK %BUILD A CIRCUIT FROM NAD TO KERNEL DDT, TURN OFF RELOCATION
	REMARK %USE "Q" CMD TO PREVENT LOGINS, "H" COMMAND TO DETERMINE IF UN2 ACTIVE
	REMARK %AND "K" CMD TO KILL EXISTING USERS
	REMARK %LOAD WITH...................RUN2,BUN2,EUN2<COLON>W
	REMARK %SAVE WITH..................<COLON>S DUN2,NUN2,RUN2
	REMARK %USE "Q0" COMMAND TO RE-ENABLE LOGINS
	ELSE
	REMARK %BUILD A CIRCUIT FROM NAD TO UN2 SLOT, THEN USING DDT
	REMARK %HALT SLOT WITH.................................<COLON>H
	REMARK %FIND EXISTING UN2 CIRCUITS WITH.....<COLON><COLON>?PORT
	REMARK %KILL UN2 CIRCUITS WITH........<COLON><COLON>?HANG<PORT>
	REMARK %LOAD WITH.............................BUN2,EUN2<COLON>W
	REMARK %SAVE WITH........................<COLON>SDUN2,NUN2,BUN2
	REMARK %RESTART SLOT WITH..............................<COLON>E%
	EI
	REMARK %


	EM
	LO	UN2
	END
    eGA.